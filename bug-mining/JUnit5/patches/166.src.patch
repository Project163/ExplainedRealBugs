diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc
index c1f988022..486c0762f 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc
@@ -147,7 +147,8 @@ _@API Guardian_ JAR _mandatory_ again.
    example, `fail<Nothing>("Some message")`. These new top-level functions remove this
    requirement by returning
    https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html[`Nothing`].
-
+* New `@EnabledIf` execution condition added. Supply a JavaScript controlling
+  whether the annotated container or test is executed.
 
 [[release-notes-5.1.0-M2-junit-vintage]]
 === JUnit Vintage
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 7e81f31ce..4262d080b 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -164,6 +164,17 @@ And here's a test case with a disabled test method.
 include::{testDir}/example/DisabledTestsDemo.java[tags=user_guide]
 ----
 
+[[writing-tests-conditional]]
+=== Conditional Test Execution
+
+Here are some tests that are enabled or disabled depending
+on the evaluation of the script passed to the `@EnabledIf` annotation.
+
+[source,java,indent=0]
+----
+include::{testDir}/example/EnabledIfTestsDemo.java[tags=user_guide]
+----
+
 [[writing-tests-tagging-and-filtering]]
 === Tagging and Filtering
 
diff --git a/documentation/src/test/java/example/EnabledIfTestsDemo.java b/documentation/src/test/java/example/EnabledIfTestsDemo.java
new file mode 100644
index 000000000..59fa0eb32
--- /dev/null
+++ b/documentation/src/test/java/example/EnabledIfTestsDemo.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import org.junit.jupiter.api.EnabledIf;
+import org.junit.jupiter.api.RepeatedTest;
+import org.junit.jupiter.api.Test;
+
+// tag::user_guide[]
+class EnabledIfTestsDemo {
+
+	@Test // Static JavaScript expression.
+	@EnabledIf("1 == 1")
+	void testWillBeExecuted() {
+		assertTrue(1 == 1);
+	}
+
+	@RepeatedTest(10) // Dynamic JavaScript expression.
+	@EnabledIf("Math.random() >= 0.314159")
+	void testWillNeverOrSometimesBeExecuted() {
+	}
+
+	@Test // Regular expression testing bound system property.
+	@EnabledIf("/64/.test(systemProperty.get('os.arch'))")
+	void testWillBeExecutedIfOsArchitectureContains64() {
+		assertTrue(System.getProperty("os.arch").contains("64"));
+	}
+
+	@Test // Multi-line script, import Java package and set custom reason.
+	// end::user_guide[]
+	// @formatter:off
+	// tag::user_guide[]
+	@EnabledIf(value = {
+					"load('nashorn:mozilla_compat.js')",
+					"importPackage(java.nio.file)",
+					"",
+					"var path = Files.createTempFile('volatile-', '.temp')",
+					"java.lang.System.getProperties().put('volatile', path)",
+					"Files.exists(path)"
+				},
+				reason = "Self-fulfilling: {result}")
+	// end::user_guide[]
+	// @formatter:on
+	// tag::user_guide[]
+	void tautology() {
+		assertTrue(Files.exists((Path) System.getProperties().get("volatile")));
+	}
+}
+// end::user_guide[]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/EnabledIf.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/EnabledIf.java
new file mode 100644
index 000000000..030373647
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/EnabledIf.java
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code @EnabledIf} evaluates a script controlling that the annotated
+ * test class or test method is currently <em>enabled</em> or <em>disabled</em>.
+ *
+ * <p>The decision is made by interpreting the return value of the {@link #value() script}:
+ * <ul>
+ * <li>{@code true} - if and only if the String-representation of the returned
+ * value is parsed by {@link Boolean#parseBoolean(String)} to {@code true}.</li>
+ * <li>{@code ConditionEvaluationResult} - an instance of
+ *  {@link org.junit.jupiter.api.extension.ConditionEvaluationResult ConditionEvaluationResult}
+ *  is passed directly to the Jupiter engine.</li>
+ *  </ul>
+ *
+ * <p>When this annotation with a script that evaluates to {@code false}
+ * is applied at the class level, all test methods within that class
+ * are automatically disabled as well.
+ *
+ * <h3>Script engine</h3>
+ * The default script engine is: Oracle Nashorn.
+ *
+ * The {@link #engine()} property overrides the default script engine name.
+ *
+ * <h3>Bindings</h3>
+ * An {@link Accessor accessor} value provides access to a map-like structure.
+ *
+ * <p>The following System property accessors are available:
+ * <ul>
+ * <li>{@link Bind#SYSTEM_ENVIRONMENT systemEnvironment} - System environment accessor.</li>
+ * <li>{@link Bind#SYSTEM_PROPERTY systemProperty} - System property accessor.</li>
+ * </ul>
+ *
+ * The following Jupiter extension context-aware {@link Bind bindings} are available:
+ * <ul>
+ * <li>{@link Bind#JUPITER_TAGS jupiterTags} - All tags as a {@code Set<String>}.</li>
+ * <li>{@link Bind#JUPITER_DISPLAY_NAME jupiterDisplayName} - Display name as a {@code String}.</li>
+ * <li>{@link Bind#JUPITER_UNIQUE_ID jupiterUniqueId} - Unique ID as a {@code String}.</li>
+ * <li>{@link Bind#JUPITER_CONFIGURATION_PARAMETER jupiterConfigurationParameter} - Configuration parameter accessor.</li>
+ * </ul>
+ *
+ * @since 5.1
+ * @see javax.script.ScriptEngine
+ * @see org.junit.jupiter.api.extension.ExecutionCondition
+ * @see org.junit.jupiter.api.extension.ConditionEvaluationResult#enabled(String)
+ * @see org.junit.jupiter.api.extension.ConditionEvaluationResult#disabled(String)
+ */
+@Target({ ElementType.TYPE, ElementType.METHOD })
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+@API(status = EXPERIMENTAL, since = "5.1")
+public @interface EnabledIf {
+
+	/**
+	 * The lines of the script controlling the <em>enabled</em> or <em>disabled</em> state.
+	 */
+	String[] value();
+
+	/**
+	 * Short name of the {@link javax.script.ScriptEngine ScriptEngine} to use.
+	 *
+	 * <p>Oracle Nashorn is used by default interpreting JavaScript scripts.
+	 *
+	 * <p>Until Java SE 7, JDKs shipped with a JavaScript scripting engine based
+	 * on Mozilla Rhino. Java SE 8 instead ships with the new engine called
+	 * Oracle Nashorn, which is based on JSR 292 and {@code invokedynamic}.
+	 *
+	 * @return script engine name
+	 * @see javax.script.ScriptEngineManager#getEngineByName(String)
+	 * @see <a href="http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html">Oracle Nashorn</a>
+	 */
+	String engine() default "nashorn";
+
+	/**
+	 * The reason this test is <em>enabled</em> or <em>disabled</em>.
+	 *
+	 * <p>Defaults to: {@code "Script `{script}` evaluated to: {result}"}
+	 * <ul>
+	 *     <li>{@code {annotation}} the String-representation of the {@code @EnabledIf} annotation instance</li>
+	 *     <li>{@code {script}} the script text that was evaluated</li>
+	 *     <li>{@code {result}} the String-representation of the result object returned by the script</li>
+	 * </ul>
+	 * @return reason message
+	 * @see org.junit.jupiter.api.extension.ConditionEvaluationResult#getReason()
+	 */
+	String reason() default "Script `{script}` evaluated to: {result}";
+
+	/**
+	 * Used to access named properties without exposing the underlying container (map).
+	 */
+	interface Accessor {
+
+		/**
+		 * Get the value assigned to the specified name.
+		 *
+		 * @param key the name to lookup
+		 * @return the value assigned to the specified name; maybe {@code null}
+		 */
+		String get(String key);
+
+	}
+
+	/**
+	 * Names used for the script {@link javax.script.Bindings bindings}.
+	 */
+	interface Bind {
+
+		/**
+		 * Set of all tags assigned to the current extension context.
+		 *
+		 * <p>Value type: {@code Set<String>}
+		 *
+		 * @see org.junit.jupiter.api.extension.ExtensionContext#getTags()
+		 */
+		String JUPITER_TAGS = "jupiterTags";
+
+		/**
+		 * Unique ID associated with the current extension context.
+		 *
+		 * <p>Value type: {@code String}
+		 *
+		 * @see org.junit.jupiter.api.extension.ExtensionContext#getUniqueId()
+		 */
+		String JUPITER_UNIQUE_ID = "jupiterUniqueId";
+
+		/**
+		 * Display name of the test or container.
+		 *
+		 * <p>Value type: {@code String}
+		 *
+		 * @see org.junit.jupiter.api.extension.ExtensionContext#getDisplayName()
+		 */
+		String JUPITER_DISPLAY_NAME = "jupiterDisplayName";
+
+		/**
+		 * Configuration parameter stored under the specified key.
+		 *
+		 * <p>Usage: {@code jupiterConfigurationParameter.get(key) -> String}
+		 *
+		 * @see org.junit.jupiter.api.extension.ExtensionContext#getConfigurationParameter(String)
+		 */
+		String JUPITER_CONFIGURATION_PARAMETER = "jupiterConfigurationParameter";
+
+		/**
+		 * System property stored under the specified key.
+		 *
+		 * <p>Usage: {@code systemProperty.get(key) -> String}
+		 *
+		 * @see System#getProperty(String)
+		 */
+		String SYSTEM_PROPERTY = "systemProperty";
+
+		/**
+		 * System environment value stored under the specified key.
+		 *
+		 * <p>Usage: {@code systemEnvironment.get(key) -> String}
+		 *
+		 * @see System#getenv(String)
+		 */
+		String SYSTEM_ENVIRONMENT = "systemEnvironment";
+
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/EnabledIfCondition.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/EnabledIfCondition.java
new file mode 100644
index 000000000..e4bbc6e8e
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/EnabledIfCondition.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.junit.jupiter.api.extension.ConditionEvaluationResult.disabled;
+import static org.junit.jupiter.api.extension.ConditionEvaluationResult.enabled;
+import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
+
+import java.util.Arrays;
+import java.util.Optional;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+import javax.script.Bindings;
+import javax.script.ScriptContext;
+import javax.script.ScriptEngine;
+import javax.script.ScriptEngineManager;
+import javax.script.ScriptException;
+
+import org.junit.jupiter.api.EnabledIf;
+import org.junit.jupiter.api.extension.ConditionEvaluationResult;
+import org.junit.jupiter.api.extension.ExecutionCondition;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.Preconditions;
+
+/**
+ * {@link ExecutionCondition} that supports the {@link EnabledIf @EnabledIf} annotation.
+ *
+ * @since 5.1
+ * @see #evaluateExecutionCondition(ExtensionContext)
+ */
+class EnabledIfCondition implements ExecutionCondition {
+
+	/**
+	 * Pre-created {@code ConditionEvaluationResult} singleton that is
+	 * returned when no {@code @EnabledIf} annotation is (meta-)present
+	 * on the current element.
+	 */
+	private static final ConditionEvaluationResult ENABLED_BY_DEFAULT = enabled("@EnabledIf is not present");
+
+	// --- Values used in Bindings --------------------------------------------
+
+	private static final Accessor BIND_SYSTEM_PROPERTY_ACCESSOR = Accessor.of(System::getProperty);
+	private static final Accessor BIND_SYSTEM_ENVIRONMENT_ACCESSOR = Accessor.of(System::getenv);
+
+	// --- Placeholders usable in reason() messages ---------------------------
+
+	private static final String REASON_ANNOTATION_PLACEHOLDER = "{annotation}";
+	private static final String REASON_SCRIPT_PLACEHOLDER = "{script}";
+	private static final String REASON_RESULT_PLACEHOLDER = "{result}";
+
+	private static final Logger logger = LoggerFactory.getLogger(EnabledIfCondition.class);
+
+	@Override
+	public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
+		Optional<EnabledIf> optionalAnnotation = findAnnotation(context.getElement(), EnabledIf.class);
+		if (!optionalAnnotation.isPresent()) {
+			return ENABLED_BY_DEFAULT;
+		}
+
+		// Bind context-aware names to their current values
+		Accessor configurationParameterAccessor = Accessor.of(context::getConfigurationParameter);
+		Consumer<Bindings> contextBinder = bindings -> {
+			bindings.put(EnabledIf.Bind.JUPITER_TAGS, context.getTags());
+			bindings.put(EnabledIf.Bind.JUPITER_UNIQUE_ID, context.getUniqueId());
+			bindings.put(EnabledIf.Bind.JUPITER_DISPLAY_NAME, context.getDisplayName());
+			bindings.put(EnabledIf.Bind.JUPITER_CONFIGURATION_PARAMETER, configurationParameterAccessor);
+		};
+
+		return evaluate(optionalAnnotation.get(), contextBinder);
+	}
+
+	ConditionEvaluationResult evaluate(EnabledIf annotation, Consumer<Bindings> binder) {
+		Preconditions.notNull(annotation, "annotation must not be null");
+		Preconditions.notNull(binder, "binder must not be null");
+		Preconditions.notEmpty(annotation.value(), "String[] returned by @EnabledIf.value() must not be empty");
+
+		// Find script engine
+		ScriptEngine scriptEngine = findScriptEngine(annotation.engine());
+		logger.debug(() -> "ScriptEngine: " + scriptEngine);
+
+		// Prepare bindings
+		Bindings bindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
+		bindings.put(EnabledIf.Bind.SYSTEM_PROPERTY, BIND_SYSTEM_PROPERTY_ACCESSOR);
+		bindings.put(EnabledIf.Bind.SYSTEM_ENVIRONMENT, BIND_SYSTEM_ENVIRONMENT_ACCESSOR);
+		binder.accept(bindings);
+		logger.debug(() -> "Bindings: " + bindings);
+
+		// Build actual script text from annotation properties
+		String script = createScript(annotation, scriptEngine.getFactory().getLanguageName());
+		logger.debug(() -> "Script: " + script);
+
+		return evaluate(annotation, scriptEngine, script);
+	}
+
+	private ConditionEvaluationResult evaluate(EnabledIf annotation, ScriptEngine scriptEngine, String script) {
+		Object result;
+		try {
+			result = scriptEngine.eval(script);
+		}
+		catch (ScriptException e) {
+			String caption = "Evaluation of @EnabledIf script failed.";
+			String bindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE).entrySet().toString();
+			String message = String.format("%s script=`%s`, bindings=%s", caption, script, bindings);
+			throw new JUnitException(message, e);
+		}
+
+		// Trivial case: script returned a custom ConditionEvaluationResult instance.
+		if (result instanceof ConditionEvaluationResult) {
+			return (ConditionEvaluationResult) result;
+		}
+
+		// Parse result for "true" (ignoring case) and prepare reason message.
+		String resultAsString = String.valueOf(result);
+		String reason = createReason(annotation, script, resultAsString);
+		return Boolean.parseBoolean(resultAsString) ? enabled(reason) : disabled(reason);
+	}
+
+	ScriptEngine findScriptEngine(String string) {
+		ScriptEngineManager manager = new ScriptEngineManager();
+		ScriptEngine scriptEngine = manager.getEngineByName(string);
+		if (scriptEngine == null) {
+			scriptEngine = manager.getEngineByExtension(string);
+		}
+		if (scriptEngine == null) {
+			scriptEngine = manager.getEngineByMimeType(string);
+		}
+		Preconditions.notNull(scriptEngine, "Script engine not found: " + string);
+		return scriptEngine;
+	}
+
+	String createScript(EnabledIf annotation, String language) {
+		// trivial case: one liner
+		if (annotation.value().length == 1) {
+			return annotation.value()[0];
+		}
+
+		return joinLines(System.lineSeparator(), Arrays.asList(annotation.value()));
+	}
+
+	String createReason(EnabledIf annotation, String script, String result) {
+		String reason = annotation.reason();
+		reason = reason.replace(REASON_ANNOTATION_PLACEHOLDER, annotation.toString());
+		reason = reason.replace(REASON_SCRIPT_PLACEHOLDER, script);
+		reason = reason.replace(REASON_RESULT_PLACEHOLDER, result);
+		return reason;
+	}
+
+	private String joinLines(String delimiter, Iterable<? extends CharSequence> elements) {
+		if (delimiter.isEmpty()) {
+			delimiter = System.lineSeparator();
+		}
+		return String.join(delimiter, elements);
+	}
+
+	/**
+	 * Provides read-only access to e.g. values of {@link java.util.Map}.
+	 *
+	 * <p>Usage example: {@code Accessor.of(System::getProperty)} is
+	 * analog for {@code System.getProperty(key)} without exposing the
+	 * system properties instance.
+	 */
+	public static class Accessor implements EnabledIf.Accessor {
+
+		static Accessor of(Function<String, Object> accessor) {
+			return new Accessor(accessor);
+		}
+
+		private final Function<String, Object> accessor;
+
+		private Accessor(Function<String, Object> accessor) {
+			this.accessor = accessor;
+		}
+
+		@Override
+		public String get(String key) {
+			Object value = accessor.apply(key);
+			if (value instanceof Optional) {
+				value = ((Optional<?>) value).orElse(null);
+			}
+			return String.valueOf(value);
+		}
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java
index 45ab6db45..230d21093 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java
@@ -52,6 +52,7 @@ public class ExtensionRegistry {
 	private static final Logger logger = LoggerFactory.getLogger(ExtensionRegistry.class);
 
 	private static final List<Extension> DEFAULT_EXTENSIONS = Collections.unmodifiableList(Arrays.asList(//
+		new EnabledIfCondition(), //
 		new DisabledCondition(), //
 		new RepeatedTestExtension(), //
 		new TestInfoParameterResolver(), //
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/EnabledIfConditionTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/EnabledIfConditionTests.java
new file mode 100644
index 000000000..06ff644f2
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/EnabledIfConditionTests.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.junit.jupiter.api.Assertions.assertAll;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertLinesMatch;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import javax.script.Bindings;
+import javax.script.ScriptEngine;
+
+import org.junit.jupiter.api.EnabledIf;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ConditionEvaluationResult;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.PreconditionViolationException;
+
+class EnabledIfConditionTests {
+
+	private EnabledIfCondition condition = new EnabledIfCondition();
+
+	private ConditionEvaluationResult evaluate(EnabledIf annotation) {
+		return condition.evaluate(annotation, this::mockBinder);
+	}
+
+	@Test
+	void findJavaScriptEngine() {
+		assertAll("Names", //
+			() -> findJavaScriptEngine("Nashorn"), //
+			() -> findJavaScriptEngine("nashorn"), //
+			() -> findJavaScriptEngine("javascript"), //
+			() -> findJavaScriptEngine("ecmascript") //
+		);
+
+		assertAll("File extension", //
+			() -> findJavaScriptEngine("js") //
+		);
+
+		assertAll("MIME types", //
+			() -> findJavaScriptEngine("application/javascript"), //
+			() -> findJavaScriptEngine("application/ecmascript"), //
+			() -> findJavaScriptEngine("text/javascript"), //
+			() -> findJavaScriptEngine("text/ecmascript") //
+		);
+
+		assertThrows(PreconditionViolationException.class, () -> findJavaScriptEngine("?!"));
+	}
+
+	private void findJavaScriptEngine(String string) {
+		ScriptEngine engine = condition.findScriptEngine(string);
+		assertNotNull(engine);
+	}
+
+	@Test
+	void trivialJavaScript() {
+		String script = "true";
+		EnabledIf annotation = mockEnabledIfAnnotation(script);
+		String actual = condition.createScript(annotation, "ECMAScript");
+		assertSame(script, actual);
+	}
+
+	@Test
+	void trivialGroovyScript() {
+		String script = "true";
+		EnabledIf annotation = mockEnabledIfAnnotation(script);
+		String actual = condition.createScript(annotation, "Groovy");
+		assertSame(script, actual);
+	}
+
+	@Test
+	void trivialNonJavaScript() {
+		EnabledIf annotation = mockEnabledIfAnnotation("one", "two");
+		assertLinesMatchCreatedScript(Arrays.asList("one", "two"), annotation, "unknown language");
+	}
+
+	@Test
+	void createJavaScriptMultipleLines() {
+		EnabledIf annotation = mockEnabledIfAnnotation("m1()", "m2()");
+		assertLinesMatchCreatedScript(Arrays.asList("m1()", "m2()"), annotation, "ECMAScript");
+	}
+
+	@Test
+	void createReasonWithDefaultMessage() {
+		EnabledIf annotation = mockEnabledIfAnnotation("?");
+		String actual = condition.createReason(annotation, "?", "!");
+		assertEquals("Script `?` evaluated to: !", actual);
+	}
+
+	@Test
+	void createReasonWithCustomMessage() {
+		EnabledIf annotation = mockEnabledIfAnnotation("?");
+		when(annotation.reason()).thenReturn("result={result} script={script}");
+		String actual = condition.createReason(annotation, "?", "!");
+		assertEquals("result=! script=?", actual);
+	}
+
+	@Test
+	void syntaxErrorInScriptFailsTest() {
+		EnabledIf annotation = mockEnabledIfAnnotation("syntax error");
+		Exception exception = assertThrows(JUnitException.class, () -> evaluate(annotation));
+		assertTrue(exception.getMessage().contains("@EnabledIf"));
+		assertTrue(exception.getMessage().contains("script"));
+		assertTrue(exception.getMessage().contains("bindings"));
+	}
+
+	@Test
+	@EnabledIf(value = "true", reason = "{annotation}")
+	void createReasonWithAnnotationPlaceholder() throws Exception {
+		EnabledIf annotation = getClass() //
+				.getDeclaredMethod("createReasonWithAnnotationPlaceholder") //
+				.getDeclaredAnnotation(EnabledIf.class);
+		ConditionEvaluationResult result = evaluate(annotation);
+		assertFalse(result.isDisabled());
+		String expected = "@org.junit.jupiter.api.EnabledIf(reason=\"{annotation}\", engine=\"nashorn\", value={\"true\"})";
+		String actual = result.getReason().orElseThrow(() -> new AssertionError("causeless"));
+		assertEquals(expected, actual);
+	}
+
+	private void assertLinesMatchCreatedScript(List<String> expectedLines, EnabledIf annotation, String language) {
+		EnabledIfCondition condition = new EnabledIfCondition();
+		String actual = condition.createScript(annotation, language);
+		assertLinesMatch(expectedLines, Arrays.asList(actual.split("\\R")));
+	}
+
+	private void mockBinder(Bindings bindings) {
+		bindings.put("jupiterTags", Collections.emptySet());
+		bindings.put("jupiterUniqueId", "Mock for UniqueId");
+		bindings.put("jupiterDisplayName", "Mock for DisplayName");
+		bindings.put("jupiterConfigurationParameter", Collections.emptyMap());
+	}
+
+	private EnabledIf mockEnabledIfAnnotation(String... value) {
+		EnabledIf annotation = mock(EnabledIf.class);
+		when(annotation.value()).thenReturn(value);
+		try {
+			when(annotation.engine()).thenReturn(
+				(String) EnabledIf.class.getDeclaredMethod("engine").getDefaultValue());
+			when(annotation.reason()).thenReturn(
+				(String) EnabledIf.class.getDeclaredMethod("reason").getDefaultValue());
+		}
+		catch (NoSuchMethodException e) {
+			throw new AssertionError(e);
+		}
+		return annotation;
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java
index 035565d25..ec25eec5b 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java
@@ -49,7 +49,7 @@ class ExtensionRegistryTests {
 	void newRegistryWithoutParentHasDefaultExtensions() {
 		List<Extension> extensions = registry.getExtensions(Extension.class);
 
-		assertEquals(4, extensions.size());
+		assertEquals(5, extensions.size());
 		assertDefaultGlobalExtensionsAreRegistered();
 	}
 
@@ -62,7 +62,7 @@ class ExtensionRegistryTests {
 
 		List<Extension> extensions = registry.getExtensions(Extension.class);
 
-		assertEquals(5, extensions.size());
+		assertEquals(6, extensions.size());
 		assertDefaultGlobalExtensionsAreRegistered();
 
 		assertExtensionRegistered(registry, ServiceLoaderExtension.class);
@@ -155,13 +155,14 @@ class ExtensionRegistryTests {
 	}
 
 	private void assertDefaultGlobalExtensionsAreRegistered() {
+		assertExtensionRegistered(registry, EnabledIfCondition.class);
 		assertExtensionRegistered(registry, DisabledCondition.class);
 		assertExtensionRegistered(registry, RepeatedTestExtension.class);
 		assertExtensionRegistered(registry, TestInfoParameterResolver.class);
 		assertExtensionRegistered(registry, TestReporterParameterResolver.class);
 
 		assertEquals(2, countExtensions(registry, ParameterResolver.class));
-		assertEquals(1, countExtensions(registry, ExecutionCondition.class));
+		assertEquals(2, countExtensions(registry, ExecutionCondition.class));
 		assertEquals(1, countExtensions(registry, TestTemplateInvocationContextProvider.class));
 	}
 
diff --git a/platform-tests/src/test/java/org/junit/jupiter/extensions/EnabledIfTests.java b/platform-tests/src/test/java/org/junit/jupiter/extensions/EnabledIfTests.java
new file mode 100644
index 000000000..6ed45dcf0
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/jupiter/extensions/EnabledIfTests.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.extensions;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.EnabledIf;
+import org.junit.jupiter.api.RepeatedTest;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Script-based execution condition evaluation tests.
+ *
+ * @since 1.1
+ */
+@EnabledIf("true")
+class EnabledIfTests {
+
+	@Test
+	@EnabledIf("true")
+	void justTrue() {
+	}
+
+	@Test
+	@EnabledIf("false")
+	void justFalse() {
+		fail("test must not be executed");
+	}
+
+	@Test
+	@EnabledIf("1 == 2")
+	void oneEqualsTwo() {
+		fail("test must not be executed");
+	}
+
+	@Test
+	@EnabledIf("org.junit.jupiter.api.extension.ConditionEvaluationResult.enabled('Go!')")
+	void customResultEnabled() {
+	}
+
+	@Test
+	@EnabledIf("org.junit.jupiter.api.extension.ConditionEvaluationResult.disabled('No go.')")
+	void customResultDisabled() {
+		fail("test must not be executed");
+	}
+
+	@Test
+	@EnabledIf("java.lang.Boolean.getBoolean('is-not-set')")
+	void getBoolean() {
+		fail("test must not be executed");
+	}
+
+	@Test
+	@EnabledIf(value = { //
+			"load('nashorn:mozilla_compat.js')", //
+			"importPackage(java.nio.file)", //
+			"", //
+			"var path = Files.createTempFile('volatile-', '.temp')", //
+			"java.lang.System.getProperties().put('volatile', path)", //
+			"Files.exists(path)" //
+	})
+	void multiLineAndImportJavaPackage() {
+		assertTrue(Files.exists((Path) System.getProperties().get("volatile")));
+	}
+
+	@Test
+	@EnabledIf(value = "jupiterConfigurationParameter.get('some.value.or.null')")
+	void getJupiterConfigurationParameter() {
+		fail("test must not be executed");
+	}
+
+	@Test
+	@EnabledIf("java.lang.System.getProperty('os.name').toLowerCase().contains('win')")
+	void win() {
+		assertTrue(System.getProperty("os.name").toLowerCase().contains("win"));
+	}
+
+	@Test
+	@EnabledIf("/64/.test(systemProperty.get('os.arch'))")
+	void osArch() {
+		assertTrue(System.getProperty("os.arch").contains("64"));
+	}
+
+	@Test
+	@EnabledIf(engine = "groovy", value = { "System.properties['jsr'] = '233'", "'233' == System.properties['jsr']" })
+	void groovy() {
+		assertEquals("233", System.getProperty("jsr"));
+	}
+
+	@Test
+	@EnabledIf("true")
+	@Disabled
+	void enabledAndDisabled() {
+		fail("test must not be executed");
+	}
+
+	@Test
+	@Disabled
+	@EnabledIf("true")
+	void disabledAndEnabled() {
+		fail("test must not be executed");
+	}
+
+	@RepeatedTest(10)
+	@CoinToss
+	void gamble() {
+	}
+
+	@Target({ ElementType.TYPE, ElementType.METHOD })
+	@Retention(RetentionPolicy.RUNTIME)
+	@EnabledIf("Math.random() >= 0.5")
+	@interface CoinToss {
+	}
+}
