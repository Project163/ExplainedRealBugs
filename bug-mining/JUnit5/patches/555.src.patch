diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
index 73c6cf3ed..39b36c843 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
@@ -19,7 +19,8 @@ JUnit repository on GitHub.
 
 ==== Deprecations and Breaking Changes
 
-* ‚ùì
+* The `getMethodParameterTypes()` methods in `MethodSelector` and `NestedMethodSelector`
+  have been deprecated and replaced by `getParameterTypeNames()` for greater clarity.
 
 ==== New Features and Improvements
 
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
index f02062082..2774eb424 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
@@ -511,50 +511,50 @@ public final class DiscoverySelectors {
 
 	/**
 	 * Create a {@code MethodSelector} for the supplied class name, method name,
-	 * and method parameter types.
+	 * and parameter type names.
 	 *
-	 * <p>The parameter types {@code String} is typically a comma-separated list
-	 * of atomic types, fully qualified class names, or array types; however,
+	 * <p>The parameter type names {@code String} is typically a comma-separated
+	 * list of atomic types, fully qualified class names, or array types; however,
 	 * the exact syntax depends on the underlying test engine.
 	 *
 	 * @param className the fully qualified name of the class in which the method
 	 * is declared, or a subclass thereof; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param methodParameterTypes the method parameter types as a single string; never
-	 * {@code null} though potentially an empty string if the method does not accept
-	 * arguments
+	 * @param parameterTypeNames the parameter type names as a single string; never
+	 * {@code null} though potentially an empty string if the method does not declare
+	 * parameters
 	 * @see MethodSelector
 	 */
-	public static MethodSelector selectMethod(String className, String methodName, String methodParameterTypes) {
-		return selectMethod(className, methodName, methodParameterTypes, null);
+	public static MethodSelector selectMethod(String className, String methodName, String parameterTypeNames) {
+		return selectMethod(className, methodName, parameterTypeNames, (ClassLoader) null);
 	}
 
 	/**
 	 * Create a {@code MethodSelector} for the supplied class name, method name,
-	 * method parameter types, and class loader.
+	 * parameter type names, and class loader.
 	 *
-	 * <p>The parameter types {@code String} is typically a comma-separated list
-	 * of atomic types, fully qualified class names, or array types; however,
+	 * <p>The parameter type names {@code String} is typically a comma-separated
+	 * list of atomic types, fully qualified class names, or array types; however,
 	 * the exact syntax depends on the underlying test engine.
 	 *
 	 * @param className the fully qualified name of the class in which the method
 	 * is declared, or a subclass thereof; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param methodParameterTypes the method parameter types as a single string; never
-	 * {@code null} though potentially an empty string if the method does not accept
-	 * arguments
+	 * @param parameterTypeNames the parameter type names as a single string; never
+	 * {@code null} though potentially an empty string if the method does not declare
+	 * any parameters
 	 * @param classLoader the class loader to use to load the class, or {@code null}
 	 * to signal that the default {@code ClassLoader} should be used
 	 * @since 1.10
 	 * @see MethodSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static MethodSelector selectMethod(String className, String methodName, String methodParameterTypes,
+	public static MethodSelector selectMethod(String className, String methodName, String parameterTypeNames,
 			ClassLoader classLoader) {
 		Preconditions.notBlank(className, "Class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		Preconditions.notNull(methodParameterTypes, "Parameter types must not be null");
-		return new MethodSelector(className, methodName, methodParameterTypes.trim(), classLoader);
+		Preconditions.notNull(parameterTypeNames, "Parameter type names must not be null");
+		return new MethodSelector(className, methodName, parameterTypeNames.trim(), classLoader);
 	}
 
 	/**
@@ -571,25 +571,25 @@ public final class DiscoverySelectors {
 
 	/**
 	 * Create a {@code MethodSelector} for the supplied {@link Class}, method name,
-	 * and method parameter types.
+	 * and parameter type names.
 	 *
-	 * <p>The parameter types {@code String} is typically a comma-separated list
-	 * of atomic types, fully qualified class names, or array types; however,
+	 * <p>The parameter type names {@code String} is typically a comma-separated
+	 * list of atomic types, fully qualified class names, or array types; however,
 	 * the exact syntax depends on the underlying test engine.
 	 *
 	 * @param javaClass the class in which the method is declared, or a subclass thereof;
 	 * never {@code null}
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param methodParameterTypes the method parameter types as a single string; never
-	 * {@code null} though potentially an empty string if the method does not accept
-	 * arguments
+	 * @param parameterTypeNames the parameter type names as a single string; never
+	 * {@code null} though potentially an empty string if the method does not declare
+	 * any parameters
 	 * @see MethodSelector
 	 */
-	public static MethodSelector selectMethod(Class<?> javaClass, String methodName, String methodParameterTypes) {
+	public static MethodSelector selectMethod(Class<?> javaClass, String methodName, String parameterTypeNames) {
 		Preconditions.notNull(javaClass, "Class must not be null");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		Preconditions.notNull(methodParameterTypes, "Parameter types must not be null");
-		return new MethodSelector(javaClass, methodName, methodParameterTypes.trim());
+		Preconditions.notNull(parameterTypeNames, "Parameter type names must not be null");
+		return new MethodSelector(javaClass, methodName, parameterTypeNames.trim());
 	}
 
 	/**
@@ -694,37 +694,37 @@ public final class DiscoverySelectors {
 
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied nested class name, method name,
-	 * and method parameter types.
+	 * and parameter type names.
 	 *
-	 * <p>The parameter types {@code String} is typically a comma-separated list
-	 * of atomic types, fully qualified class names, or array types; however,
+	 * <p>The parameter type names {@code String} is typically a comma-separated
+	 * list of atomic types, fully qualified class names, or array types; however,
 	 * the exact syntax depends on the underlying test engine.
 	 *
 	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
 	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param methodParameterTypes the method parameter types as a single string; never
-	 * {@code null} though potentially an empty string if the method does not accept
-	 * arguments
+	 * @param parameterTypeNames the parameter type names as a single string; never
+	 * {@code null} though potentially an empty string if the method does not declare
+	 * parameters
 	 * @since 1.6
 	 * @see NestedMethodSelector
 	 */
 	@API(status = STABLE, since = "1.6")
 	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
-			String methodName, String methodParameterTypes) {
-		return selectNestedMethod(enclosingClassNames, nestedClassName, methodName, methodParameterTypes, null);
+			String methodName, String parameterTypeNames) {
+		return selectNestedMethod(enclosingClassNames, nestedClassName, methodName, parameterTypeNames, null);
 	}
 
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied nested class name, method name,
-	 * method parameter types, and class loader.
+	 * parameter type names, and class loader.
 	 *
 	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
 	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param methodParameterTypes the method parameter types as a single string; never
-	 * {@code null} though potentially an empty string if the method does not accept
-	 * arguments
+	 * @param parameterTypeNames the parameter type names as a single string; never
+	 * {@code null} though potentially an empty string if the method does not declare
+	 * parameters
 	 * @param classLoader the class loader to use to load the method's declaring
 	 * class, or {@code null} to signal that the default {@code ClassLoader}
 	 * should be used
@@ -733,13 +733,13 @@ public final class DiscoverySelectors {
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
 	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
-			String methodName, String methodParameterTypes, ClassLoader classLoader) {
+			String methodName, String parameterTypeNames, ClassLoader classLoader) {
 
 		Preconditions.notEmpty(enclosingClassNames, "Enclosing class names must not be null or empty");
 		Preconditions.notBlank(nestedClassName, "Nested class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		Preconditions.notNull(methodParameterTypes, "Parameter types must not be null");
-		return new NestedMethodSelector(enclosingClassNames, nestedClassName, methodName, methodParameterTypes,
+		Preconditions.notNull(parameterTypeNames, "Parameter types must not be null");
+		return new NestedMethodSelector(enclosingClassNames, nestedClassName, methodName, parameterTypeNames,
 			classLoader);
 	}
 
@@ -764,30 +764,30 @@ public final class DiscoverySelectors {
 
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied {@link Class}, method name,
-	 * and method parameter types.
+	 * and parameter type names.
 	 *
-	 * <p>The parameter types {@code String} is typically a comma-separated list
-	 * of atomic types, fully qualified class names, or array types; however,
+	 * <p>The parameter type names {@code String} is typically a comma-separated
+	 * list of atomic types, fully qualified class names, or array types; however,
 	 * the exact syntax depends on the underlying test engine.
 	 *
 	 * @param enclosingClasses the path to the nested class to select; never {@code null} or empty
 	 * @param nestedClass the nested class to select; never {@code null}
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param methodParameterTypes the method parameter types as a single string; never
-	 * {@code null} though potentially an empty string if the method does not accept
-	 * arguments
+	 * @param parameterTypeNames the parameter type names as a single string; never
+	 * {@code null} though potentially an empty string if the method does not declare
+	 * parameters
 	 * @since 1.6
 	 * @see NestedMethodSelector
 	 */
 	@API(status = STABLE, since = "1.6")
 	public static NestedMethodSelector selectNestedMethod(List<Class<?>> enclosingClasses, Class<?> nestedClass,
-			String methodName, String methodParameterTypes) {
+			String methodName, String parameterTypeNames) {
 
 		Preconditions.notEmpty(enclosingClasses, "Enclosing classes must not be null or empty");
 		Preconditions.notNull(nestedClass, "Nested class must not be null");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		Preconditions.notNull(methodParameterTypes, "Parameter types must not be null");
-		return new NestedMethodSelector(enclosingClasses, nestedClass, methodName, methodParameterTypes);
+		Preconditions.notNull(parameterTypeNames, "Parameter types must not be null");
+		return new NestedMethodSelector(enclosingClasses, nestedClass, methodName, parameterTypeNames);
 	}
 
 	/**
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
index 43b6716c6..58bd420bf 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
@@ -10,6 +10,7 @@
 
 package org.junit.platform.engine.discovery;
 
+import static org.apiguardian.api.API.Status.DEPRECATED;
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
@@ -58,32 +59,27 @@ public class MethodSelector implements DiscoverySelector {
 	private final ClassLoader classLoader;
 	private final String className;
 	private final String methodName;
-	private final String methodParameterTypes;
+	private final String parameterTypeNames;
 
-	private Class<?> javaClass;
-	private Method javaMethod;
+	private volatile Class<?> javaClass;
+	private volatile Method javaMethod;
 
-	MethodSelector(String className, String methodName, ClassLoader classLoader) {
-		this(className, methodName, "", classLoader);
-	}
-
-	MethodSelector(String className, String methodName, String methodParameterTypes, ClassLoader classLoader) {
+	/**
+	 * @since 1.10
+	 */
+	MethodSelector(String className, String methodName, String parameterTypeNames, ClassLoader classLoader) {
 		this.classLoader = classLoader;
 		this.className = className;
 		this.methodName = methodName;
-		this.methodParameterTypes = methodParameterTypes;
-	}
-
-	MethodSelector(Class<?> javaClass, String methodName) {
-		this(javaClass, methodName, "");
+		this.parameterTypeNames = parameterTypeNames;
 	}
 
-	MethodSelector(Class<?> javaClass, String methodName, String methodParameterTypes) {
+	MethodSelector(Class<?> javaClass, String methodName, String parameterTypeNames) {
 		this.classLoader = javaClass.getClassLoader();
 		this.javaClass = javaClass;
 		this.className = javaClass.getName();
 		this.methodName = methodName;
-		this.methodParameterTypes = methodParameterTypes;
+		this.parameterTypeNames = parameterTypeNames;
 	}
 
 	MethodSelector(Class<?> javaClass, Method method) {
@@ -92,18 +88,12 @@ public class MethodSelector implements DiscoverySelector {
 		this.className = javaClass.getName();
 		this.javaMethod = method;
 		this.methodName = method.getName();
-		this.methodParameterTypes = ClassUtils.nullSafeToString(method.getParameterTypes());
-	}
-
-	/**
-	 * Get the selected class name.
-	 */
-	public String getClassName() {
-		return this.className;
+		this.parameterTypeNames = ClassUtils.nullSafeToString(method.getParameterTypes());
 	}
 
 	/**
 	 * Get the {@link ClassLoader} used to load the specified class.
+	 * @return the {@code ClassLoader}; potentially {@code null}
 	 * @since 1.10
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
@@ -111,6 +101,13 @@ public class MethodSelector implements DiscoverySelector {
 		return this.classLoader;
 	}
 
+	/**
+	 * Get the selected class name.
+	 */
+	public String getClassName() {
+		return this.className;
+	}
+
 	/**
 	 * Get the selected method name.
 	 */
@@ -119,21 +116,41 @@ public class MethodSelector implements DiscoverySelector {
 	}
 
 	/**
-	 * Get the parameter types for the selected method as a {@link String},
-	 * typically a comma-separated list of primitive types, fully qualified
-	 * class names, or array types.
+	 * Get the names of parameter types for the selected method.
+	 *
+	 * <p>See {@link #getParameterTypeNames()} for details.
+	 *
+	 * @return the names of parameter types supplied to this {@code MethodSelector}
+	 * via a constructor or deduced from a {@code Method} or parameter types supplied
+	 * via a constructor; never {@code null} but potentially an empty string
+	 * @since 1.0
+	 * @see #getParameterTypes()
+	 * @deprecated since 1.10 in favor of {@link #getParameterTypeNames()}
+	 */
+	@Deprecated
+	@API(status = DEPRECATED, since = "1.10")
+	public String getMethodParameterTypes() {
+		return getParameterTypeNames();
+	}
+
+	/**
+	 * Get the names of parameter types for the selected method as a {@link String},
+	 * typically a comma-separated list of primitive types, fully qualified class
+	 * names, or array types.
 	 *
-	 * <p>Note: the parameter types are provided as a single string instead of
-	 * a collection in order to allow this selector to be used in a generic
+	 * <p>Note: the names of parameter types are provided as a single string instead
+	 * of a collection in order to allow this selector to be used in a generic
 	 * fashion by various test engines. It is therefore the responsibility of
 	 * the caller of this method to determine how to parse the returned string.
 	 *
-	 * @return the parameter types supplied to this {@code MethodSelector} via
-	 * a constructor or deduced from a {@code Method} supplied via a constructor;
-	 * never {@code null}
+	 * @return the names of parameter types supplied to this {@code MethodSelector}
+	 * via a constructor or deduced from a {@code Method} supplied via a constructor;
+	 * never {@code null} but potentially an empty string
+	 * @since 1.10
 	 */
-	public String getMethodParameterTypes() {
-		return this.methodParameterTypes;
+	@API(status = STABLE, since = "1.10")
+	public String getParameterTypeNames() {
+		return this.parameterTypeNames;
 	}
 
 	/**
@@ -178,15 +195,14 @@ public class MethodSelector implements DiscoverySelector {
 	}
 
 	private void lazyLoadJavaMethod() {
-		lazyLoadJavaClass();
-
 		if (this.javaMethod == null) {
-			if (StringUtils.isNotBlank(this.methodParameterTypes)) {
+			lazyLoadJavaClass();
+			if (StringUtils.isNotBlank(this.parameterTypeNames)) {
 				this.javaMethod = ReflectionUtils.findMethod(this.javaClass, this.methodName,
-					this.methodParameterTypes).orElseThrow(
+					this.parameterTypeNames).orElseThrow(
 						() -> new PreconditionViolationException(String.format(
 							"Could not find method with name [%s] and parameter types [%s] in class [%s].",
-							this.methodName, this.methodParameterTypes, this.javaClass.getName())));
+							this.methodName, this.parameterTypeNames, this.javaClass.getName())));
 			}
 			else {
 				this.javaMethod = ReflectionUtils.findMethod(this.javaClass, this.methodName).orElseThrow(
@@ -212,7 +228,7 @@ public class MethodSelector implements DiscoverySelector {
 		MethodSelector that = (MethodSelector) o;
 		return Objects.equals(this.className, that.className)//
 				&& Objects.equals(this.methodName, that.methodName)//
-				&& Objects.equals(this.methodParameterTypes, that.methodParameterTypes);
+				&& Objects.equals(this.parameterTypeNames, that.parameterTypeNames);
 	}
 
 	/**
@@ -221,7 +237,7 @@ public class MethodSelector implements DiscoverySelector {
 	@API(status = STABLE, since = "1.3")
 	@Override
 	public int hashCode() {
-		return Objects.hash(this.className, this.methodName, this.methodParameterTypes);
+		return Objects.hash(this.className, this.methodName, this.parameterTypeNames);
 	}
 
 	@Override
@@ -230,7 +246,7 @@ public class MethodSelector implements DiscoverySelector {
 		return new ToStringBuilder(this)
 				.append("className", getClassName())
 				.append("methodName", getMethodName())
-				.append("methodParameterTypes", getMethodParameterTypes())
+				.append("parameterTypes", getParameterTypeNames())
 				.append("classLoader", getClassLoader())
 				.toString();
 		// @formatter:on
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
index bb2ca9dc2..aeb6f28fa 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
@@ -10,6 +10,7 @@
 
 package org.junit.platform.engine.discovery;
 
+import static org.apiguardian.api.API.Status.DEPRECATED;
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
@@ -57,14 +58,9 @@ public class NestedMethodSelector implements DiscoverySelector {
 	private final MethodSelector methodSelector;
 
 	NestedMethodSelector(List<String> enclosingClassNames, String nestedClassName, String methodName,
-			ClassLoader classLoader) {
-		this(enclosingClassNames, nestedClassName, methodName, "", classLoader);
-	}
-
-	NestedMethodSelector(List<String> enclosingClassNames, String nestedClassName, String methodName,
-			String methodParameterTypes, ClassLoader classLoader) {
+			String parameterTypeNames, ClassLoader classLoader) {
 		this.nestedClassSelector = new NestedClassSelector(enclosingClassNames, nestedClassName, classLoader);
-		this.methodSelector = new MethodSelector(nestedClassName, methodName, methodParameterTypes, classLoader);
+		this.methodSelector = new MethodSelector(nestedClassName, methodName, parameterTypeNames, classLoader);
 	}
 
 	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, String methodName) {
@@ -72,9 +68,9 @@ public class NestedMethodSelector implements DiscoverySelector {
 	}
 
 	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, String methodName,
-			String methodParameterTypes) {
+			String parameterTypeNames) {
 		this.nestedClassSelector = new NestedClassSelector(enclosingClasses, nestedClass);
-		this.methodSelector = new MethodSelector(nestedClass, methodName, methodParameterTypes);
+		this.methodSelector = new MethodSelector(nestedClass, methodName, parameterTypeNames);
 	}
 
 	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, Method method) {
@@ -151,21 +147,40 @@ public class NestedMethodSelector implements DiscoverySelector {
 	}
 
 	/**
-	 * Get the parameter types for the selected method as a {@link String},
+	 * Get the names of parameter types for the selected method.
+	 *
+	 * <p>See {@link #getParameterTypeNames()} for details.
+	 *
+	 * @return the names of parameter types supplied to this {@code NestedMethodSelector}
+	 * via a constructor or deduced from a {@code Method} supplied via a constructor;
+	 * never {@code null} but potentially an empty string
+	 * @since 1.6
+	 * @deprecated since 1.10 in favor or {@link #getParameterTypeNames()}
+	 */
+	@Deprecated
+	@API(status = DEPRECATED, since = "1.10")
+	public String getMethodParameterTypes() {
+		return getParameterTypeNames();
+	}
+
+	/**
+	 * Get the names of parameter types for the selected method as a {@link String},
 	 * typically a comma-separated list of primitive types, fully qualified
 	 * class names, or array types.
 	 *
-	 * <p>Note: the parameter types are provided as a single string instead of
-	 * a collection in order to allow this selector to be used in a generic
+	 * <p>Note: the names of parameter types are provided as a single string instead
+	 * of a collection in order to allow this selector to be used in a generic
 	 * fashion by various test engines. It is therefore the responsibility of
 	 * the caller of this method to determine how to parse the returned string.
 	 *
-	 * @return the parameter types supplied to this {@code NestedMethodSelector}
-	 * via a constructor or deduced from a {@code Method} supplied via a
-	 * constructor; never {@code null}
+	 * @return the names of parameter types supplied to this {@code NestedMethodSelector}
+	 * via a constructor or deduced from a {@code Method} supplied via a constructor;
+	 * never {@code null} but potentially an empty string
+	 * @since 1.10
 	 */
-	public String getMethodParameterTypes() {
-		return this.methodSelector.getMethodParameterTypes();
+	@API(status = STABLE, since = "1.10")
+	public String getParameterTypeNames() {
+		return this.methodSelector.getParameterTypeNames();
 	}
 
 	@Override
@@ -192,7 +207,7 @@ public class NestedMethodSelector implements DiscoverySelector {
 				.append("enclosingClassNames", getEnclosingClassNames()) //
 				.append("nestedClassName", getNestedClassName()) //
 				.append("methodName", getMethodName()) //
-				.append("methodParameterTypes", getMethodParameterTypes()) //
+				.append("parameterTypes", getParameterTypeNames()) //
 				.append("classLoader", getClassLoader()) //
 				.toString();
 	}
diff --git a/platform-tests/src/test/java/org/junit/platform/console/tasks/DiscoveryRequestCreatorTests.java b/platform-tests/src/test/java/org/junit/platform/console/tasks/DiscoveryRequestCreatorTests.java
index 733d35f7f..87b35ef20 100644
--- a/platform-tests/src/test/java/org/junit/platform/console/tasks/DiscoveryRequestCreatorTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/console/tasks/DiscoveryRequestCreatorTests.java
@@ -269,10 +269,10 @@ class DiscoveryRequestCreatorTests {
 		assertThat(methodSelectors).hasSize(2);
 		assertThat(methodSelectors.get(0).getClassName()).isEqualTo("com.acme.Foo");
 		assertThat(methodSelectors.get(0).getMethodName()).isEqualTo("m");
-		assertThat(methodSelectors.get(0).getMethodParameterTypes()).isEmpty();
+		assertThat(methodSelectors.get(0).getParameterTypeNames()).isEmpty();
 		assertThat(methodSelectors.get(1).getClassName()).isEqualTo("com.example.Bar");
 		assertThat(methodSelectors.get(1).getMethodName()).isEqualTo("method");
-		assertThat(methodSelectors.get(1).getMethodParameterTypes()).isEqualTo("java.lang.Object");
+		assertThat(methodSelectors.get(1).getParameterTypeNames()).isEqualTo("java.lang.Object");
 	}
 
 	@Test
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
index a4b1f0f3c..205e16d7c 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
@@ -424,7 +424,7 @@ class DiscoverySelectorsTests {
 				assertThat(selector.getJavaClass()).isEqualTo(clazz);
 				assertThat(selector.getClassName()).isEqualTo(clazz.getName());
 				assertThat(selector.getMethodName()).isEqualTo(method.getName());
-				assertThat(selector.getMethodParameterTypes()).isEmpty();
+				assertThat(selector.getParameterTypeNames()).isEmpty();
 			}
 		}
 
@@ -552,7 +552,7 @@ class DiscoverySelectorsTests {
 			var selector = selectMethod(fqmn);
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		/**
@@ -567,7 +567,7 @@ class DiscoverySelectorsTests {
 			var selector = selectMethod(fqmn);
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		/**
@@ -583,7 +583,7 @@ class DiscoverySelectorsTests {
 			var selector = selectMethod(fqmn);
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals(methodParameters, selector.getMethodParameterTypes());
+			assertEquals(methodParameters, selector.getParameterTypeNames());
 		}
 
 		/**
@@ -599,7 +599,7 @@ class DiscoverySelectorsTests {
 
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		/**
@@ -615,7 +615,7 @@ class DiscoverySelectorsTests {
 
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		/**
@@ -632,7 +632,7 @@ class DiscoverySelectorsTests {
 
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals(methodParameters, selector.getMethodParameterTypes());
+			assertEquals(methodParameters, selector.getParameterTypeNames());
 		}
 
 		private void assertSelectMethodByFullyQualifiedName(Class<?> clazz, Method method) {
@@ -641,7 +641,7 @@ class DiscoverySelectorsTests {
 			assertEquals(clazz, selector.getJavaClass());
 			assertEquals(clazz.getName(), selector.getClassName());
 			assertEquals(method.getName(), selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		private void assertSelectMethodByFullyQualifiedName(Class<?> clazz, Method method, Class<?> parameterType,
@@ -652,7 +652,7 @@ class DiscoverySelectorsTests {
 			assertEquals(clazz, selector.getJavaClass());
 			assertEquals(clazz.getName(), selector.getClassName());
 			assertEquals(method.getName(), selector.getMethodName());
-			assertEquals(expectedParameterTypes, selector.getMethodParameterTypes());
+			assertEquals(expectedParameterTypes, selector.getParameterTypeNames());
 		}
 
 		private void assertSelectMethodByFullyQualifiedName(Class<?> clazz, Method method, String parameterName,
@@ -663,7 +663,7 @@ class DiscoverySelectorsTests {
 			assertEquals(clazz, selector.getJavaClass());
 			assertEquals(clazz.getName(), selector.getClassName());
 			assertEquals(method.getName(), selector.getMethodName());
-			assertEquals(expectedParameterTypes, selector.getMethodParameterTypes());
+			assertEquals(expectedParameterTypes, selector.getParameterTypeNames());
 		}
 
 		@Test
@@ -675,7 +675,7 @@ class DiscoverySelectorsTests {
 			assertEquals(testClass().getName(), selector.getClassName());
 			assertEquals(method, selector.getJavaMethod());
 			assertEquals("myTest", selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		@Test
@@ -689,7 +689,7 @@ class DiscoverySelectorsTests {
 			assertThat(selector.getJavaClass()).isEqualTo(testClass);
 			assertThat(selector.getMethodName()).isEqualTo("myTest");
 			assertThat(selector.getJavaMethod()).isEqualTo(method);
-			assertThat(selector.getMethodParameterTypes()).isEqualTo("java.lang.String, boolean[]");
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, boolean[]");
 		}
 
 		@Test
@@ -703,7 +703,7 @@ class DiscoverySelectorsTests {
 			assertThat(selector.getJavaClass()).isEqualTo(testClass);
 			assertThat(selector.getMethodName()).isEqualTo("myTest");
 			assertThat(selector.getJavaMethod()).isEqualTo(method);
-			assertThat(selector.getMethodParameterTypes()).isEqualTo("java.lang.String, [Z");
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, [Z");
 		}
 
 		@Test
@@ -721,7 +721,7 @@ class DiscoverySelectorsTests {
 			var selector = selectMethod(className, methodName);
 			assertEquals(className, selector.getClassName());
 			assertEquals(methodName, selector.getMethodName());
-			assertEquals("", selector.getMethodParameterTypes());
+			assertEquals("", selector.getParameterTypeNames());
 		}
 
 		private static Class<?> testClass() {
@@ -876,7 +876,7 @@ class DiscoverySelectorsTests {
 				assertThat(selector.getNestedClass().getClassLoader()).isSameAs(testClassLoader);
 
 				assertThat(selector.getMethodName()).isEqualTo(methodName);
-				assertThat(selector.getMethodParameterTypes()).isEqualTo(String.class.getName());
+				assertThat(selector.getParameterTypeNames()).isEqualTo(String.class.getName());
 			}
 		}
 
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
index 1a128b23f..6d67ecf1c 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
@@ -11,10 +11,13 @@
 package org.junit.platform.engine.discovery;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
+
+import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 import org.junit.platform.AbstractEqualsAndHashCodeTests;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
 
 /**
@@ -25,34 +28,67 @@ import org.junit.platform.commons.PreconditionViolationException;
  */
 class MethodSelectorTests extends AbstractEqualsAndHashCodeTests {
 
+	private static final String TEST_CASE_NAME = TestCase.class.getName();
+
 	@Test
 	void equalsAndHashCode() {
-		var selector1 = new MethodSelector("TestClass", "method", "int, boolean", null);
-		var selector2 = new MethodSelector("TestClass", "method", "int, boolean", null);
-
-		assertEqualsAndHashCode(selector1, selector2, new MethodSelector("TestClass", "method", "int", null));
-		assertEqualsAndHashCode(selector1, selector2, new MethodSelector("TestClass", "method", (ClassLoader) null));
-		assertEqualsAndHashCode(selector1, selector2, new MethodSelector("TestClass", "X", "int, boolean", null));
-		assertEqualsAndHashCode(selector1, selector2, new MethodSelector("TestClass", "X", (ClassLoader) null));
-		assertEqualsAndHashCode(selector1, selector2, new MethodSelector("X", "method", "int, boolean", null));
-		assertEqualsAndHashCode(selector1, selector2, new MethodSelector("X", "method", (ClassLoader) null));
+		var selector1 = new MethodSelector(TEST_CASE_NAME, "method", "int, boolean", null);
+		var selector2 = new MethodSelector(TEST_CASE_NAME, "method", "int, boolean", null);
+		var selector3 = new MethodSelector(TestCase.class, "method", "int, boolean");
+
+		Stream.of(selector2, selector3).forEach(selector -> {
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector(TEST_CASE_NAME, "method", "int", null));
+			assertEqualsAndHashCode(selector1, selector,
+				new MethodSelector(TEST_CASE_NAME, "method", "", (ClassLoader) null));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector(TEST_CASE_NAME, "X", "int, boolean", null));
+			assertEqualsAndHashCode(selector1, selector,
+				new MethodSelector(TEST_CASE_NAME, "X", "", (ClassLoader) null));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector("X", "method", "int, boolean", null));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector("X", "method", "", (ClassLoader) null));
+		});
 	}
 
 	@Test
-	void preservesOriginalExceptionWhenTryingToLoadClass() {
-		var selector = new MethodSelector("TestClass", "method", "int, boolean", (ClassLoader) null);
+	void preservesOriginalExceptionWhenTryingToLoadJavaClass() {
+		var selector = new MethodSelector("org.example.BogusClass", "method", "int, boolean", (ClassLoader) null);
 
-		var e = assertThrows(PreconditionViolationException.class, selector::getJavaClass);
+		assertThat(selector.getClassName()).isEqualTo("org.example.BogusClass");
+		assertThat(selector.getMethodName()).isEqualTo("method");
+		assertThat(selector.getParameterTypeNames()).isEqualTo("int, boolean");
 
-		assertThat(e).hasMessage("Could not load class with name: TestClass").hasCauseInstanceOf(
-			ClassNotFoundException.class);
+		assertThatExceptionOfType(PreconditionViolationException.class)//
+				.isThrownBy(selector::getJavaClass)//
+				.withMessage("Could not load class with name: org.example.BogusClass")//
+				.withCauseInstanceOf(ClassNotFoundException.class);
+	}
+
+	@Test
+	void preservesOriginalExceptionWhenTryingToLoadClassForParameterType() {
+		var selector = new MethodSelector(TEST_CASE_NAME, "method", "int[], org.example.Bogus", (ClassLoader) null);
+
+		assertThat(selector.getClassName()).isEqualTo(TEST_CASE_NAME);
+		assertThat(selector.getMethodName()).isEqualTo("method");
+		assertThat(selector.getParameterTypeNames()).isEqualTo("int[], org.example.Bogus");
+
+		assertThatExceptionOfType(JUnitException.class)//
+				.isThrownBy(selector::getJavaMethod)//
+				.withMessage("Failed to load parameter type [org.example.Bogus] for method [method] in class [%s].",
+					TEST_CASE_NAME)//
+				.withCauseInstanceOf(ClassNotFoundException.class);
 	}
 
 	@Test
 	void usesClassClassLoader() {
-		var selector = new MethodSelector(getClass(), "usesClassClassLoader");
+		var selector = new MethodSelector(getClass(), "usesClassClassLoader", "");
 
 		assertThat(selector.getClassLoader()).isNotNull().isSameAs(getClass().getClassLoader());
 	}
 
+	private static class TestCase {
+
+		@SuppressWarnings("unused")
+		void method(int num, boolean flag) {
+		}
+	}
+
 }
