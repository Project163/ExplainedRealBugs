diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc
index 54c958842..e7f2ff209 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc
@@ -47,6 +47,13 @@ on GitHub.
   `@ParameterizedTest` method that is inferred as the factory method when no explicit
   factory method is specified in the `@MethodSource` annotation.
 
+* Thread mode can be set on `@Timeout` annotation. It allows to configure whether the test code
+  is executed in the thread of the calling code or in a separate thread, the modes are:
+  `INFERRED` (default) which resolves the thread mode configured via the
+  property `junit.jupiter.execution.timeout.thread.mode.default`, `SAME_THREAD` that executes
+  the test code in the same thread than the calling code, and `SEPARATE_THREAD` which
+  executes the test code in a separate thread.
+
 
 [[release-notes-5.9.0-M2-junit-vintage]]
 === JUnit Vintage
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 7fde01551..c56837489 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -270,11 +270,10 @@ include::{testDir}/example/AssertionsDemo.java[tags=user_guide]
 [WARNING]
 .Preemptive Timeouts with `assertTimeoutPreemptively()`
 ====
-Contrary to <<writing-tests-declarative-timeouts, declarative timeouts>>, the various
-`assertTimeoutPreemptively()` methods in the `Assertions` class execute the provided
-`executable` or `supplier` in a different thread than that of the calling code. This
-behavior can lead to undesirable side effects if the code that is executed within the
-`executable` or `supplier` relies on `java.lang.ThreadLocal` storage.
+The various`assertTimeoutPreemptively()` methods in the `Assertions` class execute
+the provided `executable` or `supplier` in a different thread than that of the calling
+code. This behavior can lead to undesirable side effects if the code that is executed
+within the `executable` or `supplier` relies on `java.lang.ThreadLocal` storage.
 
 One common example of this is the transactional testing support in the Spring Framework.
 Specifically, Spring's testing support binds transaction state to the current thread (via
@@ -2045,12 +2044,6 @@ The following example shows how `@Timeout` is applied to lifecycle and test meth
 include::{testDir}/example/TimeoutDemo.java[tags=user_guide]
 ----
 
-Contrary to the `assertTimeoutPreemptively()` assertion, the execution of the annotated
-method proceeds in the main thread of the test. If the timeout is exceeded, the main
-thread is interrupted from another thread. This is done to ensure interoperability with
-frameworks such as Spring that make use of mechanisms that are sensitive to the currently
-running thread — for example, `ThreadLocal` transaction management.
-
 To apply the same timeout to all test methods within a test class and all of its `@Nested`
 classes, you can declare the `@Timeout` annotation at the class level. It will then be
 applied to all test, test factory, and test template methods within that class and its
@@ -2066,8 +2059,32 @@ within the specified duration but does not verify the execution time of each ind
 If `@Timeout` is present on a `@TestTemplate` method — for example, a `@RepeatedTest` or
 `@ParameterizedTest` — each invocation will have the given timeout applied to it.
 
+[[writing-tests-declarative-timeouts-thread-mode]]
+==== Thread mode
+
+The timeout can be applied using one of the following three thread modes: `SAME_THREAD`,
+`SEPARATE_THREAD`, or `INFERRED`.
+
+When `SAME_THREAD` is used, the execution of the annotated method proceeds in the main
+thread of the test. If the timeout is exceeded, the main thread is interrupted from
+another thread. This is done to ensure interoperability with frameworks such as Spring
+that make use of mechanisms that are sensitive to the currently running thread — for
+example, `ThreadLocal` transaction management.
+
+On the contrary when `SEPARATE_THREAD` is used, like the `assertTimeoutPreemptively()`
+assertion, the execution of the annotated method proceeds in a separate thread, this
+can lead to undesirable side effects, see <<writing-tests-assertions-preemptive-timeouts>>.
+
+When `INFERRED` (default) thread mode is used, the thread mode is resolved via the
+`junit.jupiter.execution.timeout.thread.mode.default` configuration parameter. If the
+provided configuration parameter is invalid or not present then `SAME_THREAD` is used as
+fallback.
+
+[[writing-tests-declarative-timeouts-default-timeouts]]
+==== Default Timeouts
+
 The following <<running-tests-config-params, configuration parameters>> can be used to
-specify global timeouts for all methods of a certain category unless they or an enclosing
+specify default timeouts for all methods of a certain category unless they or an enclosing
 test class is annotated with `@Timeout`:
 
 `junit.jupiter.execution.timeout.default`::
diff --git a/documentation/src/test/java/example/TimeoutDemo.java b/documentation/src/test/java/example/TimeoutDemo.java
index ddcc489a2..0980a8fd1 100644
--- a/documentation/src/test/java/example/TimeoutDemo.java
+++ b/documentation/src/test/java/example/TimeoutDemo.java
@@ -15,6 +15,7 @@ import java.util.concurrent.TimeUnit;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.Timeout.ThreadMode;
 
 // tag::user_guide[]
 class TimeoutDemo {
@@ -31,5 +32,11 @@ class TimeoutDemo {
 		// fails if execution time exceeds 100 milliseconds
 	}
 
+	@Test
+	@Timeout(value = 100, unit = TimeUnit.MILLISECONDS, threadMode = ThreadMode.SEPARATE_THREAD)
+	void failsIfExecutionTimeExceeds100MillisecondsInSeparateThread() {
+		// fails if execution time exceeds 100 milliseconds, the test code is executed in a separate thread
+	}
+
 }
 // end::user_guide[]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Timeout.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Timeout.java
index 6bab4ee4d..74faf89b3 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Timeout.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Timeout.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.api;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.lang.annotation.Documented;
@@ -316,6 +317,21 @@ public @interface Timeout {
 	@API(status = STABLE, since = "5.9")
 	String TIMEOUT_MODE_PROPERTY_NAME = "junit.jupiter.execution.timeout.mode";
 
+	/**
+	 * Property name used to set the default thread mode for all testable and lifecycle
+	 * methods: "junit.jupiter.execution.timeout.thread.mode.default".
+	 *
+	 * <p>The value of this property will be used unless overridden by a {@link Timeout @Timeout}
+	 * annotation present on the method or on an enclosing test class (for testable methods).
+	 *
+	 * <p>The supported values are {@code SAME_THREAD} or {@code SEPARATE_THREAD}, if none is provided
+	 * {@code SAME_THREAD} is used as default.
+	 *
+	 * @since 5.9
+	 */
+	@API(status = EXPERIMENTAL, since = "5.9")
+	String DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME = "junit.jupiter.execution.timeout.thread.mode.default";
+
 	/**
 	 * The duration of this timeout.
 	 *
@@ -331,4 +347,42 @@ public @interface Timeout {
 	 */
 	TimeUnit unit() default TimeUnit.SECONDS;
 
+	/**
+	 * The thread mode of this timeout.
+	 *
+	 * @return thread mode
+	 * @since 5.9
+	 * @see ThreadMode
+	 */
+	@API(status = EXPERIMENTAL, since = "5.9")
+	ThreadMode threadMode() default ThreadMode.INFERRED;
+
+	/**
+	 * {@code ThreadMode} is use to define whether the test code should be executed in the thread
+	 * of the calling code or in a separated thread.
+	 *
+	 * @since 5.9
+	 */
+	@API(status = EXPERIMENTAL, since = "5.9")
+	enum ThreadMode {
+		/**
+		 * The thread mode is determined using the parameter configured in property
+		 * {@value Timeout#DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME}.
+		 */
+		INFERRED,
+
+		/**
+		 * The test code is executed in the thread of the calling code.
+		 */
+		SAME_THREAD,
+
+		/**
+		 * The test code is executed in a different thread than that of the calling code. Furthermore,
+		 * execution of the test code will be preemptively aborted if the timeout is exceeded. See the
+		 * {@linkplain Assertions Preemptive Timeouts} section of the class-level
+		 * Javadoc for a discussion of possible undesirable side effects.
+		 */
+		SEPARATE_THREAD,
+	}
+
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
index be6eebf23..b68a9bdbb 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
@@ -313,6 +313,16 @@ public final class Constants {
 	@SuppressWarnings("deprecation")
 	public static final String TEMP_DIR_SCOPE_PROPERTY_NAME = TempDir.SCOPE_PROPERTY_NAME;
 
+	/**
+	 * Property name used to set the default timeout thread mode.
+	 *
+	 * @since 5.9
+	 * @see Timeout
+	 * @see Timeout.ThreadMode
+	 */
+	@API(status = EXPERIMENTAL, since = "5.9")
+	public static final String DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME = Timeout.DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME;
+
 	private Constants() {
 		/* no-op */
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutInvocation.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SameThreadTimeoutInvocation.java
similarity index 77%
rename from junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutInvocation.java
rename to junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SameThreadTimeoutInvocation.java
index a16db56b8..7cb93b5df 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutInvocation.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SameThreadTimeoutInvocation.java
@@ -12,7 +12,6 @@ package org.junit.jupiter.engine.extension;
 
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
 
 import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
@@ -21,14 +20,14 @@ import org.junit.platform.commons.util.UnrecoverableExceptions;
 /**
  * @since 5.5
  */
-class TimeoutInvocation<T> implements Invocation<T> {
+class SameThreadTimeoutInvocation<T> implements Invocation<T> {
 
 	private final Invocation<T> delegate;
 	private final TimeoutDuration timeout;
 	private final ScheduledExecutorService executor;
 	private final Supplier<String> descriptionSupplier;
 
-	TimeoutInvocation(Invocation<T> delegate, TimeoutDuration timeout, ScheduledExecutorService executor,
+	SameThreadTimeoutInvocation(Invocation<T> delegate, TimeoutDuration timeout, ScheduledExecutorService executor,
 			Supplier<String> descriptionSupplier) {
 		this.delegate = delegate;
 		this.timeout = timeout;
@@ -56,7 +55,7 @@ class TimeoutInvocation<T> implements Invocation<T> {
 			}
 			if (interruptTask.executed) {
 				Thread.interrupted();
-				failure = createTimeoutException(failure);
+				failure = TimeoutExceptionFactory.create(descriptionSupplier.get(), timeout, failure);
 			}
 		}
 		if (failure != null) {
@@ -65,15 +64,6 @@ class TimeoutInvocation<T> implements Invocation<T> {
 		return result;
 	}
 
-	private TimeoutException createTimeoutException(Throwable failure) {
-		String message = String.format("%s timed out after %s", descriptionSupplier.get(), timeout);
-		TimeoutException timeoutError = new TimeoutException(message);
-		if (failure != null) {
-			timeoutError.addSuppressed(failure);
-		}
-		return timeoutError;
-	}
-
 	static class InterruptTask implements Runnable {
 
 		private final Thread thread;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
new file mode 100644
index 000000000..1860f4134
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
+
+import java.util.concurrent.TimeoutException;
+import java.util.function.Supplier;
+
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.opentest4j.AssertionFailedError;
+
+/**
+ * @since 5.9
+ */
+class SeparateThreadTimeoutInvocation<T> implements Invocation<T> {
+
+	private final Invocation<T> delegate;
+	private final TimeoutDuration timeout;
+	private final Supplier<String> descriptionSupplier;
+
+	SeparateThreadTimeoutInvocation(Invocation<T> delegate, TimeoutDuration timeout,
+			Supplier<String> descriptionSupplier) {
+		this.delegate = delegate;
+		this.timeout = timeout;
+		this.descriptionSupplier = descriptionSupplier;
+	}
+
+	@Override
+	public T proceed() throws Throwable {
+		try {
+			return assertTimeoutPreemptively(timeout.toDuration(), delegate::proceed, descriptionSupplier);
+		}
+		catch (AssertionFailedError failure) {
+			TimeoutException exception = TimeoutExceptionFactory.create(descriptionSupplier.get(), timeout, null);
+			exception.initCause(failure.getCause());
+			throw exception;
+		}
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutConfiguration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutConfiguration.java
index 7d20ae916..799255432 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutConfiguration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutConfiguration.java
@@ -20,12 +20,17 @@ import static org.junit.jupiter.api.Timeout.DEFAULT_TEST_FACTORY_METHOD_TIMEOUT_
 import static org.junit.jupiter.api.Timeout.DEFAULT_TEST_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.api.Timeout.DEFAULT_TEST_TEMPLATE_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.api.Timeout.DEFAULT_TIMEOUT_PROPERTY_NAME;
+import static org.junit.jupiter.api.Timeout.DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME;
+import static org.junit.jupiter.api.Timeout.ThreadMode.SAME_THREAD;
+import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
 
 import java.util.Map;
 import java.util.Optional;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 
+import org.junit.jupiter.api.Timeout.ThreadMode;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
@@ -39,6 +44,7 @@ class TimeoutConfiguration {
 
 	private final TimeoutDurationParser parser = new TimeoutDurationParser();
 	private final Map<String, Optional<TimeoutDuration>> cache = new ConcurrentHashMap<>();
+	private final AtomicReference<Optional<ThreadMode>> threadMode = new AtomicReference<>();
 	private final ExtensionContext extensionContext;
 
 	TimeoutConfiguration(ExtensionContext extensionContext) {
@@ -106,4 +112,35 @@ class TimeoutConfiguration {
 		}));
 	}
 
+	Optional<ThreadMode> getDefaultTimeoutThreadMode() {
+		if (threadMode.get() != null) {
+			return threadMode.get();
+		}
+		else {
+			Optional<ThreadMode> configuredThreadMode = parseTimeoutThreadModeConfiguration();
+			threadMode.set(configuredThreadMode);
+			return configuredThreadMode;
+		}
+	}
+
+	private Optional<ThreadMode> parseTimeoutThreadModeConfiguration() {
+		return extensionContext.getConfigurationParameter(DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME).map(value -> {
+			try {
+				ThreadMode threadMode = ThreadMode.valueOf(value.toUpperCase());
+				if (threadMode == ThreadMode.INFERRED) {
+					logger.warn(() -> String.format(
+						"Invalid timeout thread mode '%s', only %s and %s can be used as configuration parameter for %s.",
+						value, SAME_THREAD, SEPARATE_THREAD, DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME));
+					return null;
+				}
+				return threadMode;
+			}
+			catch (Exception e) {
+				logger.warn(e,
+					() -> String.format("Invalid timeout thread mode '%s' set via the '%s' configuration parameter.",
+						value, DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME));
+				return null;
+			}
+		});
+	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutDuration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutDuration.java
index 57032e1d0..553964d18 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutDuration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutDuration.java
@@ -10,10 +10,13 @@
 
 package org.junit.jupiter.engine.extension;
 
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.jupiter.api.Timeout;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.Preconditions;
 
 /**
@@ -68,4 +71,28 @@ class TimeoutDuration {
 		return value + " " + label;
 	}
 
+	public Duration toDuration() {
+		return Duration.of(value, toChronoUnit());
+	}
+
+	private ChronoUnit toChronoUnit() {
+		switch (unit) {
+			case NANOSECONDS:
+				return ChronoUnit.NANOS;
+			case MICROSECONDS:
+				return ChronoUnit.MICROS;
+			case MILLISECONDS:
+				return ChronoUnit.MILLIS;
+			case SECONDS:
+				return ChronoUnit.SECONDS;
+			case MINUTES:
+				return ChronoUnit.MINUTES;
+			case HOURS:
+				return ChronoUnit.HOURS;
+			case DAYS:
+				return ChronoUnit.DAYS;
+			default:
+				throw new JUnitException("Could not map TimeUnit " + unit + " to ChronoUnit");
+		}
+	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExceptionFactory.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExceptionFactory.java
new file mode 100644
index 000000000..4c94a3c0a
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExceptionFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import java.util.concurrent.TimeoutException;
+
+import org.junit.platform.commons.util.Preconditions;
+
+/**
+ * @since 5.9
+ */
+class TimeoutExceptionFactory {
+
+	private TimeoutExceptionFactory() {
+	}
+
+	static TimeoutException create(String methodSignature, TimeoutDuration timeoutDuration, Throwable failure) {
+		String message = String.format("%s timed out after %s",
+			Preconditions.notNull(methodSignature, "method signature must not be null"),
+			Preconditions.notNull(timeoutDuration, "timeout duration must not be null"));
+		TimeoutException timeoutException = new TimeoutException(message);
+		if (failure != null) {
+			timeoutException.addSuppressed(failure);
+		}
+		return timeoutException;
+	}
+
+	static TimeoutException create(String methodSignature, TimeoutDuration timeoutDuration) {
+		return create(methodSignature, timeoutDuration, null);
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExtension.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExtension.java
index de8893303..4f1de2fdf 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExtension.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutExtension.java
@@ -11,24 +11,22 @@
 package org.junit.jupiter.engine.extension;
 
 import static org.junit.jupiter.api.Timeout.TIMEOUT_MODE_PROPERTY_NAME;
+import static org.junit.jupiter.api.Timeout.ThreadMode.SAME_THREAD;
 
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Method;
 import java.util.Optional;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
 import java.util.function.Function;
 
 import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.Timeout.ThreadMode;
 import org.junit.jupiter.api.extension.BeforeAllCallback;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
 import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
-import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
-import org.junit.platform.commons.JUnitException;
+import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.TimeoutInvocationParameters;
 import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -41,6 +39,7 @@ class TimeoutExtension implements BeforeAllCallback, BeforeEachCallback, Invocat
 
 	private static final ExtensionContext.Namespace NAMESPACE = ExtensionContext.Namespace.create(Timeout.class);
 	private static final String TESTABLE_METHOD_TIMEOUT_KEY = "testable_method_timeout_from_annotation";
+	private static final String TESTABLE_METHOD_TIMEOUT_THREAD_MODE_KEY = "testable_method_timeout_thread_mode_from_annotation";
 	private static final String GLOBAL_TIMEOUT_CONFIG_KEY = "global_timeout_config";
 	private static final String ENABLED_MODE_VALUE = "enabled";
 	private static final String DISABLED_MODE_VALUE = "disabled";
@@ -59,6 +58,9 @@ class TimeoutExtension implements BeforeAllCallback, BeforeEachCallback, Invocat
 	private void readAndStoreTimeoutSoChildrenInheritIt(ExtensionContext context) {
 		readTimeoutFromAnnotation(context.getElement()).ifPresent(
 			timeout -> context.getStore(NAMESPACE).put(TESTABLE_METHOD_TIMEOUT_KEY, timeout));
+		readTimeoutThreadModeFromAnnotation(context.getElement()).ifPresent(
+			timeoutThreadMode -> context.getStore(NAMESPACE).put(TESTABLE_METHOD_TIMEOUT_THREAD_MODE_KEY,
+				timeoutThreadMode));
 	}
 
 	@Override
@@ -131,6 +133,11 @@ class TimeoutExtension implements BeforeAllCallback, BeforeEachCallback, Invocat
 		return AnnotationSupport.findAnnotation(element, Timeout.class).map(TimeoutDuration::from);
 	}
 
+	@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
+	private Optional<ThreadMode> readTimeoutThreadModeFromAnnotation(Optional<AnnotatedElement> element) {
+		return AnnotationSupport.findAnnotation(element, Timeout.class).map(Timeout::threadMode);
+	}
+
 	private <T> T interceptTestableMethod(Invocation<T> invocation,
 			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext,
 			TimeoutProvider defaultTimeoutProvider) throws Throwable {
@@ -167,8 +174,23 @@ class TimeoutExtension implements BeforeAllCallback, BeforeEachCallback, Invocat
 		if (timeout == null || isTimeoutDisabled(extensionContext)) {
 			return invocation;
 		}
-		return new TimeoutInvocation<>(invocation, timeout, getExecutor(extensionContext),
-			() -> describe(invocationContext, extensionContext));
+
+		ThreadMode threadMode = resolveTimeoutThreadMode(extensionContext);
+		return new TimeoutInvocationFactory(extensionContext.getRoot().getStore(NAMESPACE)).create(threadMode,
+			new TimeoutInvocationParameters<>(invocation, timeout,
+				() -> describe(invocationContext, extensionContext)));
+	}
+
+	private ThreadMode resolveTimeoutThreadMode(ExtensionContext extensionContext) {
+		ThreadMode annotationThreadMode = getAnnotationThreadMode(extensionContext);
+		if (annotationThreadMode == null || annotationThreadMode == ThreadMode.INFERRED) {
+			return getGlobalTimeoutConfiguration(extensionContext).getDefaultTimeoutThreadMode().orElse(SAME_THREAD);
+		}
+		return annotationThreadMode;
+	}
+
+	private ThreadMode getAnnotationThreadMode(ExtensionContext extensionContext) {
+		return extensionContext.getStore(NAMESPACE).get(TESTABLE_METHOD_TIMEOUT_THREAD_MODE_KEY, ThreadMode.class);
 	}
 
 	private String describe(ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) {
@@ -180,10 +202,6 @@ class TimeoutExtension implements BeforeAllCallback, BeforeEachCallback, Invocat
 		return ReflectionUtils.getFullyQualifiedMethodName(invocationContext.getTargetClass(), method);
 	}
 
-	private ScheduledExecutorService getExecutor(ExtensionContext extensionContext) {
-		return extensionContext.getRoot().getStore(NAMESPACE).getOrComputeIfAbsent(ExecutorResource.class).get();
-	}
-
 	/**
 	 * Determine if timeouts are disabled for the supplied extension context.
 	 */
@@ -211,34 +229,4 @@ class TimeoutExtension implements BeforeAllCallback, BeforeEachCallback, Invocat
 	@FunctionalInterface
 	private interface TimeoutProvider extends Function<TimeoutConfiguration, Optional<TimeoutDuration>> {
 	}
-
-	private static class ExecutorResource implements CloseableResource {
-
-		private final ScheduledExecutorService executor;
-
-		@SuppressWarnings("unused")
-		ExecutorResource() {
-			executor = Executors.newSingleThreadScheduledExecutor(runnable -> {
-				Thread thread = new Thread(runnable, "junit-jupiter-timeout-watcher");
-				thread.setPriority(Thread.MAX_PRIORITY);
-				return thread;
-			});
-		}
-
-		ScheduledExecutorService get() {
-			return executor;
-		}
-
-		@Override
-		public void close() throws Throwable {
-			executor.shutdown();
-			boolean terminated = executor.awaitTermination(5, TimeUnit.SECONDS);
-			if (!terminated) {
-				executor.shutdownNow();
-				throw new JUnitException("Scheduled executor could not be stopped in an orderly manner");
-			}
-		}
-
-	}
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactory.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactory.java
new file mode 100644
index 000000000..2af93e782
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactory.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+
+import org.junit.jupiter.api.Timeout.ThreadMode;
+import org.junit.jupiter.api.extension.ExtensionContext.Store;
+import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.Preconditions;
+
+/**
+ * @since 5.9
+ */
+class TimeoutInvocationFactory {
+
+	private final Store store;
+
+	TimeoutInvocationFactory(Store store) {
+		this.store = Preconditions.notNull(store, "store must not be null");
+	}
+
+	<T> Invocation<T> create(ThreadMode threadMode, TimeoutInvocationParameters<T> timeoutInvocationParameters) {
+		Preconditions.notNull(threadMode, "thread mode must not be null");
+		Preconditions.condition(threadMode != ThreadMode.INFERRED, "thread mode must not be INFERRED");
+		Preconditions.notNull(timeoutInvocationParameters, "timeout invocation parameters must not be null");
+		if (threadMode == ThreadMode.SEPARATE_THREAD) {
+			return new SeparateThreadTimeoutInvocation<>(timeoutInvocationParameters.getInvocation(),
+				timeoutInvocationParameters.getTimeoutDuration(), timeoutInvocationParameters.getDescriptionSupplier());
+		}
+		return new SameThreadTimeoutInvocation<>(timeoutInvocationParameters.getInvocation(),
+			timeoutInvocationParameters.getTimeoutDuration(), getThreadExecutorForSameThreadInvocation(),
+			timeoutInvocationParameters.getDescriptionSupplier());
+	}
+
+	private ScheduledExecutorService getThreadExecutorForSameThreadInvocation() {
+		return store.getOrComputeIfAbsent(SingleThreadExecutorResource.class).get();
+	}
+
+	private static abstract class ExecutorResource implements CloseableResource {
+
+		protected final ScheduledExecutorService executor;
+
+		ExecutorResource(ScheduledExecutorService executor) {
+			this.executor = executor;
+		}
+
+		ScheduledExecutorService get() {
+			return executor;
+		}
+
+		@Override
+		public void close() throws Throwable {
+			executor.shutdown();
+			boolean terminated = executor.awaitTermination(5, TimeUnit.SECONDS);
+			if (!terminated) {
+				executor.shutdownNow();
+				throw new JUnitException("Scheduled executor could not be stopped in an orderly manner");
+			}
+		}
+	}
+
+	static class SingleThreadExecutorResource extends ExecutorResource {
+
+		@SuppressWarnings("unused")
+		SingleThreadExecutorResource() {
+			super(Executors.newSingleThreadScheduledExecutor(runnable -> {
+				Thread thread = new Thread(runnable, "junit-jupiter-timeout-watcher");
+				thread.setPriority(Thread.MAX_PRIORITY);
+				return thread;
+			}));
+		}
+	}
+
+	static class TimeoutInvocationParameters<T> {
+
+		private final Invocation<T> invocation;
+		private final TimeoutDuration timeout;
+		private final Supplier<String> descriptionSupplier;
+
+		TimeoutInvocationParameters(Invocation<T> invocation, TimeoutDuration timeout,
+				Supplier<String> descriptionSupplier) {
+			this.invocation = Preconditions.notNull(invocation, "invocation must not be null");
+			this.timeout = Preconditions.notNull(timeout, "timeout must not be null");
+			this.descriptionSupplier = Preconditions.notNull(descriptionSupplier,
+				"description supplier must not be null");
+		}
+
+		public Invocation<T> getInvocation() {
+			return invocation;
+		}
+
+		public TimeoutDuration getTimeoutDuration() {
+			return timeout;
+		}
+
+		public Supplier<String> getDescriptionSupplier() {
+			return descriptionSupplier;
+		}
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SameThreadTimeoutInvocationTests.java
similarity index 91%
rename from junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationTests.java
rename to junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SameThreadTimeoutInvocationTests.java
index 460d0754b..f4af4da6c 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SameThreadTimeoutInvocationTests.java
@@ -27,14 +27,14 @@ import org.junit.jupiter.api.function.ThrowingConsumer;
 /**
  * @since 5.5
  */
-class TimeoutInvocationTests {
+class SameThreadTimeoutInvocationTests {
 
 	@Test
 	void resetsInterruptFlag() {
 		var exception = assertThrows(TimeoutException.class, () -> withExecutor(executor -> {
 			var delegate = new EventuallyInterruptibleInvocation();
 			var duration = new TimeoutDuration(1, NANOSECONDS);
-			var timeoutInvocation = new TimeoutInvocation<>(delegate, duration, executor, () -> "execution");
+			var timeoutInvocation = new SameThreadTimeoutInvocation<>(delegate, duration, executor, () -> "execution");
 			timeoutInvocation.proceed();
 		}));
 		assertFalse(Thread.currentThread().isInterrupted());
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTest.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTest.java
new file mode 100644
index 000000000..4e8973af9
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout.ThreadMode;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.jupiter.engine.execution.ExtensionValuesStore;
+import org.junit.jupiter.engine.execution.NamespaceAwareStore;
+import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.TimeoutInvocationParameters;
+
+/**
+ * @since 5.9
+ */
+@DisplayName("SeparateThreadTimeoutInvocation")
+class SeparateThreadTimeoutInvocationTest {
+
+	@Test
+	@DisplayName("throws timeout exception when timeout duration is exceeded")
+	void throwsTimeoutException() {
+		AtomicReference<String> threadName = new AtomicReference<>();
+		var invocation = aSeparateThreadInvocation(() -> {
+			threadName.set(Thread.currentThread().getName());
+			Thread.sleep(100);
+			return null;
+		});
+
+		assertThatThrownBy(invocation::proceed) //
+				.hasMessage("method() timed out after 10 milliseconds") //
+				.isInstanceOf(TimeoutException.class) //
+				.hasRootCauseMessage("Execution timed out in thread " + threadName.get());
+	}
+
+	@Test
+	@DisplayName("executes invocation in a separate thread")
+	void runsInvocationUsingSeparateThread() throws Throwable {
+		var invocationThreadName = aSeparateThreadInvocation(() -> Thread.currentThread().getName()).proceed();
+		assertThat(invocationThreadName).isNotEqualTo(Thread.currentThread().getName());
+	}
+
+	@Test
+	@DisplayName("throws invocation exception")
+	void shouldThrowInvocationException() {
+		var invocation = aSeparateThreadInvocation(() -> {
+			throw new RuntimeException("hi!");
+		});
+		assertThatThrownBy(invocation::proceed) //
+				.isInstanceOf(RuntimeException.class) //
+				.hasMessage("hi!");
+	}
+
+	private static <T> SeparateThreadTimeoutInvocation<T> aSeparateThreadInvocation(Invocation<T> invocation) {
+		var namespace = ExtensionContext.Namespace.create(SeparateThreadTimeoutInvocationTest.class);
+		var store = new NamespaceAwareStore(new ExtensionValuesStore(null), namespace);
+		var parameters = new TimeoutInvocationParameters<>(invocation, new TimeoutDuration(10, MILLISECONDS),
+			() -> "method()");
+		return (SeparateThreadTimeoutInvocation<T>) new TimeoutInvocationFactory(store) //
+				.create(ThreadMode.SEPARATE_THREAD, parameters);
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutConfigurationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutConfigurationTests.java
index 3d950fe53..5df3617b9 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutConfigurationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutConfigurationTests.java
@@ -18,6 +18,7 @@ import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
 import static org.junit.jupiter.engine.Constants.DEFAULT_AFTER_ALL_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_AFTER_EACH_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_BEFORE_ALL_METHOD_TIMEOUT_PROPERTY_NAME;
@@ -28,6 +29,7 @@ import static org.junit.jupiter.engine.Constants.DEFAULT_TEST_FACTORY_METHOD_TIM
 import static org.junit.jupiter.engine.Constants.DEFAULT_TEST_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_TEST_TEMPLATE_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_TIMEOUT_PROPERTY_NAME;
+import static org.junit.jupiter.engine.Constants.DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
@@ -57,6 +59,7 @@ class TimeoutConfigurationTests {
 		assertThat(config.getDefaultTestFactoryMethodTimeout()).isEmpty();
 		assertThat(config.getDefaultAfterEachMethodTimeout()).isEmpty();
 		assertThat(config.getDefaultAfterAllMethodTimeout()).isEmpty();
+		assertThat(config.getDefaultTimeoutThreadMode()).isEmpty();
 	}
 
 	@Test
@@ -131,4 +134,23 @@ class TimeoutConfigurationTests {
 				.containsExactly(
 					"Ignored invalid timeout 'invalid' set via the 'junit.jupiter.execution.timeout.test.method.default' configuration parameter.");
 	}
+
+	@Test
+	void specificThreadModeIsUsed() {
+		when(extensionContext.getConfigurationParameter(DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME)).thenReturn(
+			Optional.of("SEPARATE_THREAD"));
+		assertThat(config.getDefaultTimeoutThreadMode()).isEqualTo(Optional.of(SEPARATE_THREAD));
+	}
+
+	@Test
+	@TrackLogRecords
+	void logsInvalidThreadModeValueAndReturnEmpty(LogRecordListener logRecordListener) {
+		when(extensionContext.getConfigurationParameter(DEFAULT_TIMEOUT_THREAD_MODE_PROPERTY_NAME)).thenReturn(
+			Optional.of("invalid"));
+
+		assertThat(config.getDefaultTimeoutThreadMode()).isEqualTo(Optional.empty());
+		assertThat(logRecordListener.stream(Level.WARNING).map(LogRecord::getMessage)) //
+				.containsExactly(
+					"Invalid timeout thread mode 'invalid' set via the 'junit.jupiter.execution.timeout.thread.mode.default' configuration parameter.");
+	}
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExceptionFactoryTest.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExceptionFactoryTest.java
new file mode 100644
index 000000000..75de6f895
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExceptionFactoryTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.jupiter.engine.extension.TimeoutExceptionFactory.create;
+
+import java.util.concurrent.TimeoutException;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+
+/**
+ * @since 5.9
+ */
+@DisplayName("TimeoutExceptionFactory")
+class TimeoutExceptionFactoryTest {
+
+	private static final TimeoutDuration tenMillisDuration = new TimeoutDuration(10, MILLISECONDS);
+	private static final Exception suppressedException = new Exception("Winke!");
+	private static final String methodSignature = "test()";
+
+	@Test
+	@DisplayName("creates exception with method signature and timeout")
+	void createExceptionWithMethodSignatureTimeout() {
+		TimeoutException exception = create(methodSignature, tenMillisDuration);
+
+		assertThat(exception) //
+				.hasMessage("test() timed out after 10 milliseconds") //
+				.hasNoSuppressedExceptions();
+	}
+
+	@Test
+	@DisplayName("creates exception with method signature, timeout and throwable")
+	void createExceptionWithMethodSignatureTimeoutAndThrowable() {
+		TimeoutException exception = create(methodSignature, tenMillisDuration, suppressedException);
+
+		assertThat(exception) //
+				.hasMessage("test() timed out after 10 milliseconds") //
+				.hasSuppressedException(suppressedException);
+	}
+
+	@Nested
+	@DisplayName("throws exception when")
+	class ThrowException {
+
+		@Test
+		@DisplayName("method signature is null")
+		void methodSignatureIsnull() {
+			assertThatThrownBy(() -> create(null, tenMillisDuration, suppressedException)) //
+					.hasMessage("method signature must not be null");
+		}
+
+		@Test
+		@DisplayName("method timeout duration is null")
+		void timeoutDurationIsnull() {
+			assertThatThrownBy(() -> create(methodSignature, null, suppressedException)) //
+					.hasMessage("timeout duration must not be null");
+		}
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java
index 0d6981b33..60fdd14ee 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java
@@ -16,6 +16,8 @@ import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.jupiter.api.Timeout.ThreadMode.SAME_THREAD;
+import static org.junit.jupiter.api.Timeout.ThreadMode.SEPARATE_THREAD;
 import static org.junit.jupiter.engine.Constants.DEFAULT_AFTER_ALL_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_AFTER_EACH_METHOD_TIMEOUT_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_BEFORE_ALL_METHOD_TIMEOUT_PROPERTY_NAME;
@@ -42,14 +44,18 @@ import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
 import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.RepeatedTest;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.Timeout;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.RuntimeUtils;
+import org.junit.platform.engine.TestExecutionResult.Status;
 import org.junit.platform.testkit.engine.EngineExecutionResults;
 import org.junit.platform.testkit.engine.Events;
 import org.junit.platform.testkit.engine.Execution;
@@ -332,6 +338,144 @@ class TimeoutExtensionTests extends AbstractJupiterTestEngineTests {
 				.collect(toList()));
 	}
 
+	@Nested
+	@DisplayName("separate thread")
+	class SeparateThread {
+		@Test
+		@DisplayName("timeout exceeded")
+		void timeoutExceededInSeparateThread() {
+			EngineExecutionResults results = executeTestsForClass(TimeoutExceedingSeparateThreadTestCase.class);
+
+			Execution execution = findExecution(results.testEvents(), "testMethod()");
+			assertThat(execution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(TimeoutException.class) //
+					.hasMessage("testMethod() timed out after 10 milliseconds");
+		}
+
+		@Test
+		@DisplayName("non timeout exceeded")
+		void nonTimeoutExceededInSeparateThread() {
+			executeTestsForClass(NonTimeoutExceedingSeparateThreadTestCase.class).allEvents() //
+					.assertStatistics(stats -> stats.failed(0));
+		}
+
+		@Test
+		@DisplayName("does not swallow unrecoverable exceptions")
+		void separateThreadDoesNotSwallowUnrecoverableExceptions() {
+			assertThrows(OutOfMemoryError.class,
+				() -> executeTestsForClass(UnrecoverableExceptionInSeparateThreadTestCase.class));
+		}
+
+		@Test
+		@DisplayName("handles invocation exceptions")
+		void separateThreadHandlesInvocationExceptions() {
+			EngineExecutionResults results = executeTests(request() //
+					.selectors(selectMethod(ExceptionInSeparateThreadTestCase.class, "test")) //
+					.build());
+
+			Execution execution = findExecution(results.testEvents(), "test()");
+			assertThat(execution.getDuration()) //
+					.isLessThanOrEqualTo(Duration.ofMillis(10));
+			assertThat(execution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(RuntimeException.class) //
+					.hasMessage("Oppps!");
+		}
+
+		@Test
+		@DisplayName("when one test is stuck \"forever\" the next tests should not stuck")
+		void oneThreadStuckForever() {
+			EngineExecutionResults results = executeTestsForClass(OneTestStuckForeverAndTheOthersNotTestCase.class);
+
+			Execution stuckExecution = findExecution(results.testEvents(), "stuck()");
+			assertThat(stuckExecution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(TimeoutException.class) //
+					.hasMessage("stuck() timed out after 10 milliseconds");
+
+			Execution testZeroExecution = findExecution(results.testEvents(), "testZero()");
+			assertThat(testZeroExecution.getTerminationInfo().getExecutionResult().getStatus()) //
+					.isEqualTo(Status.SUCCESSFUL);
+
+			Execution testOneExecution = findExecution(results.testEvents(), "testOne()");
+			assertThat(testOneExecution.getTerminationInfo().getExecutionResult().getStatus()) //
+					.isEqualTo(Status.SUCCESSFUL);
+		}
+
+		@Test
+		@DisplayName("mixed same thread and separate thread tests")
+		void mixedSameThreadAndSeparateThreadTests() {
+			EngineExecutionResults results = executeTestsForClass(MixedSameThreadAndSeparateThreadTestCase.class);
+
+			Execution stuck = findExecution(results.testEvents(), "testZero()");
+			assertThat(stuck.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(TimeoutException.class) //
+					.hasMessage("testZero() timed out after 10 milliseconds");
+
+			Execution testZeroExecution = findExecution(results.testEvents(), "testOne()");
+			assertThat(testZeroExecution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(TimeoutException.class) //
+					.hasMessage("testOne() timed out after 10 milliseconds");
+
+			Execution testOneExecution = findExecution(results.testEvents(), "testTwo()");
+			assertThat(testOneExecution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(TimeoutException.class) //
+					.hasMessage("testTwo() timed out after 10 milliseconds");
+		}
+
+		@Test
+		@DisplayName("one test is stuck \"forever\" in separate thread and other tests in same thread not")
+		void oneThreadStuckForeverAndOtherTestsInSameThread() {
+			EngineExecutionResults results = executeTestsForClass(
+				OneTestStuckForeverAndTheOthersInSameThreadNotTestCase.class);
+
+			Execution stuckExecution = findExecution(results.testEvents(), "stuck()");
+			assertThat(stuckExecution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+					.isInstanceOf(TimeoutException.class) //
+					.hasMessage("stuck() timed out after 10 milliseconds");
+
+			Execution testZeroExecution = findExecution(results.testEvents(), "testZero()");
+			assertThat(testZeroExecution.getTerminationInfo().getExecutionResult().getStatus()) //
+					.isEqualTo(Status.SUCCESSFUL);
+
+			Execution testOneExecution = findExecution(results.testEvents(), "testOne()");
+			assertThat(testOneExecution.getTerminationInfo().getExecutionResult().getStatus()) //
+					.isEqualTo(Status.SUCCESSFUL);
+		}
+
+		@Test
+		@DisplayName("is not applied on annotated @Test methods using timeout mode: disabled")
+		void doesNotApplyTimeoutOnAnnotatedTestMethodsUsingDisabledTimeoutMode() {
+			EngineExecutionResults results = executeTests(request() //
+					.selectors(selectMethod(TimeoutExceedingSeparateThreadTestCase.class, "testMethod")) //
+					.configurationParameter(TIMEOUT_MODE_PROPERTY_NAME, "disabled").build());
+
+			Execution execution = findExecution(results.testEvents(), "testMethod()");
+			assertThat(execution.getTerminationInfo().getExecutionResult().getThrowable()) //
+					.isEmpty();
+		}
+
+		@Nested
+		@DisplayName("on class level")
+		class OnClassLevel {
+			@Test
+			@DisplayName("timeout exceeded")
+			void timeoutExceededInSeparateThreadOnClassLevel() {
+				EngineExecutionResults results = executeTestsForClass(TimeoutExceededOnClassLevelTestCase.class);
+
+				Execution execution = findExecution(results.testEvents(), "exceptionThrown()");
+				assertThat(execution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
+						.isInstanceOf(TimeoutException.class) //
+						.hasMessage("exceptionThrown() timed out after 10 milliseconds");
+			}
+
+			@Test
+			@DisplayName("non timeout exceeded")
+			void nonTimeoutExceededInSeparateThreadOnClassLevel() {
+				executeTestsForClass(NonTimeoutExceededOnClassLevelTestCase.class).allEvents() //
+						.assertStatistics(stats -> stats.failed(0));
+			}
+		}
+	}
+
 	static class TimeoutAnnotatedTestMethodTestCase {
 		@Test
 		@Timeout(value = 10, unit = MILLISECONDS)
@@ -543,4 +687,137 @@ class TimeoutExtensionTests extends AbstractJupiterTestEngineTests {
 
 	}
 
+	static class TimeoutExceedingWithInferredThreadModeTestCase {
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS)
+		void testMethod() throws InterruptedException {
+			Thread.sleep(100);
+		}
+	}
+
+	static class TimeoutExceedingSeparateThreadTestCase {
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void testMethod() throws InterruptedException {
+			Thread.sleep(100);
+		}
+	}
+
+	static class NonTimeoutExceedingSeparateThreadTestCase {
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void testMethod() {
+		}
+	}
+
+	static class UnrecoverableExceptionInSeparateThreadTestCase {
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void test() {
+			throw new OutOfMemoryError();
+		}
+	}
+
+	static class ExceptionInSeparateThreadTestCase {
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void test() {
+			throw new RuntimeException("Oppps!");
+		}
+	}
+
+	@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+	static class TimeoutExceededOnClassLevelTestCase {
+		@Test
+		void exceptionThrown() throws InterruptedException {
+			Thread.sleep(100);
+		}
+	}
+
+	@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+	static class NonTimeoutExceededOnClassLevelTestCase {
+		@Test
+		void test() {
+		}
+	}
+
+	@TestMethodOrder(OrderAnnotation.class)
+	static class OneTestStuckForeverAndTheOthersNotTestCase {
+		private static final CountDownLatch latch = new CountDownLatch(1);
+
+		@Test
+		@Order(0)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void stuck() throws InterruptedException {
+			latch.await();
+		}
+
+		@Test
+		@Order(1)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void testZero() {
+		}
+
+		@Test
+		@Order(2)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void testOne() {
+		}
+
+		@AfterAll
+		static void stop() throws InterruptedException {
+			Thread.sleep(100);
+			latch.countDown();
+		}
+	}
+
+	static class MixedSameThreadAndSeparateThreadTestCase {
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void testZero() throws InterruptedException {
+			Thread.sleep(100);
+		}
+
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SAME_THREAD)
+		void testOne() throws InterruptedException {
+			Thread.sleep(100);
+		}
+
+		@Test
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void testTwo() throws InterruptedException {
+			Thread.sleep(100);
+		}
+	}
+
+	@TestMethodOrder(OrderAnnotation.class)
+	static class OneTestStuckForeverAndTheOthersInSameThreadNotTestCase {
+		private static final CountDownLatch latch = new CountDownLatch(1);
+
+		@Test
+		@Order(0)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		void stuck() throws InterruptedException {
+			latch.await();
+		}
+
+		@Test
+		@Order(1)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SAME_THREAD)
+		void testZero() {
+		}
+
+		@Test
+		@Order(2)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SAME_THREAD)
+		void testOne() {
+		}
+
+		@AfterAll
+		static void stop() throws InterruptedException {
+			Thread.sleep(100);
+			latch.countDown();
+		}
+	}
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTest.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTest.java
new file mode 100644
index 000000000..6fc152a36
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.verify;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout.ThreadMode;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ExtensionContext.Store;
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.jupiter.engine.execution.ExtensionValuesStore;
+import org.junit.jupiter.engine.execution.NamespaceAwareStore;
+import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.SingleThreadExecutorResource;
+import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.TimeoutInvocationParameters;
+import org.mockito.Mock;
+import org.mockito.Spy;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+@DisplayName("TimeoutInvocationFactory")
+@ExtendWith(MockitoExtension.class)
+class TimeoutInvocationFactoryTest {
+
+	@Spy
+	private final Store store = new NamespaceAwareStore(new ExtensionValuesStore(null),
+		ExtensionContext.Namespace.create(TimeoutInvocationFactoryTest.class));
+	@Mock
+	private Invocation<String> invocation;
+	@Mock
+	private TimeoutDuration timeoutDuration;
+	private TimeoutInvocationFactory timeoutInvocationFactory;
+	private TimeoutInvocationParameters<String> parameters;
+
+	@BeforeEach
+	void setUp() {
+		parameters = new TimeoutInvocationParameters<>(invocation, timeoutDuration, () -> "description");
+		timeoutInvocationFactory = new TimeoutInvocationFactory(store);
+	}
+
+	@Test
+	@DisplayName("throws exception when null store is provided on create")
+	void shouldThrowExceptionWhenInstantiatingWithNullStore() {
+		assertThatThrownBy(() -> new TimeoutInvocationFactory(null)) //
+				.hasMessage("store must not be null");
+	}
+
+	@Test
+	@DisplayName("throws exception when null timeout thread mode is provided on create")
+	void shouldThrowExceptionWhenNullTimeoutThreadModeIsProvidedWhenCreate() {
+		assertThatThrownBy(() -> timeoutInvocationFactory.create(null, parameters)) //
+				.hasMessage("thread mode must not be null");
+	}
+
+	@Test
+	@DisplayName("throws exception when null timeout invocation parameters is provided on create")
+	void shouldThrowExceptionWhenNullTimeoutInvocationParametersIsProvidedWhenCreate() {
+		assertThatThrownBy(() -> timeoutInvocationFactory.create(ThreadMode.SAME_THREAD, null)) //
+				.hasMessage("timeout invocation parameters must not be null");
+	}
+
+	@Test
+	@DisplayName("creates timeout invocation for SAME_THREAD thread mode")
+	void shouldCreateTimeoutInvocationForSameThreadTimeoutThreadMode() {
+		var invocation = timeoutInvocationFactory.create(ThreadMode.SAME_THREAD, parameters);
+		assertThat(invocation).isInstanceOf(SameThreadTimeoutInvocation.class);
+		verify(store).getOrComputeIfAbsent(SingleThreadExecutorResource.class);
+	}
+
+	@Test
+	@DisplayName("creates timeout invocation for SEPARATE_THREAD thread mode")
+	void shouldCreateTimeoutInvocationForSeparateThreadTimeoutThreadMode() {
+		var invocation = timeoutInvocationFactory.create(ThreadMode.SEPARATE_THREAD, parameters);
+		assertThat(invocation).isInstanceOf(SeparateThreadTimeoutInvocation.class);
+	}
+
+}
