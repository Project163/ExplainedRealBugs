diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index ada634f0a..d73c14f7a 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -52,6 +52,8 @@ repository on GitHub.
   discovered tests for the specified details mode without executing them.
 * Improved error message for cyclic graphs detected during test discovery to be more
   actionable.
+* Extracted `NamespacedHierarchicalStore` from JUnit Jupiter engine for reuse by other
+  test engines and their extensions.
 
 
 [[release-notes-5.10.0-M1-junit-jupiter]]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
index faee7c4f4..3182b9103 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
@@ -547,7 +547,7 @@ public interface ExtensionContext {
 		 *
 		 * @param key the key; never {@code null}
 		 * @param defaultCreator the function called with the supplied {@code key}
-		 * to create a new value; never {@code null}
+		 * to create a new value; never {@code null} but may return {@code null}
 		 * @param <K> the key type
 		 * @param <V> the value type
 		 * @return the value; potentially {@code null}
@@ -574,7 +574,7 @@ public interface ExtensionContext {
 		 *
 		 * @param key the key; never {@code null}
 		 * @param defaultCreator the function called with the supplied {@code key}
-		 * to create a new value; never {@code null}
+		 * to create a new value; never {@code null} but may return {@code null}
 		 * @param requiredType the required type of the value; never {@code null}
 		 * @param <K> the key type
 		 * @param <V> the value type
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContextException.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContextException.java
index 957c0ed69..c47bfc48e 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContextException.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContextException.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.api.extension;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import org.apiguardian.api.API;
@@ -27,8 +28,14 @@ public class ExtensionContextException extends JUnitException {
 
 	private static final long serialVersionUID = 1L;
 
+	@SuppressWarnings("unused")
 	public ExtensionContextException(String message) {
 		super(message);
 	}
 
+	@API(status = EXPERIMENTAL, since = "5.10")
+	public ExtensionContextException(String message, Throwable cause) {
+		super(message, cause);
+	}
+
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java
index 90b6a9326..58ff7c739 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java
@@ -22,9 +22,9 @@ import java.util.function.Function;
 
 import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
 import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.execution.ExtensionValuesStore;
 import org.junit.jupiter.engine.execution.NamespaceAwareStore;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.Preconditions;
@@ -33,18 +33,25 @@ import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
 import org.junit.platform.engine.reporting.ReportEntry;
 import org.junit.platform.engine.support.hierarchical.Node;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
 
 /**
  * @since 5.0
  */
 abstract class AbstractExtensionContext<T extends TestDescriptor> implements ExtensionContext, AutoCloseable {
 
+	private static final NamespacedHierarchicalStore.CloseAction<Namespace> CLOSE_RESOURCES = (__, ___, value) -> {
+		if (value instanceof CloseableResource) {
+			((CloseableResource) value).close();
+		}
+	};
+
 	private final ExtensionContext parent;
 	private final EngineExecutionListener engineExecutionListener;
 	private final T testDescriptor;
 	private final Set<String> tags;
 	private final JupiterConfiguration configuration;
-	private final ExtensionValuesStore valuesStore;
+	private final NamespacedHierarchicalStore<Namespace> valuesStore;
 	private final ExecutableInvoker executableInvoker;
 
 	AbstractExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener, T testDescriptor,
@@ -67,17 +74,17 @@ abstract class AbstractExtensionContext<T extends TestDescriptor> implements Ext
 		// @formatter:on
 	}
 
-	private ExtensionValuesStore createStore(ExtensionContext parent) {
-		ExtensionValuesStore parentStore = null;
+	private NamespacedHierarchicalStore<Namespace> createStore(ExtensionContext parent) {
+		NamespacedHierarchicalStore<Namespace> parentStore = null;
 		if (parent != null) {
 			parentStore = ((AbstractExtensionContext<?>) parent).valuesStore;
 		}
-		return new ExtensionValuesStore(parentStore);
+		return new NamespacedHierarchicalStore<>(parentStore, CLOSE_RESOURCES);
 	}
 
 	@Override
 	public void close() {
-		this.valuesStore.closeAllStoredCloseableValues();
+		this.valuesStore.close();
 	}
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExtensionValuesStore.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExtensionValuesStore.java
deleted file mode 100644
index 133e3d6b0..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExtensionValuesStore.java
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Copyright 2015-2023 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.execution;
-
-import static org.apiguardian.api.API.Status.INTERNAL;
-import static org.junit.jupiter.engine.support.JupiterThrowableCollectorFactory.createThrowableCollector;
-import static org.junit.platform.commons.util.ReflectionUtils.getWrapperType;
-import static org.junit.platform.commons.util.ReflectionUtils.isAssignableTo;
-
-import java.util.Comparator;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.function.Function;
-import java.util.function.Supplier;
-
-import org.apiguardian.api.API;
-import org.junit.jupiter.api.extension.ExtensionContext;
-import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
-import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
-import org.junit.jupiter.api.extension.ExtensionContextException;
-import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
-
-/**
- * {@code ExtensionValuesStore} is used inside implementations of
- * {@link ExtensionContext} to store and retrieve values.
- *
- * @since 5.0
- */
-@API(status = INTERNAL, since = "5.0")
-public class ExtensionValuesStore {
-
-	private static final Comparator<StoredValue> REVERSE_INSERT_ORDER = Comparator.<StoredValue, Integer> comparing(
-		it -> it.order).reversed();
-
-	private final AtomicInteger insertOrderSequence = new AtomicInteger();
-	private final ConcurrentMap<CompositeKey, StoredValue> storedValues = new ConcurrentHashMap<>(4);
-	private final ExtensionValuesStore parentStore;
-
-	public ExtensionValuesStore(ExtensionValuesStore parentStore) {
-		this.parentStore = parentStore;
-	}
-
-	/**
-	 * Close all values that implement {@link CloseableResource}.
-	 *
-	 * @implNote Only close values stored in this instance. This implementation
-	 * does not close values in parent stores.
-	 */
-	public void closeAllStoredCloseableValues() {
-		ThrowableCollector throwableCollector = createThrowableCollector();
-		storedValues.values().stream() //
-				.filter(storedValue -> storedValue.evaluateSafely() instanceof CloseableResource) //
-				.sorted(REVERSE_INSERT_ORDER) //
-				.map(storedValue -> (CloseableResource) storedValue.evaluate()) //
-				.forEach(resource -> throwableCollector.execute(resource::close));
-		throwableCollector.assertEmpty();
-	}
-
-	Object get(Namespace namespace, Object key) {
-		StoredValue storedValue = getStoredValue(new CompositeKey(namespace, key));
-		return (storedValue != null ? storedValue.evaluate() : null);
-	}
-
-	<T> T get(Namespace namespace, Object key, Class<T> requiredType) {
-		Object value = get(namespace, key);
-		return castToRequiredType(key, value, requiredType);
-	}
-
-	<K, V> Object getOrComputeIfAbsent(Namespace namespace, K key, Function<K, V> defaultCreator) {
-		CompositeKey compositeKey = new CompositeKey(namespace, key);
-		StoredValue storedValue = getStoredValue(compositeKey);
-		if (storedValue == null) {
-			StoredValue newValue = storedValue(new MemoizingSupplier(() -> defaultCreator.apply(key)));
-			storedValue = Optional.ofNullable(storedValues.putIfAbsent(compositeKey, newValue)).orElse(newValue);
-		}
-		return storedValue.evaluate();
-	}
-
-	<K, V> V getOrComputeIfAbsent(Namespace namespace, K key, Function<K, V> defaultCreator, Class<V> requiredType) {
-		Object value = getOrComputeIfAbsent(namespace, key, defaultCreator);
-		return castToRequiredType(key, value, requiredType);
-	}
-
-	void put(Namespace namespace, Object key, Object value) {
-		storedValues.put(new CompositeKey(namespace, key), storedValue(() -> value));
-	}
-
-	private StoredValue storedValue(Supplier<Object> value) {
-		return new StoredValue(insertOrderSequence.getAndIncrement(), value);
-	}
-
-	Object remove(Namespace namespace, Object key) {
-		StoredValue previous = storedValues.remove(new CompositeKey(namespace, key));
-		return (previous != null ? previous.evaluate() : null);
-	}
-
-	<T> T remove(Namespace namespace, Object key, Class<T> requiredType) {
-		Object value = remove(namespace, key);
-		return castToRequiredType(key, value, requiredType);
-	}
-
-	private StoredValue getStoredValue(CompositeKey compositeKey) {
-		StoredValue storedValue = storedValues.get(compositeKey);
-		if (storedValue != null) {
-			return storedValue;
-		}
-		if (parentStore != null) {
-			return parentStore.getStoredValue(compositeKey);
-		}
-		return null;
-	}
-
-	@SuppressWarnings("unchecked")
-	private <T> T castToRequiredType(Object key, Object value, Class<T> requiredType) {
-		if (value == null) {
-			return null;
-		}
-		if (isAssignableTo(value, requiredType)) {
-			if (requiredType.isPrimitive()) {
-				return (T) getWrapperType(requiredType).cast(value);
-			}
-			return requiredType.cast(value);
-		}
-		// else
-		throw new ExtensionContextException(
-			String.format("Object stored under key [%s] is not of required type [%s]", key, requiredType.getName()));
-	}
-
-	private static class CompositeKey {
-
-		private final Namespace namespace;
-		private final Object key;
-
-		private CompositeKey(Namespace namespace, Object key) {
-			this.namespace = namespace;
-			this.key = key;
-		}
-
-		@Override
-		public boolean equals(Object o) {
-			if (this == o) {
-				return true;
-			}
-			if (o == null || getClass() != o.getClass()) {
-				return false;
-			}
-			CompositeKey that = (CompositeKey) o;
-			return this.namespace.equals(that.namespace) && this.key.equals(that.key);
-		}
-
-		@Override
-		public int hashCode() {
-			return Objects.hash(namespace, key);
-		}
-
-	}
-
-	private static class StoredValue {
-
-		private final int order;
-		private final Supplier<Object> supplier;
-
-		public StoredValue(int order, Supplier<Object> supplier) {
-			this.order = order;
-			this.supplier = supplier;
-		}
-
-		private Object evaluateSafely() {
-			try {
-				return evaluate();
-			}
-			catch (RuntimeException e) {
-				return null;
-			}
-		}
-
-		private Object evaluate() {
-			return supplier.get();
-		}
-
-	}
-
-	private static class MemoizingSupplier implements Supplier<Object> {
-
-		private static final Object NO_VALUE_SET = new Object();
-
-		private final Lock lock = new ReentrantLock();
-		private final Supplier<Object> delegate;
-		private volatile Object value = NO_VALUE_SET;
-
-		private MemoizingSupplier(Supplier<Object> delegate) {
-			this.delegate = delegate;
-		}
-
-		@Override
-		public Object get() {
-			if (value == NO_VALUE_SET) {
-				computeValue();
-			}
-			if (value instanceof Failure) {
-				throw ((Failure) value).exception;
-			}
-			return value;
-		}
-
-		private void computeValue() {
-			lock.lock();
-			try {
-				if (value == NO_VALUE_SET) {
-					value = delegate.get();
-				}
-			}
-			catch (RuntimeException e) {
-				value = new Failure(e);
-			}
-			finally {
-				lock.unlock();
-			}
-		}
-
-		private static class Failure {
-
-			private final RuntimeException exception;
-
-			public Failure(RuntimeException exception) {
-				this.exception = exception;
-			}
-		}
-
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/NamespaceAwareStore.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/NamespaceAwareStore.java
index 1b5630450..7d30d496a 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/NamespaceAwareStore.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/NamespaceAwareStore.java
@@ -13,11 +13,15 @@ package org.junit.jupiter.engine.execution;
 import static org.apiguardian.api.API.Status.INTERNAL;
 
 import java.util.function.Function;
+import java.util.function.Supplier;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.extension.ExtensionContext.Store;
+import org.junit.jupiter.api.extension.ExtensionContextException;
 import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStoreException;
 
 /**
  * @since 5.0
@@ -25,10 +29,10 @@ import org.junit.platform.commons.util.Preconditions;
 @API(status = INTERNAL, since = "5.0")
 public class NamespaceAwareStore implements Store {
 
-	private final ExtensionValuesStore valuesStore;
+	private final NamespacedHierarchicalStore<Namespace> valuesStore;
 	private final Namespace namespace;
 
-	public NamespaceAwareStore(ExtensionValuesStore valuesStore, Namespace namespace) {
+	public NamespaceAwareStore(NamespacedHierarchicalStore<Namespace> valuesStore, Namespace namespace) {
 		this.valuesStore = valuesStore;
 		this.namespace = namespace;
 	}
@@ -36,21 +40,21 @@ public class NamespaceAwareStore implements Store {
 	@Override
 	public Object get(Object key) {
 		Preconditions.notNull(key, "key must not be null");
-		return this.valuesStore.get(this.namespace, key);
+		return accessStore(() -> this.valuesStore.get(this.namespace, key));
 	}
 
 	@Override
 	public <T> T get(Object key, Class<T> requiredType) {
 		Preconditions.notNull(key, "key must not be null");
 		Preconditions.notNull(requiredType, "requiredType must not be null");
-		return this.valuesStore.get(this.namespace, key, requiredType);
+		return accessStore(() -> this.valuesStore.get(this.namespace, key, requiredType));
 	}
 
 	@Override
 	public <K, V> Object getOrComputeIfAbsent(K key, Function<K, V> defaultCreator) {
 		Preconditions.notNull(key, "key must not be null");
 		Preconditions.notNull(defaultCreator, "defaultCreator function must not be null");
-		return this.valuesStore.getOrComputeIfAbsent(this.namespace, key, defaultCreator);
+		return accessStore(() -> this.valuesStore.getOrComputeIfAbsent(this.namespace, key, defaultCreator));
 	}
 
 	@Override
@@ -58,26 +62,36 @@ public class NamespaceAwareStore implements Store {
 		Preconditions.notNull(key, "key must not be null");
 		Preconditions.notNull(defaultCreator, "defaultCreator function must not be null");
 		Preconditions.notNull(requiredType, "requiredType must not be null");
-		return this.valuesStore.getOrComputeIfAbsent(this.namespace, key, defaultCreator, requiredType);
+		return accessStore(
+			() -> this.valuesStore.getOrComputeIfAbsent(this.namespace, key, defaultCreator, requiredType));
 	}
 
 	@Override
 	public void put(Object key, Object value) {
 		Preconditions.notNull(key, "key must not be null");
-		this.valuesStore.put(this.namespace, key, value);
+		accessStore(() -> this.valuesStore.put(this.namespace, key, value));
 	}
 
 	@Override
 	public Object remove(Object key) {
 		Preconditions.notNull(key, "key must not be null");
-		return this.valuesStore.remove(this.namespace, key);
+		return accessStore(() -> this.valuesStore.remove(this.namespace, key));
 	}
 
 	@Override
 	public <T> T remove(Object key, Class<T> requiredType) {
 		Preconditions.notNull(key, "key must not be null");
 		Preconditions.notNull(requiredType, "requiredType must not be null");
-		return this.valuesStore.remove(this.namespace, key, requiredType);
+		return accessStore(() -> this.valuesStore.remove(this.namespace, key, requiredType));
+	}
+
+	private <T> T accessStore(Supplier<T> action) {
+		try {
+			return action.get();
+		}
+		catch (NamespacedHierarchicalStoreException e) {
+			throw new ExtensionContextException(e.getMessage(), e);
+		}
 	}
 
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/NamespaceTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/NamespaceTests.java
new file mode 100644
index 000000000..67ed44ed2
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/NamespaceTests.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015-2023 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
+
+public class NamespaceTests {
+
+	@Test
+	void namespacesEqualForSamePartsSequence() {
+		Namespace ns1 = Namespace.create("part1", "part2");
+		Namespace ns2 = Namespace.create("part1", "part2");
+
+		assertEquals(ns1, ns2);
+	}
+
+	@Test
+	void orderOfNamespacePartsDoesMatter() {
+		Namespace ns1 = Namespace.create("part1", "part2");
+		Namespace ns2 = Namespace.create("part2", "part1");
+
+		assertNotEquals(ns1, ns2);
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreConcurrencyTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreConcurrencyTests.java
index f09fb6990..dd270822b 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreConcurrencyTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreConcurrencyTests.java
@@ -18,9 +18,10 @@ import java.util.stream.IntStream;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.extension.ExtensionContext.Store;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
 
 /**
- * Concurrency tests for {@link NamespaceAwareStore} and {@link ExtensionValuesStore}.
+ * Concurrency tests for {@link NamespaceAwareStore} and {@link NamespacedHierarchicalStore}.
  *
  * @since 5.0
  */
@@ -46,7 +47,7 @@ class ExtensionContextStoreConcurrencyTests {
 
 	private Store reset() {
 		count.set(0);
-		return new NamespaceAwareStore(new ExtensionValuesStore(null), Namespace.GLOBAL);
+		return new NamespaceAwareStore(new NamespacedHierarchicalStore<>(null), Namespace.GLOBAL);
 	}
 
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreTests.java
index 16f403344..d19f97f2a 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextStoreTests.java
@@ -21,9 +21,11 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.extension.ExtensionContext.Store;
 import org.junit.jupiter.api.extension.ExtensionContextException;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStoreException;
 
 /**
- * Unit tests for {@link NamespaceAwareStore} and {@link ExtensionValuesStore}.
+ * Unit tests for {@link NamespaceAwareStore} and {@link NamespacedHierarchicalStore}.
  *
  * @since 5.5
  * @see ExtensionContextStoreConcurrencyTests
@@ -34,8 +36,8 @@ class ExtensionContextStoreTests {
 	private static final String KEY = "key";
 	private static final String VALUE = "value";
 
-	private final ExtensionValuesStore parentStore = new ExtensionValuesStore(null);
-	private final ExtensionValuesStore localStore = new ExtensionValuesStore(parentStore);
+	private final NamespacedHierarchicalStore<Namespace> parentStore = new NamespacedHierarchicalStore<>(null);
+	private final NamespacedHierarchicalStore<Namespace> localStore = new NamespacedHierarchicalStore<>(parentStore);
 	private final Store store = new NamespaceAwareStore(localStore, Namespace.GLOBAL);
 
 	@Test
@@ -53,7 +55,10 @@ class ExtensionContextStoreTests {
 
 		Exception exception = assertThrows(ExtensionContextException.class,
 			() -> store.getOrDefault(KEY, boolean.class, true));
-		assertThat(exception).hasMessageContaining("is not of required type");
+		assertThat(exception) //
+				.hasMessageContaining("is not of required type") //
+				.hasCauseInstanceOf(NamespacedHierarchicalStoreException.class) //
+				.hasStackTraceContaining(NamespacedHierarchicalStore.class.getName());
 	}
 
 	@Test
@@ -83,7 +88,7 @@ class ExtensionContextStoreTests {
 		var e2 = assertThrows(RuntimeException.class, () -> store.get(KEY));
 		assertSame(e1, e2);
 
-		assertDoesNotThrow(localStore::closeAllStoredCloseableValues);
+		assertDoesNotThrow(localStore::close);
 		assertThat(invocations).hasValue(1);
 	}
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java
index d708f2104..da549d491 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java
@@ -34,8 +34,8 @@ import org.junit.jupiter.api.io.CleanupMode;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.api.io.TempDirFactory;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
-import org.junit.jupiter.engine.execution.ExtensionValuesStore;
 import org.junit.jupiter.engine.execution.NamespaceAwareStore;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
 import org.mockito.Mockito;
 
 /**
@@ -56,7 +56,7 @@ class CloseablePathCleanupTests extends AbstractJupiterTestEngineTests {
 
 	@BeforeEach
 	void setUpExtensionContext() {
-		var store = new NamespaceAwareStore(new ExtensionValuesStore(null), Namespace.GLOBAL);
+		var store = new NamespaceAwareStore(new NamespacedHierarchicalStore<>(null), Namespace.GLOBAL);
 		when(extensionContext.getStore(any())).thenReturn(store);
 	}
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTests.java
index 7ec645925..c8d51e798 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocationTests.java
@@ -23,9 +23,9 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout.ThreadMode;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
-import org.junit.jupiter.engine.execution.ExtensionValuesStore;
 import org.junit.jupiter.engine.execution.NamespaceAwareStore;
 import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.TimeoutInvocationParameters;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
 
 /**
  * @since 5.9
@@ -71,7 +71,7 @@ class SeparateThreadTimeoutInvocationTests {
 
 	private static <T> SeparateThreadTimeoutInvocation<T> aSeparateThreadInvocation(Invocation<T> invocation) {
 		var namespace = ExtensionContext.Namespace.create(SeparateThreadTimeoutInvocationTests.class);
-		var store = new NamespaceAwareStore(new ExtensionValuesStore(null), namespace);
+		var store = new NamespaceAwareStore(new NamespacedHierarchicalStore<>(null), namespace);
 		var parameters = new TimeoutInvocationParameters<>(invocation,
 			new TimeoutDuration(PREEMPTIVE_TIMEOUT_MILLIS, MILLISECONDS), () -> "method()");
 		return (SeparateThreadTimeoutInvocation<T>) new TimeoutInvocationFactory(store) //
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTests.java
index a6b2b650a..9d3c46487 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutInvocationFactoryTests.java
@@ -22,10 +22,10 @@ import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ExtensionContext.Store;
 import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
-import org.junit.jupiter.engine.execution.ExtensionValuesStore;
 import org.junit.jupiter.engine.execution.NamespaceAwareStore;
 import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.SingleThreadExecutorResource;
 import org.junit.jupiter.engine.extension.TimeoutInvocationFactory.TimeoutInvocationParameters;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
 import org.mockito.Mock;
 import org.mockito.Spy;
 import org.mockito.junit.jupiter.MockitoExtension;
@@ -35,7 +35,7 @@ import org.mockito.junit.jupiter.MockitoExtension;
 class TimeoutInvocationFactoryTests {
 
 	@Spy
-	private final Store store = new NamespaceAwareStore(new ExtensionValuesStore(null),
+	private final Store store = new NamespaceAwareStore(new NamespacedHierarchicalStore<>(null),
 		ExtensionContext.Namespace.create(TimeoutInvocationFactoryTests.class));
 	@Mock
 	private Invocation<String> invocation;
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
index 12f044db1..40c1eeeec 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
@@ -34,13 +34,13 @@ import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.parallel.ExecutionMode;
-import org.junit.jupiter.engine.execution.ExtensionValuesStore;
 import org.junit.jupiter.engine.execution.NamespaceAwareStore;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.ArgumentsProvider;
 import org.junit.jupiter.params.provider.ArgumentsSource;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
+import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
 
 /**
  * Unit tests for {@link ParameterizedTestExtension}.
@@ -189,7 +189,7 @@ class ParameterizedTestExtensionTests {
 
 		return new ExtensionContext() {
 
-			private final ExtensionValuesStore store = new ExtensionValuesStore(null);
+			private final NamespacedHierarchicalStore<Namespace> store = new NamespacedHierarchicalStore<>(null);
 
 			@Override
 			public Optional<Method> getTestMethod() {
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java
new file mode 100644
index 000000000..79f69ce5e
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStore.java
@@ -0,0 +1,403 @@
+/*
+ * Copyright 2015-2023 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.store;
+
+import static java.util.Comparator.comparing;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+import static org.junit.platform.commons.util.ReflectionUtils.getWrapperType;
+import static org.junit.platform.commons.util.ReflectionUtils.isAssignableTo;
+
+import java.util.Comparator;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.util.ExceptionUtils;
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.commons.util.UnrecoverableExceptions;
+import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
+
+/**
+ * {@code ExtensionValuesStore} is a hierarchical namespaced key-value store.
+ * <p>
+ * Its behavior when closed can be customized by passing a {@link CloseAction}
+ * to {@link #NamespacedHierarchicalStore(NamespacedHierarchicalStore, CloseAction)}.
+ * <p>
+ * This class is thread-safe.
+ *
+ * @param <N> Namespace type
+ * @since 5.10
+ */
+@API(status = EXPERIMENTAL, since = "5.10")
+public class NamespacedHierarchicalStore<N> implements AutoCloseable {
+
+	private final AtomicInteger insertOrderSequence = new AtomicInteger();
+	private final ConcurrentMap<CompositeKey<N>, StoredValue> storedValues = new ConcurrentHashMap<>(4);
+	private final NamespacedHierarchicalStore<N> parentStore;
+	private final CloseAction<N> closeAction;
+
+	/**
+	 * Create a new store with the supplied parent.
+	 *
+	 * @param parentStore The parent store to use for lookups; may be
+	 *                    {@code null}.
+	 */
+	public NamespacedHierarchicalStore(NamespacedHierarchicalStore<N> parentStore) {
+		this(parentStore, null);
+	}
+
+	/**
+	 * Create a new store with the supplied parent and close action.
+	 *
+	 * @param parentStore The parent store to use for lookups; may be
+	 *                    {@code null}.
+	 * @param closeAction The action to be called for each stored value when
+	 *                    this store is closed; may be {@code null}.
+	 */
+	public NamespacedHierarchicalStore(NamespacedHierarchicalStore<N> parentStore, CloseAction<N> closeAction) {
+		this.parentStore = parentStore;
+		this.closeAction = closeAction;
+	}
+
+	public NamespacedHierarchicalStore<N> newChild() {
+		return new NamespacedHierarchicalStore<>(this, closeAction);
+	}
+
+	/**
+	 * If a close action is configured, it will be called with all successfully
+	 * stored values in reverse insertion order.
+	 *
+	 * <p>Closing a store does not close its parent or any of its children.
+	 */
+	@Override
+	public void close() {
+		if (closeAction == null) {
+			return;
+		}
+		ThrowableCollector throwableCollector = new ThrowableCollector(__ -> false);
+		storedValues.entrySet().stream() //
+				.map(e -> e.getValue().evaluateSafely(e.getKey())) //
+				.filter(it -> it != null && it.value != null) //
+				.sorted(EvaluatedValue.REVERSE_INSERT_ORDER) //
+				.forEach(it -> throwableCollector.execute(() -> it.close(closeAction)));
+		throwableCollector.assertEmpty();
+	}
+
+	/**
+	 * Get the value stored for the supplied namespace and key in this or the
+	 * parent store, if present.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @return stored value; may be {@code null}
+	 */
+	public Object get(N namespace, Object key) {
+		StoredValue storedValue = getStoredValue(new CompositeKey<>(namespace, key));
+		return StoredValue.evaluateIfNotNull(storedValue);
+	}
+
+	/**
+	 * Get the value stored for the supplied namespace and key in this or the
+	 * parent store, if present, and cast it to the supplied required type.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @param requiredType the required type of the value; never {@code null}
+	 * @return stored value; may be {@code null}
+	 * @throws NamespacedHierarchicalStoreException if the stored value cannot
+	 *                                              be cast to the required type
+	 */
+	public <T> T get(N namespace, Object key, Class<T> requiredType) {
+		Object value = get(namespace, key);
+		return castToRequiredType(key, value, requiredType);
+	}
+
+	/**
+	 * Get the value stored for the supplied namespace and key in this or the
+	 * parent store, if present, or call the supplied function to compute it.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @param defaultCreator the function called with the supplied {@code key}
+	 * to create a new value; never {@code null} but may return {@code null}
+	 * @return stored value; may be {@code null}
+	 */
+	public <K, V> Object getOrComputeIfAbsent(N namespace, K key, Function<K, V> defaultCreator) {
+		CompositeKey<N> compositeKey = new CompositeKey<>(namespace, key);
+		Preconditions.notNull(defaultCreator, "defaultCreator must not be null");
+		StoredValue storedValue = getStoredValue(compositeKey);
+		if (storedValue == null) {
+			storedValue = storedValues.computeIfAbsent(compositeKey,
+				__ -> storedValue(new MemoizingSupplier(() -> defaultCreator.apply(key))));
+		}
+		return storedValue.evaluate();
+	}
+
+	/**
+	 * Get the value stored for the supplied namespace and key in this or the
+	 * parent store, if present, or call the supplied function to compute it
+	 * and, finally, cast it to the supplied required type.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @param defaultCreator the function called with the supplied {@code key}
+	 * to create a new value; never {@code null} but may return {@code null}
+	 * @param requiredType the required type of the value; never {@code null}
+	 * @return stored value; may be {@code null}
+	 * @throws NamespacedHierarchicalStoreException if the stored value cannot
+	 *                                              be cast to the required type
+	 */
+	public <K, V> V getOrComputeIfAbsent(N namespace, K key, Function<K, V> defaultCreator, Class<V> requiredType) {
+		Object value = getOrComputeIfAbsent(namespace, key, defaultCreator);
+		return castToRequiredType(key, value, requiredType);
+	}
+
+	/**
+	 * Put the supplied value for the supplied namespace and key into this
+	 * store and return the previously associated value in this store.
+	 *
+	 * <p>The {@link CloseAction} will <em>not</em> be called for the previously
+	 * stored value, if any.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @param value the value to store; may be {@code null}
+	 * @return previously stored value; may be {@code null}
+	 * @throws NamespacedHierarchicalStoreException if the stored value cannot
+	 *                                              be cast to the required type
+	 */
+	public Object put(N namespace, Object key, Object value) {
+		StoredValue oldValue = storedValues.put(new CompositeKey<>(namespace, key), storedValue(() -> value));
+		return StoredValue.evaluateIfNotNull(oldValue);
+	}
+
+	/**
+	 * Remove the value stored for the supplied namespace and key from this
+	 * store.
+	 *
+	 * <p>The {@link CloseAction} will <em>not</em> be called for the removed
+	 * value.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @return previously stored value; may be {@code null}
+	 */
+	public Object remove(N namespace, Object key) {
+		StoredValue previous = storedValues.remove(new CompositeKey<>(namespace, key));
+		return StoredValue.evaluateIfNotNull(previous);
+	}
+
+	/**
+	 * Remove the value stored for the supplied namespace and key from this
+	 * store and cast it to the supplied required type.
+	 *
+	 * <p>The {@link CloseAction} will <em>not</em> be called for the removed
+	 * value.
+	 *
+	 * @param namespace the namespace; never {@code null}
+	 * @param key the key; never {@code null}
+	 * @param requiredType the required type of the value; never {@code null}
+	 * @return previously stored value; may be {@code null}
+	 * @throws NamespacedHierarchicalStoreException if the stored value cannot
+	 *                                              be cast to the required type
+	 */
+	public <T> T remove(N namespace, Object key, Class<T> requiredType) {
+		Object value = remove(namespace, key);
+		return castToRequiredType(key, value, requiredType);
+	}
+
+	private StoredValue storedValue(Supplier<Object> value) {
+		return new StoredValue(insertOrderSequence.getAndIncrement(), value);
+	}
+
+	private StoredValue getStoredValue(CompositeKey<N> compositeKey) {
+		StoredValue storedValue = storedValues.get(compositeKey);
+		if (storedValue != null) {
+			return storedValue;
+		}
+		if (parentStore != null) {
+			return parentStore.getStoredValue(compositeKey);
+		}
+		return null;
+	}
+
+	@SuppressWarnings("unchecked")
+	private <T> T castToRequiredType(Object key, Object value, Class<T> requiredType) {
+		Preconditions.notNull(requiredType, "requiredType must not be null");
+		if (value == null) {
+			return null;
+		}
+		if (isAssignableTo(value, requiredType)) {
+			if (requiredType.isPrimitive()) {
+				return (T) getWrapperType(requiredType).cast(value);
+			}
+			return requiredType.cast(value);
+		}
+		// else
+		throw new NamespacedHierarchicalStoreException(
+			String.format("Object stored under key [%s] is not of required type [%s]", key, requiredType.getName()));
+	}
+
+	private static class CompositeKey<N> {
+
+		private final N namespace;
+		private final Object key;
+
+		private CompositeKey(N namespace, Object key) {
+			this.namespace = Preconditions.notNull(namespace, "namespace must not be null");
+			this.key = Preconditions.notNull(key, "key must not be null");
+		}
+
+		@Override
+		public boolean equals(Object o) {
+			if (this == o) {
+				return true;
+			}
+			if (o == null || getClass() != o.getClass()) {
+				return false;
+			}
+			CompositeKey<?> that = (CompositeKey<?>) o;
+			return this.namespace.equals(that.namespace) && this.key.equals(that.key);
+		}
+
+		@Override
+		public int hashCode() {
+			return Objects.hash(namespace, key);
+		}
+
+	}
+
+	private static class StoredValue {
+
+		private final int order;
+		private final Supplier<Object> supplier;
+
+		StoredValue(int order, Supplier<Object> supplier) {
+			this.order = order;
+			this.supplier = supplier;
+		}
+
+		private <N> EvaluatedValue<N> evaluateSafely(CompositeKey<N> compositeKey) {
+			try {
+				return new EvaluatedValue<>(compositeKey, order, evaluate());
+			}
+			catch (Throwable t) {
+				UnrecoverableExceptions.rethrowIfUnrecoverable(t);
+				return null;
+			}
+		}
+
+		private Object evaluate() {
+			return supplier.get();
+		}
+
+		static Object evaluateIfNotNull(StoredValue value) {
+			return value != null ? value.evaluate() : null;
+		}
+
+	}
+
+	private static class EvaluatedValue<N> {
+
+		private static final Comparator<EvaluatedValue<?>> REVERSE_INSERT_ORDER = comparing(
+			(EvaluatedValue<?> it) -> it.order).reversed();
+
+		private final CompositeKey<N> compositeKey;
+		private final int order;
+		private final Object value;
+
+		EvaluatedValue(CompositeKey<N> key, int order, Object value) {
+			this.compositeKey = key;
+			this.order = order;
+			this.value = value;
+		}
+
+		void close(CloseAction<N> closeAction) throws Throwable {
+			closeAction.close(compositeKey.namespace, compositeKey.key, value);
+		}
+	}
+
+	/**
+	 * Thread-safe {@link Supplier} that memoizes the result of calling its
+	 * delegate and ensures it is called at most once.
+	 *
+	 * <p>If the delegate throws an exception, it is stored and rethrown every
+	 * time {@link #get()} is called.
+	 *
+	 * @see StoredValue
+	 */
+	private static class MemoizingSupplier implements Supplier<Object> {
+
+		private static final Object NO_VALUE_SET = new Object();
+
+		private final Supplier<Object> delegate;
+		private volatile Object value = NO_VALUE_SET;
+
+		private MemoizingSupplier(Supplier<Object> delegate) {
+			this.delegate = delegate;
+		}
+
+		@Override
+		public Object get() {
+			if (value == NO_VALUE_SET) {
+				computeValue();
+			}
+			if (value instanceof Failure) {
+				ExceptionUtils.throwAsUncheckedException(((Failure) value).throwable);
+			}
+			return value;
+		}
+
+		private synchronized void computeValue() {
+			try {
+				if (value == NO_VALUE_SET) {
+					value = delegate.get();
+				}
+			}
+			catch (Throwable t) {
+				value = new Failure(t);
+				UnrecoverableExceptions.rethrowIfUnrecoverable(t);
+			}
+		}
+
+		private static class Failure {
+
+			private final Throwable throwable;
+
+			public Failure(Throwable throwable) {
+				this.throwable = throwable;
+			}
+		}
+
+	}
+
+	/**
+	 * Called for each successfully stored non-null value in when closing a
+	 * {@link NamespacedHierarchicalStore}.
+	 */
+	@FunctionalInterface
+	public interface CloseAction<N> {
+
+		/**
+		 * Close the supplied {@code value}.
+		 *
+		 * @param namespace the namespace; never {@code null}
+		 * @param key the key; never {@code null}
+		 * @param value the value; never {@code null}
+		 */
+		void close(N namespace, Object key, Object value) throws Throwable;
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreException.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreException.java
new file mode 100644
index 000000000..93be77040
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreException.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015-2023 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.store;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.JUnitException;
+
+/**
+ * Exception thrown by failed {@link NamespacedHierarchicalStore} operations.
+ *
+ * @since 5.10
+ */
+@API(status = EXPERIMENTAL, since = "5.10")
+public class NamespacedHierarchicalStoreException extends JUnitException {
+
+	private static final long serialVersionUID = 1L;
+
+	public NamespacedHierarchicalStoreException(String message) {
+		super(message);
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/package-info.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/package-info.java
new file mode 100644
index 000000000..d40e1e88e
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/store/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * Reusable data structures for test engines and their extensions.
+ */
+
+package org.junit.platform.engine.support.store;
diff --git a/junit-platform-engine/src/module/org.junit.platform.engine/module-info.java b/junit-platform-engine/src/module/org.junit.platform.engine/module-info.java
index 0b6336c6b..46c206944 100644
--- a/junit-platform-engine/src/module/org.junit.platform.engine/module-info.java
+++ b/junit-platform-engine/src/module/org.junit.platform.engine/module-info.java
@@ -30,4 +30,5 @@ module org.junit.platform.engine {
 	exports org.junit.platform.engine.support.discovery;
 	exports org.junit.platform.engine.support.filter;
 	exports org.junit.platform.engine.support.hierarchical;
+	exports org.junit.platform.engine.support.store;
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionValuesStoreTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java
similarity index 70%
rename from junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionValuesStoreTests.java
rename to platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java
index 04d6fc009..966c8a9f4 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionValuesStoreTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/store/NamespacedHierarchicalStoreTests.java
@@ -8,14 +8,20 @@
  * https://www.eclipse.org/legal/epl-v20.html
  */
 
-package org.junit.jupiter.engine.execution;
+package org.junit.platform.engine.support.store;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.platform.commons.test.ConcurrencyTestingUtils.executeConcurrently;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -23,25 +29,24 @@ import java.util.function.Function;
 
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
-import org.junit.jupiter.api.extension.ExtensionContextException;
 
 /**
- * Unit tests for {@link ExtensionValuesStore}.
+ * Unit tests for {@link NamespacedHierarchicalStore}.
  *
  * @since 5.0
- * @see org.junit.jupiter.engine.descriptor.ExtensionContextTests
  */
-public class ExtensionValuesStoreTests {
+public class NamespacedHierarchicalStoreTests {
 
 	private final Object key = "key";
 	private final Object value = "value";
 
-	private final Namespace namespace = Namespace.create("ns");
+	private final String namespace = "ns";
 
-	private final ExtensionValuesStore grandParentStore = new ExtensionValuesStore(null);
-	private final ExtensionValuesStore parentStore = new ExtensionValuesStore(grandParentStore);
-	private final ExtensionValuesStore store = new ExtensionValuesStore(parentStore);
+	private final NamespacedHierarchicalStore.CloseAction<String> closeAction = mock();
+	private final NamespacedHierarchicalStore<String> grandParentStore = new NamespacedHierarchicalStore<>(null,
+		closeAction);
+	private final NamespacedHierarchicalStore<String> parentStore = grandParentStore.newChild();
+	private final NamespacedHierarchicalStore<String> store = parentStore.newChild();
 
 	@Nested
 	class StoringValuesTests {
@@ -62,7 +67,7 @@ public class ExtensionValuesStoreTests {
 			store.put(namespace, key, value);
 
 			Object newValue = new Object();
-			store.put(namespace, key, newValue);
+			assertEquals(value, store.put(namespace, key, newValue));
 
 			assertEquals(newValue, store.get(namespace, key));
 		}
@@ -119,10 +124,10 @@ public class ExtensionValuesStoreTests {
 		@Test
 		void sameKeyWithDifferentNamespaces() {
 			Object value1 = createObject("value1");
-			Namespace namespace1 = Namespace.create("ns1");
+			String namespace1 = "ns1";
 
 			Object value2 = createObject("value2");
-			Namespace namespace2 = Namespace.create("ns2");
+			String namespace2 = "ns2";
 
 			store.put(namespace1, key, value1);
 			store.put(namespace2, key, value2);
@@ -133,8 +138,8 @@ public class ExtensionValuesStoreTests {
 
 		@Test
 		void valueIsComputedIfAbsentInDifferentNamespace() {
-			Namespace namespace1 = Namespace.create("ns1");
-			Namespace namespace2 = Namespace.create("ns2");
+			String namespace1 = "ns1";
+			String namespace2 = "ns2";
 
 			assertEquals(value, store.getOrComputeIfAbsent(namespace1, key, innerKey -> value));
 			assertEquals(value, store.get(namespace1, key));
@@ -144,8 +149,8 @@ public class ExtensionValuesStoreTests {
 
 		@Test
 		void keyIsOnlyRemovedInGivenNamespace() {
-			Namespace namespace1 = Namespace.create("ns1");
-			Namespace namespace2 = Namespace.create("ns2");
+			String namespace1 = "ns1";
+			String namespace2 = "ns2";
 
 			Object value1 = createObject("value1");
 			Object value2 = createObject("value2");
@@ -164,7 +169,7 @@ public class ExtensionValuesStoreTests {
 			String value = "enigma";
 			store.put(namespace, key, value);
 
-			Exception exception = assertThrows(ExtensionContextException.class,
+			Exception exception = assertThrows(NamespacedHierarchicalStoreException.class,
 				() -> store.get(namespace, key, Number.class));
 			assertEquals("Object stored under key [42] is not of required type [java.lang.Number]",
 				exception.getMessage());
@@ -214,7 +219,7 @@ public class ExtensionValuesStoreTests {
 			// But declare that our function creates a String...
 			Function<String, String> defaultCreator = k -> "enigma";
 
-			Exception exception = assertThrows(ExtensionContextException.class,
+			Exception exception = assertThrows(NamespacedHierarchicalStoreException.class,
 				() -> store.getOrComputeIfAbsent(namespace, key, defaultCreator, String.class));
 			assertEquals("Object stored under key [pi] is not of required type [java.lang.String]",
 				exception.getMessage());
@@ -242,13 +247,22 @@ public class ExtensionValuesStoreTests {
 			assertEquals(value, computedInteger.intValue());
 		}
 
+		@Test
+		void getOrComputeIfAbsentWithExceptionThrowingCreatorFunction() {
+			var e = assertThrows(RuntimeException.class, () -> store.getOrComputeIfAbsent(namespace, key, __ -> {
+				throw new RuntimeException("boom");
+			}));
+			assertSame(e, assertThrows(RuntimeException.class, () -> store.get(namespace, key)));
+			assertSame(e, assertThrows(RuntimeException.class, () -> store.remove(namespace, key)));
+		}
+
 		@Test
 		void removeWithTypeSafetyAndInvalidRequiredTypeThrowsException() {
 			Integer key = 42;
 			String value = "enigma";
 			store.put(namespace, key, value);
 
-			Exception exception = assertThrows(ExtensionContextException.class,
+			Exception exception = assertThrows(NamespacedHierarchicalStoreException.class,
 				() -> store.remove(namespace, key, Number.class));
 			assertEquals("Object stored under key [42] is not of required type [java.lang.Number]",
 				exception.getMessage());
@@ -297,10 +311,12 @@ public class ExtensionValuesStoreTests {
 		void simulateRaceConditionInGetOrComputeIfAbsent() throws Exception {
 			int threads = 10;
 			AtomicInteger counter = new AtomicInteger();
-			ExtensionValuesStore localStore = new ExtensionValuesStore(null);
+			List<Object> values;
 
-			List<Object> values = executeConcurrently(threads, //
-				() -> localStore.getOrComputeIfAbsent(namespace, key, it -> counter.incrementAndGet()));
+			try (var localStore = new NamespacedHierarchicalStore<>(null)) {
+				values = executeConcurrently(threads, //
+					() -> localStore.getOrComputeIfAbsent(namespace, key, it -> counter.incrementAndGet()));
+			}
 
 			assertEquals(1, counter.get());
 			assertThat(values).hasSize(threads).containsOnly(1);
@@ -332,38 +348,90 @@ public class ExtensionValuesStoreTests {
 	class CompositeNamespaceTests {
 
 		@Test
-		void namespacesEqualForSamePartsSequence() {
-			Namespace ns1 = Namespace.create("part1", "part2");
-			Namespace ns2 = Namespace.create("part1", "part2");
+		void additionNamespacePartMakesADifference() {
+
+			String ns1 = "part1/part2";
+			String ns2 = "part1";
+
+			Object value2 = createObject("value2");
+
+			parentStore.put(ns1, key, value);
+			parentStore.put(ns2, key, value2);
 
-			assertEquals(ns1, ns2);
+			assertEquals(value, store.get(ns1, key));
+			assertEquals(value2, store.get(ns2, key));
+		}
+
+	}
+
+	@Nested
+	class CloseActionTests {
+
+		@Test
+		void callsCloseActionInReverseInsertionOrderWhenClosingStore() throws Throwable {
+			store.put(namespace, "key1", "value1");
+			store.put(namespace, "key2", "value2");
+			store.put(namespace, "key3", "value3");
+			verifyNoInteractions(closeAction);
+
+			store.close();
+			var inOrder = inOrder(closeAction);
+			inOrder.verify(closeAction).close(namespace, "key3", "value3");
+			inOrder.verify(closeAction).close(namespace, "key2", "value2");
+			inOrder.verify(closeAction).close(namespace, "key1", "value1");
 		}
 
 		@Test
-		void orderOfNamespacePartsDoesMatter() {
-			Namespace ns1 = Namespace.create("part1", "part2");
-			Namespace ns2 = Namespace.create("part2", "part1");
+		void doesNotCallCloseActionForRemovedValues() {
+			store.put(namespace, key, value);
+			store.remove(namespace, key);
 
-			assertNotEquals(ns1, ns2);
+			store.close();
+
+			verifyNoInteractions(closeAction);
 		}
 
 		@Test
-		void additionNamespacePartMakesADifference() {
+		void doesNotCallCloseActionForReplacedValues() throws Throwable {
+			store.put(namespace, key, "value1");
+			store.put(namespace, key, "value2");
 
-			Namespace ns1 = Namespace.create("part1", "part2");
-			Namespace ns2 = Namespace.create("part1");
-			Namespace ns3 = Namespace.create("part1", "part2");
+			store.close();
 
-			Object value2 = createObject("value2");
+			verify(closeAction).close(namespace, key, "value2");
+			verifyNoMoreInteractions(closeAction);
+		}
 
-			parentStore.put(ns1, key, value);
-			parentStore.put(ns2, key, value2);
+		@Test
+		void doesNotCallCloseActionForNullValues() {
+			store.put(namespace, key, null);
 
-			assertEquals(value, store.get(ns1, key));
-			assertEquals(value, store.get(ns3, key));
-			assertEquals(value2, store.get(ns2, key));
+			store.close();
+
+			verifyNoInteractions(closeAction);
+		}
+
+		@Test
+		void ignoresStoredValuesThatThrewExceptionsDuringCleanup() {
+			assertThrows(RuntimeException.class, () -> store.getOrComputeIfAbsent(namespace, key, __ -> {
+				throw new RuntimeException("boom");
+			}));
+
+			assertDoesNotThrow(store::close);
+
+			verifyNoInteractions(closeAction);
 		}
 
+		@Test
+		void doesNotIgnoreStoredValuesThatThrewUnrecoverableFailuresDuringCleanup() {
+			assertThrows(OutOfMemoryError.class, () -> store.getOrComputeIfAbsent(namespace, key, __ -> {
+				throw new OutOfMemoryError();
+			}));
+
+			assertThrows(OutOfMemoryError.class, store::close);
+
+			verifyNoInteractions(closeAction);
+		}
 	}
 
 	private Object createObject(final String display) {
diff --git a/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt b/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt
index d6f696269..956d78094 100644
--- a/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt
+++ b/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt
@@ -7,6 +7,7 @@ exports org.junit.platform.engine.support.descriptor
 exports org.junit.platform.engine.support.discovery
 exports org.junit.platform.engine.support.filter
 exports org.junit.platform.engine.support.hierarchical
+exports org.junit.platform.engine.support.store
 requires java.base mandated
 requires org.apiguardian.api static transitive
 requires org.junit.platform.commons transitive
