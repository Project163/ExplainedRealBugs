diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc
index 1b91656b8..89ed5c17d 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc
@@ -86,6 +86,10 @@ on GitHub.
   details).
 * A custom test source for a `DynamicContainer` or `DynamicTest` may now be a method URI
   -- for example, `method:org.example.MyTestClass#myTestMethod()`.
+* New `junit.jupiter.execution.parallel.mode.classes.default` configuration parameter
+  allows to run top-level classes in parallel but their methods sequentially or vice versa
+  (see <<../user-guide/index.adoc#writing-tests-parallel-execution, User Guide>> for
+  details).
 
 
 [[release-notes-5.5.0-RC1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 7443878e7..a4e173e1a 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1715,6 +1715,33 @@ declarative <<writing-tests-parallel-execution-synchronization, synchronization>
 mechanism. Please note that <<running-tests-capturing-output>> needs to be enabled
 separately.
 
+In addition, you can configure the default execution mode for top-level classes by setting
+the `junit.jupiter.execution.parallel.mode.classes.default` configuration parameter. By
+combining both configuration parameters, you can configure classes to run in parallel but
+their methods in the same thread:
+
+[source,properties]
+.Configuration parameters to execute top-level classes in parallel but methods in same thread
+----
+junit.jupiter.execution.parallel.enabled = true
+junit.jupiter.execution.parallel.mode.default = same_thread
+junit.jupiter.execution.parallel.mode.classes.default = concurrent
+----
+
+The opposite combination will run all methods within one class in parallel, but top-level
+classes will run sequentially:
+
+[source,properties]
+.Configuration parameters to execute top-level classes in sequentially but their methods in parallel
+----
+junit.jupiter.execution.parallel.enabled = true
+junit.jupiter.execution.parallel.mode.default = concurrent
+junit.jupiter.execution.parallel.mode.classes.default = same_thread
+----
+
+Not configuring a value for `junit.jupiter.execution.parallel.mode.classes.default` is
+equivalent to using the same value as for `junit.jupiter.execution.parallel.mode.default`.
+
 [[writing-tests-parallel-execution-config]]
 ==== Configuration
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
index fc35e5514..113f25e55 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
@@ -135,7 +135,7 @@ public final class Constants {
 	public static final String PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME = JupiterConfiguration.PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME;
 
 	/**
-	 * Property name used to set the default parallel test execution mode: {@value}
+	 * Property name used to set the default test execution mode: {@value}
 	 *
 	 * <p>This setting is only effective if parallel execution is enabled.
 	 *
@@ -154,6 +154,27 @@ public final class Constants {
 	@API(status = EXPERIMENTAL, since = "5.4")
 	public static final String DEFAULT_PARALLEL_EXECUTION_MODE = JupiterConfiguration.DEFAULT_EXECUTION_MODE_PROPERTY_NAME;
 
+	/**
+	 * Property name used to set the default test execution mode for top-level
+	 * classes: {@value}
+	 *
+	 * <p>This setting is only effective if parallel execution is enabled.
+	 *
+	 * <h3>Supported Values</h3>
+	 *
+	 * <p>Supported values include names of enum constants defined in
+	 * {@link org.junit.jupiter.api.parallel.ExecutionMode}, ignoring case.
+	 *
+	 * <p>If not specified, it will be resolve into the same value as
+	 * {@link #DEFAULT_PARALLEL_EXECUTION_MODE}.
+	 *
+	 * @see org.junit.jupiter.api.parallel.Execution
+	 * @see org.junit.jupiter.api.parallel.ExecutionMode
+	 * @since 5.4
+	 */
+	@API(status = EXPERIMENTAL, since = "5.5")
+	public static final String DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME = JupiterConfiguration.DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME;
+
 	static final String PARALLEL_CONFIG_PREFIX = "junit.jupiter.execution.parallel.config.";
 
 	/**
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/CachingJupiterConfiguration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/CachingJupiterConfiguration.java
index dc53033cc..077d4bd39 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/CachingJupiterConfiguration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/CachingJupiterConfiguration.java
@@ -60,6 +60,12 @@ public class CachingJupiterConfiguration implements JupiterConfiguration {
 			key -> delegate.getDefaultExecutionMode());
 	}
 
+	@Override
+	public ExecutionMode getDefaultClassesExecutionMode() {
+		return (ExecutionMode) cache.computeIfAbsent(DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME,
+			key -> delegate.getDefaultClassesExecutionMode());
+	}
+
 	@Override
 	public TestInstance.Lifecycle getDefaultTestInstanceLifecycle() {
 		return (TestInstance.Lifecycle) cache.computeIfAbsent(DEFAULT_TEST_INSTANCE_LIFECYCLE_PROPERTY_NAME,
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java
index 00e43ee02..44767d8a1 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java
@@ -68,6 +68,12 @@ public class DefaultJupiterConfiguration implements JupiterConfiguration {
 			ExecutionMode.SAME_THREAD);
 	}
 
+	@Override
+	public ExecutionMode getDefaultClassesExecutionMode() {
+		return executionModeConverter.get(configurationParameters, DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME,
+			getDefaultExecutionMode());
+	}
+
 	@Override
 	public Lifecycle getDefaultTestInstanceLifecycle() {
 		return lifecycleConverter.get(configurationParameters, DEFAULT_TEST_INSTANCE_LIFECYCLE_PROPERTY_NAME,
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java
index 474a1c4dd..67b31bebb 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java
@@ -30,6 +30,7 @@ public interface JupiterConfiguration {
 	String DEACTIVATE_CONDITIONS_PATTERN_PROPERTY_NAME = "junit.jupiter.conditions.deactivate";
 	String PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME = "junit.jupiter.execution.parallel.enabled";
 	String DEFAULT_EXECUTION_MODE_PROPERTY_NAME = "junit.jupiter.execution.parallel.mode.default";
+	String DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME = "junit.jupiter.execution.parallel.mode.classes.default";
 	String EXTENSIONS_AUTODETECTION_ENABLED_PROPERTY_NAME = "junit.jupiter.extensions.autodetection.enabled";
 	String DEFAULT_TEST_INSTANCE_LIFECYCLE_PROPERTY_NAME = "junit.jupiter.testinstance.lifecycle.default";
 	String DEACTIVATE_ALL_CONDITIONS_PATTERN = ClassNamePatternParameterConverter.DEACTIVATE_ALL_PATTERN;
@@ -54,6 +55,8 @@ public interface JupiterConfiguration {
 
 	ExecutionMode getDefaultExecutionMode();
 
+	ExecutionMode getDefaultClassesExecutionMode();
+
 	TestInstance.Lifecycle getDefaultTestInstanceLifecycle();
 
 	Predicate<ExecutionCondition> getExecutionConditionFilter();
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
new file mode 100644
index 000000000..4a39f1eeb
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -0,0 +1,439 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static java.util.stream.Collectors.joining;
+import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.jupiter.engine.descriptor.ExtensionUtils.populateNewExtensionRegistryFromExtendWithAnnotation;
+import static org.junit.jupiter.engine.descriptor.ExtensionUtils.registerExtensionsFromFields;
+import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterAllMethods;
+import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterEachMethods;
+import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeAllMethods;
+import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeEachMethods;
+import static org.junit.jupiter.engine.descriptor.TestInstanceLifecycleUtils.getTestInstanceLifecycle;
+import static org.junit.jupiter.engine.support.JupiterThrowableCollectorFactory.createThrowableCollector;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.AfterAllCallback;
+import org.junit.jupiter.api.extension.BeforeAllCallback;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionConfigurationException;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.TestInstanceFactory;
+import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstances;
+import org.junit.jupiter.api.extension.TestInstantiationException;
+import org.junit.jupiter.api.function.Executable;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.AfterEachMethodAdapter;
+import org.junit.jupiter.engine.execution.BeforeEachMethodAdapter;
+import org.junit.jupiter.engine.execution.DefaultTestInstances;
+import org.junit.jupiter.engine.execution.ExecutableInvoker;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall.VoidMethodInterceptorCall;
+import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.execution.TestInstancesProvider;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.BlacklistedExceptions;
+import org.junit.platform.commons.util.ExceptionUtils;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.StringUtils;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestTag;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.descriptor.ClassSource;
+import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
+import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
+
+/**
+ * {@link TestDescriptor} for tests based on Java classes.
+ *
+ * @since 5.5
+ */
+@API(status = INTERNAL, since = "5.5")
+public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
+
+	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
+
+	private final Class<?> testClass;
+	protected final Set<TestTag> tags;
+	protected final Lifecycle lifecycle;
+
+	private ExecutionMode defaultChildExecutionMode;
+	private TestInstanceFactory testInstanceFactory;
+	private List<Method> beforeAllMethods;
+	private List<Method> afterAllMethods;
+
+	ClassBasedTestDescriptor(UniqueId uniqueId, Class<?> testClass, Supplier<String> displayNameSupplier,
+			JupiterConfiguration configuration) {
+		super(uniqueId, testClass, displayNameSupplier, ClassSource.from(testClass), configuration);
+
+		this.testClass = testClass;
+		this.tags = getTags(testClass);
+		this.lifecycle = getTestInstanceLifecycle(testClass, configuration);
+		this.defaultChildExecutionMode = (this.lifecycle == Lifecycle.PER_CLASS ? ExecutionMode.SAME_THREAD : null);
+	}
+
+	// --- TestDescriptor ------------------------------------------------------
+
+	public final Class<?> getTestClass() {
+		return this.testClass;
+	}
+
+	@Override
+	public Type getType() {
+		return Type.CONTAINER;
+	}
+
+	@Override
+	public String getLegacyReportingName() {
+		return this.testClass.getName();
+	}
+
+	// --- Node ----------------------------------------------------------------
+
+	@Override
+	protected Optional<ExecutionMode> getExplicitExecutionMode() {
+		return getExecutionModeFromAnnotation(getTestClass());
+	}
+
+	@Override
+	protected Optional<ExecutionMode> getDefaultChildExecutionMode() {
+		return Optional.ofNullable(this.defaultChildExecutionMode);
+	}
+
+	public void setDefaultChildExecutionMode(ExecutionMode defaultChildExecutionMode) {
+		this.defaultChildExecutionMode = defaultChildExecutionMode;
+	}
+
+	@Override
+	public Set<ExclusiveResource> getExclusiveResources() {
+		return getExclusiveResourcesFromAnnotation(getTestClass());
+	}
+
+	@Override
+	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
+		ExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
+			context.getExtensionRegistry(), this.testClass);
+
+		// Register extensions from static fields here, at the class level but
+		// after extensions registered via @ExtendWith.
+		registerExtensionsFromFields(registry, this.testClass, null);
+
+		// Resolve the TestInstanceFactory at the class level in order to fail
+		// the entire class in case of configuration errors (e.g., more than
+		// one factory registered per class).
+		this.testInstanceFactory = resolveTestInstanceFactory(registry);
+
+		registerBeforeEachMethodAdapters(registry);
+		registerAfterEachMethodAdapters(registry);
+
+		ThrowableCollector throwableCollector = createThrowableCollector();
+		ClassExtensionContext extensionContext = new ClassExtensionContext(context.getExtensionContext(),
+			context.getExecutionListener(), this, this.lifecycle, context.getConfiguration(), throwableCollector);
+
+		this.beforeAllMethods = findBeforeAllMethods(this.testClass, this.lifecycle == Lifecycle.PER_METHOD);
+		this.afterAllMethods = findAfterAllMethods(this.testClass, this.lifecycle == Lifecycle.PER_METHOD);
+
+		// @formatter:off
+		return context.extend()
+				.withTestInstancesProvider(testInstancesProvider(context, registry, extensionContext))
+				.withExtensionRegistry(registry)
+				.withExtensionContext(extensionContext)
+				.withThrowableCollector(throwableCollector)
+				.build();
+		// @formatter:on
+	}
+
+	@Override
+	public JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+
+		Lifecycle lifecycle = context.getExtensionContext().getTestInstanceLifecycle().orElse(Lifecycle.PER_METHOD);
+		if (lifecycle == Lifecycle.PER_CLASS) {
+			// Eagerly load test instance for BeforeAllCallbacks, if necessary,
+			// and store the instance in the ExtensionContext.
+			ClassExtensionContext extensionContext = (ClassExtensionContext) context.getExtensionContext();
+			throwableCollector.execute(() -> extensionContext.setTestInstances(
+				context.getTestInstancesProvider().getTestInstances(Optional.empty())));
+		}
+
+		if (throwableCollector.isEmpty()) {
+			context.beforeAllCallbacksExecuted(true);
+			invokeBeforeAllCallbacks(context);
+
+			if (throwableCollector.isEmpty()) {
+				context.beforeAllMethodsExecuted(true);
+				invokeBeforeAllMethods(context);
+			}
+		}
+
+		throwableCollector.assertEmpty();
+
+		return context;
+	}
+
+	@Override
+	public void after(JupiterEngineExecutionContext context) {
+
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+		Throwable previousThrowable = throwableCollector.getThrowable();
+
+		if (context.beforeAllMethodsExecuted()) {
+			invokeAfterAllMethods(context);
+		}
+
+		if (context.beforeAllCallbacksExecuted()) {
+			invokeAfterAllCallbacks(context);
+		}
+
+		// If the previous Throwable was not null when this method was called,
+		// that means an exception was already thrown either before or during
+		// the execution of this Node. If an exception was already thrown, any
+		// later exceptions were added as suppressed exceptions to that original
+		// exception unless a more severe exception occurred in the meantime.
+		if (previousThrowable != throwableCollector.getThrowable()) {
+			throwableCollector.assertEmpty();
+		}
+	}
+
+	private TestInstanceFactory resolveTestInstanceFactory(ExtensionRegistry registry) {
+		List<TestInstanceFactory> factories = registry.getExtensions(TestInstanceFactory.class);
+
+		if (factories.size() == 1) {
+			return factories.get(0);
+		}
+
+		if (factories.size() > 1) {
+			String factoryNames = factories.stream()//
+					.map(factory -> factory.getClass().getName())//
+					.collect(joining(", "));
+
+			String errorMessage = String.format(
+				"The following TestInstanceFactory extensions were registered for test class [%s], but only one is permitted: %s",
+				testClass.getName(), factoryNames);
+
+			throw new ExtensionConfigurationException(errorMessage);
+		}
+
+		return null;
+	}
+
+	private TestInstancesProvider testInstancesProvider(JupiterEngineExecutionContext parentExecutionContext,
+			ExtensionRegistry registry, ClassExtensionContext extensionContext) {
+
+		TestInstancesProvider testInstancesProvider = childRegistry -> instantiateAndPostProcessTestInstance(
+			parentExecutionContext, extensionContext, childRegistry.orElse(registry));
+
+		return childRegistry -> extensionContext.getTestInstances().orElseGet(
+			() -> testInstancesProvider.getTestInstances(childRegistry));
+	}
+
+	private TestInstances instantiateAndPostProcessTestInstance(JupiterEngineExecutionContext parentExecutionContext,
+			ExtensionContext extensionContext, ExtensionRegistry registry) {
+
+		TestInstances instances = instantiateTestClass(parentExecutionContext, registry, extensionContext);
+		invokeTestInstancePostProcessors(instances.getInnermostInstance(), registry, extensionContext);
+		// In addition, we register extensions from instance fields here since the
+		// best time to do that is immediately following test class instantiation
+		// and post processing.
+		registerExtensionsFromFields(registry, this.testClass, instances.getInnermostInstance());
+		return instances;
+	}
+
+	protected abstract TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
+			ExtensionRegistry registry, ExtensionContext extensionContext);
+
+	protected TestInstances instantiateTestClass(Optional<TestInstances> outerInstances, ExtensionRegistry registry,
+			ExtensionContext extensionContext) {
+
+		Optional<Object> outerInstance = outerInstances.map(TestInstances::getInnermostInstance);
+		Object instance = this.testInstanceFactory != null //
+				? invokeTestInstanceFactory(outerInstance, extensionContext) //
+				: invokeTestClassConstructor(outerInstance, registry, extensionContext);
+		return outerInstances.map(instances -> DefaultTestInstances.of(instances, instance)).orElse(
+			DefaultTestInstances.of(instance));
+	}
+
+	private Object invokeTestInstanceFactory(Optional<Object> outerInstance, ExtensionContext extensionContext) {
+		Object instance;
+
+		try {
+			instance = this.testInstanceFactory.createTestInstance(
+				new DefaultTestInstanceFactoryContext(this.testClass, outerInstance), extensionContext);
+		}
+		catch (Throwable throwable) {
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+
+			if (throwable instanceof TestInstantiationException) {
+				throw (TestInstantiationException) throwable;
+			}
+
+			String message = String.format("TestInstanceFactory [%s] failed to instantiate test class [%s]",
+				this.testInstanceFactory.getClass().getName(), this.testClass.getName());
+			if (StringUtils.isNotBlank(throwable.getMessage())) {
+				message += ": " + throwable.getMessage();
+			}
+			throw new TestInstantiationException(message, throwable);
+		}
+
+		if (!this.testClass.isInstance(instance)) {
+			String testClassName = this.testClass.getName();
+			Class<?> instanceClass = (instance == null ? null : instance.getClass());
+			String instanceClassName = (instanceClass == null ? "null" : instanceClass.getName());
+
+			// If the test instance was loaded via a different ClassLoader, append
+			// the identity hash codes to the type names to help users disambiguate
+			// between otherwise identical "fully qualified class names".
+			if (testClassName.equals(instanceClassName)) {
+				testClassName += "@" + Integer.toHexString(System.identityHashCode(this.testClass));
+				instanceClassName += "@" + Integer.toHexString(System.identityHashCode(instanceClass));
+			}
+			String message = String.format(
+				"TestInstanceFactory [%s] failed to return an instance of [%s] and instead returned an instance of [%s].",
+				this.testInstanceFactory.getClass().getName(), testClassName, instanceClassName);
+
+			throw new TestInstantiationException(message);
+		}
+
+		return instance;
+	}
+
+	private Object invokeTestClassConstructor(Optional<Object> outerInstance, ExtensionRegistry registry,
+			ExtensionContext extensionContext) {
+
+		Constructor<?> constructor = ReflectionUtils.getDeclaredConstructor(this.testClass);
+		return executableInvoker.invoke(constructor, outerInstance, extensionContext, registry,
+			InvocationInterceptor::interceptTestClassConstructor);
+	}
+
+	private void invokeTestInstancePostProcessors(Object instance, ExtensionRegistry registry,
+			ExtensionContext context) {
+
+		registry.stream(TestInstancePostProcessor.class).forEach(
+			extension -> executeAndMaskThrowable(() -> extension.postProcessTestInstance(instance, context)));
+	}
+
+	private void executeAndMaskThrowable(Executable executable) {
+		try {
+			executable.execute();
+		}
+		catch (Throwable throwable) {
+			ExceptionUtils.throwAsUncheckedException(throwable);
+		}
+	}
+
+	private void invokeBeforeAllCallbacks(JupiterEngineExecutionContext context) {
+		ExtensionRegistry registry = context.getExtensionRegistry();
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+
+		for (BeforeAllCallback callback : registry.getExtensions(BeforeAllCallback.class)) {
+			throwableCollector.execute(() -> callback.beforeAll(extensionContext));
+			if (throwableCollector.isNotEmpty()) {
+				break;
+			}
+		}
+	}
+
+	private void invokeBeforeAllMethods(JupiterEngineExecutionContext context) {
+		ExtensionRegistry registry = context.getExtensionRegistry();
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+		Object testInstance = extensionContext.getTestInstance().orElse(null);
+
+		for (Method method : this.beforeAllMethods) {
+			throwableCollector.execute(() -> executableInvoker.invoke(method, testInstance, extensionContext, registry,
+				ReflectiveInterceptorCall.ofVoidMethod(InvocationInterceptor::interceptBeforeAllMethod)));
+			if (throwableCollector.isNotEmpty()) {
+				break;
+			}
+		}
+	}
+
+	private void invokeAfterAllMethods(JupiterEngineExecutionContext context) {
+		ExtensionRegistry registry = context.getExtensionRegistry();
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+		Object testInstance = extensionContext.getTestInstance().orElse(null);
+
+		this.afterAllMethods.forEach(
+			method -> throwableCollector.execute(() -> executableInvoker.invoke(method, testInstance, extensionContext,
+				registry, ReflectiveInterceptorCall.ofVoidMethod(InvocationInterceptor::interceptAfterAllMethod))));
+	}
+
+	private void invokeAfterAllCallbacks(JupiterEngineExecutionContext context) {
+		ExtensionRegistry registry = context.getExtensionRegistry();
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+
+		registry.getReversedExtensions(AfterAllCallback.class)//
+				.forEach(extension -> throwableCollector.execute(() -> extension.afterAll(extensionContext)));
+	}
+
+	private void registerBeforeEachMethodAdapters(ExtensionRegistry registry) {
+		List<Method> beforeEachMethods = findBeforeEachMethods(this.testClass);
+		registerMethodsAsExtensions(beforeEachMethods, registry, this::synthesizeBeforeEachMethodAdapter);
+	}
+
+	private void registerAfterEachMethodAdapters(ExtensionRegistry registry) {
+		// Make a local copy since findAfterEachMethods() returns an immutable list.
+		List<Method> afterEachMethods = new ArrayList<>(findAfterEachMethods(this.testClass));
+
+		// Since the bottom-up ordering of afterEachMethods will later be reversed when the
+		// synthesized AfterEachMethodAdapters are executed within TestMethodTestDescriptor,
+		// we have to reverse the afterEachMethods list to put them in top-down order before
+		// we register them as synthesized extensions.
+		Collections.reverse(afterEachMethods);
+
+		registerMethodsAsExtensions(afterEachMethods, registry, this::synthesizeAfterEachMethodAdapter);
+	}
+
+	private void registerMethodsAsExtensions(List<Method> methods, ExtensionRegistry registry,
+			Function<Method, Extension> extensionSynthesizer) {
+
+		methods.forEach(method -> registry.registerExtension(extensionSynthesizer.apply(method), method));
+	}
+
+	private BeforeEachMethodAdapter synthesizeBeforeEachMethodAdapter(Method method) {
+		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry,
+			InvocationInterceptor::interceptBeforeEachMethod);
+	}
+
+	private AfterEachMethodAdapter synthesizeAfterEachMethodAdapter(Method method) {
+		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry,
+			InvocationInterceptor::interceptAfterEachMethod);
+	}
+
+	private void invokeMethodInExtensionContext(Method method, ExtensionContext context, ExtensionRegistry registry,
+			VoidMethodInterceptorCall interceptorCall) {
+		TestInstances testInstances = context.getRequiredTestInstances();
+		Object target = testInstances.findInstance(method.getDeclaringClass()).orElseThrow(
+			() -> new JUnitException("Failed to find instance for method: " + method.toGenericString()));
+
+		executableInvoker.invoke(method, target, context, registry,
+			ReflectiveInterceptorCall.ofVoidMethod(interceptorCall));
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
index e9db7368d..4015b01a6 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
@@ -24,7 +24,7 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 /**
  * @since 5.0
  */
-final class ClassExtensionContext extends AbstractExtensionContext<ClassTestDescriptor> {
+final class ClassExtensionContext extends AbstractExtensionContext<ClassBasedTestDescriptor> {
 
 	private final Lifecycle lifecycle;
 
@@ -35,17 +35,17 @@ final class ClassExtensionContext extends AbstractExtensionContext<ClassTestDesc
 	/**
 	 * Create a new {@code ClassExtensionContext} with {@link Lifecycle#PER_METHOD}.
 	 *
-	 * @see #ClassExtensionContext(ExtensionContext, EngineExecutionListener, ClassTestDescriptor, Lifecycle, JupiterConfiguration, ThrowableCollector)
+	 * @see #ClassExtensionContext(ExtensionContext, EngineExecutionListener, ClassBasedTestDescriptor, Lifecycle, JupiterConfiguration, ThrowableCollector)
 	 */
 	ClassExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
-			ClassTestDescriptor testDescriptor, JupiterConfiguration configuration,
+			ClassBasedTestDescriptor testDescriptor, JupiterConfiguration configuration,
 			ThrowableCollector throwableCollector) {
 
 		this(parent, engineExecutionListener, testDescriptor, Lifecycle.PER_METHOD, configuration, throwableCollector);
 	}
 
 	ClassExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
-			ClassTestDescriptor testDescriptor, Lifecycle lifecycle, JupiterConfiguration configuration,
+			ClassBasedTestDescriptor testDescriptor, Lifecycle lifecycle, JupiterConfiguration configuration,
 			ThrowableCollector throwableCollector) {
 
 		super(parent, engineExecutionListener, testDescriptor, configuration);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index bd1f7c320..c97b26f9b 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -10,63 +10,22 @@
 
 package org.junit.jupiter.engine.descriptor;
 
-import static java.util.stream.Collectors.joining;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.DisplayNameUtils.createDisplayNameSupplierForClass;
-import static org.junit.jupiter.engine.descriptor.ExtensionUtils.populateNewExtensionRegistryFromExtendWithAnnotation;
-import static org.junit.jupiter.engine.descriptor.ExtensionUtils.registerExtensionsFromFields;
-import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterAllMethods;
-import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findAfterEachMethods;
-import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeAllMethods;
-import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.findBeforeEachMethods;
-import static org.junit.jupiter.engine.descriptor.TestInstanceLifecycleUtils.getTestInstanceLifecycle;
-import static org.junit.jupiter.engine.support.JupiterThrowableCollectorFactory.createThrowableCollector;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Optional;
 import java.util.Set;
-import java.util.function.Function;
-import java.util.function.Supplier;
 
 import org.apiguardian.api.API;
-import org.junit.jupiter.api.TestInstance.Lifecycle;
-import org.junit.jupiter.api.extension.AfterAllCallback;
-import org.junit.jupiter.api.extension.BeforeAllCallback;
-import org.junit.jupiter.api.extension.Extension;
-import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
-import org.junit.jupiter.api.extension.InvocationInterceptor;
-import org.junit.jupiter.api.extension.TestInstanceFactory;
-import org.junit.jupiter.api.extension.TestInstancePostProcessor;
 import org.junit.jupiter.api.extension.TestInstances;
-import org.junit.jupiter.api.extension.TestInstantiationException;
-import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.execution.AfterEachMethodAdapter;
-import org.junit.jupiter.engine.execution.BeforeEachMethodAdapter;
-import org.junit.jupiter.engine.execution.DefaultTestInstances;
-import org.junit.jupiter.engine.execution.ExecutableInvoker;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall.VoidMethodInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
-import org.junit.jupiter.engine.execution.TestInstancesProvider;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
-import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.util.BlacklistedExceptions;
-import org.junit.platform.commons.util.ExceptionUtils;
-import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.commons.util.StringUtils;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
 import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.support.descriptor.ClassSource;
-import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
-import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 
 /**
  * {@link TestDescriptor} for tests based on Java classes.
@@ -80,32 +39,12 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
  * @since 5.0
  */
 @API(status = INTERNAL, since = "5.0")
-public class ClassTestDescriptor extends JupiterTestDescriptor {
+public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 
 	public static final String SEGMENT_TYPE = "class";
-	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
-
-	private final Class<?> testClass;
-	private final Set<TestTag> tags;
-	protected final Lifecycle lifecycle;
-
-	private ExecutionMode defaultChildExecutionMode;
-	private TestInstanceFactory testInstanceFactory;
-	private List<Method> beforeAllMethods;
-	private List<Method> afterAllMethods;
 
 	public ClassTestDescriptor(UniqueId uniqueId, Class<?> testClass, JupiterConfiguration configuration) {
-		this(uniqueId, testClass, createDisplayNameSupplierForClass(testClass, configuration), configuration);
-	}
-
-	ClassTestDescriptor(UniqueId uniqueId, Class<?> testClass, Supplier<String> displayNameSupplier,
-			JupiterConfiguration configuration) {
-		super(uniqueId, testClass, displayNameSupplier, ClassSource.from(testClass), configuration);
-
-		this.testClass = testClass;
-		this.tags = getTags(testClass);
-		this.lifecycle = getTestInstanceLifecycle(testClass, configuration);
-		this.defaultChildExecutionMode = (this.lifecycle == Lifecycle.PER_CLASS ? ExecutionMode.SAME_THREAD : null);
+		super(uniqueId, testClass, createDisplayNameSupplierForClass(testClass, configuration), configuration);
 	}
 
 	// --- TestDescriptor ------------------------------------------------------
@@ -116,346 +55,18 @@ public class ClassTestDescriptor extends JupiterTestDescriptor {
 		return new LinkedHashSet<>(this.tags);
 	}
 
-	public final Class<?> getTestClass() {
-		return this.testClass;
-	}
-
-	@Override
-	public Type getType() {
-		return Type.CONTAINER;
-	}
-
-	@Override
-	public String getLegacyReportingName() {
-		return this.testClass.getName();
-	}
-
 	// --- Node ----------------------------------------------------------------
 
 	@Override
-	protected Optional<ExecutionMode> getExplicitExecutionMode() {
-		return getExecutionModeFromAnnotation(getTestClass());
-	}
-
-	@Override
-	protected Optional<ExecutionMode> getDefaultChildExecutionMode() {
-		return Optional.ofNullable(this.defaultChildExecutionMode);
-	}
-
-	public void setDefaultChildExecutionMode(ExecutionMode defaultChildExecutionMode) {
-		this.defaultChildExecutionMode = defaultChildExecutionMode;
-	}
-
-	@Override
-	public Set<ExclusiveResource> getExclusiveResources() {
-		return getExclusiveResourcesFromAnnotation(getTestClass());
-	}
-
-	@Override
-	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
-			context.getExtensionRegistry(), this.testClass);
-
-		// Register extensions from static fields here, at the class level but
-		// after extensions registered via @ExtendWith.
-		registerExtensionsFromFields(registry, this.testClass, null);
-
-		// Resolve the TestInstanceFactory at the class level in order to fail
-		// the entire class in case of configuration errors (e.g., more than
-		// one factory registered per class).
-		this.testInstanceFactory = resolveTestInstanceFactory(registry);
-
-		registerBeforeEachMethodAdapters(registry);
-		registerAfterEachMethodAdapters(registry);
-
-		ThrowableCollector throwableCollector = createThrowableCollector();
-		ClassExtensionContext extensionContext = new ClassExtensionContext(context.getExtensionContext(),
-			context.getExecutionListener(), this, this.lifecycle, context.getConfiguration(), throwableCollector);
-
-		this.beforeAllMethods = findBeforeAllMethods(this.testClass, this.lifecycle == Lifecycle.PER_METHOD);
-		this.afterAllMethods = findAfterAllMethods(this.testClass, this.lifecycle == Lifecycle.PER_METHOD);
-
-		// @formatter:off
-		return context.extend()
-				.withTestInstancesProvider(testInstancesProvider(context, registry, extensionContext))
-				.withExtensionRegistry(registry)
-				.withExtensionContext(extensionContext)
-				.withThrowableCollector(throwableCollector)
-				.build();
-		// @formatter:on
-	}
-
-	@Override
-	public JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
-		ThrowableCollector throwableCollector = context.getThrowableCollector();
-
-		Lifecycle lifecycle = context.getExtensionContext().getTestInstanceLifecycle().orElse(Lifecycle.PER_METHOD);
-		if (lifecycle == Lifecycle.PER_CLASS) {
-			// Eagerly load test instance for BeforeAllCallbacks, if necessary,
-			// and store the instance in the ExtensionContext.
-			ClassExtensionContext extensionContext = (ClassExtensionContext) context.getExtensionContext();
-			throwableCollector.execute(() -> extensionContext.setTestInstances(
-				context.getTestInstancesProvider().getTestInstances(Optional.empty())));
-		}
-
-		if (throwableCollector.isEmpty()) {
-			context.beforeAllCallbacksExecuted(true);
-			invokeBeforeAllCallbacks(context);
-
-			if (throwableCollector.isEmpty()) {
-				context.beforeAllMethodsExecuted(true);
-				invokeBeforeAllMethods(context);
-			}
-		}
-
-		throwableCollector.assertEmpty();
-
-		return context;
+	public ExecutionMode getExecutionMode() {
+		return getExplicitExecutionMode().orElseGet(
+			() -> JupiterTestDescriptor.toExecutionMode(configuration.getDefaultClassesExecutionMode()));
 	}
 
 	@Override
-	public void after(JupiterEngineExecutionContext context) {
-
-		ThrowableCollector throwableCollector = context.getThrowableCollector();
-		Throwable previousThrowable = throwableCollector.getThrowable();
-
-		if (context.beforeAllMethodsExecuted()) {
-			invokeAfterAllMethods(context);
-		}
-
-		if (context.beforeAllCallbacksExecuted()) {
-			invokeAfterAllCallbacks(context);
-		}
-
-		// If the previous Throwable was not null when this method was called,
-		// that means an exception was already thrown either before or during
-		// the execution of this Node. If an exception was already thrown, any
-		// later exceptions were added as suppressed exceptions to that original
-		// exception unless a more severe exception occurred in the meantime.
-		if (previousThrowable != throwableCollector.getThrowable()) {
-			throwableCollector.assertEmpty();
-		}
-	}
-
-	private TestInstanceFactory resolveTestInstanceFactory(ExtensionRegistry registry) {
-		List<TestInstanceFactory> factories = registry.getExtensions(TestInstanceFactory.class);
-
-		if (factories.size() == 1) {
-			return factories.get(0);
-		}
-
-		if (factories.size() > 1) {
-			String factoryNames = factories.stream()//
-					.map(factory -> factory.getClass().getName())//
-					.collect(joining(", "));
-
-			String errorMessage = String.format(
-				"The following TestInstanceFactory extensions were registered for test class [%s], but only one is permitted: %s",
-				testClass.getName(), factoryNames);
-
-			throw new ExtensionConfigurationException(errorMessage);
-		}
-
-		return null;
-	}
-
-	private TestInstancesProvider testInstancesProvider(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionRegistry registry, ClassExtensionContext extensionContext) {
-
-		TestInstancesProvider testInstancesProvider = childRegistry -> instantiateAndPostProcessTestInstance(
-			parentExecutionContext, extensionContext, childRegistry.orElse(registry));
-
-		return childRegistry -> extensionContext.getTestInstances().orElseGet(
-			() -> testInstancesProvider.getTestInstances(childRegistry));
-	}
-
-	private TestInstances instantiateAndPostProcessTestInstance(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionContext extensionContext, ExtensionRegistry registry) {
-
-		TestInstances instances = instantiateTestClass(parentExecutionContext, registry, extensionContext);
-		invokeTestInstancePostProcessors(instances.getInnermostInstance(), registry, extensionContext);
-		// In addition, we register extensions from instance fields here since the
-		// best time to do that is immediately following test class instantiation
-		// and post processing.
-		registerExtensionsFromFields(registry, this.testClass, instances.getInnermostInstance());
-		return instances;
-	}
-
 	protected TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
 			ExtensionRegistry registry, ExtensionContext extensionContext) {
-
 		return instantiateTestClass(Optional.empty(), registry, extensionContext);
 	}
 
-	protected TestInstances instantiateTestClass(Optional<TestInstances> outerInstances, ExtensionRegistry registry,
-			ExtensionContext extensionContext) {
-
-		Optional<Object> outerInstance = outerInstances.map(TestInstances::getInnermostInstance);
-		Object instance = this.testInstanceFactory != null //
-				? invokeTestInstanceFactory(outerInstance, extensionContext) //
-				: invokeTestClassConstructor(outerInstance, registry, extensionContext);
-		return outerInstances.map(instances -> DefaultTestInstances.of(instances, instance)).orElse(
-			DefaultTestInstances.of(instance));
-	}
-
-	private Object invokeTestInstanceFactory(Optional<Object> outerInstance, ExtensionContext extensionContext) {
-		Object instance;
-
-		try {
-			instance = this.testInstanceFactory.createTestInstance(
-				new DefaultTestInstanceFactoryContext(this.testClass, outerInstance), extensionContext);
-		}
-		catch (Throwable throwable) {
-			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
-
-			if (throwable instanceof TestInstantiationException) {
-				throw (TestInstantiationException) throwable;
-			}
-
-			String message = String.format("TestInstanceFactory [%s] failed to instantiate test class [%s]",
-				this.testInstanceFactory.getClass().getName(), this.testClass.getName());
-			if (StringUtils.isNotBlank(throwable.getMessage())) {
-				message += ": " + throwable.getMessage();
-			}
-			throw new TestInstantiationException(message, throwable);
-		}
-
-		if (!this.testClass.isInstance(instance)) {
-			String testClassName = this.testClass.getName();
-			Class<?> instanceClass = (instance == null ? null : instance.getClass());
-			String instanceClassName = (instanceClass == null ? "null" : instanceClass.getName());
-
-			// If the test instance was loaded via a different ClassLoader, append
-			// the identity hash codes to the type names to help users disambiguate
-			// between otherwise identical "fully qualified class names".
-			if (testClassName.equals(instanceClassName)) {
-				testClassName += "@" + Integer.toHexString(System.identityHashCode(this.testClass));
-				instanceClassName += "@" + Integer.toHexString(System.identityHashCode(instanceClass));
-			}
-			String message = String.format(
-				"TestInstanceFactory [%s] failed to return an instance of [%s] and instead returned an instance of [%s].",
-				this.testInstanceFactory.getClass().getName(), testClassName, instanceClassName);
-
-			throw new TestInstantiationException(message);
-		}
-
-		return instance;
-	}
-
-	private Object invokeTestClassConstructor(Optional<Object> outerInstance, ExtensionRegistry registry,
-			ExtensionContext extensionContext) {
-
-		Constructor<?> constructor = ReflectionUtils.getDeclaredConstructor(this.testClass);
-		return executableInvoker.invoke(constructor, outerInstance, extensionContext, registry,
-			InvocationInterceptor::interceptTestClassConstructor);
-	}
-
-	private void invokeTestInstancePostProcessors(Object instance, ExtensionRegistry registry,
-			ExtensionContext context) {
-
-		registry.stream(TestInstancePostProcessor.class).forEach(
-			extension -> executeAndMaskThrowable(() -> extension.postProcessTestInstance(instance, context)));
-	}
-
-	private void executeAndMaskThrowable(Executable executable) {
-		try {
-			executable.execute();
-		}
-		catch (Throwable throwable) {
-			ExceptionUtils.throwAsUncheckedException(throwable);
-		}
-	}
-
-	private void invokeBeforeAllCallbacks(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = context.getExtensionRegistry();
-		ExtensionContext extensionContext = context.getExtensionContext();
-		ThrowableCollector throwableCollector = context.getThrowableCollector();
-
-		for (BeforeAllCallback callback : registry.getExtensions(BeforeAllCallback.class)) {
-			throwableCollector.execute(() -> callback.beforeAll(extensionContext));
-			if (throwableCollector.isNotEmpty()) {
-				break;
-			}
-		}
-	}
-
-	private void invokeBeforeAllMethods(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = context.getExtensionRegistry();
-		ExtensionContext extensionContext = context.getExtensionContext();
-		ThrowableCollector throwableCollector = context.getThrowableCollector();
-		Object testInstance = extensionContext.getTestInstance().orElse(null);
-
-		for (Method method : this.beforeAllMethods) {
-			throwableCollector.execute(() -> executableInvoker.invoke(method, testInstance, extensionContext, registry,
-				ReflectiveInterceptorCall.ofVoidMethod(InvocationInterceptor::interceptBeforeAllMethod)));
-			if (throwableCollector.isNotEmpty()) {
-				break;
-			}
-		}
-	}
-
-	private void invokeAfterAllMethods(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = context.getExtensionRegistry();
-		ExtensionContext extensionContext = context.getExtensionContext();
-		ThrowableCollector throwableCollector = context.getThrowableCollector();
-		Object testInstance = extensionContext.getTestInstance().orElse(null);
-
-		this.afterAllMethods.forEach(
-			method -> throwableCollector.execute(() -> executableInvoker.invoke(method, testInstance, extensionContext,
-				registry, ReflectiveInterceptorCall.ofVoidMethod(InvocationInterceptor::interceptAfterAllMethod))));
-	}
-
-	private void invokeAfterAllCallbacks(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = context.getExtensionRegistry();
-		ExtensionContext extensionContext = context.getExtensionContext();
-		ThrowableCollector throwableCollector = context.getThrowableCollector();
-
-		registry.getReversedExtensions(AfterAllCallback.class)//
-				.forEach(extension -> throwableCollector.execute(() -> extension.afterAll(extensionContext)));
-	}
-
-	private void registerBeforeEachMethodAdapters(ExtensionRegistry registry) {
-		List<Method> beforeEachMethods = findBeforeEachMethods(this.testClass);
-		registerMethodsAsExtensions(beforeEachMethods, registry, this::synthesizeBeforeEachMethodAdapter);
-	}
-
-	private void registerAfterEachMethodAdapters(ExtensionRegistry registry) {
-		// Make a local copy since findAfterEachMethods() returns an immutable list.
-		List<Method> afterEachMethods = new ArrayList<>(findAfterEachMethods(this.testClass));
-
-		// Since the bottom-up ordering of afterEachMethods will later be reversed when the
-		// synthesized AfterEachMethodAdapters are executed within TestMethodTestDescriptor,
-		// we have to reverse the afterEachMethods list to put them in top-down order before
-		// we register them as synthesized extensions.
-		Collections.reverse(afterEachMethods);
-
-		registerMethodsAsExtensions(afterEachMethods, registry, this::synthesizeAfterEachMethodAdapter);
-	}
-
-	private void registerMethodsAsExtensions(List<Method> methods, ExtensionRegistry registry,
-			Function<Method, Extension> extensionSynthesizer) {
-
-		methods.forEach(method -> registry.registerExtension(extensionSynthesizer.apply(method), method));
-	}
-
-	private BeforeEachMethodAdapter synthesizeBeforeEachMethodAdapter(Method method) {
-		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry,
-			InvocationInterceptor::interceptBeforeEachMethod);
-	}
-
-	private AfterEachMethodAdapter synthesizeAfterEachMethodAdapter(Method method) {
-		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry,
-			InvocationInterceptor::interceptAfterEachMethod);
-	}
-
-	private void invokeMethodInExtensionContext(Method method, ExtensionContext context, ExtensionRegistry registry,
-			VoidMethodInterceptorCall interceptorCall) {
-		TestInstances testInstances = context.getRequiredTestInstances();
-		Object target = testInstances.findInstance(method.getDeclaringClass()).orElseThrow(
-			() -> new JUnitException("Failed to find instance for method: " + method.toGenericString()));
-
-		executableInvoker.invoke(method, target, context, registry,
-			ReflectiveInterceptorCall.ofVoidMethod(interceptorCall));
-	}
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
index dc04b05f7..e996aaf62 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
@@ -98,7 +98,7 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 	// --- Node ----------------------------------------------------------------
 
 	@Override
-	public final ExecutionMode getExecutionMode() {
+	public ExecutionMode getExecutionMode() {
 		Optional<ExecutionMode> executionMode = getExplicitExecutionMode();
 		if (executionMode.isPresent()) {
 			return executionMode.get();
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
index 9b35ff495..38051244a 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
@@ -38,18 +38,12 @@ import org.junit.platform.engine.UniqueId;
  * @since 5.0
  */
 @API(status = INTERNAL, since = "5.0")
-public class NestedClassTestDescriptor extends ClassTestDescriptor {
+public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 
 	public static final String SEGMENT_TYPE = "nested-class";
-	/**
-	 * Set of local class-level tags; does not contain tags from parent.
-	 */
-	private final Set<TestTag> tags;
 
 	public NestedClassTestDescriptor(UniqueId uniqueId, Class<?> testClass, JupiterConfiguration configuration) {
 		super(uniqueId, testClass, createDisplayNameSupplierForNestedClass(testClass, configuration), configuration);
-
-		this.tags = getTags(testClass);
 	}
 
 	// --- TestDescriptor ------------------------------------------------------
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
index 07aa50d31..5d5330d53 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
@@ -29,6 +29,7 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
 import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
 import org.junit.jupiter.engine.discovery.predicates.IsNestedTestClass;
@@ -90,8 +91,8 @@ class ClassSelectorResolver implements SelectorResolver {
 		if (NestedClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {
 			String simpleClassName = lastSegment.getValue();
 			return toResolution(context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
-				if (parent instanceof ClassTestDescriptor) {
-					Class<?> parentTestClass = ((ClassTestDescriptor) parent).getTestClass();
+				if (parent instanceof ClassBasedTestDescriptor) {
+					Class<?> parentTestClass = ((ClassBasedTestDescriptor) parent).getTestClass();
 					// TODO add test for resolving unique id of inherited nested test class
 					return ReflectionUtils.findNestedClasses(parentTestClass,
 						isNestedTestClass.and(
@@ -116,7 +117,7 @@ class ClassSelectorResolver implements SelectorResolver {
 			configuration);
 	}
 
-	private Resolution toResolution(Optional<ClassTestDescriptor> testDescriptor) {
+	private Resolution toResolution(Optional<? extends ClassBasedTestDescriptor> testDescriptor) {
 		return testDescriptor.map(it -> {
 			Class<?> testClass = it.getTestClass();
 			// @formatter:off
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
index 95394debf..3f2731330 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
@@ -22,7 +22,7 @@ import java.util.stream.Stream;
 
 import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
 import org.junit.jupiter.engine.descriptor.MethodBasedTestDescriptor;
 import org.junit.platform.commons.logging.Logger;
@@ -46,14 +46,14 @@ class MethodOrderingVisitor implements TestDescriptor.Visitor {
 
 	@Override
 	public void visit(TestDescriptor testDescriptor) {
-		if (testDescriptor instanceof ClassTestDescriptor) {
-			ClassTestDescriptor classTestDescriptor = (ClassTestDescriptor) testDescriptor;
+		if (testDescriptor instanceof ClassBasedTestDescriptor) {
+			ClassBasedTestDescriptor classBasedTestDescriptor = (ClassBasedTestDescriptor) testDescriptor;
 			try {
-				orderContainedMethods(classTestDescriptor, classTestDescriptor.getTestClass());
+				orderContainedMethods(classBasedTestDescriptor, classBasedTestDescriptor.getTestClass());
 			}
 			catch (Throwable t) {
 				BlacklistedExceptions.rethrowIfBlacklisted(t);
-				logger.error(t, () -> "Failed to order methods for " + classTestDescriptor.getTestClass());
+				logger.error(t, () -> "Failed to order methods for " + classBasedTestDescriptor.getTestClass());
 			}
 		}
 	}
@@ -61,13 +61,13 @@ class MethodOrderingVisitor implements TestDescriptor.Visitor {
 	/**
 	 * @since 5.4
 	 */
-	private void orderContainedMethods(ClassTestDescriptor classTestDescriptor, Class<?> testClass) {
+	private void orderContainedMethods(ClassBasedTestDescriptor classBasedTestDescriptor, Class<?> testClass) {
 		findAnnotation(testClass, TestMethodOrder.class)//
 				.map(TestMethodOrder::value)//
 				.map(ReflectionUtils::newInstance)//
 				.ifPresent(methodOrderer -> {
 
-					Set<? extends TestDescriptor> children = classTestDescriptor.getChildren();
+					Set<? extends TestDescriptor> children = classBasedTestDescriptor.getChildren();
 
 					List<TestDescriptor> nonMethodTestDescriptors = children.stream()//
 							.filter(testDescriptor -> !(testDescriptor instanceof MethodBasedTestDescriptor))//
@@ -105,15 +105,15 @@ class MethodOrderingVisitor implements TestDescriptor.Visitor {
 
 					// Currently no way to removeAll or addAll children at once.
 					Stream.concat(sortedMethodTestDescriptors.stream(), nonMethodTestDescriptors.stream())//
-							.forEach(classTestDescriptor::removeChild);
+							.forEach(classBasedTestDescriptor::removeChild);
 					Stream.concat(sortedMethodTestDescriptors.stream(), nonMethodTestDescriptors.stream())//
-							.forEach(classTestDescriptor::addChild);
+							.forEach(classBasedTestDescriptor::addChild);
 
 					// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
 					// to be invoked after MethodOrderer#orderMethods().
 					methodOrderer.getDefaultExecutionMode()//
 							.map(JupiterTestDescriptor::toExecutionMode)//
-							.ifPresent(classTestDescriptor::setDefaultChildExecutionMode);
+							.ifPresent(classBasedTestDescriptor::setDefaultChildExecutionMode);
 				});
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
index abab626a4..188c91580 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
@@ -28,7 +28,7 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.Filterable;
 import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
@@ -177,7 +177,7 @@ class MethodSelectorResolver implements SelectorResolver {
 			if (segmentType.equals(lastSegment.getType())) {
 				return context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
 					String methodSpecPart = lastSegment.getValue();
-					Class<?> testClass = ((ClassTestDescriptor) parent).getTestClass();
+					Class<?> testClass = ((ClassBasedTestDescriptor) parent).getTestClass();
 					// @formatter:off
 					return methodFinder.findMethod(methodSpecPart, testClass)
 							.filter(methodPredicate)
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
index f3e4aa417..3ff2872ef 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
@@ -33,6 +33,7 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.jupiter.engine.config.DefaultJupiterConfiguration;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.DefaultTestInstances;
@@ -62,6 +63,7 @@ public class ExtensionContextTests {
 	@BeforeEach
 	void setUp() {
 		when(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+		when(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);
 	}
 
 	@Test
@@ -91,7 +93,7 @@ public class ExtensionContextTests {
 	@Test
 	@SuppressWarnings("resource")
 	void fromClassTestDescriptor() {
-		ClassTestDescriptor nestedClassDescriptor = nestedClassDescriptor();
+		NestedClassTestDescriptor nestedClassDescriptor = nestedClassDescriptor();
 		ClassTestDescriptor outerClassDescriptor = outerClassDescriptor(nestedClassDescriptor);
 
 		ClassExtensionContext outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor,
@@ -119,7 +121,7 @@ public class ExtensionContextTests {
 	@Test
 	@SuppressWarnings("resource")
 	void tagsCanBeRetrievedInExtensionContext() {
-		ClassTestDescriptor nestedClassDescriptor = nestedClassDescriptor();
+		NestedClassTestDescriptor nestedClassDescriptor = nestedClassDescriptor();
 		ClassTestDescriptor outerClassDescriptor = outerClassDescriptor(nestedClassDescriptor);
 		TestMethodTestDescriptor methodTestDescriptor = methodDescriptor();
 		outerClassDescriptor.addChild(methodTestDescriptor);
@@ -274,7 +276,7 @@ public class ExtensionContextTests {
 			() -> assertEquals(expected, context.getConfigurationParameter(key))));
 	}
 
-	private ClassTestDescriptor nestedClassDescriptor() {
+	private NestedClassTestDescriptor nestedClassDescriptor() {
 		return new NestedClassTestDescriptor(UniqueId.root("nested-class", "NestedClass"), OuterClass.NestedClass.class,
 			configuration);
 	}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java
index 460da7867..086b4fab7 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java
@@ -34,6 +34,7 @@ import org.junit.jupiter.api.DisplayNameGenerator;
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.JupiterTestDescriptorTests.StaticTestCase.StaticTestCaseLevel2;
 import org.junit.platform.engine.TestSource;
@@ -57,6 +58,7 @@ class JupiterTestDescriptorTests {
 	@BeforeEach
 	void setUp() {
 		when(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+		when(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);
 	}
 
 	@Test
@@ -225,7 +227,7 @@ class JupiterTestDescriptorTests {
 	void shouldTakeCustomMethodNameDescriptorFromConfigurationIfPresent() {
 		when(configuration.getDefaultDisplayNameGenerator()).thenReturn(new CustomDisplayNameGenerator());
 
-		ClassTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, getClass(), configuration);
+		ClassBasedTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, getClass(), configuration);
 		assertEquals("class-display-name", descriptor.getDisplayName());
 		assertEquals(getClass().getName(), descriptor.getLegacyReportingName());
 
@@ -244,7 +246,7 @@ class JupiterTestDescriptorTests {
 
 	@Test
 	void defaultDisplayNamesForTestClasses() {
-		ClassTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, getClass(), configuration);
+		ClassBasedTestDescriptor descriptor = new ClassTestDescriptor(uniqueId, getClass(), configuration);
 		assertEquals(getClass().getSimpleName(), descriptor.getDisplayName());
 		assertEquals(getClass().getName(), descriptor.getLegacyReportingName());
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
index 43088a514..50c4de237 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
@@ -55,6 +55,7 @@ import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.TestTemplate;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.jupiter.engine.TrackLogRecords;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.DynamicDescendantFilter;
@@ -90,6 +91,7 @@ class DiscoverySelectorResolverTests {
 	@BeforeEach
 	void setUp() {
 		when(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+		when(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);
 	}
 
 	@Test
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
index 97365856c..7d6df7aac 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
@@ -18,11 +18,13 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 import static org.junit.jupiter.api.parallel.ExecutionMode.CONCURRENT;
 import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;
+import static org.junit.jupiter.engine.Constants.DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.DEFAULT_PARALLEL_EXECUTION_MODE;
 import static org.junit.jupiter.engine.Constants.PARALLEL_CONFIG_FIXED_PARALLELISM_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.PARALLEL_CONFIG_STRATEGY_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
+import static org.junit.platform.testkit.engine.EventConditions.container;
 import static org.junit.platform.testkit.engine.EventConditions.event;
 import static org.junit.platform.testkit.engine.EventConditions.finishedSuccessfully;
 import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
@@ -60,9 +62,11 @@ import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.parallel.Execution;
 import org.junit.jupiter.api.parallel.ResourceLock;
+import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
 import org.junit.platform.engine.reporting.ReportEntry;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.testkit.engine.EngineExecutionResults;
 import org.junit.platform.testkit.engine.EngineTestKit;
 import org.junit.platform.testkit.engine.Event;
 
@@ -73,7 +77,7 @@ class ParallelExecutionIntegrationTests {
 
 	@Test
 	void successfulParallelTest(TestReporter reporter) {
-		List<Event> events = execute(3, SuccessfulParallelTestCase.class);
+		List<Event> events = executeConcurrently(3, SuccessfulParallelTestCase.class);
 
 		List<Instant> startedTimestamps = getTimestampsFor(events, event(test(), started()));
 		List<Instant> finishedTimestamps = getTimestampsFor(events, event(test(), finishedSuccessfully()));
@@ -89,13 +93,13 @@ class ParallelExecutionIntegrationTests {
 
 	@Test
 	void failingTestWithoutLock() {
-		List<Event> events = execute(3, FailingWithoutLockTestCase.class);
+		List<Event> events = executeConcurrently(3, FailingWithoutLockTestCase.class);
 		assertThat(events.stream().filter(event(test(), finishedWithFailure())::matches)).hasSize(2);
 	}
 
 	@Test
 	void successfulTestWithMethodLock() {
-		List<Event> events = execute(3, SuccessfulWithMethodLockTestCase.class);
+		List<Event> events = executeConcurrently(3, SuccessfulWithMethodLockTestCase.class);
 
 		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(3);
 		assertThat(ThreadReporter.getThreadNames(events)).hasSize(3);
@@ -103,7 +107,7 @@ class ParallelExecutionIntegrationTests {
 
 	@Test
 	void successfulTestWithClassLock() {
-		List<Event> events = execute(3, SuccessfulWithClassLockTestCase.class);
+		List<Event> events = executeConcurrently(3, SuccessfulWithClassLockTestCase.class);
 
 		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(3);
 		assertThat(ThreadReporter.getThreadNames(events)).hasSize(1);
@@ -111,7 +115,7 @@ class ParallelExecutionIntegrationTests {
 
 	@Test
 	void testCaseWithFactory() {
-		List<Event> events = execute(3, TestCaseWithTestFactory.class);
+		List<Event> events = executeConcurrently(3, TestCaseWithTestFactory.class);
 
 		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(3);
 		assertThat(ThreadReporter.getThreadNames(events)).hasSize(1);
@@ -124,7 +128,7 @@ class ParallelExecutionIntegrationTests {
 		var smilingLoader = new URLClassLoader("(-:", new URL[0], ClassLoader.getSystemClassLoader());
 		currentThread.setContextClassLoader(smilingLoader);
 		try {
-			var events = execute(3, SuccessfulWithMethodLockTestCase.class);
+			var events = executeConcurrently(3, SuccessfulWithMethodLockTestCase.class);
 
 			assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(3);
 			assertThat(ThreadReporter.getThreadNames(events)).hasSize(3);
@@ -137,7 +141,7 @@ class ParallelExecutionIntegrationTests {
 
 	@RepeatedTest(10)
 	void mixingClassAndMethodLevelLocks() {
-		List<Event> events = execute(4, TestCaseWithSortedLocks.class, TestCaseWithUnsortedLocks.class);
+		List<Event> events = executeConcurrently(4, TestCaseWithSortedLocks.class, TestCaseWithUnsortedLocks.class);
 
 		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(6);
 		assertThat(ThreadReporter.getThreadNames(events).count()).isLessThanOrEqualTo(2);
@@ -145,7 +149,7 @@ class ParallelExecutionIntegrationTests {
 
 	@RepeatedTest(10)
 	void locksOnNestedTests() {
-		List<Event> events = execute(3, TestCaseWithNestedLocks.class);
+		List<Event> events = executeConcurrently(3, TestCaseWithNestedLocks.class);
 
 		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(6);
 		assertThat(ThreadReporter.getThreadNames(events)).hasSize(1);
@@ -153,7 +157,7 @@ class ParallelExecutionIntegrationTests {
 
 	@Test
 	void afterHooksAreCalledAfterConcurrentDynamicTestsAreFinished() {
-		List<Event> events = execute(3, ConcurrentDynamicTestCase.class);
+		List<Event> events = executeConcurrently(3, ConcurrentDynamicTestCase.class);
 
 		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(1);
 		Map<String, Instant> timestampedEvents = ConcurrentDynamicTestCase.events;
@@ -166,19 +170,60 @@ class ParallelExecutionIntegrationTests {
 	 */
 	@Test
 	void threadInterruptedByUserCode() {
-		List<Event> events = execute(3, InterruptedThreadTestCase.class);
+		List<Event> events = executeConcurrently(3, InterruptedThreadTestCase.class);
 
-		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).size().isEqualTo(4);
+		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(4);
 	}
 
 	@Test
 	void executesTestTemplatesWithResourceLocksInSameThread() {
-		List<Event> events = execute(2, ConcurrentTemplateTestCase.class);
+		List<Event> events = executeConcurrently(2, ConcurrentTemplateTestCase.class);
 
-		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).size().isEqualTo(10);
+		assertThat(events.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(10);
 		assertThat(ThreadReporter.getThreadNames(events)).hasSize(1);
 	}
 
+	@Test
+	void executesClassesInParallelIfEnabledViaConfigurationParameter() {
+		var configParams = Map.of(DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME, "concurrent");
+		var results = executeWithFixedParallelism(3, configParams, TestCaseA.class, TestCaseB.class, TestCaseC.class);
+
+		results.tests().assertStatistics(stats -> stats.succeeded(9));
+		assertThat(ThreadReporter.getThreadNames(results.all().list())).hasSize(3);
+		TestDescriptor testClassA = findFirstTestDescriptor(results, container(TestCaseA.class));
+		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassA))).hasSize(1);
+		TestDescriptor testClassB = findFirstTestDescriptor(results, container(TestCaseB.class));
+		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassB))).hasSize(1);
+		TestDescriptor testClassC = findFirstTestDescriptor(results, container(TestCaseC.class));
+		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassC))).hasSize(1);
+	}
+
+	@Test
+	void executesMethodsInParallelIfEnabledViaConfigurationParameter() {
+		var configParams = Map.of( //
+			DEFAULT_PARALLEL_EXECUTION_MODE, "concurrent", //
+			DEFAULT_CLASSES_EXECUTION_MODE_PROPERTY_NAME, "same_thread");
+		var results = executeWithFixedParallelism(3, configParams, TestCaseA.class, TestCaseB.class, TestCaseC.class);
+
+		results.tests().assertStatistics(stats -> stats.succeeded(9));
+		assertThat(ThreadReporter.getThreadNames(results.all().list())).hasSizeGreaterThanOrEqualTo(3);
+		TestDescriptor testClassA = findFirstTestDescriptor(results, container(TestCaseA.class));
+		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassA))).hasSize(3);
+		TestDescriptor testClassB = findFirstTestDescriptor(results, container(TestCaseB.class));
+		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassB))).hasSize(3);
+		TestDescriptor testClassC = findFirstTestDescriptor(results, container(TestCaseC.class));
+		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassC))).hasSize(3);
+	}
+
+	private List<Event> getEventsOfChildren(EngineExecutionResults results, TestDescriptor container) {
+		return results.tests().filter(
+			event -> event.getTestDescriptor().getParent().orElseThrow().equals(container)).collect(toList());
+	}
+
+	private TestDescriptor findFirstTestDescriptor(EngineExecutionResults results, Condition<Event> condition) {
+		return results.all().filter(condition::matches).map(Event::getTestDescriptor).findFirst().orElseThrow();
+	}
+
 	private List<Instant> getTimestampsFor(List<Event> events, Condition<Event> condition) {
 		// @formatter:off
 		return events.stream()
@@ -188,17 +233,23 @@ class ParallelExecutionIntegrationTests {
 		// @formatter:on
 	}
 
-	private List<Event> execute(int parallelism, Class<?>... testClasses) {
+	private List<Event> executeConcurrently(int parallelism, Class<?>... testClasses) {
+		return executeWithFixedParallelism(parallelism, Map.of(DEFAULT_PARALLEL_EXECUTION_MODE, "concurrent"),
+			testClasses).all().list();
+	}
+
+	private EngineExecutionResults executeWithFixedParallelism(int parallelism, Map<String, String> configParams,
+			Class<?>... testClasses) {
 		// @formatter:off
 		LauncherDiscoveryRequest discoveryRequest = request()
 				.selectors(Arrays.stream(testClasses).map(DiscoverySelectors::selectClass).collect(toList()))
 				.configurationParameter(PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME, String.valueOf(true))
-				.configurationParameter(DEFAULT_PARALLEL_EXECUTION_MODE, "concurrent")
 				.configurationParameter(PARALLEL_CONFIG_STRATEGY_PROPERTY_NAME, "fixed")
 				.configurationParameter(PARALLEL_CONFIG_FIXED_PARALLELISM_PROPERTY_NAME, String.valueOf(parallelism))
+				.configurationParameters(configParams)
 				.build();
 		// @formatter:on
-		return EngineTestKit.execute("junit-jupiter", discoveryRequest).all().list();
+		return EngineTestKit.execute("junit-jupiter", discoveryRequest);
 	}
 
 	// -------------------------------------------------------------------------
@@ -514,6 +565,33 @@ class ParallelExecutionIntegrationTests {
 		}
 	}
 
+	@ExtendWith(ThreadReporter.class)
+	static class SimpleTestCase {
+		@Test
+		void test1() throws Exception {
+			Thread.sleep(10);
+		}
+
+		@Test
+		void test2() throws Exception {
+			Thread.sleep(10);
+		}
+
+		@Test
+		void test3() throws Exception {
+			Thread.sleep(10);
+		}
+	}
+
+	static class TestCaseA extends SimpleTestCase {
+	}
+
+	static class TestCaseB extends SimpleTestCase {
+	}
+
+	static class TestCaseC extends SimpleTestCase {
+	}
+
 	private static void incrementBlockAndCheck(AtomicInteger sharedResource, CountDownLatch countDownLatch)
 			throws InterruptedException {
 		int value = incrementAndBlock(sharedResource, countDownLatch);
