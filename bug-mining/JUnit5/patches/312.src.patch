diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc
index e171bb3ff..b9a2be693 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc
@@ -48,6 +48,7 @@ on GitHub.
 ==== New Features and Improvements
 
 * Documented support for comments in CSV files loaded via `@CsvFileSource`.
+* Add support for String delimiters in `@CsvSource` and `@CsvFileSource`.
 
 
 [[release-notes-5.6.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index e2fc19c96..5693e6152 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1122,6 +1122,10 @@ include::{testDir}/example/ExternalMethodSourceDemo.java[tags=external_MethodSou
 include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
 ----
 
+The default delimiter is `,` but you can use another character by setting the `delimiter`
+attribute. Alternatively, the `delimiterString` attribute allows to use a `String` delimiter.
+However, both attributes cannot be set simultaneously.
+
 `@CsvSource` uses a single quote `'` as its quote character. See the `'lemon, lime'` value
 in the example above and in the table below. An empty, quoted value `''` results in an
 empty `String` unless the `emptyValue` attribute is set; whereas, an entirely _empty_
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsParser.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsParser.java
new file mode 100644
index 000000000..a6deed0c2
--- /dev/null
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsParser.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.params.provider;
+
+import java.lang.annotation.Annotation;
+
+import com.univocity.parsers.csv.CsvParser;
+import com.univocity.parsers.csv.CsvParserSettings;
+
+import org.junit.platform.commons.PreconditionViolationException;
+
+class CsvArgumentsParser {
+
+	private static final String DEFAULT_DELIMITER = ",";
+	private static final String LINE_SEPARATOR = "\n";
+	private static final char SINGLE_QUOTE = '\'';
+	private static final char DOUBLE_QUOTE = '"';
+	private static final char EMPTY_CHAR = '\0';
+
+	private String delimiter;
+	private String lineSeparator;
+	private char quote;
+	private String emptyValue;
+
+	private CsvArgumentsParser(String delimiter, String lineSeparator, char quote, String emptyValue) {
+		this.delimiter = delimiter;
+		this.lineSeparator = lineSeparator;
+		this.quote = quote;
+		this.emptyValue = emptyValue;
+	}
+
+	public static CsvArgumentsParser from(CsvSource annotation) {
+		String delimiter = selectDelimiter(annotation, annotation.delimiter(), annotation.delimiterString());
+		return new CsvArgumentsParser(delimiter, LINE_SEPARATOR, SINGLE_QUOTE, annotation.emptyValue());
+	}
+
+	public static CsvArgumentsParser from(CsvFileSource annotation) {
+		String delimiter = selectDelimiter(annotation, annotation.delimiter(), annotation.delimiterString());
+		return new CsvArgumentsParser(delimiter, annotation.lineSeparator(), DOUBLE_QUOTE, annotation.emptyValue());
+	}
+
+	private static String selectDelimiter(Annotation annotation, char delimiter, String delimiterString) {
+		if (delimiter != EMPTY_CHAR && !delimiterString.isEmpty()) {
+			throw new PreconditionViolationException(
+				"delimiter and delimiterString cannot be simultaneously set in " + annotation);
+		}
+		if (delimiter != EMPTY_CHAR) {
+			return String.valueOf(delimiter);
+		}
+		if (!delimiterString.isEmpty()) {
+			return delimiterString;
+		}
+		return DEFAULT_DELIMITER;
+	}
+
+	CsvParser getParser() {
+		CsvParserSettings csvParserSettings = buildParserSettings();
+		return new CsvParser(csvParserSettings);
+	}
+
+	private CsvParserSettings buildParserSettings() {
+		CsvParserSettings settings = new CsvParserSettings();
+		settings.getFormat().setDelimiter(delimiter);
+		settings.getFormat().setLineSeparator(lineSeparator);
+		settings.getFormat().setQuote(quote);
+		settings.getFormat().setQuoteEscape(quote);
+		settings.setEmptyValue(emptyValue);
+		settings.setAutoConfigurationEnabled(false);
+		// Do not use the built-in support for skipping rows/lines since it will
+		// throw an IllegalArgumentException if the file does not contain at least
+		// the number of specified lines to skip.
+		// settings.setNumberOfRowsToSkip(annotation.numLinesToSkip());
+		return settings;
+	}
+
+}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
index cad8abf37..626da39a2 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
@@ -16,7 +16,6 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
 
 import com.univocity.parsers.csv.CsvParser;
-import com.univocity.parsers.csv.CsvParserSettings;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.params.support.AnnotationConsumer;
@@ -32,22 +31,17 @@ class CsvArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<CsvS
 	private static final String LINE_SEPARATOR = "\n";
 
 	private CsvSource annotation;
+	private CsvArgumentsParser csvArgumentsParser;
 
 	@Override
 	public void accept(CsvSource annotation) {
 		this.annotation = annotation;
+		this.csvArgumentsParser = CsvArgumentsParser.from(annotation);
 	}
 
 	@Override
 	public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
-		CsvParserSettings settings = new CsvParserSettings();
-		settings.getFormat().setDelimiter(this.annotation.delimiter());
-		settings.getFormat().setLineSeparator(LINE_SEPARATOR);
-		settings.getFormat().setQuote('\'');
-		settings.getFormat().setQuoteEscape('\'');
-		settings.setEmptyValue(this.annotation.emptyValue());
-		settings.setAutoConfigurationEnabled(false);
-		CsvParser csvParser = new CsvParser(settings);
+		CsvParser csvParser = csvArgumentsParser.getParser();
 		AtomicLong index = new AtomicLong(0);
 
 		// @formatter:off
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
index 3c80990f0..42e85a36e 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
@@ -24,7 +24,6 @@ import java.util.function.BiFunction;
 import java.util.stream.Stream;
 
 import com.univocity.parsers.csv.CsvParser;
-import com.univocity.parsers.csv.CsvParserSettings;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.params.support.AnnotationConsumer;
@@ -41,7 +40,7 @@ class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<
 	private CsvFileSource annotation;
 	private String[] resources;
 	private Charset charset;
-	private CsvParserSettings settings;
+	private CsvArgumentsParser csvArgumentsParser;
 	private int numLinesToSkip;
 
 	CsvFileArgumentsProvider() {
@@ -55,25 +54,19 @@ class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<
 	@Override
 	public void accept(CsvFileSource annotation) {
 		this.annotation = annotation;
-		resources = annotation.resources();
+		this.resources = annotation.resources();
+		this.charset = getCharsetFrom(annotation);
+		this.csvArgumentsParser = CsvArgumentsParser.from(annotation);
+		this.numLinesToSkip = annotation.numLinesToSkip();
+	}
+
+	private Charset getCharsetFrom(CsvFileSource annotation) {
 		try {
-			this.charset = Charset.forName(annotation.encoding());
+			return Charset.forName(annotation.encoding());
 		}
 		catch (Exception ex) {
-			throw new PreconditionViolationException("The charset supplied in " + this.annotation + " is invalid", ex);
+			throw new PreconditionViolationException("The charset supplied in " + annotation + " is invalid", ex);
 		}
-		numLinesToSkip = annotation.numLinesToSkip();
-		settings = new CsvParserSettings();
-		// Do not use the built-in support for skipping rows/lines since it will
-		// throw an IllegalArgumentException if the file does not contain at least
-		// the number of specified lines to skip.
-		// settings.setNumberOfRowsToSkip(annotation.numLinesToSkip());
-		settings.getFormat().setDelimiter(annotation.delimiter());
-		settings.getFormat().setLineSeparator(annotation.lineSeparator());
-		settings.getFormat().setQuote('"');
-		settings.getFormat().setQuoteEscape('"');
-		settings.setEmptyValue(annotation.emptyValue());
-		settings.setAutoConfigurationEnabled(false);
 	}
 
 	@Override
@@ -94,7 +87,7 @@ class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<
 	}
 
 	private CsvParser createCsvParser(InputStream inputStream) {
-		CsvParser csvParser = new CsvParser(settings);
+		CsvParser csvParser = csvArgumentsParser.getParser();
 		try {
 			csvParser.beginParsing(inputStream, charset);
 		}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
index 315f32bcd..7a4eb8955 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
@@ -66,10 +66,17 @@ public @interface CsvFileSource {
 
 	/**
 	 * The column delimiter to use when reading the CSV files.
-	 *
-	 * <p>Defaults to {@code ","}.
+	 * This can't be set simultaneously with {@link #delimiterString delimiterString}.
+	 * If neither attributes are set, the delimiter will be ','.
+	 */
+	char delimiter() default '\0';
+
+	/**
+	 * The column delimiter to use when reading the CSV files.
+	 * This can't be set simultaneously with {@link #delimiter delimiter}.
+	 * If neither attributes are set, the delimiter will be ','.
 	 */
-	char delimiter() default ',';
+	String delimiterString() default "";
 
 	/**
 	 * The number of lines to skip when reading the CSV files.
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
index 66492cde3..9692fc1d3 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
@@ -51,10 +51,17 @@ public @interface CsvSource {
 
 	/**
 	 * The column delimiter to use when reading the {@linkplain #value lines}.
-	 *
-	 * <p>Defaults to {@code ','}.
+	 * This can't be set simultaneously with {@link #delimiterString delimiterString}.
+	 * If neither attributes are set, the delimiter will be ','.
+	 */
+	char delimiter() default '\0';
+
+	/**
+	 * The column delimiter to use when reading the {@linkplain #value lines}.
+	 * This can't be set simultaneously with {@link #delimiter delimiter}.
+	 * If neither attributes are set, the delimiter will be ','.
 	 */
-	char delimiter() default ',';
+	String delimiterString() default "";
 
 	/**
 	 * The empty value to use when reading the {@linkplain #value lines}.
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
index 6f8f33343..f1d5eb51e 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
@@ -19,6 +19,7 @@ import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.PreconditionViolationException;
 
 /**
  * @since 5.0
@@ -103,10 +104,35 @@ class CsvArgumentsProviderTests {
 		assertThat(arguments).containsExactly(new Object[][] { { "", "" }, { null, null } });
 	}
 
+	@Test
+	void providesArgumentsWithStringDelimiter() {
+		Stream<Object[]> arguments = provideArguments(",", "", "foo, bar", "bar, foo");
+
+		assertThat(arguments).containsExactly(new String[] { "foo", "bar" }, new String[] { "bar", "foo" });
+	}
+
+	@Test
+	void throwsExceptionIfBothDelimitersAreSimultaneouslySet() {
+		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments(",", ',', "", "foo"));
+
+		assertThat(exception).hasMessageStartingWith("delimiter and delimiterString cannot be simultaneously set in");
+	}
+
 	private Stream<Object[]> provideArguments(char delimiter, String emptyValue, String... value) {
+		return provideArguments("", delimiter, emptyValue, value);
+	}
+
+	private Stream<Object[]> provideArguments(String delimiterString, String emptyValue, String... value) {
+		return provideArguments(delimiterString, '\0', emptyValue, value);
+	}
+
+	private Stream<Object[]> provideArguments(String delimiterString, char delimiter, String emptyValue,
+			String... value) {
 		CsvSource annotation = mock(CsvSource.class);
 		when(annotation.value()).thenReturn(value);
 		when(annotation.delimiter()).thenReturn(delimiter);
+		when(annotation.delimiterString()).thenReturn(delimiterString);
 		when(annotation.emptyValue()).thenReturn(emptyValue);
 
 		CsvArgumentsProvider provider = new CsvArgumentsProvider();
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
index 08c9d1071..a177795be 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
@@ -34,21 +34,59 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void providesArgumentsForNewlineAndComma() {
-		Stream<Object[]> arguments = provideArguments("foo, bar \n baz, qux \n", "\n", ',', "");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.lineSeparator("\n")//
+				.delimiter(',')//
+				.build();
+
+		Stream<Object[]> arguments = provideArguments("foo, bar \n baz, qux \n", annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "foo", "bar" }, new Object[] { "baz", "qux" });
 	}
 
 	@Test
 	void providesArgumentsForCarriageReturnAndSemicolon() {
-		Stream<Object[]> arguments = provideArguments("foo; bar \r baz; qux", "\r", ';', "");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.lineSeparator("\r")//
+				.delimiter(';')//
+				.build();
+
+		Stream<Object[]> arguments = provideArguments("foo; bar \r baz; qux", annotation);
+
+		assertThat(arguments).containsExactly(new Object[] { "foo", "bar" }, new Object[] { "baz", "qux" });
+	}
+
+	@Test
+	void providesArgumentsWithStringDelimiter() {
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.delimiterString(",")//
+				.build();
+
+		Stream<Object[]> arguments = provideArguments("foo, bar \n baz, qux \n", annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "foo", "bar" }, new Object[] { "baz", "qux" });
 	}
 
+	@Test
+	void throwsExceptionIfBothDelimitersAreSimultaneouslySet() {
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.delimiter(',')//
+				.delimiterString(";")//
+				.build();
+
+		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments("foo", annotation));
+
+		assertThat(exception).hasMessageStartingWith("delimiter and delimiterString cannot be simultaneously set in");
+	}
+
 	@Test
 	void ignoresCommentedOutEntries() {
-		Stream<Object[]> arguments = provideArguments("foo, bar \n#baz, qux", "\n", ',', "");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.delimiter(',')//
+				.build();
+
+		Stream<Object[]> arguments = provideArguments("foo, bar \n#baz, qux", annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "foo", "bar" });
 	}
@@ -64,7 +102,7 @@ class CsvFileArgumentsProviderTests {
 			}
 		};
 
-		Stream<Object[]> arguments = provideArguments(inputStream, "\n", ',', "");
+		Stream<Object[]> arguments = provideArguments(inputStream, CsvFileSourceMock.getDefault());
 
 		assertThat(arguments.count()).isEqualTo(1);
 		assertThat(closed.get()).describedAs("closed").isTrue();
@@ -72,9 +110,12 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromSingleClasspathResource() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", "/single-column.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("ISO-8859-1")//
+				.resources("/single-column.csv")//
+				.build();
 
-		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "foo" }, new Object[] { "bar" }, new Object[] { "baz" },
 			new Object[] { "qux" }, new Object[] { "" });
@@ -82,9 +123,13 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromSingleClasspathResourceWithCustomEmptyValue() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "vacio", "/single-column.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("ISO-8859-1")//
+				.resources("/single-column.csv")//
+				.emptyValue("vacio")//
+				.build();
 
-		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "foo" }, new Object[] { "bar" }, new Object[] { "baz" },
 			new Object[] { "qux" }, new Object[] { "vacio" });
@@ -92,18 +137,25 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromMultipleClasspathResources() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", "/single-column.csv", "/single-column.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("ISO-8859-1")//
+				.resources("/single-column.csv", "/single-column.csv")//
+				.build();
 
-		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
 
 		assertThat(arguments).hasSize(10);
 	}
 
 	@Test
 	void readsFromSingleClasspathResourceWithHeaders() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", 1, "/single-column.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("ISO-8859-1")//
+				.resources("/single-column.csv")//
+				.numLinesToSkip(1)//
+				.build();
 
-		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "bar" }, new Object[] { "baz" }, new Object[] { "qux" },
 			new Object[] { "" });
@@ -111,19 +163,26 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromSingleClasspathResourceWithMoreHeadersThanLines() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", 10, "/single-column.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("ISO-8859-1")//
+				.resources("/single-column.csv")//
+				.numLinesToSkip(10)//
+				.build();
 
-		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
 
 		assertThat(arguments).isEmpty();
 	}
 
 	@Test
 	void readsFromMultipleClasspathResourcesWithHeaders() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", 1, "/single-column.csv",
-			"/single-column.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("ISO-8859-1")//
+				.resources("/single-column.csv", "/single-column.csv")//
+				.numLinesToSkip(1)//
+				.build();
 
-		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
 
 		assertThat(arguments).containsExactly(new Object[] { "bar" }, new Object[] { "baz" }, new Object[] { "qux" },
 			new Object[] { "" }, new Object[] { "bar" }, new Object[] { "baz" }, new Object[] { "qux" },
@@ -132,30 +191,37 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void throwsExceptionForMissingClasspathResource() {
-		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "", "/does-not-exist.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.resources("/does-not-exist.csv")//
+				.build();
 
 		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
-			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
 
 		assertThat(exception).hasMessageContaining("Classpath resource [/does-not-exist.csv] does not exist");
 	}
 
 	@Test
 	void throwsExceptionForBlankClasspathResource() {
-		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "", "    ");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.resources("    ")//
+				.build();
 
 		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
-			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
 
 		assertThat(exception).hasMessageContaining("Classpath resource [    ] must not be null or blank");
 	}
 
 	@Test
 	void throwsExceptionForInvalidCharset() {
-		CsvFileSource annotation = annotation("Bogus-Charset", "\n", ',', "/bogus-charset.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.charset("Bogus-Charset")//
+				.resources("/bogus-charset.csv")//
+				.build();
 
 		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
-			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
 
 		assertThat(exception)//
 				.hasMessageContaining("The charset supplied in Mock for CsvFileSource")//
@@ -164,52 +230,33 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void throwsExceptionForInvalidCsvFormat() {
-		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "", "/broken.csv");
+		CsvFileSource annotation = CsvFileSourceMock.builder()//
+				.resources("/broken.csv")//
+				.build();
 
 		CsvParsingException exception = assertThrows(CsvParsingException.class,
-			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
 
 		assertThat(exception)//
 				.hasMessageStartingWith("Failed to parse CSV input configured via Mock for CsvFileSource")//
 				.hasRootCauseInstanceOf(ArrayIndexOutOfBoundsException.class);
 	}
 
-	private CsvFileSource annotation(String charset, String lineSeparator, char delimiter, String emptyValue,
-			String... resources) {
-		return annotation(charset, lineSeparator, delimiter, emptyValue, 0, resources);
-	}
-
-	private CsvFileSource annotation(String charset, String lineSeparator, char delimiter, String emptyValue,
-			int numLinesToSkip, String... resources) {
-
-		CsvFileSource annotation = mock(CsvFileSource.class);
-		when(annotation.resources()).thenReturn(resources);
-		when(annotation.encoding()).thenReturn(charset);
-		when(annotation.lineSeparator()).thenReturn(lineSeparator);
-		when(annotation.delimiter()).thenReturn(delimiter);
-		when(annotation.emptyValue()).thenReturn(emptyValue);
-		when(annotation.numLinesToSkip()).thenReturn(numLinesToSkip);
-		return annotation;
-	}
-
-	private Stream<Object[]> provideArguments(String content, String lineSeparator, char delimiter, String emptyValue) {
-		return provideArguments(new ByteArrayInputStream(content.getBytes(UTF_8)), lineSeparator, delimiter,
-			emptyValue);
+	private Stream<Object[]> provideArguments(String content, CsvFileSource annotation) {
+		return provideArguments(new ByteArrayInputStream(content.getBytes(UTF_8)), annotation);
 	}
 
-	private Stream<Object[]> provideArguments(InputStream inputStream, String lineSeparator, char delimiter,
-			String emptyValue) {
-		String expectedResource = "foo/bar";
-		CsvFileSource annotation = annotation("ISO-8859-1", lineSeparator, delimiter, emptyValue, expectedResource);
+	private Stream<Object[]> provideArguments(InputStream inputStream, CsvFileSource annotation) {
+		String expectedResource = annotation.resources()[0];
 
 		CsvFileArgumentsProvider provider = new CsvFileArgumentsProvider((testClass, resource) -> {
 			assertThat(resource).isEqualTo(expectedResource);
 			return inputStream;
 		});
-		return provide(provider, annotation);
+		return provideArguments(provider, annotation);
 	}
 
-	private Stream<Object[]> provide(CsvFileArgumentsProvider provider, CsvFileSource annotation) {
+	private Stream<Object[]> provideArguments(CsvFileArgumentsProvider provider, CsvFileSource annotation) {
 		provider.accept(annotation);
 		ExtensionContext context = mock(ExtensionContext.class);
 		when(context.getTestClass()).thenReturn(Optional.of(CsvFileArgumentsProviderTests.class));
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileSourceMock.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileSourceMock.java
new file mode 100644
index 000000000..fbf42a193
--- /dev/null
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileSourceMock.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.params.provider;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+class CsvFileSourceMock {
+
+	private String[] resources = new String[] { "foo/bar" };
+	private String charset = "UTF-8";
+	private String lineSeparator = "\n";
+	private char delimiter = '\0';
+	private String delimiterString = "";
+	private String emptyValue = "";
+	private int numLinesToSkip = 0;
+
+	private CsvFileSourceMock() {
+	}
+
+	static CsvFileSourceMock builder() {
+		return new CsvFileSourceMock();
+	}
+
+	static CsvFileSource getDefault() {
+		return new CsvFileSourceMock().build();
+	}
+
+	CsvFileSourceMock resources(String... resources) {
+		this.resources = resources;
+		return this;
+	}
+
+	CsvFileSourceMock charset(String charset) {
+		this.charset = charset;
+		return this;
+	}
+
+	CsvFileSourceMock lineSeparator(String lineSeparator) {
+		this.lineSeparator = lineSeparator;
+		return this;
+	}
+
+	CsvFileSourceMock delimiter(char delimiter) {
+		this.delimiter = delimiter;
+		return this;
+	}
+
+	CsvFileSourceMock delimiterString(String delimiterString) {
+		this.delimiterString = delimiterString;
+		return this;
+	}
+
+	CsvFileSourceMock emptyValue(String emptyValue) {
+		this.emptyValue = emptyValue;
+		return this;
+	}
+
+	CsvFileSourceMock numLinesToSkip(int numLinesToSkip) {
+		this.numLinesToSkip = numLinesToSkip;
+		return this;
+	}
+
+	CsvFileSource build() {
+		CsvFileSource annotation = mock(CsvFileSource.class);
+		when(annotation.resources()).thenReturn(resources);
+		when(annotation.encoding()).thenReturn(charset);
+		when(annotation.lineSeparator()).thenReturn(lineSeparator);
+		when(annotation.delimiter()).thenReturn(delimiter);
+		when(annotation.delimiterString()).thenReturn(delimiterString);
+		when(annotation.emptyValue()).thenReturn(emptyValue);
+		when(annotation.numLinesToSkip()).thenReturn(numLinesToSkip);
+		return annotation;
+	}
+}
