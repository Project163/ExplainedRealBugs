diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index be76fc61d..8c73d6d54 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -74,7 +74,10 @@ repository on GitHub.
 
 ==== Bug Fixes
 
-* â“
+* When converting an argument for a `@ParameterizedTest` method from a fully-qualified
+  class name (`String`) to a `Class`, the `ClassLoader` of the class in which the
+  `@ParameterizedTest` method is declared is now used to resolve the `Class` instead of
+  the _default_ `ClassLoader`.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-params/junit-jupiter-params.gradle.kts b/junit-jupiter-params/junit-jupiter-params.gradle.kts
index f023f4c3e..ac4303020 100644
--- a/junit-jupiter-params/junit-jupiter-params.gradle.kts
+++ b/junit-jupiter-params/junit-jupiter-params.gradle.kts
@@ -18,6 +18,7 @@ dependencies {
 	testImplementation(projects.junitJupiterEngine)
 	testImplementation(projects.junitPlatformLauncher)
 	testImplementation(projects.junitPlatformSuiteEngine)
+	testImplementation(testFixtures(projects.junitPlatformCommons))
 	testImplementation(testFixtures(projects.junitJupiterEngine))
 
 	compileOnly(kotlin("stdlib"))
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
index 5f3b159af..43223b0d3 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
@@ -253,7 +253,7 @@ class ParameterizedTestMethodContext {
 
 		@Override
 		public Object resolve(ParameterContext parameterContext, Object[] arguments, int invocationIndex) {
-			ArgumentsAccessor accessor = new DefaultArgumentsAccessor(invocationIndex, arguments);
+			ArgumentsAccessor accessor = new DefaultArgumentsAccessor(parameterContext, invocationIndex, arguments);
 			try {
 				return this.argumentsAggregator.aggregateArguments(accessor, parameterContext);
 			}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessor.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessor.java
index d5990c471..33064919c 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessor.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessor.java
@@ -18,6 +18,7 @@ import java.util.Collections;
 import java.util.List;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.params.converter.DefaultArgumentConverter;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.Preconditions;
@@ -35,12 +36,15 @@ import org.junit.platform.commons.util.Preconditions;
 @API(status = INTERNAL, since = "5.2")
 public class DefaultArgumentsAccessor implements ArgumentsAccessor {
 
+	private final ParameterContext parameterContext;
 	private final int invocationIndex;
 	private final Object[] arguments;
 
-	public DefaultArgumentsAccessor(int invocationIndex, Object... arguments) {
+	public DefaultArgumentsAccessor(ParameterContext parameterContext, int invocationIndex, Object... arguments) {
+		Preconditions.notNull(parameterContext, "ParameterContext must not be null");
 		Preconditions.condition(invocationIndex >= 1, () -> "invocation index must be >= 1");
 		Preconditions.notNull(arguments, "Arguments array must not be null");
+		this.parameterContext = parameterContext;
 		this.invocationIndex = invocationIndex;
 		this.arguments = arguments;
 	}
@@ -57,7 +61,8 @@ public class DefaultArgumentsAccessor implements ArgumentsAccessor {
 		Preconditions.notNull(requiredType, "requiredType must not be null");
 		Object value = get(index);
 		try {
-			Object convertedValue = DefaultArgumentConverter.INSTANCE.convert(value, requiredType);
+			Object convertedValue = DefaultArgumentConverter.INSTANCE.convert(value, requiredType,
+				this.parameterContext);
 			return requiredType.cast(convertedValue);
 		}
 		catch (Exception ex) {
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/DefaultArgumentConverter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/DefaultArgumentConverter.java
index 6f85dd6cf..83ff6fa24 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/DefaultArgumentConverter.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/DefaultArgumentConverter.java
@@ -49,6 +49,8 @@ import java.util.UUID;
 import java.util.function.Function;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.platform.commons.util.ClassLoaderUtils;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
 
@@ -70,7 +72,7 @@ import org.junit.platform.commons.util.ReflectionUtils;
  * @see org.junit.jupiter.params.converter.ArgumentConverter
  */
 @API(status = INTERNAL, since = "5.0")
-public class DefaultArgumentConverter extends SimpleArgumentConverter {
+public class DefaultArgumentConverter implements ArgumentConverter {
 
 	public static final DefaultArgumentConverter INSTANCE = new DefaultArgumentConverter();
 
@@ -78,6 +80,7 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 		new StringToBooleanConverter(), //
 		new StringToCharacterConverter(), //
 		new StringToNumberConverter(), //
+		new StringToClassConverter(), //
 		new StringToEnumConverter(), //
 		new StringToJavaTimeConverter(), //
 		new StringToCommonJavaTypesConverter(), //
@@ -89,7 +92,12 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 	}
 
 	@Override
-	public Object convert(Object source, Class<?> targetType) {
+	public final Object convert(Object source, ParameterContext context) {
+		Class<?> targetType = context.getParameter().getType();
+		return convert(source, targetType, context);
+	}
+
+	public final Object convert(Object source, Class<?> targetType, ParameterContext context) {
 		if (source == null) {
 			if (targetType.isPrimitive()) {
 				throw new ArgumentConversionException(
@@ -102,17 +110,17 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 			return source;
 		}
 
-		return convertToTargetType(source, targetType);
-	}
-
-	private Object convertToTargetType(Object source, Class<?> targetType) {
 		if (source instanceof String) {
 			Class<?> targetTypeToUse = toWrapperType(targetType);
 			Optional<StringToObjectConverter> converter = stringToObjectConverters.stream().filter(
 				candidate -> candidate.canConvert(targetTypeToUse)).findFirst();
 			if (converter.isPresent()) {
+				ClassLoader classLoader = context.getDeclaringExecutable().getDeclaringClass().getClassLoader();
+				if (classLoader == null) {
+					classLoader = ClassLoaderUtils.getDefaultClassLoader();
+				}
 				try {
-					return converter.get().convert((String) source, targetTypeToUse);
+					return converter.get().convert((String) source, targetTypeToUse, classLoader);
 				}
 				catch (Exception ex) {
 					if (ex instanceof ArgumentConversionException) {
@@ -146,6 +154,10 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 
 		Object convert(String source, Class<?> targetType) throws Exception;
 
+		default Object convert(String source, Class<?> targetType, ClassLoader classLoader) throws Exception {
+			return convert(source, targetType);
+		}
+
 	}
 
 	private static class StringToBooleanConverter implements StringToObjectConverter {
@@ -203,6 +215,29 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 		}
 	}
 
+	private static class StringToClassConverter implements StringToObjectConverter {
+
+		@Override
+		public boolean canConvert(Class<?> targetType) {
+			return targetType == Class.class;
+		}
+
+		@Override
+		public Object convert(String source, Class<?> targetType) throws Exception {
+			throw new UnsupportedOperationException();
+		}
+
+		@Override
+		public Object convert(String className, Class<?> targetType, ClassLoader classLoader) throws Exception {
+			// @formatter:off
+			return ReflectionUtils.tryToLoadClass(className, classLoader)
+					.getOrThrow(cause -> new ArgumentConversionException(
+							"Failed to convert String \"" + className + "\" to type java.lang.Class", cause));
+			// @formatter:on
+		}
+
+	}
+
 	private static class StringToEnumConverter implements StringToObjectConverter {
 
 		@Override
@@ -261,8 +296,6 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 		static {
 			Map<Class<?>, Function<String, ?>> converters = new HashMap<>();
 
-			// java.lang
-			converters.put(Class.class, StringToCommonJavaTypesConverter::toClass);
 			// java.io and java.nio
 			converters.put(File.class, File::new);
 			converters.put(Charset.class, Charset::forName);
@@ -291,14 +324,6 @@ public class DefaultArgumentConverter extends SimpleArgumentConverter {
 			return CONVERTERS.get(targetType).apply(source);
 		}
 
-		private static Class<?> toClass(String type) {
-			// @formatter:off
-			return ReflectionUtils.tryToLoadClass(type)
-					.getOrThrow(cause -> new ArgumentConversionException(
-							"Failed to convert String \"" + type + "\" to type java.lang.Class", cause));
-			// @formatter:on
-		}
-
 		private static URL toURL(String url) {
 			try {
 				return URI.create(url).toURL();
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessorTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessorTests.java
index f56beb375..10abef084 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessorTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/DefaultArgumentsAccessorTests.java
@@ -16,11 +16,16 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertIterableEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
+import java.lang.reflect.Method;
 import java.util.Arrays;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.platform.commons.PreconditionViolationException;
+import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
  * Unit tests for {@link DefaultArgumentsAccessor}.
@@ -31,53 +36,53 @@ class DefaultArgumentsAccessorTests {
 
 	@Test
 	void argumentsMustNotBeNull() {
-		assertThrows(PreconditionViolationException.class, () -> new DefaultArgumentsAccessor(1, (Object[]) null));
+		assertThrows(PreconditionViolationException.class, () -> defaultArgumentsAccessor(1, (Object[]) null));
 	}
 
 	@Test
 	void indexMustNotBeNegative() {
-		ArgumentsAccessor arguments = new DefaultArgumentsAccessor(1, 1, 2);
+		ArgumentsAccessor arguments = defaultArgumentsAccessor(1, 1, 2);
 		Exception exception = assertThrows(PreconditionViolationException.class, () -> arguments.get(-1));
 		assertThat(exception.getMessage()).containsSubsequence("index must be", ">= 0");
 	}
 
 	@Test
 	void indexMustBeSmallerThanLength() {
-		ArgumentsAccessor arguments = new DefaultArgumentsAccessor(1, 1, 2);
+		ArgumentsAccessor arguments = defaultArgumentsAccessor(1, 1, 2);
 		Exception exception = assertThrows(PreconditionViolationException.class, () -> arguments.get(2));
 		assertThat(exception.getMessage()).containsSubsequence("index must be", "< 2");
 	}
 
 	@Test
 	void getNull() {
-		assertNull(new DefaultArgumentsAccessor(1, new Object[] { null }).get(0));
+		assertNull(defaultArgumentsAccessor(1, new Object[] { null }).get(0));
 	}
 
 	@Test
 	void getWithNullCastToWrapperType() {
-		assertNull(new DefaultArgumentsAccessor(1, (Object[]) new Integer[] { null }).get(0, Integer.class));
+		assertNull(defaultArgumentsAccessor(1, (Object[]) new Integer[] { null }).get(0, Integer.class));
 	}
 
 	@Test
 	void get() {
-		assertEquals(1, new DefaultArgumentsAccessor(1, 1).get(0));
+		assertEquals(1, defaultArgumentsAccessor(1, 1).get(0));
 	}
 
 	@Test
 	void getWithCast() {
-		assertEquals(Integer.valueOf(1), new DefaultArgumentsAccessor(1, 1).get(0, Integer.class));
-		assertEquals(Character.valueOf('A'), new DefaultArgumentsAccessor(1, 'A').get(0, Character.class));
+		assertEquals(Integer.valueOf(1), defaultArgumentsAccessor(1, 1).get(0, Integer.class));
+		assertEquals(Character.valueOf('A'), defaultArgumentsAccessor(1, 'A').get(0, Character.class));
 	}
 
 	@Test
 	void getWithCastToPrimitiveType() {
 		Exception exception = assertThrows(ArgumentAccessException.class,
-			() -> new DefaultArgumentsAccessor(1, 1).get(0, int.class));
+			() -> defaultArgumentsAccessor(1, 1).get(0, int.class));
 		assertThat(exception.getMessage()).isEqualTo(
 			"Argument at index [0] with value [1] and type [java.lang.Integer] could not be converted or cast to type [int].");
 
 		exception = assertThrows(ArgumentAccessException.class,
-			() -> new DefaultArgumentsAccessor(1, new Object[] { null }).get(0, int.class));
+			() -> defaultArgumentsAccessor(1, new Object[] { null }).get(0, int.class));
 		assertThat(exception.getMessage()).isEqualTo(
 			"Argument at index [0] with value [null] and type [null] could not be converted or cast to type [int].");
 	}
@@ -85,59 +90,59 @@ class DefaultArgumentsAccessorTests {
 	@Test
 	void getWithCastToIncompatibleType() {
 		Exception exception = assertThrows(ArgumentAccessException.class,
-			() -> new DefaultArgumentsAccessor(1, 1).get(0, Character.class));
+			() -> defaultArgumentsAccessor(1, 1).get(0, Character.class));
 		assertThat(exception.getMessage()).isEqualTo(
 			"Argument at index [0] with value [1] and type [java.lang.Integer] could not be converted or cast to type [java.lang.Character].");
 	}
 
 	@Test
 	void getCharacter() {
-		assertEquals(Character.valueOf('A'), new DefaultArgumentsAccessor(1, 'A', 'B').getCharacter(0));
+		assertEquals(Character.valueOf('A'), defaultArgumentsAccessor(1, 'A', 'B').getCharacter(0));
 	}
 
 	@Test
 	void getBoolean() {
-		assertEquals(Boolean.TRUE, new DefaultArgumentsAccessor(1, true, false).getBoolean(0));
+		assertEquals(Boolean.TRUE, defaultArgumentsAccessor(1, true, false).getBoolean(0));
 	}
 
 	@Test
 	void getByte() {
-		assertEquals(Byte.valueOf((byte) 42), new DefaultArgumentsAccessor(1, (byte) 42).getByte(0));
+		assertEquals(Byte.valueOf((byte) 42), defaultArgumentsAccessor(1, (byte) 42).getByte(0));
 	}
 
 	@Test
 	void getShort() {
-		assertEquals(Short.valueOf((short) 42), new DefaultArgumentsAccessor(1, (short) 42).getShort(0));
+		assertEquals(Short.valueOf((short) 42), defaultArgumentsAccessor(1, (short) 42).getShort(0));
 	}
 
 	@Test
 	void getInteger() {
-		assertEquals(Integer.valueOf(42), new DefaultArgumentsAccessor(1, 42).getInteger(0));
+		assertEquals(Integer.valueOf(42), defaultArgumentsAccessor(1, 42).getInteger(0));
 	}
 
 	@Test
 	void getLong() {
-		assertEquals(Long.valueOf(42L), new DefaultArgumentsAccessor(1, 42L).getLong(0));
+		assertEquals(Long.valueOf(42L), defaultArgumentsAccessor(1, 42L).getLong(0));
 	}
 
 	@Test
 	void getFloat() {
-		assertEquals(Float.valueOf(42.0f), new DefaultArgumentsAccessor(1, 42.0f).getFloat(0));
+		assertEquals(Float.valueOf(42.0f), defaultArgumentsAccessor(1, 42.0f).getFloat(0));
 	}
 
 	@Test
 	void getDouble() {
-		assertEquals(Double.valueOf(42.0), new DefaultArgumentsAccessor(1, 42.0).getDouble(0));
+		assertEquals(Double.valueOf(42.0), defaultArgumentsAccessor(1, 42.0).getDouble(0));
 	}
 
 	@Test
 	void getString() {
-		assertEquals("foo", new DefaultArgumentsAccessor(1, "foo", "bar").getString(0));
+		assertEquals("foo", defaultArgumentsAccessor(1, "foo", "bar").getString(0));
 	}
 
 	@Test
 	void toArray() {
-		var arguments = new DefaultArgumentsAccessor(1, "foo", "bar");
+		var arguments = defaultArgumentsAccessor(1, "foo", "bar");
 		var copy = arguments.toArray();
 		assertArrayEquals(new String[] { "foo", "bar" }, copy);
 
@@ -148,7 +153,7 @@ class DefaultArgumentsAccessorTests {
 
 	@Test
 	void toList() {
-		var arguments = new DefaultArgumentsAccessor(1, "foo", "bar");
+		var arguments = defaultArgumentsAccessor(1, "foo", "bar");
 		var copy = arguments.toList();
 		assertIterableEquals(Arrays.asList("foo", "bar"), copy);
 
@@ -158,9 +163,24 @@ class DefaultArgumentsAccessorTests {
 
 	@Test
 	void size() {
-		assertEquals(0, new DefaultArgumentsAccessor(1).size());
-		assertEquals(1, new DefaultArgumentsAccessor(1, 42).size());
-		assertEquals(5, new DefaultArgumentsAccessor(1, 'a', 'b', 'c', 'd', 'e').size());
+		assertEquals(0, defaultArgumentsAccessor(1).size());
+		assertEquals(1, defaultArgumentsAccessor(1, 42).size());
+		assertEquals(5, defaultArgumentsAccessor(1, 'a', 'b', 'c', 'd', 'e').size());
+	}
+
+	private static DefaultArgumentsAccessor defaultArgumentsAccessor(int invocationIndex, Object... arguments) {
+		return new DefaultArgumentsAccessor(parameterContext(), invocationIndex, arguments);
+	}
+
+	private static ParameterContext parameterContext() {
+		Method declaringExecutable = ReflectionUtils.findMethod(DefaultArgumentsAccessorTests.class, "foo").get();
+		ParameterContext parameterContext = mock();
+		when(parameterContext.getDeclaringExecutable()).thenReturn(declaringExecutable);
+		return parameterContext;
+	}
+
+	@SuppressWarnings("unused")
+	private static void foo() {
 	}
 
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/DefaultArgumentConverterTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/DefaultArgumentConverterTests.java
index 8548cb3ca..07b49f494 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/DefaultArgumentConverterTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/DefaultArgumentConverterTests.java
@@ -12,9 +12,12 @@ package org.junit.jupiter.params.converter;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import java.io.File;
 import java.lang.Thread.State;
+import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.URI;
@@ -43,6 +46,9 @@ import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.platform.commons.test.TestClassLoader;
+import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
  * Unit tests for {@link DefaultArgumentConverter}.
@@ -202,6 +208,23 @@ class DefaultArgumentConverterTests {
 		assertConverts("[[Ljava.lang.String;", Class.class, String[][].class);
 	}
 
+	@Test
+	void convertsStringToClassWithCustomTypeFromDifferentClassLoader() throws Exception {
+		String customTypeName = Enigma.class.getName();
+		try (TestClassLoader customTypeClassLoader = TestClassLoader.forClasses(Enigma.class)) {
+			var customType = customTypeClassLoader.loadClass(customTypeName);
+			assertThat(customType.getClassLoader()).isInstanceOf(TestClassLoader.class);
+
+			var declaringExecutable = ReflectionUtils.findMethod(customType, "foo").get();
+			assertThat(declaringExecutable.getDeclaringClass().getClassLoader()).isInstanceOf(TestClassLoader.class);
+
+			var clazz = (Class<?>) convert(customTypeName, Class.class, parameterContext(declaringExecutable));
+			assertThat(clazz).isNotEqualTo(Enigma.class);
+			assertThat(clazz).isEqualTo(customType);
+			assertThat(clazz.getClassLoader()).isInstanceOf(TestClassLoader.class);
+		}
+	}
+
 	// --- java.math -----------------------------------------------------------
 
 	@Test
@@ -280,10 +303,33 @@ class DefaultArgumentConverterTests {
 	}
 
 	private Object convert(Object input, Class<?> targetClass) {
-		return DefaultArgumentConverter.INSTANCE.convert(input, targetClass);
+		return convert(input, targetClass, parameterContext());
+	}
+
+	private Object convert(Object input, Class<?> targetClass, ParameterContext parameterContext) {
+		return DefaultArgumentConverter.INSTANCE.convert(input, targetClass, parameterContext);
+	}
+
+	private static ParameterContext parameterContext() {
+		Method declaringExecutable = ReflectionUtils.findMethod(DefaultArgumentConverterTests.class, "foo").get();
+		return parameterContext(declaringExecutable);
+	}
+
+	private static ParameterContext parameterContext(Method declaringExecutable) {
+		ParameterContext parameterContext = mock();
+		when(parameterContext.getDeclaringExecutable()).thenReturn(declaringExecutable);
+		return parameterContext;
+	}
+
+	@SuppressWarnings("unused")
+	private static void foo() {
 	}
 
 	private static class Enigma {
+
+		@SuppressWarnings("unused")
+		void foo() {
+		}
 	}
 
 }
diff --git a/junit-jupiter-params/src/test/kotlin/org/junit/jupiter/params/aggregator/ArgumentsAccessorKotlinTests.kt b/junit-jupiter-params/src/test/kotlin/org/junit/jupiter/params/aggregator/ArgumentsAccessorKotlinTests.kt
index d30f8f8e2..3c50a0d17 100644
--- a/junit-jupiter-params/src/test/kotlin/org/junit/jupiter/params/aggregator/ArgumentsAccessorKotlinTests.kt
+++ b/junit-jupiter-params/src/test/kotlin/org/junit/jupiter/params/aggregator/ArgumentsAccessorKotlinTests.kt
@@ -13,6 +13,11 @@ import org.assertj.core.api.Assertions.assertThat
 import org.junit.jupiter.api.Assertions.assertEquals
 import org.junit.jupiter.api.Test
 import org.junit.jupiter.api.assertThrows
+import org.junit.jupiter.api.extension.ParameterContext
+import org.junit.platform.commons.util.ReflectionUtils
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.`when`
+import java.lang.reflect.Method
 
 /**
  * Unit tests for using [ArgumentsAccessor] from Kotlin.
@@ -21,14 +26,14 @@ class ArgumentsAccessorKotlinTests {
 
     @Test
     fun `get() with reified type and index`() {
-        assertEquals(1, DefaultArgumentsAccessor(1, 1).get<Int>(0))
-        assertEquals('A', DefaultArgumentsAccessor(1, 'A').get<Char>(0))
+        assertEquals(1, defaultArgumentsAccessor(1, 1).get<Int>(0))
+        assertEquals('A', defaultArgumentsAccessor(1, 'A').get<Char>(0))
     }
 
     @Test
     fun `get() with reified type and index for incompatible type`() {
         val exception = assertThrows<ArgumentAccessException> {
-            DefaultArgumentsAccessor(1, Integer.valueOf(1)).get<Char>(0)
+            defaultArgumentsAccessor(1, Integer.valueOf(1)).get<Char>(0)
         }
 
         assertThat(exception).hasMessage(
@@ -38,13 +43,27 @@ class ArgumentsAccessorKotlinTests {
 
     @Test
     fun `get() with index`() {
-        assertEquals(1, DefaultArgumentsAccessor(1, 1).get(0))
-        assertEquals('A', DefaultArgumentsAccessor(1, 'A').get(0))
+        assertEquals(1, defaultArgumentsAccessor(1, 1).get(0))
+        assertEquals('A', defaultArgumentsAccessor(1, 'A').get(0))
     }
 
     @Test
     fun `get() with index and class reference`() {
-        assertEquals(1, DefaultArgumentsAccessor(1, 1).get(0, Integer::class.java))
-        assertEquals('A', DefaultArgumentsAccessor(1, 'A').get(0, Character::class.java))
+        assertEquals(1, defaultArgumentsAccessor(1, 1).get(0, Integer::class.java))
+        assertEquals('A', defaultArgumentsAccessor(1, 'A').get(0, Character::class.java))
+    }
+
+    fun defaultArgumentsAccessor(invocationIndex: Int, vararg arguments: Any): DefaultArgumentsAccessor {
+        return DefaultArgumentsAccessor(parameterContext(), invocationIndex, *arguments)
+    }
+
+    fun parameterContext(): ParameterContext {
+        val declaringExecutable: Method = ReflectionUtils.findMethod(DefaultArgumentsAccessorTests::class.java, "foo").get()
+        val parameterContext: ParameterContext = mock()
+        `when`(parameterContext.getDeclaringExecutable()).thenReturn(declaringExecutable)
+        return parameterContext
+    }
+
+    fun foo() {
     }
 }
