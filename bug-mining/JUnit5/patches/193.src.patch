diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc
index 31f90949b..cc2c28975 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc
@@ -48,6 +48,8 @@ on GitHub.
 * `ArgumentConverters` and `ArgumentsAggregators` registered using `@ConvertWith` and
   `@AggregateWith`, respectively, are now only instantiated once per `@ParameterizedTest`
   instead of once for each invocation.
+* Performance improvements for executing parameterized tests, particularly when the method
+  declares more than a few parameters.
 
 
 [[release-notes-5.3.0-RC1-junit-vintage]]
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
index b297a8e49..e435cc290 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
@@ -10,24 +10,19 @@
 
 package org.junit.jupiter.params;
 
-import static org.junit.jupiter.params.aggregator.AggregationUtils.hasAggregator;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 import static org.junit.platform.commons.util.AnnotationUtils.findRepeatableAnnotations;
 import static org.junit.platform.commons.util.AnnotationUtils.isAnnotated;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
-import org.junit.jupiter.params.aggregator.AggregationUtils;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
-import org.junit.jupiter.params.converter.ArgumentConverter;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.ArgumentsProvider;
 import org.junit.jupiter.params.provider.ArgumentsSource;
@@ -41,6 +36,8 @@ import org.junit.platform.commons.util.ReflectionUtils;
  */
 class ParameterizedTestExtension implements TestTemplateInvocationContextProvider {
 
+	private static final String METHOD_CONTEXT_KEY = "context";
+
 	@Override
 	public boolean supportsTestTemplate(ExtensionContext context) {
 		if (!context.getTestMethod().isPresent()) {
@@ -52,22 +49,26 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 			return false;
 		}
 
-		Preconditions.condition(AggregationUtils.hasPotentiallyValidSignature(testMethod),
+		ParameterizedTestMethodContext methodContext = new ParameterizedTestMethodContext(testMethod);
+
+		Preconditions.condition(methodContext.hasPotentiallyValidSignature(),
 			() -> String.format(
 				"@ParameterizedTest method [%s] declares formal parameters in an invalid order: "
 						+ "argument aggregators must be declared after any indexed arguments "
 						+ "and before any arguments resolved by another ParameterResolver.",
 				testMethod.toGenericString()));
 
+		getStore(context).put(METHOD_CONTEXT_KEY, methodContext);
+
 		return true;
 	}
 
 	@Override
-	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {
-		Method templateMethod = context.getRequiredTestMethod();
-
-		Map<Class<? extends ArgumentsAggregator>, ArgumentsAggregator> aggregators = new ConcurrentHashMap<>();
-		Map<Class<? extends ArgumentConverter>, ArgumentConverter> converters = new ConcurrentHashMap<>();
+	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(
+			ExtensionContext extensionContext) {
+		Method templateMethod = extensionContext.getRequiredTestMethod();
+		ParameterizedTestMethodContext methodContext = getStore(extensionContext).get(METHOD_CONTEXT_KEY,
+			ParameterizedTestMethodContext.class);
 
 		ParameterizedTestNameFormatter formatter = createNameFormatter(templateMethod);
 		AtomicLong invocationCount = new AtomicLong(0);
@@ -77,10 +78,10 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 				.map(ArgumentsSource::value)
 				.map(ReflectionUtils::newInstance)
 				.map(provider -> AnnotationConsumerInitializer.initialize(templateMethod, provider))
-				.flatMap(provider -> arguments(provider, context))
+				.flatMap(provider -> arguments(provider, extensionContext))
 				.map(Arguments::get)
-				.map(arguments -> consumedArguments(arguments, templateMethod))
-				.map(arguments -> createInvocationContext(formatter, arguments, aggregators, converters))
+				.map(arguments -> consumedArguments(arguments, methodContext))
+				.map(arguments -> createInvocationContext(formatter, methodContext, arguments))
 				.peek(invocationContext -> invocationCount.incrementAndGet())
 				.onClose(() ->
 						Preconditions.condition(invocationCount.get() > 0,
@@ -88,10 +89,13 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		// @formatter:on
 	}
 
+	private ExtensionContext.Store getStore(ExtensionContext context) {
+		return context.getStore(Namespace.create(ParameterizedTestExtension.class, context.getRequiredTestMethod()));
+	}
+
 	private TestTemplateInvocationContext createInvocationContext(ParameterizedTestNameFormatter formatter,
-			Object[] arguments, Map<Class<? extends ArgumentsAggregator>, ArgumentsAggregator> aggregators,
-			Map<Class<? extends ArgumentConverter>, ArgumentConverter> converters) {
-		return new ParameterizedTestInvocationContext(formatter, arguments, aggregators, converters);
+			ParameterizedTestMethodContext methodContext, Object[] arguments) {
+		return new ParameterizedTestInvocationContext(formatter, methodContext, arguments);
 	}
 
 	private ParameterizedTestNameFormatter createNameFormatter(Method templateMethod) {
@@ -112,9 +116,9 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		}
 	}
 
-	private Object[] consumedArguments(Object[] arguments, Method templateMethod) {
-		int parameterCount = templateMethod.getParameterCount();
-		return hasAggregator(templateMethod) ? arguments
+	private Object[] consumedArguments(Object[] arguments, ParameterizedTestMethodContext methodContext) {
+		int parameterCount = methodContext.getParameterCount();
+		return methodContext.hasAggregator() ? arguments
 				: (arguments.length > parameterCount ? Arrays.copyOf(arguments, parameterCount) : arguments);
 	}
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java
index 58d1e6bb2..1002d9863 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java
@@ -13,12 +13,9 @@ package org.junit.jupiter.params;
 import static java.util.Collections.singletonList;
 
 import java.util.List;
-import java.util.Map;
 
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
-import org.junit.jupiter.params.converter.ArgumentConverter;
 
 /**
  * @since 5.0
@@ -26,17 +23,14 @@ import org.junit.jupiter.params.converter.ArgumentConverter;
 class ParameterizedTestInvocationContext implements TestTemplateInvocationContext {
 
 	private final ParameterizedTestNameFormatter formatter;
+	private final ParameterizedTestMethodContext methodContext;
 	private final Object[] arguments;
-	private final Map<Class<? extends ArgumentsAggregator>, ArgumentsAggregator> aggregators;
-	private final Map<Class<? extends ArgumentConverter>, ArgumentConverter> converters;
 
-	ParameterizedTestInvocationContext(ParameterizedTestNameFormatter formatter, Object[] arguments,
-			Map<Class<? extends ArgumentsAggregator>, ArgumentsAggregator> aggregators,
-			Map<Class<? extends ArgumentConverter>, ArgumentConverter> converters) {
+	ParameterizedTestInvocationContext(ParameterizedTestNameFormatter formatter,
+			ParameterizedTestMethodContext methodContext, Object[] arguments) {
 		this.formatter = formatter;
+		this.methodContext = methodContext;
 		this.arguments = arguments;
-		this.aggregators = aggregators;
-		this.converters = converters;
 	}
 
 	@Override
@@ -46,7 +40,7 @@ class ParameterizedTestInvocationContext implements TestTemplateInvocationContex
 
 	@Override
 	public List<Extension> getAdditionalExtensions() {
-		return singletonList(new ParameterizedTestParameterResolver(this.arguments, this.aggregators, this.converters));
+		return singletonList(new ParameterizedTestParameterResolver(this.methodContext, this.arguments));
 	}
 
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
new file mode 100644
index 000000000..8105ae1ba
--- /dev/null
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
@@ -0,0 +1,254 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.params;
+
+import static org.junit.jupiter.params.ParameterizedTestMethodContext.ResolverType.AGGREGATOR;
+import static org.junit.jupiter.params.ParameterizedTestMethodContext.ResolverType.CONVERTER;
+import static org.junit.platform.commons.util.AnnotationUtils.isAnnotated;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Parameter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.params.aggregator.AggregateWith;
+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
+import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
+import org.junit.jupiter.params.aggregator.DefaultArgumentsAccessor;
+import org.junit.jupiter.params.converter.ArgumentConverter;
+import org.junit.jupiter.params.converter.ConvertWith;
+import org.junit.jupiter.params.converter.DefaultArgumentConverter;
+import org.junit.jupiter.params.support.AnnotationConsumerInitializer;
+import org.junit.platform.commons.support.ReflectionSupport;
+import org.junit.platform.commons.util.AnnotationUtils;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.StringUtils;
+
+/**
+ * Encapsulates access to the parameters of a parameterized test method and
+ * caches the converters and aggregators used to resolve them.
+ *
+ * @since 5.3
+ */
+class ParameterizedTestMethodContext {
+
+	private final List<ResolverType> resolverTypes;
+	private final Resolver[] resolvers;
+
+	ParameterizedTestMethodContext(Method testMethod) {
+		Parameter[] parameters = testMethod.getParameters();
+		this.resolverTypes = new ArrayList<>(parameters.length);
+		this.resolvers = new Resolver[parameters.length];
+		for (Parameter parameter : parameters) {
+			this.resolverTypes.add(isAggregator(parameter) ? AGGREGATOR : CONVERTER);
+		}
+	}
+
+	/**
+	 * Determine if the supplied {@link Parameter} is an aggregator (i.e., of
+	 * type {@link ArgumentsAccessor} or annotated with {@link AggregateWith}).
+	 *
+	 * @return {@code true} if the parameter is an aggregator
+	 */
+	private static boolean isAggregator(Parameter parameter) {
+		return ArgumentsAccessor.class.isAssignableFrom(parameter.getType())
+				|| isAnnotated(parameter, AggregateWith.class);
+	}
+
+	/**
+	 * Determine if the {@link Method} represented by this context has a
+	 * <em>potentially</em> valid signature (i.e., formal parameter
+	 * declarations) with regard to aggregators.
+	 *
+	 * <p>This method takes a best-effort approach at enforcing the following
+	 * policy for parameterized test methods that accept aggregators as arguments.
+	 *
+	 * <ol>
+	 * <li>zero or more <em>indexed arguments</em> come first.</li>
+	 * <li>zero or more <em>aggregators</em> come next.</li>
+	 * <li>zero or more arguments supplied by other {@code ParameterResolver}
+	 * implementations come last.</li>
+	 * </ol>
+	 *
+	 * @return {@code true} if the method has a potentially valid signature
+	 */
+	boolean hasPotentiallyValidSignature() {
+		int indexOfPreviousAggregator = -1;
+		for (int i = 0; i < getParameterCount(); i++) {
+			if (isAggregator(i)) {
+				if ((indexOfPreviousAggregator != -1) && (i != indexOfPreviousAggregator + 1)) {
+					return false;
+				}
+				indexOfPreviousAggregator = i;
+			}
+		}
+		return true;
+	}
+
+	/**
+	 * Get the number of parameters of the {@link Method} represented by this
+	 * context.
+	 */
+	int getParameterCount() {
+		return resolvers.length;
+	}
+
+	/**
+	 * Determine if the {@link Method} represented by this context declares at
+	 * least one {@link Parameter} that is an
+	 * {@linkplain #isAggregator aggregator}.
+	 *
+	 * @return {@code true} if the method has an aggregator
+	 */
+	boolean hasAggregator() {
+		return resolverTypes.contains(AGGREGATOR);
+	}
+
+	/**
+	 * Determine if the {@link Parameter} with the supplied index is an
+	 * aggregator (i.e., of type {@link ArgumentsAccessor} or annotated with
+	 * {@link AggregateWith}).
+	 *
+	 * @return {@code true} if the parameter is an aggregator
+	 */
+	boolean isAggregator(int parameterIndex) {
+		return resolverTypes.get(parameterIndex) == AGGREGATOR;
+	}
+
+	/**
+	 * Find the index of the first {@linkplain #isAggregator aggregator}
+	 * {@link Parameter} in the {@link Method} represented by this context.
+	 *
+	 * @return the index of the first aggregator, or {@code -1} if not found
+	 */
+	int indexOfFirstAggregator() {
+		return resolverTypes.indexOf(AGGREGATOR);
+	}
+
+	/**
+	 * Resolve the parameter for the supplied context using the supplied
+	 * arguments.
+	 */
+	Object resolve(ParameterContext parameterContext, Object[] arguments) {
+		return getResolver(parameterContext).resolve(parameterContext, arguments);
+	}
+
+	private Resolver getResolver(ParameterContext parameterContext) {
+		int index = parameterContext.getIndex();
+		if (resolvers[index] == null) {
+			resolvers[index] = resolverTypes.get(index).createResolver(parameterContext);
+		}
+		return resolvers[index];
+	}
+
+	enum ResolverType {
+
+		CONVERTER {
+			@Override
+			Resolver createResolver(ParameterContext parameterContext) {
+				try { // @formatter:off
+					return AnnotationUtils.findAnnotation(parameterContext.getParameter(), ConvertWith.class)
+							.map(ConvertWith::value)
+							.map(clazz -> (ArgumentConverter) ReflectionUtils.newInstance(clazz))
+							.map(converter -> AnnotationConsumerInitializer.initialize(parameterContext.getParameter(), converter))
+							.map(Converter::new)
+							.orElse(Converter.DEFAULT);
+				} // @formatter:on
+				catch (Exception ex) {
+					throw parameterResolutionException("Error creating ArgumentConverter", ex, parameterContext);
+				}
+			}
+		},
+
+		AGGREGATOR {
+			@Override
+			Resolver createResolver(ParameterContext parameterContext) {
+				try { // @formatter:off
+					return AnnotationUtils.findAnnotation(parameterContext.getParameter(), AggregateWith.class)
+							.map(AggregateWith::value)
+							.map(clazz -> (ArgumentsAggregator) ReflectionSupport.newInstance(clazz))
+							.map(Aggregator::new)
+							.orElse(Aggregator.DEFAULT);
+				} // @formatter:on
+				catch (Exception ex) {
+					throw parameterResolutionException("Error creating ArgumentsAggregator", ex, parameterContext);
+				}
+			}
+		};
+
+		abstract Resolver createResolver(ParameterContext parameterContext);
+
+	}
+
+	interface Resolver {
+
+		Object resolve(ParameterContext parameterContext, Object[] arguments);
+
+	}
+
+	static class Converter implements Resolver {
+
+		private static final Converter DEFAULT = new Converter(DefaultArgumentConverter.INSTANCE);
+
+		private final ArgumentConverter argumentConverter;
+
+		Converter(ArgumentConverter argumentConverter) {
+			this.argumentConverter = argumentConverter;
+		}
+
+		@Override
+		public Object resolve(ParameterContext parameterContext, Object[] arguments) {
+			Object argument = arguments[parameterContext.getIndex()];
+			try {
+				return this.argumentConverter.convert(argument, parameterContext);
+			}
+			catch (Exception ex) {
+				throw parameterResolutionException("Error converting parameter", ex, parameterContext);
+			}
+		}
+
+	}
+
+	static class Aggregator implements Resolver {
+
+		private static final Aggregator DEFAULT = new Aggregator((accessor, context) -> accessor);
+
+		private final ArgumentsAggregator argumentsAggregator;
+
+		Aggregator(ArgumentsAggregator argumentsAggregator) {
+			this.argumentsAggregator = argumentsAggregator;
+		}
+
+		@Override
+		public Object resolve(ParameterContext parameterContext, Object[] arguments) {
+			ArgumentsAccessor accessor = new DefaultArgumentsAccessor(arguments);
+			try {
+				return this.argumentsAggregator.aggregateArguments(accessor, parameterContext);
+			}
+			catch (Exception ex) {
+				throw parameterResolutionException("Error aggregating arguments for parameter", ex, parameterContext);
+			}
+		}
+
+	}
+
+	private static ParameterResolutionException parameterResolutionException(String message, Exception cause,
+			ParameterContext parameterContext) {
+		String fullMessage = message + " at index " + parameterContext.getIndex();
+		if (StringUtils.isNotBlank(cause.getMessage())) {
+			fullMessage += ": " + cause.getMessage();
+		}
+		return new ParameterResolutionException(fullMessage, cause);
+	}
+
+}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
index a0de7bc06..8f44f615a 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
@@ -10,47 +10,25 @@
 
 package org.junit.jupiter.params;
 
-import static org.junit.jupiter.params.aggregator.AggregationUtils.indexOfFirstAggregator;
-import static org.junit.jupiter.params.aggregator.AggregationUtils.isAggregator;
-
 import java.lang.reflect.Executable;
 import java.lang.reflect.Method;
-import java.lang.reflect.Parameter;
-import java.util.Map;
-import java.util.Optional;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
-import org.junit.jupiter.params.aggregator.AggregateWith;
-import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
-import org.junit.jupiter.params.aggregator.DefaultArgumentsAccessor;
-import org.junit.jupiter.params.converter.ArgumentConverter;
-import org.junit.jupiter.params.converter.ConvertWith;
-import org.junit.jupiter.params.converter.DefaultArgumentConverter;
-import org.junit.jupiter.params.support.AnnotationConsumerInitializer;
-import org.junit.platform.commons.support.ReflectionSupport;
-import org.junit.platform.commons.util.AnnotationUtils;
-import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.commons.util.StringUtils;
 
 /**
  * @since 5.0
  */
 class ParameterizedTestParameterResolver implements ParameterResolver {
 
+	private final ParameterizedTestMethodContext methodContext;
 	private final Object[] arguments;
-	private final Map<Class<? extends ArgumentsAggregator>, ArgumentsAggregator> aggregators;
-	private final Map<Class<? extends ArgumentConverter>, ArgumentConverter> converters;
 
-	ParameterizedTestParameterResolver(Object[] arguments,
-			Map<Class<? extends ArgumentsAggregator>, ArgumentsAggregator> aggregators,
-			Map<Class<? extends ArgumentConverter>, ArgumentConverter> converters) {
+	ParameterizedTestParameterResolver(ParameterizedTestMethodContext methodContext, Object[] arguments) {
+		this.methodContext = methodContext;
 		this.arguments = arguments;
-		this.aggregators = aggregators;
-		this.converters = converters;
 	}
 
 	@Override
@@ -64,15 +42,14 @@ class ParameterizedTestParameterResolver implements ParameterResolver {
 		}
 
 		// Current parameter is an aggregator?
-		if (isAggregator(parameterContext.getParameter())) {
+		if (this.methodContext.isAggregator(parameterContext.getIndex())) {
 			return true;
 		}
 
 		// Ensure that the current parameter is declared before aggregators.
 		// Otherwise, a different ParameterResolver should handle it.
-		int indexOfFirstAggregator = indexOfFirstAggregator(testMethod);
-		if (indexOfFirstAggregator != -1) {
-			return parameterContext.getIndex() < indexOfFirstAggregator;
+		if (this.methodContext.indexOfFirstAggregator() != -1) {
+			return parameterContext.getIndex() < this.methodContext.indexOfFirstAggregator();
 		}
 
 		// Else fallback to behavior for parameterized test methods without aggregators.
@@ -83,55 +60,7 @@ class ParameterizedTestParameterResolver implements ParameterResolver {
 	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
 			throws ParameterResolutionException {
 
-		return isAggregator(parameterContext.getParameter()) ? aggregate(parameterContext) : convert(parameterContext);
-	}
-
-	private Object convert(ParameterContext parameterContext) {
-		Parameter parameter = parameterContext.getParameter();
-		Object argument = this.arguments[parameterContext.getIndex()];
-		Optional<ConvertWith> annotation = AnnotationUtils.findAnnotation(parameter, ConvertWith.class);
-		// @formatter:off
-		ArgumentConverter argumentConverter = annotation.map(ConvertWith::value)
-				.map(clazz -> converters.computeIfAbsent(clazz, ReflectionUtils::newInstance))
-				.map(converter -> AnnotationConsumerInitializer.initialize(parameter, converter))
-				.orElse(DefaultArgumentConverter.INSTANCE);
-		// @formatter:on
-		try {
-			return argumentConverter.convert(argument, parameterContext);
-		}
-		catch (Exception ex) {
-			throw parameterResolutionException("Error converting parameter", ex, parameterContext);
-		}
-	}
-
-	private Object aggregate(ParameterContext parameterContext) {
-		Parameter parameter = parameterContext.getParameter();
-		Optional<AggregateWith> annotation = AnnotationUtils.findAnnotation(parameter, AggregateWith.class);
-		ArgumentsAccessor accessor = new DefaultArgumentsAccessor(this.arguments);
-		if (annotation.isPresent()) {
-			return aggregateSafely(annotation.get().value(), accessor, parameterContext);
-		}
-		return accessor;
-	}
-
-	private Object aggregateSafely(Class<? extends ArgumentsAggregator> clazz, ArgumentsAccessor accessor,
-			ParameterContext parameterContext) {
-		try {
-			ArgumentsAggregator aggregator = aggregators.computeIfAbsent(clazz, ReflectionSupport::newInstance);
-			return aggregator.aggregateArguments(accessor, parameterContext);
-		}
-		catch (Exception ex) {
-			throw parameterResolutionException("Error aggregating arguments for parameter", ex, parameterContext);
-		}
-	}
-
-	private ParameterResolutionException parameterResolutionException(String message, Exception cause,
-			ParameterContext context) {
-		String fullMessage = message + " at index " + context.getIndex();
-		if (StringUtils.isNotBlank(cause.getMessage())) {
-			fullMessage += ": " + cause.getMessage();
-		}
-		return new ParameterResolutionException(fullMessage, cause);
+		return this.methodContext.resolve(parameterContext, this.arguments);
 	}
 
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/AggregationUtils.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/AggregationUtils.java
deleted file mode 100644
index 7104be40f..000000000
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/aggregator/AggregationUtils.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.params.aggregator;
-
-import static org.apiguardian.api.API.Status.INTERNAL;
-import static org.junit.platform.commons.util.AnnotationUtils.isAnnotated;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.Parameter;
-
-import org.apiguardian.api.API;
-
-/**
- * Collection of utilities for working with aggregating argument consumers
- * in parameterized tests (i.e., parameters of type {@link ArgumentsAccessor}
- * or annotated with {@link AggregateWith @AggregateWith}).
- *
- * @since 5.2
- */
-@API(status = INTERNAL, since = "5.2")
-public class AggregationUtils {
-
-	private AggregationUtils() {
-		/* no-op */
-	}
-
-	/**
-	 * Determine if the supplied {@link Method} has a <em>potentially</em>
-	 * valid signature (i.e., formal parameter declarations) with regard to
-	 * aggregators.
-	 *
-	 * <p>This method takes a best-effort approach at enforcing the following
-	 * policy for parameterized test methods that accept aggregators as arguments.
-	 *
-	 * <ol>
-	 * <li>zero or more <em>indexed arguments</em> come first.</li>
-	 * <li>zero or more <em>aggregators</em> come next.</li>
-	 * <li>zero or more arguments supplied by other {@code ParameterResolver}
-	 * implementations come last.</li>
-	 * </ol>
-	 *
-	 * @return {@code true} if the method has a potentially valid signature
-	 */
-	public static boolean hasPotentiallyValidSignature(Method method) {
-		Parameter[] parameters = method.getParameters();
-		int indexOfPreviousAggregator = -1;
-		for (int i = 0; i < parameters.length; i++) {
-			if (isAggregator(parameters[i])) {
-				if ((indexOfPreviousAggregator != -1) && (i != indexOfPreviousAggregator + 1)) {
-					return false;
-				}
-				indexOfPreviousAggregator = i;
-			}
-		}
-		return true;
-	}
-
-	/**
-	 * Determine if the supplied {@link Parameter} is an aggregator (i.e., of
-	 * type {@link ArgumentsAccessor} or annotated with {@link AggregateWith}).
-	 *
-	 * @return {@code true} if the parameter is an aggregator
-	 */
-	public static boolean isAggregator(Parameter parameter) {
-		return ArgumentsAccessor.class.isAssignableFrom(parameter.getType())
-				|| isAnnotated(parameter, AggregateWith.class);
-	}
-
-	/**
-	 * Determine if the supplied {@link Method} declares at least one
-	 * {@link Parameter} that is an {@linkplain #isAggregator aggregator}.
-	 *
-	 * @return {@code true} if the method has an aggregator
-	 */
-	public static boolean hasAggregator(Method method) {
-		return indexOfFirstAggregator(method) != -1;
-	}
-
-	/**
-	 * Find the index of the first {@linkplain #isAggregator aggregator}
-	 * {@link Parameter} in the supplied {@link Method}.
-	 *
-	 * @return the index of the first aggregator, or {@code -1} if not found
-	 */
-	public static int indexOfFirstAggregator(Method method) {
-		Parameter[] parameters = method.getParameters();
-		for (int i = 0; i < parameters.length; i++) {
-			if (isAggregator(parameters[i])) {
-				return i;
-			}
-		}
-		return -1;
-	}
-
-}
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
index 94830bb94..bcde168b6 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
@@ -30,6 +30,8 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInstance.Lifecycle;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
+import org.junit.jupiter.engine.execution.ExtensionValuesStore;
+import org.junit.jupiter.engine.execution.NamespaceAwareStore;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.ArgumentsProvider;
 import org.junit.jupiter.params.provider.ArgumentsSource;
@@ -71,6 +73,9 @@ class ParameterizedTestExtensionTests {
 	void streamsReturnedByProvidersAreClosedWhenCallingProvide() {
 		ExtensionContext extensionContext = getExtensionContextReturningSingleMethod(
 			new TestCaseWithArgumentSourceAnnotatedMethod());
+		// we need to call supportsTestTemplate() first, because it creates and
+		// puts the ParameterizedTestMethodContext into the Store
+		this.parameterizedTestExtension.supportsTestTemplate(extensionContext);
 
 		Stream<TestTemplateInvocationContext> stream = this.parameterizedTestExtension.provideTestTemplateInvocationContexts(
 			extensionContext);
@@ -116,6 +121,8 @@ class ParameterizedTestExtensionTests {
 
 		return new ExtensionContext() {
 
+			private final ExtensionValuesStore store = new ExtensionValuesStore(null);
+
 			@Override
 			public Optional<Method> getTestMethod() {
 				return optional;
@@ -182,7 +189,7 @@ class ParameterizedTestExtensionTests {
 
 			@Override
 			public Store getStore(Namespace namespace) {
-				return null;
+				return new NamespaceAwareStore(store, namespace);
 			}
 		};
 	}
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregationUtilsTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestMethodContextTests.java
similarity index 84%
rename from junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregationUtilsTests.java
rename to junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestMethodContextTests.java
index c1a0171a0..6b0fa3e04 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregationUtilsTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestMethodContextTests.java
@@ -8,39 +8,38 @@
  * http://www.eclipse.org/legal/epl-v20.html
  */
 
-package org.junit.jupiter.params.aggregator;
+package org.junit.jupiter.params;
 
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.params.aggregator.AggregationUtils.hasPotentiallyValidSignature;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
 import org.junit.jupiter.api.TestInfo;
-import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.aggregator.AggregatorIntegrationTests.CsvToPerson;
 import org.junit.jupiter.params.aggregator.AggregatorIntegrationTests.Person;
+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 import org.junit.jupiter.params.provider.ValueSource;
 
 /**
- * Unit tests for {@link AggregationUtils}.
+ * Unit tests for {@link ParameterizedTestMethodContext}.
  *
  * @since 5.2
  */
-class AggregationUtilsTests {
+class ParameterizedTestMethodContextTests {
 
 	@ParameterizedTest
 	@ValueSource(strings = { "onePrimitive", "twoPrimitives", "twoAggregators", "twoAggregatorsWithTestInfoAtTheEnd",
 			"mixedMode" })
 	void validSignatures(String name) {
-		assertTrue(hasPotentiallyValidSignature(method(name)));
+		assertTrue(new ParameterizedTestMethodContext(method(name)).hasPotentiallyValidSignature());
 	}
 
 	@ParameterizedTest
 	@ValueSource(strings = { "twoAggregatorsWithPrimitiveInTheMiddle", "twoAggregatorsWithTestInfoInTheMiddle" })
 	void invalidSignatures(String name) {
-		assertFalse(hasPotentiallyValidSignature(method(name)));
+		assertFalse(new ParameterizedTestMethodContext(method(name)).hasPotentiallyValidSignature());
 	}
 
 	private Method method(String name) {
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregatorIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregatorIntegrationTests.java
index 11d8c54a7..4f652aaa0 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregatorIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/aggregator/AggregatorIntegrationTests.java
@@ -58,7 +58,7 @@ import org.junit.platform.engine.test.event.ExecutionEventRecorder;
  *
  * @since 5.2
  */
-class AggregatorIntegrationTests {
+public class AggregatorIntegrationTests {
 
 	@ParameterizedTest
 	@CsvSource({ "Jane, Doe, 1980-04-16, F, red", "Jack, Smith, 2000-11-22, M, blue" })
@@ -204,7 +204,7 @@ class AggregatorIntegrationTests {
 
 	// -------------------------------------------------------------------------
 
-	static class Person {
+	public static class Person {
 
 		final String firstName;
 		final String lastName;
@@ -249,7 +249,7 @@ class AggregatorIntegrationTests {
 	@Retention(RetentionPolicy.RUNTIME)
 	@Target(ElementType.PARAMETER)
 	@AggregateWith(PersonAggregator.class)
-	@interface CsvToPerson {
+	public @interface CsvToPerson {
 	}
 
 	@Retention(RetentionPolicy.RUNTIME)
