diff --git a/build.gradle b/build.gradle
index 6a8749724..dc9f0eb42 100644
--- a/build.gradle
+++ b/build.gradle
@@ -228,6 +228,10 @@ subprojects { subproj ->
 		classpath = project.sourceSets.main.compileClasspath + configurations.shadowed
 	}
 
+	checkstyleMain {
+		classpath += configurations.shadowed
+	}
+
 	if (subproj.name in mavenizedProjects) {
 
 		apply from: "$rootDir/gradle/publishing.gradle"
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc
index f93789457..045793877 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.0-RC1.adoc
@@ -40,6 +40,13 @@ on GitHub.
 * If the new experimental feature is enabled, captured output to `System.out` and
   `System.err` is now written to the dedicated `system-out` and `system-err` elements,
   respectively, in the XML report generated by `ConsoleLauncher`.
+* The `ConsoleLauncher` now uses the https://github.com/remkop/picocli[picocli] library
+  under the hood to parse the command line and generate usage help. Users may now pass
+  command line arguments via an argument file (`@-file`) to the console launcher.
+  Argument files allow users to work around system limitations on the length of a command
+  line when creating a command line with lots of options or with long arguments for
+  options. The usage help is now displayed using ANSI colors on supported platforms.
+
 
 
 [[release-notes-5.3.0-RC1-junit-jupiter]]
diff --git a/documentation/src/docs/asciidoc/user-guide/running-tests.adoc b/documentation/src/docs/asciidoc/user-guide/running-tests.adoc
index 070489b70..849f92cc3 100644
--- a/documentation/src/docs/asciidoc/user-guide/running-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/running-tests.adoc
@@ -598,6 +598,32 @@ is `0`.
 include::{consoleLauncherOptionsFile}[]
 ----
 
+==== @-files
+On some platforms you may run into system limitations on the length of a command line
+when creating a command line with lots of options or with long arguments.
+
+Starting from v5.3-RC1, the `ConsoleLauncher` supports "argument files" or "@-files".
+Argument files are files that themselves contain arguments to the command.
+When the underlying https://github.com/remkop/picocli[picocli] command line parser
+encounters an argument beginning with the character `@`, it expands the contents of that
+file into the argument list.
+
+The arguments within a file can be space-separated or newline-separated.
+If an argument contains embedded whitespace, put the whole argument in double or single
+quotes (`"-f=My Files\Stuff.java"`).
+
+If the file does not exist, or cannot be read, then the argument will be treated
+literally, and not removed. This will likely result in an "unmatched argument" error
+message. You can troubleshoot by executing the command with system property
+`picocli.trace` set to `DEBUG`.
+
+Multiple @-files may be specified on the command line.
+The specified path may be relative to the current directory or absolute.
+
+You can pass a real parameter with an initial '@' character by escaping it
+with an additional '@' symbol, e.g. '@@somearg' will become '@somearg' and not be subject
+to expansion.
+
 
 [[running-tests-junit-platform-runner]]
 === Using JUnit 4 to run the JUnit Platform
diff --git a/junit-platform-console/junit-platform-console.gradle b/junit-platform-console/junit-platform-console.gradle
index 78db0be47..66ff589c6 100644
--- a/junit-platform-console/junit-platform-console.gradle
+++ b/junit-platform-console/junit-platform-console.gradle
@@ -5,7 +5,7 @@ description = 'JUnit Platform Console'
 dependencies {
 	api(project(':junit-platform-launcher'))
 
-	shadowed('net.sf.jopt-simple:jopt-simple:5.0.4')
+	shadowed('info.picocli:picocli:3.5.1')
 }
 
 jar {
@@ -29,16 +29,7 @@ shadowJar {
 	classifier = null
 	configurations = [project.configurations.shadowed]
 	exclude 'META-INF/**'
-	relocate 'joptsimple', 'org.junit.platform.console.shadow.joptsimple'
-	transform(com.github.jengelman.gradle.plugins.shadow.transformers.PropertiesFileTransformer) {
-		paths = [
-			'joptsimple/ExceptionMessages.properties',
-			'joptsimple/HelpFormatterMessages.properties'
-		]
-		keyTransformer = { key ->
-			key.replaceAll('^(joptsimple\\..*)$', 'org.junit.platform.console.shadow.$1')
-		}
-	}
+	relocate 'picocli', 'org.junit.platform.console.shadow.picocli'
 	from(projectDir) {
 		include 'LICENSE-jopt-simple.md'
 		into 'META-INF'
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/ConsoleLauncher.java b/junit-platform-console/src/main/java/org/junit/platform/console/ConsoleLauncher.java
index 4489e0b8b..167c47561 100644
--- a/junit-platform-console/src/main/java/org/junit/platform/console/ConsoleLauncher.java
+++ b/junit-platform-console/src/main/java/org/junit/platform/console/ConsoleLauncher.java
@@ -17,12 +17,14 @@ import java.io.BufferedWriter;
 import java.io.OutputStreamWriter;
 import java.io.PrintStream;
 import java.io.PrintWriter;
+import java.io.StringWriter;
 import java.nio.charset.Charset;
 
 import org.apiguardian.api.API;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.console.options.CommandLineOptions;
 import org.junit.platform.console.options.CommandLineOptionsParser;
-import org.junit.platform.console.options.JOptSimpleCommandLineOptionsParser;
+import org.junit.platform.console.options.PicocliCommandLineOptionsParser;
 import org.junit.platform.console.tasks.ConsoleTestExecutor;
 import org.junit.platform.launcher.listeners.TestExecutionSummary;
 
@@ -42,7 +44,7 @@ public class ConsoleLauncher {
 
 	@API(status = INTERNAL, since = "1.0")
 	public static ConsoleLauncherExecutionResult execute(PrintStream out, PrintStream err, String... args) {
-		CommandLineOptionsParser parser = new JOptSimpleCommandLineOptionsParser();
+		CommandLineOptionsParser parser = new PicocliCommandLineOptionsParser();
 		ConsoleLauncher consoleLauncher = new ConsoleLauncher(parser, out, err);
 		return consoleLauncher.execute(args);
 	}
@@ -65,7 +67,18 @@ public class ConsoleLauncher {
 	}
 
 	ConsoleLauncherExecutionResult execute(String... args) {
-		CommandLineOptions options = commandLineOptionsParser.parse(args);
+
+		CommandLineOptions options = null;
+		try {
+			options = commandLineOptionsParser.parse(args);
+		}
+		catch (JUnitException ex) {
+			errStream.println(ex.getMessage());
+			StringWriter sw = new StringWriter();
+			commandLineOptionsParser.printHelp(new PrintWriter(sw));
+			errStream.println(sw);
+			return ConsoleLauncherExecutionResult.failed();
+		}
 		try (PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStream, charset)))) {
 			if (options.isDisplayHelp()) {
 				commandLineOptionsParser.printHelp(out);
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java b/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java
index 63a2493c1..c04169a99 100644
--- a/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java
+++ b/junit-platform-console/src/main/java/org/junit/platform/console/options/AvailableOptions.java
@@ -10,273 +10,328 @@
 
 package org.junit.platform.console.options;
 
-import static java.util.Arrays.asList;
-
-import java.io.File;
 import java.net.URI;
 import java.nio.file.Path;
-import java.util.HashMap;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
-import joptsimple.OptionSpec;
-import joptsimple.util.KeyValuePair;
-import joptsimple.util.PathConverter;
-
 import org.junit.platform.engine.discovery.ClassNameFilter;
 
+import picocli.CommandLine;
+import picocli.CommandLine.Command;
+import picocli.CommandLine.Model.CommandSpec;
+import picocli.CommandLine.Option;
+import picocli.CommandLine.ParameterException;
+import picocli.CommandLine.ParseResult;
+import picocli.CommandLine.Spec;
+
 /**
  * @since 1.0
  */
+@Command(name = "ConsoleLauncher", sortOptions = false, description = "Launches the JUnit Platform from the console.")
 class AvailableOptions {
 
 	private static final String CP_OPTION = "cp";
 
-	private final OptionParser parser = new OptionParser();
-
-	// General Purpose
-	private final OptionSpec<Void> help;
-	private final OptionSpec<Void> disableAnsiColors;
-	private final OptionSpec<Details> details;
-	private final OptionSpec<Theme> theme;
-	private final OptionSpec<Path> additionalClasspathEntries;
-	private final OptionSpec<Void> failIfNoTests;
-
-	// Reports
-	private final OptionSpec<Path> reportsDir;
-
-	// Selectors
-	private final OptionSpec<Path> selectedClasspathEntries;
-	private final OptionSpec<URI> selectedUris;
-	private final OptionSpec<String> selectedFiles;
-	private final OptionSpec<String> selectedDirectories;
-	private final OptionSpec<String> selectedPackages;
-	private final OptionSpec<String> selectedClasses;
-	private final OptionSpec<String> selectedMethods;
-	private final OptionSpec<String> selectedClasspathResources;
-
-	// Java Platform Module System Options
-	private final OptionSpec<Void> scanModulepath;
-	private final OptionSpec<String> selectedModules;
-
-	// Filters
-	private final OptionSpec<String> includeClassNamePattern;
-	private final OptionSpec<String> excludeClassNamePattern;
-	private final OptionSpec<String> includePackage;
-	private final OptionSpec<String> excludePackage;
-	private final OptionSpec<String> includeTag;
-	private final OptionSpec<String> excludeTag;
-	private final OptionSpec<String> includeEngine;
-	private final OptionSpec<String> excludeEngine;
-
-	// Configuration Parameters
-	private final OptionSpec<KeyValuePair> configurationParameters;
+	// --- General Purpose -------------------------------------------------
 
-	AvailableOptions() {
+	@Option(names = { "-h", "--help" }, usageHelp = true, description = "Display help information.")
+	private boolean helpRequested;
+
+	@Option(names = { "--h", "-help" }, help = true, hidden = true)
+	private boolean helpRequested2;
+
+	@Option(names = "--disable-ansi-colors", description = "Disable ANSI colors in output (not supported by all terminals).")
+	private boolean disableAnsiColors;
+
+	@Option(names = "-disable-ansi-colors", hidden = true)
+	private boolean disableAnsiColors2;
 
-		// --- General Purpose -------------------------------------------------
+	@Option(names = "--details", paramLabel = "MODE", description = "Select an output details mode for when tests are executed. " //
+			+ "Use one of: ${COMPLETION-CANDIDATES}. If 'none' is selected, " //
+			+ "then only the summary and test failures are shown. Default: ${DEFAULT-VALUE}.")
+	private Details details = CommandLineOptions.DEFAULT_DETAILS;
 
-		help = parser.acceptsAll(asList("h", "help"), //
-			"Display help information.");
+	@Option(names = "-details", hidden = true)
+	private Details details2 = CommandLineOptions.DEFAULT_DETAILS;
 
-		disableAnsiColors = parser.accepts("disable-ansi-colors",
-			"Disable ANSI colors in output (not supported by all terminals).");
+	@Option(names = "--details-theme", paramLabel = "THEME", description = "Select an output details tree theme for when tests are executed. "
+			+ "Use one of: ${COMPLETION-CANDIDATES}. Default: ${DEFAULT-VALUE}.")
+	private Theme theme = CommandLineOptions.DEFAULT_THEME;
 
-		details = parser.accepts("details",
-			"Select an output details mode for when tests are executed. Use one of: " + asList(Details.values())
-					+ ". If '" + Details.NONE + "' is selected, then only the summary and test failures are shown.") //
-				.withRequiredArg() //
-				.ofType(Details.class) //
-				.withValuesConvertedBy(new DetailsConverter()) //
-				.defaultsTo(CommandLineOptions.DEFAULT_DETAILS);
+	@Option(names = "-details-theme", hidden = true)
+	private Theme theme2 = CommandLineOptions.DEFAULT_THEME;
 
-		theme = parser.accepts("details-theme",
-			"Select an output details tree theme for when tests are executed. Use one of: " + asList(Theme.values())) //
-				.withRequiredArg() //
-				.ofType(Theme.class) //
-				.withValuesConvertedBy(new ThemeConverter()) //
-				.defaultsTo(CommandLineOptions.DEFAULT_THEME);
+	@Option(names = { "-cp", "--classpath",
+			"--class-path" }, split = ";|:", paramLabel = "PATH", arity = "1", description = "Provide additional classpath entries "
+					+ "-- for example, for adding engines and their dependencies. This option can be repeated.")
+	private List<Path> additionalClasspathEntries = new ArrayList<>();
 
-		additionalClasspathEntries = parser.acceptsAll(asList(CP_OPTION, "classpath", "class-path"), //
-			"Provide additional classpath entries -- for example, for adding engines and their dependencies. "
-					+ "This option can be repeated.") //
-				.withRequiredArg() //
-				.withValuesConvertedBy(new PathConverter()) //
-				.withValuesSeparatedBy(File.pathSeparatorChar) //
-				.describedAs("path1" + File.pathSeparator + "path2" + File.pathSeparator + "...");
+	@Option(names = { "--cp", "-classpath", "-class-path" }, split = ";|:", hidden = true)
+	private List<Path> additionalClasspathEntries2 = new ArrayList<>();
 
-		failIfNoTests = parser.accepts("fail-if-no-tests", "Fail and return exit status code 2 if no tests are found.");
+	@Option(names = "--fail-if-no-tests", description = "Fail and return exit status code 2 if no tests are found.")
+	private boolean failIfNoTests; // no single-dash equivelent: was introduced in 5.3-M1
 
-		// --- Reports ---------------------------------------------------------
+	// --- Reports ---------------------------------------------------------
 
-		reportsDir = parser.accepts("reports-dir", //
-			"Enable report output into a specified local directory (will be created if it does not exist).") //
-				.withRequiredArg() //
-				.withValuesConvertedBy(new PathConverter());
+	@Option(names = "--reports-dir", paramLabel = "DIR", description = "Enable report output into a specified local directory (will be created if it does not exist).")
+	private Path reportsDir;
 
-		// --- Java Platform Module System -------------------------------------
+	@Option(names = "-reports-dir", hidden = true)
+	private Path reportsDir2;
 
-		scanModulepath = parser.acceptsAll(asList("scan-modules"), //
-			"EXPERIMENTAL: Scan all resolved modules for test discovery.");
+	// --- Java Platform Module System -------------------------------------
 
-		selectedModules = parser.acceptsAll(asList("o", "select-module"), //
-			"EXPERIMENTAL: Select single module for test discovery. This option can be repeated.") //
-				.withRequiredArg() //
-				.describedAs("module name");
+	@Option(names = "--scan-modules", description = "EXPERIMENTAL: Scan all resolved modules for test discovery.")
+	private boolean scanModulepath;
 
-		// --- Selectors -------------------------------------------------------
+	@Option(names = "-scan-modules", hidden = true)
+	private boolean scanModulepath2;
 
-		selectedClasspathEntries = parser.acceptsAll(asList("scan-class-path", "scan-classpath"), //
-			"Scan all directories on the classpath or explicit classpath roots. " //
+	@Option(names = { "-o",
+			"--select-module" }, paramLabel = "NAME", arity = "1", description = "EXPERIMENTAL: Select single module for test discovery. This option can be repeated.")
+	private List<String> selectedModules = new ArrayList<>();
+
+	@Option(names = { "--o", "-select-module" }, arity = "1", hidden = true)
+	private List<String> selectedModules2 = new ArrayList<>();
+
+	// --- Selectors -------------------------------------------------------
+
+	@Option(names = { "--scan-class-path",
+			"--scan-classpath" }, split = ";|:", paramLabel = "PATH", arity = "0..1", description = "Scan all directories on the classpath or explicit classpath roots. " //
 					+ "Without arguments, only directories on the system classpath as well as additional classpath " //
 					+ "entries supplied via -" + CP_OPTION + " (directories and JAR files) are scanned. " //
 					+ "Explicit classpath roots that are not on the classpath will be silently ignored. " //
-					+ "This option can be repeated.") //
-				.withOptionalArg() //
-				.withValuesConvertedBy(new PathConverter()) //
-				.withValuesSeparatedBy(File.pathSeparatorChar) //
-				.describedAs("path1" + File.pathSeparator + "path2" + File.pathSeparator + "...");
+					+ "This option can be repeated.")
+	private List<Path> selectedClasspathEntries = new ArrayList<>();
+
+	@Option(names = { "-scan-class-path", "-scan-classpath" }, split = ";|:", arity = "0..1", hidden = true)
+	private List<Path> selectedClasspathEntries2 = new ArrayList<>();
+
+	@Option(names = { "-u",
+			"--select-uri" }, paramLabel = "URI", arity = "1", description = "Select a URI for test discovery. This option can be repeated.")
+	private List<URI> selectedUris = new ArrayList<>();
+
+	@Option(names = { "--u", "-select-uri" }, arity = "1", hidden = true)
+	private List<URI> selectedUris2 = new ArrayList<>();
+
+	@Option(names = { "-f",
+			"--select-file" }, paramLabel = "FILE", arity = "1", description = "Select a file for test discovery. This option can be repeated.")
+	private List<String> selectedFiles = new ArrayList<>();
 
-		selectedUris = parser.acceptsAll(asList("u", "select-uri"), //
-			"Select a URI for test discovery. This option can be repeated.") //
-				.withRequiredArg() //
-				.withValuesConvertedBy(new UriConverter());
+	@Option(names = { "--f", "-select-file" }, arity = "1", hidden = true)
+	private List<String> selectedFiles2 = new ArrayList<>();
 
-		selectedFiles = parser.acceptsAll(asList("f", "select-file"), //
-			"Select a file for test discovery. This option can be repeated.") //
-				.withRequiredArg();
+	@Option(names = { "-d",
+			"--select-directory" }, paramLabel = "DIR", arity = "1", description = "Select a directory for test discovery. This option can be repeated.")
+	private List<String> selectedDirectories = new ArrayList<>();
 
-		selectedDirectories = parser.acceptsAll(asList("d", "select-directory"), //
-			"Select a directory for test discovery. This option can be repeated.") //
-				.withRequiredArg();
+	@Option(names = { "--d", "-select-directory" }, arity = "1", hidden = true)
+	private List<String> selectedDirectories2 = new ArrayList<>();
 
-		selectedPackages = parser.acceptsAll(asList("p", "select-package"), //
-			"Select a package for test discovery. This option can be repeated.") //
-				.withRequiredArg();
+	@Option(names = { "-p",
+			"--select-package" }, paramLabel = "PKG", arity = "1", description = "Select a package for test discovery. This option can be repeated.")
+	private List<String> selectedPackages = new ArrayList<>();
 
-		selectedClasses = parser.acceptsAll(asList("c", "select-class"), //
-			"Select a class for test discovery. This option can be repeated.") //
-				.withRequiredArg();
+	@Option(names = { "--p", "-select-package" }, arity = "1", hidden = true)
+	private List<String> selectedPackages2 = new ArrayList<>();
 
-		selectedMethods = parser.acceptsAll(asList("m", "select-method"), //
-			"Select a method for test discovery. This option can be repeated.") //
-				.withRequiredArg();
+	@Option(names = { "-c",
+			"--select-class" }, paramLabel = "CLASS", arity = "1", description = "Select a class for test discovery. This option can be repeated.")
+	private List<String> selectedClasses = new ArrayList<>();
 
-		selectedClasspathResources = parser.acceptsAll(asList("r", "select-resource"), //
-			"Select a classpath resource for test discovery. This option can be repeated.") //
-				.withRequiredArg();
+	@Option(names = { "--c", "-select-class" }, arity = "1", hidden = true)
+	private List<String> selectedClasses2 = new ArrayList<>();
 
-		// --- Filters ---------------------------------------------------------
+	@Option(names = { "-m",
+			"--select-method" }, paramLabel = "NAME", arity = "1", description = "Select a method for test discovery. This option can be repeated.")
+	private List<String> selectedMethods = new ArrayList<>();
 
-		includeClassNamePattern = parser.acceptsAll(asList("n", "include-classname"),
-			"Provide a regular expression to include only classes whose fully qualified names match. " //
+	@Option(names = { "--m", "-select-method" }, arity = "1", hidden = true)
+	private List<String> selectedMethods2 = new ArrayList<>();
+
+	@Option(names = { "-r",
+			"--select-resource" }, paramLabel = "RESOURCE", arity = "1", description = "Select a classpath resource for test discovery. This option can be repeated.")
+	private List<String> selectedClasspathResources = new ArrayList<>();
+
+	@Option(names = { "--r", "-select-resource" }, arity = "1", hidden = true)
+	private List<String> selectedClasspathResources2 = new ArrayList<>();
+
+	// --- Filters ---------------------------------------------------------
+
+	@Option(names = { "-n",
+			"--include-classname" }, paramLabel = "PATTERN", arity = "1", description = "Provide a regular expression to include only classes whose fully qualified names match. " //
 					+ "To avoid loading classes unnecessarily, the default pattern only includes class " //
 					+ "names that begin with \"Test\" or end with \"Test\" or \"Tests\". " //
-					+ "When this option is repeated, all patterns will be combined using OR semantics.") //
-				.withRequiredArg() //
-				.defaultsTo(ClassNameFilter.STANDARD_INCLUDE_PATTERN);
-		excludeClassNamePattern = parser.acceptsAll(asList("N", "exclude-classname"),
-			"Provide a regular expression to exclude those classes whose fully qualified names match. " //
-					+ "When this option is repeated, all patterns will be combined using OR semantics.") //
-				.withRequiredArg();
-
-		includePackage = parser.accepts("include-package",
-			"Provide a package to be included in the test run. This option can be repeated.") //
-				.withRequiredArg();
-		excludePackage = parser.accepts("exclude-package",
-			"Provide a package to be excluded from the test run. This option can be repeated.") //
-				.withRequiredArg();
-
-		includeTag = parser.acceptsAll(asList("t", "include-tag"),
-			"Provide a tag or tag expression to include only tests whose tags match. " + //
-					"When this option is repeated, all patterns will be combined using OR semantics.") //
-				.withRequiredArg();
-		excludeTag = parser.acceptsAll(asList("T", "exclude-tag"),
-			"Provide a tag or tag expression to exclude those tests whose tags match. " + //
-					"When this option is repeated, all patterns will be combined using OR semantics.") //
-				.withRequiredArg();
-
-		includeEngine = parser.acceptsAll(asList("e", "include-engine"),
-			"Provide the ID of an engine to be included in the test run. This option can be repeated.") //
-				.withRequiredArg();
-		excludeEngine = parser.acceptsAll(asList("E", "exclude-engine"),
-			"Provide the ID of an engine to be excluded from the test run. This option can be repeated.") //
-				.withRequiredArg();
-
-		// --- Configuration Parameters ----------------------------------------
-
-		configurationParameters = parser.accepts("config",
-			"Set a configuration parameter for test discovery and execution. This option can be repeated.") //
-				.withRequiredArg() //
-				.withValuesConvertedBy(new KeyValuePairConverter());
+					+ "When this option is repeated, all patterns will be combined using OR semantics. " //
+					+ "Default: ${DEFAULT-VALUE}")
+	private List<String> includeClassNamePatterns = new ArrayList<>(
+		Arrays.asList(ClassNameFilter.STANDARD_INCLUDE_PATTERN));
+
+	@Option(names = { "--n", "-include-classname" }, arity = "1", hidden = true)
+	private List<String> includeClassNamePatterns2 = new ArrayList<>();
+
+	@Option(names = { "-N",
+			"--exclude-classname" }, paramLabel = "PATTERN", arity = "1", description = "Provide a regular expression to exclude those classes whose fully qualified names match. " //
+					+ "When this option is repeated, all patterns will be combined using OR semantics.")
+	private List<String> excludeClassNamePatterns = new ArrayList<>();
+
+	@Option(names = { "--N", "-exclude-classname" }, arity = "1", hidden = true)
+	private List<String> excludeClassNamePatterns2 = new ArrayList<>();
+
+	@Option(names = {
+			"--include-package" }, paramLabel = "PKG", arity = "1", description = "Provide a package to be included in the test run. This option can be repeated.")
+	private List<String> includePackages = new ArrayList<>();
+
+	@Option(names = { "-include-package" }, arity = "1", hidden = true)
+	private List<String> includePackages2 = new ArrayList<>();
+
+	@Option(names = {
+			"--exclude-package" }, paramLabel = "PKG", arity = "1", description = "Provide a package to be excluded from the test run. This option can be repeated.")
+	private List<String> excludePackages = new ArrayList<>();
+
+	@Option(names = { "-exclude-package" }, arity = "1", hidden = true)
+	private List<String> excludePackages2 = new ArrayList<>();
+
+	@Option(names = { "-t",
+			"--include-tag" }, paramLabel = "TAG", arity = "1", description = "Provide a tag or tag expression to include only tests whose tags match. "
+					+ //
+					"When this option is repeated, all patterns will be combined using OR semantics.")
+	private List<String> includedTags = new ArrayList<>();
+
+	@Option(names = { "--t", "-include-tag" }, arity = "1", hidden = true)
+	private List<String> includedTags2 = new ArrayList<>();
+
+	@Option(names = { "-T",
+			"--exclude-tag" }, paramLabel = "TAG", arity = "1", description = "Provide a tag or tag expression to exclude those tests whose tags match. "
+					+ //
+					"When this option is repeated, all patterns will be combined using OR semantics.")
+	private List<String> excludedTags = new ArrayList<>();
+
+	@Option(names = { "--T", "-exclude-tag" }, arity = "1", hidden = true)
+	private List<String> excludedTags2 = new ArrayList<>();
+
+	@Option(names = { "-e",
+			"--include-engine" }, paramLabel = "ID", arity = "1", description = "Provide the ID of an engine to be included in the test run. This option can be repeated.")
+	private List<String> includedEngines = new ArrayList<>();
+
+	@Option(names = { "--e", "-include-engine" }, arity = "1", hidden = true)
+	private List<String> includedEngines2 = new ArrayList<>();
+
+	@Option(names = { "-E",
+			"--exclude-engine" }, paramLabel = "ID", arity = "1", description = "Provide the ID of an engine to be excluded from the test run. This option can be repeated.")
+	private List<String> excludedEngines = new ArrayList<>();
+
+	@Option(names = { "--E", "-exclude-engine" }, arity = "1", hidden = true)
+	private List<String> excludedEngines2 = new ArrayList<>();
+
+	// --- Configuration Parameters ----------------------------------------
+
+	// Implementation note: the @Option annotation is on a setter method to allow validation.
+	private Map<String, String> configurationParameters = new LinkedHashMap<>();
+
+	@Spec
+	private CommandSpec spec;
+
+	AvailableOptions() {
+	}
+
+	/**
+	 * Adds the specified key-value pair (or pairs) to the configuration parameters.
+	 * A {@code ParameterException} is thrown if the same key is specified multiple times
+	 * on the command line.
+	 *
+	 * @param map the key-value pairs to add
+	 * @throws picocli.CommandLine.ParameterException if the map already contains this key
+	 * @see <a href="https://github.com/junit-team/junit5/issues/1308">#1308</a>
+	 */
+	@Option(names = "--config", paramLabel = "KEY=VALUE", arity = "1", description = "Set a configuration parameter for test discovery and execution. This option can be repeated.")
+	public void setConfigurationParameters(Map<String, String> map) {
+		for (String key : map.keySet()) {
+			String newValue = map.get(key);
+			validateUnique(key, newValue);
+			configurationParameters.put(key, newValue);
+		}
+	}
+
+	private void validateUnique(String key, String newValue) {
+		String existing = configurationParameters.get(key);
+		if (existing != null && !existing.equals(newValue)) {
+			throw new ParameterException(spec.commandLine(),
+				String.format("Duplicate key '%s' for values '%s' and '%s'.", key, existing, newValue));
+		}
+	}
+
+	@Option(names = { "-config" }, arity = "1", hidden = true)
+	public void setConfigurationParameters2(Map<String, String> keyValuePairs) {
+		setConfigurationParameters(keyValuePairs);
 	}
 
-	OptionParser getParser() {
-		return parser;
+	CommandLine getParser() {
+		CommandLine result = new CommandLine(this);
+		result.setUsageHelpWidth(90);
+		result.setCaseInsensitiveEnumValuesAllowed(true);
+		result.setAtFileCommentChar(null); // for --select-method com.acme.Foo#m()
+		return result;
 	}
 
-	CommandLineOptions toCommandLineOptions(OptionSet detectedOptions) {
+	CommandLineOptions toCommandLineOptions(ParseResult parseResult) {
 
 		CommandLineOptions result = new CommandLineOptions();
 
 		// General Purpose
-		result.setDisplayHelp(detectedOptions.has(this.help));
-		result.setAnsiColorOutputDisabled(detectedOptions.has(this.disableAnsiColors));
-		result.setDetails(detectedOptions.valueOf(this.details));
-		result.setTheme(detectedOptions.valueOf(this.theme));
-		result.setAdditionalClasspathEntries(detectedOptions.valuesOf(this.additionalClasspathEntries));
-		result.setFailIfNoTests(detectedOptions.has(this.failIfNoTests));
+		result.setDisplayHelp(this.helpRequested || this.helpRequested2);
+		result.setAnsiColorOutputDisabled(this.disableAnsiColors || this.disableAnsiColors2);
+		result.setDetails(choose(this.details, this.details2, CommandLineOptions.DEFAULT_DETAILS));
+		result.setTheme(choose(this.theme, this.theme2, CommandLineOptions.DEFAULT_THEME));
+		result.setAdditionalClasspathEntries(merge(this.additionalClasspathEntries, this.additionalClasspathEntries2));
+		result.setFailIfNoTests(this.failIfNoTests);
 
 		// Reports
-		result.setReportsDir(detectedOptions.valueOf(this.reportsDir));
+		result.setReportsDir(choose(this.reportsDir, this.reportsDir2, null));
 
 		// Java Platform Module System
-		result.setScanModulepath(detectedOptions.has(this.scanModulepath));
-		result.setSelectedModules(detectedOptions.valuesOf(this.selectedModules));
+		result.setScanModulepath(this.scanModulepath || this.scanModulepath2);
+		result.setSelectedModules(merge(this.selectedModules, this.selectedModules2));
 
 		// Selectors
-		result.setScanClasspath(detectedOptions.has(this.selectedClasspathEntries));
-		result.setSelectedClasspathEntries(detectedOptions.valuesOf(this.selectedClasspathEntries));
-		result.setSelectedUris(detectedOptions.valuesOf(this.selectedUris));
-		result.setSelectedFiles(detectedOptions.valuesOf(this.selectedFiles));
-		result.setSelectedDirectories(detectedOptions.valuesOf(this.selectedDirectories));
-		result.setSelectedPackages(detectedOptions.valuesOf(this.selectedPackages));
-		result.setSelectedClasses(detectedOptions.valuesOf(this.selectedClasses));
-		result.setSelectedMethods(detectedOptions.valuesOf(this.selectedMethods));
-		result.setSelectedClasspathResources(detectedOptions.valuesOf(this.selectedClasspathResources));
+		result.setScanClasspath(parseResult.hasMatchedOption("scan-class-path")); // flag was specified
+		result.setSelectedClasspathEntries(merge(this.selectedClasspathEntries, this.selectedClasspathEntries2));
+		result.setSelectedUris(merge(this.selectedUris, this.selectedUris2));
+		result.setSelectedFiles(merge(this.selectedFiles, this.selectedFiles2));
+		result.setSelectedDirectories(merge(this.selectedDirectories, this.selectedDirectories2));
+		result.setSelectedPackages(merge(this.selectedPackages, this.selectedPackages2));
+		result.setSelectedClasses(merge(this.selectedClasses, this.selectedClasses2));
+		result.setSelectedMethods(merge(this.selectedMethods, this.selectedMethods2));
+		result.setSelectedClasspathResources(merge(this.selectedClasspathResources, this.selectedClasspathResources2));
 
 		// Filters
-		result.setIncludedClassNamePatterns(detectedOptions.valuesOf(this.includeClassNamePattern));
-		result.setExcludedClassNamePatterns(detectedOptions.valuesOf(this.excludeClassNamePattern));
-		result.setIncludedPackages(detectedOptions.valuesOf(this.includePackage));
-		result.setExcludedPackages(detectedOptions.valuesOf(this.excludePackage));
-		result.setIncludedTagExpressions(detectedOptions.valuesOf(this.includeTag));
-		result.setExcludedTagExpressions(detectedOptions.valuesOf(this.excludeTag));
-		result.setIncludedEngines(detectedOptions.valuesOf(this.includeEngine));
-		result.setExcludedEngines(detectedOptions.valuesOf(this.excludeEngine));
+		result.setIncludedClassNamePatterns(merge(this.includeClassNamePatterns, this.includeClassNamePatterns2));
+		result.setExcludedClassNamePatterns(merge(this.excludeClassNamePatterns, this.excludeClassNamePatterns2));
+		result.setIncludedPackages(merge(this.includePackages, this.includePackages2));
+		result.setExcludedPackages(merge(this.excludePackages, this.excludePackages2));
+		result.setIncludedTagExpressions(merge(this.includedTags, this.includedTags2));
+		result.setExcludedTagExpressions(merge(this.excludedTags, this.excludedTags2));
+		result.setIncludedEngines(merge(this.includedEngines, this.includedEngines2));
+		result.setExcludedEngines(merge(this.excludedEngines, this.excludedEngines2));
 
 		// Configuration Parameters
-		result.setConfigurationParameters(toMap(detectedOptions.valuesOf(this.configurationParameters)));
+		result.setConfigurationParameters(this.configurationParameters);
 
 		return result;
 	}
 
-	/**
-	 * Convert a list of key-value pairs to map.
-	 * @see <a href="https://github.com/junit-team/junit5/issues/1308">#1308</a>
-	 */
-	private Map<String, String> toMap(List<KeyValuePair> pairs) {
-		Map<String, String> map = new HashMap<>();
-		for (KeyValuePair pair : pairs) {
-			String key = pair.key;
-			if (map.containsKey(key)) {
-				throw new IllegalArgumentException("Duplicate key '" + key + "' in: " + pairs);
-			}
-			map.put(key, pair.value);
-		}
-		return map;
+	private static <T> List<T> merge(List<T> list1, List<T> list2) {
+		List<T> result = new ArrayList<>(list1);
+		result.addAll(list2);
+		return result;
 	}
 
+	private static <T> T choose(T left, T right, T defaultValue) {
+		return left == right ? left : (left == defaultValue ? right : left);
+	}
 }
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/options/DetailsConverter.java b/junit-platform-console/src/main/java/org/junit/platform/console/options/DetailsConverter.java
deleted file mode 100644
index c54e5a9b9..000000000
--- a/junit-platform-console/src/main/java/org/junit/platform/console/options/DetailsConverter.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.console.options;
-
-import joptsimple.util.EnumConverter;
-
-/**
- * @since 1.0
- */
-class DetailsConverter extends EnumConverter<Details> {
-
-	DetailsConverter() {
-		super(Details.class);
-	}
-
-}
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/options/KeyValuePairConverter.java b/junit-platform-console/src/main/java/org/junit/platform/console/options/KeyValuePairConverter.java
deleted file mode 100644
index 5fd8a6d5c..000000000
--- a/junit-platform-console/src/main/java/org/junit/platform/console/options/KeyValuePairConverter.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.console.options;
-
-import joptsimple.ValueConverter;
-import joptsimple.util.KeyValuePair;
-
-class KeyValuePairConverter implements ValueConverter<KeyValuePair> {
-	@Override
-	public KeyValuePair convert(String value) {
-		return KeyValuePair.valueOf(value);
-	}
-
-	@Override
-	public Class<? extends KeyValuePair> valueType() {
-		return KeyValuePair.class;
-	}
-
-	@Override
-	public String valuePattern() {
-		return "key=value";
-	}
-}
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/options/JOptSimpleCommandLineOptionsParser.java b/junit-platform-console/src/main/java/org/junit/platform/console/options/PicocliCommandLineOptionsParser.java
similarity index 56%
rename from junit-platform-console/src/main/java/org/junit/platform/console/options/JOptSimpleCommandLineOptionsParser.java
rename to junit-platform-console/src/main/java/org/junit/platform/console/options/PicocliCommandLineOptionsParser.java
index 5bb739685..f19137435 100644
--- a/junit-platform-console/src/main/java/org/junit/platform/console/options/JOptSimpleCommandLineOptionsParser.java
+++ b/junit-platform-console/src/main/java/org/junit/platform/console/options/PicocliCommandLineOptionsParser.java
@@ -14,42 +14,36 @@ import static org.apiguardian.api.API.Status.INTERNAL;
 
 import java.io.IOException;
 import java.io.Writer;
-import java.util.LinkedHashSet;
-import java.util.Map;
-
-import joptsimple.BuiltinHelpFormatter;
-import joptsimple.OptionDescriptor;
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
 
 import org.apiguardian.api.API;
 import org.junit.platform.commons.JUnitException;
 
+import picocli.CommandLine;
+import picocli.CommandLine.ParseResult;
+
 /**
  * @since 1.0
  */
 @API(status = INTERNAL, since = "1.0")
-public class JOptSimpleCommandLineOptionsParser implements CommandLineOptionsParser {
+public class PicocliCommandLineOptionsParser implements CommandLineOptionsParser {
 
 	@Override
 	public CommandLineOptions parse(String... arguments) {
 		AvailableOptions availableOptions = getAvailableOptions();
-		OptionParser parser = availableOptions.getParser();
+		CommandLine parser = availableOptions.getParser();
 		try {
-			OptionSet detectedOptions = parser.parse(arguments);
+			ParseResult detectedOptions = parser.parseArgs(arguments);
 			return availableOptions.toCommandLineOptions(detectedOptions);
 		}
 		catch (Exception e) {
-			throw new JUnitException("Error parsing command-line arguments", e);
+			throw new JUnitException("Error parsing command-line arguments: " + e.getMessage(), e);
 		}
 	}
 
 	@Override
 	public void printHelp(Writer writer) {
-		OptionParser optionParser = getAvailableOptions().getParser();
-		optionParser.formatHelpWith(new OrderPreservingHelpFormatter());
 		try {
-			optionParser.printHelpOn(writer);
+			writer.write(getAvailableOptions().getParser().getUsageMessage());
 		}
 		catch (IOException e) {
 			throw new JUnitException("Error printing help", e);
@@ -59,17 +53,4 @@ public class JOptSimpleCommandLineOptionsParser implements CommandLineOptionsPar
 	private AvailableOptions getAvailableOptions() {
 		return new AvailableOptions();
 	}
-
-	private static final class OrderPreservingHelpFormatter extends BuiltinHelpFormatter {
-
-		private OrderPreservingHelpFormatter() {
-			super(90, 4);
-		}
-
-		@Override
-		public String format(Map<String, ? extends OptionDescriptor> options) {
-			addRows(new LinkedHashSet<>(options.values()));
-			return formattedHelpOutput();
-		}
-	}
 }
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/options/ThemeConverter.java b/junit-platform-console/src/main/java/org/junit/platform/console/options/ThemeConverter.java
deleted file mode 100644
index 5af860e03..000000000
--- a/junit-platform-console/src/main/java/org/junit/platform/console/options/ThemeConverter.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.console.options;
-
-import joptsimple.util.EnumConverter;
-
-/**
- * @since 1.0
- */
-class ThemeConverter extends EnumConverter<Theme> {
-
-	ThemeConverter() {
-		super(Theme.class);
-	}
-
-}
diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/options/UriConverter.java b/junit-platform-console/src/main/java/org/junit/platform/console/options/UriConverter.java
deleted file mode 100644
index 6dbba7644..000000000
--- a/junit-platform-console/src/main/java/org/junit/platform/console/options/UriConverter.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.console.options;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.text.MessageFormat;
-
-import joptsimple.ValueConversionException;
-import joptsimple.ValueConverter;
-
-/**
- * @since 1.0
- */
-class UriConverter implements ValueConverter<URI> {
-
-	@Override
-	public URI convert(String value) {
-		try {
-			return new URI(value);
-		}
-		catch (URISyntaxException e) {
-			String message = MessageFormat.format("Value [{0}] is not a valid URI", value);
-			throw new ValueConversionException(message, e);
-		}
-	}
-
-	@Override
-	public Class<? extends URI> valueType() {
-		return URI.class;
-	}
-
-	@Override
-	public String valuePattern() {
-		return null;
-	}
-
-}
diff --git a/platform-tests/src/test/java/org/junit/platform/console/ConsoleDetailsTests.java b/platform-tests/src/test/java/org/junit/platform/console/ConsoleDetailsTests.java
index 7d6234953..37f1ca838 100644
--- a/platform-tests/src/test/java/org/junit/platform/console/ConsoleDetailsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/console/ConsoleDetailsTests.java
@@ -92,7 +92,7 @@ class ConsoleDetailsTests {
 							"--include-engine", "junit-jupiter", //
 							"--details", details.name(), //
 							"--details-theme", theme.name(), //
-							"--disable-ansi-colors", "true", //
+							"--disable-ansi-colors", //
 							"--include-classname", containerClass.getCanonicalName(), //
 							"--select-method", getFullyQualifiedMethodName(containerClass, methodName, types) //
 					};
diff --git a/platform-tests/src/test/java/org/junit/platform/console/ConsoleLauncherWrapper.java b/platform-tests/src/test/java/org/junit/platform/console/ConsoleLauncherWrapper.java
index 10e22f8a2..8cafe73c6 100644
--- a/platform-tests/src/test/java/org/junit/platform/console/ConsoleLauncherWrapper.java
+++ b/platform-tests/src/test/java/org/junit/platform/console/ConsoleLauncherWrapper.java
@@ -24,7 +24,7 @@ import java.nio.charset.StandardCharsets;
 import java.util.Optional;
 
 import org.junit.platform.console.options.CommandLineOptionsParser;
-import org.junit.platform.console.options.JOptSimpleCommandLineOptionsParser;
+import org.junit.platform.console.options.PicocliCommandLineOptionsParser;
 
 /**
  * @since 1.0
@@ -41,7 +41,7 @@ class ConsoleLauncherWrapper {
 	}
 
 	private ConsoleLauncherWrapper(Charset charset) {
-		this(charset, new JOptSimpleCommandLineOptionsParser());
+		this(charset, new PicocliCommandLineOptionsParser());
 	}
 
 	private ConsoleLauncherWrapper(Charset charset, CommandLineOptionsParser parser) {
diff --git a/platform-tests/src/test/java/org/junit/platform/console/options/JOptSimpleCommandLineOptionsParserTests.java b/platform-tests/src/test/java/org/junit/platform/console/options/JOptSimpleCommandLineOptionsParserTests.java
deleted file mode 100644
index dc3eea260..000000000
--- a/platform-tests/src/test/java/org/junit/platform/console/options/JOptSimpleCommandLineOptionsParserTests.java
+++ /dev/null
@@ -1,562 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.console.options;
-
-import static java.util.Arrays.asList;
-import static java.util.Arrays.stream;
-import static java.util.Collections.emptyList;
-import static java.util.Collections.emptyMap;
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.entry;
-import static org.junit.jupiter.api.Assertions.assertAll;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.platform.engine.discovery.ClassNameFilter.STANDARD_INCLUDE_PATTERN;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.net.URI;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.util.Optional;
-import java.util.function.Predicate;
-
-import org.junit.jupiter.api.Test;
-import org.junit.platform.commons.JUnitException;
-
-/**
- * @since 1.0
- */
-class JOptSimpleCommandLineOptionsParserTests {
-
-	@Test
-	void parseNoArguments() {
-		String[] noArguments = {};
-		CommandLineOptions options = createParser().parse(noArguments);
-
-		// @formatter:off
-		assertAll(
-			() -> assertFalse(options.isAnsiColorOutputDisabled()),
-			() -> assertFalse(options.isDisplayHelp()),
-			() -> assertEquals(CommandLineOptions.DEFAULT_DETAILS, options.getDetails()),
-			() -> assertFalse(options.isScanClasspath()),
-			() -> assertEquals(singletonList(STANDARD_INCLUDE_PATTERN), options.getIncludedClassNamePatterns()),
-			() -> assertEquals(emptyList(), options.getExcludedClassNamePatterns()),
-			() -> assertEquals(emptyList(), options.getIncludedPackages()),
-			() -> assertEquals(emptyList(), options.getExcludedPackages()),
-			() -> assertEquals(emptyList(), options.getIncludedTagExpressions()),
-			() -> assertEquals(emptyList(), options.getExcludedTagExpressions()),
-			() -> assertEquals(emptyList(), options.getAdditionalClasspathEntries()),
-			() -> assertEquals(Optional.empty(), options.getReportsDir()),
-			() -> assertEquals(emptyList(), options.getSelectedUris()),
-			() -> assertEquals(emptyList(), options.getSelectedFiles()),
-			() -> assertEquals(emptyList(), options.getSelectedDirectories()),
-			() -> assertEquals(emptyList(), options.getSelectedModules()),
-			() -> assertEquals(emptyList(), options.getSelectedPackages()),
-			() -> assertEquals(emptyList(), options.getSelectedMethods()),
-			() -> assertEquals(emptyList(), options.getSelectedClasspathEntries()),
-			() -> assertEquals(emptyMap(), options.getConfigurationParameters())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseSwitches() {
-		// @formatter:off
-		assertAll(
-			() -> assertParses("disable ansi", CommandLineOptions::isAnsiColorOutputDisabled, "--disable-ansi-colors"),
-			() -> assertParses("help", CommandLineOptions::isDisplayHelp, "-h", "--help"),
-			() -> assertParses("scan class path", CommandLineOptions::isScanClasspath, "--scan-class-path")
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseValidDetails() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(Details.VERBOSE, parseArgLine("--details verbose").getDetails()),
-			() -> assertEquals(Details.TREE, parseArgLine("--details tree").getDetails()),
-			() -> assertEquals(Details.FLAT, parseArgLine("--details flat").getDetails()),
-			() -> assertEquals(Details.NONE, parseArgLine("--details NONE").getDetails()),
-			() -> assertEquals(Details.NONE, parseArgLine("--details none").getDetails()),
-			() -> assertEquals(Details.NONE, parseArgLine("--details None").getDetails())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidDetails() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("--details");
-	}
-
-	@Test
-	void parseValidDetailsTheme() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(Theme.ASCII, parseArgLine("--details-theme ascii").getTheme()),
-			() -> assertEquals(Theme.ASCII, parseArgLine("--details-theme ASCII").getTheme()),
-			() -> assertEquals(Theme.UNICODE, parseArgLine("--details-theme unicode").getTheme()),
-			() -> assertEquals(Theme.UNICODE, parseArgLine("--details-theme UNICODE").getTheme()),
-			() -> assertEquals(Theme.UNICODE, parseArgLine("--details-theme uniCode").getTheme())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidDetailsTheme() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("--details-theme");
-	}
-
-	@Test
-	void parseValidIncludeClassNamePatterns() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(singletonList(".*Test"), parseArgLine("-n .*Test").getIncludedClassNamePatterns()),
-			() -> assertEquals(asList(".*Test", ".*Tests"), parseArgLine("--include-classname .*Test --include-classname .*Tests").getIncludedClassNamePatterns()),
-			() -> assertEquals(singletonList(".*Test"), parseArgLine("--include-classname=.*Test").getIncludedClassNamePatterns())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseValidExcludeClassNamePatterns() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(singletonList(".*Test"), parseArgLine("-N .*Test").getExcludedClassNamePatterns()),
-			() -> assertEquals(asList(".*Test", ".*Tests"), parseArgLine("--exclude-classname .*Test --exclude-classname .*Tests").getExcludedClassNamePatterns()),
-			() -> assertEquals(singletonList(".*Test"), parseArgLine("--exclude-classname=.*Test").getExcludedClassNamePatterns())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void usesDefaultClassNamePatternWithoutExplicitArgument() {
-		assertEquals(singletonList(STANDARD_INCLUDE_PATTERN), parseArgLine("").getIncludedClassNamePatterns());
-	}
-
-	@Test
-	void parseInvalidIncludeClassNamePatterns() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("-n", "--include-classname");
-	}
-
-	@Test
-	void parseInvalidExcludeClassNamePatterns() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("-N", "--exclude-classname");
-	}
-
-	@Test
-	void parseValidIncludedPackages() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(asList("org.junit.included"),
-						parseArgLine("--include-package org.junit.included").getIncludedPackages()),
-				() -> assertEquals(asList("org.junit.included"),
-						parseArgLine("--include-package=org.junit.included").getIncludedPackages()),
-				() -> assertEquals(asList("org.junit.included1", "org.junit.included2"),
-						parseArgLine("--include-package org.junit.included1 --include-package org.junit.included2").getIncludedPackages())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseValidExcludedPackages() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(asList("org.junit.excluded"),
-						parseArgLine("--exclude-package org.junit.excluded").getExcludedPackages()),
-				() -> assertEquals(asList("org.junit.excluded"),
-						parseArgLine("--exclude-package=org.junit.excluded").getExcludedPackages()),
-				() -> assertEquals(asList("org.junit.excluded1", "org.junit.excluded2"),
-						parseArgLine("--exclude-package org.junit.excluded1 --exclude-package org.junit.excluded2").getExcludedPackages())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseValidIncludedTags() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(asList("fast"), parseArgLine("-t fast").getIncludedTagExpressions()),
-			() -> assertEquals(asList("fast"), parseArgLine("--include-tag fast").getIncludedTagExpressions()),
-			() -> assertEquals(asList("fast"), parseArgLine("--include-tag=fast").getIncludedTagExpressions()),
-			() -> assertEquals(asList("fast", "slow"), parseArgLine("-t fast -t slow").getIncludedTagExpressions())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidIncludedTags() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-t", "--include-tag");
-	}
-
-	@Test
-	void parseValidExcludedTags() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(asList("fast"), parseArgLine("-T fast").getExcludedTagExpressions()),
-			() -> assertEquals(asList("fast"), parseArgLine("--exclude-tag fast").getExcludedTagExpressions()),
-			() -> assertEquals(asList("fast"), parseArgLine("--exclude-tag=fast").getExcludedTagExpressions()),
-			() -> assertEquals(asList("fast", "slow"), parseArgLine("-T fast -T slow").getExcludedTagExpressions())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidExcludedTags() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-T", "--exclude-tag");
-	}
-
-	@Test
-	void parseValidIncludedEngines() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(asList("junit-jupiter"), parseArgLine("-e junit-jupiter").getIncludedEngines()),
-			() -> assertEquals(asList("junit-vintage"), parseArgLine("--include-engine junit-vintage").getIncludedEngines()),
-			() -> assertEquals(emptyList(), parseArgLine("").getIncludedEngines())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidIncludedEngines() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("-e", "--include-engine");
-	}
-
-	@Test
-	void parseValidExcludedEngines() {
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(asList("junit-jupiter"), parseArgLine("-E junit-jupiter").getExcludedEngines()),
-			() -> assertEquals(asList("junit-vintage"), parseArgLine("--exclude-engine junit-vintage").getExcludedEngines()),
-			() -> assertEquals(emptyList(), parseArgLine("").getExcludedEngines())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidExcludedEngines() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("-E", "--exclude-engine");
-	}
-
-	@Test
-	void parseValidAdditionalClasspathEntries() {
-		Path dir = Paths.get(".");
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(singletonList(dir), parseArgLine("-cp .").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--cp .").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("-classpath .").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("-classpath=.").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--classpath .").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--classpath=.").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--class-path .").getAdditionalClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--class-path=.").getAdditionalClasspathEntries()),
-			() -> assertEquals(asList(dir, Paths.get("src", "test", "java")), parseArgLine("-cp . -cp src/test/java").getAdditionalClasspathEntries()),
-			() -> assertEquals(asList(dir, Paths.get("src", "test", "java")), parseArgLine("-cp ." + File.pathSeparator + "src/test/java").getAdditionalClasspathEntries())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidAdditionalClasspathEntries() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-cp", "--classpath", "--class-path");
-	}
-
-	@Test
-	void parseValidXmlReportsDirs() {
-		Path dir = Paths.get("build", "test-results");
-		// @formatter:off
-		assertAll(
-			() -> assertEquals(Optional.of(dir), parseArgLine("--reports-dir build/test-results").getReportsDir()),
-			() -> assertEquals(Optional.of(dir), parseArgLine("--reports-dir=build/test-results").getReportsDir())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidXmlReportsDirs() throws Exception {
-		assertOptionWithMissingRequiredArgumentThrowsException("--reports-dir");
-	}
-
-	@Test
-	void parseValidUriSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList(new URI("file:///foo.txt")), parseArgLine("-u file:///foo.txt").getSelectedUris()),
-				() -> assertEquals(singletonList(new URI("file:///foo.txt")), parseArgLine("--u file:///foo.txt").getSelectedUris()),
-				() -> assertEquals(singletonList(new URI("file:///foo.txt")), parseArgLine("-select-uri file:///foo.txt").getSelectedUris()),
-				() -> assertEquals(singletonList(new URI("file:///foo.txt")), parseArgLine("-select-uri=file:///foo.txt").getSelectedUris()),
-				() -> assertEquals(singletonList(new URI("file:///foo.txt")), parseArgLine("--select-uri file:///foo.txt").getSelectedUris()),
-				() -> assertEquals(singletonList(new URI("file:///foo.txt")), parseArgLine("--select-uri=file:///foo.txt").getSelectedUris()),
-				() -> assertEquals(asList(new URI("file:///foo.txt"), new URI("http://localhost")), parseArgLine("-u file:///foo.txt -u http://localhost").getSelectedUris())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidUriSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-u", "--select-uri", "-u unknown-scheme:");
-	}
-
-	@Test
-	void parseValidFileSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("foo.txt"), parseArgLine("-f foo.txt").getSelectedFiles()),
-				() -> assertEquals(singletonList("foo.txt"), parseArgLine("--f foo.txt").getSelectedFiles()),
-				() -> assertEquals(singletonList("foo.txt"), parseArgLine("-select-file foo.txt").getSelectedFiles()),
-				() -> assertEquals(singletonList("foo.txt"), parseArgLine("-select-file=foo.txt").getSelectedFiles()),
-				() -> assertEquals(singletonList("foo.txt"), parseArgLine("--select-file foo.txt").getSelectedFiles()),
-				() -> assertEquals(singletonList("foo.txt"), parseArgLine("--select-file=foo.txt").getSelectedFiles()),
-				() -> assertEquals(asList("foo.txt", "bar.csv"), parseArgLine("-f foo.txt -f bar.csv").getSelectedFiles())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidFileSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-f", "--select-file");
-	}
-
-	@Test
-	void parseValidDirectorySelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("foo/bar"), parseArgLine("-d foo/bar").getSelectedDirectories()),
-				() -> assertEquals(singletonList("foo/bar"), parseArgLine("--d foo/bar").getSelectedDirectories()),
-				() -> assertEquals(singletonList("foo/bar"), parseArgLine("-select-directory foo/bar").getSelectedDirectories()),
-				() -> assertEquals(singletonList("foo/bar"), parseArgLine("-select-directory=foo/bar").getSelectedDirectories()),
-				() -> assertEquals(singletonList("foo/bar"), parseArgLine("--select-directory foo/bar").getSelectedDirectories()),
-				() -> assertEquals(singletonList("foo/bar"), parseArgLine("--select-directory=foo/bar").getSelectedDirectories()),
-				() -> assertEquals(asList("foo/bar", "bar/qux"), parseArgLine("-d foo/bar -d bar/qux").getSelectedDirectories())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidDirectorySelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-d", "--select-directory");
-	}
-
-	@Test
-	void parseValidModuleSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("-o com.acme.foo").getSelectedModules()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("--o com.acme.foo").getSelectedModules()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("-select-module com.acme.foo").getSelectedModules()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("-select-module=com.acme.foo").getSelectedModules()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("--select-module com.acme.foo").getSelectedModules()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("--select-module=com.acme.foo").getSelectedModules()),
-				() -> assertEquals(asList("com.acme.foo", "com.example.bar"), parseArgLine("-o com.acme.foo -o com.example.bar").getSelectedModules())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidModuleSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-o", "--select-module");
-	}
-
-	@Test
-	void parseValidPackageSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("-p com.acme.foo").getSelectedPackages()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("--p com.acme.foo").getSelectedPackages()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("-select-package com.acme.foo").getSelectedPackages()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("-select-package=com.acme.foo").getSelectedPackages()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("--select-package com.acme.foo").getSelectedPackages()),
-				() -> assertEquals(singletonList("com.acme.foo"), parseArgLine("--select-package=com.acme.foo").getSelectedPackages()),
-				() -> assertEquals(asList("com.acme.foo", "com.example.bar"), parseArgLine("-p com.acme.foo -p com.example.bar").getSelectedPackages())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidPackageSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-p", "--select-package");
-	}
-
-	@Test
-	void parseValidClassSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("com.acme.Foo"), parseArgLine("-c com.acme.Foo").getSelectedClasses()),
-				() -> assertEquals(singletonList("com.acme.Foo"), parseArgLine("--c com.acme.Foo").getSelectedClasses()),
-				() -> assertEquals(singletonList("com.acme.Foo"), parseArgLine("-select-class com.acme.Foo").getSelectedClasses()),
-				() -> assertEquals(singletonList("com.acme.Foo"), parseArgLine("-select-class=com.acme.Foo").getSelectedClasses()),
-				() -> assertEquals(singletonList("com.acme.Foo"), parseArgLine("--select-class com.acme.Foo").getSelectedClasses()),
-				() -> assertEquals(singletonList("com.acme.Foo"), parseArgLine("--select-class=com.acme.Foo").getSelectedClasses()),
-				() -> assertEquals(asList("com.acme.Foo", "com.example.Bar"), parseArgLine("-c com.acme.Foo -c com.example.Bar").getSelectedClasses())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidClassSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-c", "--select-class");
-	}
-
-	@Test
-	void parseValidMethodSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("com.acme.Foo#m()"), parseArgLine("-m com.acme.Foo#m()").getSelectedMethods()),
-				() -> assertEquals(singletonList("com.acme.Foo#m()"), parseArgLine("--m com.acme.Foo#m()").getSelectedMethods()),
-				() -> assertEquals(singletonList("com.acme.Foo#m()"), parseArgLine("-select-method com.acme.Foo#m()").getSelectedMethods()),
-				() -> assertEquals(singletonList("com.acme.Foo#m()"), parseArgLine("-select-method=com.acme.Foo#m()").getSelectedMethods()),
-				() -> assertEquals(singletonList("com.acme.Foo#m()"), parseArgLine("--select-method com.acme.Foo#m()").getSelectedMethods()),
-				() -> assertEquals(singletonList("com.acme.Foo#m()"), parseArgLine("--select-method=com.acme.Foo#m()").getSelectedMethods()),
-				() -> assertEquals(asList("com.acme.Foo#m()", "com.example.Bar#method(java.lang.Object)"),
-						parseArgLine("-m com.acme.Foo#m() -m com.example.Bar#method(java.lang.Object)").getSelectedMethods())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidMethodSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-m", "--select-method");
-	}
-
-	@Test
-	void parseValidClasspathResourceSelectors() {
-		// @formatter:off
-		assertAll(
-				() -> assertEquals(singletonList("/foo.csv"), parseArgLine("-r /foo.csv").getSelectedClasspathResources()),
-				() -> assertEquals(singletonList("/foo.csv"), parseArgLine("--r /foo.csv").getSelectedClasspathResources()),
-				() -> assertEquals(singletonList("/foo.csv"), parseArgLine("-select-resource /foo.csv").getSelectedClasspathResources()),
-				() -> assertEquals(singletonList("/foo.csv"), parseArgLine("-select-resource=/foo.csv").getSelectedClasspathResources()),
-				() -> assertEquals(singletonList("/foo.csv"), parseArgLine("--select-resource /foo.csv").getSelectedClasspathResources()),
-				() -> assertEquals(singletonList("/foo.csv"), parseArgLine("--select-resource=/foo.csv").getSelectedClasspathResources()),
-				() -> assertEquals(asList("/foo.csv", "bar.json"), parseArgLine("-r /foo.csv -r bar.json").getSelectedClasspathResources())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidClasspathResourceSelectors() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-r", "--select-resource");
-	}
-
-	@Test
-	void parseClasspathScanningEntries() {
-		Path dir = Paths.get(".");
-		// @formatter:off
-		assertAll(
-			() -> assertTrue(parseArgLine("--scan-class-path").isScanClasspath()),
-			() -> assertEquals(emptyList(), parseArgLine("--scan-class-path").getSelectedClasspathEntries()),
-			() -> assertTrue(parseArgLine("--scan-classpath").isScanClasspath()),
-			() -> assertEquals(emptyList(), parseArgLine("--scan-classpath").getSelectedClasspathEntries()),
-			() -> assertTrue(parseArgLine("--scan-class-path .").isScanClasspath()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--scan-class-path .").getSelectedClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("--scan-class-path=.").getSelectedClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("-scan-class-path .").getSelectedClasspathEntries()),
-			() -> assertEquals(singletonList(dir), parseArgLine("-scan-class-path=.").getSelectedClasspathEntries()),
-			() -> assertEquals(asList(dir, Paths.get("src/test/java")), parseArgLine("--scan-class-path . --scan-class-path src/test/java").getSelectedClasspathEntries()),
-			() -> assertEquals(asList(dir, Paths.get("src/test/java")), parseArgLine("--scan-class-path ." + File.pathSeparator + "src/test/java").getSelectedClasspathEntries())
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseValidConfigurationParameters() {
-		// @formatter:off
-		assertAll(
-				() -> assertThat(parseArgLine("-config foo=bar").getConfigurationParameters())
-						.containsOnly(entry("foo", "bar")),
-				() -> assertThat(parseArgLine("-config=foo=bar").getConfigurationParameters())
-						.containsOnly(entry("foo", "bar")),
-				() -> assertThat(parseArgLine("--config foo=bar").getConfigurationParameters())
-						.containsOnly(entry("foo", "bar")),
-				() -> assertThat(parseArgLine("--config=foo=bar").getConfigurationParameters())
-						.containsOnly(entry("foo", "bar")),
-				() -> assertThat(parseArgLine("--config foo=bar --config baz=qux").getConfigurationParameters())
-						.containsExactly(entry("foo", "bar"), entry("baz", "qux"))
-		);
-		// @formatter:on
-	}
-
-	@Test
-	void parseInvalidConfigurationParameters() {
-		assertOptionWithMissingRequiredArgumentThrowsException("-config", "--config");
-	}
-
-	@Test
-	void parseInvalidConfigurationParametersWithDuplicateKey() {
-		Exception e = assertThrows(JUnitException.class, () -> parseArgLine("--config foo=bar --config foo=baz"));
-
-		assertThat(e.getMessage()).isEqualTo("Error parsing command-line arguments");
-		assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class);
-		assertThat(e.getCause().getMessage()).isEqualTo("Duplicate key 'foo' in: [foo=bar, foo=baz]");
-	}
-
-	@Test
-	void printHelpOutputsHelpOption() {
-		StringWriter writer = new StringWriter();
-
-		createParser().printHelp(writer);
-
-		assertThat(writer.toString()).contains("--help");
-	}
-
-	@Test
-	void printHelpPreservesOriginalIOException() {
-		Writer writer = new Writer() {
-
-			@Override
-			public void write(char[] cbuf, int off, int len) throws IOException {
-				throw new IOException("Something went wrong");
-			}
-
-			@Override
-			public void flush() {
-			}
-
-			@Override
-			public void close() {
-			}
-		};
-
-		CommandLineOptionsParser parser = createParser();
-		RuntimeException exception = assertThrows(RuntimeException.class, () -> parser.printHelp(writer));
-
-		assertThat(exception).hasCauseInstanceOf(IOException.class);
-		assertThat(exception.getCause()).hasMessage("Something went wrong");
-	}
-
-	private void assertOptionWithMissingRequiredArgumentThrowsException(String... options) {
-		assertAll(stream(options).map(opt -> () -> assertThrows(JUnitException.class, () -> parseArgLine(opt))));
-	}
-
-	private void assertParses(String name, Predicate<CommandLineOptions> property, String... argLines) {
-		stream(argLines).forEach(argLine -> {
-			CommandLineOptions options = parseArgLine(argLine);
-			assertTrue(property.test(options), () -> name + " should be enabled by: " + argLine);
-		});
-	}
-
-	private CommandLineOptions parseArgLine(String argLine) {
-		String[] arguments = argLine.split("\\s+");
-		return createParser().parse(arguments);
-	}
-
-	private CommandLineOptionsParser createParser() {
-		return new JOptSimpleCommandLineOptionsParser();
-	}
-
-}
diff --git a/platform-tests/src/test/java/org/junit/platform/console/options/PicocliCommandLineOptionsParserTests.java b/platform-tests/src/test/java/org/junit/platform/console/options/PicocliCommandLineOptionsParserTests.java
new file mode 100644
index 000000000..31fa140ba
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/console/options/PicocliCommandLineOptionsParserTests.java
@@ -0,0 +1,620 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.console.options;
+
+import static java.util.Arrays.asList;
+import static java.util.Arrays.stream;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.entry;
+import static org.junit.jupiter.api.Assertions.assertAll;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.platform.engine.discovery.ClassNameFilter.STANDARD_INCLUDE_PATTERN;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.net.URI;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+import org.junit.platform.commons.JUnitException;
+
+/**
+ * @since 1.0
+ */
+class PicocliCommandLineOptionsParserTests {
+
+	@Test
+	void parseNoArguments() {
+		String[] noArguments = {};
+		CommandLineOptions options = createParser().parse(noArguments);
+
+		// @formatter:off
+		assertAll(
+			() -> assertFalse(options.isAnsiColorOutputDisabled()),
+			() -> assertFalse(options.isDisplayHelp()),
+			() -> assertEquals(CommandLineOptions.DEFAULT_DETAILS, options.getDetails()),
+			() -> assertFalse(options.isScanClasspath()),
+			() -> assertEquals(singletonList(STANDARD_INCLUDE_PATTERN), options.getIncludedClassNamePatterns()),
+			() -> assertEquals(emptyList(), options.getExcludedClassNamePatterns()),
+			() -> assertEquals(emptyList(), options.getIncludedPackages()),
+			() -> assertEquals(emptyList(), options.getExcludedPackages()),
+			() -> assertEquals(emptyList(), options.getIncludedTagExpressions()),
+			() -> assertEquals(emptyList(), options.getExcludedTagExpressions()),
+			() -> assertEquals(emptyList(), options.getAdditionalClasspathEntries()),
+			() -> assertEquals(Optional.empty(), options.getReportsDir()),
+			() -> assertEquals(emptyList(), options.getSelectedUris()),
+			() -> assertEquals(emptyList(), options.getSelectedFiles()),
+			() -> assertEquals(emptyList(), options.getSelectedDirectories()),
+			() -> assertEquals(emptyList(), options.getSelectedModules()),
+			() -> assertEquals(emptyList(), options.getSelectedPackages()),
+			() -> assertEquals(emptyList(), options.getSelectedMethods()),
+			() -> assertEquals(emptyList(), options.getSelectedClasspathEntries()),
+			() -> assertEquals(emptyMap(), options.getConfigurationParameters())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseSwitches() {
+		// @formatter:off
+		assertAll(
+			() -> assertParses("disable ansi", CommandLineOptions::isAnsiColorOutputDisabled, "--disable-ansi-colors"),
+			() -> assertParses("help", CommandLineOptions::isDisplayHelp, "-h", "--help"),
+			() -> assertParses("scan class path", CommandLineOptions::isScanClasspath, "--scan-class-path")
+		);
+		// @formatter:on
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidDetails(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(Details.VERBOSE, type.parseArgLine("--details verbose").getDetails()),
+			() -> assertEquals(Details.TREE, type.parseArgLine("--details tree").getDetails()),
+			() -> assertEquals(Details.FLAT, type.parseArgLine("--details flat").getDetails()),
+			() -> assertEquals(Details.NONE, type.parseArgLine("--details NONE").getDetails()),
+			() -> assertEquals(Details.NONE, type.parseArgLine("--details none").getDetails()),
+			() -> assertEquals(Details.NONE, type.parseArgLine("--details None").getDetails())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidDetails() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("--details");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidDetailsTheme(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(Theme.ASCII, type.parseArgLine("--details-theme ascii").getTheme()),
+			() -> assertEquals(Theme.ASCII, type.parseArgLine("--details-theme ASCII").getTheme()),
+			() -> assertEquals(Theme.UNICODE, type.parseArgLine("--details-theme unicode").getTheme()),
+			() -> assertEquals(Theme.UNICODE, type.parseArgLine("--details-theme UNICODE").getTheme()),
+			() -> assertEquals(Theme.UNICODE, type.parseArgLine("--details-theme uniCode").getTheme())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidDetailsTheme() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("--details-theme");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidIncludeClassNamePatterns(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(singletonList(".*Test"), type.parseArgLine("-n .*Test").getIncludedClassNamePatterns()),
+			() -> assertEquals(asList(".*Test", ".*Tests"), type.parseArgLine("--include-classname .*Test --include-classname .*Tests").getIncludedClassNamePatterns()),
+			() -> assertEquals(singletonList(".*Test"), type.parseArgLine("--include-classname=.*Test").getIncludedClassNamePatterns())
+		);
+		// @formatter:on
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidExcludeClassNamePatterns(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(singletonList(".*Test"), type.parseArgLine("-N .*Test").getExcludedClassNamePatterns()),
+			() -> assertEquals(asList(".*Test", ".*Tests"), type.parseArgLine("--exclude-classname .*Test --exclude-classname .*Tests").getExcludedClassNamePatterns()),
+			() -> assertEquals(singletonList(".*Test"), type.parseArgLine("--exclude-classname=.*Test").getExcludedClassNamePatterns())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void usesDefaultClassNamePatternWithoutExplicitArgument() throws Exception {
+		assertEquals(singletonList(STANDARD_INCLUDE_PATTERN),
+			ArgsType.args.parseArgLine("").getIncludedClassNamePatterns());
+	}
+
+	@Test
+	void parseInvalidIncludeClassNamePatterns() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("-n", "--include-classname");
+	}
+
+	@Test
+	void parseInvalidExcludeClassNamePatterns() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("-N", "--exclude-classname");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidIncludedPackages(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(asList("org.junit.included"),
+						type.parseArgLine("--include-package org.junit.included").getIncludedPackages()),
+				() -> assertEquals(asList("org.junit.included"),
+						type.parseArgLine("--include-package=org.junit.included").getIncludedPackages()),
+				() -> assertEquals(asList("org.junit.included1", "org.junit.included2"),
+						type.parseArgLine("--include-package org.junit.included1 --include-package org.junit.included2").getIncludedPackages())
+		);
+		// @formatter:on
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidExcludedPackages(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(asList("org.junit.excluded"),
+						type.parseArgLine("--exclude-package org.junit.excluded").getExcludedPackages()),
+				() -> assertEquals(asList("org.junit.excluded"),
+						type.parseArgLine("--exclude-package=org.junit.excluded").getExcludedPackages()),
+				() -> assertEquals(asList("org.junit.excluded1", "org.junit.excluded2"),
+						type.parseArgLine("--exclude-package org.junit.excluded1 --exclude-package org.junit.excluded2").getExcludedPackages())
+		);
+		// @formatter:on
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidIncludedTags(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(asList("fast"), type.parseArgLine("-t fast").getIncludedTagExpressions()),
+			() -> assertEquals(asList("fast"), type.parseArgLine("--include-tag fast").getIncludedTagExpressions()),
+			() -> assertEquals(asList("fast"), type.parseArgLine("--include-tag=fast").getIncludedTagExpressions()),
+			() -> assertEquals(asList("fast", "slow"), type.parseArgLine("-t fast -t slow").getIncludedTagExpressions())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidIncludedTags() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-t", "--include-tag");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidExcludedTags(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(asList("fast"), type.parseArgLine("-T fast").getExcludedTagExpressions()),
+			() -> assertEquals(asList("fast"), type.parseArgLine("--exclude-tag fast").getExcludedTagExpressions()),
+			() -> assertEquals(asList("fast"), type.parseArgLine("--exclude-tag=fast").getExcludedTagExpressions()),
+			() -> assertEquals(asList("fast", "slow"), type.parseArgLine("-T fast -T slow").getExcludedTagExpressions())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidExcludedTags() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-T", "--exclude-tag");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidIncludedEngines(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(asList("junit-jupiter"), type.parseArgLine("-e junit-jupiter").getIncludedEngines()),
+			() -> assertEquals(asList("junit-vintage"), type.parseArgLine("--include-engine junit-vintage").getIncludedEngines()),
+			() -> assertEquals(emptyList(), type.parseArgLine("").getIncludedEngines())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidIncludedEngines() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("-e", "--include-engine");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidExcludedEngines(ArgsType type) {
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(asList("junit-jupiter"), type.parseArgLine("-E junit-jupiter").getExcludedEngines()),
+			() -> assertEquals(asList("junit-vintage"), type.parseArgLine("--exclude-engine junit-vintage").getExcludedEngines()),
+			() -> assertEquals(emptyList(), type.parseArgLine("").getExcludedEngines())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidExcludedEngines() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("-E", "--exclude-engine");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidAdditionalClasspathEntries(ArgsType type) {
+		Path dir = Paths.get(".");
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(singletonList(dir), type.parseArgLine("-cp .").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--cp .").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("-classpath .").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("-classpath=.").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--classpath .").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--classpath=.").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--class-path .").getAdditionalClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--class-path=.").getAdditionalClasspathEntries()),
+			() -> assertEquals(asList(dir, Paths.get("src", "test", "java")), type.parseArgLine("-cp . -cp src/test/java").getAdditionalClasspathEntries()),
+			() -> assertEquals(asList(dir, Paths.get("src", "test", "java")), type.parseArgLine("-cp ." + File.pathSeparator + "src/test/java").getAdditionalClasspathEntries())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidAdditionalClasspathEntries() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-cp", "--classpath", "--class-path");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidXmlReportsDirs(ArgsType type) {
+		Path dir = Paths.get("build", "test-results");
+		// @formatter:off
+		assertAll(
+			() -> assertEquals(Optional.of(dir), type.parseArgLine("--reports-dir build/test-results").getReportsDir()),
+			() -> assertEquals(Optional.of(dir), type.parseArgLine("--reports-dir=build/test-results").getReportsDir())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidXmlReportsDirs() throws Exception {
+		assertOptionWithMissingRequiredArgumentThrowsException("--reports-dir");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidUriSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList(new URI("file:///foo.txt")), type.parseArgLine("-u file:///foo.txt").getSelectedUris()),
+				() -> assertEquals(singletonList(new URI("file:///foo.txt")), type.parseArgLine("--u file:///foo.txt").getSelectedUris()),
+				() -> assertEquals(singletonList(new URI("file:///foo.txt")), type.parseArgLine("-select-uri file:///foo.txt").getSelectedUris()),
+				() -> assertEquals(singletonList(new URI("file:///foo.txt")), type.parseArgLine("-select-uri=file:///foo.txt").getSelectedUris()),
+				() -> assertEquals(singletonList(new URI("file:///foo.txt")), type.parseArgLine("--select-uri file:///foo.txt").getSelectedUris()),
+				() -> assertEquals(singletonList(new URI("file:///foo.txt")), type.parseArgLine("--select-uri=file:///foo.txt").getSelectedUris()),
+				() -> assertEquals(asList(new URI("file:///foo.txt"), new URI("http://localhost")), type.parseArgLine("-u file:///foo.txt -u http://localhost").getSelectedUris())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidUriSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-u", "--select-uri", "-u unknown-scheme:");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidFileSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("foo.txt"), type.parseArgLine("-f foo.txt").getSelectedFiles()),
+				() -> assertEquals(singletonList("foo.txt"), type.parseArgLine("--f foo.txt").getSelectedFiles()),
+				() -> assertEquals(singletonList("foo.txt"), type.parseArgLine("-select-file foo.txt").getSelectedFiles()),
+				() -> assertEquals(singletonList("foo.txt"), type.parseArgLine("-select-file=foo.txt").getSelectedFiles()),
+				() -> assertEquals(singletonList("foo.txt"), type.parseArgLine("--select-file foo.txt").getSelectedFiles()),
+				() -> assertEquals(singletonList("foo.txt"), type.parseArgLine("--select-file=foo.txt").getSelectedFiles()),
+				() -> assertEquals(asList("foo.txt", "bar.csv"), type.parseArgLine("-f foo.txt -f bar.csv").getSelectedFiles())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidFileSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-f", "--select-file");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidDirectorySelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("foo/bar"), type.parseArgLine("-d foo/bar").getSelectedDirectories()),
+				() -> assertEquals(singletonList("foo/bar"), type.parseArgLine("--d foo/bar").getSelectedDirectories()),
+				() -> assertEquals(singletonList("foo/bar"), type.parseArgLine("-select-directory foo/bar").getSelectedDirectories()),
+				() -> assertEquals(singletonList("foo/bar"), type.parseArgLine("-select-directory=foo/bar").getSelectedDirectories()),
+				() -> assertEquals(singletonList("foo/bar"), type.parseArgLine("--select-directory foo/bar").getSelectedDirectories()),
+				() -> assertEquals(singletonList("foo/bar"), type.parseArgLine("--select-directory=foo/bar").getSelectedDirectories()),
+				() -> assertEquals(asList("foo/bar", "bar/qux"), type.parseArgLine("-d foo/bar -d bar/qux").getSelectedDirectories())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidDirectorySelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-d", "--select-directory");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidModuleSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("-o com.acme.foo").getSelectedModules()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("--o com.acme.foo").getSelectedModules()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("-select-module com.acme.foo").getSelectedModules()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("-select-module=com.acme.foo").getSelectedModules()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("--select-module com.acme.foo").getSelectedModules()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("--select-module=com.acme.foo").getSelectedModules()),
+				() -> assertEquals(asList("com.acme.foo", "com.example.bar"), type.parseArgLine("-o com.acme.foo -o com.example.bar").getSelectedModules())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidModuleSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-o", "--select-module");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidPackageSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("-p com.acme.foo").getSelectedPackages()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("--p com.acme.foo").getSelectedPackages()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("-select-package com.acme.foo").getSelectedPackages()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("-select-package=com.acme.foo").getSelectedPackages()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("--select-package com.acme.foo").getSelectedPackages()),
+				() -> assertEquals(singletonList("com.acme.foo"), type.parseArgLine("--select-package=com.acme.foo").getSelectedPackages()),
+				() -> assertEquals(asList("com.acme.foo", "com.example.bar"), type.parseArgLine("-p com.acme.foo -p com.example.bar").getSelectedPackages())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidPackageSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-p", "--select-package");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidClassSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("com.acme.Foo"), type.parseArgLine("-c com.acme.Foo").getSelectedClasses()),
+				() -> assertEquals(singletonList("com.acme.Foo"), type.parseArgLine("--c com.acme.Foo").getSelectedClasses()),
+				() -> assertEquals(singletonList("com.acme.Foo"), type.parseArgLine("-select-class com.acme.Foo").getSelectedClasses()),
+				() -> assertEquals(singletonList("com.acme.Foo"), type.parseArgLine("-select-class=com.acme.Foo").getSelectedClasses()),
+				() -> assertEquals(singletonList("com.acme.Foo"), type.parseArgLine("--select-class com.acme.Foo").getSelectedClasses()),
+				() -> assertEquals(singletonList("com.acme.Foo"), type.parseArgLine("--select-class=com.acme.Foo").getSelectedClasses()),
+				() -> assertEquals(asList("com.acme.Foo", "com.example.Bar"), type.parseArgLine("-c com.acme.Foo -c com.example.Bar").getSelectedClasses())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidClassSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-c", "--select-class");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidMethodSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("com.acme.Foo#m()"), type.parseArgLine("-m com.acme.Foo#m()").getSelectedMethods()),
+				() -> assertEquals(singletonList("com.acme.Foo#m()"), type.parseArgLine("--m com.acme.Foo#m()").getSelectedMethods()),
+				() -> assertEquals(singletonList("com.acme.Foo#m()"), type.parseArgLine("-select-method com.acme.Foo#m()").getSelectedMethods()),
+				() -> assertEquals(singletonList("com.acme.Foo#m()"), type.parseArgLine("-select-method=com.acme.Foo#m()").getSelectedMethods()),
+				() -> assertEquals(singletonList("com.acme.Foo#m()"), type.parseArgLine("--select-method com.acme.Foo#m()").getSelectedMethods()),
+				() -> assertEquals(singletonList("com.acme.Foo#m()"), type.parseArgLine("--select-method=com.acme.Foo#m()").getSelectedMethods()),
+				() -> assertEquals(asList("com.acme.Foo#m()", "com.example.Bar#method(java.lang.Object)"),
+						type.parseArgLine("-m com.acme.Foo#m() -m com.example.Bar#method(java.lang.Object)").getSelectedMethods())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidMethodSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-m", "--select-method");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidClasspathResourceSelectors(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertEquals(singletonList("/foo.csv"), type.parseArgLine("-r /foo.csv").getSelectedClasspathResources()),
+				() -> assertEquals(singletonList("/foo.csv"), type.parseArgLine("--r /foo.csv").getSelectedClasspathResources()),
+				() -> assertEquals(singletonList("/foo.csv"), type.parseArgLine("-select-resource /foo.csv").getSelectedClasspathResources()),
+				() -> assertEquals(singletonList("/foo.csv"), type.parseArgLine("-select-resource=/foo.csv").getSelectedClasspathResources()),
+				() -> assertEquals(singletonList("/foo.csv"), type.parseArgLine("--select-resource /foo.csv").getSelectedClasspathResources()),
+				() -> assertEquals(singletonList("/foo.csv"), type.parseArgLine("--select-resource=/foo.csv").getSelectedClasspathResources()),
+				() -> assertEquals(asList("/foo.csv", "bar.json"), type.parseArgLine("-r /foo.csv -r bar.json").getSelectedClasspathResources())
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidClasspathResourceSelectors() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-r", "--select-resource");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseClasspathScanningEntries(ArgsType type) {
+		Path dir = Paths.get(".");
+		// @formatter:off
+		assertAll(
+			() -> assertTrue(type.parseArgLine("--scan-class-path").isScanClasspath()),
+			() -> assertEquals(emptyList(), type.parseArgLine("--scan-class-path").getSelectedClasspathEntries()),
+			() -> assertTrue(type.parseArgLine("--scan-classpath").isScanClasspath()),
+			() -> assertEquals(emptyList(), type.parseArgLine("--scan-classpath").getSelectedClasspathEntries()),
+			() -> assertTrue(type.parseArgLine("--scan-class-path .").isScanClasspath()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--scan-class-path .").getSelectedClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("--scan-class-path=.").getSelectedClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("-scan-class-path .").getSelectedClasspathEntries()),
+			() -> assertEquals(singletonList(dir), type.parseArgLine("-scan-class-path=.").getSelectedClasspathEntries()),
+			() -> assertEquals(asList(dir, Paths.get("src/test/java")), type.parseArgLine("--scan-class-path . --scan-class-path src/test/java").getSelectedClasspathEntries()),
+			() -> assertEquals(asList(dir, Paths.get("src/test/java")), type.parseArgLine("--scan-class-path ." + File.pathSeparator + "src/test/java").getSelectedClasspathEntries())
+		);
+		// @formatter:on
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseValidConfigurationParameters(ArgsType type) {
+		// @formatter:off
+		assertAll(
+				() -> assertThat(type.parseArgLine("-config foo=bar").getConfigurationParameters())
+						.containsOnly(entry("foo", "bar")),
+				() -> assertThat(type.parseArgLine("-config=foo=bar").getConfigurationParameters())
+						.containsOnly(entry("foo", "bar")),
+				() -> assertThat(type.parseArgLine("--config foo=bar").getConfigurationParameters())
+						.containsOnly(entry("foo", "bar")),
+				() -> assertThat(type.parseArgLine("--config=foo=bar").getConfigurationParameters())
+						.containsOnly(entry("foo", "bar")),
+				() -> assertThat(type.parseArgLine("--config foo=bar --config baz=qux").getConfigurationParameters())
+						.containsExactly(entry("foo", "bar"), entry("baz", "qux"))
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void parseInvalidConfigurationParameters() {
+		assertOptionWithMissingRequiredArgumentThrowsException("-config", "--config");
+	}
+
+	@ParameterizedTest
+	@EnumSource(ArgsType.class)
+	void parseInvalidConfigurationParametersWithDuplicateKey(ArgsType type) {
+		Exception e = assertThrows(JUnitException.class, () -> type.parseArgLine("--config foo=bar --config foo=baz"));
+
+		assertThat(e.getMessage()).isEqualTo(
+			"Error parsing command-line arguments: Duplicate key 'foo' for values 'bar' and 'baz'.");
+		assertThat(e.getCause().getMessage()).isEqualTo("Duplicate key 'foo' for values 'bar' and 'baz'.");
+	}
+
+	@Test
+	void printHelpOutputsHelpOption() {
+		StringWriter writer = new StringWriter();
+
+		createParser().printHelp(writer);
+
+		assertThat(writer.toString()).contains("--help");
+	}
+
+	@Test
+	void printHelpPreservesOriginalIOException() {
+		Writer writer = new Writer() {
+
+			@Override
+			public void write(char[] cbuf, int off, int len) throws IOException {
+				throw new IOException("Something went wrong");
+			}
+
+			@Override
+			public void flush() {
+			}
+
+			@Override
+			public void close() {
+			}
+		};
+
+		CommandLineOptionsParser parser = createParser();
+		RuntimeException exception = assertThrows(RuntimeException.class, () -> parser.printHelp(writer));
+
+		assertThat(exception).hasCauseInstanceOf(IOException.class);
+		assertThat(exception.getCause()).hasMessage("Something went wrong");
+	}
+
+	private void assertOptionWithMissingRequiredArgumentThrowsException(String... options) {
+		assertAll(stream(options).map(
+			opt -> () -> assertThrows(JUnitException.class, () -> ArgsType.args.parseArgLine(opt))));
+	}
+
+	private void assertParses(String name, Predicate<CommandLineOptions> property, String... argLines) {
+		stream(argLines).forEach(argLine -> {
+			CommandLineOptions options = null;
+			try {
+				options = ArgsType.args.parseArgLine(argLine);
+			}
+			catch (IOException e) {
+				fail(e);
+			}
+			assertTrue(property.test(options), () -> name + " should be enabled by: " + argLine);
+		});
+	}
+
+	enum ArgsType {
+		args {
+			CommandLineOptions parseArgLine(String argLine) {
+				return createParser().parse(split(argLine));
+			}
+		},
+		atFile {
+			CommandLineOptions parseArgLine(String argLine) throws IOException {
+				Path atFile = Files.createTempFile("junit-launcher-args", ".txt");
+				try {
+					List<String> lines = Arrays.asList(split(argLine));
+					Files.write(atFile, lines);
+					return createParser().parse("@" + atFile);
+				}
+				finally {
+					Files.deleteIfExists(atFile);
+				}
+			}
+		};
+		abstract CommandLineOptions parseArgLine(String argLine) throws IOException;
+
+		private static String[] split(String argLine) {
+			return "".equals(argLine) ? new String[0] : argLine.split("\\s+");
+		}
+	}
+
+	private static CommandLineOptionsParser createParser() {
+		return new PicocliCommandLineOptionsParser();
+	}
+
+}
diff --git a/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-console.expected.txt b/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-console.expected.txt
index a22fbfeed..ad05f0180 100644
--- a/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-console.expected.txt
+++ b/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-console.expected.txt
@@ -4,8 +4,7 @@ org.junit.platform.console@${platformVersion} automatic
 requires java.base mandated
 contains org.junit.platform.console
 contains org.junit.platform.console.options
-contains org.junit.platform.console.shadow.joptsimple
-contains org.junit.platform.console.shadow.joptsimple.internal
-contains org.junit.platform.console.shadow.joptsimple.util
+contains org.junit.platform.console.shadow.picocli
+contains org.junit.platform.console.shadow.picocli.groovy
 contains org.junit.platform.console.tasks
 main-class org.junit.platform.console.ConsoleLauncher
