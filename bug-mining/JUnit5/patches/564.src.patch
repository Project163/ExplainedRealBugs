diff --git a/junit-platform-suite-api/src/main/java/org/junit/platform/suite/api/SelectMethod.java b/junit-platform-suite-api/src/main/java/org/junit/platform/suite/api/SelectMethod.java
index b83fd4204..a1313a343 100644
--- a/junit-platform-suite-api/src/main/java/org/junit/platform/suite/api/SelectMethod.java
+++ b/junit-platform-suite-api/src/main/java/org/junit/platform/suite/api/SelectMethod.java
@@ -30,7 +30,11 @@ import org.apiguardian.api.API;
  * @since 1.10
  * @see Suite
  * @see org.junit.platform.runner.JUnitPlatform
+ * @see org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(String)
+ * @see org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(String, String, String)
+ * @see org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(String, String, Class...)
  * @see org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(Class, String, String)
+ * @see org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(Class, String, Class...)
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
@@ -40,15 +44,74 @@ import org.apiguardian.api.API;
 @Repeatable(SelectMethods.class)
 public @interface SelectMethod {
 
+	/**
+	 * The <em>fully qualified method name</em> of the method to select.
+	 *
+	 * <p>The following formats are supported.
+	 *
+	 * <ul>
+	 * <li>{@code [fully qualified class name]#[methodName]}</li>
+	 * <li>{@code [fully qualified class name]#[methodName](parameter type list)}
+	 * </ul>
+	 *
+	 * <p>The <em>parameter type list</em> is a comma-separated list of primitive
+	 * names or fully qualified class names for the types of parameters accepted
+	 * by the method.
+	 *
+	 * <p>Array parameter types may be specified using either the JVM's internal
+	 * String representation (e.g., {@code [[I} for {@code int[][]},
+	 * {@code [Ljava.lang.String;} for {@code java.lang.String[]}, etc.) or
+	 * <em>source code syntax</em> (e.g., {@code int[][]}, {@code java.lang.String[]},
+	 * etc.).
+	 *
+	 * <table class="plain">
+	 * <caption>Examples</caption>
+	 * <tr><th>Method</th><th>Fully Qualified Method Name</th></tr>
+	 * <tr><td>{@code java.lang.String.chars()}</td><td>{@code java.lang.String#chars}</td></tr>
+	 * <tr><td>{@code java.lang.String.chars()}</td><td>{@code java.lang.String#chars()}</td></tr>
+	 * <tr><td>{@code java.lang.String.equalsIgnoreCase(String)}</td><td>{@code java.lang.String#equalsIgnoreCase(java.lang.String)}</td></tr>
+	 * <tr><td>{@code java.lang.String.substring(int, int)}</td><td>{@code java.lang.String#substring(int, int)}</td></tr>
+	 * <tr><td>{@code example.Calc.avg(int[])}</td><td>{@code example.Calc#avg([I)}</td></tr>
+	 * <tr><td>{@code example.Calc.avg(int[])}</td><td>{@code example.Calc#avg(int[])}</td></tr>
+	 * <tr><td>{@code example.Matrix.multiply(double[][])}</td><td>{@code example.Matrix#multiply([[D)}</td></tr>
+	 * <tr><td>{@code example.Matrix.multiply(double[][])}</td><td>{@code example.Matrix#multiply(double[][])}</td></tr>
+	 * <tr><td>{@code example.Service.process(String[])}</td><td>{@code example.Service#process([Ljava.lang.String;)}</td></tr>
+	 * <tr><td>{@code example.Service.process(String[])}</td><td>{@code example.Service#process(java.lang.String[])}</td></tr>
+	 * <tr><td>{@code example.Service.process(String[][])}</td><td>{@code example.Service#process([[Ljava.lang.String;)}</td></tr>
+	 * <tr><td>{@code example.Service.process(String[][])}</td><td>{@code example.Service#process(java.lang.String[][])}</td></tr>
+	 * </table>
+	 *
+	 * <p>Cannot be combined with any other attribute.
+	 *
+	 * @see org.junit.platform.engine.discovery.DiscoverySelectors#selectMethod(String)
+	 */
+	String value() default "";
+
 	/**
 	 * The class in which the method is declared, or a subclass thereof.
+	 *
+	 * <p>Cannot be used in conjunction with {@link #typeName()}.
+	 */
+	Class<?> type() default Class.class;
+
+	/**
+	 * The <em>fully qualified class name</em> in which the method is declared, or a subclass thereof.
+	 *
+	 * <p>Cannot be used in conjunction with {@link #type()}.
 	 */
-	Class<?> clazz();
+	String typeName() default "";
 
 	/**
-	 * The name of the method to select; never blank.
+	 * The name of the method to select; never blank unless {@link #value()} is used.
 	 */
-	String name();
+	String name() default "";
+
+	/**
+	 * The parameter types of the method to select.
+	 *
+	 * <p>Cannot be used in conjunction with {@link #parameterTypeNames()}.
+	 */
+	Class<?>[] parameterTypes() default {};
 
 	/**
 	 * The parameter types of the method to select.
@@ -81,7 +144,9 @@ public @interface SelectMethod {
 	 * <tr><td>{@code example.Service.process(String[][])}</td><td>{@code [[Ljava.lang.String;}</td></tr>
 	 * <tr><td>{@code example.Service.process(String[][])}</td><td>{@code java.lang.String[][]}</td></tr>
 	 * </table>
+	 *
+	 * <p>Cannot be used in conjunction with {@link #parameterTypes()}.
 	 */
-	String parameters() default "";
+	String parameterTypeNames() default "";
 
 }
diff --git a/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/AdditionalDiscoverySelectors.java b/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/AdditionalDiscoverySelectors.java
index 188385080..65e6c3504 100644
--- a/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/AdditionalDiscoverySelectors.java
+++ b/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/AdditionalDiscoverySelectors.java
@@ -23,7 +23,6 @@ import org.junit.platform.engine.discovery.DirectorySelector;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
 import org.junit.platform.engine.discovery.FilePosition;
 import org.junit.platform.engine.discovery.FileSelector;
-import org.junit.platform.engine.discovery.MethodSelector;
 import org.junit.platform.engine.discovery.ModuleSelector;
 import org.junit.platform.engine.discovery.PackageSelector;
 import org.junit.platform.engine.discovery.UriSelector;
@@ -82,12 +81,6 @@ class AdditionalDiscoverySelectors {
 		return uniqueStreamOf(classNames).map(DiscoverySelectors::selectClass);
 	}
 
-	static MethodSelector selectMethod(Class<?> clazz, String name, String parameterTypeNames) {
-		Preconditions.notBlank(name, "Method name must not be null or blank");
-		Preconditions.notNull(parameterTypeNames, "parameter type names must not be null");
-		return DiscoverySelectors.selectMethod(clazz, name, parameterTypeNames);
-	}
-
 	static List<ModuleSelector> selectModules(String... moduleNames) {
 		Preconditions.notNull(moduleNames, "Module names must not be null");
 		Preconditions.containsNoNullElements(moduleNames, "Individual module names must not be null");
diff --git a/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java b/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java
index 08cb4aea2..c94b8009a 100644
--- a/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java
+++ b/junit-platform-suite-commons/src/main/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilder.java
@@ -38,6 +38,7 @@ import org.junit.platform.engine.DiscoverySelector;
 import org.junit.platform.engine.Filter;
 import org.junit.platform.engine.discovery.ClassNameFilter;
 import org.junit.platform.engine.discovery.ClassSelector;
+import org.junit.platform.engine.discovery.DiscoverySelectors;
 import org.junit.platform.engine.discovery.MethodSelector;
 import org.junit.platform.engine.discovery.PackageNameFilter;
 import org.junit.platform.launcher.EngineFilter;
@@ -155,7 +156,7 @@ public final class SuiteLauncherDiscoveryRequestBuilder {
 				.ifPresent(this::selectors);
 		findRepeatableAnnotations(suiteClass, SelectMethod.class)
 				.stream()
-				.map(annotation -> selectMethod(annotation.clazz(), annotation.name(), annotation.parameters()))
+				.map(annotation -> selectMethod(suiteClass, annotation))
 				.forEach(this::selectors);
 		findAnnotationValues(suiteClass, IncludeClassNamePatterns.class, IncludeClassNamePatterns::value)
 				.flatMap(SuiteLauncherDiscoveryRequestBuilder::trimmed)
@@ -226,9 +227,68 @@ public final class SuiteLauncherDiscoveryRequestBuilder {
 		);
 	}
 
-	private MethodSelector selectMethod(Class<?> clazz, String name, String parameters) {
-		selectedClassNames.add(clazz.getName());
-		return AdditionalDiscoverySelectors.selectMethod(clazz, name, parameters);
+	private MethodSelector selectMethod(Class<?> suiteClass, SelectMethod annotation) {
+		MethodSelector methodSelector = toMethodSelector(suiteClass, annotation);
+		selectedClassNames.add(methodSelector.getClassName());
+		return methodSelector;
+	}
+
+	private MethodSelector toMethodSelector(Class<?> suiteClass, SelectMethod annotation) {
+		if (!annotation.value().isEmpty()) {
+			Preconditions.condition(annotation.type() == Class.class,
+				() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+					"type must not be set in conjunction with fully qualified method name"));
+			Preconditions.condition(annotation.typeName().isEmpty(),
+				() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+					"type name must not be set in conjunction with fully qualified method name"));
+			Preconditions.condition(annotation.name().isEmpty(),
+				() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+					"method name must not be set in conjunction with fully qualified method name"));
+			Preconditions.condition(annotation.parameterTypes().length == 0,
+				() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+					"parameter types must not be set in conjunction with fully qualified method name"));
+			Preconditions.condition(annotation.parameterTypeNames().isEmpty(),
+				() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+					"parameter type names must not be set in conjunction with fully qualified method name"));
+
+			return DiscoverySelectors.selectMethod(annotation.value());
+		}
+
+		Class<?> type = annotation.type() == Class.class ? null : annotation.type();
+		String typeName = annotation.typeName().isEmpty() ? null : annotation.typeName().trim();
+		String methodName = Preconditions.notBlank(annotation.name(),
+			() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass, "method name must not be blank"));
+		Class<?>[] parameterTypes = annotation.parameterTypes().length == 0 ? null : annotation.parameterTypes();
+		String parameterTypeNames = annotation.parameterTypeNames().trim();
+		if (parameterTypes != null) {
+			Preconditions.condition(parameterTypeNames.isEmpty(),
+				() -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+					"either parameter type names or parameter types must be set but not both"));
+		}
+		if (type == null) {
+			Preconditions.notBlank(typeName, () -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+				"type must be set or type name must not be blank"));
+			if (parameterTypes == null) {
+				return DiscoverySelectors.selectMethod(typeName, methodName, parameterTypeNames);
+			}
+			else {
+				return DiscoverySelectors.selectMethod(typeName, methodName, parameterTypes);
+			}
+		}
+		else {
+			Preconditions.condition(typeName == null, () -> prefixErrorMessageForInvalidSelectMethodUsage(suiteClass,
+				"either type name or type must be set but not both"));
+			if (parameterTypes == null) {
+				return DiscoverySelectors.selectMethod(type, methodName, parameterTypeNames);
+			}
+			else {
+				return DiscoverySelectors.selectMethod(type, methodName, parameterTypes);
+			}
+		}
+	}
+
+	private static String prefixErrorMessageForInvalidSelectMethodUsage(Class<?> suiteClass, String detailMessage) {
+		return String.format("@SelectMethod on class [%s]: %s", suiteClass.getName(), detailMessage);
 	}
 
 	private ClassNameFilter createIncludeClassNameFilter(String... patterns) {
diff --git a/platform-tests/src/test/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilderTests.java b/platform-tests/src/test/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilderTests.java
index bafc67b02..55aa8d6ea 100644
--- a/platform-tests/src/test/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilderTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/suite/commons/SuiteLauncherDiscoveryRequestBuilderTests.java
@@ -10,11 +10,14 @@
 
 package org.junit.platform.suite.commons;
 
+import static java.util.Map.entry;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilder.request;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -26,8 +29,11 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.regex.Pattern;
+import java.util.stream.Stream;
 
+import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.engine.JupiterTestEngine;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.CollectionUtils;
@@ -72,7 +78,7 @@ import org.junit.platform.suite.api.SelectUris;
 
 class SuiteLauncherDiscoveryRequestBuilderTests {
 
-	SuiteLauncherDiscoveryRequestBuilder builder = SuiteLauncherDiscoveryRequestBuilder.request();
+	SuiteLauncherDiscoveryRequestBuilder builder = request();
 
 	@Test
 	void configurationParameter() {
@@ -249,40 +255,68 @@ class SuiteLauncherDiscoveryRequestBuilderTests {
 	static class NonLocalTestCase {
 	}
 
-	@Test
-	void selectOneMethodWithNoParameters() {
-		@SuppressWarnings("unused")
-		class TestClass {
-			void testMethod() {
-			}
+	@TestFactory
+	Stream<DynamicTest> selectOneMethodWithNoParameters() {
+		@SelectMethod("org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$NoParameterTestCase#testMethod")
+		class SuiteA {
 		}
-		@SelectMethod(clazz = TestClass.class, name = "testMethod")
-		class Suite {
+		@SelectMethod(type = NoParameterTestCase.class, name = "testMethod")
+		class SuiteB {
+		}
+		@SelectMethod(typeName = "org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$NoParameterTestCase", name = "testMethod")
+		class SuiteC {
 		}
 
-		LauncherDiscoveryRequest request = builder.suite(Suite.class).build();
-		List<MethodSelector> selectors = request.getSelectorsByType(MethodSelector.class);
-		assertEquals(DiscoverySelectors.selectMethod(TestClass.class, "testMethod"), exactlyOne(selectors));
+		return Stream.of(SuiteA.class, SuiteB.class, SuiteC.class) //
+				.map(suiteClass -> dynamicTest(suiteClass.getSimpleName(), () -> {
+					LauncherDiscoveryRequest request = request().suite(suiteClass).build();
+					List<MethodSelector> selectors = request.getSelectorsByType(MethodSelector.class);
+					assertEquals(DiscoverySelectors.selectMethod(NoParameterTestCase.class, "testMethod"),
+						exactlyOne(selectors));
+				}));
 	}
 
-	@Test
-	void selectOneMethodWithOneParameters() {
+	static class NoParameterTestCase {
 		@SuppressWarnings("unused")
-		class TestClass {
-			void testMethod(int i) {
-			}
+		void testMethod() {
 		}
-		@SelectMethod(clazz = TestClass.class, name = "testMethod", parameters = "int")
-		class Suite {
+	}
+
+	@TestFactory
+	Stream<DynamicTest> selectOneMethodWithOneParameter() {
+		@SelectMethod("org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$OneParameterTestCase#testMethod(int)")
+		class SuiteA {
+		}
+		@SelectMethod(type = OneParameterTestCase.class, name = "testMethod", parameterTypeNames = "int")
+		class SuiteB {
+		}
+		@SelectMethod(type = OneParameterTestCase.class, name = "testMethod", parameterTypes = int.class)
+		class SuiteC {
+		}
+		@SelectMethod(typeName = "org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$OneParameterTestCase", name = "testMethod", parameterTypeNames = "int")
+		class SuiteD {
+		}
+		@SelectMethod(typeName = "org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$OneParameterTestCase", name = "testMethod", parameterTypes = int.class)
+		class SuiteE {
 		}
 
-		LauncherDiscoveryRequest request = builder.suite(Suite.class).build();
-		List<MethodSelector> selectors = request.getSelectorsByType(MethodSelector.class);
-		assertEquals(DiscoverySelectors.selectMethod(TestClass.class, "testMethod", "int"), exactlyOne(selectors));
+		return Stream.of(SuiteA.class, SuiteB.class, SuiteC.class, SuiteD.class, SuiteE.class) //
+				.map(suiteClass -> dynamicTest(suiteClass.getSimpleName(), () -> {
+					LauncherDiscoveryRequest request = request().suite(suiteClass).build();
+					List<MethodSelector> selectors = request.getSelectorsByType(MethodSelector.class);
+					assertEquals(DiscoverySelectors.selectMethod(OneParameterTestCase.class, "testMethod", "int"),
+						exactlyOne(selectors));
+				}));
+	}
+
+	static class OneParameterTestCase {
+		@SuppressWarnings("unused")
+		void testMethod(int i) {
+		}
 	}
 
 	@Test
-	void selectTwoMethodWithTwoParameters() {
+	void selectTwoMethodsWithTwoParameters() {
 		@SuppressWarnings("unused")
 		class TestClass {
 			void firstTestMethod(int i, String j) {
@@ -291,8 +325,9 @@ class SuiteLauncherDiscoveryRequestBuilderTests {
 			void secondTestMethod(boolean i, float j) {
 			}
 		}
-		@SelectMethod(clazz = TestClass.class, name = "firstTestMethod", parameters = "int, java.lang.String")
-		@SelectMethod(clazz = TestClass.class, name = "secondTestMethod", parameters = "boolean, float")
+		@SelectMethod(type = TestClass.class, name = "firstTestMethod", parameterTypeNames = "int, java.lang.String")
+		@SelectMethod(type = TestClass.class, name = "secondTestMethod", parameterTypes = { boolean.class,
+				float.class })
 		class Suite {
 		}
 
@@ -305,6 +340,61 @@ class SuiteLauncherDiscoveryRequestBuilderTests {
 			selectors.get(1));
 	}
 
+	@TestFactory
+	Stream<DynamicTest> selectMethodCausesExceptionOnInvalidUsage() {
+		@SelectMethod(value = "irrelevant", type = NoParameterTestCase.class)
+		class ValueAndType {
+		}
+		@SelectMethod(value = "SomeClass#someMethod", typeName = "org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$NoParameterTestCase")
+		class ValueAndTypeName {
+		}
+		@SelectMethod(value = "SomeClass#someMethod", name = "testMethod")
+		class ValueAndMethodName {
+		}
+		@SelectMethod(value = "SomeClass#someMethod", parameterTypes = int.class)
+		class ValueAndParameterTypes {
+		}
+		@SelectMethod(value = "SomeClass#someMethod", parameterTypeNames = "int")
+		class ValueAndParameterTypeNames {
+		}
+		@SelectMethod(type = NoParameterTestCase.class)
+		class MissingMethodName {
+		}
+		@SelectMethod(name = "testMethod", type = NoParameterTestCase.class, typeName = "org.junit.platform.suite.commons.SuiteLauncherDiscoveryRequestBuilderTests$NoParameterTestCase")
+		class TypeAndTypeName {
+		}
+		@SelectMethod(name = "testMethod", parameterTypes = int.class, parameterTypeNames = "int")
+		class ParameterTypesAndParameterTypeNames {
+		}
+
+		var expectedFailureMessages = Map.ofEntries( //
+			entry(ValueAndType.class, "type must not be set in conjunction with fully qualified method name"), //
+			entry(ValueAndTypeName.class, "type name must not be set in conjunction with fully qualified method name"), //
+			entry(ValueAndMethodName.class,
+				"method name must not be set in conjunction with fully qualified method name"), //
+			entry(ValueAndParameterTypes.class,
+				"parameter types must not be set in conjunction with fully qualified method name"), //
+			entry(ValueAndParameterTypeNames.class,
+				"parameter type names must not be set in conjunction with fully qualified method name"), //
+			entry(MissingMethodName.class, "method name must not be blank"), //
+			entry(TypeAndTypeName.class, "either type name or type must be set but not both"), //
+			entry(ParameterTypesAndParameterTypeNames.class,
+				"either parameter type names or parameter types must be set but not both") //
+		);
+		return expectedFailureMessages.entrySet().stream() //
+				.map(entry -> {
+					Class<?> suiteClassName = entry.getKey();
+					var expectedFailureMessage = entry.getValue();
+					return dynamicTest(suiteClassName.getSimpleName(), () -> {
+						var ex = assertThrows(PreconditionViolationException.class,
+							() -> request().suite(suiteClassName));
+						assertEquals(
+							"@SelectMethod on class [" + suiteClassName.getName() + "]: " + expectedFailureMessage,
+							ex.getMessage());
+					});
+				});
+	}
+
 	@Test
 	void selectClasspathResource() {
 		@SelectClasspathResource("com.example.testcases")
diff --git a/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SelectMethodsSuite.java b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SelectMethodsSuite.java
index 1e9712e5e..49184c267 100644
--- a/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SelectMethodsSuite.java
+++ b/platform-tests/src/test/java/org/junit/platform/suite/engine/testsuites/SelectMethodsSuite.java
@@ -18,6 +18,6 @@ import org.junit.platform.suite.engine.testcases.MultipleTestsTestCase;
  * @since 1.10
  */
 @Suite
-@SelectMethod(clazz = MultipleTestsTestCase.class, name = "test")
+@SelectMethod(type = MultipleTestsTestCase.class, name = "test")
 public class SelectMethodsSuite {
 }
