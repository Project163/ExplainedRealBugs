diff --git a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
index 471a2aa3c..e95e9cddb 100644
--- a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
+++ b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
@@ -96,6 +96,8 @@ on GitHub.
 * If a `@ParameterizedTest` accepts an array as an argument, the string representation of
   the array will now be converted to a human readable format when generating the display
   name for invocations of the parameterized test.
+* Extensions may now share state across top-level test classes by using the `Store` of the
+  newly introduced engine-level `ExtensionContext`.
 
 
 [[release-notes-5.0.0-m5-junit-vintage]]
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
index 976f78f68..5c8dfde81 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
@@ -13,9 +13,11 @@ package org.junit.jupiter.engine.descriptor;
 import static org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryWithDefaultExtensions;
 import static org.junit.platform.commons.meta.API.Usage.Internal;
 
+import org.junit.jupiter.api.extension.ContainerExtensionContext;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.commons.meta.API;
+import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.EngineDescriptor;
 import org.junit.platform.engine.support.hierarchical.Node;
@@ -31,12 +33,15 @@ public class JupiterEngineDescriptor extends EngineDescriptor implements Node<Ju
 	}
 
 	@Override
-	public JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
+	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) throws Exception {
 		ExtensionRegistry extensionRegistry = createRegistryWithDefaultExtensions(context.getConfigurationParameters());
+		EngineExecutionListener executionListener = context.getExecutionListener();
+		ContainerExtensionContext extensionContext = new JupiterEngineExtensionContext(executionListener, this);
 
 		// @formatter:off
 		return context.extend()
 				.withExtensionRegistry(extensionRegistry)
+				.withExtensionContext(extensionContext)
 				.build();
 		// @formatter:on
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java
new file mode 100644
index 000000000..31b544789
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static org.junit.platform.commons.meta.API.Usage.Internal;
+
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Method;
+import java.util.Optional;
+
+import org.junit.jupiter.api.extension.ContainerExtensionContext;
+import org.junit.platform.commons.meta.API;
+import org.junit.platform.engine.EngineExecutionListener;
+
+/**
+ * @since 5.0
+ */
+@API(Internal)
+public final class JupiterEngineExtensionContext extends AbstractExtensionContext<JupiterEngineDescriptor>
+		implements ContainerExtensionContext {
+
+	public JupiterEngineExtensionContext(EngineExecutionListener engineExecutionListener,
+			JupiterEngineDescriptor testDescriptor) {
+		super(null, engineExecutionListener, testDescriptor);
+	}
+
+	@Override
+	public Optional<AnnotatedElement> getElement() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Class<?>> getTestClass() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Method> getTestMethod() {
+		return Optional.empty();
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextTests.java
index 2402c96d5..308fd0c7f 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExtensionContextTests.java
@@ -10,20 +10,21 @@
 
 package org.junit.jupiter.engine.execution;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertAll;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.Collections;
 import java.util.Map;
-import java.util.Optional;
 
-import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.descriptor.ClassBasedContainerExtensionContext;
 import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
+import org.junit.jupiter.engine.descriptor.JupiterEngineExtensionContext;
 import org.junit.jupiter.engine.descriptor.MethodBasedTestExtensionContext;
 import org.junit.jupiter.engine.descriptor.MethodTestDescriptor;
 import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
@@ -36,14 +37,31 @@ import org.mockito.Mockito;
 
 /**
  * Microtests for implementors of {@linkplain ExtensionContext}:
- * {@linkplain ClassBasedContainerExtensionContext} and
- * {@linkplain MethodBasedTestExtensionContext}
+ * {@linkplain JupiterEngineExtensionContext},
+ * {@linkplain ClassBasedContainerExtensionContext}, and
+ * {@linkplain MethodBasedTestExtensionContext}.
  *
  * @since 5.0
  * @see ExtensionValuesStoreTests
  */
 class ExtensionContextTests {
 
+	@Test
+	void fromJupiterEngineDescriptor() {
+		JupiterEngineDescriptor engineTestDescriptor = new JupiterEngineDescriptor(
+			UniqueId.root("engine", "junit-jupiter"));
+
+		JupiterEngineExtensionContext engineContext = new JupiterEngineExtensionContext(null, engineTestDescriptor);
+
+		assertAll("engineContext", //
+			() -> assertThat(engineContext.getTestClass()).isEmpty(), //
+			() -> assertThat(engineContext.getTestMethod()).isEmpty(), //
+			() -> assertThat(engineContext.getElement()).isEmpty(), //
+			() -> assertThat(engineContext.getDisplayName()).isEqualTo(engineTestDescriptor.getDisplayName()), //
+			() -> assertThat(engineContext.getParent()).isEmpty() //
+		);
+	}
+
 	@Test
 	void fromClassTestDescriptor() {
 		ClassTestDescriptor nestedClassDescriptor = nestedClassDescriptor();
@@ -51,15 +69,15 @@ class ExtensionContextTests {
 
 		ClassBasedContainerExtensionContext outerExtensionContext = new ClassBasedContainerExtensionContext(null, null,
 			outerClassDescriptor);
-		Assertions.assertAll("outerContext", //
-			() -> assertEquals(OuterClass.class, outerExtensionContext.getTestClass().get()), //
-			() -> assertEquals(outerClassDescriptor.getDisplayName(), outerExtensionContext.getDisplayName()), //
-			() -> assertEquals(Optional.empty(), outerExtensionContext.getParent()) //
+		assertAll("outerContext", //
+			() -> assertThat(outerExtensionContext.getTestClass()).contains(OuterClass.class), //
+			() -> assertThat(outerExtensionContext.getDisplayName()).isEqualTo(outerClassDescriptor.getDisplayName()), //
+			() -> assertThat(outerExtensionContext.getParent()).isEmpty() //
 		);
 
 		ClassBasedContainerExtensionContext nestedExtensionContext = new ClassBasedContainerExtensionContext(
 			outerExtensionContext, null, nestedClassDescriptor);
-		Assertions.assertSame(outerExtensionContext, nestedExtensionContext.getParent().get());
+		assertThat(nestedExtensionContext.getParent()).containsSame(outerExtensionContext);
 	}
 
 	@Test
@@ -72,23 +90,15 @@ class ExtensionContextTests {
 		ClassBasedContainerExtensionContext outerExtensionContext = new ClassBasedContainerExtensionContext(null, null,
 			outerClassDescriptor);
 
-		Assertions.assertAll("tags in outer class", //
-			() -> assertEquals(1, outerExtensionContext.getTags().size()), //
-			() -> assertTrue(outerExtensionContext.getTags().contains("outer-tag")));
+		assertThat(outerExtensionContext.getTags()).containsExactly("outer-tag");
 
 		ClassBasedContainerExtensionContext nestedExtensionContext = new ClassBasedContainerExtensionContext(
 			outerExtensionContext, null, nestedClassDescriptor);
-		Assertions.assertAll("tags in nested class", //
-			() -> assertEquals(2, nestedExtensionContext.getTags().size()), //
-			() -> assertTrue(nestedExtensionContext.getTags().contains("outer-tag"), "outer-tag missing"), //
-			() -> assertTrue(nestedExtensionContext.getTags().contains("nested-tag"), "nested-tag missing"));
+		assertThat(nestedExtensionContext.getTags()).containsExactlyInAnyOrder("outer-tag", "nested-tag");
 
 		MethodBasedTestExtensionContext testExtensionContext = new MethodBasedTestExtensionContext(
 			outerExtensionContext, null, methodTestDescriptor, new OuterClass(), new ThrowableCollector());
-		Assertions.assertAll("tags in method", //
-			() -> assertEquals(2, testExtensionContext.getTags().size()), //
-			() -> assertTrue(testExtensionContext.getTags().contains("outer-tag"), "outer-tag missing"), //
-			() -> assertTrue(testExtensionContext.getTags().contains("method-tag"), "method-tag missing"));
+		assertThat(testExtensionContext.getTags()).containsExactlyInAnyOrder("outer-tag", "method-tag");
 	}
 
 	@Test
@@ -100,11 +110,11 @@ class ExtensionContextTests {
 			classTestDescriptor);
 		MethodBasedTestExtensionContext testExtensionContext = new MethodBasedTestExtensionContext(
 			classExtensionContext, null, methodTestDescriptor, new OuterClass(), new ThrowableCollector());
-		Assertions.assertAll("methodContext", //
-			() -> assertEquals(OuterClass.class, testExtensionContext.getTestClass().get()), //
-			() -> assertEquals(methodTestDescriptor.getDisplayName(), testExtensionContext.getDisplayName()), //
-			() -> assertEquals(classExtensionContext, testExtensionContext.getParent().get()), //
-			() -> assertEquals(OuterClass.class, testExtensionContext.getTestInstance().getClass()) //
+		assertAll("methodContext", //
+			() -> assertThat(testExtensionContext.getTestClass()).contains(OuterClass.class), //
+			() -> assertThat(testExtensionContext.getDisplayName()).isEqualTo(methodTestDescriptor.getDisplayName()), //
+			() -> assertThat(testExtensionContext.getParent()).contains(classExtensionContext), //
+			() -> assertThat(testExtensionContext.getTestInstance()).isExactlyInstanceOf(OuterClass.class) //
 		);
 	}
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionContextExecutionTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionContextExecutionTests.java
new file mode 100644
index 000000000..dea7ae979
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionContextExecutionTests.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
+
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.BeforeAllCallback;
+import org.junit.jupiter.api.extension.ContainerExtensionContext;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.api.extension.TestExtensionContext;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.platform.engine.test.event.ExecutionEventRecorder;
+
+class ExtensionContextExecutionTests extends AbstractJupiterTestEngineTests {
+
+	@Test
+	@ExtendWith(ExtensionContextParameterResolver.class)
+	void extensionContextHierarchy(ExtensionContext testExtensionContext) {
+		assertThat(testExtensionContext).isInstanceOf(TestExtensionContext.class);
+
+		Optional<ExtensionContext> classExtensionContext = testExtensionContext.getParent();
+		assertThat(classExtensionContext).containsInstanceOf(ContainerExtensionContext.class);
+
+		Optional<ExtensionContext> engineExtensionContext = classExtensionContext.orElse(null).getParent();
+		assertThat(engineExtensionContext).containsInstanceOf(ContainerExtensionContext.class);
+
+		assertThat(engineExtensionContext.orElse(null).getParent()).isEmpty();
+	}
+
+	static class ExtensionContextParameterResolver implements ParameterResolver {
+		@Override
+		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+				throws ParameterResolutionException {
+			return ExtensionContext.class.equals(parameterContext.getParameter().getType());
+		}
+
+		@Override
+		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+				throws ParameterResolutionException {
+			return extensionContext;
+		}
+	}
+
+	@Test
+	void twoTestClassesCanShareStateViaEngineExtensionContext() {
+		Parent.counter.set(0);
+
+		ExecutionEventRecorder eventRecorder = executeTests(
+			request().selectors(selectClass(A.class), selectClass(B.class)).build());
+
+		assertThat(eventRecorder.getTestFinishedCount()).isEqualTo(2);
+		assertThat(Parent.counter).hasValue(1);
+	}
+
+	@ExtendWith(OnlyIncrementCounterOnce.class)
+	static class Parent {
+		static final AtomicInteger counter = new AtomicInteger(0);
+
+		@Test
+		void test() {
+		}
+	}
+
+	static class A extends Parent {
+	}
+
+	static class B extends Parent {
+	}
+
+	static class OnlyIncrementCounterOnce implements BeforeAllCallback {
+		@Override
+		public void beforeAll(ContainerExtensionContext context) throws Exception {
+			getRoot(context).getStore().getOrComputeIfAbsent("counter", key -> Parent.counter.incrementAndGet());
+		}
+
+		private ExtensionContext getRoot(ExtensionContext context) {
+			return context.getParent().map(this::getRoot).orElse(context);
+		}
+	}
+
+}
