diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.2.adoc
index 337aea4e5..0da105d0e 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.2.adoc
@@ -5,8 +5,8 @@
 
 *Scope:* Bug fixes since 5.6.1
 
-For a complete list of all _closed_ issues and pull requests for this release, consult
-the link:{junit5-repo}+/milestone/48?closed=1+[5.6.2] milestone page in the JUnit repository
+For a complete list of all _closed_ issues and pull requests for this release, consult the
+link:{junit5-repo}+/milestone/48?closed=1+[5.6.2] milestone page in the JUnit repository
 on GitHub.
 
 
@@ -15,7 +15,10 @@ on GitHub.
 
 ==== Bug Fixes
 
-* ❓
+* `ReflectionSupport.findNestedClasses()` no longer detects inner class cycles for classes
+  that do not match the supplied `Predicate`. For example, JUnit Jupiter no longer throws
+  an exception if an inner class cycle is detected in a nested class hierarchy whose inner
+  classes are not annotated with `@Nested`.
 
 
 [[release-notes-5.6.2-junit-jupiter]]
@@ -23,7 +26,8 @@ on GitHub.
 
 ==== Bug Fixes
 
-* ❓
+* Test discovery no longer halts with an exception for inner class hierarchies that form a
+  cycle if such inner classes are not annotated with `@Nested`.
 
 
 [[release-notes-5.6.2-junit-vintage]]
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java
index 98615023b..9605a0c2e 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTestsTests.java
@@ -84,6 +84,15 @@ class IsTestClassWithTestsTests {
 		assertFalse(isTestClassWithTests.test(PrivateStaticTestCase.class));
 	}
 
+	/**
+	 * @see https://github.com/junit-team/junit5/issues/2249
+	 */
+	@Test
+	void recursiveHierarchies() {
+		assertTrue(isTestClassWithTests.test(OuterClass.class));
+		assertFalse(isTestClassWithTests.test(OuterClass.RecursiveInnerClass.class));
+	}
+
 	// -------------------------------------------------------------------------
 
 	private class PrivateClassWithTestMethod {
@@ -143,6 +152,22 @@ class IsTestClassWithTestsTests {
 		}
 	}
 
+	static class OuterClass {
+
+		@Nested
+		class InnerClass {
+
+			@Test
+			void test() {
+			}
+		}
+
+		// Intentionally commented out so that RecursiveInnerClass is NOT a candidate test class
+		// @Nested
+		class RecursiveInnerClass extends OuterClass {
+		}
+	}
+
 }
 
 // -----------------------------------------------------------------------------
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
index 4f3bd778d..0c5c2f58b 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
@@ -1004,22 +1004,26 @@ public final class ReflectionUtils {
 		Preconditions.notNull(predicate, "Predicate must not be null");
 
 		Set<Class<?>> candidates = new LinkedHashSet<>();
-		findNestedClasses(clazz, candidates);
-		return candidates.stream().filter(predicate).collect(toUnmodifiableList());
+		findNestedClasses(clazz, predicate, candidates);
+		return Collections.unmodifiableList(new ArrayList<>(candidates));
 	}
 
-	private static void findNestedClasses(Class<?> clazz, Set<Class<?>> candidates) {
+	private static void findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate, Set<Class<?>> candidates) {
 		if (!isSearchable(clazz)) {
 			return;
 		}
 
-		detectInnerClassCycle(clazz);
+		if (isInnerClass(clazz) && predicate.test(clazz)) {
+			detectInnerClassCycle(clazz);
+		}
 
 		try {
 			// Candidates in current class
 			for (Class<?> nestedClass : clazz.getDeclaredClasses()) {
-				detectInnerClassCycle(nestedClass);
-				candidates.add(nestedClass);
+				if (predicate.test(nestedClass)) {
+					detectInnerClassCycle(nestedClass);
+					candidates.add(nestedClass);
+				}
 			}
 		}
 		catch (NoClassDefFoundError error) {
@@ -1027,11 +1031,11 @@ public final class ReflectionUtils {
 		}
 
 		// Search class hierarchy
-		findNestedClasses(clazz.getSuperclass(), candidates);
+		findNestedClasses(clazz.getSuperclass(), predicate, candidates);
 
 		// Search interface hierarchy
 		for (Class<?> ifc : clazz.getInterfaces()) {
-			findNestedClasses(ifc, candidates);
+			findNestedClasses(ifc, predicate, candidates);
 		}
 	}
 
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
index fcb4ea6b1..64e9bdddc 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
@@ -690,6 +690,14 @@ class ReflectionUtilsTests {
 		assertThat(findNestedClasses(AbstractOuterClass.class))//
 				.containsExactly(AbstractOuterClass.InnerClass.class);
 
+		// OuterClass contains recursive hierarchies, but the non-matching
+		// predicate should prevent cycle detection.
+		// See https://github.com/junit-team/junit5/issues/2249
+		assertThat(ReflectionUtils.findNestedClasses(OuterClass.class, clazz -> false)).isEmpty();
+		// RecursiveInnerInnerClass is part of a recursive hierarchy, but the non-matching
+		// predicate should prevent cycle detection.
+		assertThat(ReflectionUtils.findNestedClasses(RecursiveInnerInnerClass.class, clazz -> false)).isEmpty();
+
 		// Sibling types don't actually result in cycles.
 		assertThat(findNestedClasses(StaticNestedSiblingClass.class))//
 				.containsExactly(AbstractOuterClass.InnerClass.class);
