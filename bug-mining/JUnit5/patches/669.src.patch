diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc
index ee08a53ee..1e2d0eab3 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc
@@ -16,7 +16,10 @@ JUnit repository on GitHub.
 [[release-notes-5.11.4-junit-platform-bug-fixes]]
 ==== Bug Fixes
 
-* ‚ùì
+* Escape whitespace characters (such as line breaks) in XML attribute values (such as
+  exception messages) in the legacy XML report generated by the Console Launcher. This
+  change ensures the resulting XML files can be processed by downstream tools while
+  preserving whitespace characters.
 
 [[release-notes-5.11.4-junit-platform-deprecations-and-breaking-changes]]
 ==== Deprecations and Breaking Changes
diff --git a/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java b/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java
index 6fa11f044..b9d7ea13a 100644
--- a/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java
+++ b/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java
@@ -13,6 +13,7 @@ package org.junit.platform.reporting.legacy.xml;
 import static java.text.MessageFormat.format;
 import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME;
 import static java.util.Collections.emptyList;
+import static java.util.Collections.unmodifiableMap;
 import static java.util.Comparator.naturalOrder;
 import static java.util.function.Function.identity;
 import static java.util.stream.Collectors.counting;
@@ -30,6 +31,7 @@ import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.Aggregated
 import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.AggregatedTestResult.Type.SKIPPED;
 import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.AggregatedTestResult.Type.SUCCESS;
 
+import java.io.IOException;
 import java.io.Writer;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -38,6 +40,7 @@ import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
@@ -70,6 +73,15 @@ class XmlReportWriter {
 
 	static final char ILLEGAL_CHARACTER_REPLACEMENT = '\uFFFD';
 
+	private static final Map<Character, String> REPLACEMENTS_IN_ATTRIBUTE_VALUES;
+	static {
+		Map<Character, String> tmp = new HashMap<>(3);
+		tmp.put('\n', "&#10;");
+		tmp.put('\r', "&#13;");
+		tmp.put('\t', "&#9;");
+		REPLACEMENTS_IN_ATTRIBUTE_VALUES = unmodifiableMap(tmp);
+	}
+
 	// Using zero-width assertions in the split pattern simplifies the splitting process: All split parts
 	// (including the first and last one) can be used directly, without having to re-add separator characters.
 	private static final Pattern CDATA_SPLIT_PATTERN = Pattern.compile("(?<=]])(?=>)");
@@ -103,239 +115,265 @@ class XmlReportWriter {
 	private void writeXmlReport(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests,
 			Writer out) throws XMLStreamException {
 
-		XMLOutputFactory factory = XMLOutputFactory.newInstance();
-		XMLStreamWriter xmlWriter = factory.createXMLStreamWriter(out);
-		xmlWriter.writeStartDocument("UTF-8", "1.0");
-		newLine(xmlWriter);
-		writeTestsuite(testIdentifier, tests, xmlWriter);
-		xmlWriter.writeEndDocument();
-		xmlWriter.flush();
-		xmlWriter.close();
+		new XmlReport(out).write(testIdentifier, tests);
 	}
 
-	private void writeTestsuite(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests,
-			XMLStreamWriter writer) throws XMLStreamException {
+	class XmlReport implements AutoCloseable {
 
-		// NumberFormat is not thread-safe. Thus, we instantiate it here and pass it to
-		// writeTestcase instead of using a constant
-		NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
+		private final XMLStreamWriter xml;
+		private final ReplacingWriter out;
 
-		writer.writeStartElement("testsuite");
+		XmlReport(Writer out) throws XMLStreamException {
+			this.out = new ReplacingWriter(out);
+			XMLOutputFactory factory = XMLOutputFactory.newInstance();
+			this.xml = factory.createXMLStreamWriter(this.out);
+		}
 
-		writeSuiteAttributes(testIdentifier, tests.values(), numberFormat, writer);
+		void write(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests)
+				throws XMLStreamException {
+			xml.writeStartDocument("UTF-8", "1.0");
+			newLine();
+			writeTestsuite(testIdentifier, tests);
+			xml.writeEndDocument();
+		}
 
-		newLine(writer);
-		writeSystemProperties(writer);
+		private void writeTestsuite(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests)
+				throws XMLStreamException {
 
-		for (Entry<TestIdentifier, AggregatedTestResult> entry : tests.entrySet()) {
-			writeTestcase(entry.getKey(), entry.getValue(), numberFormat, writer);
-		}
+			// NumberFormat is not thread-safe. Thus, we instantiate it here and pass it to
+			// writeTestcase instead of using a constant
+			NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
 
-		writeOutputElement("system-out", formatNonStandardAttributesAsString(testIdentifier), writer);
+			xml.writeStartElement("testsuite");
 
-		writer.writeEndElement();
-		newLine(writer);
-	}
+			writeSuiteAttributes(testIdentifier, tests.values(), numberFormat);
 
-	private void writeSuiteAttributes(TestIdentifier testIdentifier, Collection<AggregatedTestResult> testResults,
-			NumberFormat numberFormat, XMLStreamWriter writer) throws XMLStreamException {
+			newLine();
+			writeSystemProperties();
 
-		writeAttributeSafely(writer, "name", testIdentifier.getDisplayName());
-		writeTestCounts(testResults, writer);
-		writeAttributeSafely(writer, "time", getTime(testIdentifier, numberFormat));
-		writeAttributeSafely(writer, "hostname", getHostname().orElse("<unknown host>"));
-		writeAttributeSafely(writer, "timestamp", ISO_LOCAL_DATE_TIME.format(getCurrentDateTime()));
-	}
+			for (Entry<TestIdentifier, AggregatedTestResult> entry : tests.entrySet()) {
+				writeTestcase(entry.getKey(), entry.getValue(), numberFormat);
+			}
 
-	private void writeTestCounts(Collection<AggregatedTestResult> testResults, XMLStreamWriter writer)
-			throws XMLStreamException {
-		Map<Type, Long> counts = testResults.stream().map(it -> it.type).collect(groupingBy(identity(), counting()));
-		long total = counts.values().stream().mapToLong(Long::longValue).sum();
-		writeAttributeSafely(writer, "tests", String.valueOf(total));
-		writeAttributeSafely(writer, "skipped", counts.getOrDefault(SKIPPED, 0L).toString());
-		writeAttributeSafely(writer, "failures", counts.getOrDefault(FAILURE, 0L).toString());
-		writeAttributeSafely(writer, "errors", counts.getOrDefault(ERROR, 0L).toString());
-	}
+			writeOutputElement("system-out", formatNonStandardAttributesAsString(testIdentifier));
 
-	private void writeSystemProperties(XMLStreamWriter writer) throws XMLStreamException {
-		writer.writeStartElement("properties");
-		newLine(writer);
-		Properties systemProperties = System.getProperties();
-		for (String propertyName : new TreeSet<>(systemProperties.stringPropertyNames())) {
-			writer.writeEmptyElement("property");
-			writeAttributeSafely(writer, "name", propertyName);
-			writeAttributeSafely(writer, "value", systemProperties.getProperty(propertyName));
-			newLine(writer);
-		}
-		writer.writeEndElement();
-		newLine(writer);
-	}
+			xml.writeEndElement();
+			newLine();
+		}
 
-	private void writeTestcase(TestIdentifier testIdentifier, AggregatedTestResult testResult,
-			NumberFormat numberFormat, XMLStreamWriter writer) throws XMLStreamException {
+		private void writeSuiteAttributes(TestIdentifier testIdentifier, Collection<AggregatedTestResult> testResults,
+				NumberFormat numberFormat) throws XMLStreamException {
 
-		writer.writeStartElement("testcase");
+			writeAttributeSafely("name", testIdentifier.getDisplayName());
+			writeTestCounts(testResults);
+			writeAttributeSafely("time", getTime(testIdentifier, numberFormat));
+			writeAttributeSafely("hostname", getHostname().orElse("<unknown host>"));
+			writeAttributeSafely("timestamp", ISO_LOCAL_DATE_TIME.format(getCurrentDateTime()));
+		}
 
-		writeAttributeSafely(writer, "name", getName(testIdentifier));
-		writeAttributeSafely(writer, "classname", getClassName(testIdentifier));
-		writeAttributeSafely(writer, "time", getTime(testIdentifier, numberFormat));
-		newLine(writer);
+		private void writeTestCounts(Collection<AggregatedTestResult> testResults) throws XMLStreamException {
+			Map<Type, Long> counts = testResults.stream().map(it -> it.type).collect(
+				groupingBy(identity(), counting()));
+			long total = counts.values().stream().mapToLong(Long::longValue).sum();
+			writeAttributeSafely("tests", String.valueOf(total));
+			writeAttributeSafely("skipped", counts.getOrDefault(SKIPPED, 0L).toString());
+			writeAttributeSafely("failures", counts.getOrDefault(FAILURE, 0L).toString());
+			writeAttributeSafely("errors", counts.getOrDefault(ERROR, 0L).toString());
+		}
 
-		writeSkippedOrErrorOrFailureElement(testIdentifier, testResult, writer);
+		private void writeSystemProperties() throws XMLStreamException {
+			xml.writeStartElement("properties");
+			newLine();
+			Properties systemProperties = System.getProperties();
+			for (String propertyName : new TreeSet<>(systemProperties.stringPropertyNames())) {
+				xml.writeEmptyElement("property");
+				writeAttributeSafely("name", propertyName);
+				writeAttributeSafely("value", systemProperties.getProperty(propertyName));
+				newLine();
+			}
+			xml.writeEndElement();
+			newLine();
+		}
 
-		List<String> systemOutElements = new ArrayList<>();
-		List<String> systemErrElements = new ArrayList<>();
-		systemOutElements.add(formatNonStandardAttributesAsString(testIdentifier));
-		collectReportEntries(testIdentifier, systemOutElements, systemErrElements);
-		writeOutputElements("system-out", systemOutElements, writer);
-		writeOutputElements("system-err", systemErrElements, writer);
+		private void writeTestcase(TestIdentifier testIdentifier, AggregatedTestResult testResult,
+				NumberFormat numberFormat) throws XMLStreamException {
 
-		writer.writeEndElement();
-		newLine(writer);
-	}
+			xml.writeStartElement("testcase");
 
-	private String getName(TestIdentifier testIdentifier) {
-		return testIdentifier.getLegacyReportingName();
-	}
+			writeAttributeSafely("name", getName(testIdentifier));
+			writeAttributeSafely("classname", getClassName(testIdentifier));
+			writeAttributeSafely("time", getTime(testIdentifier, numberFormat));
+			newLine();
 
-	private String getClassName(TestIdentifier testIdentifier) {
-		return LegacyReportingUtils.getClassName(this.reportData.getTestPlan(), testIdentifier);
-	}
+			writeSkippedOrErrorOrFailureElement(testIdentifier, testResult);
+
+			List<String> systemOutElements = new ArrayList<>();
+			List<String> systemErrElements = new ArrayList<>();
+			systemOutElements.add(formatNonStandardAttributesAsString(testIdentifier));
+			collectReportEntries(testIdentifier, systemOutElements, systemErrElements);
+			writeOutputElements("system-out", systemOutElements);
+			writeOutputElements("system-err", systemErrElements);
+
+			xml.writeEndElement();
+			newLine();
+		}
 
-	private void writeSkippedOrErrorOrFailureElement(TestIdentifier testIdentifier, AggregatedTestResult testResult,
-			XMLStreamWriter writer) throws XMLStreamException {
+		private String getName(TestIdentifier testIdentifier) {
+			return testIdentifier.getLegacyReportingName();
+		}
 
-		if (testResult.type == SKIPPED) {
-			writeSkippedElement(this.reportData.getSkipReason(testIdentifier), writer);
+		private String getClassName(TestIdentifier testIdentifier) {
+			return LegacyReportingUtils.getClassName(reportData.getTestPlan(), testIdentifier);
 		}
-		else {
-			Map<Type, List<Optional<Throwable>>> throwablesByType = testResult.getThrowablesByType();
-			for (Type type : EnumSet.of(FAILURE, ERROR)) {
-				for (Optional<Throwable> throwable : throwablesByType.getOrDefault(type, emptyList())) {
-					writeErrorOrFailureElement(type, throwable.orElse(null), writer);
+
+		private void writeSkippedOrErrorOrFailureElement(TestIdentifier testIdentifier, AggregatedTestResult testResult)
+				throws XMLStreamException {
+
+			if (testResult.type == SKIPPED) {
+				writeSkippedElement(reportData.getSkipReason(testIdentifier), xml);
+			}
+			else {
+				Map<Type, List<Optional<Throwable>>> throwablesByType = testResult.getThrowablesByType();
+				for (Type type : EnumSet.of(FAILURE, ERROR)) {
+					for (Optional<Throwable> throwable : throwablesByType.getOrDefault(type, emptyList())) {
+						writeErrorOrFailureElement(type, throwable.orElse(null), xml);
+					}
 				}
 			}
 		}
-	}
 
-	private void writeSkippedElement(String reason, XMLStreamWriter writer) throws XMLStreamException {
-		if (isNotBlank(reason)) {
-			writer.writeStartElement("skipped");
-			writeCDataSafely(writer, reason);
-			writer.writeEndElement();
-		}
-		else {
-			writer.writeEmptyElement("skipped");
+		private void writeSkippedElement(String reason, XMLStreamWriter writer) throws XMLStreamException {
+			if (isNotBlank(reason)) {
+				writer.writeStartElement("skipped");
+				writeCDataSafely(reason);
+				writer.writeEndElement();
+			}
+			else {
+				writer.writeEmptyElement("skipped");
+			}
+			newLine();
 		}
-		newLine(writer);
-	}
 
-	private void writeErrorOrFailureElement(Type type, Throwable throwable, XMLStreamWriter writer)
-			throws XMLStreamException {
+		private void writeErrorOrFailureElement(Type type, Throwable throwable, XMLStreamWriter writer)
+				throws XMLStreamException {
 
-		String elementName = type == FAILURE ? "failure" : "error";
-		if (throwable != null) {
-			writer.writeStartElement(elementName);
-			writeFailureAttributesAndContent(throwable, writer);
-			writer.writeEndElement();
-		}
-		else {
-			writer.writeEmptyElement(elementName);
+			String elementName = type == FAILURE ? "failure" : "error";
+			if (throwable != null) {
+				writer.writeStartElement(elementName);
+				writeFailureAttributesAndContent(throwable);
+				writer.writeEndElement();
+			}
+			else {
+				writer.writeEmptyElement(elementName);
+			}
+			newLine();
 		}
-		newLine(writer);
-	}
 
-	private void writeFailureAttributesAndContent(Throwable throwable, XMLStreamWriter writer)
-			throws XMLStreamException {
+		private void writeFailureAttributesAndContent(Throwable throwable) throws XMLStreamException {
 
-		if (throwable.getMessage() != null) {
-			writeAttributeSafely(writer, "message", throwable.getMessage());
+			if (throwable.getMessage() != null) {
+				writeAttributeSafely("message", throwable.getMessage());
+			}
+			writeAttributeSafely("type", throwable.getClass().getName());
+			writeCDataSafely(readStackTrace(throwable));
 		}
-		writeAttributeSafely(writer, "type", throwable.getClass().getName());
-		writeCDataSafely(writer, readStackTrace(throwable));
-	}
 
-	private void collectReportEntries(TestIdentifier testIdentifier, List<String> systemOutElements,
-			List<String> systemErrElements) {
-		List<ReportEntry> entries = this.reportData.getReportEntries(testIdentifier);
-		if (!entries.isEmpty()) {
-			List<String> systemOutElementsForCapturedOutput = new ArrayList<>();
-			StringBuilder formattedReportEntries = new StringBuilder();
-			for (int i = 0; i < entries.size(); i++) {
-				ReportEntry reportEntry = entries.get(i);
-				Map<String, String> keyValuePairs = new LinkedHashMap<>(reportEntry.getKeyValuePairs());
-				removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDOUT_REPORT_ENTRY_KEY,
-					systemOutElementsForCapturedOutput);
-				removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDERR_REPORT_ENTRY_KEY, systemErrElements);
-				if (!keyValuePairs.isEmpty()) {
-					buildReportEntryDescription(reportEntry.getTimestamp(), keyValuePairs, i + 1,
-						formattedReportEntries);
+		private void collectReportEntries(TestIdentifier testIdentifier, List<String> systemOutElements,
+				List<String> systemErrElements) {
+			List<ReportEntry> entries = reportData.getReportEntries(testIdentifier);
+			if (!entries.isEmpty()) {
+				List<String> systemOutElementsForCapturedOutput = new ArrayList<>();
+				StringBuilder formattedReportEntries = new StringBuilder();
+				for (int i = 0; i < entries.size(); i++) {
+					ReportEntry reportEntry = entries.get(i);
+					Map<String, String> keyValuePairs = new LinkedHashMap<>(reportEntry.getKeyValuePairs());
+					removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDOUT_REPORT_ENTRY_KEY,
+						systemOutElementsForCapturedOutput);
+					removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDERR_REPORT_ENTRY_KEY, systemErrElements);
+					if (!keyValuePairs.isEmpty()) {
+						buildReportEntryDescription(reportEntry.getTimestamp(), keyValuePairs, i + 1,
+							formattedReportEntries);
+					}
 				}
+				systemOutElements.add(formattedReportEntries.toString().trim());
+				systemOutElements.addAll(systemOutElementsForCapturedOutput);
 			}
-			systemOutElements.add(formattedReportEntries.toString().trim());
-			systemOutElements.addAll(systemOutElementsForCapturedOutput);
 		}
-	}
 
-	private void removeIfPresentAndAddAsSeparateElement(Map<String, String> keyValuePairs, String key,
-			List<String> elements) {
-		String value = keyValuePairs.remove(key);
-		if (value != null) {
-			elements.add(value);
+		private void removeIfPresentAndAddAsSeparateElement(Map<String, String> keyValuePairs, String key,
+				List<String> elements) {
+			String value = keyValuePairs.remove(key);
+			if (value != null) {
+				elements.add(value);
+			}
 		}
-	}
 
-	private void buildReportEntryDescription(LocalDateTime timestamp, Map<String, String> keyValuePairs,
-			int entryNumber, StringBuilder result) {
-		result.append(
-			format("Report Entry #{0} (timestamp: {1})\n", entryNumber, ISO_LOCAL_DATE_TIME.format(timestamp)));
-		keyValuePairs.forEach((key, value) -> result.append(format("\t- {0}: {1}\n", key, value)));
-	}
+		private void buildReportEntryDescription(LocalDateTime timestamp, Map<String, String> keyValuePairs,
+				int entryNumber, StringBuilder result) {
+			result.append(
+				format("Report Entry #{0} (timestamp: {1})\n", entryNumber, ISO_LOCAL_DATE_TIME.format(timestamp)));
+			keyValuePairs.forEach((key, value) -> result.append(format("\t- {0}: {1}\n", key, value)));
+		}
 
-	private String getTime(TestIdentifier testIdentifier, NumberFormat numberFormat) {
-		return numberFormat.format(this.reportData.getDurationInSeconds(testIdentifier));
-	}
+		private String getTime(TestIdentifier testIdentifier, NumberFormat numberFormat) {
+			return numberFormat.format(reportData.getDurationInSeconds(testIdentifier));
+		}
 
-	private Optional<String> getHostname() {
-		try {
-			return Optional.ofNullable(InetAddress.getLocalHost().getHostName());
+		private Optional<String> getHostname() {
+			try {
+				return Optional.ofNullable(InetAddress.getLocalHost().getHostName());
+			}
+			catch (UnknownHostException e) {
+				return Optional.empty();
+			}
 		}
-		catch (UnknownHostException e) {
-			return Optional.empty();
+
+		private LocalDateTime getCurrentDateTime() {
+			return LocalDateTime.now(reportData.getClock()).withNano(0);
 		}
-	}
 
-	private LocalDateTime getCurrentDateTime() {
-		return LocalDateTime.now(this.reportData.getClock()).withNano(0);
-	}
+		private String formatNonStandardAttributesAsString(TestIdentifier testIdentifier) {
+			return "unique-id: " + testIdentifier.getUniqueId() //
+					+ "\ndisplay-name: " + testIdentifier.getDisplayName();
+		}
 
-	private String formatNonStandardAttributesAsString(TestIdentifier testIdentifier) {
-		return "unique-id: " + testIdentifier.getUniqueId() //
-				+ "\ndisplay-name: " + testIdentifier.getDisplayName();
-	}
+		private void writeOutputElements(String elementName, List<String> elements) throws XMLStreamException {
+			for (String content : elements) {
+				writeOutputElement(elementName, content);
+			}
+		}
 
-	private void writeOutputElements(String elementName, List<String> elements, XMLStreamWriter writer)
-			throws XMLStreamException {
-		for (String content : elements) {
-			writeOutputElement(elementName, content, writer);
+		private void writeOutputElement(String elementName, String content) throws XMLStreamException {
+			xml.writeStartElement(elementName);
+			writeCDataSafely("\n" + content + "\n");
+			xml.writeEndElement();
+			newLine();
 		}
-	}
 
-	private void writeOutputElement(String elementName, String content, XMLStreamWriter writer)
-			throws XMLStreamException {
-		writer.writeStartElement(elementName);
-		writeCDataSafely(writer, "\n" + content + "\n");
-		writer.writeEndElement();
-		newLine(writer);
-	}
+		private void writeAttributeSafely(String name, String value) throws XMLStreamException {
+			// Workaround for XMLStreamWriter implementations that don't escape
+			// '\n', '\r', and '\t' characters in attribute values
+			xml.flush();
+			out.setWhitespaceReplacingEnabled(true);
+			xml.writeAttribute(name, replaceIllegalCharacters(value));
+			xml.flush();
+			out.setWhitespaceReplacingEnabled(false);
+		}
 
-	private void writeAttributeSafely(XMLStreamWriter writer, String name, String value) throws XMLStreamException {
-		writer.writeAttribute(name, replaceIllegalCharacters(value));
-	}
+		private void writeCDataSafely(String data) throws XMLStreamException {
+			for (String safeDataPart : CDATA_SPLIT_PATTERN.split(replaceIllegalCharacters(data))) {
+				xml.writeCData(safeDataPart);
+			}
+		}
 
-	private void writeCDataSafely(XMLStreamWriter writer, String data) throws XMLStreamException {
-		for (String safeDataPart : CDATA_SPLIT_PATTERN.split(replaceIllegalCharacters(data))) {
-			writer.writeCData(safeDataPart);
+		private void newLine() throws XMLStreamException {
+			xml.writeCharacters("\n");
+		}
+
+		@Override
+		public void close() throws XMLStreamException {
+			xml.flush();
+			xml.close();
 		}
 	}
 
@@ -365,15 +403,6 @@ class XmlReportWriter {
 				|| (codePoint >= 0x10000 && codePoint <= 0x10FFFF);
 	}
 
-	private void newLine(XMLStreamWriter xmlWriter) throws XMLStreamException {
-		xmlWriter.writeCharacters("\n");
-	}
-
-	private static boolean isFailure(TestExecutionResult result) {
-		Optional<Throwable> throwable = result.getThrowable();
-		return throwable.isPresent() && throwable.get() instanceof AssertionError;
-	}
-
 	static class AggregatedTestResult {
 
 		private static final AggregatedTestResult SKIPPED_RESULT = new AggregatedTestResult(SKIPPED, emptyList());
@@ -413,6 +442,125 @@ class XmlReportWriter {
 				}
 				return SUCCESS;
 			}
+
+			private static boolean isFailure(TestExecutionResult result) {
+				Optional<Throwable> throwable = result.getThrowable();
+				return throwable.isPresent() && throwable.get() instanceof AssertionError;
+			}
+		}
+	}
+
+	private static class ReplacingWriter extends Writer {
+
+		private final Writer delegate;
+		private boolean whitespaceReplacingEnabled;
+
+		ReplacingWriter(Writer delegate) {
+			this.delegate = delegate;
+		}
+
+		void setWhitespaceReplacingEnabled(boolean whitespaceReplacingEnabled) {
+			this.whitespaceReplacingEnabled = whitespaceReplacingEnabled;
+		}
+
+		@Override
+		public void write(char[] cbuf, int off, int len) throws IOException {
+			if (!whitespaceReplacingEnabled) {
+				delegate.write(cbuf, off, len);
+				return;
+			}
+			StringBuilder stringBuilder = new StringBuilder(len * 2);
+			for (int i = off; i < off + len; i++) {
+				char c = cbuf[i];
+				String replacement = REPLACEMENTS_IN_ATTRIBUTE_VALUES.get(c);
+				if (replacement != null) {
+					stringBuilder.append(replacement);
+				}
+				else {
+					stringBuilder.append(c);
+				}
+			}
+			delegate.write(stringBuilder.toString());
+		}
+
+		@Override
+		public void write(int c) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				super.write(c);
+			}
+			else {
+				delegate.write(c);
+			}
+		}
+
+		@Override
+		public void write(char[] cbuf) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				super.write(cbuf);
+			}
+			else {
+				delegate.write(cbuf);
+			}
+		}
+
+		@Override
+		public void write(String str) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				super.write(str);
+			}
+			else {
+				delegate.write(str);
+			}
+		}
+
+		@Override
+		public void write(String str, int off, int len) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				super.write(str, off, len);
+			}
+			else {
+				delegate.write(str, off, len);
+			}
+		}
+
+		@Override
+		public Writer append(CharSequence csq) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				return super.append(csq);
+			}
+			else {
+				return delegate.append(csq);
+			}
+		}
+
+		@Override
+		public Writer append(CharSequence csq, int start, int end) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				return super.append(csq, start, end);
+			}
+			else {
+				return delegate.append(csq, start, end);
+			}
+		}
+
+		@Override
+		public Writer append(char c) throws IOException {
+			if (whitespaceReplacingEnabled) {
+				return super.append(c);
+			}
+			else {
+				return delegate.append(c);
+			}
+		}
+
+		@Override
+		public void flush() throws IOException {
+			delegate.flush();
+		}
+
+		@Override
+		public void close() throws IOException {
+			delegate.close();
 		}
 	}
 
