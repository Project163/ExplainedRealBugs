diff --git a/buildSrc/src/main/kotlin/Versions.kt b/buildSrc/src/main/kotlin/Versions.kt
index b6d887f9f..1b86969d1 100644
--- a/buildSrc/src/main/kotlin/Versions.kt
+++ b/buildSrc/src/main/kotlin/Versions.kt
@@ -20,6 +20,7 @@ object Versions {
     val classgraph = "4.4.12"
     val commonsIo = "2.6"
     val javaCompilerScriptEngine = "0.1.2"
+    val jimfs = "1.1"
     val log4j = "2.11.1"
     val mockito = "2.23.0"
     val slf4j = "1.7.25"
diff --git a/documentation/documentation.gradle.kts b/documentation/documentation.gradle.kts
index 0c417b6fb..dd793b732 100644
--- a/documentation/documentation.gradle.kts
+++ b/documentation/documentation.gradle.kts
@@ -33,6 +33,9 @@ dependencies {
 	testImplementation(project(":junit-platform-launcher"))
 	testImplementation(project(":junit-platform-reporting"))
 	testImplementation("org.jetbrains.kotlin:kotlin-stdlib")
+	testImplementation("com.google.jimfs:jimfs:${Versions.jimfs}") {
+		because("used to demo TempDirectory extension")
+	}
 
 	// Required by :consoleLauncherTest and :generateConsoleLauncherOptions
 	testRuntimeOnly(project(":junit-platform-console"))
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
index e05169000..612eaacaa 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
@@ -75,6 +75,8 @@ repository on GitHub.
   to ease getting started with JUnit Jupiter. It contains the compile/api dependencies to
   `junit-jupiter-api` and `junit-jupiter-params` and also the runtime dependency to
   `junit-jupiter-engine`.
+* New `TempDirectory` extension (formerly part of JUnit Pioneer) that allows to write test
+  that require a temporary directory in a `java.nio.file.FileSystem`.
 * `Assertions.assertEquals()` variants that compare floating point numbers using a delta
   now support a _delta_ of zero.
 * New `Assertions.assertEquals()` variants that accept mixed boxed and unboxed primitive
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index fc1071863..875ea5d1a 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1498,3 +1498,42 @@ to the same shared resource is running.
 ----
 include::{testDir}/example/SharedResourcesDemo.java[tags=user_guide]
 ----
+
+
+[[writing-tests-built-in-extensions]]
+=== Built-in Extensions
+
+While the JUnit team encourages reusable extensions to be packaged and maintained in
+separate libraries, the JUnit Jupiter API artifact includes a few user-facing extension
+implementations that are considered so generally useful that users shouldn't have to add
+another dependency.
+
+[[writing-tests-built-in-extensions-TempDirectory]]
+==== The TempDirectory Extension
+
+The `TempDirectory` extension can be used to create and clean up a temporary directory for
+an individual test or all tests in a test class. To use it, simply register the extension
+and add a parameter of type `java.nio.file.Path` annotated with `@TempDir` to your test,
+lifecycle method, or test class constructor.
+
+For example, the following test registers the extension for a single test method, creates
+and writes a file to the temporary directory and checks its content.
+
+[source,java,indent=0]
+.A test method that requires a temporary directory
+----
+include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide]
+----
+
+In addition to the default file system, the extension can be used with any `FileSystem`
+implementation, e.g. https://github.com/google/jimfs[Jimfs]. In order to use a custom file
+system, simply register the extension programmatically and pass a provider of a custom
+parent directory of type `Path`. The following example uses the Jimfs `FileSystem` and
+passes a custom `tmp` parent directory to the `createInCustomDirectory` static factory
+method.
+
+[source,java]
+.A test class that sets up the TempDirectory extension to use a custom file system
+----
+include::{testDir}/example/TempDirectoryWithCustomFileSystemDemo.java[tags=user_guide]
+----
diff --git a/documentation/src/main/java/example/util/ListWriter.java b/documentation/src/main/java/example/util/ListWriter.java
new file mode 100644
index 000000000..0abf88c96
--- /dev/null
+++ b/documentation/src/main/java/example/util/ListWriter.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example.util;
+
+import static java.util.Collections.singletonList;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+public class ListWriter {
+
+	private final Path file;
+
+	public ListWriter(Path file) {
+		this.file = file;
+	}
+
+	public void write(String... items) throws IOException {
+		Files.write(file, singletonList(String.join(",", items)));
+	}
+
+}
diff --git a/documentation/src/test/java/example/TempDirectoryDemo.java b/documentation/src/test/java/example/TempDirectoryDemo.java
new file mode 100644
index 000000000..a2f7a81ad
--- /dev/null
+++ b/documentation/src/test/java/example/TempDirectoryDemo.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example;
+
+import static java.util.Collections.singletonList;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import example.util.ListWriter;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.support.io.TempDirectory;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
+
+class TempDirectoryDemo {
+
+	// tag::user_guide[]
+	@Test
+	@ExtendWith(TempDirectory.class)
+	void writesItemsToFile(@TempDir Path tempDir) throws IOException {
+		Path file = tempDir.resolve("test.txt");
+
+		new ListWriter(file).write("a", "b", "c");
+
+		assertEquals(singletonList("a,b,c"), Files.readAllLines(file));
+	}
+	// end::user_guide[]
+
+}
diff --git a/documentation/src/test/java/example/TempDirectoryWithCustomFileSystemDemo.java b/documentation/src/test/java/example/TempDirectoryWithCustomFileSystemDemo.java
new file mode 100644
index 000000000..cc8aefe00
--- /dev/null
+++ b/documentation/src/test/java/example/TempDirectoryWithCustomFileSystemDemo.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example;
+
+import static java.util.Collections.singletonList;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import com.google.common.jimfs.Configuration;
+import com.google.common.jimfs.Jimfs;
+
+import example.util.ListWriter;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.junit.jupiter.api.support.io.TempDirectory;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
+
+// tag::user_guide[]
+class TempDirectoryWithCustomFileSystemDemo {
+
+	private static FileSystem fileSystem;
+
+	@BeforeAll
+	static void createFileSystem() {
+		fileSystem = Jimfs.newFileSystem(Configuration.unix());
+	}
+
+	@AfterAll
+	static void closeFileSystem() throws Exception {
+		fileSystem.close();
+	}
+
+	@RegisterExtension
+	Extension tempDirectory = TempDirectory.createInCustomDirectory(() -> fileSystem.getPath("/"));
+
+	@Test
+	void writesItemsToFile(@TempDir Path tempDir) throws IOException {
+		Path file = tempDir.resolve("test.txt");
+
+		new ListWriter(file).write("a", "b", "c");
+
+		assertEquals(singletonList("a,b,c"), Files.readAllLines(file));
+	}
+
+}
+// end::user_guide[]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/support/io/TempDirectory.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/support/io/TempDirectory.java
new file mode 100644
index 000000000..c8c7f7c1c
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/support/io/TempDirectory.java
@@ -0,0 +1,332 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.support.io;
+
+import static java.nio.file.FileVisitResult.CONTINUE;
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.joining;
+
+import java.io.IOException;
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.concurrent.Callable;
+
+import org.junit.jupiter.api.extension.ExtensionConfigurationException;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
+import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.ParameterResolver;
+
+/**
+ * {@code TempDirectory} is a JUnit Jupiter extension to create and clean up a
+ * temporary directory.
+ *
+ * <p>The temporary directory is only created if a test or lifecycle method or
+ * test class constructor has a parameter annotated with
+ * {@link TempDir @TempDir}. If the parameter type is not {@link Path} or if the
+ * temporary directory could not be created, this extension will throw a
+ * {@link ParameterResolutionException}.
+ *
+ * <p>The scope of the temporary directory depends on where the first
+ * {@link TempDir @TempDir} annotation is encountered when executing a test
+ * class. The temporary directory will be shared by all tests in a class when
+ * the annotation is present on a parameter of a
+ * {@link org.junit.jupiter.api.BeforeAll @BeforeAll} method or the test class
+ * constructor. Otherwise, e.g. when only used on test or
+ * {@link org.junit.jupiter.api.BeforeEach @BeforeEach} or
+ * {@link org.junit.jupiter.api.AfterEach @AfterEach} methods, each test will
+ * use its own temporary directory.
+ *
+ * <p>When the end of the scope of a temporary directory is reached, i.e. when
+ * the test method or class has finished execution, this extension will attempt
+ * to recursively delete all files and directories in the temporary directory
+ * and, finally, the temporary directory itself. In case deletion of a file or
+ * directory fails, this extension will throw an {@link IOException} that will
+ * cause the test to fail.
+ *
+ * <p>By default, this extension will use the default
+ * {@link java.nio.file.FileSystem FileSystem} to create temporary directories
+ * in the default location. However, you may instantiate this extension using
+ * the {@link TempDirectory#createInCustomDirectory(ParentDirProvider)}
+ * or {@link TempDirectory#createInCustomDirectory(Callable)}} factory methods
+ * and register it via {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension}
+ * to pass a custom provider to configure the parent directory for all temporary
+ * directories created by this extension. This allows the use of this extension
+ * with any third-party {@code FileSystem} implementation, e.g.
+ * <a href="https://github.com/google/jimfs">Jimfs</a>.
+ *
+ * @since 0.1
+ * @see TempDir
+ * @see ParentDirProvider
+ * @see Files#createTempDirectory
+ */
+public class TempDirectory implements ParameterResolver {
+
+	/**
+	 * {@code TempDir} can be used to annotate a test or lifecycle method or
+	 * test class constructor parameter of type {@link Path} that should be
+	 * resolved into a temporary directory.
+	 *
+	 * @see TempDirectory
+	 */
+	@Target(ElementType.PARAMETER)
+	@Retention(RetentionPolicy.RUNTIME)
+	@Documented
+	public @interface TempDir {
+	}
+
+	/**
+	 * {@code ParentDirProvider} can be used to configure a custom parent
+	 * directory for all temporary directories created by the
+	 * {@link TempDirectory} extension this is used with.
+	 *
+	 * @see org.junit.jupiter.api.extension.RegisterExtension
+	 * @see TempDirectory#createInCustomDirectory(ParentDirProvider)
+	 */
+	@FunctionalInterface
+	public interface ParentDirProvider {
+		/**
+		 * Get the parent directory for all temporary directories created by the
+		 * {@link TempDirectory} extension this is used with.
+		 *
+		 * @return the parent directory for all temporary directories
+		 */
+		Path get(ParameterContext parameterContext, ExtensionContext extensionContext) throws Exception;
+	}
+
+	/**
+	 * {@code TempDirProvider} is used internally to define how the temporary
+	 * directory is created.
+	 *
+	 * <p>The temporary directory is by default created on the regular
+	 * file system, but the user can also provide a custom file system
+	 * by using the {@link ParentDirProvider}. An instance of
+	 * {@code TempDirProvider} executes these (and possibly other) strategies.
+	 *
+	 * @see TempDirectory.ParentDirProvider
+	 */
+	@FunctionalInterface
+	private interface TempDirProvider {
+		CloseablePath get(ParameterContext parameterContext, ExtensionContext extensionContext, String dirPrefix);
+	}
+
+	private static final Namespace NAMESPACE = Namespace.create(TempDirectory.class);
+	private static final String KEY = "temp.dir";
+	private static final String TEMP_DIR_PREFIX = "junit";
+
+	private final TempDirProvider tempDirProvider;
+
+	private TempDirectory(TempDirProvider tempDirProvider) {
+		this.tempDirProvider = requireNonNull(tempDirProvider);
+	}
+
+	/**
+	 * Create a new {@code TempDirectory} extension that uses the default
+	 * {@link java.nio.file.FileSystem FileSystem} and creates temporary
+	 * directories in the default location.
+	 *
+	 * <p>This constructor is used by the JUnit Jupiter Engine when the
+	 * extension is registered via
+	 * {@link org.junit.jupiter.api.extension.ExtendWith @ExtendWith}.
+	 */
+	public TempDirectory() {
+		this((__, ___, dirPrefix) -> createDefaultTempDir(dirPrefix));
+	}
+
+	/**
+	 * Returns a {@code TempDirectory} extension that uses the default
+	 * {@link java.nio.file.FileSystem FileSystem} and creates temporary
+	 * directories in the default location.
+	 *
+	 * <p>You may use this factory method when registering this extension via
+	 * {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension},
+	 * although you might prefer the simpler registration via
+	 * {@link org.junit.jupiter.api.extension.ExtendWith @ExtendWith}.
+	 *
+	 * @return a {@code TempDirectory} extension
+	 */
+	public static TempDirectory createInDefaultDirectory() {
+		return new TempDirectory();
+	}
+
+	/**
+	 * Returns a {@code TempDirectory} extension that uses the supplied
+	 * {@link ParentDirProvider} to configure the parent directory for the
+	 * temporary directories created by this extension.
+	 *
+	 * <p>You may use this factory method when registering this extension via
+	 * {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension}.
+	 *
+	 * @param parentDirProvider used to configure the parent directory for the
+	 * temporary directories created by this extension
+	 */
+	public static TempDirectory createInCustomDirectory(ParentDirProvider parentDirProvider) {
+		requireNonNull(parentDirProvider);
+		// @formatter:off
+		return new TempDirectory((parameterContext, extensionContext, dirPrefix) ->
+				createCustomTempDir(parentDirProvider, parameterContext, extensionContext, dirPrefix));
+		// @formatter:on
+	}
+
+	/**
+	 * Returns a {@code TempDirectory} extension that uses the supplied
+	 * {@link Callable} to configure the parent directory for the temporary
+	 * directories created by this extension.
+	 *
+	 * <p>You may use this factory method when registering this extension via
+	 * {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension}.
+	 *
+	 * @param parentDirProvider used to configure the parent directory for the
+	 * temporary directories created by this extension
+	 */
+	public static TempDirectory createInCustomDirectory(Callable<Path> parentDirProvider) {
+		requireNonNull(parentDirProvider);
+		return createInCustomDirectory((parameterContext, extensionContext) -> parentDirProvider.call());
+	}
+
+	@Override
+	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
+		return parameterContext.isAnnotated(TempDir.class);
+	}
+
+	@Override
+	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
+		Class<?> parameterType = parameterContext.getParameter().getType();
+		if (parameterType != Path.class) {
+			throw new ParameterResolutionException(
+				"Can only resolve parameter of type " + Path.class.getName() + " but was: " + parameterType.getName());
+		}
+		return extensionContext.getStore(NAMESPACE) //
+				.getOrComputeIfAbsent(KEY,
+					key -> tempDirProvider.get(parameterContext, extensionContext, TEMP_DIR_PREFIX),
+					CloseablePath.class) //
+				.get();
+	}
+
+	private static CloseablePath createDefaultTempDir(String dirPrefix) {
+		try {
+			return new CloseablePath(Files.createTempDirectory(dirPrefix));
+		}
+		catch (Exception ex) {
+			throw new ExtensionConfigurationException("Failed to create default temp directory", ex);
+		}
+	}
+
+	private static CloseablePath createCustomTempDir(ParentDirProvider parentDirProvider,
+			ParameterContext parameterContext, ExtensionContext extensionContext, String dirPrefix) {
+		Path parentDir;
+		try {
+			parentDir = parentDirProvider.get(parameterContext, extensionContext);
+			requireNonNull(parentDir);
+		}
+		catch (Exception ex) {
+			throw new ParameterResolutionException("Failed to get parent directory from provider", ex);
+		}
+		try {
+			return new CloseablePath(Files.createTempDirectory(parentDir, dirPrefix));
+		}
+		catch (Exception ex) {
+			throw new ParameterResolutionException("Failed to create custom temp directory", ex);
+		}
+	}
+
+	private static class CloseablePath implements CloseableResource {
+
+		private final Path dir;
+
+		CloseablePath(Path dir) {
+			this.dir = dir;
+		}
+
+		Path get() {
+			return dir;
+		}
+
+		@Override
+		public void close() throws IOException {
+			SortedMap<Path, IOException> failures = deleteAllFilesAndDirectories();
+			if (!failures.isEmpty()) {
+				throw createIOExceptionWithAttachedFailures(failures);
+			}
+		}
+
+		private SortedMap<Path, IOException> deleteAllFilesAndDirectories() throws IOException {
+			SortedMap<Path, IOException> failures = new TreeMap<>();
+			Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {
+
+				@Override
+				public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {
+					return deleteAndContinue(file);
+				}
+
+				@Override
+				public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
+					return deleteAndContinue(dir);
+				}
+
+				private FileVisitResult deleteAndContinue(Path path) {
+					try {
+						Files.delete(path);
+					}
+					catch (IOException ex) {
+						failures.put(path, ex);
+					}
+					return CONTINUE;
+				}
+			});
+			return failures;
+		}
+
+		private IOException createIOExceptionWithAttachedFailures(SortedMap<Path, IOException> failures) {
+			// @formatter:off
+			String joinedPaths = failures.keySet().stream()
+					.peek(this::tryToDeleteOnExit)
+					.map(this::relativizeSafely)
+					.map(String::valueOf)
+					.collect(joining(", "));
+			// @formatter:on
+			IOException exception = new IOException("Failed to delete temp directory " + dir.toAbsolutePath()
+					+ ". The following paths could not be deleted (see suppressed exceptions for details): "
+					+ joinedPaths);
+			failures.values().forEach(exception::addSuppressed);
+			return exception;
+		}
+
+		private void tryToDeleteOnExit(Path path) {
+			try {
+				path.toFile().deleteOnExit();
+			}
+			catch (UnsupportedOperationException ignore) {
+			}
+		}
+
+		private Path relativizeSafely(Path path) {
+			try {
+				return dir.relativize(path);
+			}
+			catch (IllegalArgumentException e) {
+				return path;
+			}
+		}
+	}
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/support/io/package-info.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/support/io/package-info.java
new file mode 100644
index 000000000..ff5def9f7
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/support/io/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * IO-related support classes and built-in extensions
+ */
+
+package org.junit.jupiter.api.support.io;
diff --git a/junit-jupiter-engine/junit-jupiter-engine.gradle.kts b/junit-jupiter-engine/junit-jupiter-engine.gradle.kts
index be6bef990..929dd6c10 100644
--- a/junit-jupiter-engine/junit-jupiter-engine.gradle.kts
+++ b/junit-jupiter-engine/junit-jupiter-engine.gradle.kts
@@ -31,4 +31,7 @@ dependencies {
 	testImplementation(project(":junit-platform-runner"))
 	testImplementation(project(":junit-platform-testkit"))
 	testImplementation("org.jetbrains.kotlin:kotlin-stdlib")
+	testImplementation("com.google.jimfs:jimfs:${Versions.jimfs}") {
+		because("used to test TempDirectory extension")
+	}
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/support/io/TempDirectoryTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/support/io/TempDirectoryTests.java
new file mode 100644
index 000000000..b182f313b
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/support/io/TempDirectoryTests.java
@@ -0,0 +1,477 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.support.io;
+
+import static org.assertj.core.api.Assertions.allOf;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.isA;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.spi.FileSystemProvider;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.LinkedList;
+
+import com.google.common.jimfs.Jimfs;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
+import org.junit.jupiter.api.extension.ExtensionContext.Store;
+import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.platform.testkit.engine.EngineExecutionResults;
+
+@DisplayName("TempDirectory extension")
+class TempDirectoryTests extends AbstractJupiterTestEngineTests {
+
+	@BeforeEach
+	@AfterEach
+	void resetStaticVariables() {
+		BaseSharedTempDirTestCase.tempDir = null;
+		BaseSeparateTempDirsTestCase.tempDirs.clear();
+	}
+
+	@Nested
+	@DisplayName("resolves shared temp dir")
+	class SharedTempDir {
+
+		@Test
+		@DisplayName("when @TempDir is used on constructor parameter")
+		void resolvesSharedTempDirWhenAnnotationIsUsedOnConstructorParameter() {
+			assertResolvesShareTempDir(AnnotationOnConstructorParameterTestCase.class);
+		}
+
+		@Test
+		@DisplayName("when @TempDir is used on @BeforeAll method parameter")
+		void resolvesSharedTempDirWhenAnnotationIsUsedOnBeforeAllMethodParameter() {
+			assertResolvesShareTempDir(AnnotationOnBeforeAllMethodParameterTestCase.class);
+		}
+
+		@Test
+		@DisplayName("when @TempDir is used on constructor parameter with @TestInstance(PER_CLASS)")
+		void resolvesSharedTempDirWhenAnnotationIsUsedOnConstructorParameterWithTestInstancePerClass() {
+			assertResolvesShareTempDir(AnnotationOnConstructorParameterWithTestInstancePerClassTestCase.class);
+		}
+
+		@Test
+		@DisplayName("when @TempDir is used on @BeforeAll method parameter with @TestInstance(PER_CLASS)")
+		void resolvesSharedTempDirWhenAnnotationIsUsedOnBeforeAllMethodParameterWithTestInstancePerClass() {
+			assertResolvesShareTempDir(AnnotationOnBeforeAllMethodParameterWithTestInstancePerClassTestCase.class);
+		}
+
+		private void assertResolvesShareTempDir(Class<? extends BaseSharedTempDirTestCase> testClass) {
+			var results = executeTests(selectClass(testClass));
+
+			results.tests().assertStatistics(stats -> stats.started(2).failed(0).succeeded(2));
+			assertThat(BaseSharedTempDirTestCase.tempDir).isNotNull().doesNotExist();
+		}
+	}
+
+	@Nested
+	@DisplayName("resolves separate temp dirs")
+	class SeparateTempDirs {
+
+		@Test
+		@DisplayName("for @AfterAll method parameter when @TempDir is not used on constructor or @BeforeAll method parameter")
+		void resolvesSeparateTempDirWhenAnnotationIsUsedOnAfterAllMethodParameterOnly() {
+			var results = executeTests(selectClass(AnnotationOnAfterAllMethodParameterTestCase.class));
+
+			results.tests().assertStatistics(stats -> stats.started(1).failed(0).succeeded(1));
+			assertThat(AnnotationOnAfterAllMethodParameterTestCase.firstTempDir).isNotNull().doesNotExist();
+			assertThat(AnnotationOnAfterAllMethodParameterTestCase.secondTempDir).isNotNull().doesNotExist();
+		}
+
+		@Test
+		@DisplayName("when @TempDir is used on @BeforeEach/@AfterEach method parameters")
+		void resolvesSeparateTempDirsWhenUsedOnForEachLifecycleMethods() {
+			assertResolvesSeparateTempDirs(SeparateTempDirsWhenUsedOnForEachLifecycleMethodsTestCase.class);
+			assertThat(BaseSeparateTempDirsTestCase.tempDirs.getFirst()).doesNotExist();
+			assertThat(BaseSeparateTempDirsTestCase.tempDirs.getLast()).doesNotExist();
+		}
+
+		@Test
+		@DisplayName("when @TempDir is used on @BeforeEach/@AfterEach method parameters with @TestInstance(PER_CLASS)")
+		void resolvesSeparateTempDirsWhenUsedOnForEachLifecycleMethodsWithTestInstancePerClass() {
+			assertResolvesSeparateTempDirs(
+				SeparateTempDirsWhenUsedOnForEachLifecycleMethodsWithTestInstancePerClassTestCase.class);
+			assertThat(BaseSeparateTempDirsTestCase.tempDirs.getFirst()).doesNotExist();
+			assertThat(BaseSeparateTempDirsTestCase.tempDirs.getLast()).doesNotExist();
+		}
+	}
+
+	@Nested
+	@DisplayName("resolves temp dir with custom parent dir")
+	class WithCustomParentDir {
+		@Test
+		@DisplayName("from Callable<Path>")
+		void resolvesTempDirWithCustomParentDirFromCallable() {
+			assertResolvesSeparateTempDirs(ParentDirFromCallableTestCase.class);
+		}
+
+		@Test
+		@DisplayName("from ParentDirProvider")
+		void resolvesTempDirWithCustomParentDirFromProvider() {
+			assertResolvesSeparateTempDirs(ParentDirFromProviderTestCase.class);
+		}
+	}
+
+	@Nested
+	@DisplayName("reports failure")
+	class Failures {
+
+		@Test
+		@DisplayName("when @TempDir is used on parameter of wrong type")
+		void onlySupportsParametersOfTypePath() {
+			var results = executeTests(selectClass(InvalidTestCase.class));
+
+			assertSingleFailedTest(results, ParameterResolutionException.class,
+				"Can only resolve parameter of type java.nio.file.Path");
+		}
+
+		@Test
+		@DisplayName("when attempt to create temp dir fails")
+		void failedCreationAttemptMakesTestFail() {
+			var results = executeTests(selectClass(FailedCreationAttemptTestCase.class));
+
+			assertSingleFailedTest(results, ParameterResolutionException.class,
+				"Failed to create custom temp directory");
+		}
+
+		@Test
+		@DisplayName("when attempt to delete temp dir fails")
+		void failedDeletionAttemptMakesTestFail() {
+			var results = executeTests(selectClass(FailedDeletionAttemptTestCase.class));
+
+			assertSingleFailedTest(results, IOException.class, "Failed to delete temp directory");
+		}
+
+		@Test
+		@DisplayName("when attempt to get parent dir from ParentDirProvider fails")
+		void erroneousParentDirProviderMakesTestFail() {
+			var results = executeTests(selectClass(ErroneousParentDirProviderTestCase.class));
+
+			assertSingleFailedTest(results, ParameterResolutionException.class, "Failed to get parent directory");
+		}
+
+		private void assertSingleFailedTest(EngineExecutionResults results, Class<? extends Throwable> clazz,
+				String message) {
+			results.tests().assertStatistics(stats -> stats.started(1).failed(1).succeeded(0));
+			results.tests().assertThatEvents().haveExactly(1,
+				finishedWithFailure(allOf(isA(clazz), message(actual -> actual.contains(message)))));
+		}
+	}
+
+	private void assertResolvesSeparateTempDirs(Class<? extends BaseSeparateTempDirsTestCase> testClass) {
+		var results = executeTests(selectClass(testClass));
+
+		results.tests().assertStatistics(stats -> stats.started(2).failed(0).succeeded(2));
+		Deque<Path> tempDirs = BaseSeparateTempDirsTestCase.tempDirs;
+		assertThat(tempDirs).hasSize(2);
+	}
+
+	@ExtendWith(TempDirectory.class)
+	static class BaseSharedTempDirTestCase {
+		static Path tempDir;
+
+		@BeforeEach
+		void beforeEach(@TempDir Path tempDir) {
+			check(tempDir);
+		}
+
+		@Test
+		void test1(@TempDir Path tempDir, TestInfo testInfo) throws Exception {
+			check(tempDir);
+			writeFile(tempDir, testInfo);
+		}
+
+		@Test
+		void test2(TestInfo testInfo, @TempDir Path tempDir) throws Exception {
+			check(tempDir);
+			writeFile(tempDir, testInfo);
+		}
+
+		@AfterEach
+		void afterEach(@TempDir Path tempDir) {
+			check(tempDir);
+		}
+
+		static void check(Path tempDir) {
+			assertThat(BaseSharedTempDirTestCase.tempDir).isNotNull().isSameAs(tempDir);
+			assertTrue(Files.exists(tempDir));
+		}
+	}
+
+	static class AnnotationOnConstructorParameterTestCase extends BaseSharedTempDirTestCase {
+		AnnotationOnConstructorParameterTestCase(@TempDir Path tempDir) {
+			if (BaseSharedTempDirTestCase.tempDir != null) {
+				assertSame(BaseSharedTempDirTestCase.tempDir, tempDir);
+			}
+			else {
+				BaseSharedTempDirTestCase.tempDir = tempDir;
+			}
+			check(tempDir);
+		}
+	}
+
+	static class AnnotationOnBeforeAllMethodParameterTestCase extends BaseSharedTempDirTestCase {
+		@BeforeAll
+		static void beforeAll(@TempDir Path tempDir) {
+			assertThat(BaseSharedTempDirTestCase.tempDir).isNull();
+			BaseSharedTempDirTestCase.tempDir = tempDir;
+			check(tempDir);
+		}
+	}
+
+	@TestInstance(PER_CLASS)
+	static class AnnotationOnConstructorParameterWithTestInstancePerClassTestCase
+			extends AnnotationOnConstructorParameterTestCase {
+		AnnotationOnConstructorParameterWithTestInstancePerClassTestCase(@TempDir Path tempDir) {
+			super(tempDir);
+		}
+	}
+
+	@TestInstance(PER_CLASS)
+	static class AnnotationOnBeforeAllMethodParameterWithTestInstancePerClassTestCase
+			extends AnnotationOnBeforeAllMethodParameterTestCase {
+	}
+
+	@ExtendWith(TempDirectory.class)
+	static class AnnotationOnAfterAllMethodParameterTestCase {
+		static Path firstTempDir = null;
+		static Path secondTempDir = null;
+
+		@Test
+		void test(@TempDir Path tempDir, TestInfo testInfo) throws Exception {
+			assertThat(firstTempDir).isNull();
+			firstTempDir = tempDir;
+			writeFile(tempDir, testInfo);
+		}
+
+		@AfterAll
+		static void afterAll(@TempDir Path tempDir) {
+			assertThat(firstTempDir).isNotNull();
+			assertNotEquals(firstTempDir, tempDir);
+			secondTempDir = tempDir;
+		}
+	}
+
+	static class BaseSeparateTempDirsTestCase {
+		static final Deque<Path> tempDirs = new LinkedList<>();
+
+		@BeforeEach
+		void beforeEach(@TempDir Path tempDir) {
+			for (Path dir : tempDirs) {
+				assertThat(dir).doesNotExist();
+			}
+			assertThat(tempDirs).doesNotContain(tempDir);
+			tempDirs.add(tempDir);
+			check(tempDir);
+		}
+
+		@Test
+		void test1(@TempDir Path tempDir, TestInfo testInfo) throws Exception {
+			check(tempDir);
+			writeFile(tempDir, testInfo);
+		}
+
+		@Test
+		void test2(TestInfo testInfo, @TempDir Path tempDir) throws Exception {
+			check(tempDir);
+			writeFile(tempDir, testInfo);
+		}
+
+		@AfterEach
+		void afterEach(@TempDir Path tempDir) {
+			check(tempDir);
+		}
+
+		void check(@TempDir Path tempDir) {
+			assertSame(tempDirs.getLast(), tempDir);
+			assertTrue(Files.exists(tempDir));
+		}
+	}
+
+	@ExtendWith(TempDirectory.class)
+	static class SeparateTempDirsWhenUsedOnForEachLifecycleMethodsTestCase extends BaseSeparateTempDirsTestCase {
+	}
+
+	@TestInstance(PER_CLASS)
+	static class SeparateTempDirsWhenUsedOnForEachLifecycleMethodsWithTestInstancePerClassTestCase
+			extends SeparateTempDirsWhenUsedOnForEachLifecycleMethodsTestCase {
+	}
+
+	@ExtendWith(TempDirectory.class)
+	static class InvalidTestCase {
+		@Test
+		void wrongParameterType(@SuppressWarnings("unused") @TempDir File ignored) {
+			fail("this should never be called");
+		}
+	}
+
+	static class ParentDirFromCallableTestCase extends BaseSeparateTempDirsTestCase {
+
+		private static FileSystem fileSystem;
+
+		@BeforeAll
+		static void createFileSystem() {
+			fileSystem = Jimfs.newFileSystem();
+		}
+
+		@AfterAll
+		static void closeFileSystem() throws Exception {
+			assertThat(tempDirs.getFirst()).doesNotExist();
+			assertThat(tempDirs.getLast()).doesNotExist();
+			fileSystem.close();
+		}
+
+		@RegisterExtension
+		@SuppressWarnings("unused")
+		Extension tempDirectory = TempDirectory.createInCustomDirectory(
+			() -> Files.createDirectories(fileSystem.getPath("tmp")));
+
+	}
+
+	static class ParentDirFromProviderTestCase extends BaseSeparateTempDirsTestCase {
+
+		@RegisterExtension
+		@SuppressWarnings("unused")
+		Extension tempDirectory = TempDirectory.createInCustomDirectory((parameterContext, extensionContext) -> {
+			Store store = extensionContext.getRoot().getStore(Namespace.GLOBAL);
+			FileSystem fileSystem = store.getOrComputeIfAbsent("jimfs.fileSystem", key -> new JimfsFileSystemResource(),
+				JimfsFileSystemResource.class).get();
+			return Files.createDirectories(fileSystem.getPath("tmp"));
+		});
+
+		static class JimfsFileSystemResource implements CloseableResource {
+			private final FileSystem fileSystem;
+
+			JimfsFileSystemResource() {
+				this.fileSystem = Jimfs.newFileSystem();
+			}
+
+			FileSystem get() {
+				return fileSystem;
+			}
+
+			@Override
+			public void close() throws IOException {
+				assertThat(tempDirs.getFirst()).doesNotExist();
+				assertThat(tempDirs.getLast()).doesNotExist();
+				fileSystem.close();
+			}
+		}
+	}
+
+	static class FailedCreationAttemptTestCase {
+
+		private FileSystem fileSystem = mock(FileSystem.class);
+
+		@BeforeEach
+		void prepareFileSystem() {
+			when(fileSystem.getPath(any())).thenAnswer(invocation -> {
+				Path path = mock(Path.class, Arrays.toString(invocation.getArguments()));
+				when(path.getFileSystem()).thenThrow(new RuntimeException("Simulated creation failure"));
+				return path;
+			});
+		}
+
+		@RegisterExtension
+		@SuppressWarnings("unused")
+		Extension tempDirectory = TempDirectory.createInCustomDirectory(() -> fileSystem.getPath("tmp"));
+
+		@Test
+		void test(@SuppressWarnings("unused") @TempDir Path tempDir) {
+			fail("this should never be called");
+		}
+	}
+
+	static class FailedDeletionAttemptTestCase {
+
+		private FileSystem fileSystem = mock(FileSystem.class);
+
+		@BeforeEach
+		@SuppressWarnings("unchecked")
+		void prepareFileSystem() throws Exception {
+			FileSystemProvider provider = mock(FileSystemProvider.class);
+			when(provider.readAttributes(any(), any(Class.class), any())) //
+					.thenAnswer(invocation -> mock(invocation.getArgument(1)));
+			doThrow(new IOException("Simulated deletion failure")).when(provider).delete(any());
+			when(fileSystem.provider()).thenReturn(provider);
+			when(fileSystem.getPath(any())).thenAnswer(invocation -> {
+				Path path = mock(Path.class, Arrays.toString(invocation.getArguments()));
+				when(path.getFileSystem()).thenReturn(fileSystem);
+				when(path.toAbsolutePath()).thenReturn(path);
+				when(path.resolve(any(Path.class))).thenAnswer(invocation1 -> invocation1.getArgument(0));
+				when(path.toFile()).thenThrow(UnsupportedOperationException.class);
+				when(path.relativize(any(Path.class))).thenAnswer(invocation1 -> invocation1.getArgument(0));
+				return path;
+			});
+		}
+
+		@RegisterExtension
+		@SuppressWarnings("unused")
+		Extension tempDirectory = TempDirectory.createInCustomDirectory(() -> fileSystem.getPath("tmp"));
+
+		@Test
+		void test(@TempDir Path tempDir) {
+			assertNotNull(tempDir);
+		}
+	}
+
+	static class ErroneousParentDirProviderTestCase {
+
+		@RegisterExtension
+		@SuppressWarnings("unused")
+		Extension tempDirectory = TempDirectory.createInCustomDirectory(() -> {
+			throw new IOException("something went horribly wrong");
+		});
+
+		@Test
+		void test(@SuppressWarnings("unused") @TempDir Path tempDir) {
+			fail("this should never be called");
+		}
+	}
+
+	private static void writeFile(@TempDir Path tempDir, TestInfo testInfo) throws IOException {
+		Path file = tempDir.resolve(testInfo.getTestMethod().orElseThrow().getName() + ".txt");
+		Files.write(file, testInfo.getDisplayName().getBytes());
+	}
+}
diff --git a/platform-tests/src/test/java/org/junit/jupiter/extensions/TempDirectory.java b/platform-tests/src/test/java/org/junit/jupiter/extensions/TempDirectory.java
deleted file mode 100644
index 29eb03197..000000000
--- a/platform-tests/src/test/java/org/junit/jupiter/extensions/TempDirectory.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.extensions;
-
-import java.io.IOException;
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.nio.file.FileVisitResult;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.SimpleFileVisitor;
-import java.nio.file.attribute.BasicFileAttributes;
-
-import org.junit.jupiter.api.extension.AfterEachCallback;
-import org.junit.jupiter.api.extension.ExtensionContext;
-import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
-import org.junit.jupiter.api.extension.ParameterContext;
-import org.junit.jupiter.api.extension.ParameterResolutionException;
-import org.junit.jupiter.api.extension.ParameterResolver;
-
-/**
- * @since 1.0
- */
-public class TempDirectory implements AfterEachCallback, ParameterResolver {
-
-	@Target(ElementType.PARAMETER)
-	@Retention(RetentionPolicy.RUNTIME)
-	@Documented
-	public @interface Root {
-	}
-
-	private static final String KEY = "tempDirectory";
-
-	@Override
-	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
-		return parameterContext.isAnnotated(Root.class) && parameterContext.getParameter().getType() == Path.class;
-	}
-
-	@Override
-	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext context) {
-		return getLocalStore(context).getOrComputeIfAbsent(KEY, key -> createTempDirectory(context));
-	}
-
-	@Override
-	public void afterEach(ExtensionContext context) throws Exception {
-		Path tempDirectory = (Path) getLocalStore(context).get(KEY);
-		if (tempDirectory != null) {
-			delete(tempDirectory);
-		}
-	}
-
-	private ExtensionContext.Store getLocalStore(ExtensionContext context) {
-		return context.getStore(localNamespace(context));
-	}
-
-	private Namespace localNamespace(ExtensionContext context) {
-		return Namespace.create(TempDirectory.class, context);
-	}
-
-	private Path createTempDirectory(ExtensionContext context) {
-		try {
-			String tempDirName;
-			if (context.getTestMethod().isPresent()) {
-				tempDirName = context.getTestMethod().get().getName();
-			}
-			else if (context.getTestClass().isPresent()) {
-				tempDirName = context.getTestClass().get().getName();
-			}
-			else {
-				tempDirName = context.getDisplayName();
-			}
-
-			return Files.createTempDirectory(tempDirName);
-		}
-		catch (IOException e) {
-			throw new ParameterResolutionException("Could not create temp directory", e);
-		}
-	}
-
-	private void delete(Path tempDirectory) throws IOException {
-		Files.walkFileTree(tempDirectory, new SimpleFileVisitor<Path>() {
-
-			@Override
-			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
-				return deleteAndContinue(file);
-			}
-
-			@Override
-			public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
-				return deleteAndContinue(dir);
-			}
-
-			private FileVisitResult deleteAndContinue(Path path) throws IOException {
-				Files.delete(path);
-				return FileVisitResult.CONTINUE;
-			}
-		});
-	}
-
-}
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java
index fed977c32..eb677f88a 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java
@@ -35,9 +35,9 @@ import java.util.stream.Collectors;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.support.io.TempDirectory;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
 import org.junit.jupiter.engine.TrackLogRecords;
-import org.junit.jupiter.extensions.TempDirectory;
-import org.junit.jupiter.extensions.TempDirectory.Root;
 import org.junit.platform.commons.function.Try;
 import org.junit.platform.commons.logging.LogRecordListener;
 
@@ -269,7 +269,7 @@ class ClasspathScannerTests {
 
 	@Test
 	@ExtendWith(TempDirectory.class)
-	void doesNotLoopInfinitelyWithCircularSymlinks(@Root Path tempDir) throws Exception {
+	void doesNotLoopInfinitelyWithCircularSymlinks(@TempDir Path tempDir) throws Exception {
 
 		// Abort if running on Microsoft Windows since we are testing symbolic links
 		assumeFalse(System.getProperty("os.name").toLowerCase().contains("win"));
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
index 8d1c05d4f..296b62f8c 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
@@ -48,9 +48,9 @@ import java.util.logging.LogRecord;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.support.io.TempDirectory;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
 import org.junit.jupiter.engine.TrackLogRecords;
-import org.junit.jupiter.extensions.TempDirectory;
-import org.junit.jupiter.extensions.TempDirectory.Root;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.commons.util.ReflectionUtilsTests.ClassWithNestedClasses.Nested1;
@@ -609,7 +609,7 @@ class ReflectionUtilsTests {
 
 	@Test
 	@ExtendWith(TempDirectory.class)
-	void getAllClasspathRootDirectories(@Root Path tempDirectory) throws Exception {
+	void getAllClasspathRootDirectories(@TempDir Path tempDirectory) throws Exception {
 		Path root1 = tempDirectory.resolve("root1").toAbsolutePath();
 		Path root2 = tempDirectory.resolve("root2").toAbsolutePath();
 		String testClassPath = root1 + File.pathSeparator + root2;
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
index ef38dbe7f..aabe85ed4 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
@@ -40,8 +40,8 @@ import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
-import org.junit.jupiter.extensions.TempDirectory;
-import org.junit.jupiter.extensions.TempDirectory.Root;
+import org.junit.jupiter.api.support.io.TempDirectory;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -575,7 +575,7 @@ class DiscoverySelectorsTests {
 
 	@Test
 	@ExtendWith(TempDirectory.class)
-	void selectClasspathRootsWithExistingDirectory(@Root Path tempDir) {
+	void selectClasspathRootsWithExistingDirectory(@TempDir Path tempDir) {
 		List<ClasspathRootSelector> selectors = selectClasspathRoots(singleton(tempDir));
 
 		assertThat(selectors).extracting(ClasspathRootSelector::getClasspathRoot).containsExactly(tempDir.toUri());
diff --git a/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListenerTests.java b/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListenerTests.java
index c2b593008..26c5d349d 100644
--- a/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListenerTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/LegacyXmlReportGeneratingListenerTests.java
@@ -42,8 +42,8 @@ import java.util.Map;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestReporter;
 import org.junit.jupiter.api.extension.ExtendWith;
-import org.junit.jupiter.extensions.TempDirectory;
-import org.junit.jupiter.extensions.TempDirectory.Root;
+import org.junit.jupiter.api.support.io.TempDirectory;
+import org.junit.jupiter.api.support.io.TempDirectory.TempDir;
 import org.junit.platform.engine.TestEngine;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.reporting.ReportEntry;
@@ -66,7 +66,7 @@ import org.opentest4j.AssertionFailedError;
 class LegacyXmlReportGeneratingListenerTests {
 
 	@Test
-	void writesFileForSingleSucceedingTest(@Root Path tempDirectory) throws Exception {
+	void writesFileForSingleSucceedingTest(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("succeedingTest", "display<-->Name ðŸ˜Ž", () -> {
 		});
@@ -98,7 +98,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesFileForSingleFailingTest(@Root Path tempDirectory) throws Exception {
+	void writesFileForSingleFailingTest(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("failingTest", () -> fail("expected to <b>fail</b>"));
 
@@ -123,7 +123,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesFileForSingleErroneousTest(@Root Path tempDirectory) throws Exception {
+	void writesFileForSingleErroneousTest(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("failingTest", () -> {
 			throw new RuntimeException("error occurred");
@@ -150,7 +150,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesFileForSingleSkippedTest(@Root Path tempDirectory) throws Exception {
+	void writesFileForSingleSkippedTest(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		DemoHierarchicalTestDescriptor testDescriptor = engine.addTest("skippedTest", () -> fail("never called"));
 		testDescriptor.markSkipped("should be skipped");
@@ -175,7 +175,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesFileForSingleAbortedTest(@Root Path tempDirectory) throws Exception {
+	void writesFileForSingleAbortedTest(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("abortedTest", () -> assumeFalse(true, "deliberately aborted"));
 
@@ -201,7 +201,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void measuresTimesInSeconds(@Root Path tempDirectory) throws Exception {
+	void measuresTimesInSeconds(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("firstTest", () -> {
 		});
@@ -227,7 +227,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void testWithImmeasurableTimeIsOutputCorrectly(@Root Path tempDirectory) throws Exception {
+	void testWithImmeasurableTimeIsOutputCorrectly(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("test", () -> {
 		});
@@ -245,7 +245,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesFileForSkippedContainer(@Root Path tempDirectory) throws Exception {
+	void writesFileForSkippedContainer(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("test", () -> fail("never called"));
 		engine.getEngineDescriptor().markSkipped("should be skipped");
@@ -268,7 +268,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesFileForFailingContainer(@Root Path tempDirectory) throws Exception {
+	void writesFileForFailingContainer(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("test", () -> fail("never called"));
 		engine.getEngineDescriptor().setBeforeAllBehavior(() -> fail("failure before all tests"));
@@ -292,7 +292,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesSystemProperties(@Root Path tempDirectory) throws Exception {
+	void writesSystemProperties(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("test", () -> {
 		});
@@ -315,7 +315,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesHostNameAndTimestamp(@Root Path tempDirectory) throws Exception {
+	void writesHostNameAndTimestamp(@TempDir Path tempDirectory) throws Exception {
 		DemoHierarchicalTestEngine engine = new DemoHierarchicalTestEngine("dummy");
 		engine.addTest("test", () -> {
 		});
@@ -339,7 +339,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void printsExceptionWhenReportsDirCannotBeCreated(@Root Path tempDirectory) throws Exception {
+	void printsExceptionWhenReportsDirCannotBeCreated(@TempDir Path tempDirectory) throws Exception {
 		Path reportsDir = tempDirectory.resolve("dummy.txt");
 		Files.write(reportsDir, singleton("content"));
 
@@ -354,7 +354,7 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void printsExceptionWhenReportCouldNotBeWritten(@Root Path tempDirectory) throws Exception {
+	void printsExceptionWhenReportCouldNotBeWritten(@TempDir Path tempDirectory) throws Exception {
 		EngineDescriptor engineDescriptor = new EngineDescriptor(UniqueId.forEngine("engine"), "Engine");
 
 		Path xmlFile = tempDirectory.resolve("TEST-engine.xml");
@@ -371,7 +371,8 @@ class LegacyXmlReportGeneratingListenerTests {
 	}
 
 	@Test
-	void writesReportEntriesToSystemOutElement(@Root Path tempDirectory, TestReporter testReporter) throws Exception {
+	void writesReportEntriesToSystemOutElement(@TempDir Path tempDirectory, TestReporter testReporter)
+			throws Exception {
 		EngineDescriptor engineDescriptor = new EngineDescriptor(UniqueId.forEngine("engine"), "Engine");
 		engineDescriptor.addChild(new TestDescriptorStub(UniqueId.root("child", "test"), "test"));
 		TestPlan testPlan = TestPlan.from(singleton(engineDescriptor));
