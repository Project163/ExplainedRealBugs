diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
index 4236da2f1..d4e13d291 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
@@ -34,6 +34,10 @@ on GitHub.
 * A `@ParameterizedTest` method configured with a `@MethodSource` annotation that
   references a factory method inherited from multiple interfaces no longer fails with an
   exception stating that multiple factory methods with the same name were found.
+* A `@ParameterizedTest` method configured with a `@MethodSource` annotation that
+  references a factory method whose name is the same as other test methods in the same
+  class no longer fails with an exception stating that multiple factory methods with the
+  same name were found.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
index 4be203387..f8df21bac 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
@@ -12,12 +12,17 @@ package org.junit.jupiter.params.provider;
 
 import static java.lang.String.format;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
+import static org.junit.platform.commons.util.AnnotationUtils.isAnnotated;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.List;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.TestTemplate;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.params.support.AnnotationConsumer;
 import org.junit.platform.commons.JUnitException;
@@ -72,10 +77,15 @@ class MethodArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<M
 				methodParameters, className)));
 	}
 
+	/**
+	 * Find all methods in the given {@code testClass} with the desired {@code factoryMethodName},
+	 * ignoring the {@code testMethod} itself as well as any {@code @Test}, {@code @TestTemplate},
+	 * or {@code @TestFactory} methods with the same name.
+	 */
 	private Method getFactoryMethodBySimpleName(Class<?> testClass, Method testMethod, String factoryMethodName) {
-		// Find all methods with the desired factory method name, but ignore the test method itself.
-		List<Method> methods = ReflectionUtils.findMethods(testClass,
-			factoryMethod -> factoryMethodName.equals(factoryMethod.getName()) && !testMethod.equals(factoryMethod));
+		Predicate<Method> isFactoryMethod = candidate -> factoryMethodName.equals(candidate.getName())
+				&& !(testMethod.equals(candidate) || isTestMethod(candidate));
+		List<Method> methods = ReflectionUtils.findMethods(testClass, isFactoryMethod);
 		Preconditions.condition(methods.size() > 0,
 			() -> format("Could not find factory method [%s] in class [%s]", factoryMethodName, testClass.getName()));
 		Preconditions.condition(methods.size() == 1,
@@ -84,6 +94,11 @@ class MethodArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<M
 		return methods.get(0);
 	}
 
+	private boolean isTestMethod(Method candidate) {
+		return isAnnotated(candidate, Test.class) || isAnnotated(candidate, TestTemplate.class)
+				|| isAnnotated(candidate, TestFactory.class);
+	}
+
 	private Class<?> loadRequiredClass(String className) {
 		return ReflectionUtils.tryToLoadClass(className).getOrThrow(
 			cause -> new JUnitException(format("Could not load class [%s]", className), cause));
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
index 50aa14fc2..4682db419 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
@@ -12,9 +12,12 @@ package org.junit.jupiter.params;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.within;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 import static org.junit.jupiter.api.Named.named;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.appendTestTemplateInvocationSegment;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTestTemplateMethod;
@@ -53,13 +56,17 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Assumptions;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
 import org.junit.jupiter.api.Named;
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Order;
+import org.junit.jupiter.api.RepeatedTest;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.TestInfo;
 import org.junit.jupiter.api.TestMethodOrder;
+import org.junit.jupiter.api.TestReporter;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
@@ -722,11 +729,6 @@ class ParameterizedTestIntegrationTests {
 							message("Assumption failed: nothing to test"))));
 		}
 
-		private EngineExecutionResults execute(String methodName, Class<?>... methodParameterTypes) {
-			return ParameterizedTestIntegrationTests.this.execute(MethodSourceTestCase.class, methodName,
-				methodParameterTypes);
-		}
-
 		@Test
 		void namedParameters() {
 			execute("namedParameters", String.class).allEvents().assertThatEvents() //
@@ -745,6 +747,27 @@ class ParameterizedTestIntegrationTests {
 						event(test(), displayName("default name"), finishedWithFailure(message("default name"))));
 		}
 
+		/**
+		 * @since 5.9.1
+		 * @see https://github.com/junit-team/junit5/issues/3001
+		 */
+		@Test
+		void duplicateMethodNames() {
+			// It is sufficient to assert that 8 tests started and finished, because
+			// without the fix for #3001 the 4 parameterized tests would fail. In
+			// other words, we're not really testing the support for @RepeatedTest
+			// and @TestFactory, but their presence also contributes to the bug
+			// reported in #3001.
+			ParameterizedTestIntegrationTests.this.execute(selectClass(DuplicateMethodNamesMethodSourceTestCase.class))//
+					.testEvents()//
+					.assertStatistics(stats -> stats.started(8).failed(0).finished(8));
+		}
+
+		private EngineExecutionResults execute(String methodName, Class<?>... methodParameterTypes) {
+			return ParameterizedTestIntegrationTests.this.execute(MethodSourceTestCase.class, methodName,
+				methodParameterTypes);
+		}
+
 	}
 
 	@Nested
@@ -1251,6 +1274,40 @@ class ParameterizedTestIntegrationTests {
 
 	}
 
+	/**
+	 * @since 5.9.1
+	 * @see https://github.com/junit-team/junit5/issues/3001
+	 */
+	static class DuplicateMethodNamesMethodSourceTestCase {
+
+		@ParameterizedTest
+		@MethodSource
+		void test(String value) {
+			assertEquals(1, value.length());
+		}
+
+		@ParameterizedTest
+		@MethodSource("test")
+		void anotherTest(String value) {
+			assertEquals(1, value.length());
+		}
+
+		@RepeatedTest(2)
+		void test(TestReporter testReporter) {
+			assertNotNull(testReporter);
+		}
+
+		@TestFactory
+		Stream<DynamicTest> test(TestInfo testInfo) {
+			return test().map(value -> dynamicTest(value, () -> assertEquals(1, value.length())));
+		}
+
+		private static Stream<String> test() {
+			return Stream.of("a", "b");
+		}
+
+	}
+
 	static class UnusedArgumentsTestCase {
 
 		@ParameterizedTest
