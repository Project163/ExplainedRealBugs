diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M3.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M3.adoc
index a6c12b4ef..464ac8fca 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M3.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M3.adoc
@@ -45,7 +45,10 @@ repository on GitHub.
 [[release-notes-5.13.0-M3-junit-jupiter-new-features-and-improvements]]
 ==== New Features and Improvements
 
-* ‚ùì
+* Return types of `@TestFactory` methods are now validated during discovery rather than
+  during execution. Invalid `@TestFactory` methods are no longer executed but reported as
+  discovery issues for consistency with how `@Test` and `@TestTemplate` methods are
+  handled.
 
 
 [[release-notes-5.13.0-M3-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 850c65b9d..f4f132cb6 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2890,8 +2890,8 @@ or extensions between the execution of individual dynamic tests generated by the
 The following `DynamicTestsDemo` class demonstrates several examples of test factories
 and dynamic tests.
 
-The first method returns an invalid return type. Since an invalid return type cannot be
-detected at compile time, a `JUnitException` is thrown when it is detected at runtime.
+The first method returns an invalid return type and will cause a warning to be reported by
+JUnit during test discovery. Such methods are not executed.
 
 The next six methods demonstrate the generation of a `Collection`, `Iterable`, `Iterator`,
 array, or `Stream` of `DynamicTest` instances. Most of these examples do not really
diff --git a/documentation/src/test/java/example/DynamicTestsDemo.java b/documentation/src/test/java/example/DynamicTestsDemo.java
index 32388f62e..c5643890b 100644
--- a/documentation/src/test/java/example/DynamicTestsDemo.java
+++ b/documentation/src/test/java/example/DynamicTestsDemo.java
@@ -43,11 +43,12 @@ class DynamicTestsDemo {
 
 	private final Calculator calculator = new Calculator();
 
+	// This method will not be executed but produce a warning
+	@TestFactory
 	// end::user_guide[]
 	@Tag("exclude")
+	DynamicTest dummy() { return null; }
 	// tag::user_guide[]
-	// This will result in a JUnitException!
-	@TestFactory
 	List<String> dynamicTestsWithInvalidReturnType() {
 		return Arrays.asList("Hello");
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index 21dded659..5b8183513 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -35,7 +35,6 @@ import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker;
 import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.CollectionUtils;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.engine.TestDescriptor;
@@ -138,17 +137,11 @@ public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implemen
 		if (testFactoryMethodResult instanceof DynamicNode) {
 			return Stream.of((DynamicNode) testFactoryMethodResult);
 		}
-		try {
-			return (Stream<DynamicNode>) CollectionUtils.toStream(testFactoryMethodResult);
-		}
-		catch (PreconditionViolationException ex) {
-			throw invalidReturnTypeException(ex);
-		}
+		return (Stream<DynamicNode>) CollectionUtils.toStream(testFactoryMethodResult);
 	}
 
 	private JUnitException invalidReturnTypeException(Throwable cause) {
-		String message = String.format(
-			"@TestFactory method [%s] must return a single %2$s or a Stream, Collection, Iterable, Iterator, or array of %2$s.",
+		String message = String.format("Objects produced by @TestFactory method '%s' must be of type %s.",
 			getTestMethod().toGenericString(), DynamicNode.class.getName());
 		return new JUnitException(message, cause);
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethod.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethod.java
index 939e6721f..aaf90d6db 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethod.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethod.java
@@ -12,8 +12,20 @@ package org.junit.jupiter.engine.discovery.predicates;
 
 import static org.apiguardian.api.API.Status.INTERNAL;
 
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.WildcardType;
+import java.util.Iterator;
+import java.util.stream.Stream;
+
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.DynamicNode;
 import org.junit.jupiter.api.TestFactory;
+import org.junit.platform.engine.DiscoveryIssue;
+import org.junit.platform.engine.DiscoveryIssue.Severity;
+import org.junit.platform.engine.support.descriptor.MethodSource;
 import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 
 /**
@@ -27,8 +39,76 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 @API(status = INTERNAL, since = "5.0")
 public class IsTestFactoryMethod extends IsTestableMethod {
 
+	private static final String EXPECTED_RETURN_TYPE_MESSAGE = String.format(
+		"must return a single %1$s or a Stream, Collection, Iterable, Iterator, or array of %1$s",
+		DynamicNode.class.getName());
+
 	public IsTestFactoryMethod(DiscoveryIssueReporter issueReporter) {
-		super(TestFactory.class, false, issueReporter);
+		super(TestFactory.class, IsTestFactoryMethod::hasCompatibleReturnType, issueReporter);
+	}
+
+	private static DiscoveryIssueReporter.Condition<Method> hasCompatibleReturnType(
+			Class<? extends Annotation> annotationType, DiscoveryIssueReporter issueReporter) {
+		return issueReporter.createReportingCondition(method -> isCompatible(method, issueReporter),
+			method -> createIssue(annotationType, method, EXPECTED_RETURN_TYPE_MESSAGE));
+	}
+
+	private static boolean isCompatible(Method method, DiscoveryIssueReporter issueReporter) {
+		Class<?> returnType = method.getReturnType();
+		if (DynamicNode.class.isAssignableFrom(returnType) || DynamicNode[].class.isAssignableFrom(returnType)) {
+			return true;
+		}
+		if (returnType == Object.class || returnType == Object[].class) {
+			issueReporter.reportIssue(createTooGenericReturnTypeIssue(method));
+			return true;
+		}
+		boolean validContainerType = Stream.class.isAssignableFrom(returnType) //
+				|| Iterable.class.isAssignableFrom(returnType) //
+				|| Iterator.class.isAssignableFrom(returnType);
+		return validContainerType && isCompatibleContainerType(method, issueReporter);
+	}
+
+	private static boolean isCompatibleContainerType(Method method, DiscoveryIssueReporter issueReporter) {
+		Type genericReturnType = method.getGenericReturnType();
+
+		if (genericReturnType instanceof ParameterizedType) {
+			Type[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();
+			if (typeArguments.length == 1) {
+				Type typeArgument = typeArguments[0];
+				if (typeArgument instanceof Class) {
+					// Stream<DynamicNode> etc.
+					return DynamicNode.class.isAssignableFrom((Class<?>) typeArgument);
+				}
+				if (typeArgument instanceof WildcardType) {
+					WildcardType wildcardType = (WildcardType) typeArgument;
+					Type[] upperBounds = wildcardType.getUpperBounds();
+					Type[] lowerBounds = wildcardType.getLowerBounds();
+					if (upperBounds.length == 1 && lowerBounds.length == 0 && upperBounds[0] instanceof Class) {
+						Class<?> upperBound = (Class<?>) upperBounds[0];
+						if (Object.class.equals(upperBound)) { // Stream<?> etc.
+							issueReporter.reportIssue(createTooGenericReturnTypeIssue(method));
+							return true;
+						}
+						// Stream<? extends DynamicNode> etc.
+						return DynamicNode.class.isAssignableFrom(upperBound);
+					}
+				}
+			}
+			return false;
+		}
+
+		// Raw Stream etc. without type argument
+		issueReporter.reportIssue(createTooGenericReturnTypeIssue(method));
+		return true;
+	}
+
+	private static DiscoveryIssue.Builder createTooGenericReturnTypeIssue(Method method) {
+		String message = String.format(
+			"The declared return type of @TestFactory method '%s' does not support static validation. It "
+					+ EXPECTED_RETURN_TYPE_MESSAGE + ".",
+			method.toGenericString());
+		return DiscoveryIssue.builder(Severity.INFO, message) //
+				.source(MethodSource.from(method));
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethod.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethod.java
index 5c5c8d50e..f703140bc 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethod.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestMethod.java
@@ -25,7 +25,7 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 public class IsTestMethod extends IsTestableMethod {
 
 	public IsTestMethod(DiscoveryIssueReporter issueReporter) {
-		super(Test.class, true, issueReporter);
+		super(Test.class, IsTestableMethod::hasVoidReturnType, issueReporter);
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethod.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethod.java
index 4c9715f25..61f8cb688 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethod.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestTemplateMethod.java
@@ -25,7 +25,7 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 public class IsTestTemplateMethod extends IsTestableMethod {
 
 	public IsTestTemplateMethod(DiscoveryIssueReporter issueReporter) {
-		super(TestTemplate.class, true, issueReporter);
+		super(TestTemplate.class, IsTestableMethod::hasVoidReturnType, issueReporter);
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java
index b689c9b7b..060fc0141 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestableMethod.java
@@ -11,10 +11,10 @@
 package org.junit.jupiter.engine.discovery.predicates;
 
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
-import static org.junit.platform.commons.util.ReflectionUtils.returnsPrimitiveVoid;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
+import java.util.function.BiFunction;
 import java.util.function.Predicate;
 
 import org.junit.platform.commons.support.ModifierSupport;
@@ -33,13 +33,14 @@ abstract class IsTestableMethod implements Predicate<Method> {
 	private final Class<? extends Annotation> annotationType;
 	private final Condition<Method> condition;
 
-	IsTestableMethod(Class<? extends Annotation> annotationType, boolean mustReturnPrimitiveVoid,
+	IsTestableMethod(Class<? extends Annotation> annotationType,
+			BiFunction<Class<? extends Annotation>, DiscoveryIssueReporter, Condition<Method>> returnTypeConditionFactory,
 			DiscoveryIssueReporter issueReporter) {
 		this.annotationType = annotationType;
-		this.condition = isNotStatic(issueReporter) //
-				.and(isNotPrivate(issueReporter)) //
-				.and(isNotAbstract(issueReporter)) //
-				.and(hasCompatibleReturnType(mustReturnPrimitiveVoid, issueReporter));
+		this.condition = isNotStatic(annotationType, issueReporter) //
+				.and(isNotPrivate(annotationType, issueReporter)) //
+				.and(isNotAbstract(annotationType, issueReporter)) //
+				.and(returnTypeConditionFactory.apply(annotationType, issueReporter));
 	}
 
 	@Override
@@ -50,37 +51,34 @@ abstract class IsTestableMethod implements Predicate<Method> {
 		return false;
 	}
 
-	private Condition<Method> isNotStatic(DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> isNotStatic(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotStatic,
-			method -> createIssue(method, "must not be static"));
+			method -> createIssue(annotationType, method, "must not be static"));
 	}
 
-	private Condition<Method> isNotPrivate(DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> isNotPrivate(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotPrivate,
-			method -> createIssue(method, "must not be private"));
+			method -> createIssue(annotationType, method, "must not be private"));
 	}
 
-	private Condition<Method> isNotAbstract(DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> isNotAbstract(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotAbstract,
-			method -> createIssue(method, "must not be abstract"));
+			method -> createIssue(annotationType, method, "must not be abstract"));
 	}
 
-	private Condition<Method> hasCompatibleReturnType(boolean mustReturnPrimitiveVoid,
+	protected static Condition<Method> hasVoidReturnType(Class<? extends Annotation> annotationType,
 			DiscoveryIssueReporter issueReporter) {
-		if (mustReturnPrimitiveVoid) {
-			return issueReporter.createReportingCondition(ReflectionUtils::returnsPrimitiveVoid,
-				method -> createIssue(method, "must not return a value"));
-		}
-		else {
-			// TODO [#4246] Use `Predicate.not`
-			return issueReporter.createReportingCondition(method -> !returnsPrimitiveVoid(method),
-				method -> createIssue(method, "must return a value"));
-		}
+		return issueReporter.createReportingCondition(ReflectionUtils::returnsPrimitiveVoid,
+			method -> createIssue(annotationType, method, "must not return a value"));
 	}
 
-	private DiscoveryIssue createIssue(Method method, String condition) {
+	protected static DiscoveryIssue createIssue(Class<? extends Annotation> annotationType, Method method,
+			String condition) {
 		String message = String.format("@%s method '%s' %s. It will be not be executed.",
-			this.annotationType.getSimpleName(), method.toGenericString(), condition);
+			annotationType.getSimpleName(), method.toGenericString(), condition);
 		return DiscoveryIssue.builder(Severity.WARNING, message) //
 				.source(MethodSource.from(method)) //
 				.build();
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
index ad1ef49fc..4ebb656d3 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
@@ -154,11 +154,10 @@ class TestFactoryTestDescriptorTests {
 		private ExtensionContext extensionContext;
 		private TestFactoryTestDescriptor descriptor;
 		private boolean isClosed;
-		private JupiterConfiguration jupiterConfiguration;
 
 		@BeforeEach
 		void before() throws Exception {
-			jupiterConfiguration = mock();
+			JupiterConfiguration jupiterConfiguration = mock();
 			when(jupiterConfiguration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
 
 			extensionContext = mock();
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java
index d01027a83..763591ab3 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/IsTestFactoryMethodTests.java
@@ -11,6 +11,8 @@
 package org.junit.jupiter.engine.discovery.predicates;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
 
 import java.lang.reflect.Method;
@@ -18,11 +20,15 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.function.Predicate;
+import java.util.stream.Stream;
 
-import org.junit.jupiter.api.Disabled;
+import org.assertj.core.api.Assertions;
+import org.junit.jupiter.api.DynamicContainer;
+import org.junit.jupiter.api.DynamicNode;
 import org.junit.jupiter.api.DynamicTest;
-import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.commons.support.ReflectionSupport;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.support.descriptor.MethodSource;
@@ -37,36 +43,47 @@ class IsTestFactoryMethodTests {
 	final List<DiscoveryIssue> discoveryIssues = new ArrayList<>();
 	final Predicate<Method> isTestFactoryMethod = new IsTestFactoryMethod(discoveryIssues::add);
 
-	@Test
-	void factoryMethodReturningCollectionOfDynamicTests() {
-		assertThat(isTestFactoryMethod).accepts(method("dynamicTestsFactory"));
+	@ParameterizedTest
+	@ValueSource(strings = { "dynamicTestsFactoryFromCollection", "dynamicTestsFactoryFromStreamWithExtendsWildcard",
+			"dynamicTestsFactoryFromNode", "dynamicTestsFactoryFromTest", "dynamicTestsFactoryFromContainer",
+			"dynamicTestsFactoryFromNodeArray", "dynamicTestsFactoryFromTestArray",
+			"dynamicTestsFactoryFromContainerArray" })
+	void validFactoryMethods(String methodName) {
+		assertThat(isTestFactoryMethod).accepts(method(methodName));
+		assertThat(discoveryIssues).isEmpty();
 	}
 
-	@Test
-	void bogusFactoryMethodReturningVoid() {
-		var method = method("bogusVoidFactory");
+	@ParameterizedTest
+	@ValueSource(strings = { "bogusVoidFactory", "bogusStringsFactory", "bogusStringArrayFactory",
+			"dynamicTestsFactoryFromStreamWithSuperWildcard" })
+	void invalidFactoryMethods(String methodName) {
+		var method = method(methodName);
 
 		assertThat(isTestFactoryMethod).rejects(method);
 
 		var issue = getOnlyElement(discoveryIssues);
 		assertThat(issue.severity()).isEqualTo(DiscoveryIssue.Severity.WARNING);
 		assertThat(issue.message()).isEqualTo(
-			"@TestFactory method '%s' must return a value. It will be not be executed.", method.toGenericString());
+			"@TestFactory method '%s' must return a single org.junit.jupiter.api.DynamicNode or a Stream, Collection, Iterable, Iterator, or array of org.junit.jupiter.api.DynamicNode. "
+					+ "It will be not be executed.",
+			method.toGenericString());
 		assertThat(issue.source()).contains(MethodSource.from(method));
 	}
 
-	// TODO [#949] Enable test once IsTestFactoryMethod properly checks return type.
-	@Disabled("Disabled until IsTestFactoryMethod properly checks return type")
-	@Test
-	void bogusFactoryMethodReturningObject() {
-		assertThat(isTestFactoryMethod).rejects(method("bogusObjectFactory"));
-	}
+	@ParameterizedTest
+	@ValueSource(strings = { "objectFactory", "objectArrayFactory", "rawCollectionFactory", "unboundStreamFactory" })
+	void suspiciousFactoryMethods(String methodName) {
+		var method = method(methodName);
+
+		assertThat(isTestFactoryMethod).accepts(method);
 
-	// TODO [#949] Enable test once IsTestFactoryMethod properly checks return type.
-	@Disabled("Disabled until IsTestFactoryMethod properly checks return type")
-	@Test
-	void bogusFactoryMethodReturningCollectionOfStrings() {
-		assertThat(isTestFactoryMethod).rejects(method("bogusStringsFactory"));
+		var issue = getOnlyElement(discoveryIssues);
+		assertThat(issue.severity()).isEqualTo(DiscoveryIssue.Severity.INFO);
+		assertThat(issue.message()).isEqualTo(
+			"The declared return type of @TestFactory method '%s' does not support static validation. "
+					+ "It must return a single org.junit.jupiter.api.DynamicNode or a Stream, Collection, Iterable, Iterator, or array of org.junit.jupiter.api.DynamicNode.",
+			method.toGenericString());
+		assertThat(issue.source()).contains(MethodSource.from(method));
 	}
 
 	private static Method method(String name) {
@@ -77,17 +94,47 @@ class IsTestFactoryMethodTests {
 	private static class ClassWithTestFactoryMethods {
 
 		@TestFactory
-		Collection<DynamicTest> dynamicTestsFactory() {
+		Collection<DynamicTest> dynamicTestsFactoryFromCollection() {
 			return new ArrayList<>();
 		}
 
 		@TestFactory
-		void bogusVoidFactory() {
+		Stream<? extends DynamicTest> dynamicTestsFactoryFromStreamWithExtendsWildcard() {
+			return Stream.empty();
+		}
+
+		@TestFactory
+		DynamicTest dynamicTestsFactoryFromNode() {
+			return dynamicTest("foo", Assertions::fail);
+		}
+
+		@TestFactory
+		DynamicTest dynamicTestsFactoryFromTest() {
+			return dynamicTest("foo", Assertions::fail);
+		}
+
+		@TestFactory
+		DynamicNode dynamicTestsFactoryFromContainer() {
+			return dynamicContainer("foo", Stream.empty());
+		}
+
+		@TestFactory
+		DynamicNode[] dynamicTestsFactoryFromNodeArray() {
+			return new DynamicNode[0];
+		}
+
+		@TestFactory
+		DynamicTest[] dynamicTestsFactoryFromTestArray() {
+			return new DynamicTest[0];
+		}
+
+		@TestFactory
+		DynamicContainer[] dynamicTestsFactoryFromContainerArray() {
+			return new DynamicContainer[0];
 		}
 
 		@TestFactory
-		Object bogusObjectFactory() {
-			return new Object();
+		void bogusVoidFactory() {
 		}
 
 		@TestFactory
@@ -95,6 +142,37 @@ class IsTestFactoryMethodTests {
 			return new ArrayList<>();
 		}
 
+		@TestFactory
+		String[] bogusStringArrayFactory() {
+			return new String[0];
+		}
+
+		@TestFactory
+		Stream<? super DynamicTest> dynamicTestsFactoryFromStreamWithSuperWildcard() {
+			return Stream.empty();
+		}
+
+		@TestFactory
+		Object objectFactory() {
+			return dynamicTest("foo", Assertions::fail);
+		}
+
+		@TestFactory
+		Object[] objectArrayFactory() {
+			return new DynamicNode[0];
+		}
+
+		@SuppressWarnings("rawtypes")
+		@TestFactory
+		Collection rawCollectionFactory() {
+			return new ArrayList<>();
+		}
+
+		@TestFactory
+		Stream<?> unboundStreamFactory() {
+			return Stream.of();
+		}
+
 	}
 
 }
