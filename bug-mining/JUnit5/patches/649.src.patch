diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index dfbe7932d..5c55bec09 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -128,6 +128,7 @@ endif::[]
 :Execution:                                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/Execution.html[@Execution]
 :Isolated:                                   {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/Isolated.html[@Isolated]
 :ResourceLock:                               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/ResourceLock.html[@ResourceLock]
+:ResourceLocksProvider:                      {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/ResourceLocksProvider.html[ResourceLocksProvider]
 :Resources:                                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/Resources.html[Resources]
 // Jupiter Extension APIs
 :extension-api-package:                      {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/package-summary.html[org.junit.jupiter.api.extension]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-M1.adoc
index e23dcb707..504d94de8 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-M1.adoc
@@ -54,6 +54,8 @@ JUnit repository on GitHub.
   `@ConvertWith`), and `ArgumentsAggregator` (declared via `@AggregateWith`)
   implementations can now use constructor injection from registered `ParameterResolver`
   extensions.
+* Allow determining "shared resources" at runtime via the new `@ResourceLock#providers`
+  attribute that accepts implementations of `ResourceLocksProvider`.
 
 
 [[release-notes-5.12.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 2dc985d9a..d8e7c351c 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2943,6 +2943,12 @@ execution. The shared resource is identified by a unique name which is a `String
 name can be user-defined or one of the predefined constants in `{Resources}`:
 `SYSTEM_PROPERTIES`, `SYSTEM_OUT`, `SYSTEM_ERR`, `LOCALE`, or `TIME_ZONE`.
 
+In addition to declaring these shared resources statically, the `{ResourceLock}`
+annotation has a `providers` attribute that allows registering implementations of the
+`{ResourceLocksProvider}` interface that can add shared resources dynamically at runtime.
+Note that resources declared statically with `{ResourceLock}` annotation are combined with
+resources added dynamically by `{ResourceLocksProvider}` implementations.
+
 If the tests in the following example were run in parallel _without_ the use of
 {ResourceLock}, they would be _flaky_. Sometimes they would pass, and at other times they
 would fail due to the inherent race condition of writing and then reading the same JVM
@@ -2970,8 +2976,15 @@ parallel with each other but not while any other test that requires `READ_WRITE`
 to the same shared resource is running.
 
 [source,java]
+.Declaring shared resources "statically" with `{ResourceLock}` annotation
+----
+include::{testDir}/example/sharedresources/StaticSharedResourcesDemo.java[tags=user_guide]
+----
+
+[source,java]
+.Adding shared resources "dynamically" with `{ResourceLocksProvider}` implementation
 ----
-include::{testDir}/example/SharedResourcesDemo.java[tags=user_guide]
+include::{testDir}/example/sharedresources/DynamicSharedResourcesDemo.java[tags=user_guide]
 ----
 
 
diff --git a/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java b/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java
new file mode 100644
index 000000000..8c80d511a
--- /dev/null
+++ b/documentation/src/test/java/example/sharedresources/DynamicSharedResourcesDemo.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2015-2024 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example.sharedresources;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.parallel.ExecutionMode.CONCURRENT;
+import static org.junit.jupiter.api.parallel.ResourceAccessMode.READ;
+import static org.junit.jupiter.api.parallel.ResourceAccessMode.READ_WRITE;
+import static org.junit.jupiter.api.parallel.Resources.SYSTEM_PROPERTIES;
+
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.Properties;
+import java.util.Set;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ResourceAccessMode;
+import org.junit.jupiter.api.parallel.ResourceLock;
+import org.junit.jupiter.api.parallel.ResourceLocksProvider;
+
+// tag::user_guide[]
+@Execution(CONCURRENT)
+@ResourceLock(providers = DynamicSharedResourcesDemo.Provider.class)
+class DynamicSharedResourcesDemo {
+
+	private Properties backup;
+
+	@BeforeEach
+	void backup() {
+		backup = new Properties();
+		backup.putAll(System.getProperties());
+	}
+
+	@AfterEach
+	void restore() {
+		System.setProperties(backup);
+	}
+
+	@Test
+	void customPropertyIsNotSetByDefault() {
+		assertNull(System.getProperty("my.prop"));
+	}
+
+	@Test
+	void canSetCustomPropertyToApple() {
+		System.setProperty("my.prop", "apple");
+		assertEquals("apple", System.getProperty("my.prop"));
+	}
+
+	@Test
+	void canSetCustomPropertyToBanana() {
+		System.setProperty("my.prop", "banana");
+		assertEquals("banana", System.getProperty("my.prop"));
+	}
+
+	static class Provider implements ResourceLocksProvider {
+
+		@Override
+		public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+			ResourceAccessMode mode = testMethod.getName().startsWith("canSet") ? READ_WRITE : READ;
+			return Collections.singleton(new Lock(SYSTEM_PROPERTIES, mode));
+		}
+	}
+
+}
+// end::user_guide[]
diff --git a/documentation/src/test/java/example/SharedResourcesDemo.java b/documentation/src/test/java/example/sharedresources/StaticSharedResourcesDemo.java
similarity index 96%
rename from documentation/src/test/java/example/SharedResourcesDemo.java
rename to documentation/src/test/java/example/sharedresources/StaticSharedResourcesDemo.java
index d52248892..869f9eb79 100644
--- a/documentation/src/test/java/example/SharedResourcesDemo.java
+++ b/documentation/src/test/java/example/sharedresources/StaticSharedResourcesDemo.java
@@ -8,7 +8,7 @@
  * https://www.eclipse.org/legal/epl-v20.html
  */
 
-package example;
+package example.sharedresources;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNull;
@@ -27,7 +27,7 @@ import org.junit.jupiter.api.parallel.ResourceLock;
 
 // tag::user_guide[]
 @Execution(CONCURRENT)
-class SharedResourcesDemo {
+class StaticSharedResourcesDemo {
 
 	private Properties backup;
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceAccessMode.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceAccessMode.java
index 24cdc2240..cc973b0dd 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceAccessMode.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceAccessMode.java
@@ -19,6 +19,7 @@ import org.apiguardian.api.API;
  *
  * @since 5.3
  * @see ResourceLock
+ * @see ResourceLocksProvider.Lock
  */
 @API(status = STABLE, since = "5.10")
 public enum ResourceAccessMode {
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
index f9839322b..f32012e68 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.api.parallel;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.lang.annotation.ElementType;
@@ -48,10 +49,20 @@ import org.junit.jupiter.api.BeforeEach;
  * <p>Since JUnit Jupiter 5.4, this annotation is {@linkplain Inherited inherited}
  * within class hierarchies.
  *
+ * <p>Since JUnit Jupiter 5.12, this annotation supports adding shared resources
+ * dynamically at runtime via {@link ResourceLock#providers}.
+ *
+ * <p>Resources declared "statically" using {@link #value()} and {@link #mode()}
+ * are combined with "dynamic" resources added via {@link #providers()}.
+ * For example, declaring resource "A" via {@code @ResourceLock("A")}
+ * and resource "B" via a provider returning {@code new Lock("B")} will result
+ * in two shared resources "A" and "B".
+ *
  * @see Isolated
  * @see Resources
  * @see ResourceAccessMode
  * @see ResourceLocks
+ * @see ResourceLocksProvider
  * @since 5.3
  */
 @API(status = STABLE, since = "5.10")
@@ -64,9 +75,12 @@ public @interface ResourceLock {
 	/**
 	 * The resource key.
 	 *
+	 * <p>Defaults to an empty string.
+	 *
 	 * @see Resources
+	 * @see ResourceLocksProvider.Lock#getKey()
 	 */
-	String value();
+	String value() default "";
 
 	/**
 	 * The resource access mode.
@@ -74,7 +88,19 @@ public @interface ResourceLock {
 	 * <p>Defaults to {@link ResourceAccessMode#READ_WRITE READ_WRITE}.
 	 *
 	 * @see ResourceAccessMode
+	 * @see ResourceLocksProvider.Lock#getAccessMode()
 	 */
 	ResourceAccessMode mode() default ResourceAccessMode.READ_WRITE;
 
+	/**
+	 * An array of one or more classes implementing {@link ResourceLocksProvider}.
+	 *
+	 * <p>Defaults to an empty array.
+	 *
+	 * @see ResourceLocksProvider.Lock
+	 * @since 5.12
+	 */
+	@API(status = EXPERIMENTAL, since = "5.12")
+	Class<? extends ResourceLocksProvider>[] providers() default {};
+
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java
new file mode 100644
index 000000000..720224ed0
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLocksProvider.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2015-2024 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.parallel;
+
+import static java.util.Collections.emptySet;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.reflect.Method;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.Nested;
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.commons.util.ToStringBuilder;
+
+/**
+ * {@code @ResourceLocksProvider} is used to add shared resources
+ * to a test class and / or its test methods dynamically at runtime.
+ *
+ * <p>Each shared resource is represented by an instance of {@link Lock}.
+ *
+ * <p>Adding shared resources using this interface has the same semantics
+ * as declaring them via {@code @ResourceLock(value, mode)} annotation
+ * but for some cases may be a more flexible and less verbose alternative
+ * since it allows to add resources programmatically.
+ *
+ * <p>Implementations must provide a no-args constructor.
+ *
+ * @since 5.12
+ * @see ResourceLock#providers()
+ * @see Resources
+ * @see ResourceAccessMode
+ * @see Lock
+ */
+@API(status = EXPERIMENTAL, since = "5.12")
+public interface ResourceLocksProvider {
+
+	/**
+	 * Add shared resources to a test class.
+	 *
+	 * <p>Invoked in case a test class or its parent class
+	 * is annotated with {@code @ResourceLock(providers)}.
+	 *
+	 * @apiNote Adding {@linkplain Lock a shared resource} with this method
+	 * has the same semantics as annotating a test class
+	 * with analogous {@code @ResourceLock(value, mode)}.
+	 *
+	 * @param testClass a test class to add shared resources
+	 * @return a set of {@link Lock}; may be empty
+	 */
+	default Set<Lock> provideForClass(Class<?> testClass) {
+		return emptySet();
+	}
+
+	/**
+	 * Add shared resources to a {@linkplain Nested nested} test class.
+	 *
+	 * <p>Invoked in case:
+	 * <ul>
+	 *     <li>an enclosing test class of any level or its parent class
+	 *     is annotated with {@code @ResourceLock(providers)}.</li>
+	 *     <li>a nested test class or its parent class
+	 * 	   is annotated with {@code @ResourceLock(providers)}.</li>
+	 * </ul>
+	 *
+	 * <p>Invoked for a nested test class
+	 * annotated with {@code @ResourceLock(providers)}
+	 * and for its child classes.
+	 *
+	 * @apiNote Adding {@linkplain Lock a shared resource} with this method
+	 * has the same semantics as annotating a nested test class
+	 * with analogous {@code @ResourceLock(value, mode)}.
+	 *
+	 * @param testClass a nested test class to add shared resources
+	 * @return a set of {@link Lock}; may be empty
+	 * @see Nested
+	 */
+	default Set<Lock> provideForNestedClass(Class<?> testClass) {
+		return emptySet();
+	}
+
+	/**
+	 * Add shared resources to a test method.
+	 *
+	 * <p>Invoked in case:
+	 * <ul>
+	 *     <li>an enclosing test class of any level or its parent class
+	 *     is annotated with {@code @ResourceLock(providers)}.</li>
+	 *     <li>a test method
+	 *     is annotated with {@code @ResourceLock(providers)}.</li>
+	 * </ul>
+	 *
+	 * @apiNote Adding {@linkplain Lock a shared resource} with this method
+	 * has the same semantics as annotating a test method
+	 * with analogous {@code @ResourceLock(value, mode)}.
+	 *
+	 * @param testClass a test class
+	 * or {@linkplain Nested nested} test class containing the {@code testMethod}
+	 * @param testMethod a test method to add shared resources
+	 * @return a set of {@link Lock}; may be empty
+	 */
+	default Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+		return emptySet();
+	}
+
+	/**
+	 *
+	 * <p>{@link Lock} represents a shared resource.
+	 *
+	 * <p>Each resource is identified by a {@link #key}.
+	 * In addition, the {@link #accessMode} allows to specify
+	 * whether a test class or test
+	 * method requires {@link ResourceAccessMode#READ_WRITE READ_WRITE}
+	 * or only {@link ResourceAccessMode#READ READ} access to the resource.
+	 *
+	 * @apiNote {@link Lock#key} and {@link Lock#accessMode} have the same
+	 * semantics as {@link ResourceLock#value()} and {@link ResourceLock#mode()}
+	 * respectively.
+	 *
+	 * @since 5.12
+	 * @see Isolated
+	 * @see Resources
+	 * @see ResourceAccessMode
+	 * @see ResourceLock
+	 * @see ResourceLocksProvider
+	 */
+	final class Lock {
+
+		private final String key;
+
+		private final ResourceAccessMode accessMode;
+
+		/**
+		 * Create a new {@code Lock} with {@code accessMode = READ_WRITE}.
+		 *
+		 * @param key the identifier of the resource; never {@code null} or blank
+		 * @see ResourceLock#value()
+		 */
+		public Lock(String key) {
+			this(key, ResourceAccessMode.READ_WRITE);
+		}
+
+		/**
+		 * Create a new {@code Lock}.
+		 *
+		 * @param key the identifier of the resource; never {@code null} or blank
+		 * @param accessMode the lock mode to use to synchronize access to the resource; never {@code null}
+		 * @see ResourceLock#value()
+		 * @see ResourceLock#mode()
+		 */
+		public Lock(String key, ResourceAccessMode accessMode) {
+			this.key = Preconditions.notBlank(key, "key must not be null or blank");
+			this.accessMode = Preconditions.notNull(accessMode, "accessMode must not be null");
+		}
+
+		/**
+		 * Get the key of this lock.
+		 *
+		 * @see ResourceLock#value()
+		 */
+		public String getKey() {
+			return key;
+		}
+
+		/**
+		 * Get the access mode of this lock.
+		 *
+		 * @see ResourceLock#mode()
+		 */
+		public ResourceAccessMode getAccessMode() {
+			return accessMode;
+		}
+
+		@Override
+		public boolean equals(Object o) {
+			if (this == o) {
+				return true;
+			}
+			if (o == null || getClass() != o.getClass()) {
+				return false;
+			}
+			Lock lock = (Lock) o;
+			return Objects.equals(key, lock.key) && accessMode == lock.accessMode;
+		}
+
+		@Override
+		public int hashCode() {
+			return Objects.hash(key, accessMode);
+		}
+
+		@Override
+		public String toString() {
+			return new ToStringBuilder(this) //
+					.append("key", key) //
+					.append("accessMode", accessMode) //
+					.toString();
+		}
+	}
+
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Resources.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Resources.java
index c9fa33ff2..d6c4be305 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Resources.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Resources.java
@@ -19,6 +19,7 @@ import org.apiguardian.api.API;
  *
  * @since 5.3
  * @see ResourceLock
+ * @see ResourceLocksProvider.Lock
  */
 @API(status = STABLE, since = "5.10")
 public class Resources {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index baa884c18..ddfbe7ef3 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -112,8 +112,6 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 		return this.testClass;
 	}
 
-	public abstract List<Class<?>> getEnclosingTestClasses();
-
 	@Override
 	public Type getType() {
 		return Type.CONTAINER;
@@ -142,7 +140,12 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 
 	@Override
 	public Set<ExclusiveResource> getExclusiveResources() {
-		return getExclusiveResourcesFromAnnotation(getTestClass());
+		// @formatter:off
+		return getExclusiveResourcesFromAnnotations(
+				getTestClass(),
+				provider -> provider.provideForClass(getTestClass())
+		);
+		// @formatter:on
 	}
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index 4b840a0d6..a7c3034a8 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -10,12 +10,10 @@
 
 package org.junit.jupiter.engine.descriptor;
 
-import static java.util.Collections.emptyList;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.DisplayNameUtils.createDisplayNameSupplierForClass;
 
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 
@@ -59,11 +57,6 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 		return new LinkedHashSet<>(this.tags);
 	}
 
-	@Override
-	public List<Class<?>> getEnclosingTestClasses() {
-		return emptyList();
-	}
-
 	// --- Node ----------------------------------------------------------------
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
index e96c36333..54673dcb9 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
@@ -10,8 +10,10 @@
 
 package org.junit.jupiter.engine.descriptor;
 
+import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.DisplayNameUtils.determineDisplayName;
@@ -19,12 +21,16 @@ import static org.junit.platform.commons.support.AnnotationSupport.findAnnotatio
 import static org.junit.platform.commons.support.AnnotationSupport.findRepeatableAnnotations;
 
 import java.lang.reflect.AnnotatedElement;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.stream.Stream;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.Tag;
@@ -33,6 +39,7 @@ import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.parallel.Execution;
 import org.junit.jupiter.api.parallel.ResourceAccessMode;
 import org.junit.jupiter.api.parallel.ResourceLock;
+import org.junit.jupiter.api.parallel.ResourceLocksProvider;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.ConditionEvaluator;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
@@ -41,6 +48,8 @@ import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.ExceptionUtils;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.StringUtils;
 import org.junit.platform.commons.util.UnrecoverableExceptions;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestSource;
@@ -100,6 +109,17 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 		// @formatter:on
 	}
 
+	public List<Class<?>> getEnclosingTestClasses() {
+		TestDescriptor parent = getParent().orElse(null);
+		if (parent instanceof ClassBasedTestDescriptor) {
+			ClassBasedTestDescriptor parentClassDescriptor = (ClassBasedTestDescriptor) parent;
+			List<Class<?>> result = new ArrayList<>(parentClassDescriptor.getEnclosingTestClasses());
+			result.add(parentClassDescriptor.getTestClass());
+			return result;
+		}
+		return emptyList();
+	}
+
 	/**
 	 * Invoke exception handlers for the supplied {@code Throwable} one-by-one
 	 * until none are left or the throwable to handle has been swallowed.
@@ -180,11 +200,46 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 		throw new JUnitException("Unknown ExecutionMode: " + mode);
 	}
 
-	Set<ExclusiveResource> getExclusiveResourcesFromAnnotation(AnnotatedElement element) {
+	Set<ExclusiveResource> getExclusiveResourcesFromAnnotations(AnnotatedElement element,
+			Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> providerToLocks) {
+		// @formatter:off
+		List<ResourceLock> ownAnnotations = findRepeatableAnnotations(element, ResourceLock.class);
+		List<ResourceLock> enclosingClassesAnnotations = getEnclosingTestClasses().stream()
+				.map(clazz -> findRepeatableAnnotations(clazz, ResourceLock.class))
+				.flatMap(Collection::stream)
+				.collect(toList());
+
+		return Stream.of(
+				getExclusiveResourcesFromValues(ownAnnotations),
+				getExclusiveResourcesFromProviders(ownAnnotations, providerToLocks),
+				getExclusiveResourcesFromProviders(enclosingClassesAnnotations, providerToLocks)
+		).flatMap(s -> s)
+		.collect(toSet());
+		// @formatter:on
+	}
+
+	private Stream<ExclusiveResource> getExclusiveResourcesFromValues(List<ResourceLock> annotations) {
+		// @formatter:off
+		return annotations.stream()
+				.flatMap(annotation -> {
+					if (StringUtils.isBlank(annotation.value())) {
+						return Stream.empty();
+					}
+					return Stream.of(new ExclusiveResource(annotation.value(), toLockMode(annotation.mode())));
+				});
+		// @formatter:on
+	}
+
+	private Stream<ExclusiveResource> getExclusiveResourcesFromProviders(List<ResourceLock> annotations,
+			Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> providerToLocks) {
 		// @formatter:off
-		return findRepeatableAnnotations(element, ResourceLock.class).stream()
-				.map(resource -> new ExclusiveResource(resource.value(), toLockMode(resource.mode())))
-				.collect(toSet());
+		return annotations.stream()
+				.flatMap(annotation -> Stream.of(annotation.providers())
+						.map(ReflectionUtils::newInstance)
+						.map(providerToLocks)
+						.flatMap(Collection::stream)
+						.map(lock -> new ExclusiveResource(lock.getKey(), toLockMode(lock.getAccessMode())))
+				);
 		// @formatter:on
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java
index 8c851955c..6a21a3ae6 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java
@@ -81,7 +81,12 @@ public abstract class MethodBasedTestDescriptor extends JupiterTestDescriptor {
 
 	@Override
 	public Set<ExclusiveResource> getExclusiveResources() {
-		return getExclusiveResourcesFromAnnotation(getTestMethod());
+		// @formatter:off
+		return getExclusiveResourcesFromAnnotations(
+				getTestMethod(),
+				provider -> provider.provideForMethod(getTestClass(), getTestMethod())
+		);
+		// @formatter:on
 	}
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
index 84ce0645b..7732a8585 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
@@ -10,13 +10,10 @@
 
 package org.junit.jupiter.engine.descriptor;
 
-import static java.util.Collections.emptyList;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.DisplayNameUtils.createDisplayNameSupplierForNestedClass;
 
-import java.util.ArrayList;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 
@@ -30,6 +27,7 @@ import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
 import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
 import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 
 /**
@@ -61,18 +59,6 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 		return allTags;
 	}
 
-	@Override
-	public List<Class<?>> getEnclosingTestClasses() {
-		TestDescriptor parent = getParent().orElse(null);
-		if (parent instanceof ClassBasedTestDescriptor) {
-			ClassBasedTestDescriptor parentClassDescriptor = (ClassBasedTestDescriptor) parent;
-			List<Class<?>> result = new ArrayList<>(parentClassDescriptor.getEnclosingTestClasses());
-			result.add(parentClassDescriptor.getTestClass());
-			return result;
-		}
-		return emptyList();
-	}
-
 	// --- Node ----------------------------------------------------------------
 
 	@Override
@@ -87,4 +73,14 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 		return instantiateTestClass(Optional.of(outerInstances), registry, extensionContext);
 	}
 
+	@Override
+	public Set<ExclusiveResource> getExclusiveResources() {
+		// @formatter:off
+		return getExclusiveResourcesFromAnnotations(
+				getTestClass(),
+				provider -> provider.provideForNestedClass(getTestClass())
+		);
+		// @formatter:on
+	}
+
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
index 32d627dff..acc31605e 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
@@ -53,7 +53,7 @@ public class TestTemplateInvocationTestDescriptor extends TestMethodTestDescript
 
 	@Override
 	public Set<ExclusiveResource> getExclusiveResources() {
-		// @ResourceLock annotations are already collected and returned by the enclosing container
+		// Resources are already collected and returned by the enclosing container
 		return emptySet();
 	}
 
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/LockTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/LockTests.java
new file mode 100644
index 000000000..c0cc1d0c3
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/LockTests.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015-2024 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.descriptor;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.parallel.ResourceAccessMode.READ;
+import static org.junit.jupiter.api.parallel.ResourceAccessMode.READ_WRITE;
+import static org.junit.jupiter.api.parallel.ResourceLocksProvider.Lock;
+
+import org.junit.jupiter.api.Test;
+import org.junit.platform.AbstractEqualsAndHashCodeTests;
+
+/**
+ * Unit tests for {@link Lock}.
+ *
+ * @since 5.12
+ */
+class LockTests extends AbstractEqualsAndHashCodeTests {
+
+	@Test
+	void readWriteModeSetByDefault() {
+		assertEquals(READ_WRITE, new Lock("a").getAccessMode());
+	}
+
+	@Test
+	void equalsAndHashCode() {
+		// @formatter:off
+		assertEqualsAndHashCode(
+				new Lock("a", READ_WRITE),
+				new Lock("a", READ_WRITE),
+				new Lock("b", READ_WRITE)
+		);
+		assertEqualsAndHashCode(
+				new Lock("a", READ_WRITE),
+				new Lock("a", READ_WRITE),
+				new Lock("a", READ)
+		);
+		// @formatter:on
+	}
+}
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ResourceLockAnnotationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ResourceLockAnnotationTests.java
new file mode 100644
index 000000000..414e31c96
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ResourceLockAnnotationTests.java
@@ -0,0 +1,391 @@
+/*
+ * Copyright 2015-2024 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.descriptor;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.lang.reflect.Method;
+import java.util.Set;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayNameGenerator;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ExecutionMode;
+import org.junit.jupiter.api.parallel.ResourceAccessMode;
+import org.junit.jupiter.api.parallel.ResourceLock;
+import org.junit.jupiter.api.parallel.ResourceLocksProvider;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
+
+/**
+ * Integration tests for {@link ResourceLock} and {@link ResourceLocksProvider}.
+ *
+ * @since 5.12
+ */
+class ResourceLockAnnotationTests {
+
+	private static final UniqueId uniqueId = UniqueId.root("enigma", "foo");
+
+	private final JupiterConfiguration configuration = mock();
+
+	@BeforeEach
+	void setUp() {
+		when(configuration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+		when(configuration.getDefaultExecutionMode()).thenReturn(ExecutionMode.SAME_THREAD);
+	}
+
+	@Test
+	void noSharedResources() {
+		// @formatter:off
+		var classResources = getClassResources(
+				NoSharedResourcesTestCase.class
+		);
+		assertThat(classResources).isEmpty();
+
+		var methodResources = getMethodResources(
+				NoSharedResourcesTestCase.class
+		);
+		assertThat(methodResources).isEmpty();
+
+		var nestedClassResources = getNestedClassResources(
+				NoSharedResourcesTestCase.class,
+				NoSharedResourcesTestCase.NestedClass.class
+		);
+		assertThat(nestedClassResources).isEmpty();
+		// @formatter:on
+	}
+
+	@Test
+	void addSharedResourcesViaAnnotationValue() {
+		// @formatter:off
+		var classResources = getClassResources(
+				SharedResourcesViaAnnotationValueTestCase.class
+		);
+		assertThat(classResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("a1", LockMode.READ_WRITE),
+				new ExclusiveResource("a2", LockMode.READ_WRITE)
+		);
+
+		var methodResources = getMethodResources(
+				SharedResourcesViaAnnotationValueTestCase.class
+		);
+		assertThat(methodResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("b1", LockMode.READ),
+				new ExclusiveResource("b2", LockMode.READ_WRITE)
+		);
+
+		var nestedClassResources = getNestedClassResources(
+				SharedResourcesViaAnnotationValueTestCase.class,
+				SharedResourcesViaAnnotationValueTestCase.NestedClass.class
+		);
+		assertThat(nestedClassResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("c1", LockMode.READ),
+				new ExclusiveResource("c2", LockMode.READ)
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void addSharedResourcesViaAnnotationProviders() {
+		// @formatter:off
+		var classResources = getClassResources(
+				SharedResourcesViaAnnotationProvidersTestCase.class
+		);
+		assertThat(classResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("a1", LockMode.READ),
+				new ExclusiveResource("a2", LockMode.READ)
+		);
+
+		var methodResources = getMethodResources(
+				SharedResourcesViaAnnotationProvidersTestCase.class
+		);
+		assertThat(methodResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("b1", LockMode.READ_WRITE),
+				new ExclusiveResource("b2", LockMode.READ_WRITE)
+		);
+
+		var nestedClassResources = getNestedClassResources(
+				SharedResourcesViaAnnotationProvidersTestCase.class,
+				SharedResourcesViaAnnotationProvidersTestCase.NestedClass.class
+		);
+		assertThat(nestedClassResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("c1", LockMode.READ_WRITE),
+				new ExclusiveResource("c2", LockMode.READ)
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void addSharedResourcesViaAnnotationValueAndProviders() {
+		// @formatter:off
+		var classResources = getClassResources(
+				SharedResourcesViaAnnotationValueAndProvidersTestCase.class
+		);
+		assertThat(classResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("a1", LockMode.READ_WRITE),
+				new ExclusiveResource("a2", LockMode.READ)
+		);
+
+		var methodResources = getMethodResources(
+				SharedResourcesViaAnnotationValueAndProvidersTestCase.class
+		);
+		assertThat(methodResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("b1", LockMode.READ),
+				new ExclusiveResource("b2", LockMode.READ)
+		);
+
+		var nestedClassResources = getNestedClassResources(
+				SharedResourcesViaAnnotationValueAndProvidersTestCase.class,
+				SharedResourcesViaAnnotationValueAndProvidersTestCase.NestedClass.class
+		);
+		assertThat(nestedClassResources).containsExactlyInAnyOrder(
+				new ExclusiveResource("c1", LockMode.READ_WRITE),
+				new ExclusiveResource("c2", LockMode.READ_WRITE),
+				new ExclusiveResource("c3", LockMode.READ_WRITE)
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void emptyAnnotation() {
+		// @formatter:off
+		var classResources = getClassResources(
+				EmptyAnnotationTestCase.class
+		);
+		assertThat(classResources).isEmpty();
+
+		var methodResources = getMethodResources(
+				EmptyAnnotationTestCase.class
+		);
+		assertThat(methodResources).isEmpty();
+
+		var nestedClassResources = getNestedClassResources(
+				EmptyAnnotationTestCase.class,
+				EmptyAnnotationTestCase.NestedClass.class
+		);
+		assertThat(nestedClassResources).isEmpty();
+		// @formatter:on
+	}
+
+	private Set<ExclusiveResource> getClassResources(Class<?> testClass) {
+		return getClassTestDescriptor(testClass).getExclusiveResources();
+	}
+
+	private ClassTestDescriptor getClassTestDescriptor(Class<?> testClass) {
+		return new ClassTestDescriptor(uniqueId, testClass, configuration);
+	}
+
+	private Set<ExclusiveResource> getMethodResources(Class<?> testClass) {
+		try {
+			// @formatter:off
+			var descriptor = new TestMethodTestDescriptor(
+				uniqueId, testClass, testClass.getDeclaredMethod("test"), configuration
+			);
+			// @formatter:on
+			descriptor.setParent(getClassTestDescriptor(testClass));
+			return descriptor.getExclusiveResources();
+		}
+		catch (NoSuchMethodException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	private Set<ExclusiveResource> getNestedClassResources(Class<?> testClass, Class<?> nestedClass) {
+		var descriptor = new NestedClassTestDescriptor(uniqueId, nestedClass, configuration);
+		descriptor.setParent(getClassTestDescriptor(testClass));
+		return descriptor.getExclusiveResources();
+	}
+
+	// -------------------------------------------------------------------------
+
+	static class NoSharedResourcesTestCase {
+
+		@Test
+		void test() {
+		}
+
+		@Nested
+		class NestedClass {
+		}
+	}
+
+	@ResourceLock("a1")
+	@ResourceLock(value = "a2", mode = ResourceAccessMode.READ_WRITE)
+	static class SharedResourcesViaAnnotationValueTestCase {
+
+		@Test
+		@ResourceLock(value = "b1", mode = ResourceAccessMode.READ)
+		@ResourceLock("b2")
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock(value = "c1", mode = ResourceAccessMode.READ)
+		@ResourceLock(value = "c2", mode = ResourceAccessMode.READ)
+		class NestedClass {
+		}
+	}
+
+	@ResourceLock(providers = { //
+			SharedResourcesViaAnnotationProvidersTestCase.FirstClassLevelProvider.class, //
+			SharedResourcesViaAnnotationProvidersTestCase.SecondClassLevelProvider.class //
+	})
+	static class SharedResourcesViaAnnotationProvidersTestCase {
+
+		@Test
+		@ResourceLock(providers = MethodLevelProvider.class)
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock(providers = NestedClassLevelProvider.class)
+		class NestedClass {
+		}
+
+		static class FirstClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				return Set.of(new Lock("a1", ResourceAccessMode.READ));
+			}
+		}
+
+		static class SecondClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				return Set.of(new Lock("a2", ResourceAccessMode.READ));
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				return Set.of(new Lock("b1"));
+			}
+		}
+
+		static class MethodLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				return Set.of(new Lock("b2"));
+			}
+		}
+
+		static class NestedClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				return Set.of(new Lock("c1"), new Lock("c2", ResourceAccessMode.READ));
+			}
+		}
+	}
+
+	@ResourceLock( //
+			value = "a1", //
+			mode = ResourceAccessMode.READ_WRITE, //
+			providers = SharedResourcesViaAnnotationValueAndProvidersTestCase.ClassLevelProvider.class //
+	)
+	static class SharedResourcesViaAnnotationValueAndProvidersTestCase {
+
+		@Test
+		@ResourceLock(value = "b1", mode = ResourceAccessMode.READ)
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock("c1")
+		@ResourceLock(providers = NestedClassLevelProvider.class)
+		class NestedClass {
+		}
+
+		static class ClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				return Set.of(new Lock("a2", ResourceAccessMode.READ));
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				return Set.of(new Lock("b2", ResourceAccessMode.READ));
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				return Set.of(new Lock("c2"));
+			}
+		}
+
+		static class NestedClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				return Set.of(new Lock("c3"));
+			}
+		}
+	}
+
+	@ResourceLock
+	static class EmptyAnnotationTestCase {
+
+		@Test
+		@ResourceLock
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock
+		class NestedClass {
+		}
+	}
+
+	static class NestedNestedTestCase {
+
+		@Nested
+		@ResourceLock(providers = NestedNestedTestCase.Provider.class)
+		static class NestedClass {
+
+			@Nested
+			class NestedClassTwo {
+
+				@Test
+				void test() {
+				}
+			}
+		}
+
+		static class Provider implements ResourceLocksProvider {
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				return ResourceLocksProvider.super.provideForClass(testClass);
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				return ResourceLocksProvider.super.provideForNestedClass(testClass);
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				return ResourceLocksProvider.super.provideForMethod(testClass, testMethod);
+			}
+		}
+	}
+
+}
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ResourceLocksProviderTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ResourceLocksProviderTests.java
new file mode 100644
index 000000000..f9b350ccb
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/ResourceLocksProviderTests.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright 2015-2024 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.descriptor;
+
+import static java.util.Collections.emptySet;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
+import static org.junit.platform.testkit.engine.EventConditions.event;
+import static org.junit.platform.testkit.engine.EventConditions.finishedSuccessfully;
+import static org.junit.platform.testkit.engine.EventConditions.test;
+
+import java.lang.reflect.Method;
+import java.util.Set;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
+import org.junit.jupiter.api.parallel.ResourceLocksProvider;
+import org.junit.platform.engine.discovery.DiscoverySelectors;
+import org.junit.platform.testkit.engine.EngineTestKit;
+import org.junit.platform.testkit.engine.Event;
+
+/**
+ * Integration tests for {@link ResourceLocksProvider}.
+ *
+ * @since 5.12
+ */
+class ResourceLocksProviderTests {
+
+	@Test
+	void classLevelProvider() {
+		var events = execute(ClassLevelProviderTestCase.class);
+		assertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);
+	}
+
+	@Test
+	void nestedClassLevelProvider() {
+		var events = execute(NestedClassLevelProviderTestCase.class);
+		assertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);
+	}
+
+	@Test
+	void methodLevelProvider() {
+		var events = execute(MethodLevelProviderTestCase.class);
+		assertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);
+	}
+
+	@Test
+	void methodLevelProviderInNestedClass() {
+		var events = execute(MethodLevelProviderInNestedClassTestCase.class);
+		assertThat(events.filter(event(test(), finishedSuccessfully())::matches)).hasSize(2);
+	}
+
+	private Stream<Event> execute(Class<?> testCase) {
+		// @formatter:off
+		var discoveryRequest = request()
+				.selectors(Stream.of(testCase).map(DiscoverySelectors::selectClass).toList())
+				.build();
+		return EngineTestKit.execute("junit-jupiter", discoveryRequest)
+				.allEvents()
+				.stream();
+		// @formatter:on
+	}
+
+	// -------------------------------------------------------------------------
+
+	@ResourceLock(providers = ClassLevelProviderTestCase.Provider.class)
+	static class ClassLevelProviderTestCase {
+
+		@Test
+		void test() {
+			assertTrue(Provider.isProvideForClassCalled, "'provideForClass' was not called");
+			assertTrue(Provider.isProvideForTestMethodCalled, "'provideForMethod(test)' was not called");
+		}
+
+		@Nested
+		class NestedClass {
+
+			@Test
+			void nestedTest() {
+				assertTrue(Provider.isProvideForNestedClassCalled, "'provideForNestedClass' was not called");
+				// @formatter:off
+				assertTrue(
+						Provider.isProvideForNestedTestMethodCalled,
+						"'provideForMethod(nestedTest)' was not called"
+				);
+				// @formatter:on
+			}
+		}
+
+		@AfterAll
+		static void afterAll() {
+			Provider.isProvideForClassCalled = false;
+			Provider.isProvideForTestMethodCalled = false;
+
+			Provider.isProvideForNestedClassCalled = false;
+			Provider.isProvideForNestedTestMethodCalled = false;
+		}
+
+		static class Provider implements ResourceLocksProvider {
+
+			private static boolean isProvideForClassCalled = false;
+			private static boolean isProvideForTestMethodCalled = false;
+
+			private static boolean isProvideForNestedClassCalled = false;
+			private static boolean isProvideForNestedTestMethodCalled = false;
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				isProvideForClassCalled = true;
+				assertEquals(ClassLevelProviderTestCase.class, testClass);
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				isProvideForNestedClassCalled = true;
+				assertEquals(ClassLevelProviderTestCase.NestedClass.class, testClass);
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				if (testClass == ClassLevelProviderTestCase.class) {
+					assertEquals("test", testMethod.getName());
+					isProvideForTestMethodCalled = true;
+					return emptySet();
+				}
+				if (testClass == ClassLevelProviderTestCase.NestedClass.class) {
+					assertEquals("nestedTest", testMethod.getName());
+					isProvideForNestedTestMethodCalled = true;
+					return emptySet();
+				}
+				fail("Unexpected test class: " + testClass);
+				return emptySet();
+			}
+		}
+	}
+
+	static class NestedClassLevelProviderTestCase {
+
+		@Test
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock(providers = NestedClassLevelProviderTestCase.Provider.class)
+		class NestedClass {
+
+			@Test
+			void nestedTest() {
+				assertTrue(Provider.isProvideForNestedClassCalled, "'provideForNestedClass' was not called");
+				assertTrue(Provider.isProvideForMethodCalled, "'provideForMethod' was not called");
+			}
+		}
+
+		@AfterAll
+		static void afterAll() {
+			Provider.isProvideForNestedClassCalled = false;
+			Provider.isProvideForMethodCalled = false;
+		}
+
+		static class Provider implements ResourceLocksProvider {
+
+			private static boolean isProvideForNestedClassCalled = false;
+
+			private static boolean isProvideForMethodCalled = false;
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				fail("'provideForClass' should not be called");
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				isProvideForNestedClassCalled = true;
+				assertEquals(NestedClass.class, testClass);
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				isProvideForMethodCalled = true;
+				assertEquals(NestedClassLevelProviderTestCase.NestedClass.class, testClass);
+				assertEquals("nestedTest", testMethod.getName());
+				return emptySet();
+			}
+		}
+	}
+
+	static class MethodLevelProviderTestCase {
+
+		@Test
+		@ResourceLock(providers = MethodLevelProviderTestCase.Provider.class)
+		void test() {
+			assertTrue(Provider.isProvideForMethodCalled, "'provideForMethod' was not called");
+		}
+
+		@Nested
+		class NestedClass {
+
+			@Test
+			void nestedTest() {
+			}
+		}
+
+		@AfterAll
+		static void afterAll() {
+			Provider.isProvideForMethodCalled = false;
+		}
+
+		static class Provider implements ResourceLocksProvider {
+
+			private static boolean isProvideForMethodCalled = false;
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				fail("'provideForClass' should not be called");
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				fail("'provideForNestedClass' should not be called");
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				isProvideForMethodCalled = true;
+				assertEquals(MethodLevelProviderTestCase.class, testClass);
+				assertEquals("test", testMethod.getName());
+				return emptySet();
+			}
+		}
+	}
+
+	static class MethodLevelProviderInNestedClassTestCase {
+
+		@Test
+		void test() {
+		}
+
+		@Nested
+		class NestedClass {
+
+			@Test
+			@ResourceLock(providers = MethodLevelProviderInNestedClassTestCase.Provider.class)
+			void nestedTest() {
+				assertTrue(Provider.isProvideForMethodCalled, "'provideForMethod' was not called");
+			}
+		}
+
+		@AfterAll
+		static void afterAll() {
+			Provider.isProvideForMethodCalled = false;
+		}
+
+		static class Provider implements ResourceLocksProvider {
+
+			private static boolean isProvideForMethodCalled = false;
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				fail("'provideForClass' should not be called");
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(Class<?> testClass) {
+				fail("'provideForNestedClass' should not be called");
+				return emptySet();
+			}
+
+			@Override
+			public Set<Lock> provideForMethod(Class<?> testClass, Method testMethod) {
+				isProvideForMethodCalled = true;
+				assertEquals(MethodLevelProviderInNestedClassTestCase.NestedClass.class, testClass);
+				assertEquals("nestedTest", testMethod.getName());
+				return emptySet();
+			}
+		}
+	}
+}
