diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
index 3102f9930..814267148 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
@@ -77,6 +77,8 @@ on GitHub.
 * A subset of the invocations of parameterized or dynamic tests can now be selected via
   the new `IterationSelector` discovery selector when launching the JUnit Platform.
 * `JAVA_19` has been added to the `JRE` enum for use with JRE-based execution conditions.
+* `@MethodSource` factory methods can now accept arguments resolved by registered
+  `ParameterResolver`.
 
 
 [[release-notes-5.9.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 8a1eed5c7..de0ff39dd 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1273,7 +1273,7 @@ or external classes.
 
 Factory methods within the test class must be `static` unless the test class is annotated
 with `@TestInstance(Lifecycle.PER_CLASS)`; whereas, factory methods in external classes
-must always be `static`. In addition, such factory methods must not accept any arguments.
+must always be `static`.
 
 Each factory method must generate a _stream_ of _arguments_, and each set of arguments
 within the stream will be provided as the physical arguments for individual invocations
@@ -1333,6 +1333,18 @@ package example;
 include::{testDir}/example/ExternalMethodSourceDemo.java[tags=external_MethodSource_example]
 ----
 
+Factory methods can declare parameters, which will be provided by registered implementations
+of `ParameterResolver`. In the following example, the factory method is referenced by its
+name since there's only one such method in the test class. If there are several methods with
+the same name, the factory method needs to be referenced by its fully qualified method name
+(e.g., `@MethodSource("example.MyTests#factoryMethodWithArguments(java.lang.String)")`).
+
+[source,java,indent=0]
+----
+include::{testDir}/example/MethodSourceParameterResolutionTestDemo.java[tags=parameter_resolution_MethodSource_example]
+----
+
+
 [[writing-tests-parameterized-tests-sources-CsvSource]]
 ===== @CsvSource
 
diff --git a/documentation/src/test/java/example/MethodSourceParameterResolutionTestDemo.java b/documentation/src/test/java/example/MethodSourceParameterResolutionTestDemo.java
new file mode 100644
index 000000000..9f0e93284
--- /dev/null
+++ b/documentation/src/test/java/example/MethodSourceParameterResolutionTestDemo.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class MethodSourceParameterResolutionTestDemo {
+
+	// @formatter:off
+	// tag::parameter_resolution_MethodSource_example[]
+	@RegisterExtension
+	static final IntegerResolver integerResolver = new IntegerResolver();
+
+	@ParameterizedTest
+	@MethodSource("factoryMethodWithArguments")
+	void testWithArgumentsProviderUsingParameterResolvers(String argument) {
+		assertTrue(argument.startsWith("2"));
+	}
+
+	static Stream<Arguments> factoryMethodWithArguments(int quantity) {
+		return Stream.of(
+				arguments(quantity + " apple"),
+				arguments(quantity + " lemon")
+		);
+	}
+
+	static class IntegerResolver implements ParameterResolver {
+
+		@Override
+		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+				throws ParameterResolutionException {
+			return parameterContext.getParameter().getType() == int.class;
+		}
+
+		@Override
+		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+				throws ParameterResolutionException {
+			return 2;
+		}
+
+	}
+	// end::parameter_resolution_MethodSource_example[]
+	// @formatter:on
+
+}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
index 27986cdd5..d8b52d473 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
@@ -15,6 +15,7 @@ import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.List;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -43,23 +44,21 @@ class MethodArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<M
 		// @formatter:off
 		return Arrays.stream(this.methodNames)
 				.map(factoryMethodName -> getMethod(context, factoryMethodName))
-				.map(method -> ReflectionUtils.invokeMethod(method, testInstance))
+				.map(method -> context.getExecutableInvoker().invoke(method, testInstance))
 				.flatMap(CollectionUtils::toStream)
 				.map(MethodArgumentsProvider::toArguments);
 		// @formatter:on
 	}
 
 	private Method getMethod(ExtensionContext context, String factoryMethodName) {
-		if (StringUtils.isNotBlank(factoryMethodName)) {
-			if (factoryMethodName.contains(".") || factoryMethodName.contains("#")) {
-				return getMethodByFullyQualifiedName(factoryMethodName);
-			}
-			else {
-				return ReflectionUtils.getRequiredMethod(context.getRequiredTestClass(), factoryMethodName);
-			}
+		if (StringUtils.isBlank(factoryMethodName)) {
+			return ReflectionUtils.getRequiredMethod(context.getRequiredTestClass(),
+				context.getRequiredTestMethod().getName());
 		}
-		return ReflectionUtils.getRequiredMethod(context.getRequiredTestClass(),
-			context.getRequiredTestMethod().getName());
+		if (factoryMethodName.contains(".") || factoryMethodName.contains("#")) {
+			return getMethodByFullyQualifiedName(factoryMethodName);
+		}
+		return getMethodByShortName(context.getRequiredTestClass(), factoryMethodName);
 	}
 
 	private Method getMethodByFullyQualifiedName(String fullyQualifiedMethodName) {
@@ -68,10 +67,19 @@ class MethodArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<M
 		String methodName = methodParts[1];
 		String methodParameters = methodParts[2];
 
-		Preconditions.condition(StringUtils.isBlank(methodParameters),
-			() -> format("factory method [%s] must not declare formal parameters", fullyQualifiedMethodName));
+		return ReflectionUtils.findMethod(loadRequiredClass(className), methodName, methodParameters).orElseThrow(
+			() -> new JUnitException(
+				format("Could not find method [%s(%s)] in class [%s]", methodName, methodParameters, className)));
+	}
 
-		return ReflectionUtils.getRequiredMethod(loadRequiredClass(className), methodName);
+	private Method getMethodByShortName(Class<?> testClass, String methodName) {
+		List<Method> methods = ReflectionUtils.findMethods(testClass, method -> method.getName().equals(methodName));
+		Preconditions.condition(methods.size() > 0,
+			() -> format("Could not find method [%s] in class [%s]", methodName, testClass.getName()));
+		Preconditions.condition(methods.size() <= 1,
+			() -> format("Several factory methods named [%s] were found in class [%s]", methodName,
+				testClass.getName()));
+		return methods.get(0);
 	}
 
 	private Class<?> loadRequiredClass(String className) {
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodSource.java
index baea1ad42..e8e280987 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodSource.java
@@ -87,8 +87,10 @@ import org.junit.jupiter.params.ParameterizedTest;
  * <p>Factory methods within the test class must be {@code static} unless the
  * {@link org.junit.jupiter.api.TestInstance.Lifecycle#PER_CLASS PER_CLASS}
  * test instance lifecycle mode is used; whereas, factory methods in external
- * classes must always be {@code static}. In any case, factory methods must not
- * declare any parameters.
+ * classes must always be {@code static}.
+ *
+ * <p>Factory methods can declare parameters, which will be provided by registered
+ * implementations of {@link org.junit.jupiter.api.extension.ParameterResolver}.
  *
  * @since 5.0
  * @see Arguments
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
index 0c74627aa..3f326864d 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
@@ -12,6 +12,7 @@ package org.junit.jupiter.params.provider;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.engine.extension.MutableExtensionRegistry.createRegistryWithDefaultExtensions;
 import static org.junit.jupiter.params.provider.MethodArgumentsProviderTests.DefaultFactoryMethodNameTestCase.TEST_METHOD;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
 import static org.mockito.Mockito.doCallRealMethod;
@@ -28,9 +29,16 @@ import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 import java.util.stream.Stream;
 
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.DefaultExecutableInvoker;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -40,6 +48,8 @@ import org.junit.platform.commons.util.ReflectionUtils;
  */
 class MethodArgumentsProviderTests {
 
+	private MutableExtensionRegistry extensionRegistry;
+
 	@Test
 	void throwsExceptionForIllegalReturnType() {
 		var exception = assertThrows(PreconditionViolationException.class,
@@ -232,15 +242,6 @@ class MethodArgumentsProviderTests {
 		assertThat(arguments).containsExactly(array("foo"), array("bar"), array("string1"), array("string2"));
 	}
 
-	@Test
-	void throwsExceptionWhenExternalFactoryMethodDeclaresParameters() {
-		var exception = assertThrows(PreconditionViolationException.class, () -> provideArguments(
-			ExternalFactoryMethods.class.getName() + "#methodWithParams(String, String)").toArray());
-
-		assertThat(exception.getMessage()).isEqualTo("factory method [" + ExternalFactoryMethods.class.getName()
-				+ "#methodWithParams(String, String)] must not declare formal parameters");
-	}
-
 	@Test
 	void throwsExceptionWhenClassForExternalFactoryMethodCannotBeLoaded() {
 		var exception = assertThrows(JUnitException.class,
@@ -256,7 +257,7 @@ class MethodArgumentsProviderTests {
 			() -> provideArguments(ExternalFactoryMethods.class.getName() + "#nonExistentMethod").toArray());
 
 		assertThat(exception.getMessage()).isEqualTo(
-			"Could not find method [nonExistentMethod] in class [" + ExternalFactoryMethods.class.getName() + "]");
+			"Could not find method [nonExistentMethod()] in class [" + ExternalFactoryMethods.class.getName() + "]");
 	}
 
 	@Test
@@ -357,6 +358,58 @@ class MethodArgumentsProviderTests {
 
 	}
 
+	@Nested
+	class ParameterResolution {
+
+		@BeforeEach
+		void registerParameterResolver() {
+			JupiterConfiguration configuration = mock(JupiterConfiguration.class);
+			extensionRegistry = createRegistryWithDefaultExtensions(configuration);
+			extensionRegistry.registerExtension(StringResolver.class);
+		}
+
+		@Test
+		void providesArgumentsUsingFactoryMethodWithParameter() {
+			var arguments = provideArguments("stringStreamProviderWithParameter");
+
+			assertThat(arguments).containsExactly(array("foo!"), array("bar!"));
+		}
+
+		@Test
+		void providesArgumentsUsingFullyQualifiedNameWithParameter() {
+			var arguments = provideArguments(
+				TestCase.class.getName() + "#stringStreamProviderWithParameter(java.lang.String)");
+
+			assertThat(arguments).containsExactly(array("foo!"), array("bar!"));
+		}
+
+		@Test
+		void throwExceptionWhenSeveralFactoryMethodsWithSameNameAreAvailable() {
+			var exception = assertThrows(PreconditionViolationException.class,
+				() -> provideArguments("stringStreamProviderWithOrWithoutParameter").toArray());
+
+			assertThat(exception.getMessage()).isEqualTo(
+				"Several factory methods named [stringStreamProviderWithOrWithoutParameter] were found in class [org.junit.jupiter.params.provider.MethodArgumentsProviderTests$TestCase]");
+		}
+
+		@Test
+		void providesArgumentsUsingFactoryMethodSelectedViaFullyQualifiedNameWithParameter() {
+			var arguments = provideArguments(
+				TestCase.class.getName() + "#stringStreamProviderWithOrWithoutParameter(java.lang.String)");
+
+			assertThat(arguments).containsExactly(array("foo!"), array("bar!"));
+		}
+
+		@Test
+		void providesArgumentsUsingFactoryMethodSelectedViaFullyQualifiedNameWithoutParameter() {
+			var arguments = provideArguments(
+				TestCase.class.getName() + "#stringStreamProviderWithOrWithoutParameter()");
+
+			assertThat(arguments).containsExactly(array("foo"), array("bar"));
+		}
+
+	}
+
 	// -------------------------------------------------------------------------
 
 	private static Object[] array(Object... objects) {
@@ -377,6 +430,8 @@ class MethodArgumentsProviderTests {
 		var extensionContext = mock(ExtensionContext.class);
 		when(extensionContext.getTestClass()).thenReturn(Optional.ofNullable(testClass));
 		when(extensionContext.getTestMethod()).thenReturn(Optional.ofNullable(testMethod));
+		when(extensionContext.getExecutableInvoker()).thenReturn(
+			new DefaultExecutableInvoker(extensionContext, extensionRegistry));
 
 		doCallRealMethod().when(extensionContext).getRequiredTestMethod();
 		doCallRealMethod().when(extensionContext).getRequiredTestClass();
@@ -449,6 +504,18 @@ class MethodArgumentsProviderTests {
 			return objectArrayStreamProvider().map(Arguments::of);
 		}
 
+		static Stream<String> stringStreamProviderWithParameter(String parameter) {
+			return Stream.of("foo" + parameter, "bar" + parameter);
+		}
+
+		static Stream<String> stringStreamProviderWithOrWithoutParameter() {
+			return stringStreamProvider();
+		}
+
+		static Stream<String> stringStreamProviderWithOrWithoutParameter(String parameter) {
+			return stringStreamProviderWithParameter(parameter);
+		}
+
 		// --- Iterable / Collection -------------------------------------------
 
 		static Iterable<String> stringIterableProvider() {
@@ -549,4 +616,19 @@ class MethodArgumentsProviderTests {
 		}
 	}
 
+	static class StringResolver implements ParameterResolver {
+
+		@Override
+		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+				throws ParameterResolutionException {
+			return parameterContext.getParameter().getType() == String.class;
+		}
+
+		@Override
+		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+				throws ParameterResolutionException {
+			return "!";
+		}
+	}
+
 }
