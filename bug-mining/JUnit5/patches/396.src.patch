diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
index f3d11a10e..ebff27d74 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
@@ -109,6 +109,8 @@ on GitHub.
   same functionality but a more descriptive name.
 * New `junit.jupiter.testmethod.order.default` configuration parameter to set the default
   `MethodOrderer` that will be used unless `@TestMethodOrder` is present.
+* New `DynamicTest.stream()` factory method that accepts a `Stream` instead of an
+  `Iterator` for the input source.
 * `@CsvFileSource` now allows one to specify file paths as an alternative to classpath
   resources.
 * Arguments in display names of parameterized test invocations are now truncated if
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 4b944ec57..d241da866 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1676,8 +1676,13 @@ behavior of `generateRandomNumberOfTests()` is of course in conflict with test
 repeatability and should thus be used with care, it serves to demonstrate the
 expressiveness and power of dynamic tests.
 
-The last method generates a nested hierarchy of dynamic tests utilizing
-`DynamicContainer`.
+The next method is similar to `generateRandomNumberOfTests()` in terms of flexibility;
+however, `dynamicTestsFromStreamFactoryMethod()` generates a stream of dynamic tests from
+an existing `Stream` via the `DynamicTest.stream()` factory method.
+
+For demonstration purposes, the `dynamicNodeSingleTest()` method generates a single
+`DynamicTest` instead of a stream, and the `dynamicNodeSingleContainer()` method generates
+a nested hierarchy of dynamic tests utilizing `DynamicContainer`.
 
 [source,java]
 ----
diff --git a/documentation/src/test/java/example/DynamicTestsDemo.java b/documentation/src/test/java/example/DynamicTestsDemo.java
index 8c4403551..8aa063a57 100644
--- a/documentation/src/test/java/example/DynamicTestsDemo.java
+++ b/documentation/src/test/java/example/DynamicTestsDemo.java
@@ -99,7 +99,7 @@ class DynamicTestsDemo {
 	}
 
 	@TestFactory
-	Stream<DynamicTest> generateRandomNumberOfTests() {
+	Stream<DynamicTest> generateRandomNumberOfTestsFromIterator() {
 
 		// Generates random positive integers between 0 and 100 until
 		// a number evenly divisible by 7 is encountered.
@@ -136,6 +136,21 @@ class DynamicTestsDemo {
 		return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
 	}
 
+	@TestFactory
+	Stream<DynamicTest> dynamicTestsFromStreamFactoryMethod() {
+		// Stream of palindromes to check
+		Stream<String> inputStream = Stream.of("racecar", "radar", "mom", "dad");
+
+		// Generates display names like: racecar is a palindrome
+		Function<String, String> displayNameGenerator = text -> text + " is a palindrome";
+
+		// Executes tests based on the current input value.
+		ThrowingConsumer<String> testExecutor = text -> assertTrue(isPalindrome(text));
+
+		// Returns a stream of dynamic tests.
+		return DynamicTest.stream(inputStream, displayNameGenerator, testExecutor);
+	}
+
 	@TestFactory
 	Stream<DynamicNode> dynamicTestsWithContainers() {
 		return Stream.of("A", "B", "C")
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java
index 726de11b1..b4b1ef0c3 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java
@@ -82,40 +82,77 @@ public class DynamicTest extends DynamicNode {
 	}
 
 	/**
-	 * Generate a stream of dynamic tests based on the supplied generators
-	 * and test executor.
+	 * Generate a stream of dynamic tests based on the given generator and test
+	 * executor.
 	 *
-	 * <p>Use this method when the set of dynamic tests is nondeterministic
-	 * in nature.
+	 * <p>Use this method when the set of dynamic tests is nondeterministic in
+	 * nature or when the input comes from an existing {@link Iterator}. See
+	 * {@link #stream(Stream, Function, ThrowingConsumer)} as an alternative.
 	 *
-	 * <p>The supplied {@code inputGenerator} is responsible for generating
+	 * <p>The given {@code inputGenerator} is responsible for generating
 	 * input values. A {@link DynamicTest} will be added to the resulting
-	 * stream for each dynamically generated input value, using the supplied
+	 * stream for each dynamically generated input value, using the given
 	 * {@code displayNameGenerator} and {@code testExecutor}.
 	 *
 	 * @param inputGenerator an {@code Iterator} that serves as a dynamic
 	 * <em>input generator</em>; never {@code null}
 	 * @param displayNameGenerator a function that generates a display name
 	 * based on an input value; never {@code null}
-	 * @param testExecutor a consumer that executes a test based on an
-	 * input value; never {@code null}
+	 * @param testExecutor a consumer that executes a test based on an input
+	 * value; never {@code null}
 	 * @param <T> the type of <em>input</em> generated by the {@code inputGenerator}
 	 * and used by the {@code displayNameGenerator} and {@code testExecutor}
-	 * @return a stream of dynamic tests based on the supplied generators and
+	 * @return a stream of dynamic tests based on the given generator and
 	 * executor; never {@code null}
 	 * @see #dynamicTest(String, Executable)
+	 * @see #stream(Stream, Function, ThrowingConsumer)
 	 */
 	public static <T> Stream<DynamicTest> stream(Iterator<T> inputGenerator,
 			Function<? super T, String> displayNameGenerator, ThrowingConsumer<? super T> testExecutor) {
 
 		Preconditions.notNull(inputGenerator, "inputGenerator must not be null");
+
+		return stream(StreamSupport.stream(spliteratorUnknownSize(inputGenerator, ORDERED), false),
+			displayNameGenerator, testExecutor);
+	}
+
+	/**
+	 * Generate a stream of dynamic tests based on the given input stream and
+	 * test executor.
+	 *
+	 * <p>Use this method when the set of dynamic tests is nondeterministic in
+	 * nature or when the input comes from an existing {@link Stream}. See
+	 * {@link #stream(Iterator, Function, ThrowingConsumer)} as an alternative.
+	 *
+	 * <p>The given {@code inputStream} is responsible for supplying input values.
+	 * A {@link DynamicTest} will be added to the resulting stream for each
+	 * dynamically supplied input value, using the given {@code displayNameGenerator}
+	 * and {@code testExecutor}.
+	 *
+	 * @param inputStream a {@code Stream} that supplies dynamic input values;
+	 * never {@code null}
+	 * @param displayNameGenerator a function that generates a display name
+	 * based on an input value; never {@code null}
+	 * @param testExecutor a consumer that executes a test based on an input
+	 * value; never {@code null}
+	 * @param <T> the type of <em>input</em> supplied by the {@code inputStream}
+	 * and used by the {@code displayNameGenerator} and {@code testExecutor}
+	 * @return a stream of dynamic tests based on the given generator and
+	 * executor; never {@code null}
+	 * @since 5.7
+	 * @see #dynamicTest(String, Executable)
+	 * @see #stream(Iterator, Function, ThrowingConsumer)
+	 */
+	@API(status = MAINTAINED, since = "5.7")
+	public static <T> Stream<DynamicTest> stream(Stream<T> inputStream,
+			Function<? super T, String> displayNameGenerator, ThrowingConsumer<? super T> testExecutor) {
+
+		Preconditions.notNull(inputStream, "inputStream must not be null");
 		Preconditions.notNull(displayNameGenerator, "displayNameGenerator must not be null");
 		Preconditions.notNull(testExecutor, "testExecutor must not be null");
 
-		// @formatter:off
-		return StreamSupport.stream(spliteratorUnknownSize(inputGenerator, ORDERED), false)
+		return inputStream //
 				.map(input -> dynamicTest(displayNameGenerator.apply(input), () -> testExecutor.accept(input)));
-		// @formatter:on
 	}
 
 	private final Executable executable;
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DynamicTestTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DynamicTestTests.java
index 6d7ed84f4..25527af98 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DynamicTestTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DynamicTestTests.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.api;
 
+import static java.util.Collections.emptyIterator;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
@@ -19,12 +20,15 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.URI;
 import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.function.Executable;
+import org.junit.jupiter.api.function.ThrowingConsumer;
+import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.support.ReflectionSupport;
 import org.opentest4j.AssertionFailedError;
 
@@ -38,10 +42,49 @@ class DynamicTestTests {
 
 	private final List<String> assertedValues = new ArrayList<>();
 
+	@Test
+	void streamFromStreamPreconditions() {
+		ThrowingConsumer<Object> testExecutor = input -> {
+		};
+		Function<Object, String> displayNameGenerator = Object::toString;
+
+		assertThrows(PreconditionViolationException.class,
+			() -> DynamicTest.stream((Stream<?>) null, displayNameGenerator, testExecutor));
+		assertThrows(PreconditionViolationException.class,
+			() -> DynamicTest.stream(Stream.empty(), null, testExecutor));
+		assertThrows(PreconditionViolationException.class,
+			() -> DynamicTest.stream(Stream.empty(), displayNameGenerator, null));
+	}
+
+	@Test
+	void streamFromIteratorPreconditions() {
+		ThrowingConsumer<Object> testExecutor = input -> {
+		};
+		Function<Object, String> displayNameGenerator = Object::toString;
+
+		assertThrows(PreconditionViolationException.class,
+			() -> DynamicTest.stream((Iterator<?>) null, displayNameGenerator, testExecutor));
+		assertThrows(PreconditionViolationException.class,
+			() -> DynamicTest.stream(emptyIterator(), null, testExecutor));
+		assertThrows(PreconditionViolationException.class,
+			() -> DynamicTest.stream(emptyIterator(), displayNameGenerator, null));
+	}
+
+	@Test
+	void streamFromStream() throws Throwable {
+		Stream<DynamicTest> stream = DynamicTest.stream(Stream.of("foo", "bar", "baz"), String::toUpperCase,
+			this::throwingConsumer);
+		assertStream(stream);
+	}
+
 	@Test
 	void streamFromIterator() throws Throwable {
-		Stream<DynamicTest> stream = DynamicTest.stream(Arrays.asList("foo", "bar", "baz").iterator(),
-			String::toUpperCase, this::throwingConsumer);
+		Stream<DynamicTest> stream = DynamicTest.stream(List.of("foo", "bar", "baz").iterator(), String::toUpperCase,
+			this::throwingConsumer);
+		assertStream(stream);
+	}
+
+	private void assertStream(Stream<DynamicTest> stream) throws Throwable {
 		List<DynamicTest> dynamicTests = stream.collect(Collectors.toList());
 
 		assertThat(dynamicTests).extracting(DynamicTest::getDisplayName).containsExactly("FOO", "BAR", "BAZ");
