diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M1.adoc
index 901247280..c30a31371 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M1.adoc
@@ -23,6 +23,8 @@ on GitHub.
 
 ==== New Features and Improvements
 
+* Configurable test discovery implementation that can be reused by different test engines
+  (see Javadoc of `org.junit.platform.engine.support.discovery`).
 * New `isFinal()` and `isNotFinal()` methods in `ModifierSupport`.
 
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/JupiterTestEngine.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/JupiterTestEngine.java
index f738b948a..310363537 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/JupiterTestEngine.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/JupiterTestEngine.java
@@ -66,7 +66,7 @@ public final class JupiterTestEngine extends HierarchicalTestEngine<JupiterEngin
 		JupiterConfiguration configuration = new CachingJupiterConfiguration(
 			new DefaultJupiterConfiguration(discoveryRequest.getConfigurationParameters()));
 		JupiterEngineDescriptor engineDescriptor = new JupiterEngineDescriptor(uniqueId, configuration);
-		new DiscoverySelectorResolver().resolveSelectors(discoveryRequest, configuration, engineDescriptor);
+		new DiscoverySelectorResolver().resolveSelectors(discoveryRequest, engineDescriptor);
 		return engineDescriptor;
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index 5fc435b89..f1ff5b10b 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -77,6 +77,7 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 @API(status = INTERNAL, since = "5.0")
 public class ClassTestDescriptor extends JupiterTestDescriptor {
 
+	public static final String SEGMENT_TYPE = "class";
 	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
 
 	private final Class<?> testClass;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
index e4ae516e8..46258291c 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
@@ -40,6 +40,7 @@ import org.junit.platform.engine.UniqueId;
 @API(status = INTERNAL, since = "5.0")
 public class NestedClassTestDescriptor extends ClassTestDescriptor {
 
+	public static final String SEGMENT_TYPE = "nested-class";
 	/**
 	 * Set of local class-level tags; does not contain tags from parent.
 	 */
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index 917a3986e..8df14f8ea 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -48,6 +48,7 @@ import org.junit.platform.engine.support.descriptor.UriSource;
 @API(status = INTERNAL, since = "5.0")
 public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implements Filterable {
 
+	public static final String SEGMENT_TYPE = "test-factory";
 	public static final String DYNAMIC_CONTAINER_SEGMENT_TYPE = "dynamic-container";
 	public static final String DYNAMIC_TEST_SEGMENT_TYPE = "dynamic-test";
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index 6c9a7ba33..d6019198f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -68,6 +68,7 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector.Executa
 @API(status = INTERNAL, since = "5.0")
 public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 
+	public static final String SEGMENT_TYPE = "method";
 	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
 	private static final Logger logger = LoggerFactory.getLogger(TestMethodTestDescriptor.class);
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
index 3cbc4f3bc..05e709bcf 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
@@ -40,6 +40,7 @@ import org.junit.platform.engine.UniqueId;
 @API(status = INTERNAL, since = "5.0")
 public class TestTemplateTestDescriptor extends MethodBasedTestDescriptor implements Filterable {
 
+	public static final String SEGMENT_TYPE = "test-template";
 	private final DynamicDescendantFilter dynamicDescendantFilter = new DynamicDescendantFilter();
 
 	public TestTemplateTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method templateMethod,
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractMethodResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractMethodResolver.java
deleted file mode 100644
index 099667de9..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractMethodResolver.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.lang.reflect.AnnotatedElement;
-import java.lang.reflect.Method;
-import java.util.Collections;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Predicate;
-
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
-import org.junit.platform.commons.util.ClassUtils;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * @since 5.0
- */
-abstract class AbstractMethodResolver implements ElementResolver {
-
-	private static final MethodFinder methodFinder = new MethodFinder();
-
-	private final String segmentType;
-	private final Predicate<Method> methodPredicate;
-	private final JupiterConfiguration configuration;
-
-	AbstractMethodResolver(String segmentType, Predicate<Method> methodPredicate, JupiterConfiguration configuration) {
-		this.segmentType = segmentType;
-		this.methodPredicate = methodPredicate;
-		this.configuration = configuration;
-	}
-
-	@Override
-	public Set<TestDescriptor> resolveElement(AnnotatedElement element, TestDescriptor parent) {
-		if (!(element instanceof Method)) {
-			return Collections.emptySet();
-		}
-
-		if (!(parent instanceof ClassTestDescriptor)) {
-			return Collections.emptySet();
-		}
-
-		Method method = (Method) element;
-		if (!isRelevantMethod(method)) {
-			return Collections.emptySet();
-		}
-
-		return Collections.singleton(createTestDescriptor(parent, method));
-	}
-
-	@Override
-	public Optional<TestDescriptor> resolveUniqueId(UniqueId.Segment segment, TestDescriptor parent) {
-		if (!segment.getType().equals(this.segmentType)) {
-			return Optional.empty();
-		}
-
-		if (!(parent instanceof ClassTestDescriptor)) {
-			return Optional.empty();
-		}
-
-		Optional<Method> optionalMethod = findMethod(segment, (ClassTestDescriptor) parent);
-		if (!optionalMethod.isPresent()) {
-			return Optional.empty();
-		}
-
-		Method method = optionalMethod.get();
-		if (!isRelevantMethod(method)) {
-			return Optional.empty();
-		}
-
-		return Optional.of(createTestDescriptor(parent, method));
-	}
-
-	private boolean isRelevantMethod(Method candidate) {
-		return methodPredicate.test(candidate);
-	}
-
-	private UniqueId createUniqueId(Method method, TestDescriptor parent) {
-		String methodId = String.format("%s(%s)", method.getName(),
-			ClassUtils.nullSafeToString(method.getParameterTypes()));
-		return parent.getUniqueId().append(this.segmentType, methodId);
-	}
-
-	private Optional<Method> findMethod(UniqueId.Segment segment, ClassTestDescriptor parent) {
-		return methodFinder.findMethod(segment.getValue(), parent.getTestClass());
-	}
-
-	private TestDescriptor createTestDescriptor(TestDescriptor parent, Method method) {
-		UniqueId uniqueId = createUniqueId(method, parent);
-		Class<?> testClass = ((ClassTestDescriptor) parent).getTestClass();
-		return createTestDescriptor(uniqueId, testClass, method, configuration);
-	}
-
-	protected abstract TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
-			JupiterConfiguration configuration);
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
new file mode 100644
index 000000000..b3ae23bf2
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.discovery;
+
+import static java.util.function.Predicate.isEqual;
+import static java.util.stream.Collectors.toCollection;
+import static org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests.isTestOrTestFactoryOrTestTemplateMethod;
+import static org.junit.platform.commons.support.ReflectionSupport.findNestedClasses;
+import static org.junit.platform.commons.util.FunctionUtils.where;
+import static org.junit.platform.commons.util.ReflectionUtils.findMethods;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
+import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.unresolved;
+
+import java.util.LinkedHashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
+import org.junit.jupiter.engine.discovery.predicates.IsNestedTestClass;
+import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.engine.DiscoverySelector;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.discovery.ClassSelector;
+import org.junit.platform.engine.discovery.DiscoverySelectors;
+import org.junit.platform.engine.discovery.MethodSelector;
+import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.support.discovery.SelectorResolver;
+
+/**
+ * @since 5.5
+ */
+class ClassSelectorResolver implements SelectorResolver {
+
+	private static final IsTestClassWithTests isTestClassWithTests = new IsTestClassWithTests();
+	private static final IsNestedTestClass isNestedTestClass = new IsNestedTestClass();
+
+	private final Predicate<String> classNameFilter;
+	private final JupiterConfiguration configuration;
+
+	ClassSelectorResolver(Predicate<String> classNameFilter, JupiterConfiguration configuration) {
+		this.classNameFilter = classNameFilter;
+		this.configuration = configuration;
+	}
+
+	@Override
+	public Resolution resolve(ClassSelector selector, Context context) {
+		Class<?> testClass = selector.getJavaClass();
+		if (isTestClassWithTests.test(testClass)) {
+			// Nested tests are never filtered out
+			if (classNameFilter.test(testClass.getName())) {
+				return toResolution(
+					context.addToParent(parent -> Optional.of(newClassTestDescriptor(parent, testClass))));
+			}
+		}
+		else if (isNestedTestClass.test(testClass)) {
+			return toResolution(context.addToParent(() -> selectClass(testClass.getEnclosingClass()),
+				parent -> Optional.of(newNestedClassTestDescriptor(parent, testClass))));
+		}
+		return unresolved();
+	}
+
+	@Override
+	public Resolution resolve(UniqueIdSelector selector, Context context) {
+		UniqueId uniqueId = selector.getUniqueId();
+		UniqueId.Segment lastSegment = uniqueId.getLastSegment();
+		if (ClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {
+			String className = lastSegment.getValue();
+			return ReflectionUtils.tryToLoadClass(className).toOptional().filter(isTestClassWithTests).map(
+				testClass -> toResolution(
+					context.addToParent(parent -> Optional.of(newClassTestDescriptor(parent, testClass))))).orElse(
+						unresolved());
+		}
+		if (NestedClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {
+			String simpleClassName = lastSegment.getValue();
+			return toResolution(context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
+				if (parent instanceof ClassTestDescriptor) {
+					Class<?> parentTestClass = ((ClassTestDescriptor) parent).getTestClass();
+					// TODO add test for resolving unique id of inherited nested test class
+					return ReflectionUtils.findNestedClasses(parentTestClass,
+						isNestedTestClass.and(
+							where(Class::getSimpleName, isEqual(simpleClassName)))).stream().findFirst().flatMap(
+								testClass -> Optional.of(newNestedClassTestDescriptor(parent, testClass)));
+				}
+				return Optional.empty();
+			}));
+		}
+		return unresolved();
+	}
+
+	private ClassTestDescriptor newClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {
+		return new ClassTestDescriptor(
+			parent.getUniqueId().append(ClassTestDescriptor.SEGMENT_TYPE, testClass.getName()), testClass,
+			configuration);
+	}
+
+	private NestedClassTestDescriptor newNestedClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {
+		return new NestedClassTestDescriptor(
+			parent.getUniqueId().append(NestedClassTestDescriptor.SEGMENT_TYPE, testClass.getSimpleName()), testClass,
+			configuration);
+	}
+
+	private Resolution toResolution(Optional<ClassTestDescriptor> testDescriptor) {
+		return testDescriptor.map(it -> {
+			Class<?> testClass = it.getTestClass();
+			// @formatter:off
+            return Resolution.match(Match.exact(it, () -> {
+                Stream<MethodSelector> methods = findMethods(testClass, isTestOrTestFactoryOrTestTemplateMethod).stream()
+                        .map(method -> selectMethod(testClass, method));
+				Stream<ClassSelector> nestedClasses = findNestedClasses(testClass, isNestedTestClass).stream()
+						.map(DiscoverySelectors::selectClass);
+				return Stream.concat(methods, nestedClasses).collect(toCollection((Supplier<Set<DiscoverySelector>>) LinkedHashSet::new));
+            }));
+            // @formatter:on
+		}).orElse(unresolved());
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoveryFilterApplier.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoveryFilterApplier.java
deleted file mode 100644
index 99b5883d0..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoveryFilterApplier.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.util.function.Predicate;
-
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
-import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
-import org.junit.platform.engine.TestDescriptor;
-
-/**
- * Class for applying filters to all children of a {@link TestDescriptor}.
- *
- * @since 5.0
- */
-class DiscoveryFilterApplier {
-
-	void applyClassNamePredicate(Predicate<String> classNamePredicate, TestDescriptor engineDescriptor) {
-		TestDescriptor.Visitor filteringVisitor = descriptor -> {
-			if (descriptor instanceof ClassTestDescriptor
-					&& !includeClass((ClassTestDescriptor) descriptor, classNamePredicate)) {
-				descriptor.removeFromHierarchy();
-			}
-		};
-		engineDescriptor.accept(filteringVisitor);
-	}
-
-	private boolean includeClass(ClassTestDescriptor classTestDescriptor, Predicate<String> classNamePredicate) {
-
-		// Nested Tests are never filtered out
-		if (classTestDescriptor instanceof NestedClassTestDescriptor) {
-			return true;
-		}
-
-		return classNamePredicate.test(classTestDescriptor.getTestClass().getName());
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
index 50773f00f..6d11feee4 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
@@ -11,23 +11,13 @@
 package org.junit.jupiter.engine.discovery;
 
 import static org.apiguardian.api.API.Status.INTERNAL;
-import static org.junit.platform.engine.support.filter.ClasspathScanningSupport.buildClassFilter;
-
-import java.util.LinkedHashSet;
-import java.util.Set;
 
 import org.apiguardian.api.API;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
 import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;
-import org.junit.platform.commons.util.ClassFilter;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.discovery.ClassSelector;
-import org.junit.platform.engine.discovery.ClasspathRootSelector;
-import org.junit.platform.engine.discovery.MethodSelector;
-import org.junit.platform.engine.discovery.ModuleSelector;
-import org.junit.platform.engine.discovery.PackageSelector;
-import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver;
 
 /**
  * {@code DiscoverySelectorResolver} resolves {@link TestDescriptor TestDescriptors}
@@ -37,53 +27,22 @@ import org.junit.platform.engine.discovery.UniqueIdSelector;
  * <p>This class is the only public entry point into the discovery package.
  *
  * @since 5.0
- * @see JavaElementsResolver
  */
 @API(status = INTERNAL, since = "5.0")
 public class DiscoverySelectorResolver {
 
-	private static final IsTestClassWithTests isTestClassWithTests = new IsTestClassWithTests();
-
-	public void resolveSelectors(EngineDiscoveryRequest request, JupiterConfiguration configuration,
-			TestDescriptor engineDescriptor) {
-		ClassFilter classFilter = buildClassFilter(request, isTestClassWithTests);
-		resolve(request, configuration, engineDescriptor, classFilter);
-		filter(engineDescriptor, classFilter);
-		pruneTree(engineDescriptor);
-	}
-
-	private void resolve(EngineDiscoveryRequest request, JupiterConfiguration configuration,
-			TestDescriptor engineDescriptor, ClassFilter classFilter) {
-		JavaElementsResolver javaElementsResolver = createJavaElementsResolver(configuration, engineDescriptor,
-			classFilter);
-
-		request.getSelectorsByType(ClasspathRootSelector.class).forEach(javaElementsResolver::resolveClasspathRoot);
-		request.getSelectorsByType(ModuleSelector.class).forEach(javaElementsResolver::resolveModule);
-		request.getSelectorsByType(PackageSelector.class).forEach(javaElementsResolver::resolvePackage);
-		request.getSelectorsByType(ClassSelector.class).forEach(javaElementsResolver::resolveClass);
-		request.getSelectorsByType(MethodSelector.class).forEach(javaElementsResolver::resolveMethod);
-		request.getSelectorsByType(UniqueIdSelector.class).forEach(javaElementsResolver::resolveUniqueId);
-	}
-
-	private void filter(TestDescriptor engineDescriptor, ClassFilter classFilter) {
-		new DiscoveryFilterApplier().applyClassNamePredicate(classFilter::match, engineDescriptor);
-	}
-
-	private void pruneTree(TestDescriptor rootDescriptor) {
-		rootDescriptor.accept(TestDescriptor::prune);
-	}
-
-	private JavaElementsResolver createJavaElementsResolver(JupiterConfiguration configuration,
-			TestDescriptor engineDescriptor, ClassFilter classFilter) {
-
-		Set<ElementResolver> resolvers = new LinkedHashSet<>();
-		resolvers.add(new TestContainerResolver(configuration));
-		resolvers.add(new NestedTestsResolver(configuration));
-		resolvers.add(new TestMethodResolver(configuration));
-		resolvers.add(new TestFactoryMethodResolver(configuration));
-		resolvers.add(new TestTemplateMethodResolver(configuration));
-
-		return new JavaElementsResolver(engineDescriptor, configuration, classFilter, resolvers);
+	// @formatter:off
+	private static final EngineDiscoveryRequestResolver<JupiterEngineDescriptor> resolver = EngineDiscoveryRequestResolver.<JupiterEngineDescriptor>builder()
+			.addClassContainerSelectorResolver(new IsTestClassWithTests())
+			.addSelectorResolver(context -> new ClassSelectorResolver(context.getClassNameFilter(), context.getEngineDescriptor().getConfiguration()))
+			.addSelectorResolver(context -> new MethodSelectorResolver(context.getEngineDescriptor().getConfiguration()))
+			.addTestDescriptorVisitor(context -> new MethodOrderingVisitor(context.getEngineDescriptor().getConfiguration()))
+			.addTestDescriptorVisitor(context -> TestDescriptor::prune)
+			.build();
+	// @formatter:on
+
+	public void resolveSelectors(EngineDiscoveryRequest request, JupiterEngineDescriptor engineDescriptor) {
+		resolver.resolve(request, engineDescriptor);
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ElementResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ElementResolver.java
deleted file mode 100644
index 5655f0a0f..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ElementResolver.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.lang.reflect.AnnotatedElement;
-import java.util.Optional;
-import java.util.Set;
-
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * @since 5.0
- */
-interface ElementResolver {
-
-	/**
-	 * Return a set of {@link TestDescriptor TestDescriptors} that can be
-	 * resolved by this resolver.
-	 *
-	 * <p>Returned set must be empty if {@code element} cannot be resolved.
-	 */
-	Set<TestDescriptor> resolveElement(AnnotatedElement element, TestDescriptor parent);
-
-	/**
-	 * Return an optional {@link TestDescriptor}.
-	 *
-	 * <p>Return {@code Optional.empty()} if {@code segment} cannot be resolved.
-	 */
-	Optional<TestDescriptor> resolveUniqueId(UniqueId.Segment segment, TestDescriptor parent);
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/JavaElementsResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/JavaElementsResolver.java
deleted file mode 100644
index 2d59b371c..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/JavaElementsResolver.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import static java.lang.String.format;
-import static java.util.stream.Collectors.toCollection;
-import static java.util.stream.Collectors.toList;
-import static java.util.stream.Collectors.toSet;
-import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
-import static org.junit.platform.commons.util.BlacklistedExceptions.rethrowIfBlacklisted;
-import static org.junit.platform.commons.util.ClassUtils.nullSafeToString;
-import static org.junit.platform.commons.util.ReflectionUtils.findAllClassesInClasspathRoot;
-import static org.junit.platform.commons.util.ReflectionUtils.findAllClassesInModule;
-import static org.junit.platform.commons.util.ReflectionUtils.findAllClassesInPackage;
-import static org.junit.platform.commons.util.ReflectionUtils.findMethods;
-import static org.junit.platform.commons.util.ReflectionUtils.findNestedClasses;
-
-import java.lang.reflect.AnnotatedElement;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Optional;
-import java.util.Set;
-
-import org.junit.jupiter.api.TestMethodOrder;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
-import org.junit.jupiter.engine.descriptor.Filterable;
-import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
-import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
-import org.junit.jupiter.engine.descriptor.MethodBasedTestDescriptor;
-import org.junit.jupiter.engine.discovery.predicates.IsInnerClass;
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.UniqueId.Segment;
-import org.junit.platform.engine.discovery.ClassSelector;
-import org.junit.platform.engine.discovery.ClasspathRootSelector;
-import org.junit.platform.engine.discovery.MethodSelector;
-import org.junit.platform.engine.discovery.ModuleSelector;
-import org.junit.platform.engine.discovery.PackageSelector;
-import org.junit.platform.engine.discovery.UniqueIdSelector;
-
-/**
- * <h3>NOTES TO DEVELOPERS</h3>
- *
- * <p>Any non-private method in this class is forbidden to throw any type of
- * exception other than a "blacklisted exception". All other exceptions must
- * be caught, logged, and swallowed in order to ensure the robustness of our
- * discovery mechanism.
- *
- * <p>Discovery errors related to Unique IDs that are particular to the Jupiter
- * test engine should be logged at WARNING level; whereas, all other discovery
- * errors should be logged at DEBUG level, since the Jupiter engine has no way
- * of knowing that it is supposed to actually handle those things (e.g.,
- * classpath roots, packages, etc. selected by a registered discovery selector).
- *
- * @since 5.0
- */
-class JavaElementsResolver {
-
-	private static final Logger logger = LoggerFactory.getLogger(JavaElementsResolver.class);
-
-	private static final IsInnerClass isInnerClass = new IsInnerClass();
-
-	private final TestDescriptor engineDescriptor;
-	private final JupiterConfiguration configuration;
-	private final ClassFilter classFilter;
-	private final Set<ElementResolver> resolvers;
-
-	JavaElementsResolver(TestDescriptor engineDescriptor, JupiterConfiguration configuration, ClassFilter classFilter,
-			Set<ElementResolver> resolvers) {
-
-		this.engineDescriptor = engineDescriptor;
-		this.configuration = configuration;
-		this.classFilter = classFilter;
-		this.resolvers = resolvers;
-	}
-
-	void resolveClasspathRoot(ClasspathRootSelector selector) {
-		try {
-			findAllClassesInClasspathRoot(selector.getClasspathRoot(), this.classFilter).forEach(this::resolveClass);
-		}
-		catch (Throwable t) {
-			rethrowIfBlacklisted(t);
-			logger.debug(t,
-				() -> format("Failed to resolve classes in classpath root '%s'.", selector.getClasspathRoot()));
-		}
-	}
-
-	void resolveModule(ModuleSelector selector) {
-		try {
-			findAllClassesInModule(selector.getModuleName(), this.classFilter).forEach(this::resolveClass);
-		}
-		catch (Throwable t) {
-			rethrowIfBlacklisted(t);
-			logger.debug(t, () -> format("Failed to resolve classes in module '%s'.", selector.getModuleName()));
-		}
-	}
-
-	void resolvePackage(PackageSelector selector) {
-		try {
-			findAllClassesInPackage(selector.getPackageName(), this.classFilter).forEach(this::resolveClass);
-		}
-		catch (Throwable t) {
-			rethrowIfBlacklisted(t);
-			logger.debug(t, () -> format("Failed to resolve classes in package '%s'.", selector.getPackageName()));
-		}
-	}
-
-	void resolveClass(ClassSelector selector) {
-		// Even though resolveClass(Class<?>) has its own similar try-catch block, the
-		// try-catch block is necessary here as well since ClassSelector#getJavaClass()
-		// may throw an exception.
-		try {
-			resolveClass(selector.getJavaClass());
-		}
-		catch (Throwable t) {
-			rethrowIfBlacklisted(t);
-			logger.debug(t, () -> format("Class '%s' could not be resolved.", selector.getClassName()));
-		}
-	}
-
-	private void resolveClass(Class<?> testClass) {
-		try {
-			Set<TestDescriptor> resolvedDescriptors = resolveContainerWithParents(testClass);
-			resolvedDescriptors.forEach(this::resolveChildren);
-
-			if (resolvedDescriptors.isEmpty()) {
-				logger.debug(() -> format("Class '%s' could not be resolved.", nullSafeToString(testClass)));
-			}
-		}
-		catch (Throwable t) {
-			rethrowIfBlacklisted(t);
-			logger.debug(t, () -> format("Class '%s' could not be resolved.", nullSafeToString(testClass)));
-		}
-	}
-
-	void resolveMethod(MethodSelector selector) {
-		try {
-			Class<?> testClass = selector.getJavaClass();
-			Method testMethod = selector.getJavaMethod();
-
-			Set<TestDescriptor> potentialParents = resolveContainerWithParents(testClass);
-			Set<TestDescriptor> resolvedDescriptors = resolveForAllParents(testMethod, potentialParents);
-
-			if (resolvedDescriptors.isEmpty()) {
-				logger.debug(() -> format("Method '%s' could not be resolved.", testMethod.toGenericString()));
-			}
-
-			logMultipleTestDescriptorsForSingleElement(testMethod, resolvedDescriptors);
-		}
-		catch (Throwable t) {
-			rethrowIfBlacklisted(t);
-			logger.debug(t, () -> format("Method '%s' in class '%s' could not be resolved.", selector.getMethodName(),
-				selector.getClassName()));
-		}
-	}
-
-	void resolveUniqueId(UniqueIdSelector selector) {
-		UniqueId uniqueId = selector.getUniqueId();
-
-		// Ignore Unique IDs from other test engines.
-		if (JupiterEngineDescriptor.ENGINE_ID.equals(uniqueId.getEngineId().orElse(null))) {
-			try {
-				Deque<TestDescriptor> resolvedDescriptors = resolveAllSegments(uniqueId);
-				handleResolvedDescriptorsForUniqueId(uniqueId, resolvedDescriptors);
-			}
-			catch (Throwable t) {
-				rethrowIfBlacklisted(t);
-				logger.warn(t, () -> format("Unique ID '%s' could not be resolved.", selector.getUniqueId()));
-			}
-		}
-	}
-
-	private Set<TestDescriptor> resolveContainerWithParents(Class<?> testClass) {
-		if (isInnerClass.test(testClass)) {
-			Set<TestDescriptor> potentialParents = resolveContainerWithParents(testClass.getDeclaringClass());
-			return resolveForAllParents(testClass, potentialParents);
-		}
-		else {
-			return resolveForAllParents(testClass, Collections.singleton(this.engineDescriptor));
-		}
-	}
-
-	/**
-	 * Attempt to resolve all segments for the supplied unique ID.
-	 */
-	private Deque<TestDescriptor> resolveAllSegments(UniqueId uniqueId) {
-		List<Segment> segments = uniqueId.getSegments();
-		Deque<TestDescriptor> resolvedDescriptors = new LinkedList<>();
-		resolvedDescriptors.addFirst(this.engineDescriptor);
-
-		for (int index = 1; index < segments.size() && resolvedDescriptors.size() == index; index++) {
-			Segment segment = segments.get(index);
-			TestDescriptor parent = resolvedDescriptors.getLast();
-			UniqueId partialUniqueId = parent.getUniqueId().append(segment);
-
-			Optional<TestDescriptor> resolvedDescriptor = findTestDescriptorByUniqueId(partialUniqueId);
-			if (!resolvedDescriptor.isPresent()) {
-				// @formatter:off
-				resolvedDescriptor = this.resolvers.stream()
-						.map(resolver -> resolver.resolveUniqueId(segment, parent))
-						.filter(Optional::isPresent)
-						.map(Optional::get)
-						.findFirst();
-				// @formatter:on
-				resolvedDescriptor.ifPresent(parent::addChild);
-			}
-			resolvedDescriptor.ifPresent(resolvedDescriptors::addLast);
-		}
-		return resolvedDescriptors;
-	}
-
-	private void handleResolvedDescriptorsForUniqueId(UniqueId uniqueId, Deque<TestDescriptor> resolvedDescriptors) {
-		List<Segment> segments = uniqueId.getSegments();
-		int numSegmentsToResolve = segments.size() - 1;
-		int numSegmentsResolved = resolvedDescriptors.size() - 1;
-
-		if (numSegmentsResolved == 0) {
-			logger.warn(() -> format("Unique ID '%s' could not be resolved.", uniqueId));
-		}
-		else if (numSegmentsResolved != numSegmentsToResolve) {
-			if (resolvedDescriptors.getLast() instanceof Filterable) {
-				((Filterable) resolvedDescriptors.getLast()).getDynamicDescendantFilter().allow(uniqueId);
-			}
-			else {
-				logger.warn(() -> {
-					List<Segment> unresolved = segments.subList(1, segments.size()); // Remove engine ID
-					unresolved = unresolved.subList(numSegmentsResolved, unresolved.size()); // Remove resolved segments
-					return format("Unique ID '%s' could only be partially resolved. "
-							+ "All resolved segments will be executed; however, the "
-							+ "following segments could not be resolved: %s",
-						uniqueId, unresolved);
-				});
-			}
-		}
-		else {
-			resolveChildren(resolvedDescriptors.getLast());
-		}
-	}
-
-	private Set<TestDescriptor> resolveContainerWithChildren(Class<?> containerClass,
-			Set<TestDescriptor> potentialParents) {
-
-		Set<TestDescriptor> resolvedDescriptors = resolveForAllParents(containerClass, potentialParents);
-		resolvedDescriptors.forEach(this::resolveChildren);
-		return resolvedDescriptors;
-	}
-
-	private Set<TestDescriptor> resolveForAllParents(AnnotatedElement element, Set<TestDescriptor> potentialParents) {
-		Set<TestDescriptor> resolvedDescriptors = new HashSet<>();
-		potentialParents.forEach(parent -> resolvedDescriptors.addAll(resolve(element, parent)));
-		// @formatter:off
-		resolvedDescriptors.stream()
-				.filter(Filterable.class::isInstance)
-				.map(Filterable.class::cast)
-				.forEach(testDescriptor -> testDescriptor.getDynamicDescendantFilter().allowAll());
-		// @formatter:on
-		return resolvedDescriptors;
-	}
-
-	private void resolveChildren(TestDescriptor descriptor) {
-		if (descriptor instanceof ClassTestDescriptor) {
-			ClassTestDescriptor classTestDescriptor = (ClassTestDescriptor) descriptor;
-			Class<?> testClass = classTestDescriptor.getTestClass();
-
-			resolveContainedMethods(classTestDescriptor, testClass);
-			orderContainedMethods(classTestDescriptor, testClass);
-			resolveContainedNestedClasses(classTestDescriptor, testClass);
-		}
-	}
-
-	/**
-	 * @since 5.4
-	 */
-	private void orderContainedMethods(ClassTestDescriptor classTestDescriptor, Class<?> testClass) {
-		findAnnotation(testClass, TestMethodOrder.class)//
-				.map(TestMethodOrder::value)//
-				.map(ReflectionUtils::newInstance)//
-				.ifPresent(methodOrderer -> {
-
-					List<DefaultMethodDescriptor> methodDescriptors = classTestDescriptor.getChildren().stream()//
-							.filter(MethodBasedTestDescriptor.class::isInstance)//
-							.map(MethodBasedTestDescriptor.class::cast)//
-							.map(DefaultMethodDescriptor::new)//
-							.collect(toCollection(ArrayList::new));
-
-					// Make a local copy for later validation
-					Set<DefaultMethodDescriptor> originalMethodDescriptors = new LinkedHashSet<>(methodDescriptors);
-
-					methodOrderer.orderMethods(
-						new DefaultMethodOrdererContext(methodDescriptors, testClass, this.configuration));
-
-					int difference = methodDescriptors.size() - originalMethodDescriptors.size();
-
-					if (difference > 0) {
-						logger.warn(() -> String.format(
-							"MethodOrderer [%s] added %s MethodDescriptor(s) for test class [%s] which will be ignored.",
-							methodOrderer.getClass().getName(), difference, testClass.getName()));
-					}
-					else if (difference < 0) {
-						logger.warn(() -> String.format(
-							"MethodOrderer [%s] removed %s MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.",
-							methodOrderer.getClass().getName(), -difference, testClass.getName()));
-					}
-
-					Set<TestDescriptor> sortedTestDescriptors = methodDescriptors.stream()//
-							.filter(originalMethodDescriptors::contains)//
-							.map(DefaultMethodDescriptor::getTestDescriptor)//
-							.collect(toCollection(LinkedHashSet::new));
-
-					// Currently no way to removeAll or addAll children at once.
-					sortedTestDescriptors.forEach(classTestDescriptor::removeChild);
-					sortedTestDescriptors.forEach(classTestDescriptor::addChild);
-
-					// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
-					// to be invoked after MethodOrderer#orderMethods().
-					methodOrderer.getDefaultExecutionMode()//
-							.map(JupiterTestDescriptor::toExecutionMode)//
-							.ifPresent(classTestDescriptor::setDefaultChildExecutionMode);
-				});
-	}
-
-	private void resolveContainedNestedClasses(TestDescriptor containerDescriptor, Class<?> clazz) {
-		List<Class<?>> nestedClassesCandidates = findNestedClasses(clazz, isInnerClass);
-		nestedClassesCandidates.forEach(
-			nestedClass -> resolveContainerWithChildren(nestedClass, Collections.singleton(containerDescriptor)));
-	}
-
-	private void resolveContainedMethods(TestDescriptor containerDescriptor, Class<?> testClass) {
-		List<Method> testMethodCandidates = findMethods(testClass, ReflectionUtils::isNotPrivate);
-		testMethodCandidates.forEach(method -> resolve(method, containerDescriptor));
-	}
-
-	private Set<TestDescriptor> resolve(AnnotatedElement element, TestDescriptor parent) {
-		Set<TestDescriptor> descriptors = this.resolvers.stream() //
-				.map(resolver -> tryToResolveWithResolver(element, parent, resolver)) //
-				.filter(testDescriptors -> !testDescriptors.isEmpty()) //
-				.flatMap(Collection::stream) //
-				.collect(toSet());
-
-		logMultipleTestDescriptorsForSingleElement(element, descriptors);
-
-		return descriptors;
-	}
-
-	private Set<TestDescriptor> tryToResolveWithResolver(AnnotatedElement element, TestDescriptor parent,
-			ElementResolver resolver) {
-
-		Set<TestDescriptor> resolvedDescriptors = resolver.resolveElement(element, parent);
-		Set<TestDescriptor> result = new LinkedHashSet<>();
-
-		resolvedDescriptors.forEach(testDescriptor -> {
-			Optional<TestDescriptor> existingTestDescriptor = findTestDescriptorByUniqueId(
-				testDescriptor.getUniqueId());
-			if (existingTestDescriptor.isPresent()) {
-				result.add(existingTestDescriptor.get());
-			}
-			else {
-				parent.addChild(testDescriptor);
-				result.add(testDescriptor);
-			}
-		});
-
-		return result;
-	}
-
-	@SuppressWarnings("unchecked")
-	private Optional<TestDescriptor> findTestDescriptorByUniqueId(UniqueId uniqueId) {
-		return (Optional<TestDescriptor>) this.engineDescriptor.findByUniqueId(uniqueId);
-	}
-
-	private void logMultipleTestDescriptorsForSingleElement(AnnotatedElement element, Set<TestDescriptor> descriptors) {
-		if (descriptors.size() > 1 && element instanceof Method) {
-			Method method = (Method) element;
-			logger.warn(() -> String.format(
-				"Possible configuration error: method [%s] resulted in multiple TestDescriptors %s. "
-						+ "This is typically the result of annotating a method with multiple competing annotations "
-						+ "such as @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, etc.",
-				method.toGenericString(), descriptors.stream().map(d -> d.getClass().getName()).collect(toList())));
-		}
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
new file mode 100644
index 000000000..95394debf
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.discovery;
+
+import static java.util.stream.Collectors.toCollection;
+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
+
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.TestMethodOrder;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
+import org.junit.jupiter.engine.descriptor.MethodBasedTestDescriptor;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.BlacklistedExceptions;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.engine.TestDescriptor;
+
+/**
+ * @since 5.5
+ */
+class MethodOrderingVisitor implements TestDescriptor.Visitor {
+
+	private static final Logger logger = LoggerFactory.getLogger(MethodOrderingVisitor.class);
+
+	private final JupiterConfiguration configuration;
+
+	MethodOrderingVisitor(JupiterConfiguration configuration) {
+		this.configuration = configuration;
+	}
+
+	@Override
+	public void visit(TestDescriptor testDescriptor) {
+		if (testDescriptor instanceof ClassTestDescriptor) {
+			ClassTestDescriptor classTestDescriptor = (ClassTestDescriptor) testDescriptor;
+			try {
+				orderContainedMethods(classTestDescriptor, classTestDescriptor.getTestClass());
+			}
+			catch (Throwable t) {
+				BlacklistedExceptions.rethrowIfBlacklisted(t);
+				logger.error(t, () -> "Failed to order methods for " + classTestDescriptor.getTestClass());
+			}
+		}
+	}
+
+	/**
+	 * @since 5.4
+	 */
+	private void orderContainedMethods(ClassTestDescriptor classTestDescriptor, Class<?> testClass) {
+		findAnnotation(testClass, TestMethodOrder.class)//
+				.map(TestMethodOrder::value)//
+				.map(ReflectionUtils::newInstance)//
+				.ifPresent(methodOrderer -> {
+
+					Set<? extends TestDescriptor> children = classTestDescriptor.getChildren();
+
+					List<TestDescriptor> nonMethodTestDescriptors = children.stream()//
+							.filter(testDescriptor -> !(testDescriptor instanceof MethodBasedTestDescriptor))//
+							.collect(Collectors.toList());
+
+					List<DefaultMethodDescriptor> methodDescriptors = children.stream()//
+							.filter(MethodBasedTestDescriptor.class::isInstance)//
+							.map(MethodBasedTestDescriptor.class::cast)//
+							.map(DefaultMethodDescriptor::new)//
+							.collect(toCollection(ArrayList::new));
+
+					// Make a local copy for later validation
+					Set<DefaultMethodDescriptor> originalMethodDescriptors = new LinkedHashSet<>(methodDescriptors);
+
+					methodOrderer.orderMethods(
+						new DefaultMethodOrdererContext(methodDescriptors, testClass, this.configuration));
+
+					int difference = methodDescriptors.size() - originalMethodDescriptors.size();
+
+					if (difference > 0) {
+						logger.warn(() -> String.format(
+							"MethodOrderer [%s] added %s MethodDescriptor(s) for test class [%s] which will be ignored.",
+							methodOrderer.getClass().getName(), difference, testClass.getName()));
+					}
+					else if (difference < 0) {
+						logger.warn(() -> String.format(
+							"MethodOrderer [%s] removed %s MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.",
+							methodOrderer.getClass().getName(), -difference, testClass.getName()));
+					}
+
+					Set<TestDescriptor> sortedMethodTestDescriptors = methodDescriptors.stream()//
+							.filter(originalMethodDescriptors::contains)//
+							.map(DefaultMethodDescriptor::getTestDescriptor)//
+							.collect(toCollection(LinkedHashSet::new));
+
+					// Currently no way to removeAll or addAll children at once.
+					Stream.concat(sortedMethodTestDescriptors.stream(), nonMethodTestDescriptors.stream())//
+							.forEach(classTestDescriptor::removeChild);
+					Stream.concat(sortedMethodTestDescriptors.stream(), nonMethodTestDescriptors.stream())//
+							.forEach(classTestDescriptor::addChild);
+
+					// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
+					// to be invoked after MethodOrderer#orderMethods().
+					methodOrderer.getDefaultExecutionMode()//
+							.map(JupiterTestDescriptor::toExecutionMode)//
+							.ifPresent(classTestDescriptor::setDefaultChildExecutionMode);
+				});
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
new file mode 100644
index 000000000..abab626a4
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.discovery;
+
+import static java.util.Collections.emptySet;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.toSet;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
+import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.matches;
+import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.unresolved;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.Filterable;
+import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;
+import org.junit.jupiter.engine.discovery.predicates.IsTestFactoryMethod;
+import org.junit.jupiter.engine.discovery.predicates.IsTestMethod;
+import org.junit.jupiter.engine.discovery.predicates.IsTestTemplateMethod;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.ClassUtils;
+import org.junit.platform.engine.DiscoverySelector;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.discovery.MethodSelector;
+import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.support.discovery.SelectorResolver;
+
+/**
+ * @since 5.5
+ */
+class MethodSelectorResolver implements SelectorResolver {
+
+	private static final Logger logger = LoggerFactory.getLogger(MethodSelectorResolver.class);
+	private static final MethodFinder methodFinder = new MethodFinder();
+
+	protected final JupiterConfiguration configuration;
+
+	MethodSelectorResolver(JupiterConfiguration configuration) {
+		this.configuration = configuration;
+	}
+
+	@Override
+	public Resolution resolve(MethodSelector selector, Context context) {
+		// @formatter:off
+		Set<Match> matches = Arrays.stream(MethodType.values())
+				.map(methodType -> methodType.resolveMethodSelector(selector, context, configuration))
+				.filter(Optional::isPresent)
+				.map(Optional::get)
+				.map(testDescriptor -> Match.exact(testDescriptor, expansionCallback(testDescriptor)))
+				.collect(toSet());
+		// @formatter:on
+		if (matches.size() > 1) {
+			logger.warn(() -> {
+				Stream<TestDescriptor> testDescriptors = matches.stream().map(Match::getTestDescriptor);
+				return String.format(
+					"Possible configuration error: method [%s] resulted in multiple TestDescriptors %s. "
+							+ "This is typically the result of annotating a method with multiple competing annotations "
+							+ "such as @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, etc.",
+					selector.getJavaMethod().toGenericString(),
+					testDescriptors.map(d -> d.getClass().getName()).collect(toList()));
+			});
+		}
+		return matches.isEmpty() ? unresolved() : matches(matches);
+	}
+
+	@Override
+	public Resolution resolve(UniqueIdSelector selector, Context context) {
+		UniqueId uniqueId = selector.getUniqueId();
+		// @formatter:off
+		return Arrays.stream(MethodType.values())
+				.map(methodType -> methodType.resolveUniqueIdIntoTestDescriptor(uniqueId, context, configuration))
+				.filter(Optional::isPresent)
+				.map(Optional::get)
+				.map(testDescriptor -> {
+					boolean exactMatch = uniqueId.equals(testDescriptor.getUniqueId());
+					if (testDescriptor instanceof Filterable) {
+						Filterable filterable = (Filterable) testDescriptor;
+						if (exactMatch) {
+							filterable.getDynamicDescendantFilter().allowAll();
+						}
+						else {
+							filterable.getDynamicDescendantFilter().allow(uniqueId);
+						}
+					}
+					return Resolution.match(exactMatch ? Match.exact(testDescriptor) : Match.partial(testDescriptor, expansionCallback(testDescriptor)));
+				})
+				.findFirst()
+				.orElse(unresolved());
+		// @formatter:on
+	}
+
+	private Supplier<Set<? extends DiscoverySelector>> expansionCallback(TestDescriptor testDescriptor) {
+		return () -> {
+			if (testDescriptor instanceof Filterable) {
+				((Filterable) testDescriptor).getDynamicDescendantFilter().allowAll();
+			}
+			return emptySet();
+		};
+	}
+
+	private enum MethodType {
+
+		TEST(new IsTestMethod(), TestMethodTestDescriptor.SEGMENT_TYPE) {
+			@Override
+			protected TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
+					JupiterConfiguration configuration) {
+				return new TestMethodTestDescriptor(uniqueId, testClass, method, configuration);
+			}
+		},
+
+		TEST_FACTORY(new IsTestFactoryMethod(), TestFactoryTestDescriptor.SEGMENT_TYPE,
+				TestFactoryTestDescriptor.DYNAMIC_CONTAINER_SEGMENT_TYPE,
+				TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE) {
+			@Override
+			protected TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
+					JupiterConfiguration configuration) {
+				return new TestFactoryTestDescriptor(uniqueId, testClass, method, configuration);
+			}
+		},
+
+		TEST_TEMPLATE(new IsTestTemplateMethod(), TestTemplateTestDescriptor.SEGMENT_TYPE,
+				TestTemplateInvocationTestDescriptor.SEGMENT_TYPE) {
+			@Override
+			protected TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
+					JupiterConfiguration configuration) {
+				return new TestTemplateTestDescriptor(uniqueId, testClass, method, configuration);
+			}
+		};
+
+		private final Predicate<Method> methodPredicate;
+		private final String segmentType;
+		private final Set<String> dynamicDescendantSegmentTypes;
+
+		MethodType(Predicate<Method> methodPredicate, String segmentType, String... dynamicDescendantSegmentTypes) {
+			this.methodPredicate = methodPredicate;
+			this.segmentType = segmentType;
+			this.dynamicDescendantSegmentTypes = new LinkedHashSet<>(Arrays.asList(dynamicDescendantSegmentTypes));
+		}
+
+		private Optional<TestDescriptor> resolveMethodSelector(MethodSelector selector, Context resolver,
+				JupiterConfiguration configuration) {
+			if (!methodPredicate.test(selector.getJavaMethod())) {
+				return Optional.empty();
+			}
+			Class<?> testClass = selector.getJavaClass();
+			Method method = selector.getJavaMethod();
+			return resolver.addToParent(() -> selectClass(testClass), //
+				parent -> Optional.of(
+					createTestDescriptor(createUniqueId(method, parent), testClass, method, configuration)));
+		}
+
+		private Optional<TestDescriptor> resolveUniqueIdIntoTestDescriptor(UniqueId uniqueId, Context context,
+				JupiterConfiguration configuration) {
+			UniqueId.Segment lastSegment = uniqueId.getLastSegment();
+			if (segmentType.equals(lastSegment.getType())) {
+				return context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
+					String methodSpecPart = lastSegment.getValue();
+					Class<?> testClass = ((ClassTestDescriptor) parent).getTestClass();
+					// @formatter:off
+					return methodFinder.findMethod(methodSpecPart, testClass)
+							.filter(methodPredicate)
+							.map(method -> createTestDescriptor(createUniqueId(method, parent), testClass, method, configuration));
+					// @formatter:on
+				});
+			}
+			if (dynamicDescendantSegmentTypes.contains(lastSegment.getType())) {
+				return resolveUniqueIdIntoTestDescriptor(uniqueId.removeLastSegment(), context, configuration);
+			}
+			return Optional.empty();
+		}
+
+		private UniqueId createUniqueId(Method method, TestDescriptor parent) {
+			String methodId = String.format("%s(%s)", method.getName(),
+				ClassUtils.nullSafeToString(method.getParameterTypes()));
+			return parent.getUniqueId().append(segmentType, methodId);
+		}
+
+		protected abstract TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
+				JupiterConfiguration configuration);
+
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/NestedTestsResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/NestedTestsResolver.java
deleted file mode 100644
index 6e2cf8d94..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/NestedTestsResolver.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
-import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
-import org.junit.jupiter.engine.discovery.predicates.IsNestedTestClass;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * @since 5.0
- */
-class NestedTestsResolver extends TestContainerResolver {
-
-	private static final IsNestedTestClass isNestedTestClass = new IsNestedTestClass();
-
-	static final String SEGMENT_TYPE = "nested-class";
-
-	public NestedTestsResolver(JupiterConfiguration configuration) {
-		super(configuration);
-	}
-
-	@Override
-	protected Class<? extends TestDescriptor> requiredParentType() {
-		return ClassTestDescriptor.class;
-	}
-
-	@Override
-	protected String getClassName(TestDescriptor parent, String segmentValue) {
-		return ((ClassTestDescriptor) parent).getTestClass().getName() + "$" + segmentValue;
-	}
-
-	@Override
-	protected String getSegmentType() {
-		return SEGMENT_TYPE;
-	}
-
-	@Override
-	protected String getSegmentValue(Class<?> testClass) {
-		return testClass.getSimpleName();
-	}
-
-	@Override
-	protected boolean isPotentialCandidate(Class<?> element) {
-		return isNestedTestClass.test(element);
-	}
-
-	@Override
-	protected TestDescriptor resolveClass(Class<?> testClass, UniqueId uniqueId) {
-		return new NestedClassTestDescriptor(uniqueId, testClass, this.configuration);
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestContainerResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestContainerResolver.java
deleted file mode 100644
index efc02c693..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestContainerResolver.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.lang.reflect.AnnotatedElement;
-import java.util.Collections;
-import java.util.Optional;
-import java.util.Set;
-
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
-import org.junit.jupiter.engine.discovery.predicates.IsPotentialTestContainer;
-import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * @since 5.0
- */
-class TestContainerResolver implements ElementResolver {
-
-	private static final IsPotentialTestContainer isPotentialTestContainer = new IsPotentialTestContainer();
-
-	static final String SEGMENT_TYPE = "class";
-
-	protected final JupiterConfiguration configuration;
-
-	public TestContainerResolver(JupiterConfiguration configuration) {
-		this.configuration = configuration;
-	}
-
-	@Override
-	public Set<TestDescriptor> resolveElement(AnnotatedElement element, TestDescriptor parent) {
-		if (!(element instanceof Class)) {
-			return Collections.emptySet();
-		}
-
-		Class<?> clazz = (Class<?>) element;
-		if (!isPotentialCandidate(clazz)) {
-			return Collections.emptySet();
-		}
-
-		UniqueId uniqueId = createUniqueId(clazz, parent);
-		return Collections.singleton(resolveClass(clazz, uniqueId));
-	}
-
-	@Override
-	public Optional<TestDescriptor> resolveUniqueId(UniqueId.Segment segment, TestDescriptor parent) {
-
-		if (!segment.getType().equals(getSegmentType())) {
-			return Optional.empty();
-		}
-
-		if (!requiredParentType().isInstance(parent)) {
-			return Optional.empty();
-		}
-
-		String className = getClassName(parent, segment.getValue());
-
-		Optional<Class<?>> optionalContainerClass = ReflectionUtils.tryToLoadClass(className).toOptional();
-		if (!optionalContainerClass.isPresent()) {
-			return Optional.empty();
-		}
-
-		Class<?> containerClass = optionalContainerClass.get();
-		if (!isPotentialCandidate(containerClass)) {
-			return Optional.empty();
-		}
-
-		UniqueId uniqueId = createUniqueId(containerClass, parent);
-		return Optional.of(resolveClass(containerClass, uniqueId));
-	}
-
-	protected Class<? extends TestDescriptor> requiredParentType() {
-		return TestDescriptor.class;
-	}
-
-	protected String getClassName(TestDescriptor parent, String segmentValue) {
-		return segmentValue;
-	}
-
-	protected String getSegmentType() {
-		return SEGMENT_TYPE;
-	}
-
-	protected String getSegmentValue(Class<?> testClass) {
-		return testClass.getName();
-	}
-
-	protected boolean isPotentialCandidate(Class<?> element) {
-		return isPotentialTestContainer.test(element);
-	}
-
-	protected UniqueId createUniqueId(Class<?> testClass, TestDescriptor parent) {
-		return parent.getUniqueId().append(getSegmentType(), getSegmentValue(testClass));
-	}
-
-	protected TestDescriptor resolveClass(Class<?> testClass, UniqueId uniqueId) {
-		return new ClassTestDescriptor(uniqueId, testClass, this.configuration);
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestFactoryMethodResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestFactoryMethodResolver.java
deleted file mode 100644
index ffc6af5cc..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestFactoryMethodResolver.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.lang.reflect.Method;
-import java.util.function.Predicate;
-
-import org.junit.jupiter.api.TestFactory;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
-import org.junit.jupiter.engine.discovery.predicates.IsTestFactoryMethod;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * {@code TestFactoryMethodResolver} is an {@link ElementResolver} that is
- * able to resolve methods annotated with {@link TestFactory @TestFactory}.
- *
- * <p>It creates {@link TestFactoryTestDescriptor} instances.
- *
- * @since 5.0
- * @see ElementResolver
- * @see TestFactory
- * @see TestFactoryTestDescriptor
- */
-class TestFactoryMethodResolver extends AbstractMethodResolver {
-
-	private static final Predicate<Method> isTestFactoryMethod = new IsTestFactoryMethod();
-
-	static final String SEGMENT_TYPE = "test-factory";
-
-	TestFactoryMethodResolver(JupiterConfiguration configuration) {
-		super(SEGMENT_TYPE, isTestFactoryMethod, configuration);
-	}
-
-	@Override
-	protected TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
-			JupiterConfiguration configuration) {
-		return new TestFactoryTestDescriptor(uniqueId, testClass, method, configuration);
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestMethodResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestMethodResolver.java
deleted file mode 100644
index be0846d13..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestMethodResolver.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.lang.reflect.Method;
-import java.util.function.Predicate;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
-import org.junit.jupiter.engine.discovery.predicates.IsTestMethod;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * {@code TestMethodResolver} is an {@link ElementResolver} that is able to
- * resolve methods annotated with {@link Test @Test}.
- *
- * <p>It creates {@link TestMethodTestDescriptor} instances.
- *
- * @since 5.0
- * @see ElementResolver
- * @see Test
- * @see TestMethodTestDescriptor
- */
-class TestMethodResolver extends AbstractMethodResolver {
-
-	private static final Predicate<Method> isTestMethod = new IsTestMethod();
-
-	static final String SEGMENT_TYPE = "method";
-
-	TestMethodResolver(JupiterConfiguration configuration) {
-		super(SEGMENT_TYPE, isTestMethod, configuration);
-	}
-
-	@Override
-	protected TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
-			JupiterConfiguration configuration) {
-		return new TestMethodTestDescriptor(uniqueId, testClass, method, configuration);
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestTemplateMethodResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestTemplateMethodResolver.java
deleted file mode 100644
index 7f60dcd06..000000000
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/TestTemplateMethodResolver.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import java.lang.reflect.Method;
-import java.util.function.Predicate;
-
-import org.junit.jupiter.api.TestTemplate;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;
-import org.junit.jupiter.engine.discovery.predicates.IsTestTemplateMethod;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * {@code TestTemplateMethodResolver} is an {@link ElementResolver} that is
- * able to resolve methods annotated with {@link TestTemplate @TestTemplate}.
- *
- * <p>It creates {@link TestTemplateTestDescriptor} instances.
- *
- * @since 5.0
- * @see ElementResolver
- * @see TestTemplate
- * @see TestTemplateTestDescriptor
- */
-class TestTemplateMethodResolver extends AbstractMethodResolver {
-
-	private static final Predicate<Method> isTestTemplateMethod = new IsTestTemplateMethod();
-
-	static final String SEGMENT_TYPE = "test-template";
-
-	TestTemplateMethodResolver(JupiterConfiguration configuration) {
-		super(SEGMENT_TYPE, isTestTemplateMethod, configuration);
-	}
-
-	@Override
-	protected TestDescriptor createTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method method,
-			JupiterConfiguration configuration) {
-		return new TestTemplateTestDescriptor(uniqueId, testClass, method, configuration);
-	}
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java
index b24ca4ac5..e815cb9e2 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/IsTestClassWithTests.java
@@ -33,7 +33,7 @@ public class IsTestClassWithTests implements Predicate<Class<?>> {
 
 	private static final IsTestTemplateMethod isTestTemplateMethod = new IsTestTemplateMethod();
 
-	private static final Predicate<Method> isTestOrTestFactoryOrTestTemplateMethod = isTestMethod.or(
+	public static final Predicate<Method> isTestOrTestFactoryOrTestTemplateMethod = isTestMethod.or(
 		isTestFactoryMethod).or(isTestTemplateMethod);
 
 	private static final IsPotentialTestContainer isPotentialTestContainer = new IsPotentialTestContainer();
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestDescriptorBuilder.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestDescriptorBuilder.java
deleted file mode 100644
index 0dcff07a3..000000000
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestDescriptorBuilder.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.descriptor;
-
-import static org.mockito.Mockito.mock;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * @since 5.0
- */
-public abstract class TestDescriptorBuilder<T extends TestDescriptor> {
-
-	private static final JupiterConfiguration configuration = mock(JupiterConfiguration.class);
-	final List<TestDescriptorBuilder<?>> children = new ArrayList<>();
-
-	public static JupiterEngineDescriptorBuilder engineDescriptor() {
-		return new JupiterEngineDescriptorBuilder();
-	}
-
-	public static ClassTestDescriptorBuilder classTestDescriptor(String uniqueId, Class<?> testClass) {
-		return new ClassTestDescriptorBuilder(uniqueId, testClass);
-	}
-
-	public static NestedClassTestDescriptorBuilder nestedClassTestDescriptor(String uniqueId, Class<?> testClass) {
-		return new NestedClassTestDescriptorBuilder(uniqueId, testClass);
-	}
-
-	public T build() {
-		T testDescriptor = buildDescriptor();
-		children.forEach(builder -> testDescriptor.addChild(builder.build()));
-		return testDescriptor;
-	}
-
-	public TestDescriptorBuilder<?> with(TestDescriptorBuilder<?>... children) {
-		Collections.addAll(this.children, children);
-		return this;
-	}
-
-	abstract T buildDescriptor();
-
-	public static class JupiterEngineDescriptorBuilder extends TestDescriptorBuilder<JupiterEngineDescriptor> {
-
-		@Override
-		JupiterEngineDescriptor buildDescriptor() {
-			return new JupiterEngineDescriptor(UniqueId.forEngine("junit-jupiter"), configuration);
-		}
-	}
-
-	public static class ClassTestDescriptorBuilder extends TestDescriptorBuilder<ClassTestDescriptor> {
-
-		protected final String uniqueId;
-		protected final Class<?> testClass;
-
-		public ClassTestDescriptorBuilder(String uniqueId, Class<?> testClass) {
-			this.uniqueId = uniqueId;
-			this.testClass = testClass;
-		}
-
-		@Override
-		ClassTestDescriptor buildDescriptor() {
-			return new ClassTestDescriptor(UniqueId.root("class", uniqueId), testClass, configuration);
-		}
-	}
-
-	public static class NestedClassTestDescriptorBuilder extends ClassTestDescriptorBuilder {
-
-		public NestedClassTestDescriptorBuilder(String uniqueId, Class<?> testClass) {
-			super(uniqueId, testClass);
-		}
-
-		@Override
-		NestedClassTestDescriptor buildDescriptor() {
-			return new NestedClassTestDescriptor(UniqueId.root("nested-class", uniqueId), testClass, configuration);
-		}
-	}
-
-}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryFilterApplierTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryFilterApplierTests.java
deleted file mode 100644
index c7304997e..000000000
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryFilterApplierTests.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.discovery;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.engine.descriptor.TestDescriptorBuilder.classTestDescriptor;
-import static org.junit.jupiter.engine.descriptor.TestDescriptorBuilder.engineDescriptor;
-import static org.junit.jupiter.engine.descriptor.TestDescriptorBuilder.nestedClassTestDescriptor;
-import static org.junit.platform.engine.Filter.composeFilters;
-import static org.junit.platform.engine.discovery.ClassNameFilter.includeClassNamePatterns;
-import static org.junit.platform.engine.discovery.PackageNameFilter.excludePackageNames;
-import static org.junit.platform.engine.discovery.PackageNameFilter.includePackageNames;
-
-import org.junit.jupiter.api.Nested;
-import org.junit.jupiter.api.Test;
-import org.junit.platform.engine.Filter;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-
-/**
- * Microtests for {@link DiscoveryFilterApplier}.
- *
- * @since 5.0
- */
-class DiscoveryFilterApplierTests {
-
-	@Test
-	void packageNameFilterInclude_nonMatchingPackagesAreExcluded() {
-		// @formatter:off
-		TestDescriptor engineDescriptor = engineDescriptor()
-				.with(
-						classTestDescriptor("matching", MatchingClass.class)
-				)
-				.build();
-		// @formatter:on
-
-		applyClassNamePredicate(engineDescriptor, includePackageNames("org.junit.jupiter.engine.unknown"));
-
-		assertThat(engineDescriptor.getDescendants()).isEmpty();
-	}
-
-	@Test
-	void packageNameFilterInclude_matchingPackagesAreIncluded() {
-
-		// @formatter:off
-		TestDescriptor engineDescriptor = engineDescriptor()
-				.with(
-						classTestDescriptor("matching", MatchingClass.class)
-				)
-				.build();
-
-		applyClassNamePredicate(engineDescriptor, includePackageNames("org.junit.jupiter.engine"));
-
-		assertThat(engineDescriptor.getDescendants())
-				.extracting(TestDescriptor::getUniqueId)
-				.containsExactly(UniqueId.root("class", "matching"));
-		// @formatter:on
-	}
-
-	@Test
-	void packageNameFilterExclude_matchingPackagesAreExcluded() {
-
-		// @formatter:off
-		TestDescriptor engineDescriptor = engineDescriptor()
-				.with(
-						classTestDescriptor("matching", MatchingClass.class)
-				)
-				.build();
-		// @formatter:on
-
-		applyClassNamePredicate(engineDescriptor, excludePackageNames("org.junit.jupiter.engine"));
-
-		assertThat(engineDescriptor.getDescendants()).isEmpty();
-	}
-
-	@Test
-	void packageNameFilterExclude_nonMatchingPackagesAreIncluded() {
-
-		// @formatter:off
-		TestDescriptor engineDescriptor = engineDescriptor()
-				.with(
-						classTestDescriptor("matching", MatchingClass.class)
-				)
-				.build();
-
-		applyClassNamePredicate(engineDescriptor, excludePackageNames("org.junit.jupiter.engine.unknown"));
-
-		assertThat(engineDescriptor.getDescendants())
-				.extracting(TestDescriptor::getUniqueId)
-				.containsExactly(UniqueId.root("class", "matching"));
-		// @formatter:on
-	}
-
-	@Test
-	void nonMatchingClassesAreExcluded() {
-
-		// @formatter:off
-		TestDescriptor engineDescriptor = engineDescriptor()
-				.with(
-						classTestDescriptor("matching", MatchingClass.class),
-						classTestDescriptor("other", OtherClass.class)
-				)
-				.build();
-
-		applyClassNamePredicate(engineDescriptor, includeClassNamePatterns(".*\\$MatchingClass"));
-
-		assertThat(engineDescriptor.getDescendants())
-				.extracting(TestDescriptor::getUniqueId)
-				.containsExactly(UniqueId.root("class", "matching"));
-		// @formatter:on
-	}
-
-	@Test
-	void nestedTestClassesAreAlwaysIncludedWhenTheirParentIs() {
-
-		// @formatter:off
-		TestDescriptor engineDescriptor = engineDescriptor()
-				.with(
-						classTestDescriptor("matching", MatchingClass.class)
-								.with(nestedClassTestDescriptor("nested", MatchingClass.NestedClass.class))
-				)
-				.build();
-
-		applyClassNamePredicate(engineDescriptor, includeClassNamePatterns(".*\\$MatchingClass"));
-
-		assertThat(engineDescriptor.getDescendants())
-				.extracting(TestDescriptor::getUniqueId)
-				.containsExactlyInAnyOrder(
-						UniqueId.root("class", "matching"),
-						UniqueId.root("nested-class", "nested")
-				);
-		// @formatter:on
-	}
-
-	private void applyClassNamePredicate(TestDescriptor engineDescriptor, Filter<String> filter) {
-		DiscoveryFilterApplier applier = new DiscoveryFilterApplier();
-		applier.applyClassNamePredicate(composeFilters(filter).toPredicate(), engineDescriptor);
-	}
-
-	private static class MatchingClass {
-		@Nested
-		class NestedClass {
-		}
-	}
-
-	private static class OtherClass {
-	}
-}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
index 5e16bb1dc..fca78112c 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
@@ -25,11 +25,14 @@ import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueId
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTestTemplateMethod;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTopLevelClass;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.engine.discovery.ClassNameFilter.includeClassNamePatterns;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClasspathRoots;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectPackage;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
+import static org.junit.platform.engine.discovery.PackageNameFilter.excludePackageNames;
+import static org.junit.platform.engine.discovery.PackageNameFilter.includePackageNames;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 import static org.mockito.Mockito.mock;
 
@@ -63,7 +66,6 @@ import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.commons.util.PreconditionViolationException;
 import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.discovery.ClassSelector;
@@ -71,21 +73,20 @@ import org.junit.platform.engine.discovery.ClasspathRootSelector;
 import org.junit.platform.engine.discovery.MethodSelector;
 import org.junit.platform.engine.discovery.PackageSelector;
 import org.junit.platform.engine.discovery.UniqueIdSelector;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver;
+import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
 
 /**
  * @since 5.0
  */
 class DiscoverySelectorResolverTests {
 
-	private final JupiterEngineDescriptor engineDescriptor = new JupiterEngineDescriptor(engineId(), null);
-	private final DiscoverySelectorResolver resolver = new DiscoverySelectorResolver();
 	private final JupiterConfiguration configuration = mock(JupiterConfiguration.class);
+	private final JupiterEngineDescriptor engineDescriptor = new JupiterEngineDescriptor(engineId(), configuration);
 
 	@Test
 	void nonTestClassResolution() {
-		resolver.resolveSelectors(request().selectors(selectClass(NonTestClass.class)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectClass(NonTestClass.class)));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 	}
@@ -93,19 +94,19 @@ class DiscoverySelectorResolverTests {
 	@Test
 	@TrackLogRecords
 	void abstractClassResolution(LogRecordListener listener) {
-		resolver.resolveSelectors(request().selectors(selectClass(AbstractTestClass.class)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectClass(AbstractTestClass.class)));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		assertThat(firstDebugLogRecord(listener).getMessage())//
-				.isEqualTo("Class 'org.junit.jupiter.engine.discovery.AbstractTestClass' could not be resolved.");
+				.isEqualTo(
+					"ClassSelector [className = '" + AbstractTestClass.class.getName() + "'] could not be resolved.");
 	}
 
 	@Test
 	void singleClassResolution() {
 		ClassSelector selector = selectClass(MyTestClass.class);
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(4, engineDescriptor.getDescendants().size());
 		assertUniqueIdsForMyTestClass(uniqueIds());
@@ -116,19 +117,19 @@ class DiscoverySelectorResolverTests {
 	void classResolutionForNonexistentClass(LogRecordListener listener) {
 		ClassSelector selector = selectClass("org.example.DoesNotExist");
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		assertThat(firstDebugLogRecord(listener).getMessage())//
-				.isEqualTo("Class 'org.example.DoesNotExist' could not be resolved.");
+				.isEqualTo("ClassSelector [className = 'org.example.DoesNotExist'] could not be resolved.");
 	}
 
 	@Test
 	void duplicateClassSelectorOnlyResolvesOnce() {
-		resolver.resolveSelectors(request().selectors( //
+		resolve(request().selectors( //
 			selectClass(MyTestClass.class), //
 			selectClass(MyTestClass.class) //
-		).build(), configuration, engineDescriptor);
+		));
 
 		assertEquals(4, engineDescriptor.getDescendants().size());
 		assertUniqueIdsForMyTestClass(uniqueIds());
@@ -139,7 +140,7 @@ class DiscoverySelectorResolverTests {
 		ClassSelector selector1 = selectClass(MyTestClass.class);
 		ClassSelector selector2 = selectClass(YourTestClass.class);
 
-		resolver.resolveSelectors(request().selectors(selector1, selector2).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector1, selector2));
 
 		assertEquals(7, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -160,7 +161,7 @@ class DiscoverySelectorResolverTests {
 	void classResolutionOfStaticNestedClass() {
 		ClassSelector selector = selectClass(OtherTestClass.NestedTestClass.class);
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(3, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -174,7 +175,7 @@ class DiscoverySelectorResolverTests {
 		Method test1 = MyTestClass.class.getDeclaredMethod("test1");
 		MethodSelector selector = selectMethod(test1.getDeclaringClass(), test1);
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(2, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -186,7 +187,7 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionFromInheritedMethod() throws NoSuchMethodException {
 		MethodSelector selector = selectMethod(HerTestClass.class, MyTestClass.class.getDeclaredMethod("test1"));
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(2, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -198,9 +199,8 @@ class DiscoverySelectorResolverTests {
 	void resolvingSelectorOfNonTestMethodResolvesNothing() throws NoSuchMethodException {
 		Method notATest = MyTestClass.class.getDeclaredMethod("notATest");
 		MethodSelector selector = selectMethod(notATest.getDeclaringClass(), notATest);
-		EngineDiscoveryRequest request = request().selectors(selector).build();
 
-		resolver.resolveSelectors(request, configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 	}
@@ -212,12 +212,13 @@ class DiscoverySelectorResolverTests {
 		String methodName = "bogus";
 		MethodSelector selector = selectMethod(className, methodName, "");
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		LogRecord logRecord = firstDebugLogRecord(listener);
 		assertThat(logRecord.getMessage())//
-				.isEqualTo("Method '" + methodName + "' in class '" + className + "' could not be resolved.");
+				.startsWith("MethodSelector").endsWith("could not be resolved.")//
+				.contains(className, methodName);
 		assertThat(logRecord.getThrown())//
 				.isInstanceOf(PreconditionViolationException.class)//
 				.hasMessageStartingWith("Could not load class with name: " + className);
@@ -228,18 +229,19 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionForNonexistentMethod(LogRecordListener listener) {
 		MethodSelector selector = selectMethod(MyTestClass.class, "bogus", "");
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		assertThat(firstDebugLogRecord(listener).getMessage())//
-				.isEqualTo("Method 'bogus' in class '" + MyTestClass.class.getName() + "' could not be resolved.");
+				.startsWith("MethodSelector").endsWith("could not be resolved.")//
+				.contains(MyTestClass.class.getName(), "bogus");
 	}
 
 	@Test
 	void classResolutionByUniqueId() {
 		UniqueIdSelector selector = selectUniqueId(uniqueIdForClass(MyTestClass.class).toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(4, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -250,7 +252,7 @@ class DiscoverySelectorResolverTests {
 	void staticNestedClassResolutionByUniqueId() {
 		UniqueIdSelector selector = selectUniqueId(uniqueIdForClass(OtherTestClass.NestedTestClass.class).toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(3, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -264,7 +266,7 @@ class DiscoverySelectorResolverTests {
 		UniqueIdSelector selector = selectUniqueId(
 			uniqueIdForMethod(OtherTestClass.NestedTestClass.class, "test5()").toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(2, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -277,21 +279,21 @@ class DiscoverySelectorResolverTests {
 	void resolvingUniqueIdWithUnknownSegmentTypeResolvesNothing(LogRecordListener listener) {
 		UniqueId uniqueId = engineId().append("bogus", "enigma");
 		UniqueIdSelector selector = selectUniqueId(uniqueId);
-		EngineDiscoveryRequest request = request().selectors(selector).build();
 
-		resolver.resolveSelectors(request, configuration, engineDescriptor);
+		resolve(request().selectors(selector));
+
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		assertThat(firstWarningLogRecord(listener).getMessage()) //
-				.isEqualTo("Unique ID '" + uniqueId + "' could not be resolved.");
+				.isEqualTo("UniqueIdSelector [uniqueId = " + uniqueId + "] could not be resolved.");
 	}
 
 	@Test
 	void resolvingUniqueIdOfNonTestMethodResolvesNothing() {
 		UniqueIdSelector selector = selectUniqueId(uniqueIdForMethod(MyTestClass.class, "notATest()"));
-		EngineDiscoveryRequest request = request().selectors(selector).build();
 
-		resolver.resolveSelectors(request, configuration, engineDescriptor);
-		assertTrue(engineDescriptor.getDescendants().isEmpty());
+		resolve(request().selectors(selector));
+
+		assertThat(engineDescriptor.getDescendants()).isEmpty();
 	}
 
 	@Test
@@ -299,12 +301,12 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionByUniqueIdWithMissingMethodName(LogRecordListener listener) {
 		UniqueId uniqueId = uniqueIdForMethod(getClass(), "()");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(uniqueId)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(uniqueId)));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		LogRecord logRecord = firstWarningLogRecord(listener);
-		assertThat(logRecord.getMessage()).isEqualTo("Unique ID '" + uniqueId + "' could not be resolved.");
+		assertThat(logRecord.getMessage()).isEqualTo(
+			"UniqueIdSelector [uniqueId = " + uniqueId + "] could not be resolved.");
 		assertThat(logRecord.getThrown())//
 				.isInstanceOf(PreconditionViolationException.class)//
 				.hasMessageStartingWith("Method [()] does not match pattern");
@@ -315,12 +317,12 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionByUniqueIdWithMissingParameters(LogRecordListener listener) {
 		UniqueId uniqueId = uniqueIdForMethod(getClass(), "methodName");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(uniqueId)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(uniqueId)));
 
-		assertTrue(engineDescriptor.getDescendants().isEmpty());
+		assertThat(engineDescriptor.getDescendants()).isEmpty();
 		LogRecord logRecord = firstWarningLogRecord(listener);
-		assertThat(logRecord.getMessage()).isEqualTo("Unique ID '" + uniqueId + "' could not be resolved.");
+		assertThat(logRecord.getMessage()).isEqualTo(
+			"UniqueIdSelector [uniqueId = " + uniqueId + "] could not be resolved.");
 		assertThat(logRecord.getThrown())//
 				.isInstanceOf(PreconditionViolationException.class)//
 				.hasMessageStartingWith("Method [methodName] does not match pattern");
@@ -331,12 +333,12 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionByUniqueIdWithBogusParameters(LogRecordListener listener) {
 		UniqueId uniqueId = uniqueIdForMethod(getClass(), "methodName(java.lang.String, junit.foo.Enigma)");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(uniqueId)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(uniqueId)));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		LogRecord logRecord = firstWarningLogRecord(listener);
-		assertThat(logRecord.getMessage()).isEqualTo("Unique ID '" + uniqueId + "' could not be resolved.");
+		assertThat(logRecord.getMessage()).isEqualTo(
+			"UniqueIdSelector [uniqueId = " + uniqueId + "] could not be resolved.");
 		assertThat(logRecord.getThrown())//
 				.isInstanceOf(JUnitException.class)//
 				.hasMessage("Failed to load parameter type [%s] for method [%s] in class [%s].", "junit.foo.Enigma",
@@ -347,7 +349,7 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionByUniqueId() {
 		UniqueIdSelector selector = selectUniqueId(uniqueIdForMethod(MyTestClass.class, "test1()").toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(2, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -359,7 +361,7 @@ class DiscoverySelectorResolverTests {
 	void methodResolutionByUniqueIdFromInheritedClass() {
 		UniqueIdSelector selector = selectUniqueId(uniqueIdForMethod(HerTestClass.class, "test1()").toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(2, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -374,29 +376,25 @@ class DiscoverySelectorResolverTests {
 		UniqueIdSelector selector = selectUniqueId(
 			uniqueIdForMethod(HerTestClass.class, "test7(java.lang.String)").toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(2, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
 		assertThat(uniqueIds).contains(uniqueIdForClass(HerTestClass.class));
 		assertThat(uniqueIds).contains(uniqueIdForMethod(HerTestClass.class, "test7(java.lang.String)"));
 
-		assertZeroLogRecords(listener);
 	}
 
 	@Test
 	@TrackLogRecords
 	void resolvingUniqueIdWithWrongParamsResolvesNothing(LogRecordListener listener) {
 		UniqueId uniqueId = uniqueIdForMethod(HerTestClass.class, "test7(java.math.BigDecimal)");
-		EngineDiscoveryRequest request = request().selectors(selectUniqueId(uniqueId)).build();
 
-		resolver.resolveSelectors(request, configuration, engineDescriptor);
+		resolve(request().selectors(selectUniqueId(uniqueId)));
 
 		assertTrue(engineDescriptor.getDescendants().isEmpty());
 		assertThat(firstWarningLogRecord(listener).getMessage())//
-				.isEqualTo("Unique ID '" + uniqueId + "' could only be partially resolved. "
-						+ "All resolved segments will be executed; however, the following segments "
-						+ "could not be resolved: [Segment [type = 'method', value = 'test7(java.math.BigDecimal)']]");
+				.isEqualTo("UniqueIdSelector [uniqueId = " + uniqueId + "] could not be resolved.");
 	}
 
 	@Test
@@ -405,8 +403,7 @@ class DiscoverySelectorResolverTests {
 		UniqueIdSelector selector2 = selectUniqueId(uniqueIdForMethod(MyTestClass.class, "test2()").toString());
 
 		// adding same selector twice should have no effect
-		resolver.resolveSelectors(request().selectors(selector1, selector2, selector2).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selector1, selector2, selector2));
 
 		assertEquals(3, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -427,7 +424,7 @@ class DiscoverySelectorResolverTests {
 	void packageResolutionUsingExplicitBasePackage() {
 		PackageSelector selector = selectPackage("org.junit.jupiter.engine.descriptor.subpackage");
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(6, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -441,7 +438,7 @@ class DiscoverySelectorResolverTests {
 
 	@Test
 	void packageResolutionUsingDefaultPackage() throws Exception {
-		resolver.resolveSelectors(request().selectors(selectPackage("")).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selectPackage("")));
 
 		// 150 is completely arbitrary. The actual number is likely much higher.
 		assertThat(engineDescriptor.getDescendants().size())//
@@ -465,7 +462,7 @@ class DiscoverySelectorResolverTests {
 
 		List<ClasspathRootSelector> selectors = selectClasspathRoots(singleton(classpath));
 
-		resolver.resolveSelectors(request().selectors(selectors).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selectors));
 
 		// 150 is completely arbitrary. The actual number is likely much higher.
 		assertThat(engineDescriptor.getDescendants().size())//
@@ -494,7 +491,7 @@ class DiscoverySelectorResolverTests {
 		try (URLClassLoader classLoader = new URLClassLoader(new URL[] { jarUrl })) {
 			Thread.currentThread().setContextClassLoader(classLoader);
 
-			resolver.resolveSelectors(request().selectors(selectors).build(), configuration, engineDescriptor);
+			resolve(request().selectors(selectors));
 
 			assertThat(uniqueIds()) //
 					.contains(uniqueIdForTopLevelClass("com.example.project.FirstTest")) //
@@ -509,10 +506,10 @@ class DiscoverySelectorResolverTests {
 	void nestedTestResolutionFromBaseClass() {
 		ClassSelector selector = selectClass(TestCaseWithNesting.class);
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		List<UniqueId> uniqueIds = uniqueIds();
-		assertEquals(6, uniqueIds.size());
+		assertThat(uniqueIds).hasSize(6);
 
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.class));
 		assertThat(uniqueIds).contains(uniqueIdForMethod(TestCaseWithNesting.class, "testA()"));
@@ -527,10 +524,10 @@ class DiscoverySelectorResolverTests {
 	void nestedTestResolutionFromNestedTestClass() {
 		ClassSelector selector = selectClass(TestCaseWithNesting.NestedTestCase.class);
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		List<UniqueId> uniqueIds = uniqueIds();
-		assertEquals(5, uniqueIds.size());
+		assertThat(uniqueIds).hasSize(5);
 
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.class));
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.NestedTestCase.class));
@@ -545,10 +542,10 @@ class DiscoverySelectorResolverTests {
 		UniqueIdSelector selector = selectUniqueId(
 			uniqueIdForClass(TestCaseWithNesting.NestedTestCase.DoubleNestedTestCase.class).toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		List<UniqueId> uniqueIds = uniqueIds();
-		assertEquals(4, uniqueIds.size());
+		assertThat(uniqueIds).hasSize(4);
 
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.class));
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.NestedTestCase.class));
@@ -561,10 +558,10 @@ class DiscoverySelectorResolverTests {
 	void doubleNestedTestResolutionFromClass() {
 		ClassSelector selector = selectClass(TestCaseWithNesting.NestedTestCase.DoubleNestedTestCase.class);
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		List<UniqueId> uniqueIds = uniqueIds();
-		assertEquals(4, uniqueIds.size());
+		assertThat(uniqueIds).hasSize(4);
 
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.class));
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.NestedTestCase.class));
@@ -578,7 +575,7 @@ class DiscoverySelectorResolverTests {
 		MethodSelector selector = selectMethod(TestCaseWithNesting.NestedTestCase.DoubleNestedTestCase.class,
 			TestCaseWithNesting.NestedTestCase.DoubleNestedTestCase.class.getDeclaredMethod("testC"));
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		assertEquals(4, engineDescriptor.getDescendants().size());
 		List<UniqueId> uniqueIds = uniqueIds();
@@ -594,10 +591,10 @@ class DiscoverySelectorResolverTests {
 		UniqueIdSelector selector = selectUniqueId(
 			uniqueIdForMethod(TestCaseWithNesting.NestedTestCase.class, "testB()").toString());
 
-		resolver.resolveSelectors(request().selectors(selector).build(), configuration, engineDescriptor);
+		resolve(request().selectors(selector));
 
 		List<UniqueId> uniqueIds = uniqueIds();
-		assertEquals(3, uniqueIds.size());
+		assertThat(uniqueIds).hasSize(3);
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.class));
 		assertThat(uniqueIds).contains(uniqueIdForClass(TestCaseWithNesting.NestedTestCase.class));
 		assertThat(uniqueIds).contains(uniqueIdForMethod(TestCaseWithNesting.NestedTestCase.class, "testB()"));
@@ -608,8 +605,7 @@ class DiscoverySelectorResolverTests {
 		Class<?> clazz = MyTestClass.class;
 		UniqueId factoryUid = uniqueIdForTestFactoryMethod(clazz, "dynamicTest()");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(factoryUid)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(factoryUid)));
 
 		assertThat(engineDescriptor.getDescendants()).hasSize(2);
 		assertThat(uniqueIds()).containsSequence(uniqueIdForClass(clazz), factoryUid);
@@ -620,8 +616,7 @@ class DiscoverySelectorResolverTests {
 		Class<?> clazz = TestClassWithTemplate.class;
 		UniqueId templateUid = uniqueIdForTestTemplateMethod(clazz, "testTemplate()");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(templateUid)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(templateUid)));
 
 		assertThat(engineDescriptor.getDescendants()).hasSize(2);
 		assertThat(uniqueIds()).containsSequence(uniqueIdForClass(clazz), templateUid);
@@ -635,8 +630,7 @@ class DiscoverySelectorResolverTests {
 		UniqueId dynamicTestUid = factoryUid.append(DYNAMIC_TEST_SEGMENT_TYPE, "#1");
 		UniqueId differentDynamicTestUid = factoryUid.append(DYNAMIC_TEST_SEGMENT_TYPE, "#2");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(dynamicTestUid)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(dynamicTestUid)));
 
 		assertThat(engineDescriptor.getDescendants()).hasSize(2);
 		assertThat(uniqueIds()).containsSequence(uniqueIdForClass(clazz), factoryUid);
@@ -660,8 +654,7 @@ class DiscoverySelectorResolverTests {
 		UniqueId dynamicTestUid = dynamicContainerUid.append(DYNAMIC_TEST_SEGMENT_TYPE, "#1");
 		UniqueId differentDynamicTestUid = dynamicContainerUid.append(DYNAMIC_TEST_SEGMENT_TYPE, "#2");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(dynamicTestUid)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(dynamicTestUid)));
 
 		assertThat(engineDescriptor.getDescendants()).hasSize(2);
 		assertThat(uniqueIds()).containsSequence(uniqueIdForClass(clazz), factoryUid);
@@ -682,11 +675,7 @@ class DiscoverySelectorResolverTests {
 		UniqueId factoryUid = uniqueIdForTestFactoryMethod(clazz, "dynamicTest()");
 		UniqueId dynamicTestUid = factoryUid.append(DYNAMIC_TEST_SEGMENT_TYPE, "#1");
 
-		LauncherDiscoveryRequest request = request() //
-				.selectors(selectUniqueId(dynamicTestUid), selectMethod(clazz, "dynamicTest")) //
-				.build();
-
-		resolver.resolveSelectors(request, configuration, engineDescriptor);
+		resolve(request().selectors(selectUniqueId(dynamicTestUid), selectMethod(clazz, "dynamicTest")));
 
 		assertThat(engineDescriptor.getDescendants()).hasSize(2);
 		assertThat(uniqueIds()).containsSequence(uniqueIdForClass(clazz), factoryUid);
@@ -707,13 +696,56 @@ class DiscoverySelectorResolverTests {
 		UniqueId templateUid = uniqueIdForTestTemplateMethod(clazz, "testTemplate()");
 		UniqueId invocationUid = templateUid.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#1");
 
-		resolver.resolveSelectors(request().selectors(selectUniqueId(invocationUid)).build(), configuration,
-			engineDescriptor);
+		resolve(request().selectors(selectUniqueId(invocationUid)));
 
 		assertThat(engineDescriptor.getDescendants()).hasSize(2);
 		assertThat(uniqueIds()).containsSequence(uniqueIdForClass(clazz), templateUid);
 	}
 
+	@Test
+	void includingPackageNameFilterExcludesClassesInNonMatchingPackages() {
+		resolve(request().selectors(selectClass(MatchingClass.class)).filters(
+			includePackageNames("org.junit.jupiter.engine.unknown")));
+
+		assertThat(engineDescriptor.getDescendants()).isEmpty();
+	}
+
+	@Test
+	void includingPackageNameFilterIncludesClassesInMatchingPackages() {
+		resolve(request().selectors(selectClass(MatchingClass.class)).filters(
+			includePackageNames("org.junit.jupiter.engine")));
+
+		assertThat(engineDescriptor.getDescendants()).hasSize(3);
+	}
+
+	@Test
+	void excludingPackageNameFilterExcludesClassesInMatchingPackages() {
+		resolve(request().selectors(selectClass(MatchingClass.class)).filters(
+			excludePackageNames("org.junit.jupiter.engine")));
+
+		assertThat(engineDescriptor.getDescendants()).isEmpty();
+	}
+
+	@Test
+	void excludingPackageNameFilterIncludesClassesInNonMatchingPackages() {
+		resolve(request().selectors(selectClass(MatchingClass.class)).filters(
+			excludePackageNames("org.junit.jupiter.engine.unknown")));
+
+		assertThat(engineDescriptor.getDescendants()).hasSize(3);
+	}
+
+	@Test
+	void classNamePatternFilterExcludesNonMatchingClasses() {
+		resolve(request().selectors(selectClass(MatchingClass.class), selectClass(OtherClass.class)).filters(
+			includeClassNamePatterns(".*MatchingClass")));
+
+		assertThat(engineDescriptor.getDescendants()).hasSize(3);
+	}
+
+	private void resolve(LauncherDiscoveryRequestBuilder builder) {
+		new DiscoverySelectorResolver().resolveSelectors(builder.build(), engineDescriptor);
+	}
+
 	private TestDescriptor descriptorByUniqueId(UniqueId uniqueId) {
 		return engineDescriptor.getDescendants().stream().filter(
 			d -> d.getUniqueId().equals(uniqueId)).findFirst().get();
@@ -724,16 +756,16 @@ class DiscoverySelectorResolverTests {
 	}
 
 	private void assertZeroLogRecords(LogRecordListener listener) {
-		assertThat(listener.stream(JavaElementsResolver.class)).isEmpty();
+		assertThat(listener.stream(EngineDiscoveryRequestResolver.class)).isEmpty();
 	}
 
 	private LogRecord firstWarningLogRecord(LogRecordListener listener) throws AssertionError {
-		return listener.stream(JavaElementsResolver.class, Level.WARNING).findFirst().orElseThrow(
+		return listener.stream(EngineDiscoveryRequestResolver.class, Level.WARNING).findFirst().orElseThrow(
 			() -> new AssertionError("Failed to find warning log record"));
 	}
 
 	private LogRecord firstDebugLogRecord(LogRecordListener listener) throws AssertionError {
-		return listener.stream(JavaElementsResolver.class, Level.FINE).findFirst().orElseThrow(
+		return listener.stream(EngineDiscoveryRequestResolver.class, Level.FINE).findFirst().orElseThrow(
 			() -> new AssertionError("Failed to find debug log record"));
 	}
 
@@ -831,3 +863,18 @@ class TestClassWithTemplate {
 	void testTemplate() {
 	}
 }
+
+class MatchingClass {
+	@Nested
+	class NestedClass {
+		@Test
+		void test() {
+		}
+	}
+}
+
+class OtherClass {
+	@Test
+	void test() {
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
index 5cf860f15..fb5e069b9 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
@@ -10,7 +10,12 @@
 
 package org.junit.jupiter.engine.discovery;
 
+import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
+import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;
 import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.engine.UniqueId;
 
@@ -27,25 +32,25 @@ public class JupiterUniqueIdBuilder {
 		UniqueId containerId = engineId();
 		if (clazz.getEnclosingClass() != null && !ReflectionUtils.isStatic(clazz)) {
 			containerId = uniqueIdForClass(clazz.getEnclosingClass());
-			return containerId.append(NestedTestsResolver.SEGMENT_TYPE, clazz.getSimpleName());
+			return containerId.append(NestedClassTestDescriptor.SEGMENT_TYPE, clazz.getSimpleName());
 		}
-		return containerId.append(TestContainerResolver.SEGMENT_TYPE, clazz.getName());
+		return containerId.append(ClassTestDescriptor.SEGMENT_TYPE, clazz.getName());
 	}
 
 	public static UniqueId uniqueIdForTopLevelClass(String className) {
-		return engineId().append(TestContainerResolver.SEGMENT_TYPE, className);
+		return engineId().append(ClassTestDescriptor.SEGMENT_TYPE, className);
 	}
 
 	public static UniqueId uniqueIdForMethod(Class<?> clazz, String methodPart) {
-		return uniqueIdForClass(clazz).append(TestMethodResolver.SEGMENT_TYPE, methodPart);
+		return uniqueIdForClass(clazz).append(TestMethodTestDescriptor.SEGMENT_TYPE, methodPart);
 	}
 
 	public static UniqueId uniqueIdForTestFactoryMethod(Class<?> clazz, String methodPart) {
-		return uniqueIdForClass(clazz).append(TestFactoryMethodResolver.SEGMENT_TYPE, methodPart);
+		return uniqueIdForClass(clazz).append(TestFactoryTestDescriptor.SEGMENT_TYPE, methodPart);
 	}
 
 	public static UniqueId uniqueIdForTestTemplateMethod(Class<?> clazz, String methodPart) {
-		return uniqueIdForClass(clazz).append(TestTemplateMethodResolver.SEGMENT_TYPE, methodPart);
+		return uniqueIdForClass(clazz).append(TestTemplateTestDescriptor.SEGMENT_TYPE, methodPart);
 	}
 
 	public static UniqueId engineId() {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
index 043ed047e..67b8fcfed 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
@@ -101,6 +101,17 @@ class OrderedMethodTests {
 		assertOrderAnnotationSupport(OuterTestCase.class);
 	}
 
+	@Test
+	void orderAnnotationWithNestedTestClass() {
+		var tests = executeTestsInParallel(OrderAnnotationWithNestedClassTestCase.class);
+
+		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
+
+		assertThat(callSequence).containsExactly("test1", "test2", "test3", "test4", "test5", "test6", "nestedTest1",
+			"nestedTest2");
+		assertThat(threadNames).hasSize(1);
+	}
+
 	private void assertOrderAnnotationSupport(Class<?> testClass) {
 		var tests = executeTestsInParallel(testClass);
 
@@ -444,6 +455,29 @@ class OrderedMethodTests {
 		}
 	}
 
+	static class OrderAnnotationWithNestedClassTestCase extends OrderAnnotationTestCase {
+		@Nested
+		class NestedTests {
+
+			@BeforeEach
+			void trackInvocations(TestInfo testInfo) {
+				callSequence.add(testInfo.getDisplayName());
+			}
+
+			@Test
+			@Order(1)
+			@DisplayName("nestedTest1")
+			void nestedTest1() {
+			}
+
+			@Test
+			@Order(2)
+			@DisplayName("nestedTest2")
+			void nestedTest2() {
+			}
+		}
+	}
+
 	static class MisbehavingByAdding implements MethodOrderer {
 
 		@Override
diff --git a/junit-jupiter-engine/src/test/resources/log4j2-test.xml b/junit-jupiter-engine/src/test/resources/log4j2-test.xml
index e10d849cb..bc37259ce 100644
--- a/junit-jupiter-engine/src/test/resources/log4j2-test.xml
+++ b/junit-jupiter-engine/src/test/resources/log4j2-test.xml
@@ -9,6 +9,7 @@
 		<Logger name="org.junit" level="warn" />
 		<Logger name="org.junit.jupiter.api" level="off" />
 		<Logger name="org.junit.jupiter.engine" level="off" />
+		<Logger name="org.junit.platform.engine.support.discovery" level="off" />
 		<Root level="error">
 			<AppenderRef ref="Console" />
 		</Root>
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java
index d0f5a0463..2d2926b61 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueId.java
@@ -173,6 +173,34 @@ public class UniqueId implements Cloneable, Serializable {
 		return size >= prefixSize && this.segments.subList(0, prefixSize).equals(potentialPrefix.segments);
 	}
 
+	/**
+	 * Construct a new {@code UniqueId} and removing the last {@link Segment} of
+	 * this {@code UniqueId}.
+	 *
+	 * <p>This {@code UniqueId} will not be modified.
+	 *
+	 * @throws org.junit.platform.commons.util.PreconditionViolationException
+	 * if this {@code UniqueId} contains a single segment
+	 * @return a new {@code UniqueId}; never {@code null}
+	 * @since 1.5
+	 */
+	@API(status = STABLE, since = "1.5")
+	public UniqueId removeLastSegment() {
+		Preconditions.condition(this.segments.size() > 1, "Cannot remove last remaining segment");
+		return new UniqueId(uniqueIdFormat, new ArrayList<>(segments.subList(0, segments.size() - 1)));
+	}
+
+	/**
+	 * Get the last {@link Segment} of this {@code UniqueId}.
+	 *
+	 * @return the last {@code Segment}; never {@code null}
+	 * @since 1.5
+	 */
+	@API(status = STABLE, since = "1.5")
+	public Segment getLastSegment() {
+		return this.segments.get(this.segments.size() - 1);
+	}
+
 	@Override
 	protected Object clone() throws CloneNotSupportedException {
 		return super.clone();
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/ClassContainerSelectorResolver.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/ClassContainerSelectorResolver.java
new file mode 100644
index 000000000..466cc607a
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/ClassContainerSelectorResolver.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.discovery;
+
+import static java.util.stream.Collectors.toSet;
+import static org.junit.platform.commons.support.ReflectionSupport.findAllClassesInClasspathRoot;
+import static org.junit.platform.commons.support.ReflectionSupport.findAllClassesInModule;
+import static org.junit.platform.commons.support.ReflectionSupport.findAllClassesInPackage;
+import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.selectors;
+
+import java.util.List;
+import java.util.function.Predicate;
+
+import org.junit.platform.engine.discovery.ClasspathRootSelector;
+import org.junit.platform.engine.discovery.DiscoverySelectors;
+import org.junit.platform.engine.discovery.ModuleSelector;
+import org.junit.platform.engine.discovery.PackageSelector;
+
+/**
+ * @since 1.5
+ */
+class ClassContainerSelectorResolver implements SelectorResolver {
+
+	private final Predicate<Class<?>> classFilter;
+	private final Predicate<String> classNameFilter;
+
+	ClassContainerSelectorResolver(Predicate<Class<?>> classFilter, Predicate<String> classNameFilter) {
+		this.classFilter = classFilter;
+		this.classNameFilter = classNameFilter;
+	}
+
+	@Override
+	public Resolution resolve(ClasspathRootSelector selector, Context context) {
+		return classSelectors(findAllClassesInClasspathRoot(selector.getClasspathRoot(), classFilter, classNameFilter));
+	}
+
+	@Override
+	public Resolution resolve(ModuleSelector selector, Context context) {
+		return classSelectors(findAllClassesInModule(selector.getModuleName(), classFilter, classNameFilter));
+	}
+
+	@Override
+	public Resolution resolve(PackageSelector selector, Context context) {
+		return classSelectors(findAllClassesInPackage(selector.getPackageName(), classFilter, classNameFilter));
+	}
+
+	private Resolution classSelectors(List<Class<?>> classes) {
+		return selectors(classes.stream().map(DiscoverySelectors::selectClass).collect(toSet()));
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java
new file mode 100644
index 000000000..ad18edd3a
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolution.java
@@ -0,0 +1,262 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.discovery;
+
+import static java.util.stream.Collectors.joining;
+import static org.junit.platform.commons.util.BlacklistedExceptions.rethrowIfBlacklisted;
+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+
+import java.util.ArrayDeque;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Queue;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.engine.DiscoverySelector;
+import org.junit.platform.engine.EngineDiscoveryRequest;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.discovery.ClassSelector;
+import org.junit.platform.engine.discovery.ClasspathResourceSelector;
+import org.junit.platform.engine.discovery.ClasspathRootSelector;
+import org.junit.platform.engine.discovery.DirectorySelector;
+import org.junit.platform.engine.discovery.FileSelector;
+import org.junit.platform.engine.discovery.MethodSelector;
+import org.junit.platform.engine.discovery.ModuleSelector;
+import org.junit.platform.engine.discovery.PackageSelector;
+import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.discovery.UriSelector;
+import org.junit.platform.engine.support.discovery.SelectorResolver.Context;
+import org.junit.platform.engine.support.discovery.SelectorResolver.Match;
+import org.junit.platform.engine.support.discovery.SelectorResolver.Resolution;
+
+/**
+ * @since 1.5
+ */
+class EngineDiscoveryRequestResolution {
+
+	private final Logger logger;
+	private final EngineDiscoveryRequest request;
+	private final Context defaultContext;
+	private final List<SelectorResolver> resolvers;
+	private final List<TestDescriptor.Visitor> visitors;
+	private final TestDescriptor engineDescriptor;
+	private final Map<DiscoverySelector, Resolution> resolvedSelectors = new LinkedHashMap<>();
+	private final Map<UniqueId, Match> resolvedUniqueIds = new LinkedHashMap<>();
+	private final Queue<DiscoverySelector> remainingSelectors = new ArrayDeque<>();
+	private final Map<DiscoverySelector, Context> contextBySelector = new HashMap<>();
+
+	EngineDiscoveryRequestResolution(Logger logger, EngineDiscoveryRequest request, TestDescriptor engineDescriptor,
+			List<SelectorResolver> resolvers, List<TestDescriptor.Visitor> visitors) {
+		this.logger = logger;
+		this.request = request;
+		this.engineDescriptor = engineDescriptor;
+		this.resolvers = resolvers;
+		this.visitors = visitors;
+		this.defaultContext = new DefaultContext(null);
+		this.resolvedUniqueIds.put(engineDescriptor.getUniqueId(), Match.exact(engineDescriptor));
+	}
+
+	void run() {
+		remainingSelectors.addAll(request.getSelectorsByType(DiscoverySelector.class));
+		while (!remainingSelectors.isEmpty()) {
+			resolveCompletely(remainingSelectors.poll());
+		}
+		visitors.forEach(engineDescriptor::accept);
+	}
+
+	private void resolveCompletely(DiscoverySelector selector) {
+		try {
+			Optional<Resolution> result = resolve(selector);
+			if (result.isPresent()) {
+				enqueueAdditionalSelectors(result.get());
+			}
+			else {
+				logUnresolvedSelector(selector, null);
+			}
+		}
+		catch (Throwable t) {
+			rethrowIfBlacklisted(t);
+			logUnresolvedSelector(selector, t);
+		}
+	}
+
+	private void enqueueAdditionalSelectors(Resolution resolution) {
+		remainingSelectors.addAll(resolution.getSelectors());
+		resolution.getMatches().stream().filter(Match::isExact).forEach(match -> {
+			Set<? extends DiscoverySelector> childSelectors = match.expand();
+			if (!childSelectors.isEmpty()) {
+				remainingSelectors.addAll(childSelectors);
+				DefaultContext context = new DefaultContext(match.getTestDescriptor());
+				childSelectors.forEach(selector -> contextBySelector.put(selector, context));
+			}
+		});
+	}
+
+	private Optional<Resolution> resolve(DiscoverySelector selector) {
+		if (resolvedSelectors.containsKey(selector)) {
+			return Optional.of(resolvedSelectors.get(selector));
+		}
+		if (selector instanceof UniqueIdSelector) {
+			return resolveUniqueId((UniqueIdSelector) selector);
+		}
+		return resolve(selector, resolver -> {
+			Context context = getContext(selector);
+			if (selector instanceof ClasspathResourceSelector) {
+				return resolver.resolve((ClasspathResourceSelector) selector, context);
+			}
+			if (selector instanceof ClasspathRootSelector) {
+				return resolver.resolve((ClasspathRootSelector) selector, context);
+			}
+			if (selector instanceof ClassSelector) {
+				return resolver.resolve((ClassSelector) selector, context);
+			}
+			if (selector instanceof DirectorySelector) {
+				return resolver.resolve((DirectorySelector) selector, context);
+			}
+			if (selector instanceof FileSelector) {
+				return resolver.resolve((FileSelector) selector, context);
+			}
+			if (selector instanceof MethodSelector) {
+				return resolver.resolve((MethodSelector) selector, context);
+			}
+			if (selector instanceof ModuleSelector) {
+				return resolver.resolve((ModuleSelector) selector, context);
+			}
+			if (selector instanceof PackageSelector) {
+				return resolver.resolve((PackageSelector) selector, context);
+			}
+			if (selector instanceof UriSelector) {
+				return resolver.resolve((UriSelector) selector, context);
+			}
+			return resolver.resolve(selector, context);
+		});
+	}
+
+	private Optional<Resolution> resolveUniqueId(UniqueIdSelector selector) {
+		UniqueId uniqueId = selector.getUniqueId();
+		if (resolvedUniqueIds.containsKey(uniqueId)) {
+			return Optional.of(Resolution.match(resolvedUniqueIds.get(uniqueId)));
+		}
+		if (!uniqueId.hasPrefix(engineDescriptor.getUniqueId())) {
+			return Optional.empty();
+		}
+		return resolve(selector, resolver -> resolver.resolve(selector, getContext(selector)));
+	}
+
+	private Context getContext(DiscoverySelector selector) {
+		return contextBySelector.getOrDefault(selector, defaultContext);
+	}
+
+	private Optional<Resolution> resolve(DiscoverySelector selector,
+			Function<SelectorResolver, Resolution> resolutionFunction) {
+		// @formatter:off
+		return resolvers.stream()
+				.map(resolutionFunction)
+				.filter(Resolution::isResolved)
+				.findFirst()
+				.map(resolution -> {
+					contextBySelector.remove(selector);
+					resolvedSelectors.put(selector, resolution);
+					resolution.getMatches()
+							.forEach(match -> resolvedUniqueIds.put(match.getTestDescriptor().getUniqueId(), match));
+					return resolution;
+				});
+		// @formatter:on
+	}
+
+	private void logUnresolvedSelector(DiscoverySelector selector, Throwable cause) {
+		BiConsumer<Throwable, Supplier<String>> loggingConsumer = logger::debug;
+		if (selector instanceof UniqueIdSelector) {
+			UniqueId uniqueId = ((UniqueIdSelector) selector).getUniqueId();
+			if (uniqueId.hasPrefix(engineDescriptor.getUniqueId())) {
+				loggingConsumer = logger::warn;
+			}
+			else {
+				return;
+			}
+		}
+		loggingConsumer.accept(cause, () -> selector + " could not be resolved.");
+	}
+
+	private class DefaultContext implements Context {
+
+		private final TestDescriptor parent;
+
+		DefaultContext(TestDescriptor parent) {
+			this.parent = parent;
+		}
+
+		@Override
+		public <T extends TestDescriptor> Optional<T> addToParent(Function<TestDescriptor, Optional<T>> creator) {
+			if (parent != null) {
+				return createAndAdd(parent, creator);
+			}
+			return createAndAdd(engineDescriptor, creator);
+		}
+
+		@Override
+		public <T extends TestDescriptor> Optional<T> addToParent(Supplier<DiscoverySelector> parentSelectorSupplier,
+				Function<TestDescriptor, Optional<T>> creator) {
+			if (parent != null) {
+				return createAndAdd(parent, creator);
+			}
+			return resolve(parentSelectorSupplier.get()).flatMap(parent -> createAndAdd(parent, creator));
+		}
+
+		@Override
+		public Optional<TestDescriptor> resolve(DiscoverySelector selector) {
+			// @formatter:off
+			return EngineDiscoveryRequestResolution.this.resolve(selector)
+					.map(Resolution::getMatches)
+					.flatMap(matches -> {
+						if (matches.size() > 1) {
+							String stringRepresentation = matches.stream()
+									.map(Match::getTestDescriptor)
+									.map(Objects::toString)
+									.collect(joining(", "));
+							throw new JUnitException(
+								"Selector " + selector + " did not yield unique test descriptor: " + stringRepresentation);
+						}
+						if (matches.size() == 1) {
+							return Optional.of(getOnlyElement(matches).getTestDescriptor());
+						}
+						return Optional.empty();
+					});
+			// @formatter:on
+		}
+
+		@SuppressWarnings("unchecked")
+		private <T extends TestDescriptor> Optional<T> createAndAdd(TestDescriptor parent,
+				Function<TestDescriptor, Optional<T>> creator) {
+			Optional<T> child = creator.apply(parent);
+			if (child.isPresent()) {
+				UniqueId uniqueId = child.get().getUniqueId();
+				if (resolvedUniqueIds.containsKey(uniqueId)) {
+					return Optional.of((T) resolvedUniqueIds.get(uniqueId).getTestDescriptor());
+				}
+				parent.addChild(child.get());
+			}
+			return child;
+		}
+
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java
new file mode 100644
index 000000000..6d922303c
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/EngineDiscoveryRequestResolver.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.discovery;
+
+import static java.util.stream.Collectors.toCollection;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.engine.EngineDiscoveryRequest;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.discovery.ClassNameFilter;
+import org.junit.platform.engine.discovery.ClassSelector;
+import org.junit.platform.engine.discovery.ClasspathRootSelector;
+import org.junit.platform.engine.discovery.ModuleSelector;
+import org.junit.platform.engine.discovery.PackageNameFilter;
+import org.junit.platform.engine.discovery.PackageSelector;
+import org.junit.platform.engine.support.discovery.SelectorResolver.Match;
+import org.junit.platform.engine.support.discovery.SelectorResolver.Resolution;
+import org.junit.platform.engine.support.filter.ClasspathScanningSupport;
+
+/**
+ * Configurable test discovery implementation based on {@link SelectorResolver}
+ * and {@link TestDescriptor.Visitor} that can be reused by different
+ * {@link org.junit.platform.engine.TestEngine TestEngines}.
+ *
+ * @param <T> the type of the engine's descriptor
+ * @see #builder()
+ * @see #resolve(EngineDiscoveryRequest, TestDescriptor)
+ * @since 1.5
+ */
+@API(status = EXPERIMENTAL, since = "1.5")
+public class EngineDiscoveryRequestResolver<T extends TestDescriptor> {
+
+	private static final Logger logger = LoggerFactory.getLogger(EngineDiscoveryRequestResolver.class);
+
+	private final List<Function<InitializationContext<T>, SelectorResolver>> resolverCreators;
+	private final List<Function<InitializationContext<T>, TestDescriptor.Visitor>> visitorCreators;
+
+	private EngineDiscoveryRequestResolver(List<Function<InitializationContext<T>, SelectorResolver>> resolverCreators,
+			List<Function<InitializationContext<T>, TestDescriptor.Visitor>> visitorCreators) {
+		this.resolverCreators = new ArrayList<>(resolverCreators);
+		this.visitorCreators = new ArrayList<>(visitorCreators);
+	}
+
+	/**
+	 * Resolve the supplied {@link EngineDiscoveryRequest} and collect the
+	 * results into the supplied {@link TestDescriptor}.
+	 *
+	 * <p>The algorithm works as follows:
+	 *
+	 * <ol>
+	 *     <li>Enqueue all selectors in the supplied
+	 *     {@linkplain EngineDiscoveryRequest request} to be resolved.
+	 *     </li>
+	 *     <li>
+	 *         While there are selectors to be resolved, get the next one.
+	 *         Otherwise, the resolution is finished.
+	 *         <ol>
+	 *             <li>
+	 *                 Iterate over all registered {@linkplain SelectorResolver
+	 *                 resolvers} in the order they were registered in and find the
+	 *                 first one that returns a {@linkplain Resolution resolution}
+	 *                 other than {@link Resolution#unresolved() unresolved()}.
+	 *             </li>
+	 *             <li>
+	 *                 If such a {@linkplain Resolution resolution} exists, enqueue
+	 *                 its {@linkplain Resolution#getSelectors() selectors}.
+	 *             </li>
+	 *             <li>
+	 *                 For each exact {@linkplain Match match} in the {@linkplain
+	 *                 Resolution resolution}, {@linkplain Match#expand() expand}
+	 *                 its children and enqueue them as well.
+	 *             </li>
+	 *         </ol>
+	 *     </li>
+	 *     <li>
+	 *         Iterate over all registered {@linkplain TestDescriptor.Visitor
+	 *         visitors} and let the engine test descriptor {@linkplain
+	 *         TestDescriptor#accept(TestDescriptor.Visitor) accept} them.
+	 *     </li>
+	 * </ol>
+	 *
+	 * @param request the request to be resolved; never {@code null}
+	 * @param engineDescriptor the engine's {@code TestDescriptor} to be used
+	 * for adding direct children
+	 * @see SelectorResolver
+	 * @see TestDescriptor.Visitor
+	 */
+	public void resolve(EngineDiscoveryRequest request, T engineDescriptor) {
+		Preconditions.notNull(request, "request must not be null");
+		Preconditions.notNull(engineDescriptor, "engineDescriptor must not be null");
+		InitializationContext<T> initializationContext = new DefaultInitializationContext<>(request, engineDescriptor);
+		List<SelectorResolver> resolvers = instantiate(resolverCreators, initializationContext);
+		List<TestDescriptor.Visitor> visitors = instantiate(visitorCreators, initializationContext);
+		new EngineDiscoveryRequestResolution(logger, request, engineDescriptor, resolvers, visitors).run();
+	}
+
+	private <R> List<R> instantiate(List<Function<InitializationContext<T>, R>> creators,
+			InitializationContext<T> context) {
+		return creators.stream().map(creator -> creator.apply(context)).collect(toCollection(ArrayList::new));
+	}
+
+	/**
+	 * Create a new {@link Builder} for creating a {@link EngineDiscoveryRequestResolver}.
+	 *
+	 * @param <T> the type of the engine's descriptor
+	 * @return a new builder; never {@code null}
+	 */
+	public static <T extends TestDescriptor> Builder<T> builder() {
+		return new Builder<>();
+	}
+
+	/**
+	 * Builder for {@link EngineDiscoveryRequestResolver}.
+	 *
+	 * @param <T> the type of the engine's descriptor
+	 * @since 1.5
+	 */
+	@API(status = EXPERIMENTAL, since = "1.5")
+	public static class Builder<T extends TestDescriptor> {
+
+		private final List<Function<InitializationContext<T>, SelectorResolver>> resolverCreators = new ArrayList<>();
+		private final List<Function<InitializationContext<T>, TestDescriptor.Visitor>> visitorCreators = new ArrayList<>();
+
+		private Builder() {
+		}
+
+		/**
+		 * Add a predefined resolver that resolves {@link ClasspathRootSelector
+		 * ClasspathRootSelectors}, {@link ModuleSelector ModuleSelectors}, and
+		 * {@link PackageSelector PackageSelectors} into {@link ClassSelector
+		 * ClassSelectors} by scanning for classes that satisfy the supplied
+		 * predicate in the respective class containers to this builder.
+		 *
+		 * @param classFilter predicate the resolved classes must satisfy; never
+		 * {@code null}
+		 * @return this builder for method chaining
+		 */
+		public Builder<T> addClassContainerSelectorResolver(Predicate<Class<?>> classFilter) {
+			Preconditions.notNull(classFilter, "classFilter must not be null");
+			return addSelectorResolver(
+				context -> new ClassContainerSelectorResolver(classFilter, context.getClassNameFilter()));
+		}
+
+		/**
+		 * Add a context insensitive {@link SelectorResolver} to this builder.
+		 *
+		 * @param resolver the resolver to add; never {@code null}
+		 * @return this builder for method chaining
+		 */
+		public Builder<T> addSelectorResolver(SelectorResolver resolver) {
+			Preconditions.notNull(resolver, "resolver must not be null");
+			return addSelectorResolver(context -> resolver);
+		}
+
+		/**
+		 * Add a context sensitive {@link SelectorResolver} to this builder.
+		 *
+		 * @param resolverCreator the function that will be called to create the
+		 * {@link SelectorResolver} to be added.
+		 * @return this builder for method chaining
+		 * @see InitializationContext
+		 */
+		public Builder<T> addSelectorResolver(Function<InitializationContext<T>, SelectorResolver> resolverCreator) {
+			resolverCreators.add(resolverCreator);
+			return this;
+		}
+
+		/**
+		 * Add a context sensitive {@link TestDescriptor.Visitor} to this
+		 * builder.
+		 *
+		 * @param visitorCreator the function that will be called to create the
+		 * {@link TestDescriptor.Visitor} to be added.
+		 * @return this builder for method chaining
+		 * @see InitializationContext
+		 */
+		public Builder<T> addTestDescriptorVisitor(
+				Function<InitializationContext<T>, TestDescriptor.Visitor> visitorCreator) {
+			visitorCreators.add(visitorCreator);
+			return this;
+		}
+
+		/**
+		 * Build the {@link EngineDiscoveryRequestResolver} that has been
+		 * configured via this builder.
+		 */
+		public EngineDiscoveryRequestResolver<T> build() {
+			return new EngineDiscoveryRequestResolver<>(resolverCreators, visitorCreators);
+		}
+
+	}
+
+	/**
+	 * The initialization context for creating {@linkplain SelectorResolver
+	 * resolvers} and {@linkplain TestDescriptor.Visitor visitors} that depend
+	 * on the {@link EngineDiscoveryRequest} to be resolved or the engine
+	 * descriptor that will be used to collect the results.
+	 *
+	 * @since 1.5
+	 * @see Builder#addSelectorResolver(Function)
+	 * @see Builder#addTestDescriptorVisitor(Function)
+	 */
+	@API(status = EXPERIMENTAL, since = "1.5")
+	public interface InitializationContext<T extends TestDescriptor> {
+
+		/**
+		 * Get the {@link EngineDiscoveryRequest} that is about to be resolved.
+		 *
+		 * @return the {@link EngineDiscoveryRequest}; never {@code null}
+		 */
+		EngineDiscoveryRequest getDiscoveryRequest();
+
+		/**
+		 * Get the engine's {@link TestDescriptor} that will be used to collect
+		 * the results.
+		 *
+		 * @return engine's {@link TestDescriptor}; never {@code null}
+		 */
+		T getEngineDescriptor();
+
+		/**
+		 * Get the class name filter built from the {@link ClassNameFilter
+		 * ClassNameFilters} and {@link PackageNameFilter PackageNameFilters}
+		 * in the {@link EngineDiscoveryRequest} that is about to be resolved.
+		 *
+		 * @return the predicate for filtering the resolved class names; never
+		 * {@code null}
+		 */
+		Predicate<String> getClassNameFilter();
+
+	}
+
+	private static class DefaultInitializationContext<T extends TestDescriptor> implements InitializationContext<T> {
+
+		private final EngineDiscoveryRequest request;
+		private final T engineDescriptor;
+		private final Predicate<String> classNameFilter;
+
+		DefaultInitializationContext(EngineDiscoveryRequest request, T engineDescriptor) {
+			this.request = request;
+			this.engineDescriptor = engineDescriptor;
+			this.classNameFilter = ClasspathScanningSupport.buildClassNamePredicate(request);
+		}
+
+		@Override
+		public EngineDiscoveryRequest getDiscoveryRequest() {
+			return request;
+		}
+
+		@Override
+		public T getEngineDescriptor() {
+			return engineDescriptor;
+		}
+
+		@Override
+		public Predicate<String> getClassNameFilter() {
+			return classNameFilter;
+		}
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java
new file mode 100644
index 000000000..f61378bdd
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/SelectorResolver.java
@@ -0,0 +1,615 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.discovery;
+
+import static java.util.Collections.emptySet;
+import static java.util.Collections.singleton;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.util.Collections;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.engine.DiscoverySelector;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.discovery.ClassSelector;
+import org.junit.platform.engine.discovery.ClasspathResourceSelector;
+import org.junit.platform.engine.discovery.ClasspathRootSelector;
+import org.junit.platform.engine.discovery.DirectorySelector;
+import org.junit.platform.engine.discovery.FileSelector;
+import org.junit.platform.engine.discovery.MethodSelector;
+import org.junit.platform.engine.discovery.ModuleSelector;
+import org.junit.platform.engine.discovery.PackageSelector;
+import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.discovery.UriSelector;
+
+/**
+ * A resolver that supports resolving one or multiple types of
+ * {@link DiscoverySelector DiscoverySelectors}.
+ *
+ * <p>An implementation of a {@code resolve()} method is typically comprised
+ * of the following steps:
+ *
+ * <ol>
+ *     <li>
+ *         Check whether the selector is applicable for the current
+ *         {@link org.junit.platform.engine.TestEngine} and the current
+ *         {@link org.junit.platform.engine.EngineDiscoveryRequest} (e.g.
+ *         for a test class: is it relevant for the current engine and does
+ *         it pass all filters in the request?).
+ *     </li>
+ *     <li>
+ *         If so, use the supplied {@link Context Context}, to add one or
+ *         multiple {@link TestDescriptor TestDescriptors} to the designated
+ *         parent (see {@link Context Context} for details) and return a
+ *         {@linkplain Resolution#match(Match) match} or multiple {@linkplain
+ *         Resolution#matches(Set) matches}. Alternatively, convert the supplied
+ *         selector into one or multiple other
+ *         {@linkplain Resolution#selectors(Set) selectors} (e.g. a {@link
+ *         PackageSelector} into a set of {@link ClassSelector ClassSelectors}).
+ *         Otherwise, return {@link Resolution#unresolved() unresolved()}.
+ *     </li>
+ * </ol>
+ *
+ * @since 1.5
+ */
+@API(status = EXPERIMENTAL, since = "1.5")
+public interface SelectorResolver {
+
+	/**
+	 * Resolve the supplied {@link ClasspathResourceSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(ClasspathResourceSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link ClasspathRootSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(ClasspathRootSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link ClassSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(ClassSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link DirectorySelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(DirectorySelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link FileSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(FileSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link MethodSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(MethodSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link ModuleSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(ModuleSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link PackageSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(PackageSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link UniqueIdSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(UniqueIdSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link UriSelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>The default implementation simply delegates to {@link
+	 * #resolve(DiscoverySelector, Context)}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see #resolve(DiscoverySelector, Context)
+	 */
+	default Resolution resolve(UriSelector selector, Context context) {
+		return resolve((DiscoverySelector) selector, context);
+	}
+
+	/**
+	 * Resolve the supplied {@link DiscoverySelector} using the supplied
+	 * {@link Context Context}.
+	 *
+	 * <p>This method is only called if none of the overloaded variants match.
+	 *
+	 * <p>The default implementation returns {@link Resolution#unresolved()
+	 * unresolved()}.
+	 *
+	 * @param selector the selector to be resolved; never {@code null}
+	 * @param context the context to be used for resolving the selector; never
+	 * {@code null}
+	 * @return a {@link Resolution Resolution} of {@link Resolution#unresolved()
+	 * unresolved()}, {@link Resolution#selectors(Set) selectors()}, or {@link
+	 * Resolution#matches(Set) matches()}; never {@code null}
+	 * @see Context
+	 */
+	default Resolution resolve(DiscoverySelector selector, Context context) {
+		return Resolution.unresolved();
+	}
+
+	/**
+	 * The context for resolving a {@link DiscoverySelector} and adding it to
+	 * the test tree.
+	 *
+	 * <p>The context is used to add resolved {@link TestDescriptor
+	 * TestDescriptors} to the test tree if and only if the parent
+	 * {@code TestDescriptor} could be found. Alternatively, a resolver may
+	 * use the context to {@linkplain #resolve(DiscoverySelector) resolve} a
+	 * certain {@code DiscoverySelector} into a {@code TestDescriptor} (e.g. for
+	 * adding a filter and returning a {@linkplain Match#partial(TestDescriptor)
+	 * partial match}).
+	 *
+	 * @see SelectorResolver
+	 * @since 1.5
+	 */
+	@API(status = EXPERIMENTAL, since = "1.5")
+	interface Context {
+
+		/**
+		 * Resolve the supplied {@link TestDescriptor}, if possible.
+		 *
+		 * <p>Calling this method has the same effect as returning a {@linkplain
+		 * Match#partial(TestDescriptor) partial match} from a {@link
+		 * SelectorResolver}: the children of the resulting {@link
+		 * TestDescriptor} will only be resolved if a subsequent resolution
+		 * finds an exact match that contains a {@code TestDescriptor} with the
+		 * same {@linkplain TestDescriptor#getUniqueId() unique ID}.
+		 *
+		 * @param selector the selector to resolve
+		 * @return the resolved {@code TestDescriptor}; never {@code null} but
+		 * potentially empty
+		 */
+		Optional<TestDescriptor> resolve(DiscoverySelector selector);
+
+		/**
+		 * Add a {@link TestDescriptor} to an unspecified parent, usually the
+		 * engine descriptor, by applying the supplied {@code Function} to the
+		 * new parent.
+		 *
+		 * <p>The parent will be the engine descriptor unless another parent has
+		 * already been determined, i.e. if the selector that is being resolved
+		 * is the result of {@linkplain Match#expand() expanding} a {@link
+		 * Match}.
+		 *
+		 * <p>If the result of applying the {@code Function} is {@linkplain
+		 * Optional#isPresent() present}, it will be added as a child of the
+		 * parent {@code TestDescriptor} unless a descriptor with the same
+		 * {@linkplain TestDescriptor#getUniqueId() unique ID} was added
+		 * earlier.
+		 *
+		 * @param creator {@code Function} that will be called with the new
+		 * parent to determine the new {@code TestDescriptor} to be added; must
+		 * not return {@code null}
+		 * @param <T> the type of the new {@code TestDescriptor}
+		 * @return the new {@code TestDescriptor} or the previously existing one
+		 * with the same unique ID; never {@code null} but potentially empty
+		 * @throws ClassCastException if the previously existing {@code
+		 * TestDescriptor} is not an instance of {@code T}
+		 */
+		<T extends TestDescriptor> Optional<T> addToParent(Function<TestDescriptor, Optional<T>> creator);
+
+		/**
+		 * Add a {@link TestDescriptor} to a parent, specified by the {@link
+		 * DiscoverySelector} returned by the supplied {@code Supplier}, by
+		 * applying the supplied {@code Function} to the new parent.
+		 *
+		 * <p>Unless another parent has already been determined, i.e. if the
+		 * selector that is being resolved is the result of {@linkplain
+		 * Match#expand() expanding} a {@link Match}, the {@link
+		 * DiscoverySelector} returned by the supplied {@code Supplier} will
+		 * be used to determine the parent. If no parent is found, the supplied
+		 * {@code Function} will not be called. If there are multiple potential
+		 * parents, an exception will be thrown. Otherwise, the resolved
+		 * {@code TestDescriptor} will be used as the parent and passed to the
+		 * supplied {@code Function}.
+		 *
+		 * <p>If the result of applying the {@code Function} is {@linkplain
+		 * Optional#isPresent() present}, it will be added as a child of the
+		 * parent {@code TestDescriptor} unless a descriptor with the same
+		 * {@linkplain TestDescriptor#getUniqueId() unique ID} was added
+		 * earlier.
+		 *
+		 * @param creator {@code Function} that will be called with the new
+		 * parent to determine the new {@code TestDescriptor} to be added; must
+		 * not return {@code null}
+		 * @param <T> the type of the new {@code TestDescriptor}
+		 * @return the new {@code TestDescriptor} or the previously existing one
+		 * with the same unique ID; never {@code null} but potentially empty
+		 * @throws ClassCastException if the previously existing {@code
+		 * TestDescriptor} is not an instance of {@code T}
+		 */
+		<T extends TestDescriptor> Optional<T> addToParent(Supplier<DiscoverySelector> parentSelectorSupplier,
+				Function<TestDescriptor, Optional<T>> creator);
+
+	}
+
+	/**
+	 * The result of an attempt to resolve a {@link DiscoverySelector}.
+	 *
+	 * <p>A resolution is either {@linkplain #unresolved unresolved}, contains a
+	 * {@linkplain #match match} or multiple {@linkplain #matches}, or a set of
+	 * {@linkplain #selectors selectors}.
+	 *
+	 * @see SelectorResolver
+	 * @since 1.5
+	 */
+	@API(status = EXPERIMENTAL, since = "1.5")
+	class Resolution {
+
+		private static final Resolution UNRESOLVED = new Resolution(emptySet(), emptySet());
+
+		private final Set<Match> matches;
+		private final Set<? extends DiscoverySelector> selectors;
+
+		/**
+		 * Factory for creating <em>unresolved</em> resolutions.
+		 *
+		 * @return an <em>unresolved</em> resolution; never {@code null}
+		 */
+		public static Resolution unresolved() {
+			return UNRESOLVED;
+		}
+
+		/**
+		 * Factory for creating a resolution that contains the supplied
+		 * {@link Match Match}.
+		 *
+		 * @param match the resolved {@code Match}; never {@code null}
+		 * @return an resolution that contains the supplied {@code Match}; never
+		 * {@code null}
+		 */
+		public static Resolution match(Match match) {
+			return new Resolution(singleton(match), emptySet());
+		}
+
+		/**
+		 * Factory for creating a resolution that contains the supplied
+		 * {@link Match Matches}.
+		 *
+		 * @param matches the resolved {@code Matches}; never {@code null} or
+		 * empty
+		 * @return an resolution that contains the supplied {@code Matches};
+		 * never {@code null}
+		 */
+		public static Resolution matches(Set<Match> matches) {
+			Preconditions.containsNoNullElements(matches, "matches must not contain null elements");
+			Preconditions.notEmpty(matches, "matches must not be empty");
+			return new Resolution(matches, emptySet());
+		}
+
+		/**
+		 * Factory for creating a resolution that contains the supplied
+		 * {@link DiscoverySelector DiscoverySelectors}.
+		 *
+		 * @param selectors the resolved {@code DiscoverySelectors}; never
+		 * {@code null} or empty
+		 * @return an resolution that contains the supplied
+		 * {@code DiscoverySelectors}; never {@code null}
+		 */
+		public static Resolution selectors(Set<? extends DiscoverySelector> selectors) {
+			Preconditions.containsNoNullElements(selectors, "selectors must not contain null elements");
+			Preconditions.notEmpty(selectors, "selectors must not be empty");
+			return new Resolution(emptySet(), selectors);
+		}
+
+		private Resolution(Set<Match> matches, Set<? extends DiscoverySelector> selectors) {
+			this.matches = matches;
+			this.selectors = selectors;
+		}
+
+		/**
+		 * Whether this resolution contains matches or selectors.
+		 *
+		 * @return {@code true} if this resolution contains matches or selectors
+		 */
+		public boolean isResolved() {
+			return this != UNRESOLVED;
+		}
+
+		/**
+		 * Returns the matches contained by this resolution.
+		 *
+		 * @return the set of matches; never {@code null} but potentially empty
+		 */
+		public Set<Match> getMatches() {
+			return matches;
+		}
+
+		/**
+		 * Returns the selectors contained by this resolution.
+		 *
+		 * @return the set of selectors; never {@code null} but potentially empty
+		 */
+		public Set<? extends DiscoverySelector> getSelectors() {
+			return selectors;
+		}
+
+	}
+
+	/**
+	 * An exact or partial match for resolving a {@link DiscoverySelector} into
+	 * a {@link TestDescriptor}.
+	 *
+	 * <p>A match is <em>exact</em> if the {@link DiscoverySelector} directly
+	 * represents the resulting {@link TestDescriptor}, e.g. if a
+	 * {@link ClassSelector} was resolved into the {@link TestDescriptor} that
+	 * represents the test class. It is <em>partial</em> if the matching
+	 * {@link TestDescriptor} does not directly correspond to the resolved
+	 * {@link DiscoverySelector}, e.g. when resolving a {@link UniqueIdSelector}
+	 * that represents a dynamic child of the resolved {@link TestDescriptor}.
+	 *
+	 * <p>In addition to the {@link TestDescriptor}, a match may contain a
+	 * {@code Supplier} of {@link DiscoverySelector DiscoverySelectors} that may
+	 * be used to discover the children of the {@link TestDescriptor}. The
+	 * algorithm implemented by {@link EngineDiscoveryRequestResolver}
+	 * {@linkplain #expand() expands} all exact matches immediately, i.e. it
+	 * resolves all of their children. Partial matches will only be expanded in
+	 * case a subsequent resolution finds an exact match that contains a {@link
+	 * TestDescriptor} with the same {@linkplain TestDescriptor#getUniqueId()
+	 * unique ID}.
+	 *
+	 * @see SelectorResolver
+	 * @see Resolution#match(Match)
+	 * @see Resolution#matches(Set)
+	 * @since 1.5
+	 */
+	@API(status = EXPERIMENTAL, since = "1.5")
+	class Match {
+
+		private final TestDescriptor testDescriptor;
+		private final Supplier<Set<? extends DiscoverySelector>> childSelectorsSupplier;
+		private final Type type;
+
+		/**
+		 * Factory for creating an exact match without any children.
+		 *
+		 * @param testDescriptor the resolved {@code TestDescriptor}; never
+		 * {@code null}
+		 * @return a match that contains the supplied {@code TestDescriptor};
+		 * never {@code null}
+		 */
+		public static Match exact(TestDescriptor testDescriptor) {
+			return exact(testDescriptor, Collections::emptySet);
+		}
+
+		/**
+		 * Factory for creating an exact match with potential children.
+		 *
+		 * @param testDescriptor the resolved {@code TestDescriptor}; never
+		 * {@code null}
+		 * @param childSelectorsSupplier a {@code Supplier} of children
+		 * selectors that will be resolved when this match is expanded; never
+		 * {@code null}
+		 * @return a match that contains the supplied {@code TestDescriptor};
+		 * never {@code null}
+		 */
+		public static Match exact(TestDescriptor testDescriptor,
+				Supplier<Set<? extends DiscoverySelector>> childSelectorsSupplier) {
+			return new Match(testDescriptor, childSelectorsSupplier, Type.EXACT);
+		}
+
+		/**
+		 * Factory for creating a partial match without any children.
+		 *
+		 * @param testDescriptor the resolved {@code TestDescriptor}; never
+		 * {@code null}
+		 * @return a match that contains the supplied {@code TestDescriptor};
+		 * never {@code null}
+		 */
+		public static Match partial(TestDescriptor testDescriptor) {
+			return partial(testDescriptor, Collections::emptySet);
+		}
+
+		/**
+		 * Factory for creating a partial match with potential children.
+		 *
+		 * @param testDescriptor the resolved {@code TestDescriptor}; never
+		 * {@code null}
+		 * @param childSelectorsSupplier a {@code Supplier} of children
+		 * selectors that will be resolved when this match is expanded; never
+		 * {@code null}
+		 * @return a match that contains the supplied {@code TestDescriptor};
+		 * never {@code null}
+		 */
+		public static Match partial(TestDescriptor testDescriptor,
+				Supplier<Set<? extends DiscoverySelector>> childSelectorsSupplier) {
+			return new Match(testDescriptor, childSelectorsSupplier, Type.PARTIAL);
+		}
+
+		private Match(TestDescriptor testDescriptor, Supplier<Set<? extends DiscoverySelector>> childSelectorsSupplier,
+				Type type) {
+			this.testDescriptor = Preconditions.notNull(testDescriptor, "testDescriptor must not be null");
+			this.childSelectorsSupplier = Preconditions.notNull(childSelectorsSupplier,
+				"childSelectorsSupplier must not be null");
+			this.type = type;
+		}
+
+		/**
+		 * Whether this match is exact.
+		 *
+		 * @return {@code true} if this match is exact; {@code false} if it's
+		 * partial
+		 */
+		public boolean isExact() {
+			return type == Type.EXACT;
+		}
+
+		/**
+		 * Get the contained {@link TestDescriptor}.
+		 *
+		 * @return the contained {@code TestDescriptor}; never {@code null}
+		 */
+		public TestDescriptor getTestDescriptor() {
+			return testDescriptor;
+		}
+
+		/**
+		 * Expand this match in order to resolve the children of the contained
+		 * {@link TestDescriptor}.
+		 *
+		 * @return the set of {@code DiscoverySelectors} that represent the
+		 * children of the contained {@code TestDescriptor}; never {@code null}
+		 */
+		public Set<? extends DiscoverySelector> expand() {
+			return childSelectorsSupplier.get();
+		}
+
+		private enum Type {
+			EXACT, PARTIAL
+		}
+
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/package-info.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/package-info.java
new file mode 100644
index 000000000..1f0ea1ff3
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/discovery/package-info.java
@@ -0,0 +1,9 @@
+/**
+ * Configurable test discovery implementation that can be reused by different test engines.
+ *
+ * @see org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver#builder()
+ * @see org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver#resolve
+ * @see org.junit.platform.engine.support.discovery.SelectorResolver
+ */
+
+package org.junit.platform.engine.support.discovery;
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/OrFilter.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/OrFilter.java
similarity index 94%
rename from junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/OrFilter.java
rename to junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/OrFilter.java
index 87b22a287..50ab06f40 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/OrFilter.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/OrFilter.java
@@ -8,7 +8,7 @@
  * https://www.eclipse.org/legal/epl-v20.html
  */
 
-package org.junit.vintage.engine.discovery;
+package org.junit.vintage.engine.descriptor;
 
 import static java.util.stream.Collectors.joining;
 
@@ -19,7 +19,7 @@ import org.junit.runner.Description;
 import org.junit.runner.manipulation.Filter;
 
 /**
- * @since 4.12
+ * @since 5.4
  */
 class OrFilter extends Filter {
 
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerDecorator.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerDecorator.java
similarity index 70%
rename from junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerDecorator.java
rename to junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerDecorator.java
index 80eb1cf62..6678cf1eb 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerDecorator.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerDecorator.java
@@ -8,10 +8,14 @@
  * https://www.eclipse.org/legal/epl-v20.html
  */
 
-package org.junit.vintage.engine.discovery;
+package org.junit.vintage.engine.descriptor;
 
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import org.apiguardian.api.API;
 import org.junit.runner.Runner;
 
+@API(status = INTERNAL, since = "5.4")
 public interface RunnerDecorator {
 
 	Runner getDecoratedRunner();
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
index 44f8a2f9f..8625dc238 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
@@ -13,8 +13,12 @@ package org.junit.vintage.engine.descriptor;
 import static java.util.Collections.singletonList;
 import static org.apiguardian.api.API.Status.INTERNAL;
 
+import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
 import java.util.Set;
+import java.util.function.Consumer;
 
 import org.apiguardian.api.API;
 import org.junit.platform.commons.logging.Logger;
@@ -36,12 +40,15 @@ public class RunnerTestDescriptor extends VintageTestDescriptor {
 
 	private static final Logger logger = LoggerFactory.getLogger(RunnerTestDescriptor.class);
 
-	private final Runner runner;
 	private final Set<Description> rejectedExclusions = new HashSet<>();
+	private final Class<?> testClass;
+	private Runner runner;
 	private boolean wasFiltered;
+	private List<Filter> filters = new ArrayList<>();
 
 	public RunnerTestDescriptor(UniqueId uniqueId, Class<?> testClass, Runner runner) {
 		super(uniqueId, runner.getDescription(), testClass.getSimpleName(), ClassSource.from(testClass));
+		this.testClass = testClass;
 		this.runner = runner;
 	}
 
@@ -102,17 +109,48 @@ public class RunnerTestDescriptor extends VintageTestDescriptor {
 
 	private void logIncompleteFiltering() {
 		if (runner instanceof Filterable) {
-			logger.warn(() -> "Runner " + runner.getClass().getName() //
-					+ " (used on " + getDescription().getTestClass()
+			logger.warn(() -> "Runner " + getRunnerToReport().getClass().getName() //
+					+ " (used on class " + getDescription().getTestClass().getName()
 					+ ") was not able to satisfy all filter requests.");
 		}
 		else {
-			logger.warn(() -> "Runner " + runner.getClass().getName() //
-					+ " (used on " + getDescription().getTestClass() + ") does not support filtering" //
-					+ " and will therefore be run completely.");
+			warnAboutUnfilterableRunner();
 		}
 	}
 
+	private void warnAboutUnfilterableRunner() {
+		logger.warn(() -> "Runner " + getRunnerToReport().getClass().getName() //
+				+ " (used on class " + getDescription().getTestClass().getName() + ") does not support filtering" //
+				+ " and will therefore be run completely.");
+	}
+
+	public Optional<List<Filter>> getFilters() {
+		return Optional.ofNullable(filters);
+	}
+
+	public void clearFilters() {
+		this.filters = null;
+	}
+
+	public void applyFilters(Consumer<RunnerTestDescriptor> childrenCreator) {
+		if (filters != null && !filters.isEmpty()) {
+			if (runner instanceof Filterable) {
+				this.runner = toRequest().filterWith(new OrFilter(filters)).getRunner();
+				this.description = runner.getDescription();
+				this.children.clear();
+				childrenCreator.accept(this);
+			}
+			else {
+				warnAboutUnfilterableRunner();
+			}
+		}
+		clearFilters();
+	}
+
+	private Runner getRunnerToReport() {
+		return (runner instanceof RunnerDecorator) ? ((RunnerDecorator) runner).getDecoratedRunner() : runner;
+	}
+
 	private static class ExcludeDescriptionFilter extends Filter {
 
 		private final Description description;
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java
index 4fef9cbb5..6b7eb3700 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java
@@ -49,7 +49,7 @@ public class VintageTestDescriptor extends AbstractTestDescriptor {
 	public static final String SEGMENT_TYPE_TEST = "test";
 	public static final String SEGMENT_TYPE_DYNAMIC = "dynamic";
 
-	private final Description description;
+	protected Description description;
 
 	public VintageTestDescriptor(UniqueId uniqueId, Description description) {
 		this(uniqueId, description, generateDisplayName(description), toTestSource(description));
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClassSelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClassSelectorResolver.java
index bab777225..fdccc9bbe 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClassSelectorResolver.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClassSelectorResolver.java
@@ -10,24 +10,72 @@
 
 package org.junit.vintage.engine.discovery;
 
+import static java.util.Collections.emptySet;
+import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.unresolved;
+import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.SEGMENT_TYPE_RUNNER;
+
+import java.util.Optional;
+
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.UniqueId.Segment;
 import org.junit.platform.engine.discovery.ClassSelector;
+import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.support.discovery.SelectorResolver;
+import org.junit.runner.Runner;
+import org.junit.runners.model.RunnerBuilder;
+import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
 
 /**
  * @since 4.12
  */
-class ClassSelectorResolver implements DiscoverySelectorResolver {
+class ClassSelectorResolver implements SelectorResolver {
+
+	private static final RunnerBuilder RUNNER_BUILDER = new DefensiveAllDefaultPossibilitiesBuilder();
+
+	private final ClassFilter classFilter;
+
+	ClassSelectorResolver(ClassFilter classFilter) {
+		this.classFilter = classFilter;
+	}
 
 	@Override
-	public void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector) {
-		// @formatter:off
-		request.getSelectorsByType(ClassSelector.class)
-			.stream()
-			.map(ClassSelector::getJavaClass)
-			.filter(classFilter)
-			.forEach(collector::addCompletely);
-		// @formatter:on
+	public Resolution resolve(ClassSelector selector, Context context) {
+		return resolveTestClass(selector.getJavaClass(), context);
 	}
 
+	@Override
+	public Resolution resolve(UniqueIdSelector selector, Context context) {
+		Segment lastSegment = selector.getUniqueId().getLastSegment();
+		if (SEGMENT_TYPE_RUNNER.equals(lastSegment.getType())) {
+			String testClassName = lastSegment.getValue();
+			Class<?> testClass = ReflectionUtils.tryToLoadClass(testClassName)//
+					.getOrThrow(cause -> new JUnitException("Unknown class: " + testClassName, cause));
+			return resolveTestClass(testClass, context);
+		}
+		return unresolved();
+	}
+
+	private Resolution resolveTestClass(Class<?> testClass, Context context) {
+		if (!classFilter.test(testClass)) {
+			return unresolved();
+		}
+		Runner runner = RUNNER_BUILDER.safeRunnerForClass(testClass);
+		if (runner == null) {
+			return unresolved();
+		}
+		return context.addToParent(parent -> Optional.of(createRunnerTestDescriptor(parent, testClass, runner))).map(
+			runnerTestDescriptor -> Match.exact(runnerTestDescriptor, () -> {
+				runnerTestDescriptor.clearFilters();
+				return emptySet();
+			})).map(Resolution::match).orElse(unresolved());
+	}
+
+	private RunnerTestDescriptor createRunnerTestDescriptor(TestDescriptor parent, Class<?> testClass, Runner runner) {
+		UniqueId uniqueId = parent.getUniqueId().append(SEGMENT_TYPE_RUNNER, testClass.getName());
+		return new RunnerTestDescriptor(uniqueId, testClass, runner);
+	}
 }
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClasspathRootSelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClasspathRootSelectorResolver.java
deleted file mode 100644
index 667eba513..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ClasspathRootSelectorResolver.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static org.junit.platform.commons.util.ReflectionUtils.findAllClassesInClasspathRoot;
-
-import java.util.Collection;
-
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
-import org.junit.platform.engine.discovery.ClasspathRootSelector;
-
-/**
- * @since 4.12
- */
-class ClasspathRootSelectorResolver implements DiscoverySelectorResolver {
-
-	@Override
-	public void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector) {
-		// @formatter:off
-		request.getSelectorsByType(ClasspathRootSelector.class)
-			.stream()
-			.map(ClasspathRootSelector::getClasspathRoot)
-			.map(root -> findAllClassesInClasspathRoot(root, classFilter))
-			.flatMap(Collection::stream)
-			.forEach(collector::addCompletely);
-		// @formatter:on
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DiscoverySelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DiscoverySelectorResolver.java
deleted file mode 100644
index de56c889a..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DiscoverySelectorResolver.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
-
-/**
- * @since 4.12
- */
-interface DiscoverySelectorResolver {
-
-	void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector);
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java
index 88873a7b7..7b9c26d31 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java
@@ -14,6 +14,7 @@ import org.junit.platform.commons.util.Preconditions;
 import org.junit.runner.Description;
 import org.junit.runner.Runner;
 import org.junit.runner.notification.RunNotifier;
+import org.junit.vintage.engine.descriptor.RunnerDecorator;
 
 /**
  * Decorator for Runners that will be ignored completely.
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/MethodSelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/MethodSelectorResolver.java
index 81815efa3..d7da306f9 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/MethodSelectorResolver.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/MethodSelectorResolver.java
@@ -10,33 +10,76 @@
 
 package org.junit.vintage.engine.discovery;
 
-import static org.junit.vintage.engine.discovery.RunnerTestDescriptorAwareFilter.adapter;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
+import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.unresolved;
+import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.SEGMENT_TYPE_RUNNER;
 
 import java.lang.reflect.Method;
+import java.util.Optional;
+import java.util.function.Function;
 
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
+import org.junit.platform.engine.DiscoverySelector;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.discovery.MethodSelector;
+import org.junit.platform.engine.discovery.UniqueIdSelector;
+import org.junit.platform.engine.support.discovery.SelectorResolver;
 import org.junit.runner.Description;
 import org.junit.runner.manipulation.Filter;
+import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
 
 /**
  * @since 4.12
  */
-class MethodSelectorResolver implements DiscoverySelectorResolver {
+class MethodSelectorResolver implements SelectorResolver {
 
 	@Override
-	public void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector) {
-		request.getSelectorsByType(MethodSelector.class).forEach(selector -> resolve(selector, classFilter, collector));
+	public Resolution resolve(MethodSelector selector, Context context) {
+		Class<?> testClass = selector.getJavaClass();
+		return resolveParentAndAddFilter(context, selectClass(testClass), parent -> toMethodFilter(selector));
 	}
 
-	private void resolve(MethodSelector selector, ClassFilter classFilter, TestClassCollector collector) {
-		Class<?> testClass = selector.getJavaClass();
-		if (classFilter.test(testClass)) {
-			Method testMethod = selector.getJavaMethod();
-			Description methodDescription = Description.createTestDescription(testClass, testMethod.getName());
-			collector.addFiltered(testClass, adapter(matchMethodDescription(methodDescription)));
+	@Override
+	public Resolution resolve(UniqueIdSelector selector, Context context) {
+		for (UniqueId current = selector.getUniqueId(); !current.getSegments().isEmpty(); current = current.removeLastSegment()) {
+			if (SEGMENT_TYPE_RUNNER.equals(current.getLastSegment().getType())) {
+				return resolveParentAndAddFilter(context, selectUniqueId(current),
+					parent -> toUniqueIdFilter(parent, selector.getUniqueId()));
+			}
 		}
+		return unresolved();
+	}
+
+	private Resolution resolveParentAndAddFilter(Context context, DiscoverySelector selector,
+			Function<RunnerTestDescriptor, Filter> filterCreator) {
+		return context.resolve(selector).flatMap(parent -> addFilter(parent, filterCreator)).map(
+			this::toResolution).orElse(unresolved());
+	}
+
+	private Optional<RunnerTestDescriptor> addFilter(TestDescriptor parent,
+			Function<RunnerTestDescriptor, Filter> filterCreator) {
+		if (parent instanceof RunnerTestDescriptor) {
+			RunnerTestDescriptor runnerTestDescriptor = (RunnerTestDescriptor) parent;
+			runnerTestDescriptor.getFilters().ifPresent(
+				filters -> filters.add(filterCreator.apply(runnerTestDescriptor)));
+			return Optional.of(runnerTestDescriptor);
+		}
+		return Optional.empty();
+	}
+
+	private Resolution toResolution(RunnerTestDescriptor parent) {
+		return Resolution.match(Match.partial(parent));
+	}
+
+	private Filter toMethodFilter(MethodSelector methodSelector) {
+		Class<?> testClass = methodSelector.getJavaClass();
+		Method testMethod = methodSelector.getJavaMethod();
+		return matchMethodDescription(Description.createTestDescription(testClass, testMethod.getName()));
+	}
+
+	private Filter toUniqueIdFilter(RunnerTestDescriptor runnerTestDescriptor, UniqueId uniqueId) {
+		return new UniqueIdFilter(runnerTestDescriptor, uniqueId);
 	}
 
 	/**
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ModuleNameSelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ModuleNameSelectorResolver.java
deleted file mode 100644
index 8010b9859..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/ModuleNameSelectorResolver.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static org.junit.platform.commons.util.ReflectionUtils.findAllClassesInModule;
-
-import java.util.Collection;
-
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
-import org.junit.platform.engine.discovery.ModuleSelector;
-
-/**
- * @since 4.12.1
- */
-class ModuleNameSelectorResolver implements DiscoverySelectorResolver {
-
-	@Override
-	public void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector) {
-		// @formatter:off
-		request.getSelectorsByType(ModuleSelector.class)
-			.stream()
-			.map(ModuleSelector::getModuleName)
-			.map(moduleName -> findAllClassesInModule(moduleName, classFilter))
-			.flatMap(Collection::stream)
-			.forEach(collector::addCompletely);
-		// @formatter:on
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/PackageNameSelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/PackageNameSelectorResolver.java
deleted file mode 100644
index bec4ad61d..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/PackageNameSelectorResolver.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static org.junit.platform.commons.util.ReflectionUtils.findAllClassesInPackage;
-
-import java.util.Collection;
-
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
-import org.junit.platform.engine.discovery.PackageSelector;
-
-/**
- * @since 4.12
- */
-class PackageNameSelectorResolver implements DiscoverySelectorResolver {
-
-	@Override
-	public void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector) {
-		// @formatter:off
-		request.getSelectorsByType(PackageSelector.class)
-			.stream()
-			.map(PackageSelector::getPackageName)
-			.map(packageName -> findAllClassesInPackage(packageName, classFilter))
-			.flatMap(Collection::stream)
-			.forEach(collector::addCompletely);
-		// @formatter:on
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorAwareFilter.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorAwareFilter.java
deleted file mode 100644
index 0ae51ef4d..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorAwareFilter.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import org.junit.runner.Description;
-import org.junit.runner.manipulation.Filter;
-import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
-
-/**
- * @since 4.12
- */
-abstract class RunnerTestDescriptorAwareFilter extends Filter {
-
-	abstract void initialize(RunnerTestDescriptor runnerTestDescriptor);
-
-	static RunnerTestDescriptorAwareFilter adapter(Filter filter) {
-		return new RunnerTestDescriptorAwareFilter() {
-			@Override
-			void initialize(RunnerTestDescriptor runnerTestDescriptor) {
-				// do nothing
-			}
-
-			@Override
-			public boolean shouldRun(Description description) {
-				return filter.shouldRun(description);
-			}
-
-			@Override
-			public String describe() {
-				return filter.describe();
-			}
-		};
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessor.java
similarity index 52%
rename from junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java
rename to junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessor.java
index 045a9de14..29a10e6fe 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessor.java
@@ -12,7 +12,6 @@ package org.junit.vintage.engine.discovery;
 
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.toCollection;
-import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.SEGMENT_TYPE_RUNNER;
 
 import java.util.ArrayList;
 import java.util.LinkedHashMap;
@@ -25,73 +24,24 @@ import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.engine.UniqueId;
 import org.junit.runner.Description;
-import org.junit.runner.Runner;
-import org.junit.runner.manipulation.Filter;
-import org.junit.runner.manipulation.Filterable;
-import org.junit.runners.model.RunnerBuilder;
 import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
 import org.junit.vintage.engine.descriptor.VintageTestDescriptor;
 import org.junit.vintage.engine.support.UniqueIdReader;
 import org.junit.vintage.engine.support.UniqueIdStringifier;
 
 /**
- * @since 4.12
+ * @since 5.5
  */
-class TestClassRequestResolver {
+class RunnerTestDescriptorPostProcessor {
 
-	private static final Logger logger = LoggerFactory.getLogger(TestClassRequestResolver.class);
-
-	private static final RunnerBuilder RUNNER_BUILDER = new DefensiveAllDefaultPossibilitiesBuilder();
+	private static final Logger logger = LoggerFactory.getLogger(RunnerTestDescriptorPostProcessor.class);
 
 	private final UniqueIdReader uniqueIdReader = new UniqueIdReader();
-
 	private final UniqueIdStringifier uniqueIdStringifier = new UniqueIdStringifier();
 
-	TestClassRequestResolver() {
-	}
-
-	RunnerTestDescriptor createRunnerTestDescriptor(TestClassRequest request, UniqueId engineId) {
-		Class<?> testClass = request.getTestClass();
-		Runner runner = RUNNER_BUILDER.safeRunnerForClass(testClass);
-		if (runner == null) {
-			return null;
-		}
-		return determineRunnerTestDescriptor(testClass, runner, request.getFilters(), engineId);
-	}
-
-	private RunnerTestDescriptor determineRunnerTestDescriptor(Class<?> testClass, Runner runner,
-			List<RunnerTestDescriptorAwareFilter> filters, UniqueId engineId) {
-		RunnerTestDescriptor runnerTestDescriptor = createCompleteRunnerTestDescriptor(testClass, runner, engineId);
-		if (!filters.isEmpty()) {
-			if (runner instanceof Filterable) {
-				Filter filter = createOrFilter(filters, runnerTestDescriptor);
-				Runner filteredRunner = runnerTestDescriptor.toRequest().filterWith(filter).getRunner();
-				runnerTestDescriptor = createCompleteRunnerTestDescriptor(testClass, filteredRunner, engineId);
-			}
-			else {
-				Runner runnerToReport = (runner instanceof RunnerDecorator)
-						? ((RunnerDecorator) runner).getDecoratedRunner()
-						: runner;
-				logger.warn(() -> "Runner " + runnerToReport.getClass().getName() //
-						+ " (used on " + testClass.getName() + ") does not support filtering" //
-						+ " and will therefore be run completely.");
-			}
-		}
-		return runnerTestDescriptor;
-	}
-
-	private Filter createOrFilter(List<RunnerTestDescriptorAwareFilter> filters,
-			RunnerTestDescriptor runnerTestDescriptor) {
-		filters.forEach(filter -> filter.initialize(runnerTestDescriptor));
-		return new OrFilter(filters);
-	}
-
-	private RunnerTestDescriptor createCompleteRunnerTestDescriptor(Class<?> testClass, Runner runner,
-			UniqueId engineId) {
-		UniqueId id = engineId.append(SEGMENT_TYPE_RUNNER, testClass.getName());
-		RunnerTestDescriptor runnerTestDescriptor = new RunnerTestDescriptor(id, testClass, runner);
+	void applyFiltersAndCreateDescendants(RunnerTestDescriptor runnerTestDescriptor) {
 		addChildrenRecursively(runnerTestDescriptor);
-		return runnerTestDescriptor;
+		runnerTestDescriptor.applyFilters(this::addChildrenRecursively);
 	}
 
 	private void addChildrenRecursively(VintageTestDescriptor parent) {
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassCollector.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassCollector.java
deleted file mode 100644
index fc6be3b49..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassCollector.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static java.util.stream.Stream.concat;
-import static org.junit.platform.commons.util.FunctionUtils.where;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.stream.Stream;
-
-/**
- * @since 4.12
- */
-class TestClassCollector {
-
-	private final Set<Class<?>> completeTestClasses = new LinkedHashSet<>();
-	private final Map<Class<?>, List<RunnerTestDescriptorAwareFilter>> filteredTestClasses = new LinkedHashMap<>();
-
-	void addCompletely(Class<?> testClass) {
-		completeTestClasses.add(testClass);
-	}
-
-	void addFiltered(Class<?> testClass, RunnerTestDescriptorAwareFilter filter) {
-		filteredTestClasses.computeIfAbsent(testClass, key -> new ArrayList<>()).add(filter);
-	}
-
-	Stream<TestClassRequest> toRequests() {
-		return concat(completeRequests(), filteredRequests());
-	}
-
-	private Stream<TestClassRequest> completeRequests() {
-		return completeTestClasses.stream().map(TestClassRequest::new);
-	}
-
-	private Stream<TestClassRequest> filteredRequests() {
-		// @formatter:off
-		return filteredTestClasses.entrySet()
-				.stream()
-				.filter(where(Entry::getKey, testClass -> !completeTestClasses.contains(testClass)))
-				.map(entry -> new TestClassRequest(entry.getKey(), entry.getValue()));
-		// @formatter:on
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequest.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequest.java
deleted file mode 100644
index 8c14a85e5..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static java.util.Collections.emptyList;
-
-import java.util.List;
-
-/**
- * @since 4.12
- */
-class TestClassRequest {
-
-	private final Class<?> testClass;
-	private final List<RunnerTestDescriptorAwareFilter> filters;
-
-	TestClassRequest(Class<?> testClass) {
-		this(testClass, emptyList());
-	}
-
-	TestClassRequest(Class<?> testClass, List<RunnerTestDescriptorAwareFilter> filters) {
-		this.testClass = testClass;
-		this.filters = filters;
-	}
-
-	Class<?> getTestClass() {
-		return testClass;
-	}
-
-	List<RunnerTestDescriptorAwareFilter> getFilters() {
-		return filters;
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdFilter.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdFilter.java
index b0daa4552..f2b091fe5 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdFilter.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdFilter.java
@@ -21,28 +21,32 @@ import java.util.Set;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 import org.junit.runner.Description;
+import org.junit.runner.manipulation.Filter;
 import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
 import org.junit.vintage.engine.descriptor.VintageTestDescriptor;
 
 /**
  * @since 4.12
  */
-class UniqueIdFilter extends RunnerTestDescriptorAwareFilter {
+class UniqueIdFilter extends Filter {
 
+	private final RunnerTestDescriptor runnerTestDescriptor;
 	private final UniqueId uniqueId;
 
 	private Deque<Description> path;
 	private Set<Description> descendants;
 
-	UniqueIdFilter(UniqueId uniqueId) {
+	UniqueIdFilter(RunnerTestDescriptor runnerTestDescriptor, UniqueId uniqueId) {
+		this.runnerTestDescriptor = runnerTestDescriptor;
 		this.uniqueId = uniqueId;
 	}
 
-	@Override
-	void initialize(RunnerTestDescriptor runnerTestDescriptor) {
-		Optional<? extends TestDescriptor> identifiedTestDescriptor = runnerTestDescriptor.findByUniqueId(uniqueId);
-		descendants = determineDescendants(identifiedTestDescriptor);
-		path = determinePath(runnerTestDescriptor, identifiedTestDescriptor);
+	private void ensureInitialized() {
+		if (descendants == null) {
+			Optional<? extends TestDescriptor> identifiedTestDescriptor = runnerTestDescriptor.findByUniqueId(uniqueId);
+			descendants = determineDescendants(identifiedTestDescriptor);
+			path = determinePath(runnerTestDescriptor, identifiedTestDescriptor);
+		}
 	}
 
 	private Deque<Description> determinePath(RunnerTestDescriptor runnerTestDescriptor,
@@ -71,6 +75,7 @@ class UniqueIdFilter extends RunnerTestDescriptorAwareFilter {
 
 	@Override
 	public boolean shouldRun(Description description) {
+		ensureInitialized();
 		return path.contains(description) || descendants.contains(description);
 	}
 
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdSelectorResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdSelectorResolver.java
deleted file mode 100644
index 491b501a0..000000000
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/UniqueIdSelectorResolver.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static java.lang.String.format;
-import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.ENGINE_ID;
-import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.SEGMENT_TYPE_RUNNER;
-
-import java.util.Optional;
-
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.engine.EngineDiscoveryRequest;
-import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.UniqueId.Segment;
-import org.junit.platform.engine.discovery.UniqueIdSelector;
-
-/**
- * @since 4.12
- */
-class UniqueIdSelectorResolver implements DiscoverySelectorResolver {
-
-	private static final Logger logger = LoggerFactory.getLogger(UniqueIdSelectorResolver.class);
-
-	@Override
-	public void resolve(EngineDiscoveryRequest request, ClassFilter classFilter, TestClassCollector collector) {
-		// @formatter:off
-		request.getSelectorsByType(UniqueIdSelector.class)
-			.stream()
-			.map(UniqueIdSelector::getUniqueId)
-			.filter(this::isNotEngineId)
-			.filter(this::isForVintageEngine)
-			.forEach(uniqueId -> resolveIntoFilteredTestClass(uniqueId, classFilter, collector));
-		// @formatter:on
-	}
-
-	private boolean isNotEngineId(UniqueId uniqueId) {
-		boolean isEngineId = UniqueId.forEngine(ENGINE_ID).equals(uniqueId);
-		if (isEngineId) {
-			logger.warn(() -> format("Unresolvable Unique ID (%s): Cannot resolve the engine's unique ID", uniqueId));
-		}
-		return !isEngineId;
-	}
-
-	private boolean isForVintageEngine(UniqueId uniqueId) {
-		// @formatter:off
-		return uniqueId.getEngineId()
-			.map(engineId -> engineId.equals(ENGINE_ID))
-			.orElse(false);
-		// @formatter:on
-	}
-
-	private void resolveIntoFilteredTestClass(UniqueId uniqueId, ClassFilter classFilter,
-			TestClassCollector collector) {
-		// @formatter:off
-		determineTestClassName(uniqueId)
-				.flatMap(testClassName -> loadTestClass(testClassName, uniqueId))
-				.filter(classFilter)
-				.ifPresent(testClass -> collector.addFiltered(testClass, new UniqueIdFilter(uniqueId)));
-		// @formatter:on
-	}
-
-	private Optional<Class<?>> loadTestClass(String className, UniqueId uniqueId) {
-		// @formatter:off
-		return ReflectionUtils.tryToLoadClass(className)
-				.ifFailure(cause -> logger.warn(cause, () ->
-						format("Unresolvable Unique ID (%s): Unknown class %s", uniqueId, className)))
-				.toOptional();
-		// @formatter:on
-	}
-
-	private Optional<String> determineTestClassName(UniqueId uniqueId) {
-		Segment runnerSegment = uniqueId.getSegments().get(1); // skip engine node
-		if (SEGMENT_TYPE_RUNNER.equals(runnerSegment.getType())) {
-			return Optional.of(runnerSegment.getValue());
-		}
-		logger.warn(
-			() -> format("Unresolvable Unique ID (%s): Unique ID segment after engine segment must be of type \""
-					+ SEGMENT_TYPE_RUNNER + "\"",
-				uniqueId));
-		return Optional.empty();
-	}
-
-}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/VintageDiscoverer.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/VintageDiscoverer.java
index f871b128f..2a95b3b4a 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/VintageDiscoverer.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/VintageDiscoverer.java
@@ -10,12 +10,7 @@
 
 package org.junit.vintage.engine.discovery;
 
-import static java.util.Arrays.asList;
 import static org.apiguardian.api.API.Status.INTERNAL;
-import static org.junit.platform.engine.support.filter.ClasspathScanningSupport.buildClassNamePredicate;
-
-import java.util.List;
-import java.util.Objects;
 
 import org.apiguardian.api.API;
 import org.junit.platform.commons.util.ClassFilter;
@@ -23,6 +18,8 @@ import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.EngineDescriptor;
+import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver;
+import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
 
 /**
  * @since 4.12
@@ -32,38 +29,25 @@ public class VintageDiscoverer {
 
 	private static final IsPotentialJUnit4TestClass isPotentialJUnit4TestClass = new IsPotentialJUnit4TestClass();
 
-	private final TestClassRequestResolver resolver = new TestClassRequestResolver();
-
-	private final List<DiscoverySelectorResolver> selectorResolvers = asList(
 	// @formatter:off
-			new ClasspathRootSelectorResolver(),
-			new ModuleNameSelectorResolver(),
-			new PackageNameSelectorResolver(),
-			new ClassSelectorResolver(),
-			new MethodSelectorResolver(),
-			new UniqueIdSelectorResolver()
+	private static final EngineDiscoveryRequestResolver<TestDescriptor> resolver = EngineDiscoveryRequestResolver.builder()
+			.addClassContainerSelectorResolver(isPotentialJUnit4TestClass)
+			.addSelectorResolver(context -> new ClassSelectorResolver(ClassFilter.of(context.getClassNameFilter(), isPotentialJUnit4TestClass)))
+			.addSelectorResolver(new MethodSelectorResolver())
+			.build();
 	// @formatter:on
-	);
 
 	public TestDescriptor discover(EngineDiscoveryRequest discoveryRequest, UniqueId uniqueId) {
 		EngineDescriptor engineDescriptor = new EngineDescriptor(uniqueId, "JUnit Vintage");
+		resolver.resolve(discoveryRequest, engineDescriptor);
+		RunnerTestDescriptorPostProcessor postProcessor = new RunnerTestDescriptorPostProcessor();
 		// @formatter:off
-		collectTestClasses(discoveryRequest)
-				.toRequests()
-				.map(request -> resolver.createRunnerTestDescriptor(request, uniqueId))
-				.filter(Objects::nonNull)
-				.forEach(engineDescriptor::addChild);
+		engineDescriptor.getChildren().stream()
+				.filter(RunnerTestDescriptor.class::isInstance)
+				.map(RunnerTestDescriptor.class::cast)
+				.forEach(postProcessor::applyFiltersAndCreateDescendants);
 		// @formatter:on
 		return engineDescriptor;
 	}
 
-	private TestClassCollector collectTestClasses(EngineDiscoveryRequest discoveryRequest) {
-		ClassFilter classFilter = ClassFilter.of(buildClassNamePredicate(discoveryRequest), isPotentialJUnit4TestClass);
-		TestClassCollector collector = new TestClassCollector();
-		for (DiscoverySelectorResolver selectorResolver : selectorResolvers) {
-			selectorResolver.resolve(discoveryRequest, classFilter, collector);
-		}
-		return collector;
-	}
-
 }
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/OrFilterTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/descriptor/OrFilterTests.java
similarity index 97%
rename from junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/OrFilterTests.java
rename to junit-vintage-engine/src/test/java/org/junit/vintage/engine/descriptor/OrFilterTests.java
index 80d1e914d..df0cc4b5e 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/OrFilterTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/descriptor/OrFilterTests.java
@@ -8,7 +8,7 @@
  * https://www.eclipse.org/legal/epl-v20.html
  */
 
-package org.junit.vintage.engine.discovery;
+package org.junit.vintage.engine.descriptor;
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.emptyList;
@@ -28,7 +28,7 @@ import org.junit.runner.Description;
 import org.junit.runner.manipulation.Filter;
 
 /**
- * @since 4.12
+ * @since 5.5
  */
 class OrFilterTests {
 
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessorTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessorTests.java
new file mode 100644
index 000000000..ebb30d1d9
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/RunnerTestDescriptorPostProcessorTests.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.discovery;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
+
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.engine.TrackLogRecords;
+import org.junit.platform.commons.logging.LogRecordListener;
+import org.junit.platform.engine.DiscoverySelector;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
+import org.junit.vintage.engine.VintageUniqueIdBuilder;
+import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
+import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCase;
+import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCaseWithNotFilterableRunner;
+import org.junit.vintage.engine.samples.junit4.NotFilterableRunner;
+import org.junit.vintage.engine.samples.junit4.PlainJUnit4TestCaseWithFiveTestMethods;
+
+/**
+ * Tests for {@link RunnerTestDescriptorPostProcessor}.
+ *
+ * @since 5.5
+ */
+@TrackLogRecords
+class RunnerTestDescriptorPostProcessorTests {
+
+	@Test
+	void doesNotLogAnythingForFilterableRunner(LogRecordListener listener) {
+		resolve(selectMethod(PlainJUnit4TestCaseWithFiveTestMethods.class, "someTest"));
+
+		assertThat(listener.stream(RunnerTestDescriptor.class)).isEmpty();
+	}
+
+	@Test
+	void doesNotLogAnythingForNonFilterableRunnerIfNoFiltersAreToBeApplied(LogRecordListener listener) {
+		resolve(selectClass(IgnoredJUnit4TestCase.class));
+
+		assertThat(listener.stream(RunnerTestDescriptor.class)).isEmpty();
+	}
+
+	@Test
+	void logsWarningOnNonFilterableRunner(LogRecordListener listener) {
+		Class<?> testClass = IgnoredJUnit4TestCaseWithNotFilterableRunner.class;
+
+		resolve(selectMethod(testClass, "someTest"));
+
+		// @formatter:off
+		assertThat(listener.stream(RunnerTestDescriptor.class, Level.WARNING).map(LogRecord::getMessage))
+				.containsOnlyOnce("Runner " + NotFilterableRunner.class.getName()
+						+ " (used on class " + testClass.getName() + ") does not support filtering"
+						+ " and will therefore be run completely.");
+		// @formatter:on
+	}
+
+	private void resolve(DiscoverySelector selector) {
+		LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request().selectors(selector).build();
+		TestDescriptor engineDescriptor = new VintageDiscoverer().discover(request, VintageUniqueIdBuilder.engineId());
+		RunnerTestDescriptor runnerTestDescriptor = (RunnerTestDescriptor) getOnlyElement(
+			engineDescriptor.getChildren());
+		new RunnerTestDescriptorPostProcessor().applyFiltersAndCreateDescendants(runnerTestDescriptor);
+	}
+
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java
deleted file mode 100644
index 30a196e7c..000000000
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static java.util.Collections.emptyList;
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.runner.Description.createTestDescription;
-import static org.junit.runner.manipulation.Filter.matchMethodDescription;
-import static org.junit.vintage.engine.discovery.RunnerTestDescriptorAwareFilter.adapter;
-
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.engine.TrackLogRecords;
-import org.junit.platform.commons.logging.LogRecordListener;
-import org.junit.vintage.engine.VintageUniqueIdBuilder;
-import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCase;
-import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCaseWithNotFilterableRunner;
-import org.junit.vintage.engine.samples.junit4.NotFilterableRunner;
-import org.junit.vintage.engine.samples.junit4.PlainJUnit4TestCaseWithFiveTestMethods;
-
-/**
- * Tests for {@link TestClassRequestResolver}.
- *
- * @since 4.12
- */
-@TrackLogRecords
-class TestClassRequestResolverTests {
-
-	@Test
-	void doesNotLogAnythingForFilterableRunner(LogRecordListener listener) {
-		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
-		RunnerTestDescriptorAwareFilter filter = adapter(
-			matchMethodDescription(createTestDescription(testClass, "failingTest")));
-
-		resolve(new TestClassRequest(testClass, singletonList(filter)));
-
-		assertThat(listener.stream(TestClassRequestResolver.class)).isEmpty();
-	}
-
-	@Test
-	void doesNotLogAnythingForNonFilterableRunnerIfNoFiltersAreToBeApplied(LogRecordListener listener) {
-		Class<?> testClass = IgnoredJUnit4TestCase.class;
-		List<RunnerTestDescriptorAwareFilter> filters = emptyList();
-
-		resolve(new TestClassRequest(testClass, filters));
-
-		assertThat(listener.stream(TestClassRequestResolver.class)).isEmpty();
-	}
-
-	@Test
-	void logsWarningOnNonFilterableRunner(LogRecordListener listener) {
-		Class<?> testClass = IgnoredJUnit4TestCaseWithNotFilterableRunner.class;
-		RunnerTestDescriptorAwareFilter filter = adapter(
-			matchMethodDescription(createTestDescription(testClass, "failingTest")));
-
-		resolve(new TestClassRequest(testClass, singletonList(filter)));
-
-		// @formatter:off
-		assertThat(listener.stream(TestClassRequestResolver.class, Level.WARNING).map(LogRecord::getMessage))
-				.containsOnlyOnce("Runner " + NotFilterableRunner.class.getName()
-						+ " (used on " + testClass.getName() + ") does not support filtering"
-						+ " and will therefore be run completely.");
-		// @formatter:on
-	}
-
-	private void resolve(TestClassRequest request) {
-		TestClassRequestResolver resolver = new TestClassRequestResolver();
-		resolver.createRunnerTestDescriptor(request, VintageUniqueIdBuilder.engineId());
-	}
-
-}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/UniqueIdSelectorResolverTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/UniqueIdSelectorResolverTests.java
deleted file mode 100644
index 946d25a59..000000000
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/UniqueIdSelectorResolverTests.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright 2015-2019 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.vintage.engine.discovery;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
-import static org.junit.vintage.engine.VintageUniqueIdBuilder.engineId;
-import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.ENGINE_ID;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.util.Collections;
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.stream.Stream;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.engine.TrackLogRecords;
-import org.junit.platform.commons.logging.LogRecordListener;
-import org.junit.platform.commons.util.ClassFilter;
-import org.junit.platform.engine.EngineDiscoveryRequest;
-import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.discovery.UniqueIdSelector;
-import org.junit.vintage.engine.VintageUniqueIdBuilder;
-
-/**
- * Tests for {@link UniqueIdSelectorResolver}.
- *
- * @since 4.12
- */
-@TrackLogRecords
-class UniqueIdSelectorResolverTests {
-
-	private static final ClassFilter allClassesPredicate = ClassFilter.of(clazz -> true);
-
-	private final TestClassCollector collector = new TestClassCollector();
-
-	@Test
-	void logsWarningOnUnloadableTestClass(LogRecordListener listener) {
-		UniqueId uniqueId = VintageUniqueIdBuilder.uniqueIdForClass("foo.bar.UnknownClass");
-		EngineDiscoveryRequest request = requestWithSelector(selectUniqueId(uniqueId));
-
-		new UniqueIdSelectorResolver().resolve(request, allClassesPredicate, collector);
-
-		assertNoRequests();
-		assertLoggedWarning(listener, "Unresolvable Unique ID (" + uniqueId + "): Unknown class foo.bar.UnknownClass");
-	}
-
-	@Test
-	void logsWarningForEngineUniqueId(LogRecordListener listener) {
-		String uniqueId = engineId().toString();
-		EngineDiscoveryRequest request = requestWithSelector(selectUniqueId(uniqueId));
-
-		new UniqueIdSelectorResolver().resolve(request, allClassesPredicate, collector);
-
-		assertNoRequests();
-		assertLoggedWarning(listener,
-			"Unresolvable Unique ID (" + engineId() + "): Cannot resolve the engine's unique ID");
-	}
-
-	@Test
-	void ignoresUniqueIdsOfOtherEngines(LogRecordListener listener) {
-		UniqueId uniqueId = UniqueId.forEngine("someEngine");
-		EngineDiscoveryRequest request = requestWithSelector(selectUniqueId(uniqueId));
-
-		new UniqueIdSelectorResolver().resolve(request, allClassesPredicate, collector);
-
-		assertNoRequests();
-		assertThat(listener.stream(UniqueIdSelectorResolver.class)).isEmpty();
-	}
-
-	@Test
-	void logsWarningOnUnexpectedTestDescriptor(LogRecordListener listener) {
-		UniqueId uniqueId = UniqueId.forEngine(ENGINE_ID).append("wrong-type", "foo:bar");
-		EngineDiscoveryRequest request = requestWithSelector(selectUniqueId(uniqueId));
-
-		new UniqueIdSelectorResolver().resolve(request, allClassesPredicate, collector);
-
-		assertNoRequests();
-		assertLoggedWarning(listener, "Unresolvable Unique ID (" + uniqueId
-				+ "): Unique ID segment after engine segment must be of type \"runner\"");
-	}
-
-	private void assertLoggedWarning(LogRecordListener listener, String expectedMessage) {
-		// @formatter:off
-		assertThat(listener.stream(UniqueIdSelectorResolver.class, Level.WARNING)
-			.map(LogRecord::getMessage)
-			.filter(m -> m.equals(expectedMessage))
-			.count()
-		).isEqualTo(1);
-		// @formatter:on
-	}
-
-	private void assertNoRequests() {
-		Stream<TestClassRequest> requests = collector.toRequests();
-		assertThat(requests).isEmpty();
-	}
-
-	private EngineDiscoveryRequest requestWithSelector(UniqueIdSelector selector) {
-		EngineDiscoveryRequest request = mock(EngineDiscoveryRequest.class);
-		when(request.getSelectorsByType(UniqueIdSelector.class)).thenReturn(Collections.singletonList(selector));
-		return request;
-	}
-
-}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/VintageDiscovererTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/VintageDiscovererTests.java
index 776dedca6..9ca11892b 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/VintageDiscovererTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/VintageDiscovererTests.java
@@ -13,17 +13,25 @@ package org.junit.vintage.engine.discovery;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 import static org.junit.vintage.engine.VintageUniqueIdBuilder.engineId;
 
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.engine.TrackLogRecords;
 import org.junit.platform.commons.logging.LogRecordListener;
+import org.junit.platform.engine.DiscoverySelector;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.discovery.ClassNameFilter;
 import org.junit.platform.engine.discovery.PackageNameFilter;
+import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.vintage.engine.VintageUniqueIdBuilder;
 import org.junit.vintage.engine.samples.junit3.AbstractJUnit3TestCase;
 import org.junit.vintage.engine.samples.junit4.AbstractJunit4TestCaseWithConstructorParameter;
 
@@ -44,8 +52,7 @@ class VintageDiscovererTests {
 				.build();
 		// @formatter:on
 
-		VintageDiscoverer discoverer = new VintageDiscoverer();
-		TestDescriptor testDescriptor = discoverer.discover(request, engineId());
+		TestDescriptor testDescriptor = discover(request);
 
 		assertThat(testDescriptor.getChildren()).hasSize(1);
 		assertThat(getOnlyElement(testDescriptor.getChildren()).getUniqueId().toString()).contains(Foo.class.getName());
@@ -60,30 +67,48 @@ class VintageDiscovererTests {
 				.build();
 		// @formatter:on
 
-		VintageDiscoverer discoverer = new VintageDiscoverer();
-		TestDescriptor testDescriptor = discoverer.discover(request, engineId());
+		TestDescriptor testDescriptor = discover(request);
 
 		assertThat(testDescriptor.getChildren()).isEmpty();
 	}
 
 	@Test
 	void doesNotResolveAbstractJUnit3Classes(LogRecordListener listener) {
-		doesNotResolve(listener, AbstractJUnit3TestCase.class);
+		doesNotResolve(listener, selectClass(AbstractJUnit3TestCase.class));
 	}
 
 	@Test
 	void doesNotResolveAbstractJUnit4Classes(LogRecordListener listener) {
-		doesNotResolve(listener, AbstractJunit4TestCaseWithConstructorParameter.class);
+		doesNotResolve(listener, selectClass(AbstractJunit4TestCaseWithConstructorParameter.class));
 	}
 
-	private void doesNotResolve(LogRecordListener listener, Class<?> testClass) {
-		LauncherDiscoveryRequest request = request().selectors(selectClass(testClass)).build();
+	@Test
+	void logsWarningOnUnloadableTestClass(LogRecordListener listener) {
+		UniqueId uniqueId = VintageUniqueIdBuilder.uniqueIdForClass("foo.bar.UnknownClass");
+
+		doesNotResolve(listener, selectUniqueId(uniqueId));
 
-		VintageDiscoverer discoverer = new VintageDiscoverer();
-		TestDescriptor testDescriptor = discoverer.discover(request, engineId());
+		LogRecord logRecord = listener.stream(EngineDiscoveryRequestResolver.class, Level.WARNING).findFirst().get();
+		assertThat(logRecord.getMessage()).isEqualTo(
+			"UniqueIdSelector [uniqueId = " + uniqueId + "] could not be resolved.");
+		assertThat(logRecord.getThrown()).hasCauseInstanceOf(ClassNotFoundException.class);
+	}
+
+	@Test
+	void ignoresUniqueIdsOfOtherEngines(LogRecordListener listener) {
+		doesNotResolve(listener, selectUniqueId(UniqueId.forEngine("someEngine")));
+	}
+
+	private void doesNotResolve(LogRecordListener listener, DiscoverySelector selector) {
+		LauncherDiscoveryRequest request = request().selectors(selector).build();
+
+		TestDescriptor testDescriptor = discover(request);
 
 		assertThat(testDescriptor.getChildren()).isEmpty();
-		assertThat(listener.stream(VintageDiscoverer.class)).isEmpty();
+	}
+
+	private TestDescriptor discover(EngineDiscoveryRequest request) {
+		return new VintageDiscoverer().discover(request, engineId());
 	}
 
 	public static class Foo {
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java
index aee990bd0..9b2f6b04e 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java
@@ -10,6 +10,7 @@
 
 package org.junit.vintage.engine.samples.junit4;
 
+import org.junit.Test;
 import org.junit.experimental.categories.Category;
 import org.junit.runner.RunWith;
 import org.junit.vintage.engine.samples.junit4.ConfigurableRunner.ChildCount;
@@ -21,4 +22,9 @@ import org.junit.vintage.engine.samples.junit4.ConfigurableRunner.ChildCount;
 @ChildCount(2)
 @Category(Categories.Successful.class)
 public class JUnit4TestCaseWithNotFilterableRunner {
+
+	@Test
+	public void someTest() {
+	}
+
 }
diff --git a/junit-vintage-engine/src/test/resources/log4j2-test.xml b/junit-vintage-engine/src/test/resources/log4j2-test.xml
index 9e8694f83..657d9b667 100644
--- a/junit-vintage-engine/src/test/resources/log4j2-test.xml
+++ b/junit-vintage-engine/src/test/resources/log4j2-test.xml
@@ -8,6 +8,7 @@
 	<Loggers>
 		<Logger name="org.junit" level="warn" />
 		<Logger name="org.junit.vintage.engine" level="error" />
+		<Logger name="org.junit.platform.engine.support.discovery" level="error" />
 		<Root level="error">
 			<AppenderRef ref="Console" />
 		</Root>
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java b/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java
index 6813251be..3497616cb 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java
@@ -13,6 +13,7 @@ package org.junit.platform.engine;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -259,6 +260,29 @@ class UniqueIdTests {
 
 	}
 
+	@Nested
+	class LastSegment {
+
+		@Test
+		void returnsLastSegment() {
+			UniqueId uniqueId = UniqueId.forEngine("foo");
+			assertSame(uniqueId.getSegments().get(0), uniqueId.getLastSegment());
+
+			uniqueId = UniqueId.forEngine("foo").append("type", "bar");
+			assertSame(uniqueId.getSegments().get(1), uniqueId.getLastSegment());
+		}
+
+		@Test
+		void removesLastSegment() {
+			UniqueId uniqueId = UniqueId.forEngine("foo");
+			assertThrows(PreconditionViolationException.class, uniqueId::removeLastSegment);
+
+			UniqueId newUniqueId = uniqueId.append("type", "bar").removeLastSegment();
+			assertEquals(uniqueId, newUniqueId);
+		}
+
+	}
+
 	private void assertSegment(Segment segment, String expectedType, String expectedValue) {
 		assertEquals(expectedType, segment.getType(), "segment type");
 		assertEquals(expectedValue, segment.getValue(), "segment value");
diff --git a/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt b/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt
index ffcc09833..e294e32df 100644
--- a/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt
+++ b/platform-tooling-support-tests/projects/jar-describe-module/junit-platform-engine.expected.txt
@@ -7,5 +7,6 @@ contains org.junit.platform.engine.discovery
 contains org.junit.platform.engine.reporting
 contains org.junit.platform.engine.support.config
 contains org.junit.platform.engine.support.descriptor
+contains org.junit.platform.engine.support.discovery
 contains org.junit.platform.engine.support.filter
 contains org.junit.platform.engine.support.hierarchical
diff --git a/platform-tooling-support-tests/projects/multi-release-jar/default/src/test/java/integration/integration/JupiterIntegrationTests.java b/platform-tooling-support-tests/projects/multi-release-jar/default/src/test/java/integration/integration/JupiterIntegrationTests.java
index 7486586dc..438364485 100644
--- a/platform-tooling-support-tests/projects/multi-release-jar/default/src/test/java/integration/integration/JupiterIntegrationTests.java
+++ b/platform-tooling-support-tests/projects/multi-release-jar/default/src/test/java/integration/integration/JupiterIntegrationTests.java
@@ -14,22 +14,20 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.launcher.EngineFilter.includeEngines;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 
 import org.junit.jupiter.api.MethodOrderer.Alphanumeric;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.condition.EnabledIf;
-import org.junit.jupiter.engine.config.DefaultJupiterConfiguration;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
-import org.junit.jupiter.engine.discovery.DiscoverySelectorResolver;
+import org.junit.platform.commons.util.CollectionUtils;
 import org.junit.platform.commons.util.ModuleUtils;
-import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
 import org.junit.platform.engine.discovery.ModuleSelector;
-import org.junit.platform.engine.support.descriptor.EngineDescriptor;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.launcher.TestIdentifier;
+import org.junit.platform.launcher.TestPlan;
+import org.junit.platform.launcher.core.LauncherFactory;
 
 @TestMethodOrder(Alphanumeric.class)
 class JupiterIntegrationTests {
@@ -57,15 +55,15 @@ class JupiterIntegrationTests {
 		ModuleSelector selector = DiscoverySelectors.selectModule(getClass().getModule().getName());
 		assertEquals(getClass().getModule().getName(), selector.getModuleName());
 
-		LauncherDiscoveryRequest request = request().selectors(selector).build();
-		JupiterConfiguration configuration = new DefaultJupiterConfiguration(request.getConfigurationParameters());
-		EngineDescriptor engine = new JupiterEngineDescriptor(UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID), configuration);
-		DiscoverySelectorResolver resolver = new DiscoverySelectorResolver();
+		TestPlan testPlan = LauncherFactory.create().discover(request()
+				.selectors(selector)
+				.filters(includeEngines("junit-jupiter"))
+				.build());
 
-		resolver.resolveSelectors(request, configuration, engine);
+		TestIdentifier engine = CollectionUtils.getOnlyElement(testPlan.getRoots());
 
-		assertEquals(1, engine.getChildren().size()); // JupiterIntegrationTests.class
-		assertEquals(5, getOnlyElement(engine.getChildren()).getChildren().size()); // 5 test methods
+		assertEquals(1, testPlan.getChildren(engine).size()); // JupiterIntegrationTests.class
+		assertEquals(5, testPlan.getChildren(getOnlyElement(testPlan.getChildren(engine))).size()); // 5 test methods
 	}
 
 	@Test
diff --git a/platform-tooling-support-tests/projects/multi-release-jar/no-scripting/src/test/java/integration/integration/JupiterIntegrationTests.java b/platform-tooling-support-tests/projects/multi-release-jar/no-scripting/src/test/java/integration/integration/JupiterIntegrationTests.java
index 7486586dc..438364485 100644
--- a/platform-tooling-support-tests/projects/multi-release-jar/no-scripting/src/test/java/integration/integration/JupiterIntegrationTests.java
+++ b/platform-tooling-support-tests/projects/multi-release-jar/no-scripting/src/test/java/integration/integration/JupiterIntegrationTests.java
@@ -14,22 +14,20 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.launcher.EngineFilter.includeEngines;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 
 import org.junit.jupiter.api.MethodOrderer.Alphanumeric;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.condition.EnabledIf;
-import org.junit.jupiter.engine.config.DefaultJupiterConfiguration;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
-import org.junit.jupiter.engine.discovery.DiscoverySelectorResolver;
+import org.junit.platform.commons.util.CollectionUtils;
 import org.junit.platform.commons.util.ModuleUtils;
-import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
 import org.junit.platform.engine.discovery.ModuleSelector;
-import org.junit.platform.engine.support.descriptor.EngineDescriptor;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.launcher.TestIdentifier;
+import org.junit.platform.launcher.TestPlan;
+import org.junit.platform.launcher.core.LauncherFactory;
 
 @TestMethodOrder(Alphanumeric.class)
 class JupiterIntegrationTests {
@@ -57,15 +55,15 @@ class JupiterIntegrationTests {
 		ModuleSelector selector = DiscoverySelectors.selectModule(getClass().getModule().getName());
 		assertEquals(getClass().getModule().getName(), selector.getModuleName());
 
-		LauncherDiscoveryRequest request = request().selectors(selector).build();
-		JupiterConfiguration configuration = new DefaultJupiterConfiguration(request.getConfigurationParameters());
-		EngineDescriptor engine = new JupiterEngineDescriptor(UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID), configuration);
-		DiscoverySelectorResolver resolver = new DiscoverySelectorResolver();
+		TestPlan testPlan = LauncherFactory.create().discover(request()
+				.selectors(selector)
+				.filters(includeEngines("junit-jupiter"))
+				.build());
 
-		resolver.resolveSelectors(request, configuration, engine);
+		TestIdentifier engine = CollectionUtils.getOnlyElement(testPlan.getRoots());
 
-		assertEquals(1, engine.getChildren().size()); // JupiterIntegrationTests.class
-		assertEquals(5, getOnlyElement(engine.getChildren()).getChildren().size()); // 5 test methods
+		assertEquals(1, testPlan.getChildren(engine).size()); // JupiterIntegrationTests.class
+		assertEquals(5, testPlan.getChildren(getOnlyElement(testPlan.getChildren(engine))).size()); // 5 test methods
 	}
 
 	@Test
