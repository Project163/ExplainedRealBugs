diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index e4dee9ca8..0a0862b6f 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2672,6 +2672,11 @@ The following example demonstrates how to use the custom `@JimfsTempDir` annotat
 include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_composed_annotation_usage]
 ----
 
+Meta-annotations or additional annotations on the field or parameter the `TempDir`
+annotation is declared on might expose additional attributes to configure the factory.
+Such annotations and related attributes can be accessed via the `AnnotatedElementContext`
+parameter of `createTempDirectory`.
+
 You can use the `junit.jupiter.tempdir.factory.default`
 <<running-tests-config-params, configuration parameter>> to specify the fully qualified
 class name of the `TempDirFactory` you would like to use by default. Just like for
diff --git a/documentation/src/test/java/example/TempDirectoryDemo.java b/documentation/src/test/java/example/TempDirectoryDemo.java
index d45961698..027242993 100644
--- a/documentation/src/test/java/example/TempDirectoryDemo.java
+++ b/documentation/src/test/java/example/TempDirectoryDemo.java
@@ -32,6 +32,7 @@ import example.TempDirectoryDemo.InMemoryTempDirDemo.JimfsTempDirFactory;
 import example.util.ListWriter;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.api.io.TempDirFactory;
@@ -110,8 +111,9 @@ class TempDirectoryDemo {
 		static class Factory implements TempDirFactory {
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws IOException {
-				return Files.createTempDirectory(context.getRequiredTestMethod().getName());
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws IOException {
+				return Files.createTempDirectory(extensionContext.getRequiredTestMethod().getName());
 			}
 
 		}
@@ -133,7 +135,8 @@ class TempDirectoryDemo {
 			private final FileSystem fileSystem = Jimfs.newFileSystem(Configuration.unix());
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws IOException {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws IOException {
 				return Files.createTempDirectory(fileSystem.getPath("/"), "junit");
 			}
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/AnnotatedElementContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/AnnotatedElementContext.java
new file mode 100644
index 000000000..49cf3500a
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/AnnotatedElementContext.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2015-2023 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.AnnotatedElement;
+import java.util.List;
+import java.util.Optional;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.support.AnnotationSupport;
+
+/**
+ * {@code AnnotatedElementContext} encapsulates the <em>context</em> in which an
+ * {@link #getAnnotatedElement() AnnotatedElement} is declared.
+ *
+ * <p>For example, an {@code AnnotatedElementContext} is used in
+ * {@link org.junit.jupiter.api.io.TempDirFactory TempDirFactory} to allow inspecting
+ * the field or parameter the {@link org.junit.jupiter.api.io.TempDir TempDir}
+ * annotation is declared on.
+ *
+ * <p>This interface is not intended to be implemented by clients.
+ *
+ * @since 5.10
+ */
+@API(status = EXPERIMENTAL, since = "5.10")
+public interface AnnotatedElementContext {
+
+	/**
+	 * Get the {@link AnnotatedElement} for this context.
+	 *
+	 * <h4>WARNING</h4>
+	 * <p>When searching for annotations on the annotated element in this context,
+	 * favor {@link #isAnnotated(Class)}, {@link #findAnnotation(Class)}, and
+	 * {@link #findRepeatableAnnotations(Class)} over methods in the
+	 * {@link AnnotatedElement} API due to a bug in {@code javac} on JDK versions prior
+	 * to JDK 9.
+	 *
+	 * @return the annotated element; never {@code null}
+	 */
+	AnnotatedElement getAnnotatedElement();
+
+	/**
+	 * Determine if an annotation of {@code annotationType} is either
+	 * <em>present</em> or <em>meta-present</em> on the {@link AnnotatedElement} for
+	 * this context.
+	 *
+	 * <h4>WARNING</h4>
+	 * <p>Favor the use of this method over directly invoking
+	 * {@link AnnotatedElement#isAnnotationPresent(Class)} due to a bug in {@code javac}
+	 * on JDK versions prior to JDK 9.
+	 *
+	 * @param annotationType the annotation type to search for; never {@code null}
+	 * @return {@code true} if the annotation is present or meta-present
+	 * @see #findAnnotation(Class)
+	 * @see #findRepeatableAnnotations(Class)
+	 */
+	default boolean isAnnotated(Class<? extends Annotation> annotationType) {
+		return AnnotationSupport.isAnnotated(getAnnotatedElement(), annotationType);
+	}
+
+	/**
+	 * Find the first annotation of {@code annotationType} that is either
+	 * <em>present</em> or <em>meta-present</em> on the {@link AnnotatedElement} for
+	 * this context.
+	 *
+	 * <h4>WARNING</h4>
+	 * <p>Favor the use of this method over directly invoking annotation lookup
+	 * methods in the {@link AnnotatedElement} API due to a bug in {@code javac} on JDK
+	 * versions prior to JDK 9.
+	 *
+	 * @param <A> the annotation type
+	 * @param annotationType the annotation type to search for; never {@code null}
+	 * @return an {@code Optional} containing the annotation; never {@code null} but
+	 * potentially empty
+	 * @see #isAnnotated(Class)
+	 * @see #findRepeatableAnnotations(Class)
+	 */
+	default <A extends Annotation> Optional<A> findAnnotation(Class<A> annotationType) {
+		return AnnotationSupport.findAnnotation(getAnnotatedElement(), annotationType);
+	}
+
+	/**
+	 * Find all <em>repeatable</em> {@linkplain Annotation annotations} of
+	 * {@code annotationType} that are either <em>present</em> or
+	 * <em>meta-present</em> on the {@link AnnotatedElement} for this context.
+	 *
+	 * <h4>WARNING</h4>
+	 * <p>Favor the use of this method over directly invoking annotation lookup
+	 * methods in the {@link AnnotatedElement} API due to a bug in {@code javac} on JDK
+	 * versions prior to JDK 9.
+	 *
+	 * @param <A> the annotation type
+	 * @param annotationType the repeatable annotation type to search for; never
+	 * {@code null}
+	 * @return the list of all such annotations found; neither {@code null} nor
+	 * mutable, but potentially empty
+	 * @see #isAnnotated(Class)
+	 * @see #findAnnotation(Class)
+	 * @see java.lang.annotation.Repeatable
+	 */
+	default <A extends Annotation> List<A> findRepeatableAnnotations(Class<A> annotationType) {
+		return AnnotationSupport.findRepeatableAnnotations(getAnnotatedElement(), annotationType);
+	}
+
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterContext.java
index 1bce9ffbe..88165ba85 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterContext.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterContext.java
@@ -10,9 +10,11 @@
 
 package org.junit.jupiter.api.extension;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.lang.annotation.Annotation;
+import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Executable;
 import java.lang.reflect.Parameter;
 import java.util.List;
@@ -36,7 +38,7 @@ import org.apiguardian.api.API;
  * @see java.lang.reflect.Constructor
  */
 @API(status = STABLE, since = "5.0")
-public interface ParameterContext {
+public interface ParameterContext extends AnnotatedElementContext {
 
 	/**
 	 * Get the {@link Parameter} for this context.
@@ -89,63 +91,43 @@ public interface ParameterContext {
 	Optional<Object> getTarget();
 
 	/**
-	 * Determine if an annotation of {@code annotationType} is either
-	 * <em>present</em> or <em>meta-present</em> on the {@link Parameter} for
-	 * this context.
-	 *
-	 * <h4>WARNING</h4>
-	 * <p>Favor the use of this method over directly invoking
-	 * {@link Parameter#isAnnotationPresent(Class)} due to a bug in {@code javac}
-	 * on JDK versions prior to JDK 9.
-	 *
-	 * @param annotationType the annotation type to search for; never {@code null}
-	 * @return {@code true} if the annotation is present or meta-present
+	 * {@inheritDoc}
+	 * @since 5.10
+	 */
+	@API(status = EXPERIMENTAL, since = "5.10")
+	@Override
+	default AnnotatedElement getAnnotatedElement() {
+		return getParameter();
+	}
+
+	/**
+	 * {@inheritDoc}
 	 * @since 5.1.1
-	 * @see #findAnnotation(Class)
-	 * @see #findRepeatableAnnotations(Class)
 	 */
-	boolean isAnnotated(Class<? extends Annotation> annotationType);
+	@API(status = STABLE, since = "5.10")
+	@Override
+	default boolean isAnnotated(Class<? extends Annotation> annotationType) {
+		return AnnotatedElementContext.super.isAnnotated(annotationType);
+	}
 
 	/**
-	 * Find the first annotation of {@code annotationType} that is either
-	 * <em>present</em> or <em>meta-present</em> on the {@link Parameter} for
-	 * this context.
-	 *
-	 * <h4>WARNING</h4>
-	 * <p>Favor the use of this method over directly invoking annotation lookup
-	 * methods in the {@link Parameter} API due to a bug in {@code javac} on JDK
-	 * versions prior to JDK 9.
-	 *
-	 * @param <A> the annotation type
-	 * @param annotationType the annotation type to search for; never {@code null}
-	 * @return an {@code Optional} containing the annotation; never {@code null} but
-	 * potentially empty
+	 * {@inheritDoc}
 	 * @since 5.1.1
-	 * @see #isAnnotated(Class)
-	 * @see #findRepeatableAnnotations(Class)
 	 */
-	<A extends Annotation> Optional<A> findAnnotation(Class<A> annotationType);
+	@API(status = STABLE, since = "5.10")
+	@Override
+	default <A extends Annotation> Optional<A> findAnnotation(Class<A> annotationType) {
+		return AnnotatedElementContext.super.findAnnotation(annotationType);
+	}
 
 	/**
-	 * Find all <em>repeatable</em> {@linkplain Annotation annotations} of
-	 * {@code annotationType} that are either <em>present</em> or
-	 * <em>meta-present</em> on the {@link Parameter} for this context.
-	 *
-	 * <h4>WARNING</h4>
-	 * <p>Favor the use of this method over directly invoking annotation lookup
-	 * methods in the {@link Parameter} API due to a bug in {@code javac} on JDK
-	 * versions prior to JDK 9.
-	 *
-	 * @param <A> the annotation type
-	 * @param annotationType the repeatable annotation type to search for; never
-	 * {@code null}
-	 * @return the list of all such annotations found; neither {@code null} nor
-	 * mutable, but potentially empty
+	 * {@inheritDoc}
 	 * @since 5.1.1
-	 * @see #isAnnotated(Class)
-	 * @see #findAnnotation(Class)
-	 * @see java.lang.annotation.Repeatable
 	 */
-	<A extends Annotation> List<A> findRepeatableAnnotations(Class<A> annotationType);
+	@API(status = STABLE, since = "5.10")
+	@Override
+	default <A extends Annotation> List<A> findRepeatableAnnotations(Class<A> annotationType) {
+		return AnnotatedElementContext.super.findRepeatableAnnotations(annotationType);
+	}
 
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDirFactory.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDirFactory.java
index 97dfe075a..b7ffbc941 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDirFactory.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDirFactory.java
@@ -18,6 +18,7 @@ import java.nio.file.Files;
 import java.nio.file.Path;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.ExtensionContext;
 
 /**
@@ -30,8 +31,9 @@ import org.junit.jupiter.api.extension.ExtensionContext;
  *
  * <p>Implementations must provide a no-args constructor and should not make any
  * assumptions regarding when and how many times they are instantiated, but they
- * can assume that {@link #createTempDirectory(ExtensionContext)} and {@link #close()}
- * will both be called once per instance, in this order, and from the same thread.
+ * can assume that {@link #createTempDirectory(AnnotatedElementContext, ExtensionContext)}
+ * and {@link #close()} will both be called once per instance, in this order,
+ * and from the same thread.
  *
  * <p>A {@link TempDirFactory} can be configured <em>globally</em> for the
  * entire test suite via the {@value TempDir#DEFAULT_FACTORY_PROPERTY_NAME}
@@ -53,11 +55,14 @@ public interface TempDirFactory extends Closeable {
 	 * not be associated with the {@link java.nio.file.FileSystems#getDefault()
 	 * default FileSystem}.
 	 *
-	 * @param context the current extension context; never {@code null}
+	 * @param elementContext the context of the field or parameter where
+	 * {@code @TempDir} is declared; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
 	 * @return the path to the newly created temporary directory; never {@code null}
 	 * @throws Exception in case of failures
 	 */
-	Path createTempDirectory(ExtensionContext context) throws Exception;
+	Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+			throws Exception;
 
 	/**
 	 * {@inheritDoc}
@@ -82,7 +87,8 @@ public interface TempDirFactory extends Closeable {
 		}
 
 		@Override
-		public Path createTempDirectory(ExtensionContext context) throws IOException {
+		public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+				throws IOException {
 			return Files.createTempDirectory(TEMP_DIR_PREFIX);
 		}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
index 0c41baa47..fe76498bd 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
@@ -41,6 +41,7 @@ import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.function.Predicate;
 
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.BeforeAllCallback;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
 import org.junit.jupiter.api.extension.ExtensionConfigurationException;
@@ -59,7 +60,9 @@ import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.ExceptionUtils;
+import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.ToStringBuilder;
 
 /**
  * {@code TempDirectory} is a JUnit Jupiter extension that creates and cleans
@@ -128,7 +131,7 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 				CleanupMode cleanupMode = determineCleanupModeForField(field);
 				TempDirFactory factory = determineTempDirFactoryForField(field, scope);
 				makeAccessible(field).set(testInstance,
-					getPathOrFile(field, field.getType(), factory, cleanupMode, scope, context));
+					getPathOrFile(new FieldContext(field), field.getType(), factory, cleanupMode, scope, context));
 			}
 			catch (Throwable t) {
 				ExceptionUtils.throwAsUncheckedException(t);
@@ -161,8 +164,7 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		CleanupMode cleanupMode = determineCleanupModeForParameter(parameterContext);
 		Scope scope = getScope(extensionContext);
 		TempDirFactory factory = determineTempDirFactoryForParameter(parameterContext, scope);
-		return getPathOrFile(parameterContext.getParameter(), parameterType, factory, cleanupMode, scope,
-			extensionContext);
+		return getPathOrFile(parameterContext, parameterType, factory, cleanupMode, scope, extensionContext);
 	}
 
 	private CleanupMode determineCleanupModeForField(Field field) {
@@ -232,13 +234,13 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		}
 	}
 
-	private Object getPathOrFile(AnnotatedElement sourceElement, Class<?> type, TempDirFactory factory,
+	private Object getPathOrFile(AnnotatedElementContext elementContext, Class<?> type, TempDirFactory factory,
 			CleanupMode cleanupMode, Scope scope, ExtensionContext extensionContext) {
 		Namespace namespace = scope == Scope.PER_DECLARATION //
-				? NAMESPACE.append(sourceElement) //
+				? NAMESPACE.append(elementContext) //
 				: NAMESPACE;
 		Path path = extensionContext.getStore(namespace) //
-				.getOrComputeIfAbsent(KEY, __ -> createTempDir(factory, cleanupMode, extensionContext),
+				.getOrComputeIfAbsent(KEY, __ -> createTempDir(factory, cleanupMode, elementContext, extensionContext),
 					CloseablePath.class) //
 				.get();
 
@@ -246,9 +248,9 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 	}
 
 	static CloseablePath createTempDir(TempDirFactory factory, CleanupMode cleanupMode,
-			ExtensionContext executionContext) {
+			AnnotatedElementContext elementContext, ExtensionContext extensionContext) {
 		try {
-			return new CloseablePath(factory, cleanupMode, executionContext);
+			return new CloseablePath(factory, cleanupMode, elementContext, extensionContext);
 		}
 		catch (Exception ex) {
 			throw new ExtensionConfigurationException("Failed to create default temp directory", ex);
@@ -262,14 +264,14 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		private final Path dir;
 		private final TempDirFactory factory;
 		private final CleanupMode cleanupMode;
-		private final ExtensionContext executionContext;
+		private final ExtensionContext extensionContext;
 
-		CloseablePath(TempDirFactory factory, CleanupMode cleanupMode, ExtensionContext executionContext)
-				throws Exception {
-			this.dir = factory.createTempDirectory(executionContext);
+		CloseablePath(TempDirFactory factory, CleanupMode cleanupMode, AnnotatedElementContext elementContext,
+				ExtensionContext extensionContext) throws Exception {
+			this.dir = factory.createTempDirectory(elementContext, extensionContext);
 			this.factory = factory;
 			this.cleanupMode = cleanupMode;
-			this.executionContext = executionContext;
+			this.extensionContext = extensionContext;
 		}
 
 		Path get() {
@@ -280,12 +282,12 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		public void close() throws IOException {
 			try {
 				if (cleanupMode == NEVER
-						|| (cleanupMode == ON_SUCCESS && executionContext.getExecutionException().isPresent())) {
+						|| (cleanupMode == ON_SUCCESS && extensionContext.getExecutionException().isPresent())) {
 					logger.info(() -> "Skipping cleanup of temp dir " + dir + " due to cleanup mode configuration.");
 					return;
 				}
 
-				FileOperations fileOperations = executionContext.getStore(NAMESPACE) //
+				FileOperations fileOperations = extensionContext.getStore(NAMESPACE) //
 						.getOrDefault(FILE_OPERATIONS_KEY, FileOperations.class, FileOperations.DEFAULT);
 
 				SortedMap<Path, IOException> failures = deleteAllFilesAndDirectories(fileOperations);
@@ -451,4 +453,28 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 
 	}
 
+	private static class FieldContext implements AnnotatedElementContext {
+
+		private final Field field;
+
+		private FieldContext(Field field) {
+			this.field = Preconditions.notNull(field, "field must not be null");
+		}
+
+		@Override
+		public AnnotatedElement getAnnotatedElement() {
+			return this.field;
+		}
+
+		@Override
+		public String toString() {
+			// @formatter:off
+			return new ToStringBuilder(this)
+					.append("field", this.field)
+					.toString();
+			// @formatter:on
+		}
+
+	}
+
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/config/DefaultJupiterConfigurationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/config/DefaultJupiterConfigurationTests.java
index d6cfc1d41..44d05998b 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/config/DefaultJupiterConfigurationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/config/DefaultJupiterConfigurationTests.java
@@ -28,6 +28,7 @@ import org.junit.jupiter.api.DisplayNameGenerator;
 import org.junit.jupiter.api.MethodOrderer;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.io.CleanupMode;
 import org.junit.jupiter.api.io.TempDirFactory;
@@ -127,7 +128,7 @@ class DefaultJupiterConfigurationTests {
 	private static class CustomFactory implements TempDirFactory {
 
 		@Override
-		public Path createTempDirectory(ExtensionContext context) {
+		public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext) {
 			throw new UnsupportedOperationException();
 		}
 	}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java
index 43c510504..85daa5077 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/CloseablePathCleanupTests.java
@@ -28,6 +28,7 @@ import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.io.CleanupMode;
@@ -48,6 +49,7 @@ import org.junit.platform.engine.support.store.NamespacedHierarchicalStore;
  */
 class CloseablePathCleanupTests extends AbstractJupiterTestEngineTests {
 
+	private final AnnotatedElementContext elementContext = mock();
 	private final ExtensionContext extensionContext = mock();
 	private final TempDirFactory factory = spy(TempDirFactory.Standard.INSTANCE);
 
@@ -67,7 +69,7 @@ class CloseablePathCleanupTests extends AbstractJupiterTestEngineTests {
 	@Test
 	@DisplayName("is cleaned up for a cleanup mode of ALWAYS")
 	void always() throws IOException {
-		closeablePath = TempDirectory.createTempDir(factory, ALWAYS, extensionContext);
+		closeablePath = TempDirectory.createTempDir(factory, ALWAYS, elementContext, extensionContext);
 		assertThat(closeablePath.get()).exists();
 
 		closeablePath.close();
@@ -78,7 +80,7 @@ class CloseablePathCleanupTests extends AbstractJupiterTestEngineTests {
 	@Test
 	@DisplayName("is not cleaned up for a cleanup mode of NEVER")
 	void never() throws IOException {
-		closeablePath = TempDirectory.createTempDir(factory, NEVER, extensionContext);
+		closeablePath = TempDirectory.createTempDir(factory, NEVER, elementContext, extensionContext);
 		assertThat(closeablePath.get()).exists();
 
 		closeablePath.close();
@@ -91,7 +93,7 @@ class CloseablePathCleanupTests extends AbstractJupiterTestEngineTests {
 	void onSuccessWithException() throws IOException {
 		when(extensionContext.getExecutionException()).thenReturn(Optional.of(new Exception()));
 
-		closeablePath = TempDirectory.createTempDir(factory, ON_SUCCESS, extensionContext);
+		closeablePath = TempDirectory.createTempDir(factory, ON_SUCCESS, elementContext, extensionContext);
 		assertThat(closeablePath.get()).exists();
 
 		closeablePath.close();
@@ -104,7 +106,7 @@ class CloseablePathCleanupTests extends AbstractJupiterTestEngineTests {
 	void onSuccessWithNoException() throws IOException {
 		when(extensionContext.getExecutionException()).thenReturn(Optional.empty());
 
-		closeablePath = TempDirectory.createTempDir(factory, ON_SUCCESS, extensionContext);
+		closeablePath = TempDirectory.createTempDir(factory, ON_SUCCESS, elementContext, extensionContext);
 		assertThat(closeablePath.get()).exists();
 
 		closeablePath.close();
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java
index 4515d33b2..ac6f15281 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java
@@ -48,6 +48,7 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
 import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.TestMethodOrder;
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
@@ -318,7 +319,8 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 		private static class Factory implements TempDirFactory {
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
 				return Files.createTempDirectory("junit");
 			}
 		}
@@ -693,7 +695,8 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 		private static class Factory implements TempDirFactory {
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
 				return Files.createTempDirectory("junit");
 			}
 		}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java
index 33a5297e2..f0575de59 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java
@@ -10,6 +10,10 @@
 
 package org.junit.jupiter.engine.extension;
 
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
@@ -30,6 +34,11 @@ import static org.junit.platform.testkit.engine.TestExecutionResultConditions.su
 
 import java.io.File;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Field;
+import java.lang.reflect.Parameter;
 import java.nio.file.DirectoryNotEmptyException;
 import java.nio.file.FileSystem;
 import java.nio.file.Files;
@@ -62,6 +71,7 @@ import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.TestReporter;
 import org.junit.jupiter.api.condition.DisabledOnOs;
 import org.junit.jupiter.api.condition.OS;
+import org.junit.jupiter.api.extension.AnnotatedElementContext;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
 import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -345,6 +355,20 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 					.assertStatistics(stats -> stats.started(1).succeeded(1));
 		}
 
+		@Test
+		@DisplayName("that uses annotated element name as temp dir name prefix")
+		void supportsFactoryWithAnnotatedElementNameAsPrefix() {
+			executeTestsForClass(FactoryWithAnnotatedElementNameAsPrefixTestCase.class).testEvents()//
+					.assertStatistics(stats -> stats.started(1).succeeded(1));
+		}
+
+		@Test
+		@DisplayName("that uses custom meta-annotation")
+		void supportsFactoryWithCustomMetaAnnotation() {
+			executeTestsForClass(FactoryWithCustomMetaAnnotationTestCase.class).testEvents()//
+					.assertStatistics(stats -> stats.started(1).succeeded(1));
+		}
+
 	}
 
 	@Nested
@@ -390,7 +414,8 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 			private boolean closed;
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
 				return Files.createTempDirectory("custom");
 			}
 
@@ -1178,8 +1203,9 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 		private static class Factory implements TempDirFactory {
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
-				return Files.createTempDirectory(context.getRequiredTestMethod().getName());
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
+				return Files.createTempDirectory(extensionContext.getRequiredTestMethod().getName());
 			}
 		}
 
@@ -1203,7 +1229,8 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 			}
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
 				return Files.createTempDirectory(parent, "prefix");
 			}
 		}
@@ -1223,7 +1250,8 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 			private static FileSystem fileSystem;
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
 				fileSystem = MemoryFileSystemBuilder.newEmpty().build();
 				return Files.createTempDirectory(fileSystem.getPath("/"), "prefix");
 			}
@@ -1250,7 +1278,8 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 			private static FileSystem fileSystem;
 
 			@Override
-			public Path createTempDirectory(ExtensionContext context) throws Exception {
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
 				fileSystem = Jimfs.newFileSystem(Configuration.unix());
 				return Files.createTempDirectory(fileSystem.getPath("/"), "prefix");
 			}
@@ -1264,6 +1293,79 @@ class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
 
 	}
 
+	static class FactoryWithAnnotatedElementNameAsPrefixTestCase {
+
+		@TempDir(factory = Factory.class)
+		private Path tempDir1;
+
+		@Test
+		void test(@TempDir(factory = Factory.class) Path tempDir2) {
+			assertThat(tempDir1.getFileName()).asString().startsWith("tempDir1");
+			assertThat(tempDir2.getFileName()).asString().startsWith("tempDir2");
+		}
+
+		private static class Factory implements TempDirFactory {
+
+			@Override
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
+				return Files.createTempDirectory(getName(elementContext.getAnnotatedElement()));
+			}
+
+			private static String getName(AnnotatedElement element) {
+				return element instanceof Field ? ((Field) element).getName() : ((Parameter) element).getName();
+			}
+
+		}
+
+	}
+
+	static class FactoryWithCustomMetaAnnotationTestCase {
+
+		@TempDirForField
+		private Path tempDir1;
+
+		@Test
+		void test(@TempDirForParameter Path tempDir2) {
+			assertThat(tempDir1.getFileName()).asString().startsWith("field");
+			assertThat(tempDir2.getFileName()).asString().startsWith("parameter");
+		}
+
+		@Target(ANNOTATION_TYPE)
+		@Retention(RUNTIME)
+		@TempDir(factory = FactoryWithCustomMetaAnnotationTestCase.Factory.class)
+		private @interface TempDirWithPrefix {
+
+			String value();
+
+		}
+
+		@Target(FIELD)
+		@Retention(RUNTIME)
+		@TempDirWithPrefix("field")
+		private @interface TempDirForField {
+		}
+
+		@Target(PARAMETER)
+		@Retention(RUNTIME)
+		@TempDirWithPrefix("parameter")
+		private @interface TempDirForParameter {
+		}
+
+		private static class Factory implements TempDirFactory {
+
+			@Override
+			public Path createTempDirectory(AnnotatedElementContext elementContext, ExtensionContext extensionContext)
+					throws Exception {
+				String prefix = elementContext.findAnnotation(TempDirWithPrefix.class) //
+						.map(TempDirWithPrefix::value).orElseThrow();
+				return Files.createTempDirectory(prefix);
+			}
+
+		}
+
+	}
+
 	static class StandardDefaultFactoryTestCase {
 
 		@Test
