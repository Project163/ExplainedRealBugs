diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.0-M3.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.0-M3.adoc
index 67ac74ee2..0f19a6985 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.0-M3.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.0-M3.adoc
@@ -47,7 +47,10 @@ repository on GitHub.
 [[release-notes-5.11.0-M3-junit-jupiter-new-features-and-improvements]]
 ==== New Features and Improvements
 
-* ❓
+* New `argumentSet()` factory method for providing a custom name for an entire set of
+  arguments for a `@ParameterizedTest`. See the
+  <<../user-guide/index.adoc#writing-tests-parameterized-tests-display-names, User Guide>>
+  for details.
 
 
 [[release-notes-5.11.0-M3-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 80681d705..50e63b154 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2244,13 +2244,15 @@ The following placeholders are supported within custom display names.
 
 [cols="20,80"]
 |===
-| Placeholder              | Description
-
-| `{displayName}`          | the display name of the method
-| `{index}`                | the current invocation index (1-based)
-| `{arguments}`            | the complete, comma-separated arguments list
-| `{argumentsWithNames}`   | the complete, comma-separated arguments list with parameter names
-| `{0}`, `{1}`, ...        | an individual argument
+| Placeholder                             | Description
+
+| `{displayName}`                         | the display name of the method
+| `{index}`                               | the current invocation index (1-based)
+| `{arguments}`                           | the complete, comma-separated arguments list
+| `{argumentsWithNames}`                  | the complete, comma-separated arguments list with parameter names
+| `{argumentSetName}`                     | the name of the argument set
+| `{argumentSetNameOrArgumentsWithNames}` | `{argumentSetName}` or `{argumentsWithNames}`, depending on how the arguments are supplied
+| `{0}`, `{1}`, ...                       | an individual argument
 |===
 
 NOTE: When including arguments in display names, their string representations are truncated
@@ -2259,8 +2261,11 @@ if they exceed the configured maximum length. The limit is configurable via the
 to 512 characters.
 
 When using `@MethodSource`, `@FieldSource`, or `@ArgumentsSource`, you can provide custom
-names for arguments using the `{Named}` API. A custom name will be used if the argument is
-included in the invocation display name, like in the example below.
+names for individual arguments or custom names for entire sets of arguments.
+
+Use the `{Named}` API to provide a custom name for an individual argument, and the custom
+name will be used if the argument is included in the invocation display name, like in the
+example below.
 
 ======
 [source,java,indent=0]
@@ -2287,6 +2292,31 @@ Similarly, `named(String, Object)` is a static factory method defined in the
 `org.junit.jupiter.api.Named` interface.
 ====
 
+Use the `ArgumentSet` API to provide a custom name for the entire set of arguments, and
+the custom name will be used as the display name, like in the example below.
+
+======
+[source,java,indent=0]
+----
+include::{testDir}/example/ParameterizedTestDemo.java[tags=named_argument_set]
+----
+
+When executing the above method using the `ConsoleLauncher` you will see output similar to
+the following.
+
+....
+A parameterized test with named argument sets ✔
+├─ [1] Important files ✔
+└─ [2] Other files ✔
+....
+======
+
+[NOTE]
+====
+Note that `argumentSet(String, Object...)` is a static factory method defined in the
+`org.junit.jupiter.params.provider.Arguments` interface.
+====
+
 If you'd like to set a default name pattern for all parameterized tests in your project,
 you can declare the `junit.jupiter.params.displayname.default` configuration parameter in
 the `junit-platform.properties` file as demonstrated in the following example (see
diff --git a/documentation/src/test/java/example/ParameterizedTestDemo.java b/documentation/src/test/java/example/ParameterizedTestDemo.java
index e4cac2000..4d99f22c9 100644
--- a/documentation/src/test/java/example/ParameterizedTestDemo.java
+++ b/documentation/src/test/java/example/ParameterizedTestDemo.java
@@ -17,6 +17,7 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Named.named;
 import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;
+import static org.junit.jupiter.params.provider.Arguments.argumentSet;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 import static org.junit.jupiter.params.provider.EnumSource.Mode.EXCLUDE;
 import static org.junit.jupiter.params.provider.EnumSource.Mode.MATCH_ALL;
@@ -551,6 +552,21 @@ class ParameterizedTestDemo {
 	// end::named_arguments[]
 	// @formatter:on
 
+	// @formatter:off
+	// tag::named_argument_set[]
+	@DisplayName("A parameterized test with named argument sets")
+	@ParameterizedTest
+	@FieldSource("argumentSets")
+	void testWithArgumentSets(File file1, File file2) {
+	}
+
+	static List<Arguments> argumentSets = Arrays.asList(
+		argumentSet("Important files", new File("path1"), new File("path2")),
+		argumentSet("Other files", new File("path3"), new File("path4"))
+	);
+	// end::named_argument_set[]
+	// @formatter:on
+
 	// tag::repeatable_annotations[]
 	@DisplayName("A parameterized test that makes use of repeatable annotations")
 	@ParameterizedTest
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
index 3b1d26564..bf45c87fd 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.params;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.lang.annotation.Documented;
@@ -148,6 +149,7 @@ public @interface ParameterizedTest {
 	 *
 	 * @since 5.3
 	 * @see #name
+	 * @see #DEFAULT_DISPLAY_NAME
 	 */
 	String INDEX_PLACEHOLDER = "{index}";
 
@@ -173,9 +175,43 @@ public @interface ParameterizedTest {
 	 *
 	 * @since 5.6
 	 * @see #name
+	 * @see #ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER
 	 */
 	String ARGUMENTS_WITH_NAMES_PLACEHOLDER = "{argumentsWithNames}";
 
+	/**
+	 * Placeholder for the name of the argument set for the current invocation
+	 * of a {@code @ParameterizedTest} method: <code>{argumentSetName}</code>.
+	 *
+	 * <p>This placeholder can be used when the current set of arguments was created via
+	 * {@link org.junit.jupiter.params.provider.Arguments#argumentSet(String, Object...)
+	 * argumentSet()}.
+	 *
+	 * @since 5.11
+	 * @see #name
+	 * @see #ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER
+	 * @see org.junit.jupiter.params.provider.Arguments#argumentSet(String, Object...)
+	 */
+	@API(status = EXPERIMENTAL, since = "5.11")
+	String ARGUMENT_SET_NAME_PLACEHOLDER = "{argumentSetName}";
+
+	/**
+	 * Placeholder for either {@link #ARGUMENT_SET_NAME_PLACEHOLDER} or
+	 * {@link #ARGUMENTS_WITH_NAMES_PLACEHOLDER}, depending on whether the
+	 * current set of arguments was created via
+	 * {@link org.junit.jupiter.params.provider.Arguments#argumentSet(String, Object...)
+	 * argumentSet()}: <code>{argumentSetNameOrArgumentsWithNames}</code>.
+	 *
+	 * @since 5.11
+	 * @see #name
+	 * @see #ARGUMENT_SET_NAME_PLACEHOLDER
+	 * @see #ARGUMENTS_WITH_NAMES_PLACEHOLDER
+	 * @see #DEFAULT_DISPLAY_NAME
+	 * @see org.junit.jupiter.params.provider.Arguments#argumentSet(String, Object...)
+	 */
+	@API(status = EXPERIMENTAL, since = "5.11")
+	String ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER = "{argumentSetNameOrArgumentsWithNames}";
+
 	/**
 	 * Default display name pattern for the current invocation of a
 	 * {@code @ParameterizedTest} method: {@value}
@@ -188,9 +224,10 @@ public @interface ParameterizedTest {
 	 * @see #name
 	 * @see #DISPLAY_NAME_PLACEHOLDER
 	 * @see #INDEX_PLACEHOLDER
-	 * @see #ARGUMENTS_WITH_NAMES_PLACEHOLDER
+	 * @see #ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER
 	 */
-	String DEFAULT_DISPLAY_NAME = "[" + INDEX_PLACEHOLDER + "] " + ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+	String DEFAULT_DISPLAY_NAME = "[" + INDEX_PLACEHOLDER + "] "
+			+ ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER;
 
 	/**
 	 * The display name to be used for individual invocations of the
@@ -215,8 +252,10 @@ public @interface ParameterizedTest {
 	 * <ul>
 	 * <li><code>{@value #DISPLAY_NAME_PLACEHOLDER}</code></li>
 	 * <li><code>{@value #INDEX_PLACEHOLDER}</code></li>
+	 * <li><code>{@value #ARGUMENT_SET_NAME_PLACEHOLDER}</code></li>
 	 * <li><code>{@value #ARGUMENTS_PLACEHOLDER}</code></li>
 	 * <li><code>{@value #ARGUMENTS_WITH_NAMES_PLACEHOLDER}</code></li>
+	 * <li><code>{@value #ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER}</code></li>
 	 * <li><code>"{0}"</code>, <code>"{1}"</code>, etc.: an individual argument (0-based)</li>
 	 * </ul>
 	 *
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
index c72689094..aa7cd4251 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
@@ -15,7 +15,6 @@ import static org.junit.platform.commons.util.AnnotationUtils.findRepeatableAnno
 import static org.junit.platform.commons.util.AnnotationUtils.isAnnotated;
 
 import java.lang.reflect.Method;
-import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
 
@@ -88,8 +87,6 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 				.map(this::instantiateArgumentsProvider)
 				.map(provider -> AnnotationConsumerInitializer.initialize(templateMethod, provider))
 				.flatMap(provider -> arguments(provider, extensionContext))
-				.map(Arguments::get)
-				.map(arguments -> consumedArguments(arguments, methodContext))
 				.map(arguments -> {
 					invocationCount.incrementAndGet();
 					return createInvocationContext(formatter, methodContext, arguments, invocationCount.intValue());
@@ -122,7 +119,7 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 	}
 
 	private TestTemplateInvocationContext createInvocationContext(ParameterizedTestNameFormatter formatter,
-			ParameterizedTestMethodContext methodContext, Object[] arguments, int invocationIndex) {
+			ParameterizedTestMethodContext methodContext, Arguments arguments, int invocationIndex) {
 
 		return new ParameterizedTestInvocationContext(formatter, methodContext, arguments, invocationIndex);
 	}
@@ -151,12 +148,4 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		}
 	}
 
-	private Object[] consumedArguments(Object[] arguments, ParameterizedTestMethodContext methodContext) {
-		if (methodContext.hasAggregator()) {
-			return arguments;
-		}
-		int parameterCount = methodContext.getParameterCount();
-		return arguments.length > parameterCount ? Arrays.copyOf(arguments, parameterCount) : arguments;
-	}
-
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java
index dbfe0792a..c0ac83e78 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestInvocationContext.java
@@ -12,10 +12,12 @@ package org.junit.jupiter.params;
 
 import static java.util.Collections.singletonList;
 
+import java.util.Arrays;
 import java.util.List;
 
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
+import org.junit.jupiter.params.provider.Arguments;
 
 /**
  * @since 5.0
@@ -24,27 +26,37 @@ class ParameterizedTestInvocationContext implements TestTemplateInvocationContex
 
 	private final ParameterizedTestNameFormatter formatter;
 	private final ParameterizedTestMethodContext methodContext;
-	private final Object[] arguments;
+	private final Arguments arguments;
+	private final Object[] consumedArguments;
 	private final int invocationIndex;
 
 	ParameterizedTestInvocationContext(ParameterizedTestNameFormatter formatter,
-			ParameterizedTestMethodContext methodContext, Object[] arguments, int invocationIndex) {
+			ParameterizedTestMethodContext methodContext, Arguments arguments, int invocationIndex) {
 
 		this.formatter = formatter;
 		this.methodContext = methodContext;
 		this.arguments = arguments;
+		this.consumedArguments = consumedArguments(methodContext, arguments.get());
 		this.invocationIndex = invocationIndex;
 	}
 
 	@Override
 	public String getDisplayName(int invocationIndex) {
-		return this.formatter.format(invocationIndex, this.arguments);
+		return this.formatter.format(invocationIndex, this.arguments, this.consumedArguments);
 	}
 
 	@Override
 	public List<Extension> getAdditionalExtensions() {
 		return singletonList(
-			new ParameterizedTestParameterResolver(this.methodContext, this.arguments, this.invocationIndex));
+			new ParameterizedTestParameterResolver(this.methodContext, this.consumedArguments, this.invocationIndex));
+	}
+
+	private static Object[] consumedArguments(ParameterizedTestMethodContext methodContext, Object[] arguments) {
+		if (methodContext.hasAggregator()) {
+			return arguments;
+		}
+		int parameterCount = methodContext.getParameterCount();
+		return arguments.length > parameterCount ? Arrays.copyOf(arguments, parameterCount) : arguments;
 	}
 
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
index 610251a08..9d730a3fa 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
@@ -13,6 +13,8 @@ package org.junit.jupiter.params;
 import static java.util.stream.Collectors.joining;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENT_SET_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
 
@@ -22,6 +24,9 @@ import java.util.Arrays;
 import java.util.stream.IntStream;
 
 import org.junit.jupiter.api.Named;
+import org.junit.jupiter.api.extension.ExtensionConfigurationException;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.Arguments.ArgumentSet;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.StringUtils;
 
@@ -47,9 +52,9 @@ class ParameterizedTestNameFormatter {
 		this.argumentMaxLength = argumentMaxLength;
 	}
 
-	String format(int invocationIndex, Object... arguments) {
+	String format(int invocationIndex, Arguments arguments, Object[] consumedArguments) {
 		try {
-			return formatSafely(invocationIndex, arguments);
+			return formatSafely(invocationIndex, arguments, consumedArguments);
 		}
 		catch (Exception ex) {
 			String message = "The display name pattern defined for the parameterized test is invalid. "
@@ -58,9 +63,9 @@ class ParameterizedTestNameFormatter {
 		}
 	}
 
-	private String formatSafely(int invocationIndex, Object[] arguments) {
-		Object[] namedArguments = extractNamedArguments(arguments);
-		String pattern = prepareMessageFormatPattern(invocationIndex, namedArguments);
+	private String formatSafely(int invocationIndex, Arguments arguments, Object[] consumedArguments) {
+		Object[] namedArguments = extractNamedArguments(consumedArguments);
+		String pattern = prepareMessageFormatPattern(invocationIndex, arguments, namedArguments);
 		MessageFormat format = new MessageFormat(pattern);
 		Object[] humanReadableArguments = makeReadable(format, namedArguments);
 		String formatted = format.format(humanReadableArguments);
@@ -73,17 +78,34 @@ class ParameterizedTestNameFormatter {
 				.toArray();
 	}
 
-	private String prepareMessageFormatPattern(int invocationIndex, Object[] arguments) {
+	private String prepareMessageFormatPattern(int invocationIndex, Arguments arguments, Object[] consumedArguments) {
 		String result = this.pattern//
 				.replace(DISPLAY_NAME_PLACEHOLDER, TEMPORARY_DISPLAY_NAME_PLACEHOLDER)//
 				.replace(INDEX_PLACEHOLDER, String.valueOf(invocationIndex));
 
+		if (result.contains(ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER)) {
+			String placeholderToUse = (arguments instanceof ArgumentSet //
+					? ARGUMENT_SET_NAME_PLACEHOLDER
+					: ARGUMENTS_WITH_NAMES_PLACEHOLDER);
+			result = result.replace(ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER, placeholderToUse);
+		}
+
+		if (result.contains(ARGUMENT_SET_NAME_PLACEHOLDER)) {
+			if (!(arguments instanceof ArgumentSet)) {
+				throw new ExtensionConfigurationException(
+					String.format("When the display name pattern for a @ParameterizedTest contains %s, "
+							+ "the arguments must be supplied as an ArgumentSet.",
+						ARGUMENT_SET_NAME_PLACEHOLDER));
+			}
+			result = result.replace(ARGUMENT_SET_NAME_PLACEHOLDER, ((ArgumentSet) arguments).getName());
+		}
+
 		if (result.contains(ARGUMENTS_WITH_NAMES_PLACEHOLDER)) {
-			result = result.replace(ARGUMENTS_WITH_NAMES_PLACEHOLDER, argumentsWithNamesPattern(arguments));
+			result = result.replace(ARGUMENTS_WITH_NAMES_PLACEHOLDER, argumentsWithNamesPattern(consumedArguments));
 		}
 
 		if (result.contains(ARGUMENTS_PLACEHOLDER)) {
-			result = result.replace(ARGUMENTS_PLACEHOLDER, argumentsPattern(arguments));
+			result = result.replace(ARGUMENTS_PLACEHOLDER, argumentsPattern(consumedArguments));
 		}
 
 		return result;
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java
index 4cd60005e..94b82972d 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/Arguments.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.params.provider;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import org.apiguardian.api.API;
@@ -43,6 +44,7 @@ import org.junit.platform.commons.util.Preconditions;
  * to convert some of the arguments from one type to another.
  *
  * @since 5.0
+ * @see ArgumentSet
  * @see org.junit.jupiter.params.ParameterizedTest
  * @see org.junit.jupiter.params.provider.ArgumentsSource
  * @see org.junit.jupiter.params.provider.ArgumentsProvider
@@ -58,7 +60,7 @@ public interface Arguments {
 	 * @apiNote If you need a type-safe way to access some or all of the arguments,
 	 * please read the {@linkplain Arguments class-level API note}.
 	 *
-	 * @return the arguments; must not be {@code null}
+	 * @return the arguments; never {@code null}
 	 */
 	Object[] get();
 
@@ -70,9 +72,10 @@ public interface Arguments {
 	 * method; must not be {@code null}
 	 * @return an instance of {@code Arguments}; never {@code null}
 	 * @see #arguments(Object...)
+	 * @see #argumentSet(String, Object...)
 	 */
 	static Arguments of(Object... arguments) {
-		Preconditions.notNull(arguments, "argument array must not be null");
+		Preconditions.notNull(arguments, "arguments array must not be null");
 		return () -> arguments;
 	}
 
@@ -88,9 +91,83 @@ public interface Arguments {
 	 * method; must not be {@code null}
 	 * @return an instance of {@code Arguments}; never {@code null}
 	 * @since 5.3
+	 * @see #argumentSet(String, Object...)
 	 */
 	static Arguments arguments(Object... arguments) {
 		return of(arguments);
 	}
 
+	/**
+	 * Factory method for creating an {@link ArgumentSet} based on the supplied
+	 * {@code name} and {@code arguments}.
+	 *
+	 * <p>Favor this method over {@link Arguments#of Arguments.of(...)} and
+	 * {@link Arguments#arguments arguments(...)} when you wish to assign a name
+	 * to the entire set of arguments.
+	 *
+	 * <p>This method is well suited to be used as a static import &mdash; for
+	 * example, via:
+	 * {@code import static org.junit.jupiter.params.provider.Arguments.argumentSet;}.
+	 *
+	 * @param name the name of the argument set; must not be {@code null} or blank
+	 * @param arguments the arguments to be used for an invocation of the test
+	 * method; must not be {@code null}
+	 * @return an {@code ArgumentSet}; never {@code null}
+	 * @since 5.11
+	 * @see ArgumentSet
+	 * @see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_PLACEHOLDER
+	 * @see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER
+	 */
+	@API(status = EXPERIMENTAL, since = "5.11")
+	static ArgumentSet argumentSet(String name, Object... arguments) {
+		return new ArgumentSet(name, arguments);
+	}
+
+	/**
+	 * Specialization of {@link Arguments} that associates a {@link #getName() name}
+	 * with a set of {@link #get() arguments}.
+	 *
+	 * @since 5.11
+	 * @see Arguments#argumentSet(String, Object...)
+	 * @see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_PLACEHOLDER
+	 * @see org.junit.jupiter.params.ParameterizedTest#ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER
+	 */
+	@API(status = EXPERIMENTAL, since = "5.11")
+	final class ArgumentSet implements Arguments {
+
+		private final String name;
+
+		private final Object[] arguments;
+
+		private ArgumentSet(String name, Object[] arguments) {
+			Preconditions.notBlank(name, "name must not be null or blank");
+			Preconditions.notNull(arguments, "arguments array must not be null");
+			this.name = name;
+			this.arguments = arguments;
+		}
+
+		/**
+		 * Get the name of this {@code ArgumentSet}.
+		 * @return the name of this {@code ArgumentSet}; never {@code null} or blank
+		 */
+		public String getName() {
+			return this.name;
+		}
+
+		@Override
+		public Object[] get() {
+			return this.arguments;
+		}
+
+		/**
+		 * Return the {@link #getName() name} of this {@code ArgumentSet}.
+		 * @return the name of this {@code ArgumentSet}
+		 */
+		@Override
+		public String toString() {
+			return getName();
+		}
+
+	}
+
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
index 2bc7c7937..663dd4ae3 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
@@ -11,14 +11,20 @@
 package org.junit.jupiter.params;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENT_SET_NAME_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.DEFAULT_DISPLAY_NAME;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
+import static org.junit.jupiter.params.provider.Arguments.argumentSet;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 import static org.mockito.Mockito.mock;
 
 import java.lang.reflect.Method;
@@ -31,11 +37,14 @@ import java.util.Arrays;
 import java.util.Locale;
 
 import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.params.aggregator.AggregateWith;
 import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
+import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.CsvSource;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -56,8 +65,8 @@ class ParameterizedTestNameFormatterTests {
 	void formatsDisplayName() {
 		var formatter = formatter(DISPLAY_NAME_PLACEHOLDER, "enigma");
 
-		assertEquals("enigma", formatter.format(1));
-		assertEquals("enigma", formatter.format(2));
+		assertEquals("enigma", format(formatter, 1, arguments()));
+		assertEquals("enigma", format(formatter, 2, arguments()));
 	}
 
 	@Test
@@ -65,8 +74,8 @@ class ParameterizedTestNameFormatterTests {
 		String displayName = "display'Zero";
 		var formatter = formatter(DISPLAY_NAME_PLACEHOLDER, "display'Zero");
 
-		assertEquals(displayName, formatter.format(1));
-		assertEquals(displayName, formatter.format(2));
+		assertEquals(displayName, format(formatter, 1, arguments()));
+		assertEquals(displayName, format(formatter, 2, arguments()));
 	}
 
 	@Test
@@ -74,23 +83,32 @@ class ParameterizedTestNameFormatterTests {
 		String displayName = "{enigma} {0} '{1}'";
 		var formatter = formatter(DISPLAY_NAME_PLACEHOLDER, displayName);
 
-		assertEquals(displayName, formatter.format(1));
-		assertEquals(displayName, formatter.format(2));
+		assertEquals(displayName, format(formatter, 1, arguments()));
+		assertEquals(displayName, format(formatter, 2, arguments()));
 	}
 
 	@Test
 	void formatsInvocationIndex() {
 		var formatter = formatter(INDEX_PLACEHOLDER, "enigma");
 
-		assertEquals("1", formatter.format(1));
-		assertEquals("2", formatter.format(2));
+		assertEquals("1", format(formatter, 1, arguments()));
+		assertEquals("2", format(formatter, 2, arguments()));
+	}
+
+	@Test
+	void defaultDisplayName() {
+		var formatter = formatter(DEFAULT_DISPLAY_NAME, "IGNORED");
+
+		var formattedName = format(formatter, 1, arguments("apple", "banana"));
+
+		assertThat(formattedName).isEqualTo("[1] apple, banana");
 	}
 
 	@Test
 	void formatsIndividualArguments() {
 		var formatter = formatter("{0} -> {1}", "enigma");
 
-		assertEquals("foo -> 42", formatter.format(1, "foo", 42));
+		assertEquals("foo -> 42", format(formatter, 1, arguments("foo", 42)));
 	}
 
 	@Test
@@ -98,17 +116,18 @@ class ParameterizedTestNameFormatterTests {
 		var formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
 		// @formatter:off
-		assertEquals("42, 99, enigma, null, [1, 2, 3], [foo, bar], [[2, 4], [3, 9]]",
-			formatter.format(1,
-				42,
-				99,
-				"enigma",
-				null,
-				new int[] { 1, 2, 3 },
-				new String[] { "foo", "bar" },
-				new Integer[][] { { 2, 4 }, { 3, 9 } }
-			));
+		Arguments args = arguments(
+			42,
+			99,
+			"enigma",
+			null,
+			new int[] { 1, 2, 3 },
+			new String[] { "foo", "bar" },
+			new Integer[][] { { 2, 4 }, { 3, 9 } }
+		);
 		// @formatter:on
+
+		assertEquals("42, 99, enigma, null, [1, 2, 3], [foo, bar], [[2, 4], [3, 9]]", format(formatter, 1, args));
 	}
 
 	@Test
@@ -116,7 +135,7 @@ class ParameterizedTestNameFormatterTests {
 		var testMethod = ParameterizedTestCases.getMethod("parameterizedTest", int.class, String.class, Object[].class);
 		var formatter = formatter(ARGUMENTS_WITH_NAMES_PLACEHOLDER, "enigma", testMethod);
 
-		var formattedName = formatter.format(1, 42, "enigma", new Object[] { "foo", 1 });
+		var formattedName = format(formatter, 1, arguments(42, "enigma", new Object[] { "foo", 1 }));
 		assertEquals("someNumber=42, someString=enigma, someArray=[foo, 1]", formattedName);
 	}
 
@@ -125,7 +144,7 @@ class ParameterizedTestNameFormatterTests {
 		var testMethod = ParameterizedTestCases.getMethod("parameterizedTestWithAggregator", int.class, String.class);
 		var formatter = formatter(ARGUMENTS_WITH_NAMES_PLACEHOLDER, "enigma", testMethod);
 
-		var formattedName = formatter.format(1, 42, "foo", "bar");
+		var formattedName = format(formatter, 1, arguments(42, "foo", "bar"));
 		assertEquals("someNumber=42, foo, bar", formattedName);
 	}
 
@@ -134,9 +153,9 @@ class ParameterizedTestNameFormatterTests {
 		var formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
 		// Explicit test for https://github.com/junit-team/junit5/issues/814
-		assertEquals("[foo, bar]", formatter.format(1, (Object) new String[] { "foo", "bar" }));
+		assertEquals("[foo, bar]", format(formatter, 1, arguments((Object) new String[] { "foo", "bar" })));
 
-		assertEquals("[foo, bar], 42, true", formatter.format(1, new String[] { "foo", "bar" }, 42, true));
+		assertEquals("[foo, bar], 42, true", format(formatter, 1, arguments(new String[] { "foo", "bar" }, 42, true)));
 	}
 
 	@Test
@@ -144,16 +163,16 @@ class ParameterizedTestNameFormatterTests {
 		var pattern = DISPLAY_NAME_PLACEHOLDER + " " + INDEX_PLACEHOLDER + " :: " + ARGUMENTS_PLACEHOLDER + " :: {1}";
 		var formatter = formatter(pattern, "enigma");
 
-		assertEquals("enigma 1 :: foo, bar :: bar", formatter.format(1, "foo", "bar"));
-		assertEquals("enigma 2 :: foo, 42 :: 42", formatter.format(2, "foo", 42));
+		assertEquals("enigma 1 :: foo, bar :: bar", format(formatter, 1, arguments("foo", "bar")));
+		assertEquals("enigma 2 :: foo, 42 :: 42", format(formatter, 2, arguments("foo", 42)));
 	}
 
 	@Test
 	void formatDoesNotAlterArgumentsArray() {
-		var formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 		Object[] actual = { 1, "two", Byte.valueOf("-128"), new Integer[][] { { 2, 4 }, { 3, 9 } } };
+		var formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 		var expected = Arrays.copyOf(actual, actual.length);
-		assertEquals("1, two, -128, [[2, 4], [3, 9]]", formatter.format(1, actual));
+		assertEquals("1, two, -128, [[2, 4], [3, 9]]", format(formatter, 1, arguments(actual)));
 		assertArrayEquals(expected, actual);
 	}
 
@@ -162,14 +181,14 @@ class ParameterizedTestNameFormatterTests {
 		var formatter = formatter("{0} -> {1}", "enigma");
 
 		Object[] arguments = new Number[] { 1, 2 };
-		assertEquals("1 -> 2", formatter.format(1, arguments));
+		assertEquals("1 -> 2", format(formatter, 1, arguments(arguments)));
 	}
 
 	@Test
 	void throwsReadableExceptionForInvalidPattern() {
 		var formatter = formatter("{index", "enigma");
 
-		var exception = assertThrows(JUnitException.class, () -> formatter.format(1));
+		var exception = assertThrows(JUnitException.class, () -> format(formatter, 1, arguments()));
 		assertNotNull(exception.getCause());
 		assertEquals(IllegalArgumentException.class, exception.getCause().getClass());
 	}
@@ -178,7 +197,7 @@ class ParameterizedTestNameFormatterTests {
 	void formattingDoesNotFailIfArgumentToStringImplementationReturnsNull() {
 		var formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
-		var formattedName = formatter.format(1, new ToStringReturnsNull(), "foo");
+		var formattedName = format(formatter, 1, arguments(new ToStringReturnsNull(), "foo"));
 
 		assertThat(formattedName).isEqualTo("null, foo");
 	}
@@ -187,15 +206,17 @@ class ParameterizedTestNameFormatterTests {
 	void formattingDoesNotFailIfArgumentToStringImplementationThrowsAnException() {
 		var formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
-		var formattedName = formatter.format(1, new ToStringThrowsException(), "foo");
+		var formattedName = format(formatter, 1, arguments(new ToStringThrowsException(), "foo"));
 
 		assertThat(formattedName).startsWith(ToStringThrowsException.class.getName() + "@");
 		assertThat(formattedName).endsWith("foo");
 	}
 
 	@ParameterizedTest(name = "{0}")
-	@CsvSource(delimiter = '|', value = { "US | 42.23 is positive on 2019 Jan 13 at 12:34:56",
-			"DE | 42,23 is positive on 13.01.2019 at 12:34:56" })
+	@CsvSource(delimiter = '|', textBlock = """
+			US | 42.23 is positive on 2019 Jan 13 at 12:34:56
+			DE | 42,23 is positive on 13.01.2019 at 12:34:56
+			""")
 	void customFormattingExpressionsAreSupported(Locale locale, String expectedValue) {
 		var pattern = "[{index}] {1,number,#.##} is {1,choice,0<positive} on {0,date} at {0,time} even though {2}";
 		var formatter = formatter(pattern, "enigma");
@@ -204,7 +225,9 @@ class ParameterizedTestNameFormatterTests {
 		var date = Date.from(
 			LocalDate.of(2019, 1, 13).atTime(LocalTime.of(12, 34, 56)).atZone(ZoneId.systemDefault()).toInstant());
 		Locale.setDefault(locale);
-		var formattedName = formatter.format(1, date, new BigDecimal("42.23"), new ToStringThrowsException());
+
+		var formattedName = format(formatter, 1,
+			arguments(date, new BigDecimal("42.23"), new ToStringThrowsException()));
 
 		assertThat(formattedName).startsWith(
 			"[1] " + expectedValue + " even though " + ToStringThrowsException.class.getName() + "@");
@@ -214,7 +237,7 @@ class ParameterizedTestNameFormatterTests {
 	void ignoresExcessPlaceholders() {
 		var formatter = formatter("{0}, {1}", "enigma");
 
-		var formattedName = formatter.format(1, "foo");
+		var formattedName = format(formatter, 1, arguments("foo"));
 
 		assertThat(formattedName).isEqualTo("foo, {1}");
 	}
@@ -223,7 +246,7 @@ class ParameterizedTestNameFormatterTests {
 	void placeholdersCanBeOmitted() {
 		var formatter = formatter("{0}", "enigma");
 
-		var formattedName = formatter.format(1, "foo", "bar");
+		var formattedName = format(formatter, 1, arguments("foo", "bar"));
 
 		assertThat(formattedName).isEqualTo("foo");
 	}
@@ -232,26 +255,80 @@ class ParameterizedTestNameFormatterTests {
 	void placeholdersCanBeSkipped() {
 		var formatter = formatter("{0}, {2}", "enigma");
 
-		var formattedName = formatter.format(1, "foo", "bar", "baz");
+		var formattedName = format(formatter, 1, arguments("foo", "bar", "baz"));
 
 		assertThat(formattedName).isEqualTo("foo, baz");
 	}
 
 	@Test
 	void truncatesArgumentsThatExceedMaxLength() {
-		var formatter = formatter("{arguments}", 3);
+		var formatter = formatter("{arguments}", "display name", 3);
 
-		var formattedName = formatter.format(1, "fo", "foo", "fooo");
+		var formattedName = format(formatter, 1, arguments("fo", "foo", "fooo"));
 
 		assertThat(formattedName).isEqualTo("fo, foo, fo…");
 	}
 
+	@Nested
+	class ArgumentSetTests {
+
+		@Test
+		void throwsExceptionForArgumentSetNamePlaceholderWithoutArgumentSet() {
+			var formatter = formatter(ARGUMENT_SET_NAME_PLACEHOLDER, "IGNORED");
+
+			// @formatter:off
+			assertThatExceptionOfType(JUnitException.class)
+				.isThrownBy(() -> format(formatter, 1, arguments()))
+				.havingCause()
+					.isExactlyInstanceOf(ExtensionConfigurationException.class)
+					.withMessage("When the display name pattern for a @ParameterizedTest contains %s, "
+						+ "the arguments must be supplied as an ArgumentSet.", ARGUMENT_SET_NAME_PLACEHOLDER);
+			// @formatter:on
+		}
+
+		@Test
+		void defaultDisplayName() {
+			var formatter = formatter(DEFAULT_DISPLAY_NAME, "IGNORED");
+
+			var formattedName = format(formatter, 42, argumentSet("Fruits", "apple", "banana"));
+
+			assertThat(formattedName).isEqualTo("[42] Fruits");
+		}
+
+		@Test
+		void argumentSetNameAndArgumentsPlaceholders() {
+			var pattern = ARGUMENT_SET_NAME_PLACEHOLDER + " :: " + ARGUMENTS_PLACEHOLDER;
+			var formatter = formatter(pattern, "IGNORED");
+
+			var formattedName = format(formatter, -1, argumentSet("Fruits", "apple", "banana"));
+
+			assertThat(formattedName).isEqualTo("Fruits :: apple, banana");
+		}
+
+		@Test
+		void mixedTypesOfArgumentsImplementationsAndCustomDisplayNamePattern() {
+			var pattern = "[%s] %s :: %s".formatted(INDEX_PLACEHOLDER, DISPLAY_NAME_PLACEHOLDER,
+				ARGUMENT_SET_NAME_OR_ARGUMENTS_WITH_NAMES_PLACEHOLDER);
+			var testMethod = ParameterizedTestCases.getMethod("processFruits", String.class, String.class);
+			var formatter = formatter(pattern, "Mixed Arguments Types", testMethod);
+
+			var name1 = format(formatter, 1, argumentSet("Fruits", "apple", "banana"));
+			var name2 = format(formatter, 2, arguments("apple", "banana"));
+
+			assertThat(name1).isEqualTo("[1] Mixed Arguments Types :: Fruits");
+			assertThat(name2).isEqualTo("[2] Mixed Arguments Types :: fruit1=apple, fruit2=banana");
+		}
+
+	}
+
+	// -------------------------------------------------------------------------
+
 	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName) {
-		return new ParameterizedTestNameFormatter(pattern, displayName, mock(), 512);
+		return formatter(pattern, displayName, 512);
 	}
 
-	private static ParameterizedTestNameFormatter formatter(String pattern, int argumentMaxLength) {
-		return new ParameterizedTestNameFormatter(pattern, "display name", mock(), argumentMaxLength);
+	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName, int argumentMaxLength) {
+		return new ParameterizedTestNameFormatter(pattern, displayName, mock(), argumentMaxLength);
 	}
 
 	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName, Method method) {
@@ -259,7 +336,9 @@ class ParameterizedTestNameFormatterTests {
 			512);
 	}
 
-	// -------------------------------------------------------------------
+	private static String format(ParameterizedTestNameFormatter formatter, int invocationIndex, Arguments arguments) {
+		return formatter.format(invocationIndex, arguments, arguments.get());
+	}
 
 	private static class ToStringReturnsNull {
 
@@ -292,6 +371,10 @@ class ParameterizedTestNameFormatterTests {
 				@AggregateWith(CustomAggregator.class) String someAggregatedString) {
 		}
 
+		@SuppressWarnings("unused")
+		void processFruits(String fruit1, String fruit2) {
+		}
+
 		private static class CustomAggregator implements ArgumentsAggregator {
 			@Override
 			public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context) {
