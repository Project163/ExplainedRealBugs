diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClasspathScanner.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClasspathScanner.java
index 398332d7d..c1cc51fab 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClasspathScanner.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ClasspathScanner.java
@@ -15,6 +15,7 @@ import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 import static org.junit.platform.commons.util.ClassFileVisitor.CLASS_FILE_SUFFIX;
+import static org.junit.platform.commons.util.StringUtils.isNotBlank;
 
 import java.io.IOException;
 import java.net.URI;
@@ -69,8 +70,9 @@ class ClasspathScanner {
 	}
 
 	List<Class<?>> scanForClassesInPackage(String basePackageName, ClassFilter classFilter) {
-
-		PackageUtils.assertPackageNameIsValid(basePackageName);
+		Preconditions.condition(
+			PackageUtils.DEFAULT_PACKAGE_NAME.equals(basePackageName) || isNotBlank(basePackageName),
+			"basePackageName must not be null or blank");
 		Preconditions.notNull(classFilter, "classFilter must not be null");
 		basePackageName = basePackageName.trim();
 
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageUtils.java
index 0e220bde4..12978601f 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/PackageUtils.java
@@ -14,17 +14,11 @@ import static org.apiguardian.api.API.Status.INTERNAL;
 
 import java.io.File;
 import java.net.URL;
-import java.security.CodeSource;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
 import java.util.Optional;
-import java.util.Set;
 import java.util.function.Function;
 import java.util.jar.Attributes;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
-import java.util.regex.Pattern;
 
 import org.apiguardian.api.API;
 
@@ -48,36 +42,6 @@ public final class PackageUtils {
 
 	static final String DEFAULT_PACKAGE_NAME = "";
 
-	/**
-	 * Compiled {@code "\."} pattern used to split canonical package (and type) names.
-	 */
-	private static final Pattern DOT_PATTERN = Pattern.compile("\\.");
-
-	/**
-	 * Assert that the supplied package name is valid in terms of Java syntax.
-	 *
-	 * <p>Note: this method does not actually verify if the named package
-	 * exists in the classpath.
-	 *
-	 * <p>The default package is represented by an empty string ({@code ""}).
-	 *
-	 * @param packageName the package name to validate
-	 * @throws org.junit.platform.commons.PreconditionViolationException if the
-	 * supplied package name is {@code null}, contains only whitespace, or
-	 * contains parts that are not valid in terms of Java syntax (e.g.,
-	 * containing keywords such as {@code void}, {@code import}, etc.)
-	 * @see JavaNameUtils#isJavaName(String)
-	 */
-	public static void assertPackageNameIsValid(String packageName) {
-		Preconditions.notNull(packageName, "package name must not be null");
-		if (packageName.equals(DEFAULT_PACKAGE_NAME)) {
-			return;
-		}
-		Preconditions.notBlank(packageName, "package name must not contain only whitespace");
-		boolean allValid = Arrays.stream(DOT_PATTERN.split(packageName, -1)).allMatch(JavaNameUtils::isJavaName);
-		Preconditions.condition(allValid, "invalid part(s) in package name: " + packageName);
-	}
-
 	/**
 	 * Get the package attribute for the supplied {@code type} using the
 	 * supplied {@code function}.
@@ -101,11 +65,7 @@ public final class PackageUtils {
 	public static Optional<String> getAttribute(Class<?> type, Function<Package, String> function) {
 		Preconditions.notNull(type, "type must not be null");
 		Preconditions.notNull(function, "function must not be null");
-		Package typePackage = type.getPackage();
-		if (typePackage != null) {
-			return Optional.ofNullable(function.apply(typePackage));
-		}
-		return Optional.empty();
+		return Optional.ofNullable(type.getPackage()).map(function);
 	}
 
 	/**
@@ -129,11 +89,9 @@ public final class PackageUtils {
 		Preconditions.notNull(type, "type must not be null");
 		Preconditions.notBlank(name, "name must not be blank");
 		try {
-			CodeSource codeSource = type.getProtectionDomain().getCodeSource();
-			URL jarUrl = codeSource.getLocation();
+			URL jarUrl = type.getProtectionDomain().getCodeSource().getLocation();
 			try (JarFile jarFile = new JarFile(new File(jarUrl.toURI()))) {
-				Manifest manifest = jarFile.getManifest();
-				Attributes mainAttributes = manifest.getMainAttributes();
+				Attributes mainAttributes = jarFile.getManifest().getMainAttributes();
 				return Optional.ofNullable(mainAttributes.getValue(name));
 			}
 		}
@@ -141,48 +99,4 @@ public final class PackageUtils {
 			return Optional.empty();
 		}
 	}
-
-	/**
-	 * Collection of utilities for working with qualified names in Java.
-	 *
-	 * @since 1.6
-	 */
-	static class JavaNameUtils {
-
-		private static final Set<String> RESTRICTED_KEYWORDS = Collections.unmodifiableSet(
-			new HashSet<>(Arrays.asList("_", "abstract", "assert", "break", "case", "catch", "const", "continue",
-				"default", "do", "else", "enum", "false", "final", "finally", "for", "goto", "if", "import",
-				"instanceof", "native", "new", "null", "private", "protected", "public", "return", "static", "strictfp",
-				"super", "switch", "synchronized", "this", "throw", "transient", "true", "try", "volatile", "while")));
-
-		/**
-		 * Determine if the supplied {@code name} is a syntactically valid qualified name.
-		 *
-		 * @param name the string to check
-		 * @return {@code true} if the supplied string is a syntactically valid name
-		 */
-		static boolean isJavaName(String name) {
-			return name != null && !name.isEmpty() && isNotRestrictedKeyword(name) && isJavaIdentifier(name);
-		}
-
-		private static boolean isNotRestrictedKeyword(String name) {
-			return !RESTRICTED_KEYWORDS.contains(name);
-		}
-
-		private static boolean isJavaIdentifier(String name) {
-			int start = name.codePointAt(0);
-			if (!Character.isJavaIdentifierStart(start)) {
-				return false;
-			}
-			int charCount = Character.charCount(start);
-			for (int i = charCount; i < name.length(); i += charCount) {
-				int codePoint = name.codePointAt(i);
-				if (!Character.isJavaIdentifierPart(codePoint)) {
-					return false;
-				}
-			}
-			return true;
-		}
-	}
-
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/support/ReflectionSupportTests.java b/platform-tests/src/test/java/org/junit/platform/commons/support/ReflectionSupportTests.java
index 46b9dedc1..3e3298ad4 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/support/ReflectionSupportTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/support/ReflectionSupportTests.java
@@ -105,10 +105,6 @@ class ReflectionSupportTests {
 
 	@Test
 	void findAllClassesInPackageDelegates() {
-		assertThrows(PreconditionViolationException.class,
-			() -> ReflectionUtils.findAllClassesInPackage("void.return.null", allTypes, allNames));
-		assertThrows(PreconditionViolationException.class,
-			() -> ReflectionSupport.findAllClassesInPackage("void.return.null", allTypes, allNames));
 		assertNotEquals(0, ReflectionSupport.findAllClassesInPackage("org.junit", allTypes, allNames).size());
 		assertEquals(ReflectionUtils.findAllClassesInPackage("org.junit", allTypes, allNames),
 			ReflectionSupport.findAllClassesInPackage("org.junit", allTypes, allNames));
@@ -116,7 +112,7 @@ class ReflectionSupportTests {
 
 	@Test
 	void findAllClassesInPackagePreconditions() {
-		assertPreconditionViolationException("package name",
+		assertPreconditionViolationExceptionForString("basePackageName",
 			() -> ReflectionSupport.findAllClassesInPackage(null, allTypes, allNames));
 		assertPreconditionViolationException("class predicate",
 			() -> ReflectionSupport.findAllClassesInPackage("org.junit", null, allNames));
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/PackageUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/PackageUtilsTests.java
index ee9fe5b8e..0005995a1 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/PackageUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/PackageUtilsTests.java
@@ -19,17 +19,11 @@ import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 import java.util.List;
 import java.util.function.Function;
 
-import javax.lang.model.SourceVersion;
-
 import org.junit.jupiter.api.DynamicTest;
-import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.function.Executable;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.commons.PreconditionViolationException;
-import org.junit.platform.commons.util.PackageUtils.JavaNameUtils;
 import org.opentest4j.ValueWrapper;
 
 /**
@@ -39,30 +33,6 @@ import org.opentest4j.ValueWrapper;
  */
 class PackageUtilsTests {
 
-	@Test
-	void assertPackageNameIsValidForValidPackageNames() {
-		PackageUtils.assertPackageNameIsValid(""); // default package
-		PackageUtils.assertPackageNameIsValid("non.existing.but.all.segments.are.syntactically.valid");
-	}
-
-	@Test
-	void assertPackageNameIsValidForNullPackageName() {
-		assertThrows(PreconditionViolationException.class, () -> PackageUtils.assertPackageNameIsValid(null));
-	}
-
-	@Test
-	void assertPackageNameIsValidForWhitespacePackageName() {
-		assertThrows(PreconditionViolationException.class, () -> PackageUtils.assertPackageNameIsValid("    "));
-	}
-
-	@Test
-	void assertPackageNameIsValidForInvalidPackageNames() {
-		assertThrows(PreconditionViolationException.class, () -> PackageUtils.assertPackageNameIsValid(".a"));
-		assertThrows(PreconditionViolationException.class, () -> PackageUtils.assertPackageNameIsValid("a."));
-		assertThrows(PreconditionViolationException.class, () -> PackageUtils.assertPackageNameIsValid("a..b"));
-		assertThrows(PreconditionViolationException.class, () -> PackageUtils.assertPackageNameIsValid("byte.true"));
-	}
-
 	@Test
 	void getAttributeWithNullType() {
 		var exception = assertThrows(PreconditionViolationException.class,
@@ -125,27 +95,4 @@ class PackageUtilsTests {
 			() -> PackageUtils.getAttribute(getClass(), ""));
 		assertEquals("name must not be blank", exception.getMessage());
 	}
-
-	@Nested
-	class JavaNameUtilsTests {
-
-		@ParameterizedTest
-		@ValueSource(strings = { "name", "_NAME", "null", "var", "public", "$+!", "", "  ", "123", "true" })
-		void isJavaName(String s) {
-			assertEquals(SourceVersion.isName(s), JavaNameUtils.isJavaName(s));
-		}
-
-		@Test
-		void isJavaNameWithNullValue() {
-			// According to https://bugs.openjdk.java.net/browse/JDK-6362039,
-			// SourceVersion.isName(null) throws a NullPointerException instead
-			// of returning false.
-			assertThrows(NullPointerException.class, () -> SourceVersion.isName(null));
-
-			// However, for our purposes, we return false for a null value.
-			assertFalse(JavaNameUtils.isJavaName(null));
-		}
-
-	}
-
 }
