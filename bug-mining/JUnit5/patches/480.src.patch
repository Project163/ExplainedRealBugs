diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index 3cc23413c..b1f9c13e4 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -108,6 +108,7 @@ endif::[]
 :TestExecutionExceptionHandler:              {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestExecutionExceptionHandler.html[TestExecutionExceptionHandler]
 :TestInstanceFactory:                        {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestInstanceFactory.html[TestInstanceFactory]
 :TestInstancePostProcessor:                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestInstancePostProcessor.html[TestInstancePostProcessor]
+:TestInstancePreConstructCallback:           {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestInstancePreConstructCallback.html[TestInstancePreConstructCallback]
 :TestInstancePreDestroyCallback:             {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.html[TestInstancePreDestroyCallback]
 :TestTemplateInvocationContext:              {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestTemplateInvocationContext.html[TestTemplateInvocationContext]
 :TestTemplateInvocationContextProvider:      {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html[TestTemplateInvocationContextProvider]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
index 26bc2e09c..a2d404532 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
@@ -46,6 +46,8 @@ on GitHub.
   parameterized or dynamic tests.
 * Add support for `MATCH_NONE` mode in `EnumSource` that selects only those enum constants
   whose names match none of the supplied patterns.
+* A new extension `TestInstancePreConstructCallback` called prior to a test instance construction
+  (symmetric extension to `TestInstancePreDestroyCallback`).
 
 
 [[release-notes-5.9.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/extensions.adoc b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
index 52777870b..4c80e2b2b 100644
--- a/documentation/src/docs/asciidoc/user-guide/extensions.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
@@ -321,6 +321,17 @@ following system property.
 
 Refer to <<running-tests-config-params-deactivation-pattern>> for details.
 
+[[extensions-test-instance-pre-construct-callback]]
+=== Test Instance Pre-construct Callback
+
+`{TestInstancePreConstructCallback}` defines the API for `Extensions` that wish to be invoked
+_prior_ to test instances being constructed (by a constructor call or via
+`{TestInstanceFactory}`).
+
+This extension provides a symmetric call to `{TestInstancePreDestroyCallback}` and is useful
+in combination with other extensions to prepare constructor parameters or keeping track of test
+instances and their lifecycle.
+
 [[extensions-test-instance-factories]]
 === Test Instance Factories
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreConstructCallback.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreConstructCallback.java
new file mode 100644
index 000000000..05bd129ff
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreConstructCallback.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2015-2021 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.TestInstance.Lifecycle;
+
+/**
+ * {@link TestInstancePreConstructCallback} defines the API for {@link Extension
+ * Extensions} that wish to be invoked <em>prior</em> to creation of test instances.
+ *
+ * <p>This extension is a symmetric counterpart to {@link TestInstancePreDestroyCallback}.
+ * The use cases for this extension may include preparing context-sensitive arguments
+ * that are injected into the instance's constructor parameters.
+ *
+ * <p>Extensions that implement {@link TestInstancePreConstructCallback} must be
+ * registered at the class level if the test class is configured with
+ * {@link Lifecycle @TestInstance(Lifecycle.PER_CLASS)}
+ * semantics. If the test class is configured with
+ * {@link Lifecycle @TestInstance(Lifecycle.PER_METHOD)}
+ * semantics, {@link TestInstancePreConstructCallback} extensions may be registered
+ * at the class level or at the method level. In the latter case, the
+ * extension will only be applied to the test method for which it is registered.
+ *
+ * <h3>Constructor Requirements</h3>
+ *
+ * <p>Consult the documentation in {@link Extension} for details on constructor
+ * requirements.
+ *
+ * @since 5.9
+ * @see TestInstancePreDestroyCallback
+ * @see TestInstanceFactory
+ * @see ParameterResolver
+ */
+@FunctionalInterface
+@API(status = EXPERIMENTAL, since = "5.9")
+public interface TestInstancePreConstructCallback extends Extension {
+
+	/**
+	 * Callback invoked prior to test instances being constructed.
+	 *
+	 * @param factoryContext the context for the test instance about to be instantiated;
+	 * never {@code null}
+	 * @param context the current extension context; never {@code null}
+	 */
+	void preConstructTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext context) throws Exception;
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
index e29ef7c40..a3f990bb8 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
@@ -41,6 +41,9 @@ import org.junit.jupiter.api.TestInstance.Lifecycle;
  * {@code TestInstancePreDestroyCallback} extension will only be applied to the
  * test method for which it is registered.
  *
+ * <p>A symmetric {@link TestInstancePreConstructCallback} extension defines a callback
+ * hook that is invoked prior to any test class instances being constructed.
+ *
  * <h3>Constructor Requirements</h3>
  *
  * <p>Consult the documentation in {@link Extension} for details on constructor
@@ -49,6 +52,7 @@ import org.junit.jupiter.api.TestInstance.Lifecycle;
  * @since 5.6
  * @see #preDestroyTestInstance(ExtensionContext)
  * @see TestInstancePostProcessor
+ * @see TestInstancePreConstructCallback
  * @see TestInstanceFactory
  * @see ParameterResolver
  */
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index 910392078..71c382e48 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -43,7 +43,9 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler;
 import org.junit.jupiter.api.extension.TestInstanceFactory;
+import org.junit.jupiter.api.extension.TestInstanceFactoryContext;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreConstructCallback;
 import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestInstantiationException;
@@ -297,6 +299,8 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 			ExtensionContext extensionContext) {
 
 		Optional<Object> outerInstance = outerInstances.map(TestInstances::getInnermostInstance);
+		invokeTestInstancePreConstructCallbacks(new DefaultTestInstanceFactoryContext(this.testClass, outerInstance),
+			registry, extensionContext);
 		Object instance = this.testInstanceFactory != null //
 				? invokeTestInstanceFactory(outerInstance, extensionContext) //
 				: invokeTestClassConstructor(outerInstance, registry, extensionContext);
@@ -356,6 +360,12 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 			InvocationInterceptor::interceptTestClassConstructor);
 	}
 
+	private void invokeTestInstancePreConstructCallbacks(TestInstanceFactoryContext factoryContext,
+			ExtensionRegistry registry, ExtensionContext context) {
+		registry.stream(TestInstancePreConstructCallback.class).forEach(
+			extension -> executeAndMaskThrowable(() -> extension.preConstructTestInstance(factoryContext, context)));
+	}
+
 	private void invokeTestInstancePostProcessors(Object instance, ExtensionRegistry registry,
 			ExtensionContext context) {
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
index 73edebc46..7733653f9 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
@@ -44,6 +44,7 @@ public class KitchenSinkExtension implements
 	LifecycleMethodExecutionExceptionHandler,
 
 	// Dependency Injection
+	TestInstancePreConstructCallback,
 	TestInstanceFactory,
 	TestInstancePostProcessor,
 	TestInstancePreDestroyCallback,
@@ -112,6 +113,10 @@ public class KitchenSinkExtension implements
 
 	// --- Dependency Injection ------------------------------------------------
 
+	@Override
+	public void preConstructTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext context) {
+	}
+
 	@Override
 	public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext) {
 		return null;
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreConstructCallbackTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreConstructCallbackTests.java
new file mode 100644
index 000000000..c6c91d5ec
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreConstructCallbackTests.java
@@ -0,0 +1,425 @@
+/*
+ * Copyright 2015-2021 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.junit.jupiter.api.extension.TestInstanceFactory;
+import org.junit.jupiter.api.extension.TestInstanceFactoryContext;
+import org.junit.jupiter.api.extension.TestInstancePreConstructCallback;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+
+/**
+ * Integration tests that verify support for {@link TestInstancePreConstructCallback}.
+ *
+ * @since 5.9
+ */
+class TestInstancePreConstructCallbackTests extends AbstractJupiterTestEngineTests {
+	private static final List<String> callSequence = new ArrayList<>();
+
+	@BeforeEach
+	void resetCallSequence() {
+		callSequence.clear();
+	}
+
+	static class CallSequenceRecordingTest {
+		protected static void record(String event) {
+			callSequence.add(event);
+		}
+	}
+
+	@ExtendWith(InstancePreConstructCallbackRecordingFoo.class)
+	static class InstancePreConstruct extends CallSequenceRecordingTest {
+		public InstancePreConstruct() {
+			record("constructor");
+		}
+
+		@BeforeAll
+		static void beforeAll() {
+			record("beforeAll");
+		}
+
+		@BeforeEach
+		void beforeEach() {
+			record("beforeEach");
+		}
+
+		@Test
+		void test1() {
+			record("test1");
+		}
+
+		@Test
+		void test2() {
+			record("test2");
+		}
+
+		@AfterEach
+		void afterEach() {
+			record("afterEach");
+		}
+
+		@AfterAll
+		static void afterAll() {
+			record("afterAll");
+		}
+	}
+
+	@Test
+	void instancePreConstruct() {
+		executeTestsForClass(InstancePreConstruct.class).testEvents().assertStatistics(
+			stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+				"beforeAll",
+
+				"PreConstructCallback: name=foo, testClass=InstancePreConstruct, outerInstance: null",
+				"constructor",
+				"beforeEach",
+				"test1",
+				"afterEach",
+
+				"PreConstructCallback: name=foo, testClass=InstancePreConstruct, outerInstance: null",
+				"constructor",
+				"beforeEach",
+				"test2",
+				"afterEach",
+
+				"afterAll"
+		);
+		// @formatter:on
+	}
+
+	@ExtendWith(InstancePreConstructCallbackRecordingFoo.class)
+	static class FactoryPreConstruct extends CallSequenceRecordingTest {
+		@RegisterExtension
+		static final TestInstanceFactory factory = (factoryContext, extensionContext) -> {
+			record("testInstanceFactory");
+			return new FactoryPreConstruct();
+		};
+
+		public FactoryPreConstruct() {
+			record("constructor");
+		}
+
+		@BeforeAll
+		static void beforeAll() {
+			record("beforeAll");
+		}
+
+		@BeforeEach
+		void beforeEach() {
+			record("beforeEach");
+		}
+
+		@Test
+		void test1() {
+			record("test1");
+		}
+
+		@Test
+		void test2() {
+			record("test2");
+		}
+
+		@AfterEach
+		void afterEach() {
+			record("afterEach");
+		}
+
+		@AfterAll
+		static void afterAll() {
+			record("afterAll");
+		}
+	}
+
+	@Test
+	void factoryPreConstruct() {
+		executeTestsForClass(FactoryPreConstruct.class).testEvents().assertStatistics(
+			stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+				"beforeAll",
+
+				"PreConstructCallback: name=foo, testClass=FactoryPreConstruct, outerInstance: null",
+				"testInstanceFactory",
+				"constructor",
+				"beforeEach",
+				"test1",
+				"afterEach",
+
+				"PreConstructCallback: name=foo, testClass=FactoryPreConstruct, outerInstance: null",
+				"testInstanceFactory",
+				"constructor",
+				"beforeEach",
+				"test2",
+				"afterEach",
+
+				"afterAll"
+		);
+		// @formatter:on
+	}
+
+	@ExtendWith(InstancePreConstructCallbackRecordingFoo.class)
+	static class PreConstructInNested extends CallSequenceRecordingTest {
+		static AtomicInteger instanceCounter = new AtomicInteger();
+		private final String instanceId;
+
+		public PreConstructInNested() {
+			record("constructor");
+			instanceId = "#" + instanceCounter.incrementAndGet();
+		}
+
+		@BeforeAll
+		static void beforeAll() {
+			instanceCounter.set(0);
+			record("beforeAll");
+		}
+
+		@BeforeEach
+		void beforeEach() {
+			record("beforeEach");
+		}
+
+		@Test
+		void outerTest1() {
+			record("outerTest1");
+		}
+
+		@Test
+		void outerTest2() {
+			record("outerTest2");
+		}
+
+		@AfterEach
+		void afterEach() {
+			record("afterEach");
+		}
+
+		@AfterAll
+		static void afterAll() {
+			record("afterAll");
+		}
+
+		@Override
+		public String toString() {
+			return instanceId;
+		}
+
+		@ExtendWith(InstancePreConstructCallbackRecordingBar.class)
+		abstract class InnerParent extends CallSequenceRecordingTest {
+		}
+
+		@Nested
+		@ExtendWith(InstancePreConstructCallbackRecordingBaz.class)
+		class Inner extends InnerParent {
+			Inner() {
+				record("constructorInner");
+			}
+
+			@BeforeEach
+			void beforeEachInner() {
+				record("beforeEachInner");
+			}
+
+			@Test
+			void innerTest1() {
+				record("innerTest1");
+			}
+
+			@AfterEach
+			void afterEachInner() {
+				record("afterEachInner");
+			}
+		}
+	}
+
+	@Test
+	void preConstructInNested() {
+		executeTestsForClass(PreConstructInNested.class).testEvents().assertStatistics(
+			stats -> stats.started(3).succeeded(3));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+				"beforeAll",
+
+				"PreConstructCallback: name=foo, testClass=PreConstructInNested, outerInstance: null",
+				"constructor",
+				"beforeEach",
+				"outerTest1",
+				"afterEach",
+
+				"PreConstructCallback: name=foo, testClass=PreConstructInNested, outerInstance: null",
+				"constructor",
+				"beforeEach",
+				"outerTest2",
+				"afterEach",
+
+				"PreConstructCallback: name=foo, testClass=PreConstructInNested, outerInstance: null",
+				"constructor",
+
+				"PreConstructCallback: name=foo, testClass=Inner, outerInstance: #3",
+				"PreConstructCallback: name=bar, testClass=Inner, outerInstance: #3",
+				"PreConstructCallback: name=baz, testClass=Inner, outerInstance: #3",
+				"constructorInner",
+				"beforeEach",
+				"beforeEachInner",
+				"innerTest1",
+				"afterEachInner",
+				"afterEach",
+
+				"afterAll"
+		);
+		// @formatter:on
+	}
+
+	static class PreConstructOnMethod extends CallSequenceRecordingTest {
+		PreConstructOnMethod() {
+			record("constructor");
+		}
+
+		@BeforeEach
+		void beforeEach() {
+			record("beforeEach");
+		}
+
+		@ExtendWith(InstancePreConstructCallbackRecordingFoo.class)
+		@Test
+		void test1() {
+			record("test1");
+		}
+
+		@Test
+		void test2() {
+			record("test2");
+		}
+
+		@AfterEach
+		void afterEach() {
+			record("afterEach");
+		}
+	}
+
+	@Test
+	void preConstructOnMethod() {
+		executeTestsForClass(PreConstructOnMethod.class).testEvents().assertStatistics(
+			stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+				"PreConstructCallback: name=foo, testClass=PreConstructOnMethod, outerInstance: null",
+				"constructor",
+				"beforeEach",
+				"test1",
+				"afterEach",
+
+				"constructor",
+				"beforeEach",
+				"test2",
+				"afterEach"
+		);
+		// @formatter:on
+	}
+
+	@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+	@ExtendWith(InstancePreConstructCallbackRecordingFoo.class)
+	@ExtendWith(InstancePreConstructCallbackRecordingBar.class)
+	static class PreConstructWithClassLifecycle extends CallSequenceRecordingTest {
+		PreConstructWithClassLifecycle() {
+			record("constructor");
+		}
+
+		@BeforeEach
+		void beforeEach() {
+			record("beforeEach");
+		}
+
+		@Test
+		void test1() {
+			callSequence.add("test1");
+		}
+
+		@Test
+		void test2() {
+			callSequence.add("test2");
+		}
+	}
+
+	@Test
+	void preConstructWithClassLifecycle() {
+		executeTestsForClass(PreConstructWithClassLifecycle.class).testEvents().assertStatistics(
+			stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+				"PreConstructCallback: name=foo, testClass=PreConstructWithClassLifecycle, outerInstance: null",
+				"PreConstructCallback: name=bar, testClass=PreConstructWithClassLifecycle, outerInstance: null",
+				"constructor",
+				"beforeEach",
+				"test1",
+				"beforeEach",
+				"test2"
+		);
+		// @formatter:on
+	}
+
+	static abstract class AbstractTestInstancePreConstructCallback implements TestInstancePreConstructCallback {
+		private final String name;
+
+		AbstractTestInstancePreConstructCallback(String name) {
+			this.name = name;
+		}
+
+		@Override
+		public void preConstructTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext context) {
+			assertThat(context.getTestInstance()).isNotPresent();
+			assertThat(context.getTestClass()).isPresent();
+			assertThat(factoryContext.getTestClass()).isSameAs(context.getTestClass().get());
+			callSequence.add(
+				"PreConstructCallback: name=" + name + ", testClass=" + factoryContext.getTestClass().getSimpleName()
+						+ ", outerInstance: " + factoryContext.getOuterInstance().orElse(null));
+		}
+	}
+
+	static class InstancePreConstructCallbackRecordingFoo extends AbstractTestInstancePreConstructCallback {
+		InstancePreConstructCallbackRecordingFoo() {
+			super("foo");
+		}
+	}
+
+	static class InstancePreConstructCallbackRecordingBar extends AbstractTestInstancePreConstructCallback {
+		InstancePreConstructCallbackRecordingBar() {
+			super("bar");
+		}
+	}
+
+	static class InstancePreConstructCallbackRecordingBaz extends AbstractTestInstancePreConstructCallback {
+		InstancePreConstructCallbackRecordingBaz() {
+			super("baz");
+		}
+	}
+}
