diff --git a/flume-ng-core/src/main/java/org/apache/flume/source/SyslogTcpSource.java b/flume-ng-core/src/main/java/org/apache/flume/source/SyslogTcpSource.java
index d78d27ff..c5964aeb 100644
--- a/flume-ng-core/src/main/java/org/apache/flume/source/SyslogTcpSource.java
+++ b/flume-ng-core/src/main/java/org/apache/flume/source/SyslogTcpSource.java
@@ -18,17 +18,16 @@
  */
 package org.apache.flume.source;
 
-import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
 import org.apache.flume.ChannelException;
 import org.apache.flume.Context;
+import org.apache.flume.CounterGroup;
 import org.apache.flume.Event;
 import org.apache.flume.EventDrivenSource;
 import org.apache.flume.conf.Configurable;
-import org.apache.flume.source.SyslogUtils;
 import org.jboss.netty.bootstrap.ServerBootstrap;
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.channel.Channel;
@@ -53,21 +52,29 @@ implements EventDrivenSource, Configurable {
   private int port = SYSLOG_TCP_PORT; // this is syslog-ng's default tcp port.
   private String host = null;
   private Channel nettyChannel;
+  private CounterGroup counterGroup = new CounterGroup();
 
   public class syslogTcpHandler extends SimpleChannelHandler {
+
+    private SyslogUtils syslogUtils = new SyslogUtils();
+
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent mEvent) {
-      try {
-        Event e = SyslogUtils.extractEvent((ChannelBuffer)mEvent.getMessage());
+      ChannelBuffer buff = (ChannelBuffer) mEvent.getMessage();
+      while (buff.readable()) {
+        Event e = syslogUtils.extractEvent(buff);
         if (e == null) {
-          return;
+          logger.debug("Parsed partial event, event will be generated when " +
+              "rest of the event is received.");
+          continue;
+        }
+        try {
+          getChannelProcessor().processEvent(e);
+          counterGroup.incrementAndGet("events.success");
+        } catch (ChannelException ex) {
+          counterGroup.incrementAndGet("events.dropped");
+          logger.error("Error writting to channel, event dropped", ex);
         }
-        getChannelProcessor().processEvent(e);
-      } catch (ChannelException ex) {
-        logger.error("Error writting to channel", ex);
-        return;
-      } catch (IOException eI) {
-        logger.error("Error reading from network", eI);
       }
 
     }
@@ -85,6 +92,8 @@ implements EventDrivenSource, Configurable {
       }
     });
 
+    logger.info("Syslog TCP Source starting...");
+
     if (host == null) {
       nettyChannel = serverBootstrap.bind(new InetSocketAddress(port));
     } else {
@@ -96,6 +105,9 @@ implements EventDrivenSource, Configurable {
 
   @Override
   public void stop() {
+    logger.info("Syslog TCP Source stopping...");
+    logger.info("Metrics:{}", counterGroup);
+
     if (nettyChannel != null) {
       nettyChannel.close();
       try {
@@ -112,7 +124,7 @@ implements EventDrivenSource, Configurable {
 
   @Override
   public void configure(Context context) {
-    port = Integer.parseInt(context.getString("port"));
+    port = context.getInteger("port", SYSLOG_TCP_PORT);
     host = context.getString("host");
   }
 
diff --git a/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUDPSource.java b/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUDPSource.java
index 34818f0d..eb483dad 100644
--- a/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUDPSource.java
+++ b/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUDPSource.java
@@ -18,13 +18,13 @@
  */
 package org.apache.flume.source;
 
-import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
 import org.apache.flume.ChannelException;
 import org.apache.flume.Context;
+import org.apache.flume.CounterGroup;
 import org.apache.flume.Event;
 import org.apache.flume.EventDrivenSource;
 import org.apache.flume.conf.Configurable;
@@ -55,21 +55,23 @@ public class SyslogUDPSource extends AbstractSource
   private static final Logger logger = LoggerFactory
       .getLogger(SyslogUDPSource.class);
 
-
+  private CounterGroup counterGroup = new CounterGroup();
   public class syslogHandler extends SimpleChannelHandler {
+    private SyslogUtils syslogUtils = new SyslogUtils(true);
+
     @Override
     public void messageReceived(ChannelHandlerContext ctx, MessageEvent mEvent) {
       try {
-        Event e = SyslogUtils.extractEvent((ChannelBuffer)mEvent.getMessage());
+        Event e = syslogUtils.extractEvent((ChannelBuffer)mEvent.getMessage());
         if (e == null) {
           return;
         }
         getChannelProcessor().processEvent(e);
+        counterGroup.incrementAndGet("events.success");
       } catch (ChannelException ex) {
+        counterGroup.incrementAndGet("events.dropped");
         logger.error("Error writting to channel", ex);
         return;
-      } catch (IOException eI) {
-        logger.error("Error reading from network", eI);
       }
     }
   }
@@ -96,6 +98,8 @@ public class SyslogUDPSource extends AbstractSource
 
   @Override
   public void stop() {
+    logger.info("Syslog UDP Source stopping...");
+    logger.info("Metrics:{}", counterGroup);
     if (nettyChannel != null) {
       nettyChannel.close();
       try {
diff --git a/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUtils.java b/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUtils.java
index ceb9ff19..061ec951 100644
--- a/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUtils.java
+++ b/flume-ng-core/src/main/java/org/apache/flume/source/SyslogUtils.java
@@ -27,59 +27,127 @@ import java.util.Map;
 import org.apache.flume.Event;
 import org.apache.flume.event.EventBuilder;
 import org.jboss.netty.buffer.ChannelBuffer;
-import org.jboss.netty.channel.Channel;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class SyslogUtils {
 
-  protected String host = null;
-  protected int port;
-  protected Channel nettyChannel;
+  private Mode m = Mode.START;
+  private StringBuilder prio = new StringBuilder();
+  private ByteArrayOutputStream baos;
   private static final Logger logger = LoggerFactory
       .getLogger(SyslogUtils.class);
 
   final public static String SYSLOG_FACILITY = "Facility";
   final public static String SYSLOG_SEVERITY = "Severity";
+  final public static String EVENT_STATUS = "flume.syslog.status";
+  final public static Integer MIN_SIZE = 10;
+  final public static Integer DEFAULT_SIZE = 2500;
+  private final boolean isUdp;
+  private boolean isBadEvent;
+  private boolean isIncompleteEvent;
+  private Integer maxSize;
+
+  public SyslogUtils() {
+    this(false);
+  }
+
+  public SyslogUtils(boolean isUdp) {
+    this(DEFAULT_SIZE, isUdp);
+  }
+
+  public SyslogUtils(Integer eventSize, boolean isUdp){
+    this.isUdp = isUdp;
+    isBadEvent = false;
+    isIncompleteEvent = false;
+    maxSize = (eventSize < MIN_SIZE) ? MIN_SIZE : eventSize;
+    baos = new ByteArrayOutputStream(eventSize);
+  }
 
   enum Mode {
-    START, PRIO, DATA, ERR
+    START, PRIO, DATA
   };
 
-  // create the event from syslog data
-  static Event buildEvent(StringBuilder prio,
-      ByteArrayOutputStream baos) {
+  public enum SyslogStatus{
+    OTHER("Unknown"),
+    INVALID("Invalid"),
+    INCOMPLETE("Incomplete");
+
+    private final String syslogStatus;
 
-    int pri = Integer.parseInt(prio.toString());
-    int  sev = pri % 8;
-    int facility = pri - sev;
+    private SyslogStatus(String status){
+      syslogStatus = status;
+    }
+
+    public String getSyslogStatus(){
+      return this.syslogStatus;
+    }
+  }
+
+  // create the event from syslog data
+  Event buildEvent() {
+    int pri = 0;
+    int sev = 0;
+    int facility = 0;
+    if(!isBadEvent){
+      pri = Integer.parseInt(prio.toString());
+      sev = pri % 8;
+      facility = pri - sev;
+    }
     Map <String, String> headers = new HashMap<String, String>();
     headers.put(SYSLOG_FACILITY, String.valueOf(facility));
     headers.put(SYSLOG_SEVERITY, String.valueOf(sev));
+    if(isBadEvent){
+      logger.warn("Event created from Invalid Syslog data.");
+      headers.put(EVENT_STATUS, SyslogStatus.INVALID.getSyslogStatus());
+    } else if(isIncompleteEvent){
+      logger.warn("Event size larger than specified event size: {}. You should " +
+          "consider increasing your event size.", maxSize);
+      headers.put(EVENT_STATUS, SyslogStatus.INCOMPLETE.getSyslogStatus());
+    }
     // TODO: add hostname and timestamp if provided ...
 
-    return EventBuilder.withBody(baos.toByteArray(), headers);
+    byte[] body = baos.toByteArray();
+    reset();
+    return EventBuilder.withBody(body, headers);
+  }
+
+  private void reset(){
+    baos.reset();
+    m = Mode.START;
+    prio.delete(0, prio.length());
+    isBadEvent = false;
+    isIncompleteEvent = false;
+
   }
 
   // extract relevant syslog data needed for building Flume event
-  public static Event extractEvent(ChannelBuffer in)
-        throws IOException {
-    StringBuilder prio = new StringBuilder();
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+  public Event extractEvent(ChannelBuffer in){
+
+    /* for protocol debugging
+    ByteBuffer bb = in.toByteBuffer();
+    int remaining = bb.remaining();
+    byte[] buf = new byte[remaining];
+    bb.get(buf);
+    HexDump.dump(buf, 0, System.out, 0);
+    */
+
     byte b = 0;
-    Mode m = Mode.START;
     Event e = null;
     boolean doneReading = false;
 
     try {
-      while (!doneReading) {
+      while (!doneReading && in.readable()) {
         b = in.readByte();
         switch (m) {
         case START:
           if (b == '<') {
             m = Mode.PRIO;
           } else {
-            m = Mode.ERR;
+            isBadEvent = true;
+            baos.write(b);
+            //Bad event, just dump everything as if it is data.
+            m = Mode.DATA;
           }
           break;
         case PRIO:
@@ -87,35 +155,48 @@ public class SyslogUtils {
             m = Mode.DATA;
           } else {
             char ch = (char) b;
-            if (Character.isDigit(ch)) {
-              prio.append(ch); // stay in PRIO mode
-            } else {
-              m = Mode.ERR;
+            prio.append(ch);
+            if (!Character.isDigit(ch)) {
+              isBadEvent = true;
+              //Append the priority to baos:
+              String badPrio = "<"+ prio;
+              baos.write(badPrio.getBytes());
+              //If we hit a bad priority, just write as if everything is data.
+              m = Mode.DATA;
             }
           }
           break;
         case DATA:
           // TCP syslog entries are separated by '\n'
           if (b == '\n') {
-            e = buildEvent(prio, baos);
+            e = buildEvent();
             doneReading = true;
+          } else {
+            baos.write(b);
           }
-
-          baos.write(b);
-          break;
-        case ERR:
-          if (b == '<') {
-            // check if its start of new event
-            m = Mode.PRIO;
+          if(baos.size() == this.maxSize && !doneReading){
+            isIncompleteEvent = true;
+            e = buildEvent();
+            doneReading = true;
           }
-          // otherwise stay in Mode.ERR;
           break;
         }
+
+      }
+
+      // UDP doesn't send a newline, so just use what we received
+      if (e == null && isUdp) {
+        doneReading = true;
+        e = buildEvent();
       }
-      return null;
-    } catch (IndexOutOfBoundsException eF) {
-        e = buildEvent(prio, baos);
+    //} catch (IndexOutOfBoundsException eF) {
+    //    e = buildEvent(prio, baos);
+    } catch (IOException e1) {
+      //no op
+    } finally {
+      // no-op
     }
+
     return e;
   }
 
diff --git a/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUdpSource.java b/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUdpSource.java
index d1db49d0..3a7c4868 100644
--- a/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUdpSource.java
+++ b/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUdpSource.java
@@ -70,16 +70,19 @@ public class TestSyslogUdpSource {
         "localhost:"+TEST_SYSLOG_PORT, SyslogAppender.LOG_FTP);
     logger.addAppender(appender);
     Event e = null;
+    Event e2 = null;
 
     source.start();
 
     // write to syslog
     logger.info("test flume syslog");
+    logger.info("");
 
     Transaction txn = channel.getTransaction();
     try {
       txn.begin();
       e = channel.take();
+      e2 = channel.take();
       txn.commit();
     } finally {
       txn.close();
@@ -90,7 +93,11 @@ public class TestSyslogUdpSource {
 
     Assert.assertNotNull(e);
     Assert.assertEquals(e.getHeaders().get(SyslogUtils.SYSLOG_FACILITY), String.valueOf(SyslogAppender.LOG_FTP));
-    Assert.assertArrayEquals(e.getBody(),"test flume syslog".getBytes());
+    Assert.assertArrayEquals(e.getBody(), "test flume syslog".getBytes());
+
+    Assert.assertNotNull(e2);
+    Assert.assertEquals(e2.getHeaders().get(SyslogUtils.SYSLOG_FACILITY), String.valueOf(SyslogAppender.LOG_FTP));
+    Assert.assertArrayEquals(e2.getBody(), "".getBytes());
   }
 
 }
diff --git a/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUtils.java b/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUtils.java
new file mode 100644
index 00000000..8b1f7c5d
--- /dev/null
+++ b/flume-ng-core/src/test/java/org/apache/flume/source/TestSyslogUtils.java
@@ -0,0 +1,271 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.flume.source;
+
+
+import java.util.Map;
+
+import junit.framework.Assert;
+
+import org.apache.flume.Event;
+import org.jboss.netty.buffer.ChannelBuffer;
+import org.jboss.netty.buffer.ChannelBuffers;
+import org.junit.Test;
+
+public class TestSyslogUtils {
+
+  /**
+   * Test bad event format 1: Priority is not numeric
+   */
+  @Test
+  public void testExtractBadEvent1() {
+    String badData1 = "<10F> bad bad data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes(badData1.getBytes());
+    Event e = util.extractEvent(buff);
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(badData1.trim(), new String(e.getBody()).trim());
+
+  }
+
+  /**
+   * Test bad event format 2: The first char is not <
+   */
+
+  @Test
+  public void testExtractBadEvent2() {
+    String badData1 = "hi guys! <10> bad bad data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes(badData1.getBytes());
+    Event e = util.extractEvent(buff);
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(badData1.trim(), new String(e.getBody()).trim());
+
+  }
+
+  /**
+   * Good event
+   */
+  @Test
+  public void testExtractGoodEvent() {
+    String priority = "<10>";
+    String goodData1 = "Good good good data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes((priority+goodData1).getBytes());
+    Event e = util.extractEvent(buff);
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("8", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("2", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(null, headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(goodData1.trim(), new String(e.getBody()).trim());
+
+  }
+
+  /**
+   * Bad event immediately followed by a good event
+   */
+  @Test
+  public void testBadEventGoodEvent(){
+    String badData1 = "hi guys! <10F> bad bad data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes(badData1.getBytes());
+    String priority = "<10>";
+    String goodData1 = "Good good good data\n";
+    buff.writeBytes((priority+goodData1).getBytes());
+    Event e = util.extractEvent(buff);
+
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(badData1.trim(), new String(e.getBody()).trim());
+
+    Event e2 = util.extractEvent(buff);
+    if(e2 == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers2 = e2.getHeaders();
+    Assert.assertEquals("8", headers2.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("2", headers2.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(null,
+        headers2.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(goodData1.trim(), new String(e2.getBody()).trim());
+  }
+
+  @Test
+  public void testGoodEventBadEvent(){
+    String badData1 = "hi guys! <10F> bad bad data\n";
+    String priority = "<10>";
+    String goodData1 = "Good good good data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes((priority+goodData1).getBytes());
+    buff.writeBytes(badData1.getBytes());
+
+    Event e2 = util.extractEvent(buff);
+    if(e2 == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers2 = e2.getHeaders();
+    Assert.assertEquals("8", headers2.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("2", headers2.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(null,
+        headers2.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(goodData1.trim(), new String(e2.getBody()).trim());
+
+    Event e = util.extractEvent(buff);
+
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(badData1.trim(), new String(e.getBody()).trim());
+
+  }
+
+  @Test
+  public void testBadEventBadEvent(){
+    String badData1 = "hi guys! <10F> bad bad data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes(badData1.getBytes());
+    String badData2 = "hi guys! <20> bad bad data\n";
+    buff.writeBytes((badData2).getBytes());
+    Event e = util.extractEvent(buff);
+
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(badData1.trim(), new String(e.getBody()).trim());
+
+    Event e2 = util.extractEvent(buff);
+
+    if(e2 == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers2 = e2.getHeaders();
+    Assert.assertEquals("0", headers2.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers2.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers2.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(badData2.trim(), new String(e2.getBody()).trim());
+  }
+
+  @Test
+  public void testGoodEventGoodEvent() {
+
+    String priority = "<10>";
+    String goodData1 = "Good good good data\n";
+    SyslogUtils util = new SyslogUtils(false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes((priority+goodData1).getBytes());
+    String priority2 = "<20>";
+    String goodData2 = "Good really good data\n";
+    buff.writeBytes((priority2+goodData2).getBytes());
+    Event e = util.extractEvent(buff);
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("8", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("2", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(null,
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(goodData1.trim(), new String(e.getBody()).trim());
+
+
+    Event e2 = util.extractEvent(buff);
+    if(e2 == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers2 = e2.getHeaders();
+    Assert.assertEquals("16", headers2.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("4", headers2.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(null,
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals(goodData2.trim(), new String(e2.getBody()).trim());
+
+  }
+
+  @Test
+  public void testExtractBadEventLarge() {
+    String badData1 = "<10> bad bad data bad bad\n";
+    SyslogUtils util = new SyslogUtils(5, false);
+    ChannelBuffer buff = ChannelBuffers.buffer(100);
+    buff.writeBytes(badData1.getBytes());
+    Event e = util.extractEvent(buff);
+    if(e == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers = e.getHeaders();
+    Assert.assertEquals("8", headers.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("2", headers.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INCOMPLETE.getSyslogStatus(),
+        headers.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals("bad bad d".trim(), new String(e.getBody()).trim());
+
+    Event e2 = util.extractEvent(buff);
+
+    if(e2 == null){
+      throw new NullPointerException("Event is null");
+    }
+    Map<String, String> headers2 = e2.getHeaders();
+    Assert.assertEquals("0", headers2.get(SyslogUtils.SYSLOG_FACILITY));
+    Assert.assertEquals("0", headers2.get(SyslogUtils.SYSLOG_SEVERITY));
+    Assert.assertEquals(SyslogUtils.SyslogStatus.INVALID.getSyslogStatus(),
+        headers2.get(SyslogUtils.EVENT_STATUS));
+    Assert.assertEquals("ata bad ba".trim(), new String(e2.getBody()).trim());
+
+  }
+
+}
