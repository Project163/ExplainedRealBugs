diff --git a/flume-ng-core/src/main/java/org/apache/flume/sink/AvroSink.java b/flume-ng-core/src/main/java/org/apache/flume/sink/AvroSink.java
index 5c6d0e37..18fe3e19 100644
--- a/flume-ng-core/src/main/java/org/apache/flume/sink/AvroSink.java
+++ b/flume-ng-core/src/main/java/org/apache/flume/sink/AvroSink.java
@@ -39,6 +39,8 @@ import org.slf4j.LoggerFactory;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
+import java.util.Properties;
+import org.apache.flume.api.RpcClientConfigurationConstants;
 
 /**
  * <p>
@@ -74,27 +76,39 @@ import com.google.common.collect.Lists;
  * <tr>
  * <th>Parameter</th>
  * <th>Description</th>
- * <th>Unit / Type</th>
+ * <th>Unit (data type)</th>
  * <th>Default</th>
  * </tr>
  * <tr>
  * <td><tt>hostname</tt></td>
  * <td>The hostname to which events should be sent.</td>
- * <td>Hostname or IP / String</td>
+ * <td>Hostname or IP (String)</td>
  * <td>none (required)</td>
  * </tr>
  * <tr>
  * <td><tt>port</tt></td>
  * <td>The port to which events should be sent on <tt>hostname</tt>.</td>
- * <td>TCP port / int</td>
+ * <td>TCP port (int)</td>
  * <td>none (required)</td>
  * </tr>
  * <tr>
  * <td><tt>batch-size</tt></td>
  * <td>The maximum number of events to send per RPC.</td>
- * <td>events / int</td>
+ * <td>events (int)</td>
  * <td>100</td>
  * </tr>
+ * <tr>
+ * <td><tt>connect-timeout</tt></td>
+ * <td>Maximum time to wait for the first Avro handshake and RPC request</td>
+ * <td>milliseconds (long)</td>
+ * <td>20000</td>
+ * </tr>
+ * <tr>
+ * <td><tt>request-timeout</tt></td>
+ * <td>Maximum time to wait RPC requests after the first</td>
+ * <td>milliseconds (long)</td>
+ * <td>20000</td>
+ * </tr>
  * </table>
  * <p>
  * <b>Metrics</b>
@@ -106,14 +120,13 @@ import com.google.common.collect.Lists;
 public class AvroSink extends AbstractSink implements Configurable {
 
   private static final Logger logger = LoggerFactory.getLogger(AvroSink.class);
-  private static final Integer defaultBatchSize = 100;
 
   private String hostname;
   private Integer port;
-  private Integer batchSize;
 
   private RpcClient client;
   private CounterGroup counterGroup;
+  private Properties clientProps;
 
   public AvroSink() {
     counterGroup = new CounterGroup();
@@ -121,16 +134,37 @@ public class AvroSink extends AbstractSink implements Configurable {
 
   @Override
   public void configure(Context context) {
+    clientProps = new Properties();
+
     hostname = context.getString("hostname");
     port = context.getInteger("port");
 
-    batchSize = context.getInteger("batch-size");
-    if (batchSize == null) {
-      batchSize = defaultBatchSize;
-    }
-
     Preconditions.checkState(hostname != null, "No hostname specified");
     Preconditions.checkState(port != null, "No port specified");
+
+    clientProps.setProperty(RpcClientConfigurationConstants.CONFIG_HOSTS, "h1");
+    clientProps.setProperty(RpcClientConfigurationConstants.CONFIG_HOSTS_PREFIX +
+        "h1", hostname + ":" + port);
+
+    Integer batchSize = context.getInteger("batch-size");
+    if (batchSize != null) {
+      clientProps.setProperty(RpcClientConfigurationConstants.CONFIG_BATCH_SIZE,
+          String.valueOf(batchSize));
+    }
+
+    Long connectTimeout = context.getLong("connect-timeout");
+    if (connectTimeout != null) {
+      clientProps.setProperty(
+          RpcClientConfigurationConstants.CONFIG_CONNECT_TIMEOUT,
+          String.valueOf(connectTimeout));
+    }
+
+    Long requestTimeout = context.getLong("request-timeout");
+    if (requestTimeout != null) {
+      clientProps.setProperty(
+          RpcClientConfigurationConstants.CONFIG_REQUEST_TIMEOUT,
+          String.valueOf(requestTimeout));
+    }
   }
 
   /**
@@ -141,11 +175,12 @@ public class AvroSink extends AbstractSink implements Configurable {
   private void createConnection() throws FlumeException {
 
     if (client == null) {
-      logger.debug("Avro sink {}: Building RpcClient with hostname: {}, " +
-          "port: {}, batchSize: {}",
-          new Object[] { getName(), hostname, port, batchSize });
+      logger.info("Avro sink {}: Building RpcClient with hostname: {}, " +
+          "port: {}",
+          new Object[] { getName(), hostname, port });
 
-       client = RpcClientFactory.getDefaultInstance(hostname, port, batchSize);
+       client = RpcClientFactory.getInstance(clientProps);
+       logger.debug("Avro sink {}: Created RpcClient: {}", getName(), client);
     }
 
   }
@@ -195,9 +230,8 @@ public class AvroSink extends AbstractSink implements Configurable {
     try {
       createConnection();
     } catch (FlumeException e) {
-      logger.warn("Unable to create avro client using hostname:" + hostname
-          + ", port:" + port + ", batchSize: " + batchSize +
-          ". Exception follows.", e);
+      logger.warn("Unable to create avro client using hostname: " + hostname
+          + ", port: " + port, e);
 
       /* Try to prevent leaking resources. */
       destroyConnection();
@@ -238,7 +272,7 @@ public class AvroSink extends AbstractSink implements Configurable {
 
       List<Event> batch = Lists.newLinkedList();
 
-      for (int i = 0; i < batchSize; i++) {
+      for (int i = 0; i < client.getBatchSize(); i++) {
         Event event = channel.take();
 
         if (event == null) {
@@ -259,16 +293,19 @@ public class AvroSink extends AbstractSink implements Configurable {
       transaction.commit();
       counterGroup.incrementAndGet("batch.success");
 
-    } catch (ChannelException e) {
-      transaction.rollback();
-      logger.error("Avro Sink " + getName() + ": Unable to get event from" +
-          " channel. Exception follows.", e);
-      status = Status.BACKOFF;
-
-    } catch (Exception ex) {
+    } catch (Throwable t) {
       transaction.rollback();
-      destroyConnection();
-      throw new EventDeliveryException("Failed to send message", ex);
+      counterGroup.incrementAndGet("batch.failure");
+      if (t instanceof Error) {
+        throw (Error) t;
+      } else if (t instanceof ChannelException) {
+        logger.error("Avro Sink " + getName() + ": Unable to get event from" +
+            " channel " + channel.getName() + ". Exception follows.", t);
+        status = Status.BACKOFF;
+      } else {
+        destroyConnection();
+        throw new EventDeliveryException("Failed to send events", t);
+      }
     } finally {
       transaction.close();
     }
diff --git a/flume-ng-core/src/test/java/org/apache/flume/sink/TestAvroSink.java b/flume-ng-core/src/test/java/org/apache/flume/sink/TestAvroSink.java
index 37659242..b9e59ef8 100644
--- a/flume-ng-core/src/test/java/org/apache/flume/sink/TestAvroSink.java
+++ b/flume-ng-core/src/test/java/org/apache/flume/sink/TestAvroSink.java
@@ -23,7 +23,9 @@ import java.net.InetSocketAddress;
 import java.nio.charset.Charset;
 import java.util.HashMap;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
 
+import com.google.common.base.Charsets;
 import org.apache.avro.AvroRemoteException;
 import org.apache.avro.ipc.NettyServer;
 import org.apache.avro.ipc.Server;
@@ -52,7 +54,7 @@ public class TestAvroSink {
 
   private static final Logger logger = LoggerFactory
       .getLogger(TestAvroSink.class);
-  private static final String hostname = "localhost";
+  private static final String hostname = "127.0.0.1";
   private static final Integer port = 41414;
 
   private AvroSink sink;
@@ -65,9 +67,11 @@ public class TestAvroSink {
 
     Context context = new Context();
 
-    context.put("hostname", "localhost");
-    context.put("port", "41414");
-    context.put("batch-size", "2");
+    context.put("hostname", hostname);
+    context.put("port", String.valueOf(port));
+    context.put("batch-size", String.valueOf(2));
+    context.put("connect-timeout", String.valueOf(2000L));
+    context.put("request-timeout", String.valueOf(3000L));
 
     sink.setChannel(channel);
 
@@ -76,8 +80,9 @@ public class TestAvroSink {
   }
 
   @Test
-  public void testLifecycle() throws InterruptedException {
-    Server server = createServer();
+  public void testLifecycle() throws InterruptedException,
+      InstantiationException, IllegalAccessException {
+    Server server = createServer(new MockAvroServer());
 
     server.start();
 
@@ -94,11 +99,10 @@ public class TestAvroSink {
 
   @Test
   public void testProcess() throws InterruptedException,
-      EventDeliveryException {
+      EventDeliveryException, InstantiationException, IllegalAccessException {
 
-    Event event = EventBuilder.withBody("test event 1".getBytes(),
-        new HashMap<String, String>());
-    Server server = createServer();
+    Event event = EventBuilder.withBody("test event 1", Charsets.UTF_8);
+    Server server = createServer(new MockAvroServer());
 
     server.start();
 
@@ -129,13 +133,68 @@ public class TestAvroSink {
     server.close();
   }
 
+  @Test
+  public void testTimeout() throws InterruptedException,
+      EventDeliveryException, InstantiationException, IllegalAccessException {
+    Event event = EventBuilder.withBody("foo", Charsets.UTF_8);
+    AtomicLong delay = new AtomicLong();
+    Server server = createServer(new DelayMockAvroServer(delay));
+    server.start();
+    sink.start();
+    Assert.assertTrue(LifecycleController.waitForOneOf(sink,
+        LifecycleState.START_OR_ERROR, 5000));
+
+    Transaction txn = channel.getTransaction();
+    txn.begin();
+    for (int i = 0; i < 4; i++) {
+      channel.put(event);
+    }
+    txn.commit();
+    txn.close();
+
+    // should throw EventDeliveryException due to connect timeout
+    delay.set(3000L); // because connect-timeout = 2000
+    boolean threw = false;
+    try {
+      sink.process();
+    } catch (EventDeliveryException ex) {
+      logger.info("Correctly threw due to connect timeout. Exception follows.",
+          ex);
+      threw = true;
+    }
+
+    Assert.assertTrue("Must throw due to connect timeout", threw);
+
+    // now, allow the connect handshake to occur
+    delay.set(0);
+    sink.process();
+
+    // should throw another EventDeliveryException due to request timeout
+    delay.set(4000L); // because request-timeout = 3000
+    threw = false;
+    try {
+      sink.process();
+    } catch (EventDeliveryException ex) {
+      logger.info("Correctly threw due to request timeout. Exception follows.",
+          ex);
+      threw = true;
+    }
+
+    Assert.assertTrue("Must throw due to request timeout", threw);
+
+    sink.stop();
+    Assert.assertTrue(LifecycleController.waitForOneOf(sink,
+        LifecycleState.STOP_OR_ERROR, 5000));
+    server.close();
+  }
+
   @Test
   public void testFailedConnect() throws InterruptedException,
-      EventDeliveryException {
+      EventDeliveryException, InstantiationException, IllegalAccessException {
 
     Event event = EventBuilder.withBody("test event 1",
         Charset.forName("UTF8"));
-    Server server = createServer();
+    Server server = createServer(new MockAvroServer());
 
     server.start();
     sink.start();
@@ -166,7 +225,7 @@ public class TestAvroSink {
           threwException);
     }
 
-    server = createServer();
+    server = createServer(new MockAvroServer());
     server.start();
 
     for (int i = 0; i < 5; i++) {
@@ -182,9 +241,10 @@ public class TestAvroSink {
     server.close();
   }
 
-  private Server createServer() {
+  private Server createServer(AvroSourceProtocol protocol)
+      throws IllegalAccessException, InstantiationException {
     Server server = new NettyServer(new SpecificResponder(
-        AvroSourceProtocol.class, new MockAvroServer()), new InetSocketAddress(
+        AvroSourceProtocol.class, protocol), new InetSocketAddress(
         hostname, port));
 
     return server;
@@ -201,9 +261,40 @@ public class TestAvroSink {
     @Override
     public Status appendBatch(List<AvroFlumeEvent> events)
         throws AvroRemoteException {
-
       logger.debug("Received event batch:{}", events);
+      return Status.OK;
+    }
+
+  }
+
+  private static class DelayMockAvroServer implements AvroSourceProtocol {
+
+    private final AtomicLong delay;
+
+    public DelayMockAvroServer(AtomicLong delay) {
+      this.delay = delay;
+    }
+
+    private void sleep() throws AvroRemoteException {
+      try {
+        Thread.sleep(delay.get());
+      } catch (InterruptedException e) {
+        throw new AvroRemoteException("Interrupted while sleeping", e);
+      }
+    }
+
+    @Override
+    public Status append(AvroFlumeEvent event) throws AvroRemoteException {
+      logger.debug("Received event:{}; delaying for {}ms", event, delay);
+      sleep();
+      return Status.OK;
+    }
 
+    @Override
+    public Status appendBatch(List<AvroFlumeEvent> events)
+        throws AvroRemoteException {
+      logger.debug("Received event batch:{}; delaying for {}ms", events, delay);
+      sleep();
       return Status.OK;
     }
 
