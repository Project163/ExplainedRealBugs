diff --git a/src/org/mockito/exceptions/Reporter.java b/src/org/mockito/exceptions/Reporter.java
index 7ae75886c..d57e33d27 100644
--- a/src/org/mockito/exceptions/Reporter.java
+++ b/src/org/mockito/exceptions/Reporter.java
@@ -22,6 +22,7 @@ import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.invocation.Location;
 import org.mockito.listeners.InvocationListener;
+import org.mockito.mock.MockName;
 import org.mockito.mock.SerializableMode;
 
 import java.lang.reflect.Field;
@@ -420,7 +421,7 @@ public class Reporter {
         throw new NoInteractionsWanted(join(
                 "No interactions wanted here:",
                 new LocationImpl(),
-                "But found this interaction on mock '" + undesired.getMock() + "':",
+                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
                 undesired.getLocation(),
                 scenario
         ));
@@ -430,7 +431,7 @@ public class Reporter {
         throw new VerificationInOrderFailure(join(
                 "No interactions wanted here:",
                 new LocationImpl(),
-                "But found this interaction on mock '" + undesired.getMock() + "':",
+                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
                 undesired.getLocation()
         ));
     }
@@ -664,14 +665,21 @@ public class Reporter {
 
     public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
         throw new MockitoException(join(
-                "Mockito couldn't inject mock dependency '" + new MockUtil().getMockName(matchingMock) + "' on field ",
+                "Mockito couldn't inject mock dependency '" + safelyGetMockName(matchingMock) + "' on field ",
                 "'" + field + "'",
                 "whose type '" + field.getDeclaringClass().getCanonicalName() + "' was annotated by @InjectMocks in your test.",
-                "Also I failed because: " + details.getCause().getMessage(),
+                "Also I failed because: " + exceptionCauseMessageIfAvailable(details),
                 ""
         ), details);
     }
 
+    private String exceptionCauseMessageIfAvailable(Exception details) {
+        if (details.getCause() == null) {
+            return details.getMessage();
+        }
+        return details.getCause().getMessage();
+    }
+
     public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
         throw new MockitoException(join(
                 "Mocked type must be the same as the type of your delegated instance.",
@@ -699,7 +707,7 @@ public class Reporter {
     public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {
         throw new MockitoException(
                 join("Invalid argument index for the current invocation of method : ",
-                        " -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
+                        " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
                         "",
                         (willReturnLastParameter ?
                                 "Last parameter wanted" :
@@ -732,7 +740,7 @@ public class Reporter {
         throw new WrongTypeOfReturnValue(join(
                 "The argument of type '" + actualType.getSimpleName() + "' cannot be returned because the following ",
                 "method should return the type '" + expectedType + "'",
-                " -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
+                " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
                 "",
                 "The reason for this error can be :",
                 "1. The wanted argument position is incorrect.",
@@ -765,11 +773,11 @@ public class Reporter {
                 ""
         ));
     }
-    
+
     public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
     	throw new MockitoException(join(
     	        "Methods called on delegated instance must have compatible return types with the mock.",
-    	        "When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
+    	        "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
     	        "return type should be: " + mockMethod.getReturnType().getSimpleName() + ", but was: " + delegateMethod.getReturnType().getSimpleName(),
     	        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
     	        "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
@@ -779,7 +787,7 @@ public class Reporter {
 	public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
 		throw new MockitoException(join(
     	        "Methods called on mock must exist in delegated instance.",
-    	        "When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
+    	        "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
     	        "no such method was found.",
     	        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
     	        "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
@@ -789,4 +797,8 @@ public class Reporter {
     public void usingConstructorWithFancySerializable(SerializableMode mode) {
         throw new MockitoException("Mocks instantiated with constructor cannot be combined with " + mode + " serialization mode.");
     }
+
+    private MockName safelyGetMockName(Object mock) {
+        return new MockUtil().getMockName(mock);
+    }
 }
diff --git a/test/org/mockito/exceptions/ReporterTest.java b/test/org/mockito/exceptions/ReporterTest.java
index e00685278..3253ad819 100644
--- a/test/org/mockito/exceptions/ReporterTest.java
+++ b/test/org/mockito/exceptions/ReporterTest.java
@@ -6,21 +6,81 @@
 package org.mockito.exceptions;
 
 import org.junit.Test;
+import org.mockito.Mockito;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.TooLittleActualInvocations;
+import org.mockito.exceptions.verification.VerificationInOrderFailure;
+import org.mockito.internal.exceptions.VerificationAwareInvocation;
 import org.mockito.internal.invocation.InvocationBuilder;
-import org.mockito.internal.reporting.*;
+import org.mockito.internal.stubbing.answers.Returns;
+import org.mockito.invocation.Invocation;
+import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
+import java.lang.reflect.Field;
+import java.util.Collections;
+
+import static org.mockito.Mockito.mock;
+
 public class ReporterTest extends TestBase {
 
-    @Test(expected=TooLittleActualInvocations.class)
-    public void shouldLetPassingNullLastActualStackTrace() throws Exception {
+    @Test(expected = TooLittleActualInvocations.class)
+    public void should_let_passing_null_last_actual_stack_trace() throws Exception {
         new Reporter().tooLittleActualInvocations(new org.mockito.internal.reporting.Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);
     }
-    
-    @Test(expected=MockitoException.class)
-    public void shouldThrowCorrectExceptionForNullInvocationListener() throws Exception {
-    	new Reporter().invocationListenerDoesNotAcceptNullParameters();
+
+    @Test(expected = MockitoException.class)
+    public void should_throw_correct_exception_for_null_invocation_listener() throws Exception {
+        new Reporter().invocationListenerDoesNotAcceptNullParameters();
+    }
+
+    @Test(expected = NoInteractionsWanted.class)
+    public void can_use_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted() throws Exception {
+        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
+        new Reporter().noMoreInteractionsWanted(invocation_with_bogus_default_answer, Collections.<VerificationAwareInvocation>emptyList());
+    }
+
+    @Test(expected = VerificationInOrderFailure.class)
+    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() throws Exception {
+        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
+        new Reporter().noMoreInteractionsWantedInOrder(invocation_with_bogus_default_answer);
+    }
+
+    @Test(expected = MockitoException.class)
+    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_invalid_argument_position() throws Exception {
+        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
+        new Reporter().invalidArgumentPositionRangeAtInvocationTime(invocation_with_bogus_default_answer, true, 0);
+    }
+
+    @Test(expected = MockitoException.class)
+    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_wrong_argument_to_return() throws Exception {
+        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
+        new Reporter().wrongTypeOfArgumentToReturn(invocation_with_bogus_default_answer, "", String.class, 0);
+    }
+
+    @Test(expected = MockitoException.class)
+    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_dont_exists() throws Exception {
+        Invocation dumb_invocation = new InvocationBuilder().toInvocation();
+        IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
+        new Reporter().delegatedMethodDoesNotExistOnDelegate(dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);
+    }
+
+    @Test(expected = MockitoException.class)
+    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_has_wrong_return_type() throws Exception {
+        Invocation dumb_invocation = new InvocationBuilder().toInvocation();
+        IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
+        new Reporter().delegatedMethodHasWrongReturnType(dumb_invocation.getMethod(), dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);
     }
+
+    @Test(expected = MockitoException.class)
+    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_injection_failure() throws Exception {
+        IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
+        new Reporter().cannotInjectDependency(someField(), mock_with_bogus_default_answer, new Exception());
+    }
+
+    private Field someField() {
+        return Mockito.class.getDeclaredFields()[0];
+    }
+
 }
diff --git a/test/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java b/test/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
new file mode 100644
index 000000000..e832567d7
--- /dev/null
+++ b/test/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
@@ -0,0 +1,26 @@
+package org.mockitousage.bugs;
+
+import org.junit.Test;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyZeroInteractions;
+
+public class ClassCastExOnVerifyZeroInteractionsTest {
+    public interface TestMock {
+        boolean m1();
+    }
+
+    @Test(expected = NoInteractionsWanted.class)
+    public void should_not_throw_a_ClassCastException() {
+        TestMock test = mock(TestMock.class, new Answer() {
+            public Object answer(InvocationOnMock invocation) throws Throwable {
+                return false;
+            }
+        });
+        test.m1();
+        verifyZeroInteractions(test);
+    }
+}
