diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 1d9dcba59..1490501ea 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -4,6 +4,11 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
+import static net.bytebuddy.matcher.ElementMatchers.isPrivate;
+import static net.bytebuddy.matcher.ElementMatchers.isStatic;
+import static net.bytebuddy.matcher.ElementMatchers.not;
+
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -38,6 +43,7 @@ import net.bytebuddy.jar.asm.Opcodes;
 import net.bytebuddy.jar.asm.Type;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.utility.OpenedClassReader;
+
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher;
@@ -51,8 +57,6 @@ import org.mockito.internal.util.concurrent.DetachedThreadLocal;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
 import org.mockito.plugins.MemberAccessor;
 
-import static net.bytebuddy.matcher.ElementMatchers.*;
-
 public class MockMethodAdvice extends MockMethodDispatcher {
 
     private final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
@@ -63,7 +67,7 @@ public class MockMethodAdvice extends MockMethodDispatcher {
     private final SelfCallInfo selfCallInfo = new SelfCallInfo();
     private final MethodGraph.Compiler compiler = MethodGraph.Compiler.Default.forJavaHierarchy();
     private final WeakConcurrentMap<Class<?>, SoftReference<MethodGraph>> graphs =
-            new WeakConcurrentMap.WithInlinedExpunction<Class<?>, SoftReference<MethodGraph>>();
+            new WeakConcurrentMap.WithInlinedExpunction<>();
 
     private final Predicate<Class<?>> isMockConstruction;
     private final ConstructionCallback onConstruction;
@@ -203,7 +207,7 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         MethodGraph methodGraph = reference == null ? null : reference.get();
         if (methodGraph == null) {
             methodGraph = compiler.compile(new TypeDescription.ForLoadedType(instance.getClass()));
-            graphs.put(instance.getClass(), new SoftReference<MethodGraph>(methodGraph));
+            graphs.put(instance.getClass(), new SoftReference<>(methodGraph));
         }
         MethodGraph.Node node =
                 methodGraph.locate(
@@ -234,7 +238,7 @@ public class MockMethodAdvice extends MockMethodDispatcher {
                 SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
             this.selfCallInfo = selfCallInfo;
             this.origin = origin;
-            this.instanceRef = new MockWeakReference<Object>(instance);
+            this.instanceRef = new MockWeakReference<>(instance);
             this.arguments = arguments;
         }
 
@@ -264,7 +268,7 @@ public class MockMethodAdvice extends MockMethodDispatcher {
                 String identifier, Method origin, Object instance, Object[] arguments) {
             this.origin = new SerializableMethod(origin);
             this.identifier = identifier;
-            this.instanceRef = new MockWeakReference<Object>(instance);
+            this.instanceRef = new MockWeakReference<>(instance);
             this.arguments = arguments;
         }
 
@@ -329,12 +333,21 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             return accessor.invoke(origin, instance, arguments);
         } catch (InvocationTargetException exception) {
             Throwable cause = exception.getCause();
+            StackTraceElement[] tmpStack = new Throwable().getStackTrace();
+
+            int skip = tmpStack.length;
+            // if there is a suitable instance, do not skip the root-cause for the exception
+            if (instance != null) {
+                skip = 0;
+                String causingClassName = instance.getClass().getName();
+                StackTraceElement stackFrame;
+                do {
+                    stackFrame = tmpStack[skip++];
+                } while (stackFrame.getClassName().startsWith(causingClassName));
+            }
+
             new ConditionalStackTraceFilter()
-                    .filter(
-                            hideRecursiveCall(
-                                    cause,
-                                    new Throwable().getStackTrace().length,
-                                    origin.getDeclaringClass()));
+                    .filter(hideRecursiveCall(cause, skip, origin.getDeclaringClass()));
             throw cause;
         }
     }
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
index dfa6d8192..ccd140a2d 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
@@ -9,9 +9,17 @@ import static net.bytebuddy.ClassFileVersion.JAVA_V8;
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assume.assumeTrue;
 
-import java.util.*;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Observable;
+import java.util.Observer;
+import java.util.Optional;
+import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.regex.Pattern;
 
@@ -23,6 +31,7 @@ import net.bytebuddy.implementation.FixedValue;
 import net.bytebuddy.implementation.StubMethod;
 import net.bytebuddy.utility.JavaConstant;
 import org.junit.Test;
+import org.mockito.Answers;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.creation.settings.CreationSettings;
@@ -234,6 +243,29 @@ public class InlineByteBuddyMockMakerTest
         assertThat(proxy.toString()).isEqualTo("foo");
     }
 
+    @Test
+    public void should_leave_causing_stack() throws Exception {
+        MockSettingsImpl<ExceptionThrowingClass> settings = new MockSettingsImpl<>();
+        settings.setTypeToMock(ExceptionThrowingClass.class);
+        settings.defaultAnswer(Answers.CALLS_REAL_METHODS);
+
+        Optional<ExceptionThrowingClass> proxy =
+                mockMaker.createSpy(
+                        settings, new MockHandlerImpl<>(settings), new ExceptionThrowingClass());
+
+        StackTraceElement[] returnedStack = null;
+        try {
+            proxy.get().throwException();
+        } catch (IOException ex) {
+            returnedStack = ex.getStackTrace();
+        }
+
+        assertNotNull("Stack trace from mockito expected", returnedStack);
+
+        assertEquals(ExceptionThrowingClass.class.getName(), returnedStack[0].getClassName());
+        assertEquals("internalThrowException", returnedStack[0].getMethodName());
+    }
+
     @Test
     public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
         StackTraceElement[] stack =
@@ -548,4 +580,27 @@ public class InlineByteBuddyMockMakerTest
     }
 
     public static class GenericSubClass extends GenericClass<String> {}
+
+    public static class ExceptionThrowingClass {
+        public IOException getException() {
+            try {
+                throwException();
+            } catch (IOException ex) {
+                return ex;
+            }
+            return null;
+        }
+
+        public void throwException() throws IOException {
+            internalThrowException(1);
+        }
+
+        void internalThrowException(int test) throws IOException {
+            // some lines of code, so the exception is not thrown in the first line of the method
+            int i = 0;
+            if (test != i) {
+                throw new IOException("fatal");
+            }
+        }
+    }
 }
