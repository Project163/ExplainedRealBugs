diff --git a/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java b/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
index 07c5a5e41..19922a7fa 100644
--- a/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
@@ -52,10 +52,31 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
     }
 
     public void addAnswer(Answer answer, Strictness stubbingStrictness) {
+        unmarkLastUsedStubIfNecessary();
+
         registeredInvocations.removeLast();
         addAnswer(answer, false, stubbingStrictness);
     }
 
+    /**
+     *  A stubbed call is marked as used when the method call is stubbed again, because the second
+     *  stub looks like an actual usage of the first stubbed call. When the second stub is set up,
+     *  the previous one is marked as unused again.
+     */
+    private void unmarkLastUsedStubIfNecessary() {
+        synchronized (stubbed) {
+            Invocation invocation = invocationForStubbing.getInvocation();
+
+            for (StubbedInvocationMatcher s : stubbed) {
+                if (s.matches(invocation)) {
+                    s.markStubUsed(null);
+                    invocation.markStubbed(null);
+                    return;
+                }
+            }
+        }
+    }
+
     public void addConsecutiveAnswer(Answer answer) {
         addAnswer(answer, true, null);
     }
diff --git a/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java b/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java
index e88c85b2d..0b1e4f4ba 100644
--- a/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java
+++ b/src/main/java/org/mockito/internal/stubbing/StubbedInvocationMatcher.java
@@ -43,6 +43,10 @@ public class StubbedInvocationMatcher extends InvocationMatcher implements Seria
         answers.add(answer);
     }
 
+    /**
+     * Marks the stub as used by the passed invocation. Passing null marks the stub as unused.
+     * @param usedAt The invocation which uses this stub
+     */
     public void markStubUsed(DescribedInvocation usedAt) {
         this.usedAt = usedAt;
     }
diff --git a/src/main/java/org/mockito/invocation/Invocation.java b/src/main/java/org/mockito/invocation/Invocation.java
index 04d14907f..ed25fd4c6 100644
--- a/src/main/java/org/mockito/invocation/Invocation.java
+++ b/src/main/java/org/mockito/invocation/Invocation.java
@@ -81,7 +81,8 @@ public interface Invocation extends InvocationOnMock, DescribedInvocation {
     StubInfo stubInfo();
 
     /**
-     * Marks this invocation as stubbed.
+     * Marks this invocation as stubbed. Passing null resets the invocation state back to not
+     * stubbed.
      *
      * @param stubInfo the information about stubbing.
      */
diff --git a/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java b/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java
index 2abbb4f90..555c65326 100644
--- a/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StrictStubbingEndToEndTest.java
@@ -4,7 +4,10 @@
  */
 package org.mockitousage.stubbing;
 
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.willReturn;
 import static org.mockitoutil.ConcurrentTesting.concurrently;
 import static org.mockitoutil.JUnitResultAssert.assertThat;
 
@@ -42,6 +45,42 @@ public class StrictStubbingEndToEndTest {
                 .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
     }
 
+    @Test public void unnecessary_stubbing_with_eq_implicit_matchers() {
+        Result result = junit.run(UnnecessaryStubbingWithImplicitEqMatchers.class);
+        assertThat(result)
+            .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
+    }
+
+    @Test public void unnecessary_stubbing_with_eq_implicit_matchers_trailing_when_style() {
+        Result result = junit.run(UnnecessaryStubbingWithImplicitEqMatchersTrailingWhenStyle.class);
+        assertThat(result)
+            .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
+    }
+
+    @Test public void unnecessary_stubbing_any_matchers() {
+        Result result = junit.run(UnnecessaryStubbingAnyMatchers.class);
+        assertThat(result)
+            .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
+    }
+
+    @Test public void unnecessary_stubbing_mixed_matchers() {
+        Result result = junit.run(UnnecessaryStubbingMixedMatchers.class);
+        assertThat(result)
+            .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
+    }
+
+    @Test public void unnecessary_stubbing_mixed_matchers_stubs_only() {
+        Result result = junit.run(UnnecessaryStubbingMixedMatchersStubsOnly.class);
+        assertThat(result)
+            .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
+    }
+
+    @Test public void unnecessary_stubbing_mixed_matchers_trailing_when_style() {
+        Result result = junit.run(UnnecessaryStubbingMixedMatchersTrailingWhenStyle.class);
+        assertThat(result)
+            .fails("unnecessary_stubbing", UnnecessaryStubbingException.class);
+    }
+
     @Test public void does_not_report_unused_stubbing_if_mismatch_reported() {
         Result result = junit.run(ReportMismatchButNotUnusedStubbing.class);
         assertThat(result).fails(1, PotentialStubbingProblem.class);
@@ -93,6 +132,106 @@ public class StrictStubbingEndToEndTest {
         }
     }
 
+    public static class UnnecessaryStubbingWithImplicitEqMatchers {
+        @Mock IMethods mock;
+        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+
+        @After public void after() {
+            mockito.finishMocking();
+        }
+
+        @Test public void unnecessary_stubbing() {
+            given(mock.simpleMethod("1")).willReturn("one");
+            given(mock.simpleMethod("2")).willReturn("three");
+            given(mock.simpleMethod("1")).willReturn("two");
+            given(mock.simpleMethod("1")).willReturn("four");
+
+            mock.simpleMethod("1");
+            mock.simpleMethod("2");
+        }
+    }
+
+    public static class UnnecessaryStubbingWithImplicitEqMatchersTrailingWhenStyle {
+        @Mock IMethods mock;
+        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+
+        @After public void after() {
+            mockito.finishMocking();
+        }
+
+        @Test public void unnecessary_stubbing() {
+            willReturn("one").given(mock).simpleMethod("1");
+            willReturn("three").given(mock).simpleMethod("2");
+            willReturn("two").given(mock).simpleMethod("1");
+            willReturn("four").given(mock).simpleMethod("1");
+
+            mock.simpleMethod("1");
+            mock.simpleMethod("2");
+        }
+    }
+
+    public static class UnnecessaryStubbingAnyMatchers {
+        @Mock IMethods mock;
+        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+
+        @After public void after() {
+            mockito.finishMocking();
+        }
+
+        @Test public void unnecessary_stubbing() {
+            given(mock.simpleMethod((String) any())).willReturn("one");
+            given(mock.simpleMethod(anyString())).willReturn("three");
+
+            mock.simpleMethod("1");
+        }
+    }
+
+    public static class UnnecessaryStubbingMixedMatchers {
+        @Mock IMethods mock;
+        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+
+        @After public void after() {
+            mockito.finishMocking();
+        }
+
+        @Test public void unnecessary_stubbing() {
+            given(mock.simpleMethod(anyString())).willReturn("one");
+            given(mock.simpleMethod("foo")).willReturn("three");
+
+            mock.simpleMethod("1");
+        }
+    }
+
+    public static class UnnecessaryStubbingMixedMatchersStubsOnly {
+        @Mock IMethods mock;
+        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+
+        @After public void after() {
+            mockito.finishMocking();
+        }
+
+        @Test public void unnecessary_stubbing() {
+            given(mock.simpleMethod(anyString())).willReturn("one");
+            given(mock.simpleMethod("foo")).willReturn("three");
+        }
+    }
+
+    public static class UnnecessaryStubbingMixedMatchersTrailingWhenStyle {
+        @Mock IMethods mock;
+        MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
+
+        @After public void after() {
+            mockito.finishMocking();
+        }
+
+        @Test public void unnecessary_stubbing() {
+            willReturn("one").given(mock).simpleMethod(anyString());
+            willReturn("three").given(mock).simpleMethod("foo");
+
+            mock.simpleMethod("1");
+        }
+    }
+
     public static class ReportMismatchButNotUnusedStubbing {
         @Mock IMethods mock;
         MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();
