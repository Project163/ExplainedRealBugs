diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java b/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java
index 3087fc3b0..608460a57 100644
--- a/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java
+++ b/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java
@@ -4,36 +4,58 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
 import java.io.Serializable;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
 /**
  * Internal answer to forward invocations on a real instance.
  *
  * @since 1.9.5
  */
 public class ForwardsInvocations implements Answer<Object>, Serializable {
+    private static final long serialVersionUID = -8343690268123254910L;
 
-	private static final long serialVersionUID = -8343690268123254910L;
-
-	private Object delegatedObject = null ;
+    private Object delegatedObject = null ;
 
-	public ForwardsInvocations(Object delegatedObject) {
-		this.delegatedObject = delegatedObject ;
-	}
+    public ForwardsInvocations(Object delegatedObject) {
+        this.delegatedObject = delegatedObject ;
+    }
 
-	public Object answer(InvocationOnMock invocation) throws Throwable {
-		Method method = invocation.getMethod() ;
+    public Object answer(InvocationOnMock invocation) throws Throwable {
+        Method mockMethod = invocation.getMethod();
 
         try {
-            return method.invoke(delegatedObject, invocation.getArguments());
+            Method delegateMethod = getDelegateMethod(mockMethod);
+            
+            if (!compatibleReturnTypes(mockMethod.getReturnType(), delegateMethod.getReturnType())) {
+                throw new MockitoException("Incompatible return type on delegate method: " + delegateMethod);
+            }
+            
+            return delegateMethod.invoke(delegatedObject, invocation.getArguments());
+        } catch (NoSuchMethodException e) {
+            throw new MockitoException("Method not found on delegate: " + mockMethod, e);
         } catch (InvocationTargetException e) {
             // propagate the original exception from the delegate
             throw e.getCause();
         }
     }
-}
\ No newline at end of file
+
+    private Method getDelegateMethod(Method mockMethod) throws NoSuchMethodException {
+        if (mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {
+            // Compatible class. Return original method.
+            return mockMethod;
+        } else {
+            // Return method of delegate object with the same signature as mockMethod.
+            return delegatedObject.getClass().getMethod(mockMethod.getName(), mockMethod.getParameterTypes());
+        }
+    }
+
+    private static boolean compatibleReturnTypes(Class<?> superType, Class<?> subType) {
+        return superType.equals(subType) || superType.isAssignableFrom(subType);
+    }
+}
diff --git a/test/org/mockitousage/stubbing/StubbingWithDelegate.java b/test/org/mockitousage/stubbing/StubbingWithDelegate.java
index 1031c2dde..4561d4b31 100644
--- a/test/org/mockitousage/stubbing/StubbingWithDelegate.java
+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java
@@ -6,10 +6,12 @@ package org.mockitousage.stubbing;
 
 import org.junit.Test;
 import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockitousage.IMethods;
 import org.mockitousage.MethodsImpl;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import static junit.framework.Assert.assertEquals;
@@ -22,7 +24,38 @@ import static org.mockito.Mockito.withSettings;
 
 @SuppressWarnings("unchecked")
 public class StubbingWithDelegate {
-
+   public class FakeList<T> {
+        private T value;
+        
+        public T get(int i) {
+            return value;
+        }
+        
+        public T set(int i, T value) {
+            T oldValue = value;
+            this.value = value;
+            return oldValue;
+        }
+        
+        public int size() {
+            return 10;
+        }
+        
+        public ArrayList<T> subList(int fromIndex, int toIndex) {
+            return new ArrayList<>();
+        }
+    }
+    
+    public class FakeListWithWrongMethods<T> {
+        public double size() {
+            return 10;
+        }
+        
+        public Collection<T> subList(int fromIndex, int toIndex) {
+            return new ArrayList<>();
+        }
+    }
+	
 	@Test
 	public void when_not_stubbed_delegate_should_be_called() {
 		List<String> delegatedList = new ArrayList<String>();
@@ -74,6 +107,58 @@ public class StubbingWithDelegate {
             assertThat(e.toString()).doesNotContain("org.mockito");
         }
     }
+    
+    @Test
+    public void instance_of_different_class_can_be_called() {
+        List<String> mock = mock(List.class, delegatesTo(new FakeList<>()));
+        
+        mock.set(1, "1");
+        assertThat(mock.get(1).equals("1"));
+    }
+    
+    @Test
+    public void method_with_subtype_return_can_be_called() {
+        List<String> mock = mock(List.class, delegatesTo(new FakeList<>()));
+        
+        List<String> subList = mock.subList(0, 0);
+        assertThat(subList.isEmpty());
+    }
+    
+    @Test
+    public void calling_missing_method_should_throw_exception() {
+        List<String> mock = mock(List.class, delegatesTo(new FakeList<>()));
+        
+        try {
+            mock.isEmpty();
+            fail();
+        } catch (MockitoException e) {
+            assertThat(e.toString()).contains("Method not found on delegate");
+        }
+    }
+    
+    @Test
+    public void calling_method_with_wrong_primitive_return_should_throw_exception() {
+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<>()));
+        
+        try {
+            mock.size();
+            fail();
+        } catch (MockitoException e) {
+            assertThat(e.toString()).contains("Incompatible return type on delegate method");
+        }
+    }
+    
+    @Test
+    public void calling_method_with_wrong_reference_return_should_throw_exception() {
+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<>()));
+        
+        try {
+            mock.subList(0, 0);
+            fail();
+        } catch (MockitoException e) {
+            assertThat(e.toString()).contains("Incompatible return type on delegate method");
+        }
+	}
 
     @Test
     public void exception_should_be_propagated_from_delegate() throws Exception {
