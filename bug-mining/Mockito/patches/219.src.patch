diff --git a/src/main/java/org/mockito/internal/exceptions/Reporter.java b/src/main/java/org/mockito/internal/exceptions/Reporter.java
index 0a182178d..5b344837b 100644
--- a/src/main/java/org/mockito/internal/exceptions/Reporter.java
+++ b/src/main/java/org/mockito/internal/exceptions/Reporter.java
@@ -10,9 +10,7 @@ import static org.mockito.internal.util.StringUtil.join;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
+import java.util.*;
 
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.exceptions.base.MockitoException;
@@ -408,14 +406,15 @@ public class Reporter {
     }
 
     public static MockitoAssertionError neverWantedButInvoked(
-            DescribedInvocation wanted, List<Location> invocations) {
+            DescribedInvocation wanted, List<Invocation> invocations) {
+
         return new NeverWantedButInvoked(
                 join(
                         wanted.toString(),
                         "Never wanted here:",
                         new LocationImpl(),
                         "But invoked here:",
-                        createAllLocationsMessage(invocations)));
+                        createAllLocationsArgsMessage(invocations)));
     }
 
     public static MockitoAssertionError tooManyActualInvocationsInOrder(
@@ -439,6 +438,21 @@ public class Reporter {
         return sb.toString();
     }
 
+    private static String createAllLocationsArgsMessage(List<Invocation> invocations) {
+        StringBuilder sb = new StringBuilder();
+        for (Invocation invocation : invocations) {
+            Location location = invocation.getLocation();
+            if (location == null) {
+                continue;
+            }
+            sb.append(location)
+                    .append(" with arguments: ")
+                    .append(Arrays.toString(invocation.getArguments()))
+                    .append("\n");
+        }
+        return sb.toString();
+    }
+
     private static String createTooFewInvocationsMessage(
             org.mockito.internal.reporting.Discrepancy discrepancy,
             DescribedInvocation wanted,
diff --git a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
index 460710cc9..78a276ef2 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java
@@ -40,7 +40,7 @@ public class NumberOfInvocationsChecker {
                     new Discrepancy(wantedCount, actualCount), wanted, allLocations);
         }
         if (wantedCount == 0 && actualCount > 0) {
-            throw neverWantedButInvoked(wanted, getAllLocations(actualInvocations));
+            throw neverWantedButInvoked(wanted, actualInvocations);
         }
         if (wantedCount < actualCount) {
             throw tooManyActualInvocations(
diff --git a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
index b92bb4dd1..d1878fc2e 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java
@@ -9,6 +9,7 @@ import static java.util.Collections.emptyList;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.util.Collections;
 import java.util.List;
 
 import org.hamcrest.BaseMatcher;
@@ -116,16 +117,33 @@ public class NumberOfInvocationsCheckerTest {
     }
 
     @Test
-    public void shouldReportNeverWantedButInvoked() throws Exception {
-        Invocation first = buildSimpleMethod().toInvocation();
+    public void shouldReportNeverWantedButInvokedWithArgs() throws Exception {
+        Invocation invocation = buildSimpleMethodWithArgs("arg1").toInvocation();
 
-        invocations = asList(first);
-        wanted = buildSimpleMethod().toInvocationMatcher();
+        invocations = Collections.singletonList(invocation);
+        wanted = buildSimpleMethodWithArgs("arg1").toInvocationMatcher();
 
         exception.expect(NeverWantedButInvoked.class);
         exception.expectMessage("Never wanted here");
         exception.expectMessage("But invoked here");
-        exception.expectMessage("" + first.getLocation());
+        exception.expectMessage("" + invocation.getLocation() + " with arguments: [arg1]");
+
+        NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
+    }
+
+    @Test
+    public void shouldReportNeverWantedButInvokedWithArgs_multipleInvocations() throws Exception {
+        Invocation first = buildSimpleMethodWithArgs("arg1").toInvocation();
+        Invocation second = buildSimpleMethodWithArgs("arg1").toInvocation();
+
+        invocations = asList(first, second);
+        wanted = buildSimpleMethodWithArgs("arg1").toInvocationMatcher();
+
+        exception.expect(NeverWantedButInvoked.class);
+        exception.expectMessage("Never wanted here");
+        exception.expectMessage("But invoked here");
+        exception.expectMessage("" + first.getLocation() + " with arguments: [arg1]");
+        exception.expectMessage("" + second.getLocation() + " with arguments: [arg1]");
 
         NumberOfInvocationsChecker.checkNumberOfInvocations(invocations, wanted, 0);
     }
@@ -145,6 +163,14 @@ public class NumberOfInvocationsCheckerTest {
         return new InvocationBuilder().mock(mock).simpleMethod();
     }
 
+    private InvocationBuilder buildSimpleMethodWithArgs(String arg) {
+        return new InvocationBuilder().mock(mock).simpleMethod().args(arg);
+    }
+
+    private InvocationBuilder buildDifferentMethodWithArgs(String arg) {
+        return new InvocationBuilder().mock(mock).differentMethod().args(arg);
+    }
+
     private static BaseMatcher<String> containsTimes(String value, int amount) {
         return new StringContainsNumberMatcher(value, amount);
     }
