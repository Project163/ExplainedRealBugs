diff --git a/src/main/java/org/mockito/MockSettings.java b/src/main/java/org/mockito/MockSettings.java
index 6958bcb34..e9c75c3a1 100644
--- a/src/main/java/org/mockito/MockSettings.java
+++ b/src/main/java/org/mockito/MockSettings.java
@@ -5,6 +5,7 @@
 package org.mockito;
 
 import java.io.Serializable;
+import java.lang.reflect.Type;
 
 import org.mockito.exceptions.misusing.PotentialStubbingProblem;
 import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
@@ -403,4 +404,11 @@ public interface MockSettings extends Serializable {
      * @since 4.8.0
      */
     MockSettings mockMaker(String mockMaker);
+
+    /**
+     * Specifies the generic type of the mock, preserving the information lost to Java type erasure.
+     * @param genericTypeToMock
+     * @return
+     */
+    MockSettings genericTypeToMock(Type genericTypeToMock);
 }
diff --git a/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java b/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java
index 95356f5c9..fed851dbe 100644
--- a/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java
+++ b/src/main/java/org/mockito/internal/configuration/MockAnnotationProcessor.java
@@ -57,6 +57,8 @@ public class MockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {
             mockSettings.mockMaker(annotation.mockMaker());
         }
 
+        mockSettings.genericTypeToMock(genericType.get());
+
         // see @Mock answer default value
         mockSettings.defaultAnswer(annotation.answer());
 
diff --git a/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java b/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java
index fa9af798f..cd5194258 100644
--- a/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java
+++ b/src/main/java/org/mockito/internal/configuration/SpyAnnotationEngine.java
@@ -87,6 +87,7 @@ public class SpyAnnotationEngine implements AnnotationEngine {
         return Mockito.mock(
                 instance.getClass(),
                 withSettings()
+                        .genericTypeToMock(field.getGenericType())
                         .spiedInstance(instance)
                         .defaultAnswer(CALLS_REAL_METHODS)
                         .name(field.getName()));
@@ -96,7 +97,10 @@ public class SpyAnnotationEngine implements AnnotationEngine {
             throws InstantiationException, IllegalAccessException, InvocationTargetException {
         // TODO: Add mockMaker option for @Spy annotation (#2740)
         MockSettings settings =
-                withSettings().defaultAnswer(CALLS_REAL_METHODS).name(field.getName());
+                withSettings()
+                        .genericTypeToMock(field.getGenericType())
+                        .defaultAnswer(CALLS_REAL_METHODS)
+                        .name(field.getName());
         Class<?> type = field.getType();
         if (type.isInterface()) {
             return Mockito.mock(type, settings.useConstructor());
diff --git a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
index 7f267d2c5..ed32c8eea 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
@@ -81,6 +81,7 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
                     injectMockCandidates(
                             fieldClass,
                             fieldInstanceNeedingInjection,
+                            injectMocksField,
                             newMockSafeHashSet(mockCandidates));
             fieldClass = fieldClass.getSuperclass();
         }
@@ -100,24 +101,32 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
     }
 
     private boolean injectMockCandidates(
-            Class<?> awaitingInjectionClazz, Object injectee, Set<Object> mocks) {
+            Class<?> awaitingInjectionClazz,
+            Object injectee,
+            Field injectMocksField,
+            Set<Object> mocks) {
         boolean injectionOccurred;
         List<Field> orderedCandidateInjecteeFields =
                 orderedInstanceFieldsFrom(awaitingInjectionClazz);
         // pass 1
         injectionOccurred =
                 injectMockCandidatesOnFields(
-                        mocks, injectee, false, orderedCandidateInjecteeFields);
+                        mocks, injectee, injectMocksField, false, orderedCandidateInjecteeFields);
         // pass 2
         injectionOccurred |=
                 injectMockCandidatesOnFields(
-                        mocks, injectee, injectionOccurred, orderedCandidateInjecteeFields);
+                        mocks,
+                        injectee,
+                        injectMocksField,
+                        injectionOccurred,
+                        orderedCandidateInjecteeFields);
         return injectionOccurred;
     }
 
     private boolean injectMockCandidatesOnFields(
             Set<Object> mocks,
             Object injectee,
+            Field injectMocksField,
             boolean injectionOccurred,
             List<Field> orderedCandidateInjecteeFields) {
         for (Iterator<Field> it = orderedCandidateInjecteeFields.iterator(); it.hasNext(); ) {
@@ -125,7 +134,11 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
             Object injected =
                     mockCandidateFilter
                             .filterCandidate(
-                                    mocks, candidateField, orderedCandidateInjecteeFields, injectee)
+                                    mocks,
+                                    candidateField,
+                                    orderedCandidateInjecteeFields,
+                                    injectee,
+                                    injectMocksField)
                             .thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
index 470a42ff1..82c913695 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
@@ -13,5 +13,6 @@ public interface MockCandidateFilter {
             Collection<Object> mocks,
             Field candidateFieldToBeInjected,
             List<Field> allRemainingCandidateFields,
-            Object injectee);
+            Object injectee,
+            Field injectMocksField);
 }
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
index 125b9595e..b2cc6c75d 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
@@ -23,7 +23,8 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {
             final Collection<Object> mocks,
             final Field candidateFieldToBeInjected,
             final List<Field> allRemainingCandidateFields,
-            final Object injectee) {
+            final Object injectee,
+            final Field injectMocksField) {
         if (mocks.size() == 1
                 && anotherCandidateMatchesMockName(
                         mocks, candidateFieldToBeInjected, allRemainingCandidateFields)) {
@@ -34,7 +35,8 @@ public class NameBasedCandidateFilter implements MockCandidateFilter {
                 tooMany(mocks) ? selectMatchingName(mocks, candidateFieldToBeInjected) : mocks,
                 candidateFieldToBeInjected,
                 allRemainingCandidateFields,
-                injectee);
+                injectee,
+                injectMocksField);
     }
 
     private boolean tooMany(Collection<Object> mocks) {
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java
index ec9dadcfa..5726ee201 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/TerminalMockCandidateFilter.java
@@ -28,7 +28,8 @@ public class TerminalMockCandidateFilter implements MockCandidateFilter {
             final Collection<Object> mocks,
             final Field candidateFieldToBeInjected,
             final List<Field> allRemainingCandidateFields,
-            final Object injectee) {
+            final Object injectee,
+            final Field injectMocksField) {
         if (mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 
diff --git a/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java b/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
index 9ba0fba98..0c40478da 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
@@ -5,10 +5,17 @@
 package org.mockito.internal.configuration.injection.filter;
 
 import java.lang.reflect.Field;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
+import org.mockito.internal.util.MockUtil;
+
 public class TypeBasedCandidateFilter implements MockCandidateFilter {
 
     private final MockCandidateFilter next;
@@ -17,20 +24,123 @@ public class TypeBasedCandidateFilter implements MockCandidateFilter {
         this.next = next;
     }
 
+    protected boolean isCompatibleTypes(Type typeToMock, Type mockType, Field injectMocksField) {
+        boolean result = false;
+        if (typeToMock instanceof ParameterizedType && mockType instanceof ParameterizedType) {
+            // ParameterizedType.equals() is documented as:
+            // "Instances of classes that implement this interface must implement
+            // an equals() method that equates any two instances that share the
+            // same generic type declaration and have equal type parameters."
+            // Unfortunately, e.g. Wildcard parameter "?" doesn't equal java.lang.String,
+            // and e.g. Set doesn't equal TreeSet, so roll our own comparison if
+            // ParameterizedTypeImpl.equals() returns false
+            if (typeToMock.equals(mockType)) {
+                result = true;
+            } else {
+                ParameterizedType genericTypeToMock = (ParameterizedType) typeToMock;
+                ParameterizedType genericMockType = (ParameterizedType) mockType;
+                Type[] actualTypeArguments = genericTypeToMock.getActualTypeArguments();
+                Type[] actualTypeArguments2 = genericMockType.getActualTypeArguments();
+                // Recurse on type parameters, so we properly test whether e.g. Wildcard bounds
+                // have a match
+                result =
+                        recurseOnTypeArguments(
+                                injectMocksField, actualTypeArguments, actualTypeArguments2);
+            }
+        } else if (typeToMock instanceof WildcardType) {
+            WildcardType wildcardTypeToMock = (WildcardType) typeToMock;
+            Type[] upperBounds = wildcardTypeToMock.getUpperBounds();
+            result =
+                    Arrays.stream(upperBounds)
+                            .anyMatch(t -> isCompatibleTypes(t, mockType, injectMocksField));
+        } else if (typeToMock instanceof Class && mockType instanceof Class) {
+            result = ((Class) typeToMock).isAssignableFrom((Class) mockType);
+        } // no need to check for GenericArrayType, as Mockito cannot mock this anyway
+
+        return result;
+    }
+
+    private boolean recurseOnTypeArguments(
+            Field injectMocksField, Type[] actualTypeArguments, Type[] actualTypeArguments2) {
+        boolean isCompatible = true;
+        for (int i = 0; i < actualTypeArguments.length; i++) {
+            Type actualTypeArgument = actualTypeArguments[i];
+            Type actualTypeArgument2 = actualTypeArguments2[i];
+            if (actualTypeArgument instanceof TypeVariable) {
+                TypeVariable<?> typeVariable = (TypeVariable<?>) actualTypeArgument;
+                // this is a TypeVariable declared by the class under test that turned
+                // up in one of its fields,
+                // e.g. class ClassUnderTest<T1, T2> { List<T1> tList; Set<T2> tSet}
+                // The TypeVariable`s actual type is declared by the field containing
+                // the object under test, i.e. the field annotated with @InjectMocks
+                // e.g. @InjectMocks ClassUnderTest<String, Integer> underTest = ..
+                Type[] injectMocksFieldTypeParameters =
+                        ((ParameterizedType) injectMocksField.getGenericType())
+                                .getActualTypeArguments();
+                // Find index of given TypeVariable where it was defined, e.g. 0 for T1 in
+                // ClassUnderTest<T1, T2>
+                // (we're always able to find it, otherwise test class wouldn't have compiled))
+                TypeVariable<?>[] genericTypeParameters =
+                        injectMocksField.getType().getTypeParameters();
+                int variableIndex = -1;
+                for (int i2 = 0; i2 < genericTypeParameters.length; i2++) {
+                    if (genericTypeParameters[i2].equals(typeVariable)) {
+                        variableIndex = i2;
+                        break;
+                    }
+                }
+                // now test whether actual type for the type variable is compatible, e.g. for
+                //   class ClassUnderTest<T1, T2> {..}
+                // T1 would be the String in
+                //   ClassUnderTest<String, Integer> underTest = ..
+                isCompatible &=
+                        isCompatibleTypes(
+                                injectMocksFieldTypeParameters[variableIndex],
+                                actualTypeArgument2,
+                                injectMocksField);
+            } else {
+                isCompatible &=
+                        isCompatibleTypes(
+                                actualTypeArgument, actualTypeArgument2, injectMocksField);
+            }
+        }
+        return isCompatible;
+    }
+
     @Override
     public OngoingInjector filterCandidate(
             final Collection<Object> mocks,
             final Field candidateFieldToBeInjected,
             final List<Field> allRemainingCandidateFields,
-            final Object injectee) {
+            final Object injectee,
+            final Field injectMocksField) {
         List<Object> mockTypeMatches = new ArrayList<>();
         for (Object mock : mocks) {
             if (candidateFieldToBeInjected.getType().isAssignableFrom(mock.getClass())) {
-                mockTypeMatches.add(mock);
-            }
+                Type genericMockType = MockUtil.getMockSettings(mock).getGenericTypeToMock();
+                Type genericType = candidateFieldToBeInjected.getGenericType();
+                boolean bothHaveGenericTypeInfo = genericType != null && genericMockType != null;
+                if (bothHaveGenericTypeInfo) {
+                    // be more specific if generic type information is available
+                    if (isCompatibleTypes(genericType, genericMockType, injectMocksField)) {
+                        mockTypeMatches.add(mock);
+                    } // else filter out mock, as generic types don't match
+                } else {
+                    // field is assignable from mock class, but no generic type information
+                    // is available (can happen with programmatically created Mocks where no
+                    // genericTypeToMock was supplied)
+                    mockTypeMatches.add(mock);
+                }
+            } // else filter out mock
+            // BTW mocks may contain Spy objects with their original class (seemingly before
+            // being wrapped), and MockUtil.getMockSettings() throws exception for those
         }
 
         return next.filterCandidate(
-                mockTypeMatches, candidateFieldToBeInjected, allRemainingCandidateFields, injectee);
+                mockTypeMatches,
+                candidateFieldToBeInjected,
+                allRemainingCandidateFields,
+                injectee,
+                injectMocksField);
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
index a25299722..7bef7764d 100644
--- a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
+++ b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
@@ -16,6 +16,7 @@ import static org.mockito.internal.exceptions.Reporter.strictnessDoesNotAcceptNu
 import static org.mockito.internal.util.collections.Sets.newSet;
 
 import java.io.Serializable;
+import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -260,6 +261,12 @@ public class MockSettingsImpl<T> extends CreationSettings<T>
         return this;
     }
 
+    @Override
+    public MockSettings genericTypeToMock(Type genericType) {
+        this.genericTypeToMock = genericType;
+        return this;
+    }
+
     private static <T> CreationSettings<T> validatedSettings(
             Class<T> typeToMock, CreationSettings<T> source) {
         MockCreationValidator validator = new MockCreationValidator();
diff --git a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
index 4b5078183..9114bcb8c 100644
--- a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
+++ b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
@@ -5,6 +5,7 @@
 package org.mockito.internal.creation.settings;
 
 import java.io.Serializable;
+import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
@@ -25,6 +26,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
     private static final long serialVersionUID = -6789800638070123629L;
 
     protected Class<T> typeToMock;
+    protected Type genericTypeToMock;
     protected Set<Class<?>> extraInterfaces = new LinkedHashSet<>();
     protected String name;
     protected Object spiedInstance;
@@ -54,6 +56,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
     public CreationSettings(CreationSettings copy) {
         // TODO can we have a reflection test here? We had a couple of bugs here in the past.
         this.typeToMock = copy.typeToMock;
+        this.genericTypeToMock = copy.genericTypeToMock;
         this.extraInterfaces = copy.extraInterfaces;
         this.name = copy.name;
         this.spiedInstance = copy.spiedInstance;
@@ -82,6 +85,11 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         return this;
     }
 
+    public CreationSettings<T> setGenericTypeToMock(Type genericTypeToMock) {
+        this.genericTypeToMock = genericTypeToMock;
+        return this;
+    }
+
     @Override
     public Set<Class<?>> getExtraInterfaces() {
         return extraInterfaces;
@@ -185,4 +193,9 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
     public String getMockMaker() {
         return mockMaker;
     }
+
+    @Override
+    public Type getGenericTypeToMock() {
+        return genericTypeToMock;
+    }
 }
diff --git a/src/main/java/org/mockito/mock/MockCreationSettings.java b/src/main/java/org/mockito/mock/MockCreationSettings.java
index 94c74558e..949af03b2 100644
--- a/src/main/java/org/mockito/mock/MockCreationSettings.java
+++ b/src/main/java/org/mockito/mock/MockCreationSettings.java
@@ -4,6 +4,7 @@
  */
 package org.mockito.mock;
 
+import java.lang.reflect.Type;
 import java.util.List;
 import java.util.Set;
 
@@ -27,6 +28,11 @@ public interface MockCreationSettings<T> {
      */
     Class<T> getTypeToMock();
 
+    /**
+     * The generic type of the mock, if any.
+     */
+    Type getGenericTypeToMock();
+
     /**
      * the extra interfaces the mock object should implement.
      */
diff --git a/subprojects/junit-jupiter/src/test/java/org/mockitousage/GenericTypeMockTest.java b/subprojects/junit-jupiter/src/test/java/org/mockitousage/GenericTypeMockTest.java
new file mode 100644
index 000000000..cfece7cb8
--- /dev/null
+++ b/subprojects/junit-jupiter/src/test/java/org/mockitousage/GenericTypeMockTest.java
@@ -0,0 +1,289 @@
+/*
+ * Copyright (c) 2023 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockitousage;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.sql.Time;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
+
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.mockito.InjectMocks;
+import org.mockito.Mock;
+import org.mockito.junit.jupiter.MockitoExtension;
+
+/**
+ * Tests that verify Mockito can discern mocks by generic types, so if there are multiple mock candidates
+ * with the same generic type but different type parameters available for injection into a given field,
+ * Mockito won't fail to inject (even if mock field name doesn't match under test's field name).
+ */
+@ExtendWith(MockitoExtension.class)
+public class GenericTypeMockTest {
+
+
+    @Nested
+    public class SingleTypeParamTest {
+        public class UnderTestWithSingleTypeParam {
+            List<String> stringList;
+            List<Integer> intList;
+        }
+
+        @Mock
+        private List<String> stringListMock;
+
+        @Mock
+        private List<Integer> intListMock;
+
+        // must construct non-static inner class ourselves here
+        // (making it public static classes doesn't work either)
+        @InjectMocks
+        private UnderTestWithSingleTypeParam underTestWithSingleTypeParam = new UnderTestWithSingleTypeParam();
+
+        @Test
+        void testSingleTypeParam() {
+            // testing for not null first before testing for equals,
+            // because assertEquals(null, null) == true,
+            // so test would succeed if both @Mock and @InjectMocks
+            // don't work at all
+            assertNotNull(stringListMock);
+            assertNotNull(intListMock);
+
+            assertEquals(stringListMock, underTestWithSingleTypeParam.stringList);
+            assertEquals(intListMock, underTestWithSingleTypeParam.intList);
+        }
+    }
+
+    @Nested
+    public class WildcardTest {
+        class UnderTestWithWildcard {
+            Set<? extends Date> dateSet;
+            Set<? extends Number> numberSet;
+        }
+
+        @Mock
+        Set<Time> timeSetMock; // java.sql.Time extends Date
+
+        @Mock
+        Set<Integer> integerSetMock;
+
+        @InjectMocks
+        UnderTestWithWildcard underTestWithWildcard = new UnderTestWithWildcard();
+
+        @Test
+        void testWildcard() {
+            assertNotNull(timeSetMock);
+            assertNotNull(integerSetMock);
+
+            // this also tests whether WildcardType.upperBounds() is evaluated,
+            // i.e. that we match <? extends Date> to <Time> type parameter
+            assertEquals(timeSetMock, underTestWithWildcard.dateSet);
+            assertEquals(integerSetMock, underTestWithWildcard.numberSet);
+        }
+    }
+
+
+    @Nested
+    public class NestedTypeParametersTest {
+        public class UnderTestWithNestedTypeParameters {
+            Map<Integer, Collection<String>> intToStringCollectionMap;
+            Map<Integer, Collection<Integer>> intoToIntCollectionMap;
+        }
+
+        @Mock
+        Map<Integer, Collection<String>> intToStringCollectionMapMock;
+
+        @Mock
+        Map<Integer, Collection<Integer>> intToIntCollectionMapMock;
+
+        @InjectMocks
+        UnderTestWithNestedTypeParameters underTestWithNestedTypeParameters = new UnderTestWithNestedTypeParameters();
+
+        @Test
+        void testNestedTypeParameters() {
+            assertNotNull(intToStringCollectionMapMock);
+            assertNotNull(intToIntCollectionMapMock);
+
+            assertEquals(intToStringCollectionMapMock, underTestWithNestedTypeParameters.intToStringCollectionMap);
+            assertEquals(intToIntCollectionMapMock, underTestWithNestedTypeParameters.intoToIntCollectionMap);
+        }
+    }
+
+    @Nested
+    public class GenericSubclassTest {
+        public class UnderTestWithGenericSubclass {
+            Set<String> stringSet;
+            Set<Integer> intSet;
+        }
+
+        @Mock
+        TreeSet<String> stringTreeSetMock;
+
+        @Mock
+        HashSet<Integer> intHashSetMock;
+
+        @InjectMocks
+        UnderTestWithGenericSubclass underTestWithGenericSubclass = new UnderTestWithGenericSubclass();
+
+        @Test
+        void testGenericSubclass() {
+            assertNotNull(stringTreeSetMock);
+            assertNotNull(intHashSetMock);
+
+            assertEquals(stringTreeSetMock, underTestWithGenericSubclass.stringSet);
+            assertEquals(intHashSetMock, underTestWithGenericSubclass.intSet);
+        }
+    }
+
+    @Nested
+    public class MultipleCandidatesByTypeTest {
+        public class UnderTestWithMultipleCandidatesByType {
+            List<String> stringList;
+        }
+
+        @Mock
+        List<String> stringList1;
+
+        @Mock
+        List<String> stringList2;
+
+        @InjectMocks
+        UnderTestWithMultipleCandidatesByType underTestWithMultipleCandidates = new UnderTestWithMultipleCandidatesByType();
+
+        @Test
+        void testMultipleCandidatesByTypes() {
+            assertNotNull(stringList1);
+            assertNotNull(stringList2);
+
+            // verify that when mutiple mock candidates exist with same type (but not matching by field names), none will be injected
+            assertNull(underTestWithMultipleCandidates.stringList);
+        }
+    }
+
+    @Nested
+    public class MultipleCandidatesOneByNameTest {
+        public class UnderTestWithMultipleCandidatesOneByName {
+            List<String> stringList;
+        }
+
+        @Mock
+        List<String> stringList;
+
+        @Mock
+        List<String> stringListMock;
+
+        @InjectMocks
+        UnderTestWithMultipleCandidatesOneByName underTestWithMultipleCandidatesOneByName = new UnderTestWithMultipleCandidatesOneByName();
+
+        @Test
+        void testMultipleCandidatesOneByName() {
+            // verify that when multiple mock candidates exist by type, and one of them matches by field name, that one is injected
+            assertNotNull(underTestWithMultipleCandidatesOneByName.stringList);
+            assertEquals(stringList, underTestWithMultipleCandidatesOneByName.stringList);
+        }
+    }
+
+    @Nested
+    public class NoneMatchByTypeParameterTest {
+        public class UnderTestWithNoMatches {
+            List<Integer> intList;
+        }
+
+        @Mock
+        List<String> stringList;
+
+        @InjectMocks
+        UnderTestWithNoMatches underTestWithNoMatches = new UnderTestWithNoMatches();
+
+        @Test
+        void testNoneMatchByTypeParameter() {
+            assertNotNull(stringList);
+
+            // verify that when no candidate matches by type parameter, none is injected
+            assertNull(underTestWithNoMatches.intList);
+        }
+    }
+
+    @Nested
+    public class NoneMatchByRawTypeTest {
+        public class UnderTestWithNoMatches {
+            List<Integer> intList;
+        }
+
+        @Mock
+        Set<Integer> intSet;
+
+        @InjectMocks
+        UnderTestWithNoMatches underTestWithNoMatchesByRawType = new UnderTestWithNoMatches();
+
+        @Test
+        void testNoneMatchByRawType() {
+            assertNotNull(intSet);
+
+            // verify that when no candidate matches by raw type, none is injected
+            assertNull(underTestWithNoMatchesByRawType.intList);
+        }
+    }
+
+
+    @Nested
+    public class ClassWithTypeParameterNoMatchTest {
+        public class UnderTestWithTypeParameter<T> {
+            List<T> tList;
+        }
+
+        @Mock
+        List<Integer> intList;
+
+        @InjectMocks
+        UnderTestWithTypeParameter<String> underTestWithTypeParameterNoMatch = new UnderTestWithTypeParameter<String>();
+
+        @Test
+        void testWithTypeParameterNoMatch() {
+            assertNotNull(intList);
+
+            // verify that when no candidate matches by type parameter of class under test, none is injected
+            assertNull(underTestWithTypeParameterNoMatch.tList);
+        }
+    }
+
+    @Nested
+    public class ClassWithTypeParametersTest {
+        public class UnderTestWithTypeParameters<T1, T2> {
+            List<T1> t1List;
+            List<T2> t2List;
+        }
+
+        @Mock
+        List<String> stringList;
+
+        @Mock
+        List<Integer> intList;
+
+        @InjectMocks
+        UnderTestWithTypeParameters<String, Integer> underTestWithTypeParameters = new UnderTestWithTypeParameters<String, Integer>();
+
+        @Test
+        void testWithTypeParameters() {
+            assertNotNull(stringList);
+            assertNotNull(intList);
+
+            // verify that we can match the type parameters of the class under test
+            assertEquals(stringList, underTestWithTypeParameters.t1List);
+            assertEquals(intList, underTestWithTypeParameters.t2List);
+        }
+    }
+
+}
