diff --git a/src/main/java/org/mockito/AdditionalAnswers.java b/src/main/java/org/mockito/AdditionalAnswers.java
index b184928d8..95223f800 100644
--- a/src/main/java/org/mockito/AdditionalAnswers.java
+++ b/src/main/java/org/mockito/AdditionalAnswers.java
@@ -4,6 +4,7 @@
  */
 package org.mockito;
 
+import org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces;
 import org.mockito.internal.stubbing.answers.ReturnsArgumentAt;
 import org.mockito.internal.stubbing.answers.ReturnsElementsOf;
 import org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations;
@@ -12,12 +13,14 @@ import org.mockito.stubbing.Answer;
 import java.util.Collection;
 
 /**
- * Additional answers provides factory methods for less common answers.
+ * Additional answers provides factory methods for answers.
  *
- * <p>Currently offer answers that can return the parameter of an invocation at a certain position.
+ * <p>Currently offer answers that can return the parameter of an invocation at a certain position,
+ * along with answers that draw on a strongly typed interface from {@link AnswerFunctionalInterfaces}
+ * to provide a neater way to write custom answers that either return a value or are void.
  *
  * <p>See factory methods for more information : {@link #returnsFirstArg}, {@link #returnsSecondArg},
- * {@link #returnsLastArg} and {@link #returnsArgAt}
+ * {@link #returnsLastArg}, {@link #returnsArgAt}, {@link #answer} and {@link #answerVoid}
  *
  * @since 1.9.5
  */
@@ -195,4 +198,140 @@ public class AdditionalAnswers {
     public static <T> Answer<T> returnsElementsOf(Collection<?> elements) {
         return (Answer<T>) new ReturnsElementsOf(elements);
     }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - which is expected to return something
+     * @param <T> return type
+     * @param <A> input parameter type 1
+     * @return the answer object to use
+     */
+    public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer1<T, A> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - a void method
+     * @param <A> input parameter type 1
+     * @return the answer object to use
+     */
+    public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer1<A> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - which is expected to return something
+     * @param <T> return type
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @return the answer object to use
+     */
+    public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer2<T, A, B> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - a void method
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @return the answer object to use
+     */
+    public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer2<A, B> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - which is expected to return something
+     * @param <T> return type
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @return the answer object to use
+     */
+    public static <T, A, B, C> Answer<T> answer(AnswerFunctionalInterfaces.Answer3<T, A, B, C> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - a void method
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @return the answer object to use
+     */
+    public static <A, B, C> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer3<A, B, C> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - which is expected to return something
+     * @param <T> return type
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @param <D> input parameter type 4
+     * @return the answer object to use
+     */
+    public static <T, A, B, C, D> Answer<T> answer(AnswerFunctionalInterfaces.Answer4<T, A, B, C, D> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - a void method
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @param <D> input parameter type 4
+     * @return the answer object to use
+     */
+    public static <A, B, C, D> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer4<A, B, C, D> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     * @param answer interface to the answer - which is expected to return something
+     * @param <T> return type
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @param <D> input parameter type 4
+     * @param <E> input parameter type 5
+     * @return the answer object to use
+     */
+    public static <T, A, B, C, D, E> Answer<T> answer(AnswerFunctionalInterfaces.Answer5<T, A, B, C, D, E> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
+
+    /**
+     * Creates an answer from a functional interface - allows for a strongly typed answer to be created
+     * ideally in Java 8
+     *
+     * @param answer interface to the answer - a void method
+     * @param <A> input parameter type 1
+     * @param <B> input parameter type 2
+     * @param <C> input parameter type 3
+     * @param <D> input parameter type 4
+     * @param <E> input parameter type 5
+     * @return the answer object to use
+     */
+    public static <A, B, C, D, E> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer5<A, B, C, D, E> answer) {
+        return AnswerFunctionalInterfaces.toAnswer(answer);
+    }
 }
diff --git a/src/main/java/org/mockito/ArgumentMatcher.java b/src/main/java/org/mockito/ArgumentMatcher.java
index 6b3618aad..6c47a8a26 100644
--- a/src/main/java/org/mockito/ArgumentMatcher.java
+++ b/src/main/java/org/mockito/ArgumentMatcher.java
@@ -70,6 +70,13 @@ package org.mockito;
  *   verify(mock).addAll(<b>listOfTwoElements()</b>);
  * </code></pre>
  *
+ * In Java 8 you can treat ArgumentMatcher as a functional interface
+ * and use a lambda, e.g.:
+ *
+ * <pre class="code"><code class="java">
+ *   verify(mock).addAll(<b>argThat(list -> list.size() == 2)</b>);
+ * </code></pre>
+ *
  * <p>
  * Read more about other matchers in javadoc for {@link Matchers} class.
  * <h2>2.0 migration guide</h2>
@@ -126,5 +133,5 @@ public interface ArgumentMatcher<T> {
      *            the argument
      * @return true if this matcher accepts the given argument.
      */
-    public boolean matches(Object argument);
+    public boolean matches(T argument);
 }
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index 3fe8a5df3..d98870181 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -65,6 +65,9 @@ import org.mockito.junit.*;
  *      <a href="#32">33. (new) Mockito JUnit rule (Since 1.10.17)</a><br/>
  *      <a href="#34">34. (new) Switch <em>on</em> or <em>off</em> plugins (Since 1.10.15)</a><br/>
  *      <a href="#35">35. (new) Custom verification failure message (Since 2.0.0)</a><br/>
+ *      <a href="#36">36. (new) Java 8 Lambda Matcher Support (Since 2.0.0)</a><br/>
+ *      <a href="#37">37. (new) Java 8 Custom Answer Support (Since 2.0.0)</a><br/>
+ *
  * </b>
  *
  * <h3 id="0">0. <a class="meaningful_link" href="#verification">Migrating to 2.0</a></h3>
@@ -180,6 +183,10 @@ import org.mockito.junit.*;
  *
  * //<b>you can also verify using an argument matcher</b>
  * verify(mockedList).get(anyInt());
+ *
+ * //<b>argument matchers can also be written as Java 8 Lambdas</b>
+ * verify(mockedList).add(someString -> someString.length() > 5);
+ *
  * </code></pre>
  *
  * <p>
@@ -1087,6 +1094,117 @@ import org.mockito.junit.*;
  * verify(mock, times(2).description("someMethod should be called twice")).someMethod();
  * </code></pre>
  *
+ * <h3 id="36">36. <a class="meaningful_link" href="#Java_8_Lambda_Matching">Java 8 Lambda Matcher Support</a> (Since 2.0.0)</h3>
+ * <p>
+ * You can use Java 8 lambda expressions with {@link ArgumentMatcher} to reduce the dependency on {@link ArgumentCaptor}.
+ * If you need to verify that the input to a function call on a mock was correct, then you would normally
+ * use the {@link ArgumentCaptor} to find the operands used and then do subsequent assertions on them. While
+ * for complex examples this can be useful, it's also long-winded.<p>
+ * Writing a lambda to express the match is quite easy. The argument to your function, when used in conjunction
+ * with argThat, will be passed to the ArgumentMatcher as a strongly typed object, so it is possible
+ * to do anything with it.
+ * <p>
+ * Examples:
+ * <p>
+ * <pre class="code"><code class="java">
+ *
+ * // verify a list only had strings of a certain length added to it
+ * // note - this will only compile under Java 8
+ * verify(list, times(2)).add(argThat(string -> string.length() < 5));
+ *
+ * // Java 7 equivalent - not as neat
+ * verify(list, times(2)).add(argThat(new ArgumentMatcher<String>(){
+ *     public boolean matches(String arg) {
+ *         return arg.length() < 5;
+ *     }
+ * }));
+ *
+ * // more complex Java 8 example - where you can specify complex verification behaviour functionally
+ * verify(target, times(1)).receiveComplexObject(argThat(obj -> obj.getSubObject().get(0).equals("expected")));
+ *
+ * // this can also be used when defining the behaviour of a mock under different inputs
+ * // in this case if the input list was fewer than 3 items the mock returns null
+ * when(mock.someMethod(argThat(list -> list.size()<3))).willReturn(null);
+ * </code></pre>
+ *
+ * <h3 id="37">37. <a class="meaningful_link" href="#Java_8_Custom_Answers">Java 8 Custom Answer Support</a> (Since 2.0.0)</h3>
+ * <p>
+ * As the {@link Answer} interface has just one method it is already possible to implement it in Java 8 using
+ * a lambda expression for very simple situations. The more you need to use the parameters of the method call,
+ * the more you need to typecast the arguments from {@link org.mockito.invocation.InvocationOnMock}.
+ *
+ * <p>
+ * Examples:
+ * <p>
+ * <pre class="code"><code class="java">
+ * // answer by returning 12 every time
+ * doAnswer(invocation -> 12).when(mock).doSomething();
+ *
+ * // answer by using one of the parameters - converting into the right
+ * // type as your go - in this case, returning the length of the second string parameter
+ * // as the answer. This gets long-winded quickly, with casting of parameters.
+ * doAnswer(invocation -> ((String)invocation.getArgument(1)).length())
+ *     .when(mock).doSomething(anyString(), anyString(), anyString());
+ * </code></pre>
+ *
+ * For convenience it is possible to write custom answers/actions, which use the parameters to the method call,
+ * as Java 8 lambdas. Even in Java 7 and lower these custom answers based on a typed interface can reduce boilerplate.
+ * In particular, this approach will make it easier to test functions which use callbacks.
+ *
+ * The functions answer and answerVoid can be found in {@link AdditionalAnswers} to create the answer object
+ * using the interfaces in {@link AnswerFunctionalInterfaces} support is provided for functions with up to 5 parameters
+ *
+ * <p>
+ * Examples:
+ * <p>
+ * <pre class="code"><code class="java">
+ *
+ * // Example interface to be mocked has a function like:
+ * void execute(String operand, Callback callback);
+ *
+ * // the example callback has a function and the class under test
+ * // will depend on the callback being invoked
+ * void receive(String item);
+ *
+ * // Java 8 - style 1
+ * doAnswer(AdditionalAnswers.<String,Callback>answerVoid((operand, callback) -> callback.receive("dummy"))
+ *     .when(mock).execute(anyString(), any(Callback.class));
+ *
+ * // Java 8 - style 2 - assuming static import of AdditionalAnswers
+ * doAnswer(answerVoid((String operand, Callback callback) -> callback.receive("dummy"))
+ *     .when(mock).execute(anyString(), any(Callback.class));
+ *
+ * // Java 8 - style 3 - where mocking function to is a static member of test class
+ * private static void dummyCallbackImpl(String operation, Callback callback) {
+ *     callback.receive("dummy");
+ * }
+ *
+ * doAnswer(answerVoid(TestClass::dummyCallbackImpl)
+ *     .when(mock).execute(anyString(), any(Callback.class));
+ *
+ * // Java 7
+ * doAnswer(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer2<String, Callback>() {
+ *     public void answer(String operation, Callback callback) {
+ *         callback.receive("dummy");
+ *     }})).when(mock).execute(anyString(), any(Callback.class));
+ *
+ * // returning a value is possible with the answer() function
+ * // and the non-void version of the functional interfaces
+ * // so if the mock interface had a method like
+ * boolean isSameString(String input1, String input2);
+ *
+ * // this could be mocked
+ * // Java 8
+ * doAnswer(AdditionalAnswers.<Boolean,String,String>answer((input1, input2) -> input1.equals(input2))))
+ *     .when(mock).execute(anyString(), anyString());
+ *
+ * // Java 7
+ * doAnswer(answer(new AnswerFunctionalInterfaces.Answer2<String, String, String>() {
+ *     public String answer(String input1, String input2) {
+ *         return input1 + input2;
+ *     }})).when(mock).execute(anyString(), anyString());
+ * </code></pre>
+ *
  * TODO rework the documentation, write about hamcrest.
  *
  */
diff --git a/src/main/java/org/mockito/exceptions/stacktrace/StackTraceCleaner.java b/src/main/java/org/mockito/exceptions/stacktrace/StackTraceCleaner.java
index abd1a32d5..8e4291328 100644
--- a/src/main/java/org/mockito/exceptions/stacktrace/StackTraceCleaner.java
+++ b/src/main/java/org/mockito/exceptions/stacktrace/StackTraceCleaner.java
@@ -17,10 +17,10 @@ package org.mockito.exceptions.stacktrace;
 public interface StackTraceCleaner {
 
     /**
-     * Decides if element is excluded.
+     * Decides if element is included.
      *
      * @param candidate element of the actual stack trace
      * @return whether the element should be excluded from cleaned stack trace.
      */
-    boolean isOut(StackTraceElement candidate);
+    boolean isIn(StackTraceElement candidate);
 }
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java
index a32d45690..c7ac166b2 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java
@@ -8,13 +8,13 @@ import org.mockito.exceptions.stacktrace.StackTraceCleaner;
 public class DefaultStackTraceCleaner implements StackTraceCleaner {
 
 	@Override
-	public boolean isOut(StackTraceElement e) {
+	public boolean isIn(StackTraceElement e) {
 		if (isFromMockitoRunner(e.getClassName()) || isFromMockitoRule(e.getClassName())) {
-			return false;
-		} else if (isMockDispatcher(e.getClassName()) || isFromMockito(e.getClassName())) {
 			return true;
-		} else {
+		} else if (isMockDispatcher(e.getClassName()) || isFromMockito(e.getClassName())) {
 			return false;
+		} else {
+			return true;
 		}
 	}
 
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
index 7cad23553..2b6fcfa0c 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
@@ -30,7 +30,7 @@ public class StackTraceFilter implements Serializable {
         //TODO: investigate "keepTop" commit history - no effect!
         final List<StackTraceElement> filtered = new ArrayList<StackTraceElement>();
         for (StackTraceElement element : target) {
-            if (!CLEANER.isOut(element)) {
+            if (CLEANER.isIn(element)) {
                 filtered.add(element);
             }
         }
diff --git a/src/main/java/org/mockito/internal/matchers/CompareTo.java b/src/main/java/org/mockito/internal/matchers/CompareTo.java
index 675aed3b0..57392088c 100644
--- a/src/main/java/org/mockito/internal/matchers/CompareTo.java
+++ b/src/main/java/org/mockito/internal/matchers/CompareTo.java
@@ -18,12 +18,8 @@ public abstract class CompareTo<T extends Comparable<T>> implements ArgumentMatc
     }
 
     @SuppressWarnings("unchecked")
-    public boolean matches(Object actual) {
-        if(!(actual instanceof Comparable)) {
-            return false;
-        }
-        
-        return matchResult(((Comparable) actual).compareTo(wanted));
+    public boolean matches(T actual) {
+        return matchResult(((Comparable)actual).compareTo(wanted));
     }
 
     public String toString() {
diff --git a/src/main/java/org/mockito/internal/matchers/Contains.java b/src/main/java/org/mockito/internal/matchers/Contains.java
index d04b6e246..daa76081b 100644
--- a/src/main/java/org/mockito/internal/matchers/Contains.java
+++ b/src/main/java/org/mockito/internal/matchers/Contains.java
@@ -18,8 +18,8 @@ public class Contains implements ArgumentMatcher<String>, Serializable {
         this.substring = substring;
     }
 
-    public boolean matches(Object actual) {
-        return actual != null && ((String) actual).contains(substring);
+    public boolean matches(String actual) {
+        return actual != null && actual.contains(substring);
     }
 
     public String toString() {
diff --git a/src/main/java/org/mockito/internal/matchers/EndsWith.java b/src/main/java/org/mockito/internal/matchers/EndsWith.java
index bc36f25d1..7bb194bfc 100644
--- a/src/main/java/org/mockito/internal/matchers/EndsWith.java
+++ b/src/main/java/org/mockito/internal/matchers/EndsWith.java
@@ -17,8 +17,8 @@ public class EndsWith implements ArgumentMatcher<String>, Serializable {
         this.suffix = suffix;
     }
 
-    public boolean matches(Object actual) {
-        return actual != null && ((String) actual).endsWith(suffix);
+    public boolean matches(String actual) {
+        return actual != null && actual.endsWith(suffix);
     }
 
     public String toString() {
diff --git a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
index f6bf15a42..d5d8e19dc 100644
--- a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
+++ b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
@@ -19,8 +19,7 @@ public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
         this.delta = delta;
     }
 
-    public boolean matches(Object object) {
-        Number actual = (Number) object;
+    public boolean matches(Number actual) {
         if (wanted == null ^ actual == null) {
             return false;
         }
diff --git a/src/main/java/org/mockito/internal/matchers/Find.java b/src/main/java/org/mockito/internal/matchers/Find.java
index 6fe6f8c90..d37771afa 100644
--- a/src/main/java/org/mockito/internal/matchers/Find.java
+++ b/src/main/java/org/mockito/internal/matchers/Find.java
@@ -18,8 +18,8 @@ public class Find implements ArgumentMatcher<String>, Serializable {
         this.regex = regex;
     }
 
-    public boolean matches(Object actual) {
-        return actual != null && Pattern.compile(regex).matcher((String) actual).find();
+    public boolean matches(String actual) {
+        return actual != null && Pattern.compile(regex).matcher(actual).find();
     }
 
     public String toString() {
diff --git a/src/main/java/org/mockito/internal/matchers/StartsWith.java b/src/main/java/org/mockito/internal/matchers/StartsWith.java
index c7e9b42a5..f89c2c035 100644
--- a/src/main/java/org/mockito/internal/matchers/StartsWith.java
+++ b/src/main/java/org/mockito/internal/matchers/StartsWith.java
@@ -17,8 +17,8 @@ public class StartsWith implements ArgumentMatcher<String>, Serializable {
         this.prefix = prefix;
     }
 
-    public boolean matches(Object actual) {
-        return actual != null && ((String) actual).startsWith(prefix);
+    public boolean matches(String actual) {
+        return actual != null && actual.startsWith(prefix);
     }
 
     public String toString() {
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java b/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java
new file mode 100644
index 000000000..11645d6b3
--- /dev/null
+++ b/src/main/java/org/mockito/internal/stubbing/answers/AnswerFunctionalInterfaces.java
@@ -0,0 +1,329 @@
+package org.mockito.internal.stubbing.answers;
+
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Functional interfaces to make it easy to implement answers in Java 8
+ */
+public class AnswerFunctionalInterfaces {
+	/**
+     * Hide constructor to avoid instantiation of class with only static methods
+     */
+    private AnswerFunctionalInterfaces() {
+    }
+
+    /**
+     * Construct an answer from a two parameter answer interface
+     * @param answer answer interface
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @return a new answer object
+     */
+    public static <T, A> Answer<T> toAnswer(final Answer1<T, A> answer) {
+        return new Answer<T>() {
+            @SuppressWarnings("unchecked")
+            public T answer(InvocationOnMock invocation) throws Throwable {
+                return answer.answer((A)invocation.getArgument(0));
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a two parameter answer interface
+     * @param answer answer interface
+     * @param <A> input parameter 1 type
+     * @return a new answer object
+     */
+    public static <A> Answer<Void> toAnswer(final VoidAnswer1<A> answer) {
+        return new Answer<Void>() {
+            @SuppressWarnings("unchecked")
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                answer.answer((A)invocation.getArgument(0));
+                return null;
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a two parameter answer interface
+     * @param answer answer interface
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @return a new answer object
+     */
+    public static <T, A, B> Answer<T> toAnswer(final Answer2<T, A, B> answer) {
+        return new Answer<T>() {
+            @SuppressWarnings("unchecked")
+            public T answer(InvocationOnMock invocation) throws Throwable {
+                return answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1));
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a two parameter answer interface
+     * @param answer answer interface
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @return a new answer object
+     */
+    public static <A, B> Answer<Void> toAnswer(final VoidAnswer2<A, B> answer) {
+        return new Answer<Void>() {
+            @SuppressWarnings("unchecked")
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1));
+                return null;
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a three parameter answer interface
+     * @param answer answer interface
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @return a new answer object
+     */
+    public static <T, A, B, C> Answer<T> toAnswer(final Answer3<T, A, B, C> answer) {
+        return new Answer<T>() {
+            @SuppressWarnings("unchecked")
+            public T answer(InvocationOnMock invocation) throws Throwable {
+                return answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1),
+                        (C)invocation.getArgument(2));
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a three parameter answer interface
+     * @param answer answer interface
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @return a new answer object
+     */
+    public static <A, B, C> Answer<Void> toAnswer(final VoidAnswer3<A, B, C> answer) {
+        return new Answer<Void>() {
+            @SuppressWarnings("unchecked")
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1),
+                        (C)invocation.getArgument(2));
+                return null;
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a four parameter answer interface
+     * @param answer answer interface
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @return a new answer object
+     */
+    public static <T, A, B, C, D> Answer<T> toAnswer(final Answer4<T, A, B, C, D> answer) {
+        return new Answer<T>() {
+            @SuppressWarnings("unchecked")
+            public T answer(InvocationOnMock invocation) throws Throwable {
+                return answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1),
+                        (C)invocation.getArgument(2),
+                        (D)invocation.getArgument(3));
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a four parameter answer interface
+     * @param answer answer interface
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @return a new answer object
+     */
+    public static <A, B, C, D> Answer<Void> toAnswer(final VoidAnswer4<A, B, C, D> answer) {
+        return new Answer<Void>() {
+            @SuppressWarnings("unchecked")
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1),
+                        (C)invocation.getArgument(2),
+                        (D)invocation.getArgument(3));
+                return null;
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a five parameter answer interface
+     * @param answer answer interface
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @param <E> input parameter 5 type
+     * @return a new answer object
+     */
+    public static <T, A, B, C, D, E> Answer<T> toAnswer(final Answer5<T, A, B, C, D, E> answer) {
+        return new Answer<T>() {
+            @SuppressWarnings("unchecked")
+            public T answer(InvocationOnMock invocation) throws Throwable {
+                return answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1),
+                        (C)invocation.getArgument(2),
+                        (D)invocation.getArgument(3),
+                        (E)invocation.getArgument(4));
+            }
+        };
+    }
+
+    /**
+     * Construct an answer from a five parameter answer interface
+     * @param answer answer interface
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @param <E> input parameter 5 type
+     * @return a new answer object
+     */
+    public static <A, B, C, D, E> Answer<Void> toAnswer(final VoidAnswer5<A, B, C, D, E> answer) {
+        return new Answer<Void>() {
+            @SuppressWarnings("unchecked")
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                answer.answer(
+                        (A)invocation.getArgument(0),
+                        (B)invocation.getArgument(1),
+                        (C)invocation.getArgument(2),
+                        (D)invocation.getArgument(3),
+                        (E)invocation.getArgument(4));
+                return null;
+            }
+        };
+    }
+
+
+    /**
+     * One parameter function which returns something
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     */
+    public interface Answer1<T, A> {
+        T answer(A a);
+    }
+
+    /**
+     * One parameter void function
+     * @param <A> input parameter 1 type
+     */
+    public interface VoidAnswer1<A> {
+        void answer(A a);
+    }
+
+    /**
+     * Two parameter function which returns something
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     */
+    public interface Answer2<T, A, B> {
+        T answer(A a, B b);
+    }
+
+    /**
+     * Two parameter void function
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     */
+    public interface VoidAnswer2< A, B> {
+        void answer(A a, B b);
+    }
+
+    /**
+     * Three parameter function which returns something
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     */
+    public interface Answer3<T, A, B, C> {
+        T answer(A a, B b, C c);
+    }
+
+    /**
+     * Two parameter void function
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     */
+    public interface VoidAnswer3< A, B, C> {
+        void answer(A a, B b, C c);
+    }
+
+    /**
+     * Three parameter function which returns something
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     */
+    public interface Answer4<T, A, B, C, D> {
+        T answer(A a, B b, C c, D d);
+    }
+
+    /**
+     * Two parameter void function
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     */
+    public interface VoidAnswer4<A, B, C, D> {
+        void answer(A a, B b, C c, D d);
+    }
+
+    /**
+     * Three parameter function which returns something
+     * @param <T> return type
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @param <E> input parameter 5 type
+     */
+    public interface Answer5<T, A, B, C, D, E> {
+        T answer(A a, B b, C c, D d, E e);
+    }
+
+    /**
+     * Two parameter void function
+     * @param <A> input parameter 1 type
+     * @param <B> input parameter 2 type
+     * @param <C> input parameter 3 type
+     * @param <D> input parameter 4 type
+     * @param <E> input parameter 5 type
+     */
+    public interface VoidAnswer5< A, B, C, D, E> {
+        void answer(A a, B b, C c, D d, E e);
+    }
+}
diff --git a/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java b/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
index 5461d5f54..64cce7e0c 100644
--- a/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
+++ b/src/test/java/org/mockito/exceptions/stacktrace/StackTraceCleanerTest.java
@@ -33,11 +33,11 @@ public class StackTraceCleanerTest {
 	}
 
 	private void assertAccepted(String className) {
-		assertThat(cleaner.isOut(type(className))).describedAs("Must be accepted %s", className).isFalse();
+		assertThat(cleaner.isIn(type(className))).describedAs("Must be accepted %s", className).isTrue();
 	}
 
 	private void assertRejected(String className) {
-		assertThat(cleaner.isOut(type(className))).describedAs("Must be rejected %s", className).isTrue();
+		assertThat(cleaner.isIn(type(className))).describedAs("Must be rejected %s", className).isFalse();
 	}
 
 	private StackTraceElement type(String className) {
diff --git a/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java b/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java
new file mode 100644
index 000000000..b2ffadaa5
--- /dev/null
+++ b/src/test/java/org/mockito/internal/matchers/StringMatchersTest.java
@@ -0,0 +1,72 @@
+package org.mockito.internal.matchers;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+/**
+ * Tests for the Matchers that operate over strings
+ */
+public class StringMatchersTest {
+	@Test
+	public void startsWithString() {
+		assertTrue(new StartsWith("mockito").matches("mockito is here"));
+	}
+
+	@Test
+	public void doesNotStartWithString() {
+		assertFalse(new StartsWith("junit").matches("mockito is here"));
+	}
+
+	@Test
+	public void nullStartsWith() {
+		assertFalse(new StartsWith("java").matches(null));
+	}
+
+	@Test
+	public void endsWithString() {
+		assertTrue(new EndsWith("mockito").matches("here is mockito"));
+	}
+
+	@Test
+	public void doesNotEndWithString() {
+		assertFalse(new EndsWith("junit").matches("here is mockito"));
+	}
+
+	@Test
+	public void nullEndsWith() {
+		assertFalse(new EndsWith("java").matches(null));
+	}
+
+	@Test
+	public void containsString() {
+		assertTrue(new Contains("mockito").matches("****mockito****"));
+	}
+
+	@Test
+	public void stringDoesNotContain() {
+		assertFalse(new Contains("junit").matches("****mockito****"));
+	}
+
+	@Test
+	public void nullContainsNothing() {
+		assertFalse(new Contains("mockito").matches(null));
+	}
+
+	@Test
+	public void matchesRegex() {
+		assertTrue(new Find("eleph.nt").matches("the elephant in the room"));
+		assertTrue(new Find("eleph.nt").matches("the elephInt in the room"));
+	}
+
+	@Test
+	public void doesNotMatchRegex() {
+		assertFalse(new Find("eleph.nt").matches("the otter in the room"));
+	}
+
+	@Test
+	public void nullDoesNotMatchRegex() {
+		assertFalse(new Find("eleph.nt").matches(null));
+	}
+
+}
diff --git a/src/test/java/org/mockitousage/IMethods.java b/src/test/java/org/mockitousage/IMethods.java
index 19fd56312..426e76957 100644
--- a/src/test/java/org/mockitousage/IMethods.java
+++ b/src/test/java/org/mockitousage/IMethods.java
@@ -132,6 +132,10 @@ public interface IMethods {
 
     Object threeArgumentMethod(int valueOne, Object valueTwo, String valueThree);
 
+    String threeArgumentMethodWithStrings(int valueOne, String valueTwo, String valueThree);
+
+    String fourArgumentMethod(int valueOne, String valueTwo, String valueThree, boolean[] array);
+
     void twoArgumentMethod(int one, int two);
 
     void arrayMethod(String[] strings);
diff --git a/src/test/java/org/mockitousage/MethodsImpl.java b/src/test/java/org/mockitousage/MethodsImpl.java
index 9f5e4f533..44c883618 100644
--- a/src/test/java/org/mockitousage/MethodsImpl.java
+++ b/src/test/java/org/mockitousage/MethodsImpl.java
@@ -249,6 +249,14 @@ public class MethodsImpl implements IMethods {
         return null;
     }
 
+    public String threeArgumentMethodWithStrings(int valueOne, String valueTwo, String valueThree) {
+        return null;
+    }
+
+    public String fourArgumentMethod(int valueOne, String valueTwo, String valueThree, boolean[] array) {
+        return null;
+    }
+
     public void twoArgumentMethod(int one, int two) {
       
     }
diff --git a/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java b/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java
index 00c0def25..e29de746b 100644
--- a/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java
+++ b/src/test/java/org/mockitousage/matchers/CustomMatcherDoesYieldCCETest.java
@@ -32,7 +32,7 @@ public class CustomMatcherDoesYieldCCETest extends TestBase {
 
     private ArgumentMatcher<String> isStringWithTextFoo() {
         return new ArgumentMatcher<String>() {
-            public boolean matches(Object argument) {
+            public boolean matches(String argument) {
                 // casting that should not be thrown:
                 String str = (String) argument;
                 return str.equals("foo");
diff --git a/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java b/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java
index 5399a8ddf..025225322 100644
--- a/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/CustomMatchersTest.java
@@ -18,27 +18,25 @@ import org.mockitoutil.TestBase;
 public class CustomMatchersTest extends TestBase {
     
     private final class ContainsFoo implements ArgumentMatcher<String> {
-        public boolean matches(Object arg) {
-            return ((String) arg).contains("foo");
+        public boolean matches(String arg) {
+            return arg.contains("foo");
         }
     }
 
     private final class IsAnyBoolean implements ArgumentMatcher<Boolean> {
-        public boolean matches(Object arg) {
+        public boolean matches(Boolean arg) {
             return true;
         }
     }
     
     private final class IsSorZ implements ArgumentMatcher<Character> {
-        public boolean matches(Object arg) {
-            Character character = (Character) arg;
+        public boolean matches(Character character) {
             return character.equals('s') || character.equals('z');
         }
     }
 
     private final class IsZeroOrOne<T extends Number> implements ArgumentMatcher<T> {
-        public boolean matches(Object arg) {
-            Number number = (Number) arg;
+        public boolean matches(T number) {
             if (number.intValue() == 0 || number.intValue() == 1) {
                 return true;
             }
@@ -137,8 +135,7 @@ public class CustomMatchersTest extends TestBase {
     }
     
     private final class StringThatContainsXxx implements ArgumentMatcher<String> {
-        public boolean matches(Object argument) {
-            String arg = (String) argument;
+        public boolean matches(String arg) {
             return arg.contains("xxx");
         }
     }
diff --git a/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java b/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
index 52217605e..bfeada251 100644
--- a/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
@@ -107,7 +107,7 @@ public class HamcrestMatchersTest extends TestBase {
     @Test
     public void coexists_with_mockito_matcher() {
         when(mock.simpleMethod(Mockito.argThat(new ArgumentMatcher<String>() {
-            public boolean matches(Object argument) {
+            public boolean matches(String argument) {
                 return true;
             }
         }))).thenReturn("x");
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java
deleted file mode 100644
index 0ba0430e3..000000000
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockitousage.stubbing;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.runners.MockitoJUnitRunner;
-import org.mockitousage.IMethods;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.AdditionalAnswers.returnsArgAt;
-import static org.mockito.AdditionalAnswers.returnsFirstArg;
-import static org.mockito.AdditionalAnswers.returnsLastArg;
-import static org.mockito.AdditionalAnswers.returnsSecondArg;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyObject;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Matchers.anyVararg;
-import static org.mockito.Matchers.eq;
-
-@RunWith(MockitoJUnitRunner.class)
-public class StubbingWithAdditionalAnswers {
-
-    @Mock IMethods iMethods;
-
-    @Test
-    public void can_return_arguments_of_invocation() throws Exception {
-        given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());
-        given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());
-        given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());
-
-        assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
-        assertThat(iMethods.threeArgumentMethod(0, "second", "whatever")).isEqualTo("second");
-        assertThat(iMethods.threeArgumentMethod(1, "whatever", "last")).isEqualTo("last");
-    }
-
-    @Test
-    public void can_return_expanded_arguments_of_invocation() throws Exception {
-        given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAt(3));
-
-        assertThat(iMethods.varargsObject(1, "bob", "alexander", "alice", "carl")).isEqualTo("alice");
-    }
-
-    @Test
-    public void can_return_primitives_or_wrappers() throws Exception {
-        given(iMethods.toIntPrimitive(anyInt())).will(returnsFirstArg());
-        given(iMethods.toIntWrapper(anyInt())).will(returnsFirstArg());
-
-        assertThat(iMethods.toIntPrimitive(1)).isEqualTo(1);
-        assertThat(iMethods.toIntWrapper(1)).isEqualTo(1);
-    }
-}
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
new file mode 100644
index 000000000..9deaba2b7
--- /dev/null
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.stubbing;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.internal.stubbing.answers.AnswerFunctionalInterfaces;
+import org.mockito.runners.MockitoJUnitRunner;
+import org.mockitousage.IMethods;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.AdditionalAnswers.returnsArgAt;
+import static org.mockito.AdditionalAnswers.returnsFirstArg;
+import static org.mockito.AdditionalAnswers.returnsLastArg;
+import static org.mockito.AdditionalAnswers.returnsSecondArg;
+import static org.mockito.AdditionalAnswers.answer;
+import static org.mockito.AdditionalAnswers.answerVoid;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.BDDMockito.mock;
+import static org.mockito.BDDMockito.verify;
+import static org.mockito.BDDMockito.times;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.anyObject;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.anyVararg;
+import static org.mockito.Matchers.eq;
+
+@RunWith(MockitoJUnitRunner.class)
+public class StubbingWithAdditionalAnswersTest {
+
+    @Mock IMethods iMethods;
+
+    @Test
+    public void can_return_arguments_of_invocation() throws Exception {
+        given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());
+        given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());
+        given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());
+
+        assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
+        assertThat(iMethods.threeArgumentMethod(0, "second", "whatever")).isEqualTo("second");
+        assertThat(iMethods.threeArgumentMethod(1, "whatever", "last")).isEqualTo("last");
+    }
+
+    @Test
+    public void can_return_expanded_arguments_of_invocation() throws Exception {
+        given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAt(3));
+
+        assertThat(iMethods.varargsObject(1, "bob", "alexander", "alice", "carl")).isEqualTo("alice");
+    }
+
+    @Test
+    public void can_return_primitives_or_wrappers() throws Exception {
+        given(iMethods.toIntPrimitive(anyInt())).will(returnsFirstArg());
+        given(iMethods.toIntWrapper(anyInt())).will(returnsFirstArg());
+
+        assertThat(iMethods.toIntPrimitive(1)).isEqualTo(1);
+        assertThat(iMethods.toIntWrapper(1)).isEqualTo(1);
+    }
+
+    @Test
+    public void can_return_based_on_strongly_types_one_parameter_function() throws Exception {
+        given(iMethods.simpleMethod(anyString()))
+                .will(answer(new AnswerFunctionalInterfaces.Answer1<String, String>() {
+                    public String answer(String s) {
+                        return s;
+                    }
+                }));
+
+        assertThat(iMethods.simpleMethod("string")).isEqualTo("string");
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_one_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.simpleMethod(anyString()))
+                .will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer1<String>() {
+                    public void answer(String s) {
+                        target.simpleMethod(s);
+                    }
+                }));
+
+        // invoke on iMethods
+        iMethods.simpleMethod("string");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).simpleMethod("string");
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_two_parameter_function() throws Exception {
+        given(iMethods.simpleMethod(anyString(), anyInt()))
+            .will(answer(new AnswerFunctionalInterfaces.Answer2<String, String, Integer>() {
+                public String answer(String s, Integer i) {
+                    return s + "-" + i;
+                }
+            }));
+
+        assertThat(iMethods.simpleMethod("string",1)).isEqualTo("string-1");
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_two_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.simpleMethod(anyString(), anyInt()))
+            .will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer2<String, Integer>() {
+                public void answer(String s, Integer i) {
+                    target.simpleMethod(s, i);
+                }
+            }));
+
+        // invoke on iMethods
+        iMethods.simpleMethod("string",1);
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).simpleMethod("string", 1);
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_three_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.threeArgumentMethodWithStrings(anyInt(), anyString(), anyString()))
+                .will(answer(new AnswerFunctionalInterfaces.Answer3<String, Integer, String, String>() {
+                    public String answer(Integer i, String s1, String s2) {
+                        target.threeArgumentMethodWithStrings(i, s1, s2);
+                        return "answered";
+                    }
+                }));
+
+        assertThat(iMethods.threeArgumentMethodWithStrings(1, "string1", "string2")).isEqualTo("answered");
+        verify(target, times(1)).threeArgumentMethodWithStrings(1, "string1", "string2");
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_three_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.threeArgumentMethodWithStrings(anyInt(), anyString(), anyString()))
+                .will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer3<Integer, String, String>() {
+                    public void answer(Integer i, String s1, String s2) {
+                        target.threeArgumentMethodWithStrings(i, s1, s2);
+                    }
+                }));
+
+        // invoke on iMethods
+        iMethods.threeArgumentMethodWithStrings(1, "string1", "string2");
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).threeArgumentMethodWithStrings(1, "string1", "string2");
+    }
+
+    @Test
+        public void can_return_based_on_strongly_typed_four_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.fourArgumentMethod(anyInt(), anyString(), anyString(), any(boolean[].class)))
+                .will(answer(new AnswerFunctionalInterfaces.Answer4<String, Integer, String, String, boolean[]>() {
+                    public String answer(Integer i, String s1, String s2, boolean[] a) {
+                        target.fourArgumentMethod(i, s1, s2, a);
+                        return "answered";
+                    }
+                }));
+
+        boolean[] booleanArray = { true, false };
+        assertThat(iMethods.fourArgumentMethod(1, "string1", "string2", booleanArray)).isEqualTo("answered");
+        verify(target, times(1)).fourArgumentMethod(1, "string1", "string2", booleanArray);
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_four_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.fourArgumentMethod(anyInt(), anyString(), anyString(), any(boolean[].class)))
+                .will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer4<Integer, String, String, boolean[]>() {
+                    public void answer(Integer i, String s1, String s2, boolean[] a) {
+                        target.fourArgumentMethod(i, s1, s2, a);
+                    }
+                }));
+
+        // invoke on iMethods
+        boolean[] booleanArray = { true, false };
+        iMethods.fourArgumentMethod(1, "string1", "string2", booleanArray);
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).fourArgumentMethod(1, "string1", "string2", booleanArray);
+    }
+
+    @Test
+    public void can_return_based_on_strongly_typed_five_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+        given(iMethods.simpleMethod(anyString(), anyInt(), anyInt(), anyInt(), anyInt()))
+                .will(answer(new AnswerFunctionalInterfaces.Answer5<String, String, Integer, Integer, Integer, Integer>() {
+                    public String answer(String s1, Integer i1, Integer i2, Integer i3, Integer i4) {
+                        target.simpleMethod(s1, i1, i2, i3, i4);
+                        return "answered";
+                    }
+                }));
+
+        assertThat(iMethods.simpleMethod("hello", 1, 2, 3, 4)).isEqualTo("answered");
+        verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4);
+    }
+
+    @Test
+    public void will_execute_a_void_based_on_strongly_typed_five_parameter_function() throws Exception {
+        final IMethods target = mock(IMethods.class);
+
+        given(iMethods.simpleMethod(anyString(), anyInt(), anyInt(), anyInt(), anyInt()))
+                .will(answerVoid(new AnswerFunctionalInterfaces.VoidAnswer5<String, Integer, Integer, Integer, Integer>() {
+                    public void  answer(String s1, Integer i1, Integer i2, Integer i3, Integer i4) {
+                        target.simpleMethod(s1, i1, i2, i3, i4);
+                    }
+                }));
+
+        // invoke on iMethods
+        iMethods.simpleMethod("hello", 1, 2, 3, 4);
+
+        // expect the answer to write correctly to "target"
+        verify(target, times(1)).simpleMethod("hello", 1, 2, 3, 4);
+    }
+
+}
diff --git a/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java b/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java
index 29ac094ab..8ed992621 100644
--- a/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java
+++ b/src/test/java/org/mockitousage/verification/VerificationWithTimeoutTest.java
@@ -119,7 +119,7 @@ public class VerificationWithTimeoutTest extends TestBase {
         verify(mock, timeout(40).only()).clear();
     }
 
-    @Test
+    @Test(expected=NoInteractionsWanted.class)
     public void shouldAllowMixingOnlyWithTimeoutAndFail() throws Exception {
         //given
         Thread t1 = waitAndExerciseMock(20);
@@ -128,12 +128,15 @@ public class VerificationWithTimeoutTest extends TestBase {
         t1.start();
         mock.add("foo");
 
-        //then
+        //then at first "clear" hasn't been called
         verify(mock, never()).clear();
-        try {
-            verify(mock, timeout(40).only()).clear();
-            fail();
-        } catch (NoInteractionsWanted e) {}
+
+        // expect to have received the "clear" but
+        // for the call on "add" to break the "only" part
+        // of the verification
+        verify(mock, timeout(50).only()).clear();
+
+        // the test should end with an exception
     }
 
     /**
diff --git a/subprojects/extTest/src/test/java/org/mockitousage/plugins/stacktrace/MyStackTraceCleanerProvider.java b/subprojects/extTest/src/test/java/org/mockitousage/plugins/stacktrace/MyStackTraceCleanerProvider.java
index a0203aa0d..264ed42a2 100644
--- a/subprojects/extTest/src/test/java/org/mockitousage/plugins/stacktrace/MyStackTraceCleanerProvider.java
+++ b/subprojects/extTest/src/test/java/org/mockitousage/plugins/stacktrace/MyStackTraceCleanerProvider.java
@@ -13,11 +13,11 @@ public class MyStackTraceCleanerProvider implements StackTraceCleanerProvider {
     public StackTraceCleaner getStackTraceCleaner(final StackTraceCleaner defaultCleaner) {
         return new StackTraceCleaner() {
 			@Override
-			public boolean isOut(StackTraceElement candidate) {
+			public boolean isIn(StackTraceElement candidate) {
 				if (ENABLED && candidate.getMethodName().contains("excludeMe")) {
-                    return true;
+                    return false;
                 }
-                return defaultCleaner.isOut(candidate);
+                return defaultCleaner.isIn(candidate);
 			}
         };
     }
