diff --git a/build.gradle b/build.gradle
index f05c97fa3..92c56c1ed 100644
--- a/build.gradle
+++ b/build.gradle
@@ -99,7 +99,7 @@ dependencies {
     testUtil sourceSets.test.output
 
     signature 'org.codehaus.mojo.signature:java18:1.0@signature'
-    signature 'net.sf.androidscents.signature:android-api-level-24:7.0_r2@signature'
+    signature 'net.sf.androidscents.signature:android-api-level-26:8.0.0_r2@signature'
 }
 
 animalsniffer {
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
index 05512b840..d40967f94 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
@@ -447,9 +447,7 @@ class InlineDelegateByteBuddyMockMaker
                                 "IBM J9 VM",
                                 "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
                                 "Hotspot",
-                                Platform.isJava8BelowUpdate45()
-                                        ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n"
-                                        : ""),
+                                ""),
                         Platform.describe(),
                         "",
                         "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java
index e8dcce229..6bb74322b 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassByteBuddyMockMaker.java
@@ -122,9 +122,7 @@ public class SubclassByteBuddyMockMaker implements ClassCreatingMockMaker {
                                 "IBM J9 VM",
                                 "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
                                 "Hotspot",
-                                Platform.isJava8BelowUpdate45()
-                                        ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n"
-                                        : ""),
+                                ""),
                         Platform.describe(),
                         "",
                         "Underlying exception : " + generationFailed),
diff --git a/src/main/java/org/mockito/internal/debugging/Java8LocationImpl.java b/src/main/java/org/mockito/internal/debugging/Java8LocationImpl.java
deleted file mode 100644
index e8ee387c0..000000000
--- a/src/main/java/org/mockito/internal/debugging/Java8LocationImpl.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.debugging;
-
-import java.io.Serializable;
-
-import org.mockito.internal.exceptions.stacktrace.StackTraceFilter;
-import org.mockito.invocation.Location;
-
-class Java8LocationImpl implements Location, Serializable {
-
-    private static final long serialVersionUID = -9054861157390980624L;
-    // Limit the amount of objects being created, as this class is heavily instantiated:
-    private static final StackTraceFilter stackTraceFilter = new StackTraceFilter();
-
-    private String stackTraceLine;
-    private String sourceFile;
-
-    public Java8LocationImpl(Throwable stackTraceHolder, boolean isInline) {
-        this(stackTraceFilter, stackTraceHolder, isInline);
-    }
-
-    private Java8LocationImpl(
-            StackTraceFilter stackTraceFilter, Throwable stackTraceHolder, boolean isInline) {
-        computeStackTraceInformation(stackTraceFilter, stackTraceHolder, isInline);
-    }
-
-    @Override
-    public String toString() {
-        return stackTraceLine;
-    }
-
-    /**
-     * Eagerly compute the stacktrace line from the stackTraceHolder. Storing the Throwable is
-     * memory-intensive for tests that have large stacktraces and have a lot of invocations on
-     * mocks.
-     */
-    private void computeStackTraceInformation(
-            StackTraceFilter stackTraceFilter, Throwable stackTraceHolder, boolean isInline) {
-        StackTraceElement filtered = stackTraceFilter.filterFirst(stackTraceHolder, isInline);
-
-        // there are corner cases where exception can have a null or empty stack trace
-        // for example, a custom exception can override getStackTrace() method
-        if (filtered == null) {
-            this.stackTraceLine = "-> at <<unknown line>>";
-            this.sourceFile = "<unknown source file>";
-        } else {
-            this.stackTraceLine = "-> at " + filtered;
-            this.sourceFile = filtered.getFileName();
-        }
-    }
-
-    @Override
-    public String getSourceFile() {
-        return sourceFile;
-    }
-}
diff --git a/src/main/java/org/mockito/internal/debugging/Java9PlusLocationImpl.java b/src/main/java/org/mockito/internal/debugging/Java9PlusLocationImpl.java
deleted file mode 100644
index 219835513..000000000
--- a/src/main/java/org/mockito/internal/debugging/Java9PlusLocationImpl.java
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.debugging;
-
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.stacktrace.StackTraceCleaner;
-import org.mockito.exceptions.stacktrace.StackTraceCleaner.StackFrameMetadata;
-import org.mockito.internal.configuration.plugins.Plugins;
-import org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleaner;
-import org.mockito.invocation.Location;
-
-import java.io.Serializable;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-import java.util.function.Function;
-import java.util.function.Predicate;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-class Java9PlusLocationImpl implements Location, Serializable {
-    private static final long serialVersionUID = 2954388321980069195L;
-
-    private static final String UNEXPECTED_ERROR_SUFFIX =
-            "\nThis is unexpected and is likely due to a change in either Java's StackWalker or Reflection APIs."
-                    + "\nIt's worth trying to upgrade to a newer version of Mockito, or otherwise to file a bug report.";
-
-    private static final String STACK_WALKER = "java.lang.StackWalker";
-    private static final String STACK_FRAME = STACK_WALKER + "$StackFrame";
-    private static final String OPTION = STACK_WALKER + "$Option";
-    private static final String SHOW_REFLECT_FRAMES = "SHOW_REFLECT_FRAMES";
-
-    /**
-     * This is an unfortunate buffer. Inside StackWalker, a buffer is created, which is resized by
-     * doubling. The resizing also allocates a tonne of StackFrame elements. If we traverse more than
-     * BUFFER_SIZE elements, the resulting resize can significantly affect the overall cost of the operation.
-     * If we traverse fewer than this number, we are inefficient. Empirically, 16 is enough stack frames
-     * for a simple stub+call operation to succeed without resizing, as measured on Java 11.
-     */
-    private static final int BUFFER_SIZE = 16;
-
-    private static final Class<?> stackWalkerClazz = clazz(STACK_WALKER);
-    private static final Class<?> stackFrameClazz = clazz(STACK_FRAME);
-    private static final Class<?> optionClazz = clazz(OPTION);
-
-    private static final Object stackWalker = stackWalker();
-    private static final Method walk = walk();
-
-    private static final String PREFIX = "-> at ";
-
-    private static final StackTraceCleaner CLEANER =
-            Plugins.getStackTraceCleanerProvider()
-                    .getStackTraceCleaner(new DefaultStackTraceCleaner());
-
-    /**
-     * In Java, allocating lambdas is cheap, but not free. stream.map(this::doSomething)
-     * will allocate a Function object each time the function is called (although not
-     * per element). By assigning these Functions and Predicates to variables, we can
-     * avoid the memory allocation.
-     */
-    private static final Function<Object, StackFrameMetadata> toStackFrameMetadata =
-            MetadataShim::new;
-
-    private static final Predicate<StackFrameMetadata> cleanerIsIn = CLEANER::isIn;
-
-    private static final int FRAMES_TO_SKIP = framesToSkip();
-
-    private final StackFrameMetadata sfm;
-    private volatile String stackTraceLine;
-
-    Java9PlusLocationImpl(boolean isInline) {
-        this.sfm = getStackFrame(isInline);
-    }
-
-    @Override
-    public String getSourceFile() {
-        return sfm.getFileName();
-    }
-
-    @Override
-    public String toString() {
-        return stackTraceLine();
-    }
-
-    private String stackTraceLine() {
-        if (stackTraceLine == null) {
-            synchronized (this) {
-                if (stackTraceLine == null) {
-                    stackTraceLine = PREFIX + sfm.toString();
-                }
-            }
-        }
-        return stackTraceLine;
-    }
-
-    private static StackFrameMetadata getStackFrame(boolean isInline) {
-        return stackWalk(
-                stream ->
-                        stream.map(toStackFrameMetadata)
-                                .skip(FRAMES_TO_SKIP)
-                                .filter(cleanerIsIn)
-                                .skip(isInline ? 1 : 0)
-                                .findFirst()
-                                .orElseThrow(
-                                        () -> new MockitoException(noStackTraceFailureMessage())));
-    }
-
-    private static boolean usingDefaultStackTraceCleaner() {
-        return CLEANER instanceof DefaultStackTraceCleaner;
-    }
-
-    private static String noStackTraceFailureMessage() {
-        if (usingDefaultStackTraceCleaner()) {
-            return "Mockito could not find the first non-Mockito stack frame."
-                    + UNEXPECTED_ERROR_SUFFIX;
-        } else {
-            String cleanerType = CLEANER.getClass().getName();
-            String fmt =
-                    "Mockito could not find the first non-Mockito stack frame. A custom stack frame cleaner \n"
-                            + "(type %s) is in use and this has mostly likely filtered out all the relevant stack frames.";
-            return String.format(fmt, cleanerType);
-        }
-    }
-
-    /**
-     * In order to trigger the stack walker, we create some reflective frames. These need to be skipped so as to
-     * ensure there are no non-Mockito frames at the top of the stack trace.
-     */
-    private static int framesToSkip() {
-        return stackWalk(
-                stream -> {
-                    List<String> metadata =
-                            stream.map(toStackFrameMetadata)
-                                    .map(StackFrameMetadata::getClassName)
-                                    .collect(Collectors.toList());
-                    return metadata.indexOf(Java9PlusLocationImpl.class.getName());
-                });
-    }
-
-    @SuppressWarnings("unchecked")
-    private static <T> T stackWalk(Function<Stream<Object>, T> function) {
-        try {
-            return (T) walk.invoke(stackWalker, function);
-        } catch (IllegalAccessException e) {
-            throw new MockitoException(
-                    "Unexpected access exception while stack walking." + UNEXPECTED_ERROR_SUFFIX,
-                    e);
-        } catch (InvocationTargetException e) {
-            throw new MockitoException(stackWalkFailureMessage());
-        }
-    }
-
-    private static String stackWalkFailureMessage() {
-        if (usingDefaultStackTraceCleaner()) {
-            return "Caught an unexpected exception while stack walking." + UNEXPECTED_ERROR_SUFFIX;
-        } else {
-            String className = CLEANER.getClass().getName();
-            String fmt =
-                    "Caught an unexpected exception while stack walking."
-                            + "\nThis is likely caused by the custom stack trace cleaner in use (class %s).";
-            return String.format(fmt, className);
-        }
-    }
-
-    private static Method walk() {
-        try {
-            return stackWalkerClazz.getMethod("walk", Function.class);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static Class<?> clazz(String name) {
-        try {
-            return Class.forName(name);
-        } catch (ClassNotFoundException e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    @SuppressWarnings({"unchecked", "rawtypes"})
-    private static Object stackWalker() {
-        try {
-            Set options =
-                    Collections.singleton(Enum.valueOf((Class) optionClazz, SHOW_REFLECT_FRAMES));
-            Method getInstance =
-                    stackWalkerClazz.getDeclaredMethod("getInstance", Set.class, int.class);
-            return getInstance.invoke(null, options, BUFFER_SIZE);
-        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
-            throw new MockitoException(
-                    "Mockito received an exception while trying to acquire a StackWalker."
-                            + UNEXPECTED_ERROR_SUFFIX);
-        }
-    }
-
-    private static final class MetadataShim implements StackFrameMetadata, Serializable {
-        private static final long serialVersionUID = 8491903719411428648L;
-        private static final Method getClassName = getter("getClassName");
-        private static final Method getMethodName = getter("getMethodName");
-        private static final Method getFileName = getter("getFileName");
-        private static final Method getLineNumber = getter("getLineNumber");
-        private static final Method toString = getter(Object.class, "toString");
-
-        private final Object stackFrame;
-
-        private MetadataShim(Object stackFrame) {
-            this.stackFrame = stackFrame;
-        }
-
-        @Override
-        public String getClassName() {
-            return (String) get(getClassName);
-        }
-
-        @Override
-        public String getMethodName() {
-            return (String) get(getMethodName);
-        }
-
-        @Override
-        public String getFileName() {
-            return (String) get(getFileName);
-        }
-
-        @Override
-        public int getLineNumber() {
-            return (int) get(getLineNumber);
-        }
-
-        @Override
-        public String toString() {
-            return (String) get(toString);
-        }
-
-        /**
-         * Ensure that this type remains serializable.
-         */
-        private Object writeReplace() {
-            return new SerializableShim(toStackTraceElement());
-        }
-
-        private StackTraceElement toStackTraceElement() {
-            try {
-                Method method = stackFrameClazz.getMethod("toStackTraceElement");
-                return (StackTraceElement) method.invoke(stackFrame);
-            } catch (InvocationTargetException | NoSuchMethodException | IllegalAccessException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        private Object get(Method handle) {
-            try {
-                return handle.invoke(stackFrame);
-            } catch (InvocationTargetException | IllegalAccessException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        private static Method getter(String name) {
-            return getter(stackFrameClazz, name);
-        }
-
-        private static Method getter(Class<?> clazz, String name) {
-            try {
-                return clazz.getDeclaredMethod(name);
-            } catch (Throwable t) {
-                throw new RuntimeException(t);
-            }
-        }
-    }
-
-    private static final class SerializableShim implements StackFrameMetadata, Serializable {
-        private static final long serialVersionUID = 7908320459080898690L;
-        private final StackTraceElement ste;
-
-        private SerializableShim(StackTraceElement ste) {
-            this.ste = ste;
-        }
-
-        @Override
-        public String getClassName() {
-            return ste.getClassName();
-        }
-
-        @Override
-        public String getMethodName() {
-            return ste.getMethodName();
-        }
-
-        @Override
-        public String getFileName() {
-            return ste.getFileName();
-        }
-
-        @Override
-        public int getLineNumber() {
-            return ste.getLineNumber();
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/debugging/LocationFactory.java b/src/main/java/org/mockito/internal/debugging/LocationFactory.java
index daafddeda..08e441e87 100644
--- a/src/main/java/org/mockito/internal/debugging/LocationFactory.java
+++ b/src/main/java/org/mockito/internal/debugging/LocationFactory.java
@@ -7,8 +7,6 @@ package org.mockito.internal.debugging;
 import org.mockito.invocation.Location;
 
 public final class LocationFactory {
-    private static final Factory factory = createLocationFactory();
-
     private LocationFactory() {}
 
     public static Location create() {
@@ -16,34 +14,6 @@ public final class LocationFactory {
     }
 
     public static Location create(boolean inline) {
-        return factory.create(inline);
-    }
-
-    private interface Factory {
-        Location create(boolean inline);
-    }
-
-    private static Factory createLocationFactory() {
-        try {
-            Class.forName("java.lang.StackWalker");
-            return new Java9PlusLocationFactory();
-        } catch (ClassNotFoundException e) {
-            return new Java8LocationFactory();
-        }
-    }
-
-    private static final class Java8LocationFactory implements Factory {
-        @Override
-        public Location create(boolean inline) {
-            return new Java8LocationImpl(new Throwable(), inline);
-        }
-    }
-
-    private static final class Java9PlusLocationFactory implements Factory {
-
-        @Override
-        public Location create(boolean inline) {
-            return new Java9PlusLocationImpl(inline);
-        }
+        return new LocationImpl(inline);
     }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
index ad8e7e246..20e9d85af 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
@@ -8,6 +8,8 @@ import static org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod;
 import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
 
 import java.io.Serializable;
+import java.time.Duration;
+import java.time.Period;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -17,12 +19,20 @@ import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.SortedSet;
 import java.util.TreeMap;
 import java.util.TreeSet;
-import org.mockito.internal.util.JavaEightUtil;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
+
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.Primitives;
 import org.mockito.invocation.InvocationOnMock;
@@ -129,26 +139,26 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {
             return new TreeMap<>();
         } else if (type == LinkedHashMap.class) {
             return new LinkedHashMap<>();
-        } else if ("java.util.Optional".equals(type.getName())) {
-            return JavaEightUtil.emptyOptional();
-        } else if ("java.util.OptionalDouble".equals(type.getName())) {
-            return JavaEightUtil.emptyOptionalDouble();
-        } else if ("java.util.OptionalInt".equals(type.getName())) {
-            return JavaEightUtil.emptyOptionalInt();
-        } else if ("java.util.OptionalLong".equals(type.getName())) {
-            return JavaEightUtil.emptyOptionalLong();
-        } else if ("java.util.stream.Stream".equals(type.getName())) {
-            return JavaEightUtil.emptyStream();
-        } else if ("java.util.stream.DoubleStream".equals(type.getName())) {
-            return JavaEightUtil.emptyDoubleStream();
-        } else if ("java.util.stream.IntStream".equals(type.getName())) {
-            return JavaEightUtil.emptyIntStream();
-        } else if ("java.util.stream.LongStream".equals(type.getName())) {
-            return JavaEightUtil.emptyLongStream();
-        } else if ("java.time.Duration".equals(type.getName())) {
-            return JavaEightUtil.emptyDuration();
-        } else if ("java.time.Period".equals(type.getName())) {
-            return JavaEightUtil.emptyPeriod();
+        } else if (type == Optional.class) {
+            return Optional.empty();
+        } else if (type == OptionalDouble.class) {
+            return OptionalDouble.empty();
+        } else if (type == OptionalInt.class) {
+            return OptionalInt.empty();
+        } else if (type == OptionalLong.class) {
+            return OptionalLong.empty();
+        } else if (type == Stream.class) {
+            return Stream.empty();
+        } else if (type == DoubleStream.class) {
+            return DoubleStream.empty();
+        } else if (type == IntStream.class) {
+            return IntStream.empty();
+        } else if (type == LongStream.class) {
+            return LongStream.empty();
+        } else if (type == Duration.class) {
+            return Duration.ZERO;
+        } else if (type == Period.class) {
+            return Period.ZERO;
         }
 
         // Let's not care about the rest of collections.
diff --git a/src/main/java/org/mockito/internal/util/JavaEightUtil.java b/src/main/java/org/mockito/internal/util/JavaEightUtil.java
deleted file mode 100644
index 20c6e80c3..000000000
--- a/src/main/java/org/mockito/internal/util/JavaEightUtil.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Copyright (c) 2016 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-
-import org.mockito.creation.instance.InstantiationException;
-
-/**
- * Helper class to work with features that were introduced in Java versions after 1.5.
- * This class uses reflection in most places to avoid coupling with a newer JDK.
- */
-public final class JavaEightUtil {
-
-    // No need for volatile, these optionals are already safe singletons.
-    private static Object emptyOptional;
-    private static Object emptyOptionalDouble;
-    private static Object emptyOptionalInt;
-    private static Object emptyOptionalLong;
-    private static Object emptyDuration;
-    private static Object emptyPeriod;
-
-    private JavaEightUtil() {
-        // utility class
-    }
-
-    /**
-     * Creates an empty Optional using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty Optional.
-     */
-    public static Object emptyOptional() {
-        // no need for double-checked locking
-        if (emptyOptional != null) {
-            return emptyOptional;
-        }
-
-        return emptyOptional = invokeNullaryFactoryMethod("java.util.Optional", "empty");
-    }
-
-    /**
-     * Creates an empty OptionalDouble using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty OptionalDouble.
-     */
-    public static Object emptyOptionalDouble() {
-        // no need for double-checked locking
-        if (emptyOptionalDouble != null) {
-            return emptyOptionalDouble;
-        }
-
-        return emptyOptionalDouble =
-                invokeNullaryFactoryMethod("java.util.OptionalDouble", "empty");
-    }
-
-    /**
-     * Creates an empty OptionalInt using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty OptionalInt.
-     */
-    public static Object emptyOptionalInt() {
-        // no need for double-checked locking
-        if (emptyOptionalInt != null) {
-            return emptyOptionalInt;
-        }
-
-        return emptyOptionalInt = invokeNullaryFactoryMethod("java.util.OptionalInt", "empty");
-    }
-
-    /**
-     * Creates an empty OptionalLong using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty OptionalLong.
-     */
-    public static Object emptyOptionalLong() {
-        // no need for double-checked locking
-        if (emptyOptionalLong != null) {
-            return emptyOptionalLong;
-        }
-
-        return emptyOptionalLong = invokeNullaryFactoryMethod("java.util.OptionalLong", "empty");
-    }
-
-    /**
-     * Creates an empty Stream using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty Stream.
-     */
-    public static Object emptyStream() {
-        // note: the empty stream can not be stored as a singleton.
-        return invokeNullaryFactoryMethod("java.util.stream.Stream", "empty");
-    }
-
-    /**
-     * Creates an empty DoubleStream using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty DoubleStream.
-     */
-    public static Object emptyDoubleStream() {
-        // note: the empty stream can not be stored as a singleton.
-        return invokeNullaryFactoryMethod("java.util.stream.DoubleStream", "empty");
-    }
-
-    /**
-     * Creates an empty IntStream using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty IntStream.
-     */
-    public static Object emptyIntStream() {
-        // note: the empty stream can not be stored as a singleton.
-        return invokeNullaryFactoryMethod("java.util.stream.IntStream", "empty");
-    }
-
-    /**
-     * Creates an empty LongStream using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty LongStream.
-     */
-    public static Object emptyLongStream() {
-        // note: the empty stream can not be stored as a singleton.
-        return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
-    }
-
-    /**
-     * Creates an empty Duration using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty (ZERO) Duration.
-     */
-    public static Object emptyDuration() {
-        // no need for double-checked locking
-        if (emptyDuration != null) {
-            return emptyDuration;
-        }
-
-        return emptyDuration = getStaticFieldValue("java.time.Duration", "ZERO");
-    }
-
-    /**
-     * Creates an empty Period using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @return an empty (ZERO) Period.
-     */
-    public static Object emptyPeriod() {
-        // no need for double-checked locking
-        if (emptyPeriod != null) {
-            return emptyPeriod;
-        }
-
-        return emptyPeriod = getStaticFieldValue("java.time.Period", "ZERO");
-    }
-
-    /**
-     * Invokes a nullary static factory method using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @param fqcn The fully qualified class name of the type to be produced.
-     * @param methodName The name of the factory method.
-     * @return the object produced.
-     */
-    private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
-        try {
-            final Method method = getMethod(fqcn, methodName);
-            return method.invoke(null);
-            // any exception is really unexpected since the type name has
-            // already been verified
-        } catch (final Exception e) {
-            throw new InstantiationException(
-                    String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
-        }
-    }
-
-    /**
-     * Gets a value of the classes' field using reflection to stay backwards-compatible with older JDKs.
-     *
-     * @param fqcn The fully qualified class name of the type to be produced.
-     * @param fieldName The name of th classes' field which value is going to be returned.
-     * @return the restored value.
-     */
-    private static Object getStaticFieldValue(final String fqcn, final String fieldName) {
-        try {
-            final Class<?> type = getClass(fqcn);
-            final Field field = type.getField(fieldName);
-            return field.get(null);
-            // any exception is really unexpected since the type name has
-            // already been verified
-        } catch (Exception e) {
-            throw new InstantiationException(
-                    String.format("Could not get %s#%s(): %s", fqcn, fieldName, e), e);
-        }
-    }
-
-    /**
-     * Returns the {@code Class} object associated with the class or interface with the given string name.
-     *
-     * @param fqcn The fully qualified class name of the type to be produced.
-     * @return the Class object for the class with the specified name.
-     */
-    private static Class<?> getClass(String fqcn) {
-        try {
-            return Class.forName(fqcn);
-            // any exception is really unexpected since the type name has
-            // already been verified
-        } catch (ClassNotFoundException e) {
-            throw new InstantiationException(String.format("Could not find %s: %s", fqcn, e), e);
-        }
-    }
-
-    /**
-     * Returns a Method object that reflects the specified public member method of the class or interface represented by the fully qualified class name.
-     *
-     * @param fqcn The fully qualified class name of the type to be produced.
-     * @param methodName The name of the method.
-     * @param parameterClasses The list of parameters.
-     * @return The Method object that matches the specified name and parameterTypes.
-     */
-    private static Method getMethod(
-            final String fqcn, final String methodName, final Class<?>... parameterClasses) {
-        try {
-            final Class<?> type = getClass(fqcn);
-            return type.getMethod(methodName, parameterClasses);
-        } catch (Exception e) {
-            throw new InstantiationException(
-                    String.format("Could not find %s#%s(): %s", fqcn, methodName, e), e);
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/util/Platform.java b/src/main/java/org/mockito/internal/util/Platform.java
index fde59fbbe..6ff037828 100644
--- a/src/main/java/org/mockito/internal/util/Platform.java
+++ b/src/main/java/org/mockito/internal/util/Platform.java
@@ -7,15 +7,9 @@ package org.mockito.internal.util;
 import static org.mockito.internal.util.StringUtil.join;
 
 import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 public abstract class Platform {
 
-    private static final Pattern JAVA_8_RELEASE_VERSION_SCHEME =
-            Pattern.compile("1\\.8\\.0_(\\d+)(?:-ea)?(?:-b\\d+)?");
-    private static final Pattern JAVA_8_DEV_VERSION_SCHEME =
-            Pattern.compile("1\\.8\\.0b\\d+_u(\\d+)");
     public static final String JAVA_VERSION = System.getProperty("java.specification.version");
     public static final String JVM_VERSION = System.getProperty("java.runtime.version");
     public static final String JVM_VENDOR = System.getProperty("java.vm.vendor");
@@ -68,31 +62,6 @@ public abstract class Platform {
         return description;
     }
 
-    public static boolean isJava8BelowUpdate45() {
-        if (JVM_VERSION == null) {
-            return false;
-        } else {
-            return isJava8BelowUpdate45(JVM_VERSION);
-        }
-    }
-
-    static boolean isJava8BelowUpdate45(String jvmVersion) {
-        Matcher matcher = JAVA_8_RELEASE_VERSION_SCHEME.matcher(jvmVersion);
-        if (matcher.matches()) {
-            int update = Integer.parseInt(matcher.group(1));
-            return update < 45;
-        }
-
-        matcher = JAVA_8_DEV_VERSION_SCHEME.matcher(jvmVersion);
-        if (matcher.matches()) {
-            int update = Integer.parseInt(matcher.group(1));
-            return update < 45;
-        }
-
-        matcher = Pattern.compile("1\\.8\\.0-b\\d+").matcher(jvmVersion);
-        return matcher.matches();
-    }
-
     public static String warnForVM(
             String vmName1, String warnMessage1, String vmName2, String warnMessage2) {
         return warnForVM(JVM_NAME, vmName1, warnMessage1, vmName2, warnMessage2);
diff --git a/src/test/java/org/mockito/internal/util/PlatformTest.java b/src/test/java/org/mockito/internal/util/PlatformTest.java
index d4c453386..42f59a1bc 100644
--- a/src/test/java/org/mockito/internal/util/PlatformTest.java
+++ b/src/test/java/org/mockito/internal/util/PlatformTest.java
@@ -63,34 +63,6 @@ public class PlatformTest {
                 .isEqualTo("");
     }
 
-    @Test
-    public void should_parse_open_jdk_string_and_report_wether_below_or_nut_update_45() {
-        // Given
-        // Sources :
-        //  - https://www.oracle.com/java/technologies/javase/versioning-naming.html
-        //  - https://www.oracle.com/java/technologies/javase/jdk7-naming.html
-        //  - https://www.oracle.com/java/technologies/javase/jdk8-naming.html
-        //  -
-        // https://stackoverflow.com/questions/35844985/how-do-we-get-sr-and-fp-of-ibm-jre-using-java
-        //  -
-        // https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.80.doc/user/build_number.html
-        Map<String, Boolean> versions = new HashMap<>();
-        versions.put("1.8.0_92-b14", false);
-        versions.put("1.8.0-b24", true);
-        versions.put("1.8.0_5", true);
-        versions.put("1.8.0b5_u44", true);
-        versions.put("1.8.0b5_u92", false);
-        versions.put("1.7.0_4", false);
-        versions.put("1.4.0_03-b04", false);
-        versions.put("1.4.0_03-ea-b01", false);
-        versions.put("pxi3270_27sr4-20160303_03 (SR4)", false);
-        versions.put("pwi3260sr11-20120412_01 (SR11)", false);
-        versions.put("pwa6480sr1fp10-20150711_01 (SR1 FP10)", false);
-        versions.put("null", false);
-
-        assertPlatformParsesCorrectlyVariousVersionScheme(versions);
-    }
-
     @Test
     public void should_parse_open_jdk9_string() {
         // The tested method targets Java 8 but should be able to parse other Java version numbers
@@ -140,9 +112,7 @@ public class PlatformTest {
 
     private void assertPlatformParsesCorrectlyVariousVersionScheme(Map<String, Boolean> versions) {
         for (Map.Entry<String, Boolean> version : versions.entrySet()) {
-            assertThat(Platform.isJava8BelowUpdate45(version.getKey()))
-                    .describedAs(version.getKey())
-                    .isEqualTo(version.getValue());
+            assertThat(version.getValue()).describedAs(version.getKey()).isEqualTo(false);
         }
     }
 }
diff --git a/subprojects/androidTest/androidTest.gradle b/subprojects/androidTest/androidTest.gradle
index 037b99cf7..2176b5052 100644
--- a/subprojects/androidTest/androidTest.gradle
+++ b/subprojects/androidTest/androidTest.gradle
@@ -30,7 +30,7 @@ android {
         targetCompatibility JavaVersion.VERSION_11
     }
     kotlinOptions {
-        jvmTarget = '1.8'
+        jvmTarget = '11'
     }
 }
 
diff --git a/subprojects/kotlinReleaseCoroutinesTest/kotlinReleaseCoroutinesTest.gradle b/subprojects/kotlinReleaseCoroutinesTest/kotlinReleaseCoroutinesTest.gradle
index a8512591c..284b3bdfb 100644
--- a/subprojects/kotlinReleaseCoroutinesTest/kotlinReleaseCoroutinesTest.gradle
+++ b/subprojects/kotlinReleaseCoroutinesTest/kotlinReleaseCoroutinesTest.gradle
@@ -1,3 +1,6 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
+
 buildscript {
     repositories {
         mavenCentral()
@@ -17,6 +20,15 @@ repositories {
     maven { url 'https://dl.bintray.com/kotlin/kotlin-eap' }
 }
 
+sourceCompatibility = 11
+targetCompatibility = 11
+
+tasks.withType(KotlinCompile).configureEach {
+    compilerOptions {
+        jvmTarget = JvmTarget.JVM_11
+    }
+}
+
 dependencies {
     testImplementation project(":")
     testImplementation libraries.junit4
diff --git a/subprojects/kotlinTest/kotlinTest.gradle b/subprojects/kotlinTest/kotlinTest.gradle
index 55c8e8036..99397def9 100644
--- a/subprojects/kotlinTest/kotlinTest.gradle
+++ b/subprojects/kotlinTest/kotlinTest.gradle
@@ -1,3 +1,6 @@
+import org.jetbrains.kotlin.gradle.dsl.JvmTarget
+import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
+
 plugins {
     id 'org.jetbrains.kotlin.jvm'
     id 'java'
@@ -7,6 +10,15 @@ description = "Kotlin tests for Mockito."
 
 apply from: "$rootDir/gradle/dependencies.gradle"
 
+sourceCompatibility = 11
+targetCompatibility = 11
+
+tasks.withType(KotlinCompile).configureEach {
+    compilerOptions {
+        jvmTarget = JvmTarget.JVM_11
+    }
+}
+
 dependencies {
     testImplementation project(":")
     testImplementation libraries.junit4
