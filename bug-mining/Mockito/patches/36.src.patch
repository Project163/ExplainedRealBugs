diff --git a/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockBytecodeGenerator.java b/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockBytecodeGenerator.java
index 8d7c42d25..4c50d90f6 100644
--- a/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockBytecodeGenerator.java
+++ b/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockBytecodeGenerator.java
@@ -5,9 +5,17 @@ import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
+import net.bytebuddy.implementation.FieldAccessor;
+import net.bytebuddy.implementation.Implementation;
+import net.bytebuddy.implementation.MethodDelegation;
 import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
 import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
+import net.bytebuddy.implementation.bind.annotation.FieldProxy;
 import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher;
+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher.FieldGetter;
+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher.FieldSetter;
+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.MockAccess;
 import org.mockito.internal.creation.util.SearchingClassLoader;
 
 import java.util.Random;
@@ -15,21 +23,22 @@ import java.util.Random;
 import static net.bytebuddy.description.modifier.FieldManifestation.FINAL;
 import static net.bytebuddy.description.modifier.Ownership.STATIC;
 import static net.bytebuddy.description.modifier.Visibility.PRIVATE;
-import static net.bytebuddy.implementation.FieldAccessor.ofBeanProperty;
 import static net.bytebuddy.implementation.MethodDelegation.to;
-import static net.bytebuddy.implementation.MethodDelegation.toInstanceField;
 import static net.bytebuddy.matcher.ElementMatchers.*;
 
 class MockBytecodeGenerator {
     private final ByteBuddy byteBuddy;
     private final Random random;
+    private final Implementation delegation;
 
     public MockBytecodeGenerator() {
         byteBuddy = new ByteBuddy(ClassFileVersion.JAVA_V5)
-//                .withIgnoredMethods(isBridge())
                 .withDefaultMethodAttributeAppender(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE)
                 .withAttribute(TypeAttributeAppender.ForSuperType.INSTANCE);
 
+        delegation = MethodDelegation.to(InterceptionDispatcher.class)
+                                     .appendParameterBinder(FieldProxy.Binder.install(FieldGetter.class,
+                                                                                      FieldSetter.class));
         random = new Random();
     }
 
@@ -38,9 +47,9 @@ class MockBytecodeGenerator {
                 byteBuddy.subclass(features.mockedType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
                          .name(nameFor(features.mockedType))
                          .implement(features.interfaces.toArray(new Class<?>[features.interfaces.size()]))
-                         .method(any()).intercept(toInstanceField(MockMethodInterceptor.class, "mockitoInterceptor")
-                                                          .filter(isDeclaredBy(MockMethodInterceptor.class)))
-                         .implement(MockMethodInterceptor.MockAccess.class).intercept(ofBeanProperty())
+                         .method(any()).intercept(delegation)
+                         .defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
+                         .implement(MockAccess.class).intercept(FieldAccessor.ofBeanProperty())
                          .method(isHashCode()).intercept(to(MockMethodInterceptor.ForHashCode.class))
                          .method(isEquals()).intercept(to(MockMethodInterceptor.ForEquals.class))
                          .defineField("serialVersionUID", long.class, STATIC, PRIVATE, FINAL).value(42L);
@@ -48,18 +57,19 @@ class MockBytecodeGenerator {
             builder = builder.implement(CrossClassLoaderSerializableMock.class)
                              .intercept(to(MockMethodInterceptor.ForWriteReplace.class));
         }
-        Class<?>[] allMockedTypes = new Class<?>[features.interfaces.size() + 1];
-        allMockedTypes[0] = features.mockedType;
-//            System.arraycopy(interfaces.toArray(), 0, allMockedTypes, 1, interfaces.size());
-        int index = 1;
-        for (Class<?> type : features.interfaces) {
-            allMockedTypes[index++] = type;
-        }
         return builder.make()
-                      .load(SearchingClassLoader.combineLoadersOf(allMockedTypes), ClassLoadingStrategy.Default.INJECTION)
+                      .load(SearchingClassLoader.combineLoadersOf(allMockedTypes(features)), ClassLoadingStrategy.Default.INJECTION)
                       .getLoaded();
     }
 
+    private <T> Class<?>[] allMockedTypes(MockFeatures<T> features) {
+        Class<?>[] allMockedTypes = new Class<?>[features.interfaces.size() + 1];
+        allMockedTypes[0] = features.mockedType;
+        System.arraycopy(features.interfaces.toArray(), 0,
+                         (Object[]) allMockedTypes, 1, features.interfaces.size());
+        return allMockedTypes;
+    }
+
     // TODO inspect naming strategy (for OSGI, signed package, java.* (and bootstrap classes), etc...)
     private String nameFor(Class<?> type) {
         String typeName = type.getName();
diff --git a/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java b/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
index c70d849dc..18b6956f3 100644
--- a/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
+++ b/mockmaker/bytebuddy/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
@@ -1,9 +1,6 @@
 package org.mockito.internal.creation.bytebuddy;
 
-import java.io.ObjectStreamException;
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.util.concurrent.Callable;
+import net.bytebuddy.implementation.bind.annotation.*;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.DelegatingMethod;
 import org.mockito.internal.invocation.MockitoMethod;
@@ -11,14 +8,11 @@ import org.mockito.internal.invocation.SerializableMethod;
 import org.mockito.internal.progress.SequenceNumber;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
-import net.bytebuddy.implementation.bind.annotation.AllArguments;
-import net.bytebuddy.implementation.bind.annotation.Argument;
-import net.bytebuddy.implementation.bind.annotation.BindingPriority;
-import net.bytebuddy.implementation.bind.annotation.DefaultCall;
-import net.bytebuddy.implementation.bind.annotation.Origin;
-import net.bytebuddy.implementation.bind.annotation.RuntimeType;
-import net.bytebuddy.implementation.bind.annotation.SuperCall;
-import net.bytebuddy.implementation.bind.annotation.This;
+
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.util.concurrent.Callable;
 
 public class MockMethodInterceptor implements Serializable {
 
@@ -122,8 +116,53 @@ public class MockMethodInterceptor implements Serializable {
         }
     }
 
-    public static interface MockAccess {
+    public interface MockAccess {
         MockMethodInterceptor getMockitoInterceptor();
         void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
     }
+
+    public static class InterceptionDispatcher {
+        public interface FieldGetter<T> {
+            T getValue();
+        }
+        public interface FieldSetter<T> {
+            void setValue(T value);
+        }
+
+        @RuntimeType
+        @BindingPriority(BindingPriority.DEFAULT * 2)
+        public static Object interceptSuperCallable(@This Object mock,
+                                                    @FieldProxy("mockitoInterceptor") FieldGetter<MockMethodInterceptor> fieldGetter,
+                                                    @Origin Method invokedMethod,
+                                                    @AllArguments Object[] arguments,
+                                                    @SuperCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
+            MockMethodInterceptor interceptor = fieldGetter.getValue();
+            if (interceptor == null) {
+                return null;
+            }
+            return interceptor.doIntercept(
+                    mock,
+                    invokedMethod,
+                    arguments,
+                    new InterceptedInvocation.SuperMethod.FromCallable(superCall)
+            );
+        }
+
+        @RuntimeType
+        public static Object interceptAbstract(@This Object mock,
+                                               @FieldProxy("mockitoInterceptor") FieldGetter<MockMethodInterceptor> fieldGetter,
+                                               @Origin(cache = true) Method invokedMethod,
+                                               @AllArguments Object[] arguments) throws Throwable {
+            MockMethodInterceptor interceptor = fieldGetter.getValue();
+            if (interceptor == null) {
+                return null;
+            }
+            return interceptor.doIntercept(
+                    mock,
+                    invokedMethod,
+                    arguments,
+                    InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE
+            );
+        }
+    }
 }
