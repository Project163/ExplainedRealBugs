diff --git a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
index 0fc9f105b..79dd049ae 100644
--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
@@ -33,7 +33,7 @@ import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
  *   <li>for each fields of a class in @InjectMocks type hierarchy
  *     <ul>
  *     <li>make a copy of mock candidates
- *     <li>order fields rom sub-type to super-type, then by field name
+ *     <li>order fields from sub-type to super-type, then by field name
  *     <li>for the list of fields in a class try two passes of :
  *         <ul>
  *             <li>find mock candidate by type
@@ -59,7 +59,6 @@ import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;
 public class PropertyAndSetterInjection extends MockInjectionStrategy {
 
     private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));
-    private final Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();
 
     private final ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {
         public boolean isOut(Field object) {
@@ -125,27 +124,45 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
         List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());
         declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);
 
-        Collections.sort(declaredFields, superTypesLast);
+        sortSuperTypesLast(declaredFields);
 
         return declaredFields;
     }
 
-    static class FieldTypeAndNameComparator implements Comparator<Field> {
-        public int compare(Field field1, Field field2) {
-            Class<?> field1Type = field1.getType();
-            Class<?> field2Type = field2.getType();
+    /**
+     * Sort first by name, then move any fields after their supertypes.
+     */
+    static void sortSuperTypesLast(List<Field> fields) {
+        Collections.sort(fields, compareFieldsByName);
 
-            // if same type, compares on field name
-            if (field1Type == field2Type) {
-                return field1.getName().compareTo(field2.getName());
-            }
-            if(field1Type.isAssignableFrom(field2Type)) {
-                return 1;
+        int i = 0;
+
+        while (i < fields.size() - 1) {
+            Field f = fields.get(i);
+            Class<?> ft = f.getType();
+            int newPos = i;
+            for (int j = i + 1; j < fields.size(); j++) {
+                Class<?> t = fields.get(j).getType();
+
+                if (ft != t && ft.isAssignableFrom(t)) {
+                    newPos = j;
+                }
             }
-            if(field2Type.isAssignableFrom(field1Type)) {
-                return -1;
+
+            if (newPos == i) {
+                i++;
+            } else {
+                fields.remove(i);
+                fields.add(newPos, f);
             }
-            return 0;
         }
     }
+
+    private static Comparator<Field> compareFieldsByName = new Comparator<Field>()
+    {
+        public int compare(Field o1, Field o2)
+        {
+            return o1.getName().compareTo(o2.getName());
+        }
+    };
 }
diff --git a/test/org/mockito/internal/configuration/injection/FieldTypeAndNameComparatorTest.java b/test/org/mockito/internal/configuration/injection/FieldTypeAndNameComparatorTest.java
index 089dd8d8b..f0f771f70 100644
--- a/test/org/mockito/internal/configuration/injection/FieldTypeAndNameComparatorTest.java
+++ b/test/org/mockito/internal/configuration/injection/FieldTypeAndNameComparatorTest.java
@@ -3,17 +3,40 @@ package org.mockito.internal.configuration.injection;
 import org.junit.Test;
 
 import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 import static org.fest.assertions.Assertions.assertThat;
 
 @SuppressWarnings("unused")
 public class FieldTypeAndNameComparatorTest {
-
-    private static Comparator<Field> cmp = new PropertyAndSetterInjection.FieldTypeAndNameComparator();
+    /**
+     * A Comparator that behaves like the old one, so the existing tests
+     * continue to work.
+     */
+    private static Comparator<Field> cmp = new Comparator<Field>()
+    {
+        public int compare(Field o1, Field o2)
+        {
+            if (o1.equals(o2)) {
+                return 0;
+            }
+
+            List<Field> l = new ArrayList<Field>(Arrays.asList(o1, o2));
+            PropertyAndSetterInjection.sortSuperTypesLast(l);
+
+            if (l.get(0) == o1) {
+                return -1;
+            } else {
+                return 1;
+            }
+        }
+    };
 
     private Object objectA;
     private Object objectB;
@@ -24,6 +47,13 @@ public class FieldTypeAndNameComparatorTest {
     private Integer integerA;
     private Integer integerB;
 
+    private Iterable<?> iterableA;
+
+    private Number xNumber;
+    private Iterable<?> yIterable;
+    private Integer zInteger;
+
+
     @Test
     public void when_same_type_the_order_is_based_on_field_name() throws Exception {
         assertThat(cmp.compare(field("objectA"), field("objectB"))).isEqualTo(-1);
@@ -48,7 +78,7 @@ public class FieldTypeAndNameComparatorTest {
                 field("integerA")
         );
 
-        Collections.sort(unsortedFields, cmp);
+        PropertyAndSetterInjection.sortSuperTypesLast(unsortedFields);
 
         assertThat(unsortedFields).containsSequence(
                 field("integerA"),
@@ -76,6 +106,45 @@ public class FieldTypeAndNameComparatorTest {
         );
     }
 
+    @Test
+    public void fields_sort_consistently_when_interfaces_are_included() throws NoSuchFieldException
+    {
+        assertSortConsistently(field("iterableA"), field("numberA"), field("integerA"));
+    }
+
+    @Test
+    public void fields_sort_consistently_when_names_and_type_indicate_different_order() throws NoSuchFieldException
+    {
+        assertSortConsistently(field("xNumber"), field("yIterable"), field("zInteger"));
+    }
+
+    /**
+     * Assert that these fields sort in the same order no matter which order
+     * they start in.
+     */
+    private static void assertSortConsistently(Field a, Field b, Field c)
+    {
+        Field[][] initialOrderings = {
+                {a, b, c},
+                {a, c, b},
+                {b, a, c},
+                {b, c, a},
+                {c, a, b},
+                {c, b, a}
+        };
+
+        Set<List<Field>> results = new HashSet<List<Field>>();
+
+        for (Field[] o : initialOrderings) {
+            List<Field> l = new ArrayList<Field>(Arrays.asList(o));
+
+            PropertyAndSetterInjection.sortSuperTypesLast(l);
+            results.add(l);
+        }
+
+        assertThat(results).hasSize(1);
+    }
+
     private Field field(String field) throws NoSuchFieldException {
         return getClass().getDeclaredField(field);
     }
