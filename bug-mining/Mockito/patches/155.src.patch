diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
index 7487e89cb..ff6b7942d 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
@@ -8,12 +8,18 @@ import static org.mockito.internal.exceptions.Reporter.smartNullPointerException
 import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
 
 import java.io.Serializable;
+import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Modifier;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
 
 import org.mockito.Mockito;
 import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.util.MockUtil;
+import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.invocation.Location;
+import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 /**
@@ -46,15 +52,108 @@ public class ReturnsSmartNulls implements Answer<Object>, Serializable {
             return defaultReturnValue;
         }
         Class<?> type = invocation.getMethod().getReturnType();
-        if (!type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {
+
+        final Type returnType = invocation.getMethod().getGenericReturnType();
+        if (returnType instanceof TypeVariable) {
+            type = findTypeFromGeneric(invocation, (TypeVariable) returnType);
+            if (type != null) {
+                defaultReturnValue = delegateChains(type);
+            }
+        }
+        if (defaultReturnValue != null) {
+            return defaultReturnValue;
+        }
+
+        if (type != null && !type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {
             final Location location = new LocationImpl();
             return Mockito.mock(type, new ThrowsSmartNullPointer(invocation, location));
         }
         return null;
     }
 
+    /**
+     * Try to resolve the result value using {@link ReturnsEmptyValues} and {@link ReturnsMoreEmptyValues}.
+     *
+     * This will try to use all parent class (superclass & interfaces) to retrieve the value..
+     *
+     * @param type the return type of the method
+     * @return a non-null instance if the type has been resolve. Null otherwise.
+     */
+    private Object delegateChains(final Class<?> type) {
+        final ReturnsEmptyValues returnsEmptyValues = new ReturnsEmptyValues();
+        Object result = returnsEmptyValues.returnValueFor(type);
+
+        if (result == null) {
+            Class<?> emptyValueForClass = type;
+            while (emptyValueForClass != null && result == null) {
+                final Class<?>[] classes = emptyValueForClass.getInterfaces();
+                for (Class<?> clazz : classes) {
+                    result = returnsEmptyValues.returnValueFor(clazz);
+                    if (result != null) {
+                        break;
+                    }
+                }
+                emptyValueForClass = emptyValueForClass.getSuperclass();
+            }
+        }
+
+        if (result == null) {
+            result = new ReturnsMoreEmptyValues().returnValueFor(type);
+        }
+
+        return result;
+    }
+
+    /**
+     * Retrieve the expected type when it came from a primitive. If the type cannot be retrieve, return null.
+     *
+     * @param invocation the current invocation
+     * @param returnType the expected return type
+     * @return the type or null if not found
+     */
+    private Class<?> findTypeFromGeneric(final InvocationOnMock invocation, final TypeVariable returnType) {
+        // Class level
+        final MockCreationSettings mockSettings = MockUtil.getMockHandler(invocation.getMock()).getMockSettings();
+        final GenericMetadataSupport returnTypeSupport = GenericMetadataSupport
+            .inferFrom(mockSettings.getTypeToMock())
+            .resolveGenericReturnType(invocation.getMethod());
+        final Class<?> rawType = returnTypeSupport.rawType();
+
+        // Method level
+        if (rawType == Object.class) {
+            return findTypeFromGenericInArguments(invocation, returnType);
+        }
+        return rawType;
+    }
+
+    /**
+     * Find a return type using generic arguments provided by the calling method.
+     *
+     * @param invocation the current invocation
+     * @param returnType the expected return type
+     * @return the return type or null if the return type cannot be found
+     */
+    private Class<?> findTypeFromGenericInArguments(final InvocationOnMock invocation, final TypeVariable returnType) {
+        final Type[] parameterTypes = invocation.getMethod().getGenericParameterTypes();
+        for (int i = 0; i < parameterTypes.length; i++) {
+            Type argType = parameterTypes[i];
+            if (returnType.equals(argType)) {
+                return invocation.getArgument(i).getClass();
+            }
+            if (argType instanceof GenericArrayType) {
+                argType = ((GenericArrayType) argType).getGenericComponentType();
+                if (returnType.equals(argType)) {
+                    return invocation.getArgument(i).getClass();
+                }
+            }
+        }
+        return null;
+    }
+
     private static class ThrowsSmartNullPointer implements Answer {
+
         private final InvocationOnMock unstubbedInvocation;
+
         private final Location location;
 
         public ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {
@@ -65,7 +164,7 @@ public class ReturnsSmartNulls implements Answer<Object>, Serializable {
         public Object answer(InvocationOnMock currentInvocation) throws Throwable {
             if (isToStringMethod(currentInvocation.getMethod())) {
                 return "SmartNull returned by this unstubbed method call on a mock:\n" +
-                        unstubbedInvocation.toString();
+                    unstubbedInvocation.toString();
             }
 
             throw smartNullPointerException(unstubbedInvocation.toString(), location);
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
index 228c56a1b..8acf0eadc 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
@@ -4,15 +4,29 @@
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
+import org.assertj.core.api.Assertions;
+import org.assertj.core.api.ThrowableAssert;
 import org.junit.Test;
 import org.mockito.exceptions.verification.SmartNullPointerException;
+import org.mockito.internal.debugging.LocationImpl;
+import org.mockito.internal.invocation.InterceptedInvocation;
+import org.mockito.internal.invocation.SerializableMethod;
+import org.mockito.internal.invocation.mockref.MockStrongReference;
 import org.mockito.stubbing.Answer;
 import org.mockitoutil.TestBase;
 
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
 
 public class ReturnsSmartNullsTest extends TestBase {
 
@@ -85,4 +99,274 @@ public class ReturnsSmartNullsTest extends TestBase {
                 .hasMessageContaining("lumpa");
         }
     }
+
+    interface GenericFoo<T> {
+        T get();
+    }
+
+    interface GenericFooBar extends GenericFoo<Foo> {
+        <I> I method();
+        <I> I methodWithArgs(int firstArg, I secondArg);
+        <I> I methodWithVarArgs(int firstArg, I... secondArg);
+    }
+
+    @Test
+    public void should_return_an_object_that_has_been_defined_with_class_generic() throws Throwable {
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Foo smartNull = (Foo) answer.answer(invocationOf(GenericFooBar.class, "get"));
+
+        assertThat(smartNull.toString())
+            .contains("SmartNull returned by")
+            .contains("genericFooBar.get()");
+    }
+
+    @Test
+    public void should_return_an_object_that_has_been_defined_with_method_generic() throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        String smartNull = (String) answer.answer(invocationOf(GenericFooBar.class, "method"));
+
+        assertThat(smartNull)
+            .isNull();
+    }
+
+    private static <T> InterceptedInvocation invocationMethodWithArgs(final T obj) throws NoSuchMethodException {
+        return new InterceptedInvocation(
+            new MockStrongReference<Object>(mock(GenericFooBar.class), false),
+            new SerializableMethod(GenericFooBar.class.getMethod("methodWithArgs", int.class, Object.class)),
+            new Object[]{1, obj},
+            InterceptedInvocation.NO_OP,
+            new LocationImpl(),
+            1);
+    }
+
+    @Test
+    public void should_return_a_String_that_has_been_defined_with_method_generic_and_provided_in_argument() throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs("secondArg"));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(String.class)
+            .asString()
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_empty_list_that_has_been_defined_with_method_generic_and_provided_in_argument() throws Throwable {
+
+        final List<String> list = Collections.singletonList("String");
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(list));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(List.class);
+        assertThat((List) smartNull)
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_empty_map_that_has_been_defined_with_method_generic_and_provided_in_argument() throws Throwable {
+
+        final Map<String, String> map = new HashMap<String, String>();
+        map.put("key-1", "value-1");
+        map.put("key-2", "value-2");
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(map));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(Map.class);
+        assertThat((Map) smartNull)
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_empty_set_that_has_been_defined_with_method_generic_and_provided_in_argument() throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull =
+            answer.answer(invocationMethodWithArgs(new HashSet<String>(Arrays.asList("set-1", "set-2"))));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(Set.class);
+        assertThat((Set) smartNull)
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_new_mock_that_has_been_defined_with_method_generic_and_provided_in_argument() throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+        final Foo mock = mock(Foo.class);
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(mock));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isNotSameAs(mock);
+        assertThat(smartNull.toString())
+            .contains("SmartNull returned by")
+            .contains("genericFooBar.methodWithArgs(");
+    }
+
+    @Test
+    public void should_return_an_Object_that_has_been_defined_with_method_generic_and_provided_in_argument() throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithArgs(new Object() {
+        }));
+
+        assertThat(smartNull.toString())
+            .contains("SmartNull returned by")
+            .contains("genericFooBar.methodWithArgs(");
+    }
+
+    @Test
+    public void should_throw_a_error_on_invocation_of_returned_mock() throws Throwable {
+
+        final Answer<Object> answer = new ReturnsSmartNulls();
+        final Foo mock = mock(Foo.class);
+
+        final Throwable throwable = Assertions.catchThrowable(new ThrowableAssert.ThrowingCallable() {
+            @Override
+            public void call() throws Throwable {
+                ((Foo) answer.answer(invocationMethodWithArgs(mock))).get();
+            }
+        });
+
+        Assertions.assertThat(throwable)
+            .isInstanceOf(SmartNullPointerException.class)
+            .hasMessageContaining("genericFooBar.methodWithArgs(")
+            .hasMessageContaining("1")
+            .hasMessageContaining(mock.toString());
+    }
+
+    private static <T> InterceptedInvocation invocationMethodWithVarArgs(final T[] obj) throws NoSuchMethodException {
+        return new InterceptedInvocation(
+            new MockStrongReference<Object>(mock(GenericFooBar.class), false),
+            new SerializableMethod(GenericFooBar.class.getMethod("methodWithVarArgs", int.class, Object[].class)),
+            new Object[]{1, obj},
+            InterceptedInvocation.NO_OP,
+            new LocationImpl(),
+            1);
+    }
+
+    @Test
+    public void should_return_a_String_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+        throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new String[]{"varArg-1", "varArg-2"}));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(String.class)
+            .asString()
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_empty_list_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+        throws Throwable {
+
+        final List<String> arg1 = Collections.singletonList("String");
+        final List<String> arg2 = Arrays.asList("str-1", "str-2");
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new List[]{arg1, arg2}));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(List.class);
+        assertThat((List) smartNull)
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_empty_map_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+        throws Throwable {
+
+        final Map<String, String> map1 = new HashMap<String, String>() {{
+            put("key-1", "value-1");
+            put("key-2", "value-2");
+        }};
+        final Map<String, String> map2 = new HashMap<String, String>() {{
+            put("key-3", "value-1");
+            put("key-4", "value-2");
+        }};
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new Map[]{map1, map2}));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(Map.class);
+        assertThat((Map) smartNull)
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_empty_set_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+        throws Throwable {
+
+        final HashSet<String> set1 = new HashSet<String>(Arrays.asList("set-1", "set-2"));
+        final HashSet<String> set2 = new HashSet<String>(Arrays.asList("set-1", "set-2"));
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull =
+            answer.answer(invocationMethodWithVarArgs(new HashSet[]{set1, set2}));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isInstanceOf(Set.class);
+        assertThat((Set) smartNull)
+            .isEmpty();
+    }
+
+    @Test
+    public void should_return_a_new_mock_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+        throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+        final Foo mock1 = mock(Foo.class);
+        final Foo mock2 = mock(Foo.class);
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new Foo[]{mock1, mock2}));
+
+        assertThat(smartNull)
+            .isNotNull()
+            .isNotSameAs(mock1)
+            .isNotSameAs(mock2);
+        assertThat(smartNull.toString())
+            .contains("SmartNull returned by")
+            .contains("genericFooBar.methodWithVarArgs(");
+    }
+
+    @Test
+    public void should_return_an_Object_that_has_been_defined_with_method_generic_and_provided_in_var_args()
+        throws Throwable {
+
+        Answer<Object> answer = new ReturnsSmartNulls();
+
+        Object smartNull = answer.answer(invocationMethodWithVarArgs(new Object[]{new Object() {
+        }, new Object() {
+        }}));
+
+        assertThat(smartNull.toString())
+            .contains("SmartNull returned by")
+            .contains("genericFooBar.methodWithVarArgs(");
+    }
+
 }
diff --git a/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java b/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java
index 86f5cf045..b5f942175 100644
--- a/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java
+++ b/src/test/java/org/mockitousage/stubbing/SmartNullsGenericBugTest.java
@@ -5,7 +5,6 @@
 package org.mockitousage.stubbing;
 
 import org.assertj.core.api.Assertions;
-import org.assertj.core.api.ThrowableAssert;
 import org.junit.Test;
 import org.mockito.Answers;
 
@@ -16,21 +15,56 @@ import static org.mockito.Mockito.withSettings;
 public class SmartNullsGenericBugTest {
 
     @Test
-    public void smart_nulls_generic_bug() {
-        final ConcreteDao concreteDao = mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
-
-        Assertions.assertThatThrownBy(new ThrowableAssert.ThrowingCallable() {
-            public void call() {
-                concreteDao.findById();
-            }
-        }).isInstanceOf(ClassCastException.class);
-        //TODO: can we avoid CCE here? Can we make the exception message better? See issue #1551
+    public void smart_nulls_generic_bug_generic_T() {
+        ConcreteDao concreteDao = mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final Entity result = concreteDao.findById();
+
+        Assertions.assertThat(result)
+            .as("#1551")
+            .isNotNull();
+    }
+
+    @Test
+    public void smart_nulls_generic_bug_generic_M() {
+        ConcreteDao concreteDao = mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final String other = concreteDao.find();
+
+        Assertions.assertThat(other)
+            .as("#1551 - CCannot resolve type")
+            .isNull();
+    }
+
+    @Test
+    public void smart_nulls_generic_bug_generic_M_provided_in_args() {
+        ConcreteDao concreteDao = mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final String other = concreteDao.findArgs(1, "plop");
+
+        Assertions.assertThat(other)
+            .as("#1551")
+            .isEqualTo("");
+    }
+
+    @Test
+    public void smart_nulls_generic_bug_generic_M_provided_as_varargs() {
+        ConcreteDao concreteDao = mock(ConcreteDao.class, withSettings().defaultAnswer(Answers.RETURNS_SMART_NULLS));
+
+        final String other = concreteDao.findVarargs(42, "plip", "plop");
+
+        Assertions.assertThat(other)
+            .as("#1551")
+            .isEqualTo("");
     }
 
     static class AbstractDao<T> {
         T findById() {
             return null;
         }
+        <M> M find() { return null; }
+        <M> M findArgs(int idx, M arg) { return null; }
+        <M> M findVarargs(int idx, M... args) { return null; }
     }
 
     static class Entity { }
