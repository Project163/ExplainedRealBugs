diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 7d9f347f6..02882a227 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -107,18 +107,20 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         return new ReturnValueWrapper(interceptor.doIntercept(instance,
                 origin,
                 arguments,
-            realMethod,
+                realMethod,
                 new LocationImpl(t)));
     }
 
     @Override
     public boolean isMock(Object instance) {
-        return interceptors.containsKey(instance);
+        // We need to exclude 'interceptors.target' explicitly to avoid a recursive check on whether
+        // the map is a mock object what requires reading from the map.
+        return instance != interceptors.target && interceptors.containsKey(instance);
     }
 
     @Override
     public boolean isMocked(Object instance) {
-        return !selfCallInfo.isSelfInvocation(instance) && isMock(instance);
+        return selfCallInfo.checkSuperCall(instance) && isMock(instance);
     }
 
     @Override
@@ -160,12 +162,8 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             if (!Modifier.isPublic(origin.getDeclaringClass().getModifiers() & origin.getModifiers())) {
                 origin.setAccessible(true);
             }
-            Object previous = selfCallInfo.replace(instance);
-            try {
-                return tryInvoke(origin, instance, arguments);
-            } finally {
-                selfCallInfo.set(previous);
-            }
+            selfCallInfo.set(instance);
+            return tryInvoke(origin, instance, arguments);
         }
 
     }
@@ -252,14 +250,19 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
     private static class SelfCallInfo extends ThreadLocal<Object> {
 
-        Object replace(Object instance) {
+        Object replace(Object value) {
             Object current = get();
-            set(instance);
+            set(value);
             return current;
         }
 
-        boolean isSelfInvocation(Object instance) {
-            return get() == instance;
+        boolean checkSuperCall(Object value) {
+            if (value == get()) {
+                set(null);
+                return false;
+            } else {
+                return true;
+            }
         }
     }
 
diff --git a/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java b/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java
index c1476936e..b411a73a9 100644
--- a/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java
+++ b/src/main/java/org/mockito/internal/util/concurrent/WeakConcurrentMap.java
@@ -26,7 +26,7 @@ public class WeakConcurrentMap<K, V> extends ReferenceQueue<K> implements Runnab
 
     private static final AtomicLong ID = new AtomicLong();
 
-    final ConcurrentMap<WeakKey<K>, V> target;
+    public final ConcurrentMap<WeakKey<K>, V> target;
 
     private final Thread thread;
 
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/RecursionTest.java b/subprojects/inline/src/test/java/org/mockitoinline/RecursionTest.java
new file mode 100644
index 000000000..2a4494e03
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/RecursionTest.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import static org.mockito.Mockito.spy;
+
+public class RecursionTest {
+
+    @Test
+    public void testMockConcurrentHashMap() {
+        ConcurrentMap<String, String> map = spy(new ConcurrentHashMap<String, String>());
+        map.putIfAbsent("a", "b");
+    }
+}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/SuperCallTest.java b/subprojects/inline/src/test/java/org/mockitoinline/SuperCallTest.java
new file mode 100644
index 000000000..1fe81969d
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/SuperCallTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2017 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+
+public final class SuperCallTest {
+
+    @Test
+    public void testSuperMethodCall() {
+        Dummy d = spy(new Dummy());
+        d.foo();
+        verify(d).bar(eq("baz"));
+    }
+
+    static class Dummy {
+
+        public void foo() {
+            bar("baz");
+        }
+
+        // Also fails if public.
+        void bar(String s) {
+            return;
+        }
+    }
+}
