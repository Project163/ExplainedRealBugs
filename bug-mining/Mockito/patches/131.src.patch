diff --git a/gradle/java-library.gradle b/gradle/java-library.gradle
index d41e3406b..28c763456 100644
--- a/gradle/java-library.gradle
+++ b/gradle/java-library.gradle
@@ -9,6 +9,10 @@ targetCompatibility = 1.6
 
 test {
     include "**/*Test.class"
+
+    // To make sure we do not leak memory during tests
+    maxHeapSize = "256m"
+
     testLogging {
         exceptionFormat 'full'
         showCauses true
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 02882a227..b6cff0b81 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -24,6 +24,7 @@ import java.io.Serializable;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -141,14 +142,14 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
         private final Method origin;
 
-        private final Object instance;
+        private final WeakReference<Object> instanceRef;
 
         private final Object[] arguments;
 
         private RealMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
             this.selfCallInfo = selfCallInfo;
             this.origin = origin;
-            this.instance = instance;
+            this.instanceRef = new WeakReference<Object>(instance);
             this.arguments = arguments;
         }
 
@@ -162,8 +163,8 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             if (!Modifier.isPublic(origin.getDeclaringClass().getModifiers() & origin.getModifiers())) {
                 origin.setAccessible(true);
             }
-            selfCallInfo.set(instance);
-            return tryInvoke(origin, instance, arguments);
+            selfCallInfo.set(instanceRef.get());
+            return tryInvoke(origin, instanceRef.get(), arguments);
         }
 
     }
@@ -174,14 +175,14 @@ public class MockMethodAdvice extends MockMethodDispatcher {
 
         private final SerializableMethod origin;
 
-        private final Object instance;
+        private final SerializeableWeakReference<Object> instanceRef;
 
         private final Object[] arguments;
 
         private SerializableRealMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
             this.origin = new SerializableMethod(origin);
             this.identifier = identifier;
-            this.instance = instance;
+            this.instanceRef = new SerializeableWeakReference<Object>(instance);
             this.arguments = arguments;
         }
 
@@ -196,13 +197,13 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             if (!Modifier.isPublic(method.getDeclaringClass().getModifiers() & method.getModifiers())) {
                 method.setAccessible(true);
             }
-            MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(identifier, instance);
+            MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(identifier, instanceRef.get());
             if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
                 throw new MockitoException("Unexpected dispatcher for advice-based super call");
             }
-            Object previous = ((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.replace(instance);
+            Object previous = ((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.replace(instanceRef.get());
             try {
-                return tryInvoke(method, instance, arguments);
+                return tryInvoke(method, instanceRef.get(), arguments);
             } finally {
                 ((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(previous);
             }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SerializableReference.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SerializableReference.java
new file mode 100644
index 000000000..33cddc4d2
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SerializableReference.java
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockito.internal.creation.bytebuddy;
+
+import java.io.Serializable;
+
+public interface SerializableReference<T> extends Serializable {
+    T get();
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SerializableStrongReference.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SerializableStrongReference.java
new file mode 100644
index 000000000..a41eb5fb8
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SerializableStrongReference.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockito.internal.creation.bytebuddy;
+
+import java.io.ObjectStreamException;
+
+public class SerializableStrongReference<T> implements SerializableReference<T> {
+    private static final long serialVersionUID = 172345563923510472L;
+
+    private final T ref;
+    private final boolean deserializeAsWeakRef;
+
+    public SerializableStrongReference(T ref, boolean deserializeAsWeakRef) {
+        this.ref = ref;
+        this.deserializeAsWeakRef = deserializeAsWeakRef;
+    }
+
+    @Override
+    public T get() {
+        return ref;
+    }
+
+    private Object readResolve() throws ObjectStreamException {
+        if (deserializeAsWeakRef) {
+            return new SerializeableWeakReference<T>(ref);
+        } else {
+            return this;
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SerializeableWeakReference.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SerializeableWeakReference.java
new file mode 100644
index 000000000..278816537
--- /dev/null
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SerializeableWeakReference.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockito.internal.creation.bytebuddy;
+
+import java.io.ObjectStreamException;
+import java.lang.ref.WeakReference;
+
+/**
+ * A weak reference that is converted into a strong reference when serialized.
+ */
+public class SerializeableWeakReference<T> extends WeakReference<T> implements SerializableReference<T> {
+    private static final long serialVersionUID = 275065433923510472L;
+
+    public SerializeableWeakReference(T t) {
+        super(t);
+    }
+
+    private Object writeReplace() throws ObjectStreamException {
+        return new SerializableStrongReference<T>(get(), true);
+    }
+
+    @Override
+    public T get() {
+        T ref = super.get();
+
+        if (ref == null) {
+            throw new IllegalStateException("The mock was garbage collected. This should not " +
+                "happen as long as the calling code keeps a reference to mock. Code using the " +
+                "public mockito API should always do that. Internal users should request the " +
+                "constructor of InterceptedInvocation to not use weak references.\n" +
+                "If this exception is seen by code using the public mockito API, please file a " +
+                "bug.");
+        }
+
+        return ref;
+    }
+}
diff --git a/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java b/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java
index 875a903ec..be14ebfe9 100644
--- a/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java
+++ b/src/main/java/org/mockito/internal/invocation/DefaultInvocationFactory.java
@@ -34,6 +34,7 @@ public class DefaultInvocationFactory implements InvocationFactory {
     public static InterceptedInvocation createInvocation(Object mock, Method invokedMethod, Object[] arguments, RealMethod realMethod, MockCreationSettings settings, Location location) {
         return new InterceptedInvocation(
             mock,
+            true,
             createMockitoMethod(invokedMethod, settings),
             arguments,
             realMethod,
diff --git a/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java b/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
index d3a9b976c..a06253992 100644
--- a/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
+++ b/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
@@ -4,6 +4,9 @@
  */
 package org.mockito.internal.invocation;
 
+import org.mockito.internal.creation.bytebuddy.SerializableReference;
+import org.mockito.internal.creation.bytebuddy.SerializableStrongReference;
+import org.mockito.internal.creation.bytebuddy.SerializeableWeakReference;
 import org.mockito.internal.exceptions.VerificationAwareInvocation;
 import org.mockito.internal.reporting.PrintSettings;
 import org.mockito.invocation.Invocation;
@@ -19,7 +22,7 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
 
     private static final long serialVersionUID = 475027563923510472L;
 
-    private final Object mock;
+    private final SerializableReference<Object> mockRef;
     private final MockitoMethod mockitoMethod;
     private final Object[] arguments, rawArguments;
     private final RealMethod realMethod;
@@ -33,12 +36,22 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
     private StubInfo stubInfo;
 
     public InterceptedInvocation(Object mock,
+                                 boolean useWeakReference,
                                  MockitoMethod mockitoMethod,
                                  Object[] arguments,
                                  RealMethod realMethod,
                                  Location location,
                                  int sequenceNumber) {
-        this.mock = mock;
+        // Strong references are used in test that use invocations without keeping a reference to
+        // the mock. In production code weak references should be used to allow the mock maker to
+        // detect when a mock is only referenced from within its own handler's invocations. See
+        // #1313
+        if (useWeakReference) {
+            this.mockRef = new SerializeableWeakReference<Object>(mock);
+        } else {
+            this.mockRef = new SerializableStrongReference<Object>(mock, false);
+        }
+
         this.mockitoMethod = mockitoMethod;
         this.arguments = ArgumentsProcessor.expandArgs(mockitoMethod, arguments);
         this.rawArguments = arguments;
@@ -99,7 +112,7 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
 
     @Override
     public Object getMock() {
-        return mock;
+        return mockRef.get();
     }
 
     @Override
@@ -138,7 +151,7 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
             return false;
         }
         InterceptedInvocation other = (InterceptedInvocation) o;
-        return this.mock.equals(other.mock)
+        return this.mockRef.get().equals(other.mockRef.get())
                 && this.mockitoMethod.equals(other.mockitoMethod)
                 && this.equalArguments(other.arguments);
     }
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
index c8943b180..85b47e452 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
@@ -61,6 +61,7 @@ public class InvocationBuilder {
         }
 
         Invocation i = new InterceptedInvocation(mock,
+            false,
             new SerializableMethod(method),
             args,
             NO_OP,
diff --git a/src/test/java/org/mockitoutil/TestBase.java b/src/test/java/org/mockitoutil/TestBase.java
index fe920e654..2f04b0c3e 100644
--- a/src/test/java/org/mockitoutil/TestBase.java
+++ b/src/test/java/org/mockitoutil/TestBase.java
@@ -64,7 +64,7 @@ public class TestBase {
         for (int i = 0; i < args.length; i++) {
             types[i] = args[i].getClass();
         }
-        return new InterceptedInvocation(mock(type), new SerializableMethod(type.getMethod(methodName,
+        return new InterceptedInvocation(mock(type), false, new SerializableMethod(type.getMethod(methodName,
                 types)), args, InterceptedInvocation.NO_OP, new LocationImpl(), 1);
     }
 
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/StressTest.java b/subprojects/inline/src/test/java/org/mockitoinline/StressTest.java
new file mode 100644
index 000000000..c6d7eafa6
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/StressTest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+public class StressTest {
+    public class TestClass {
+        public String returnA() {
+            return "A";
+        }
+    }
+
+    @Test
+    public void call_a_lot_of_mocks() {
+        for (int i = 0; i < 40000; i++) {
+            TestClass t = mock(TestClass.class);
+            when(t.returnA()).thenReturn("B");
+            assertEquals("B", t.returnA());
+
+            if (i % 1024 == 0) {
+                System.out.println(i + "/40000 mocks called");
+            }
+        }
+    }
+}
