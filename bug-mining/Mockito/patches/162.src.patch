diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
index 906692768..e57a82e73 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
@@ -46,13 +46,11 @@ public class MockMethodInterceptor implements Serializable {
                        Method invokedMethod,
                        Object[] arguments,
                        RealMethod realMethod) throws Throwable {
-        return doIntercept(
-                mock,
-                invokedMethod,
-                arguments,
-            realMethod,
-                new LocationImpl()
-        );
+        return doIntercept(mock,
+                           invokedMethod,
+                           arguments,
+                           realMethod,
+                           new LocationImpl());
     }
 
     Object doIntercept(Object mock,
@@ -108,11 +106,11 @@ public class MockMethodInterceptor implements Serializable {
                 return superCall.call();
             }
             return interceptor.doIntercept(
-                    mock,
-                    invokedMethod,
-                    arguments,
-                    new RealMethod.FromCallable(superCall)
-            );
+                mock,
+                invokedMethod,
+                arguments,
+                new RealMethod.FromCallable(superCall)
+                                          );
         }
 
         @SuppressWarnings("unused")
@@ -126,11 +124,11 @@ public class MockMethodInterceptor implements Serializable {
                 return stubValue;
             }
             return interceptor.doIntercept(
-                    mock,
-                    invokedMethod,
-                    arguments,
-                    RealMethod.IsIllegal.INSTANCE
-            );
+                mock,
+                invokedMethod,
+                arguments,
+                RealMethod.IsIllegal.INSTANCE
+                                          );
         }
     }
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
index 596827c64..d7838fb61 100644
--- a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
+++ b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
@@ -97,10 +97,20 @@ public abstract class GenericMetadataSupport {
         }
         if (type instanceof TypeVariable) {
             /*
-             * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
-             * on the class definition, such as such as List<E>.
+             * If type is a TypeVariable, then it is needed to gather data elsewhere.
+             * Usually TypeVariables are declared on the class definition, such as
+             * such as List<E>.
+             *
+             * If the data cannot be found in the contextual map, try harder on the
+             * TypeVariable itself looking for defined bounds.
              */
-            return extractRawTypeOf(contextualActualTypeParameters.get(type));
+            Type typeArgument = contextualActualTypeParameters.get(type);
+            if (typeArgument == null) {
+                BoundedType boundedType = boundsOf((TypeVariable<?>) type);
+                contextualActualTypeParameters.put((TypeVariable<?>) type, boundedType);
+                return extractRawTypeOf(boundedType);
+            }
+            return extractRawTypeOf(typeArgument);
         }
         throw new MockitoException("Raw extraction not supported for : '" + type + "'");
     }
@@ -164,8 +174,12 @@ public abstract class GenericMetadataSupport {
     private BoundedType boundsOf(WildcardType wildCard) {
         /*
          *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):
-         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)
-         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)
+         *  - Lower and upper can't coexist: (for instance, this is not allowed:
+         *    <? extends List<String> & super MyInterface>)
+         *  - Multiple concrete type bounds are not supported (for instance, this is not allowed:
+         *    <? extends ArrayList<String> & MyInterface>)
+         *    But the following form is possible where there is a single concrete tyep bound followed by interface type bounds
+         *    <T extends List<String> & Comparable>
          */
 
         WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
index 323efbf84..56fff2069 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
@@ -10,7 +10,12 @@ import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -48,6 +53,17 @@ public class GenericMetadataSupportTest {
 
     static class StringList extends ArrayList<String> { }
 
+    public interface TopInterface<T> {
+        T generic();
+    }
+    public interface MiddleInterface<T> extends TopInterface<T> { }
+    public class OwningClassWithDeclaredUpperBounds<T extends List<String> & Comparable> {
+        public abstract class AbstractInner implements MiddleInterface<T> { }
+    }
+    public class OwningClassWithNoDeclaredUpperBounds<T> {
+        public abstract class AbstractInner implements MiddleInterface<T> { }
+    }
+
     @Test
     public void typeVariable_of_self_type() {
         GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod("self", GenericsSelfReference.class));
@@ -56,7 +72,7 @@ public class GenericMetadataSupportTest {
     }
 
     @Test
-    public void can_get_raw_type_from_Class() throws Exception {
+    public void can_get_raw_type_from_Class() {
         assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);
         assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);
         assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);
@@ -199,6 +215,18 @@ public class GenericMetadataSupportTest {
         assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);
     }
 
+    @Test
+    public void can_extract_raw_type_from_bounds_on_terminal_typeVariable() {
+        assertThat(inferFrom(OwningClassWithDeclaredUpperBounds.AbstractInner.class)
+                       .resolveGenericReturnType(firstNamedMethod("generic", OwningClassWithDeclaredUpperBounds.AbstractInner.class))
+                       .rawType()
+                  ).isEqualTo(List.class);
+        assertThat(inferFrom(OwningClassWithNoDeclaredUpperBounds.AbstractInner.class)
+                       .resolveGenericReturnType(firstNamedMethod("generic", OwningClassWithNoDeclaredUpperBounds.AbstractInner.class))
+                       .rawType()
+                  ).isEqualTo(Object.class);
+    }
+
     private Type typeVariableValue(Map<TypeVariable<?>, Type> typeVariables, String typeVariableName) {
         for (Map.Entry<TypeVariable<?>, Type> typeVariableTypeEntry : typeVariables.entrySet()) {
             if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {
diff --git a/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java b/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
index 989d3a195..e3891c604 100644
--- a/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
+++ b/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
@@ -11,7 +11,11 @@ import java.util.Iterator;
 import java.util.List;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.Mockito.*;
+import static org.assertj.core.api.Assertions.fail;
+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.withSettings;
 import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;
 
 public class DeepStubsSerializableTest {
@@ -45,7 +49,7 @@ public class DeepStubsSerializableTest {
         assertThat(deserialized_deep_stub.iterator().next().add("yes")).isEqualTo(true);
     }
 
-    @Test(expected = NullPointerException.class)
+    @Test
     public void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {
         // given
         ListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
@@ -53,10 +57,14 @@ public class DeepStubsSerializableTest {
 
         ListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);
 
-        // when stubbing on a deserialized mock
-        when(deserialized_deep_stub.iterator().next().get(42)).thenReturn("no");
-
-        // then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException
+        try {
+            // when stubbing on a deserialized mock
+            // then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException
+            when(deserialized_deep_stub.iterator().next().get(42)).thenReturn("no");
+            fail("Expected an exception to be thrown as deep stubs and serialization does not play well together");
+        } catch (ClassCastException e) {
+            assertThat(e).hasMessageContaining("java.util.List");
+        }
     }
 
     static class SampleClass implements Serializable {
diff --git a/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java b/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java
index df41f062f..0e574f0c5 100644
--- a/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java
+++ b/src/test/java/org/mockitousage/stubbing/DeepStubbingTest.java
@@ -224,7 +224,7 @@ public class DeepStubbingTest extends TestBase {
     Person person = mock(Person.class, RETURNS_DEEP_STUBS);
 
     @Test
-    public void shouldStubbingBasicallyWorkFine() throws Exception {
+    public void shouldStubbingBasicallyWorkFine() {
         //given
         given(person.getAddress().getStreet().getName()).willReturn("Norymberska");
 
@@ -236,7 +236,7 @@ public class DeepStubbingTest extends TestBase {
     }
 
     @Test
-    public void shouldVerificationBasicallyWorkFine() throws Exception {
+    public void shouldVerificationBasicallyWorkFine() {
         //given
         person.getAddress().getStreet().getName();
 
@@ -245,7 +245,7 @@ public class DeepStubbingTest extends TestBase {
     }
 
     @Test
-    public void verification_work_with_argument_Matchers_in_nested_calls() throws Exception {
+    public void verification_work_with_argument_Matchers_in_nested_calls() {
         //given
         person.getAddress("111 Mock Lane").getStreet();
         person.getAddress("111 Mock Lane").getStreet(Locale.ITALIAN).getName();
@@ -257,7 +257,7 @@ public class DeepStubbingTest extends TestBase {
     }
 
     @Test
-    public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() throws Exception {
+    public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() {
         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
 
         person.getAddress("the docks").getStreet().getName();
@@ -270,7 +270,7 @@ public class DeepStubbingTest extends TestBase {
     }
 
     @Test
-    public void times_never_atLeast_atMost_verificationModes_should_work() throws Exception {
+    public void times_never_atLeast_atMost_verificationModes_should_work() {
         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
 
         person.getAddress("the docks").getStreet().getName();
@@ -285,7 +285,7 @@ public class DeepStubbingTest extends TestBase {
 
 
     @Test
-    public void inOrder_only_work_on_the_very_last_mock_but_it_works() throws Exception {
+    public void inOrder_only_work_on_the_very_last_mock_but_it_works() {
         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
         when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn("deep");
         when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn("deep");
@@ -307,7 +307,7 @@ public class DeepStubbingTest extends TestBase {
     }
 
     @Test
-    public void verificationMode_only_work_on_the_last_returned_mock() throws Exception {
+    public void verificationMode_only_work_on_the_last_returned_mock() {
         // 1st invocation on Address mock (stubbing)
         when(person.getAddress("the docks").getStreet().getName()).thenReturn("deep");
 
@@ -328,7 +328,7 @@ public class DeepStubbingTest extends TestBase {
     }
 
     @Test
-    public void shouldFailGracefullyWhenClassIsFinal() throws Exception {
+    public void shouldFailGracefullyWhenClassIsFinal() {
         //when
         FinalClass value = new FinalClass();
         given(person.getFinalClass()).willReturn(value);
