diff --git a/src/main/java/org/mockito/MockitoFramework.java b/src/main/java/org/mockito/MockitoFramework.java
index 05fb0c7b9..e020c6b96 100644
--- a/src/main/java/org/mockito/MockitoFramework.java
+++ b/src/main/java/org/mockito/MockitoFramework.java
@@ -1,7 +1,6 @@
 package org.mockito;
 
 import org.mockito.listeners.MockitoListener;
-import org.mockito.listeners.StubbingListener;
 
 /**
  * Mockito framework settings and lifecycle listeners, for advanced users or for integrating with other frameworks.
@@ -15,15 +14,6 @@ import org.mockito.listeners.StubbingListener;
 @Incubating
 public interface MockitoFramework {
 
-    /**
-     * Sets new {@link StubbingListener}.
-     * <code>null</code> is permitted and removes any previously set listener.
-     * If you set the stubbing listener, ensure that you have cleared it afterwards.
-     * See examples in Mockito codebase how {@link #setStubbingListener(StubbingListener)} is used.
-     */
-    @Incubating
-    void setStubbingListener(StubbingListener listener);
-
     /**
      * Adds listener to Mockito.
      * For a list of supported listeners, see the interfaces that extend {@link MockitoListener}.
diff --git a/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java b/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java
index de4a6c966..9895fbd4e 100644
--- a/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java
+++ b/src/main/java/org/mockito/exceptions/misusing/UnnecessaryStubbingException.java
@@ -1,7 +1,8 @@
 package org.mockito.exceptions.misusing;
 
 /**
- * Unnecessary stubs are stubbed method calls that were never realized during test execution, example:
+ * Unnecessary stubs are stubbed method calls that were never realized during test execution
+ * (see also {@link org.mockito.quality.MockitoHint}), example:
  * <pre class="code"><code class="java">
  * //code under test:
  * ...
diff --git a/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java b/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java
index cf9e802b6..f507727bd 100644
--- a/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java
+++ b/src/main/java/org/mockito/internal/framework/DefaultMockitoFramework.java
@@ -1,24 +1,12 @@
 package org.mockito.internal.framework;
 
 import org.mockito.MockitoFramework;
-import org.mockito.internal.progress.MockingProgress;
 import org.mockito.listeners.MockitoListener;
-import org.mockito.listeners.StubbingListener;
 
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 
 public class DefaultMockitoFramework implements MockitoFramework {
 
-    //TODO 401
-    public void setStubbingListener(StubbingListener listener) {
-        MockingProgress p = mockingProgress();
-        if (listener == null) {
-            p.setStubbingListener(null);
-        } else {
-            p.setStubbingListener(new ThreadSafeStubbingListener(listener));
-        }
-    }
-
     public void addListener(MockitoListener listener) {
         assertNotNull(listener);
         mockingProgress().addListener(listener);
diff --git a/src/main/java/org/mockito/internal/framework/ThreadSafeStubbingListener.java b/src/main/java/org/mockito/internal/framework/ThreadSafeStubbingListener.java
deleted file mode 100644
index 5a49ac99b..000000000
--- a/src/main/java/org/mockito/internal/framework/ThreadSafeStubbingListener.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.mockito.internal.framework;
-
-import org.mockito.invocation.Invocation;
-import org.mockito.listeners.StubbingListener;
-
-class ThreadSafeStubbingListener implements StubbingListener {
-
-    private final StubbingListener delegate;
-    private final Object lock = new Object();
-
-    ThreadSafeStubbingListener(StubbingListener delegate) {
-        this.delegate = delegate;
-    }
-
-    public void newStubbing(Invocation stubbing) {
-        synchronized (lock) {
-            delegate.newStubbing(stubbing);
-        }
-    }
-
-    public void usedStubbing(Invocation stubbing, Invocation actual) {
-        synchronized (lock) {
-            delegate.usedStubbing(stubbing, actual);
-        }
-    }
-
-    public void stubbingNotFound(Invocation actual) {
-        synchronized (lock) {
-            delegate.stubbingNotFound(actual);
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java b/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java
new file mode 100644
index 000000000..a43e35f87
--- /dev/null
+++ b/src/main/java/org/mockito/internal/junit/UnnecessaryStubbingsReporter.java
@@ -0,0 +1,38 @@
+package org.mockito.internal.junit;
+
+import org.junit.runner.Description;
+import org.junit.runner.notification.Failure;
+import org.junit.runner.notification.RunNotifier;
+import org.mockito.internal.exceptions.Reporter;
+import org.mockito.invocation.Invocation;
+import org.mockito.listeners.MockCreationListener;
+import org.mockito.mock.MockCreationSettings;
+
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Reports unnecessary stubbings
+ */
+public class UnnecessaryStubbingsReporter implements MockCreationListener {
+
+    private List<Object> mocks = new LinkedList<Object>();
+
+    public void validateUnusedStubs(Class<?> testClass, RunNotifier notifier) {
+        Collection<Invocation> unused = new UnusedStubbingsFinder().getUnusedStubbingsByLocation(mocks);
+        if (unused.size() == 0) {
+            return; //whoa!!! All stubbings were used!
+        }
+
+        //Oups, there are unused stubbings
+        Description unnecessaryStubbings = Description.createTestDescription(testClass, "unnecessary Mockito stubbings");
+        notifier.fireTestFailure(new Failure(unnecessaryStubbings,
+                Reporter.formatUnncessaryStubbingException(testClass, unused)));
+    }
+
+    @Override
+    public void onMockCreated(Object mock, MockCreationSettings settings) {
+        mocks.add(mock);
+    }
+}
diff --git a/src/main/java/org/mockito/internal/junit/UnusedStubbings.java b/src/main/java/org/mockito/internal/junit/UnusedStubbings.java
index baaf0516e..ddfa3a371 100644
--- a/src/main/java/org/mockito/internal/junit/UnusedStubbings.java
+++ b/src/main/java/org/mockito/internal/junit/UnusedStubbings.java
@@ -8,7 +8,7 @@ import java.util.Collection;
 /**
  * Contains unused stubbings, knows how to format them
  */
-class UnusedStubbings {
+public class UnusedStubbings {
 
     private final Collection<Stubbing> unused;
 
@@ -31,7 +31,7 @@ class UnusedStubbings {
         logger.log(hint.toString());
     }
 
-    int size() {
+    public int size() {
         return unused.size();
     }
 
diff --git a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
index 0cc70abeb..cddaef3bc 100644
--- a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
+++ b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
@@ -1,17 +1,21 @@
 package org.mockito.internal.junit;
 
+import org.mockito.internal.invocation.Stubbing;
 import org.mockito.internal.invocation.finder.AllInvocationsFinder;
 import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.invocation.Stubbing;
+import org.mockito.invocation.Invocation;
 
-import java.util.Collection;
-import java.util.LinkedList;
+import java.util.*;
 
 /**
  * Finds unused stubbings
  */
-class UnusedStubbingsFinder {
-    UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
+public class UnusedStubbingsFinder {
+
+    /**
+     * Gets all unused stubbings for given set of mock objects, in order
+     */
+    public UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
         Collection<Stubbing> stubbings = (Collection) AllInvocationsFinder.findStubbings(mocks);
 
         LinkedList<Stubbing> unused = ListUtil.filter(stubbings, new ListUtil.Filter<Stubbing>() {
@@ -22,4 +26,42 @@ class UnusedStubbingsFinder {
 
         return new UnusedStubbings(unused);
     }
+
+    /**
+     * Gets unused stubbings per location. This method is less accurate than {@link #getUnusedStubbings(Iterable)}.
+     * It considers that stubbings with the same location (e.g. ClassFile + line number) are the same.
+     * This is not completely accurate because a stubbing declared in a setup or constructor
+     * is created per each test method. Because those are different test methods,
+     * different mocks are created, different 'Invocation' instance is backing the 'Stubbing' instance.
+     * In certain scenarios (detecting unused stubbings by JUnit runner), we need this exact level of accuracy.
+     * Stubbing declared in constructor but realized in % of test methods is considered as 'used' stubbing.
+     * There are high level unit tests that demonstrate this scenario.
+     */
+    public Collection<Invocation> getUnusedStubbingsByLocation(Iterable<Object> mocks) {
+        Collection<Stubbing> stubbings = (Collection) AllInvocationsFinder.findStubbings(mocks);
+
+        //1st pass, collect all the locations of the stubbings that were used
+        //note that those are _not_ locations where the stubbings was used
+        Set<String> locationsOfUsedStubbings = new HashSet<String>();
+        for (Stubbing s : stubbings) {
+            if (s.wasUsed()) {
+                String location = s.getInvocation().getLocation().toString();
+                locationsOfUsedStubbings.add(location);
+            }
+        }
+
+        //2nd pass, collect unused stubbings by location
+        //If the location matches we assume the stubbing was used in at least one test method
+        //Also, using map to deduplicate reported unused stubbings
+        // if unused stubbing appear in the setup method / constructor we don't want to report it per each test case
+        Map<String, Invocation> out = new LinkedHashMap<String, Invocation>();
+        for (Stubbing s : stubbings) {
+            String location = s.getInvocation().getLocation().toString();
+            if (!locationsOfUsedStubbings.contains(location)) {
+                out.put(location, s.getInvocation());
+            }
+        }
+
+        return out.values();
+    }
 }
diff --git a/src/main/java/org/mockito/internal/progress/MockingProgress.java b/src/main/java/org/mockito/internal/progress/MockingProgress.java
index 4a4847553..07e034297 100644
--- a/src/main/java/org/mockito/internal/progress/MockingProgress.java
+++ b/src/main/java/org/mockito/internal/progress/MockingProgress.java
@@ -5,12 +5,10 @@
 
 package org.mockito.internal.progress;
 
-import org.mockito.internal.listeners.MockingProgressListener;
 import org.mockito.invocation.Invocation;
 import org.mockito.listeners.MockitoListener;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.OngoingStubbing;
-import org.mockito.listeners.StubbingListener;
 import org.mockito.verification.VerificationMode;
 import org.mockito.verification.VerificationStrategy;
 
@@ -49,13 +47,4 @@ public interface MockingProgress {
     void setVerificationStrategy(VerificationStrategy strategy);
 
     VerificationMode maybeVerifyLazily(VerificationMode mode);
-
-    void setStubbingListener(StubbingListener stubbingListener);
-
-    /**
-     * Stubbing listener is synchronized internally.
-     * This way, users don't have to worry about making the implementations of StubbingListener synchronized
-     * Be cautious how it is used and where to avoid performance impact.
-     */
-    StubbingListener getStubbingListener();
 }
\ No newline at end of file
diff --git a/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java b/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java
index 84a785b36..9345c7198 100644
--- a/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java
+++ b/src/main/java/org/mockito/internal/progress/MockingProgressImpl.java
@@ -5,9 +5,6 @@
 
 package org.mockito.internal.progress;
 
-import static org.mockito.internal.exceptions.Reporter.unfinishedStubbing;
-import static org.mockito.internal.exceptions.Reporter.unfinishedVerificationException;
-
 import org.mockito.internal.configuration.GlobalConfiguration;
 import org.mockito.internal.debugging.Localized;
 import org.mockito.internal.debugging.LocationImpl;
@@ -17,13 +14,15 @@ import org.mockito.listeners.MockCreationListener;
 import org.mockito.listeners.MockitoListener;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.OngoingStubbing;
-import org.mockito.listeners.StubbingListener;
 import org.mockito.verification.VerificationMode;
 import org.mockito.verification.VerificationStrategy;
 
 import java.util.LinkedHashSet;
 import java.util.Set;
 
+import static org.mockito.internal.exceptions.Reporter.unfinishedStubbing;
+import static org.mockito.internal.exceptions.Reporter.unfinishedVerificationException;
+
 @SuppressWarnings("unchecked")
 public class MockingProgressImpl implements MockingProgress {
     
@@ -46,8 +45,6 @@ public class MockingProgressImpl implements MockingProgress {
             }
         };
     }
-    private StubbingListener stubbingListener;
-
     public void reportOngoingStubbing(OngoingStubbing iOngoingStubbing) {
         this.ongoingStubbing = iOngoingStubbing;
     }
@@ -113,20 +110,8 @@ public class MockingProgressImpl implements MockingProgress {
 
     public void stubbingCompleted(Invocation invocation) {
         stubbingInProgress = null;
-        getStubbingListener().newStubbing(invocation);
     }
 
-    /*
-
-     //TODO 545 thread safety of all mockito
-
-     use cases:
-        - single threaded execution throughout
-        - single threaded mock creation, stubbing & verification, multi-threaded interaction with mock
-        - thread per test case
-
-     */
-    
     public String toString() {
         return  "iOngoingStubbing: " + ongoingStubbing + 
         ", verificationMode: " + verificationMode +
@@ -168,14 +153,14 @@ public class MockingProgressImpl implements MockingProgress {
         return this.verificationStrategy.maybeVerifyLazily(mode);
     }
 
-    public void setStubbingListener(StubbingListener stubbingListener) {
-        this.stubbingListener = stubbingListener;
-    }
+     /*
 
-    public StubbingListener getStubbingListener() {
-        if (this.stubbingListener == null) {
-            return NoOpStubbingListener.INSTANCE;
-        }
-        return this.stubbingListener;
-    }
+     //TODO 545 thread safety of all mockito
+
+     use cases:
+        - single threaded execution throughout
+        - single threaded mock creation, stubbing & verification, multi-threaded interaction with mock
+        - thread per test case
+
+     */
 }
\ No newline at end of file
diff --git a/src/main/java/org/mockito/internal/progress/NoOpStubbingListener.java b/src/main/java/org/mockito/internal/progress/NoOpStubbingListener.java
deleted file mode 100644
index ac4f0e7ed..000000000
--- a/src/main/java/org/mockito/internal/progress/NoOpStubbingListener.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.mockito.internal.progress;
-
-import org.mockito.invocation.Invocation;
-import org.mockito.listeners.StubbingListener;
-
-/**
- * Created by sfaber on 7/22/16.
- */
-class NoOpStubbingListener implements StubbingListener {
-
-    static StubbingListener INSTANCE = new NoOpStubbingListener();
-
-    public void newStubbing(Invocation stubbing) {}
-    public void usedStubbing(Invocation stubbing, Invocation actual) {}
-    public void stubbingNotFound(Invocation actual) {}
-}
diff --git a/src/main/java/org/mockito/internal/runners/StrictRunner.java b/src/main/java/org/mockito/internal/runners/StrictRunner.java
index e7ac44890..613886548 100644
--- a/src/main/java/org/mockito/internal/runners/StrictRunner.java
+++ b/src/main/java/org/mockito/internal/runners/StrictRunner.java
@@ -5,6 +5,7 @@ import org.junit.runner.manipulation.Filter;
 import org.junit.runner.manipulation.NoTestsRemainException;
 import org.junit.runner.notification.RunNotifier;
 import org.mockito.Mockito;
+import org.mockito.internal.junit.UnnecessaryStubbingsReporter;
 import org.mockito.internal.runners.util.FailureDetecter;
 
 public class StrictRunner implements RunnerImpl {
@@ -27,13 +28,13 @@ public class StrictRunner implements RunnerImpl {
         UnnecessaryStubbingsReporter reporter = new UnnecessaryStubbingsReporter();
         FailureDetecter listener = new FailureDetecter();
 
-        Mockito.framework().setStubbingListener(reporter);
+        Mockito.framework().addListener(reporter);
         try {
             // add listener that detects test failures
             notifier.addListener(listener);
             runner.run(notifier);
         } finally {
-            Mockito.framework().setStubbingListener(null);
+            Mockito.framework().removeListener(reporter);
         }
 
         if (!filterRequested && listener.isSussessful()) {
@@ -41,7 +42,6 @@ public class StrictRunner implements RunnerImpl {
             //1. if all tests from given test have ran (filter requested is false)
             //   Otherwise we would report unnecessary stubs even if the user runs just single test from the class
             //2. tests are successful (we don't want to add an extra failure on top of any existing failure, to avoid confusion)
-            //TODO 401 JUnit runner should have a specific message explaining to the user how it works.
             reporter.validateUnusedStubs(testClass, notifier);
         }
     }
diff --git a/src/main/java/org/mockito/internal/runners/UnnecessaryStubbingsReporter.java b/src/main/java/org/mockito/internal/runners/UnnecessaryStubbingsReporter.java
deleted file mode 100644
index f5eca5a1e..000000000
--- a/src/main/java/org/mockito/internal/runners/UnnecessaryStubbingsReporter.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.mockito.internal.runners;
-
-import org.junit.runner.Description;
-import org.junit.runner.notification.Failure;
-import org.junit.runner.notification.RunNotifier;
-import org.mockito.internal.exceptions.Reporter;
-import org.mockito.invocation.Invocation;
-import org.mockito.listeners.StubbingListener;
-
-import java.util.*;
-
-/**
- * Reports unnecessary stubbings
- */
-class UnnecessaryStubbingsReporter implements StubbingListener {
-
-    private final Map<String, Invocation> stubbings = new LinkedHashMap<String, Invocation>();
-    private final Set<String> used = new LinkedHashSet<String>();
-
-    public void newStubbing(Invocation stubbing) {
-        //We compare stubbings by the location of stubbing
-        //  so that a stubbing in @Before is considered used when at least one test method uses it
-        //  but not necessarily all test methods need to trigger 'using' it.
-        //If we compared stubbings by 'invocation' we would not be able to satisfy this scenario
-        //  because stubbing declared in the same place in code is a different 'invocation' for every test.
-        //The downside of this approach is that it will not work when there are multiple stubbings / invocations
-        //  per line of code. This should be pretty rare in Java, though.
-        stubbings.put(stubbing.getLocation().toString(), stubbing);
-    }
-
-    public void usedStubbing(Invocation stubbing, Invocation actual) {
-        String location = stubbing.getLocation().toString();
-        used.add(location);
-
-        //perf tweak, let's get rid of used stubbing now, less calculation later
-        stubbings.remove(location);
-    }
-
-    public void stubbingNotFound(Invocation actual) {}
-
-    void validateUnusedStubs(Class<?> testClass, RunNotifier notifier) {
-        if (stubbings.isEmpty()) {
-            //perf tweak, bailing out early to avoid extra computation
-            return;
-        }
-
-        //removing all used stubbings accounting for possible constructor / @Before stubbings
-        // that were used only in specific test methods (e.g. not all test methods)
-        for (String u : used) {
-            //it's awkward to manipulate the state of this object here,
-            // we cannot safely rerun validateUnusedStubs() method.
-            // However, we get good performance and simpler code.
-            stubbings.remove(u);
-        }
-
-        if (stubbings.isEmpty()) {
-            return;
-        }
-
-        if (stubbings.isEmpty()) {
-            return; //whoa!!! All stubbings were used!
-        }
-
-        //Oups, there are unused stubbings
-        Description unnecessaryStubbings = Description.createTestDescription(testClass, "unnecessary Mockito stubbings");
-        notifier.fireTestFailure(new Failure(unnecessaryStubbings,
-                Reporter.formatUnncessaryStubbingException(testClass, stubbings.values())));
-    }
-}
diff --git a/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java b/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
index 891486ff3..c9363ae53 100644
--- a/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java
@@ -76,13 +76,11 @@ public class InvocationContainerImpl implements InvocationContainer, Serializabl
         synchronized (stubbed) {
             for (StubbedInvocationMatcher s : stubbed) {
                 if (s.matches(invocation)) {
-                    mockingProgress().getStubbingListener().usedStubbing(s.getInvocation(), invocation);
                     s.markStubUsed(invocation);
                     invocation.markStubbed(new StubInfoImpl(s));
                     return s;
                 }
             }
-            mockingProgress().getStubbingListener().stubbingNotFound(invocation);
         }
 
         return null;
diff --git a/src/main/java/org/mockito/listeners/StubbingListener.java b/src/main/java/org/mockito/listeners/StubbingListener.java
deleted file mode 100644
index 4b880428e..000000000
--- a/src/main/java/org/mockito/listeners/StubbingListener.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.mockito.listeners;
-
-import org.mockito.Incubating;
-import org.mockito.invocation.Invocation;
-
-/**
- * Listener that allows to listen on events related to stubbing.
- * Useful for advanced users, framework integrators.
- * We use it internally to detect unused stubbings with JUnit runners / rules.
- * For reference, see Mockito source code on how we use this listener.
- * <p>
- * Implementations are not required to be thread safe.
- * Your implementation will be wrapped with a thread safe delegator when you register this listener.
- *
- * @since 2.*
- */
-@Incubating
-public interface StubbingListener {
-
-    /**
-     * New stubbing event, some method on a mock is being stubbed now.
-     * This typically happens in the test code, before the tested behavior is invoked
-     * (e.g. in the 'given' section of the test, every clean test has 3 sections: 'given', 'when' and 'then').
-     */
-    void newStubbing(Invocation stubbing);
-
-    /**
-     * New stubbing 'used' event, some existing stubbing on a mock is being realized now.
-     * This typically happens in the production code, when tested behavior is invoked
-     * (e.g. in the 'when' section of the test, every clean test has 3 sections: 'given', 'when' and 'then').
-     */
-    void usedStubbing(Invocation stubbing, Invocation actual);
-
-    /**
-     * Method is called on a mock, but there is no stubbed behavior registered for this invocation.
-     * Mockito will return default answer for given invocation, typically it means a default return value.
-     * <p>
-     * <strong>Warning:</strong> due to the nature of when() style of stubbing,
-     * 'stubbingNotFound' is also triggered during standard stubbing with when().
-     * Example:
-     * <pre>
-     *   when(mock.foo()).thenReturn(1); // <-- 'stubbingNotFound' is triggered for 'mock.foo()'
-     * </pre>
-     */
-    void stubbingNotFound(Invocation actual);
-}
diff --git a/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java b/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java
index 86de385a1..7fe5abd7b 100644
--- a/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java
+++ b/src/main/java/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java
@@ -12,7 +12,6 @@ import org.junit.runner.manipulation.NoTestsRemainException;
 import org.junit.runner.notification.Failure;
 import org.junit.runner.notification.RunListener;
 import org.junit.runner.notification.RunNotifier;
-import org.junit.runners.BlockJUnit4ClassRunner;
 import org.mockito.internal.debugging.WarningsCollector;
 import org.mockito.internal.runners.RunnerFactory;
 import org.mockito.internal.runners.RunnerImpl;
@@ -22,70 +21,12 @@ import org.mockito.internal.util.MockitoLogger;
 import java.lang.reflect.InvocationTargetException;
 
 /**
- * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.
+ * @deprecated as of 2.0.0. Use the {@link org.mockito.runners.MockitoJUnitRunner} runner instead
+ * which contains support for detecting unused stubs.
  * <p>
- * Experimental implementation that suppose to improve tdd/testing experience. 
- * Don't hesitate to send feedback to mockito@googlegroups.com
- * <b>It is very likely it will change in the next version!</b>
- * <p>
- * This runner does exactly what {@link MockitoJUnitRunner} does but also  
- * prints warnings that might be useful. 
- * The point is that Mockito should help the tdd developer to quickly figure out if the test fails for the right reason. 
- * Then the developer can implement the functionality. 
- * Also when the test fails it should be easy to figure out why the test fails. 
- * <p>
- * Sometimes when the test fails, the underlying reason is that stubbed method was called with wrong arguments. 
- * Sometimes it fails because one forgets to stub a method or forgets to call a stubbed method. 
- * All above problems are not immediately obvious.
- * <p>
- * One way of approaching this problem is full-blown 'expect' API. 
- * However it means the 'expectations upfront' business which is not in line with core Mockito concepts.
- * After all, the essence of testing are <b>explicit assertions</b> that are described consistently at the <b>bottom of the test</b> method.
- * <p>
- * Here's the experiment: a warning is printed to the standard output if the test fails.
- * Also, you get a clickabe link to the line of code. You can immediately jump to the place in code where the potential problem is.
- * <p> 
- * Let's say your test fails on assertion. 
- * Let's say the underlying reason is a stubbed method that was called with different arguments:
- * <pre class="code"><code class="java">
- * //test:
- * Dictionary dictionary = new Dictionary(translator);
- * when(translator.translate("Mockito")).thenReturn("cool framework");
- * String translated = dictionary.search("Mockito");
- * assertEquals("cool framework", translated);
- * 
- * //code:
- * public String search(String word) {
- *     ...
- *     return translator.translate("oups");
- *
- * </code></pre>
- * On standard output you'll see something like that:
- * <pre class="code"><code class="java">
- * [Mockito] Warning - stubbed method called with different arguments.
- * Stubbed this way:
- * translator.translate("Mockito");
- * org.dictionary.SmartDictionaryTest.shouldFindTranslation(SmartDictionaryTest.java:27)
- *  
- * But called with different arguments:
- * translator.translate("oups");
- * org.dictionary.SmartDictionary.search(SmartDictionary.java:15)
- * </code></pre>
- * <p>
- * Note that it is just a warning, not an assertion. 
- * The test fails on assertion because it's the assertion's duty to document what the test stands for and what behavior it proves. 
- * Warnings just makes it quicker to figure out if the test fails for the right reason.
- * <p>
- * Note that code links printed to the console are clickable in any decent IDE (e.g. Eclipse).
- * <p>
- * So far I identified 2 cases when warnings are printed:
- * <li>unsued stub</li>
- * <li>stubbed method but called with different arguments</li> 
- * <p>
- * <br/>
- * <p>
- * Do you think it is useful or not? Drop us an email at mockito@googlegroups.com
+ * If you still prefer using this runner, tell us why (create ticket in our issue tracker).
  */
+@Deprecated
 public class ConsoleSpammingMockitoJUnitRunner extends Runner implements Filterable {
 
     private final MockitoLogger logger;
diff --git a/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java b/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java
index 20275790e..85236af3a 100644
--- a/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java
+++ b/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java
@@ -20,22 +20,10 @@ import org.mockito.internal.util.junit.JUnitFailureHacker;
 import java.lang.reflect.InvocationTargetException;
 
 /**
- * Experimental implementation that suppose to improve tdd/testing experience. 
- * Don't hesitate to send feedback to mockito@googlegroups.com
- * <b>It is very likely it will change in the next version!</b>
+ * @deprecated as of 2.0.0. Use the {@link org.mockito.runners.MockitoJUnitRunner} runner instead
+ * which contains support for detecting unused stubs.
  * <p>
- * This runner does exactly what {@link MockitoJUnitRunner} does but also  
- * adds extra Mocktio hints to the exception message. 
- * The point is that Mockito should help the tdd developer to quickly figure out if the test fails for the right reason and track the reason. 
- * <p>
- * The implementation is pretty hacky - it uses brute force of reflection to modify the exception message and add extra mockito hints.
- * You've been warned. 
- * <p>
- * Do you think it is useful or not? Drop us an email at mockito@googlegroups.com
- * <p>
- * Experimental implementation - will change in future!
- *
- * @deprecated as of 2.0.0. Use the new {@link org.mockito.runners.MockitoJUnitRunner.Strict} runner instead.
+ * If you still prefer using this runner, tell us why (create ticket in our issue tracker).
  */
 @Deprecated
 public class VerboseMockitoJUnitRunner extends Runner implements Filterable {
diff --git a/src/test/java/org/mockito/internal/junit/UnusedStubbingsFinderTest.java b/src/test/java/org/mockito/internal/junit/UnusedStubbingsFinderTest.java
deleted file mode 100644
index dfddf1128..000000000
--- a/src/test/java/org/mockito/internal/junit/UnusedStubbingsFinderTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.mockito.internal.junit;
-
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockitousage.IMethods;
-import org.mockitoutil.TestBase;
-
-import java.util.List;
-
-import static java.util.Arrays.asList;
-import static org.junit.Assert.*;
-import static org.mockito.Mockito.when;
-
-public class UnusedStubbingsFinderTest extends TestBase {
-
-    UnusedStubbingsFinder finder = new UnusedStubbingsFinder();
-    @Mock IMethods mock1;
-    @Mock IMethods mock2;
-
-    @Test
-    public void no_interactions() throws Exception {
-        //when
-        UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
-
-        //then
-        assertEquals(0, stubbings.size());
-    }
-
-    @Test
-    public void no_stubbings() throws Exception {
-        mock1.simpleMethod();
-
-        //when
-        UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
-
-        //then
-        assertEquals(0, stubbings.size());
-    }
-
-    @Test
-    public void no_unused_stubbings() throws Exception {
-        when(mock1.simpleMethod()).thenReturn("1");
-        mock1.simpleMethod();
-
-        //when
-        UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
-
-        //then
-        assertEquals(0, stubbings.size());
-    }
-
-    @Test
-    public void unused_stubbings() throws Exception {
-        when(mock1.simpleMethod()).thenReturn("1");
-
-        //when
-        UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
-
-        //then
-        assertEquals(1, stubbings.size());
-    }
-
-    @Test
-    public void some_unused_stubbings() throws Exception {
-        when(mock1.simpleMethod(1)).thenReturn("1");
-        when(mock2.simpleMethod(2)).thenReturn("2");
-        when(mock2.simpleMethod(3)).thenReturn("3");
-
-        mock2.simpleMethod(2);
-
-        //when
-        UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
-
-        //then
-        assertEquals(2, stubbings.size());
-        assertEquals("[mock1.simpleMethod(1); stubbed with: [Returns: 1], mock2.simpleMethod(3); stubbed with: [Returns: 3]]",
-                stubbings.toString());
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java b/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java
new file mode 100644
index 000000000..22870b6f4
--- /dev/null
+++ b/src/test/java/org/mockitousage/internal/junit/UnusedStubbingsFinderTest.java
@@ -0,0 +1,127 @@
+package org.mockitousage.internal.junit;
+
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.internal.junit.UnusedStubbings;
+import org.mockito.internal.junit.UnusedStubbingsFinder;
+import org.mockitousage.IMethods;
+import org.mockitoutil.TestBase;
+
+import java.util.Collection;
+import java.util.List;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.when;
+
+/**
+ * This unit test lives in 'org.mockitousage' package for a reason.
+ * It makes it easy to write tests that depend on the stack trace filtering logic.
+ * Long term, it would be nice to have more configurability in TestBase
+ *  to make it easy to write such unit tests in 'org.mockito.*' packages.
+ */
+public class UnusedStubbingsFinderTest extends TestBase {
+
+    UnusedStubbingsFinder finder = new UnusedStubbingsFinder();
+    @Mock IMethods mock1;
+    @Mock IMethods mock2;
+
+    @Test
+    public void no_interactions() throws Exception {
+        //expect
+        assertEquals(0, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
+        assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
+    }
+
+    @Test
+    public void no_stubbings() throws Exception {
+        //when
+        mock1.simpleMethod();
+
+        //then
+        assertEquals(0, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
+        assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
+    }
+
+    @Test
+    public void no_unused_stubbings() throws Exception {
+        //when
+        when(mock1.simpleMethod()).thenReturn("1");
+        mock1.simpleMethod();
+
+        //then
+        assertEquals(0, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
+        assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
+    }
+
+    @Test
+    public void unused_stubbings() throws Exception {
+        //when
+        when(mock1.simpleMethod()).thenReturn("1");
+
+        //then
+        assertEquals(1, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
+        assertEquals(1, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
+    }
+
+    @Test
+    public void some_unused_stubbings() throws Exception {
+        when(mock1.simpleMethod(1)).thenReturn("1");
+        when(mock2.simpleMethod(2)).thenReturn("2");
+        when(mock2.simpleMethod(3)).thenReturn("3");
+
+        mock2.simpleMethod(2);
+
+        //when
+        UnusedStubbings stubbings = finder.getUnusedStubbings((List) asList(mock1, mock2));
+
+        //then
+        assertEquals(2, stubbings.size());
+        assertEquals("[mock1.simpleMethod(1); stubbed with: [Returns: 1], mock2.simpleMethod(3); stubbed with: [Returns: 3]]",
+                stubbings.toString());
+    }
+
+    @Test
+    public void some_unused_stubbings_by_location() throws Exception {
+        when(mock1.simpleMethod(1)).thenReturn("1");
+        when(mock2.simpleMethod(2)).thenReturn("2");
+        when(mock2.simpleMethod(3)).thenReturn("3");
+
+        mock2.simpleMethod(2);
+
+        //when
+        Collection stubbings = finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2));
+
+        //then
+        assertEquals(2, stubbings.size());
+        assertEquals("[mock1.simpleMethod(1);, mock2.simpleMethod(3);]", stubbings.toString());
+    }
+
+    @Test
+    public void stubbing_used_by_location() throws Exception {
+        //when
+        //Emulating stubbing in the same location by putting stubbing in the same line:
+        when(mock1.simpleMethod(1)).thenReturn("1"); when(mock2.simpleMethod(1)).thenReturn("1");
+        //End of emulation
+        mock1.simpleMethod(1);
+
+        //then technically unused stubbings exist
+        assertEquals(1, finder.getUnusedStubbings((List) asList(mock1, mock2)).size());
+        //however if we consider stubbings in the same location as the same stubbing, all is used:
+        assertEquals(0, finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2)).size());
+    }
+
+    @Test
+    public void deduplicates_stubbings_by_location() throws Exception {
+        //when
+        //Emulating stubbing in the same location by putting stubbing in the same line:
+        when(mock1.simpleMethod(1)).thenReturn("1"); when(mock2.simpleMethod(1)).thenReturn("1");
+        //End of emulation
+
+        //when
+        Collection stubbings = finder.getUnusedStubbingsByLocation((List) asList(mock1, mock2));
+
+        //then
+        assertEquals(1, stubbings.size());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
index 52f573bf4..36050b73b 100644
--- a/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/SilentRunnerTest.java
@@ -20,9 +20,6 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-/**
- * Created by sfaber on 4/22/16.
- */
 public class SilentRunnerTest extends TestBase {
 
     JUnitCore runner = new JUnitCore();
diff --git a/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java b/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
index ec40466f9..491864120 100644
--- a/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/StrictRunnerTest.java
@@ -55,7 +55,7 @@ public class StrictRunnerTest extends TestBase {
         JUnitResultAssert.assertThat(result).fails(1, MyAssertionError.class);
     }
 
-    @Test public void runner_can_coexists_with_rule() {
+    @Test public void runner_can_coexist_with_rule() {
         //I don't believe that this scenario is useful
         //I only wish that Mockito does not break awkwardly when both: runner & rule is used
 
@@ -66,6 +66,14 @@ public class StrictRunnerTest extends TestBase {
         JUnitResultAssert.assertThat(result).fails(1, UnnecessaryStubbingException.class);
     }
 
+    @Test public void runner_in_multi_threaded_tests() {
+        //when
+        Result result = runner.run(StubUsedFromDifferentThread.class);
+
+        //then
+        JUnitResultAssert.assertThat(result).isSuccessful();
+    }
+
     @RunWith(MockitoJUnitRunner.class)
     public static class StubbingInConstructorUsed extends StubbingInConstructorUnused {
         @Test public void test() {
@@ -73,7 +81,7 @@ public class StrictRunnerTest extends TestBase {
         }
     }
 
-    @RunWith(MockitoJUnitRunner.class)
+    @RunWith(MockitoJUnitRunner.Strict.class) //using Strict to make sure it does the right thing
     public static class StubbingInConstructorUnused {
         IMethods mock = when(mock(IMethods.class).simpleMethod(1)).thenReturn("1").getMock();
         @Test public void dummy() {}
@@ -146,4 +154,25 @@ public class StrictRunnerTest extends TestBase {
             mock.simpleMethod(2);
         }
     }
+
+    @RunWith(MockitoJUnitRunner.class)
+    public static class StubUsedFromDifferentThread {
+
+        IMethods mock = mock(IMethods.class);
+
+        @Test public void passing_test() throws Exception {
+            //stubbing is done in main thread:
+            when(mock.simpleMethod(1)).thenReturn("1");
+
+            //stubbing is used in a different thread
+            //stubbing should not be reported as unused by the runner
+            Thread t = new Thread() {
+                public void run() {
+                    mock.simpleMethod(1);
+                }
+            };
+            t.start();
+            t.join();
+        }
+    }
 }
diff --git a/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java b/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
index e722bfc70..3760e6446 100644
--- a/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
+++ b/src/test/java/org/mockitousage/junitrunner/UnusedStubsExceptionMessageTest.java
@@ -13,9 +13,6 @@ import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-/**
- * Created by sfaber on 4/22/16.
- */
 public class UnusedStubsExceptionMessageTest extends TestBase {
 
     //Moving the code around this class is tricky and may cause the test to fail
diff --git a/src/test/java/org/mockitoutil/TestBaseTest.java b/src/test/java/org/mockitoutil/TestBaseTest.java
index 871cc6127..d8c94d98b 100644
--- a/src/test/java/org/mockitoutil/TestBaseTest.java
+++ b/src/test/java/org/mockitoutil/TestBaseTest.java
@@ -4,9 +4,6 @@ import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
-/**
- * Created by sfaber on 7/22/16.
- */
 public class TestBaseTest extends TestBase {
 
     @Test public void filters_line_no_from_stack_trace() {
