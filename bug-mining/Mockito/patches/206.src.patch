diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
index 2d75418e6..d836d07a7 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
@@ -30,6 +30,7 @@ import org.mockito.exceptions.base.MockitoInitializationException;
 import org.mockito.exceptions.misusing.MockitoConfigurationException;
 import org.mockito.internal.SuppressSignatureCheck;
 import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.creation.instance.ConstructorInstantiator;
 import org.mockito.internal.util.Platform;
 import org.mockito.internal.util.concurrent.DetachedThreadLocal;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
@@ -321,16 +322,25 @@ public class InlineByteBuddyMockMaker
 
         try {
             T instance;
-            try {
-                // We attempt to use the "native" mock maker first that avoids Objenesis and Unsafe
-                instance = newInstance(type);
-            } catch (InstantiationException ignored) {
-                if (nullOnNonInlineConstruction) {
-                    return null;
+            if (settings.isUsingConstructor()) {
+                instance =
+                        new ConstructorInstantiator(
+                                        settings.getOuterClassInstance() != null,
+                                        settings.getConstructorArgs())
+                                .newInstance(type);
+            } else {
+                try {
+                    // We attempt to use the "native" mock maker first that avoids
+                    // Objenesis and Unsafe
+                    instance = newInstance(type);
+                } catch (InstantiationException ignored) {
+                    if (nullOnNonInlineConstruction) {
+                        return null;
+                    }
+                    Instantiator instantiator =
+                            Plugins.getInstantiatorProvider().getInstantiator(settings);
+                    instance = instantiator.newInstance(type);
                 }
-                Instantiator instantiator =
-                        Plugins.getInstantiatorProvider().getInstantiator(settings);
-                instance = instantiator.newInstance(type);
             }
             MockMethodInterceptor mockMethodInterceptor =
                     new MockMethodInterceptor(handler, settings);
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/SpyWithConstructorTest.java b/subprojects/inline/src/test/java/org/mockitoinline/SpyWithConstructorTest.java
new file mode 100644
index 000000000..fcaa58112
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/SpyWithConstructorTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertEquals;
+import static org.mockito.Mockito.*;
+
+public class SpyWithConstructorTest {
+
+    private SomethingAbstract somethingAbstract;
+
+    @Before
+    public void setUp() {
+        somethingAbstract = mock(SomethingAbstract.class, withSettings()
+            .useConstructor("foo")
+            .defaultAnswer(CALLS_REAL_METHODS));
+    }
+
+    @Test
+    public void shouldUseConstructor() {
+        assertEquals("foo", somethingAbstract.getValue());
+    }
+
+    static abstract class SomethingAbstract {
+
+        private final String value;
+
+        SomethingAbstract(String value) {
+            this.value = value;
+        }
+
+        public String getValue() {
+            return value;
+        }
+    }
+}
