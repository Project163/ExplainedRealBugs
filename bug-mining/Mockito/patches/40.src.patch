diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java
deleted file mode 100644
index 6dbd11f5d..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java
+++ /dev/null
@@ -1,423 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.Incubating;
-import org.mockito.exceptions.base.MockitoSerializationIssue;
-import org.mockito.internal.creation.instance.InstantiatorProvider;
-import org.mockito.internal.creation.settings.CreationSettings;
-import org.mockito.internal.util.MockUtil;
-import org.mockito.internal.util.reflection.FieldSetter;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.mock.MockName;
-import org.mockito.mock.SerializableMode;
-
-import java.io.*;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.Set;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-import static org.mockito.internal.util.StringJoiner.join;
-
-/**
- * This is responsible for serializing a mock, it is enabled if the mock is implementing
- * {@link Serializable}.
- * <p/>
- * <p>
- *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},
- *     if the mock settings is set to be serializable it will add the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable}
- *     interface.
- *     This interface defines a the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}
- *     whose signature match the one that is looked by the standard Java serialization.
- * </p>
- * <p/>
- * <p>
- *     Then in the {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter} of mockito, if the <code>writeReplace</code> method is called,
- *     it will use the custom implementation of this class {@link #writeReplace(Object)}. This method has a specific
- *     knowledge on how to serialize a mockito mock that is based on CGLIB.
- * </p>
- *
- * <p><strong>Only one instance per mock! See {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter}</strong></p>
- *
- * TODO use a proper way to add the interface
- * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting
- * TODO check the class is mockable in the deserialization side
- *
- * @see org.mockito.internal.creation.cglib.CglibMockMaker
- * @see org.mockito.internal.creation.cglib.MethodInterceptorFilter
- * @author Brice Dutheil
- * @since 1.10.0
- */
-@Incubating
-class AcrossJVMSerializationFeature implements Serializable {
-    private static final long serialVersionUID = 7411152578314420778L;
-    private static final String MOCKITO_PROXY_MARKER = "MockitoProxyMarker";
-    private boolean instanceLocalCurrentlySerializingFlag = false;
-    private final Lock mutex = new ReentrantLock();
-
-    public boolean isWriteReplace(Method method) {
-        return method.getReturnType() == Object.class
-                && method.getParameterTypes().length == 0
-                && method.getName().equals("writeReplace");
-    }
-
-
-    /**
-     * Custom implementation of the <code>writeReplace</code> method for serialization.
-     * <p/>
-     * Here's how it's working and why :
-     * <ol>
-     * <li>
-     * <p>When first entering in this method, it's because some is serializing the mock, with some code like :
-     * <pre class="code"><code class="java">
-     * objectOutputStream.writeObject(mock);
-     * </code></pre>
-     *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and
-     *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.
-     *         At this point, the code will return an
-     *         {@link AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy}.</p>
-     *     </li>
-     *     <li>
-     *         <p>Now, in the constructor
-     *         {@link AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}
-     *         the mock is being serialized in a custom way (using
-     *         {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream}) to a
-     *         byte array. So basically it means the code is performing double nested serialization of the passed
-     *         <code>mockitoMock</code>.</p>
-     *
-     *         <p>However the <code>ObjectOutputStream</code> will still detect the custom
-     *         <code>writeReplace</code> and execute it.
-     *         <em>(For that matter disabling replacement via {@link ObjectOutputStream#enableReplaceObject(boolean)}
-     *         doesn't disable the <code>writeReplace</code> call, but just just toggle replacement in the
-     *         written stream, <strong><code>writeReplace</code> is always called by
-     *         <code>ObjectOutputStream</code></strong>.)</em></p>
-     *
-     *         <p>In order to avoid this recursion, obviously leading to a {@link StackOverflowError}, this method is using
-     *         a flag that marks the mock as already being replaced, and then shouldn't replace itself again.
-     *         <strong>This flag is local to this class</strong>, which means the flag of this class unfortunately needs
-     *         to be protected against concurrent access, hence the reentrant lock.</p>
-     *     </li>
-     * </ol>
-     *
-     * @param mockitoMock The Mockito mock to be serialized.
-     * @return A wrapper ({@link AcrossJVMMockSerializationProxy}) to be serialized by the calling ObjectOutputStream.
-     * @throws ObjectStreamException
-     */
-    public Object writeReplace(Object mockitoMock) throws ObjectStreamException {
-        try {
-            // reentrant lock for critical section. could it be improved ?
-            mutex.lock();
-            // mark started flag // per thread, not per instance
-            // temporary loosy hack to avoid stackoverflow
-            if (mockIsCurrentlyBeingReplaced()) {
-                return mockitoMock;
-            }
-            mockReplacementStarted();
-
-            return new AcrossJVMMockSerializationProxy(mockitoMock);
-        } catch (IOException ioe) {
-            MockUtil mockUtil = new MockUtil();
-            MockName mockName = mockUtil.getMockName(mockitoMock);
-            String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();
-            throw new MockitoSerializationIssue(join(
-                    "The mock '" + mockName + "' of type '" + mockedType + "'",
-                    "The Java Standard Serialization reported an '" + ioe.getClass().getSimpleName() + "' saying :",
-                    "  " + ioe.getMessage()
-            ), ioe);
-        } finally {
-            // unmark
-            mockReplacementCompleted();
-            mutex.unlock();
-        }
-    }
-
-
-    private void mockReplacementCompleted() {
-        instanceLocalCurrentlySerializingFlag = false;
-    }
-
-
-    private void mockReplacementStarted() {
-        instanceLocalCurrentlySerializingFlag = true;
-    }
-
-
-    private boolean mockIsCurrentlyBeingReplaced() {
-        return instanceLocalCurrentlySerializingFlag;
-    }
-
-
-    /**
-     * Enable serialization serialization that will work across classloaders / and JVM.
-     * <p/>
-     * <p>Only enable if settings says the mock should be serializable. In this case add the
-     * {@link AcrossJVMMockitoMockSerializable} to the extra interface list.</p>
-     *
-     * @param settings Mock creation settings.
-     * @param <T>      Type param to not be bothered by the generics
-     */
-    public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {
-        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
-            // havin faith that this set is modifiable
-            // TODO use a proper way to add the interface
-            settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerializable.class);
-        }
-    }
-
-
-    /**
-     * This is the serialization proxy that will encapsulate the real mock data as a byte array.
-     * <p/>
-     * <p>When called in the constructor it will serialize the mock in a byte array using a
-     * custom {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream} that
-     * will annotate the mock class in the stream.
-     * Other information are used in this class in order to facilitate deserialization.
-     * </p>
-     * <p/>
-     * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via
-     * the custom {@link MockitoMockObjectInputStream} that will be in charge of creating the mock class.</p>
-     */
-    public static class AcrossJVMMockSerializationProxy implements Serializable {
-
-
-        private static final long serialVersionUID = -7600267929109286514L;
-        private final byte[] serializedMock;
-        private final Class typeToMock;
-        private final Set<Class> extraInterfaces;
-
-        /**
-         * Creates the wrapper that be used in the serialization stream.
-         *
-         * <p>Immediately serializes the Mockito mock using specifically crafted
-         * {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream},
-         * in a byte array.</p>
-         *
-         * @param mockitoMock The Mockito mock to serialize.
-         * @throws IOException
-         */
-        public AcrossJVMMockSerializationProxy(Object mockitoMock) throws IOException {
-            ByteArrayOutputStream out = new ByteArrayOutputStream();
-            ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);
-
-            objectOutputStream.writeObject(mockitoMock);
-
-            objectOutputStream.close();
-            out.close();
-
-            MockCreationSettings mockSettings = new MockUtil().getMockSettings(mockitoMock);
-            this.serializedMock = out.toByteArray();
-            this.typeToMock = mockSettings.getTypeToMock();
-            this.extraInterfaces = mockSettings.getExtraInterfaces();
-        }
-
-        /**
-         * Resolves the proxy to a new deserialized instance of the Mockito mock.
-         * <p/>
-         * <p>Uses the custom crafted {@link MockitoMockObjectInputStream} to deserialize the mock.</p>
-         *
-         * @return A deserialized instance of the Mockito mock.
-         * @throws ObjectStreamException
-         */
-        private Object readResolve() throws ObjectStreamException {
-            try {
-                ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);
-                ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);
-
-                Object deserializedMock = objectInputStream.readObject();
-
-                bis.close();
-                objectInputStream.close();
-
-                return deserializedMock;
-            } catch (IOException ioe) {
-                throw new MockitoSerializationIssue(join(
-                        "Mockito mock cannot be deserialized to a mock of '" + typeToMock.getCanonicalName() + "'. The error was :",
-                        "  " + ioe.getMessage(),
-                        "If you are unsure what is the reason of this exception, feel free to contact us on the mailing list."
-                ), ioe);
-            } catch (ClassNotFoundException cce) {
-                throw new MockitoSerializationIssue(join(
-                        "A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :",
-                        "  " + cce.getMessage(),
-                        "If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list."
-                ), cce);
-            }
-        }
-    }
-
-
-    /**
-     * Special Mockito aware <code>ObjectInputStream</code> that will resolve the Mockito proxy class.
-     * <p/>
-     * <p>
-     *     This specificaly crafted ObjectInoutStream has the most important role to resolve the Mockito generated
-     *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream
-     *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it
-     *     delegates class resolution to the default super behavior.
-     *     The mirror method used for serializing the mock is
-     *     {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream#annotateClass(Class)}.
-     * </p>
-     * <p/>
-     * <p>
-     *     When this marker is found, {@link org.mockito.internal.creation.cglib.ClassImposterizer} methods are being used to create the mock class.
-     *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the
-     *     {@link org.mockito.internal.creation.util.SearchingClassLoader} that will look if this enhanced class has
-     *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer
-     *     code.</em>
-     * </p>
-     */
-    public static class MockitoMockObjectInputStream extends ObjectInputStream {
-        private final Class typeToMock;
-        private final Set<Class> extraInterfaces;
-
-        public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {
-            super(in);
-            this.typeToMock = typeToMock;
-            this.extraInterfaces = extraInterfaces;
-            enableResolveObject(true); // ensure resolving is enabled
-        }
-
-        /**
-         * Resolve the Mockito proxy class if it is marked as such.
-         * <p/>
-         * <p>Uses the fields {@link #typeToMock} and {@link #extraInterfaces} to
-         * create the Mockito proxy class as the <code>ObjectStreamClass</code>
-         * doesn't carry useful information for this purpose.</p>
-         *
-         * @param desc Description of the class in the stream, not used.
-         * @return The class that will be used to deserialize the instance mock.
-         * @throws IOException
-         * @throws ClassNotFoundException
-         */
-        @Override
-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
-            if (notMarkedAsAMockitoMock(readObject())) {
-                return super.resolveClass(desc);
-            }
-
-            // TODO check the class is mockable in the deserialization side
-            // ClassImposterizer.INSTANCE.canImposterise(typeToMock);
-
-            // create the Mockito mock class before it can even be deserialized
-            //TODO SF unify creation of imposterizer, constructor code duplicated
-            ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator(new CreationSettings()));
-            imposterizer.setConstructorsAccessible(typeToMock, true);
-            Class<?> proxyClass = imposterizer.createProxyClass(
-                    typeToMock,
-                    extraInterfaces.toArray(new Class[extraInterfaces.size()])
-            );
-
-            hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);
-            return proxyClass;
-        }
-
-        /**
-         * Hack the <code>name</code> field of the given <code>ObjectStreamClass</code> with
-         * the <code>newProxyClass</code>.
-         * <p/>
-         * The parent ObjectInputStream will check the name of the class in the stream matches the name of the one
-         * that is created in this method.
-         * <p/>
-         * The CGLIB classes uses a hash of the classloader and/or maybe some other data that allow them to be
-         * relatively unique in a JVM.
-         * <p/>
-         * When names differ, which happens when the mock is deserialized in another ClassLoader, a
-         * <code>java.io.InvalidObjectException</code> is thrown, so this part of the code is hacking through
-         * the given <code>ObjectStreamClass</code> to change the name with the newly created class.
-         *
-         * @param descInstance The <code>ObjectStreamClass</code> that will be hacked.
-         * @param proxyClass   The proxy class whose name will be applied.
-         * @throws InvalidObjectException
-         */
-        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {
-            try {
-                Field classNameField = descInstance.getClass().getDeclaredField("name");
-                new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());
-            } catch (NoSuchFieldException nsfe) {
-                // TODO use our own mockito mock serialization exception
-                throw new MockitoSerializationIssue(join(
-                        "Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',",
-                        "this is definitely a bug in our code as it means the JDK team changed a few internal things.",
-                        "",
-                        "Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome."
-                ), nsfe);
-            }
-        }
-
-        /**
-         * Read the stream class annotation and identify it as a Mockito mock or not.
-         *
-         * @param marker The marker to identify.
-         * @return <code>true</code> if not marked as a Mockito, <code>false</code> if the class annotation marks a Mockito mock.
-         * @throws IOException
-         * @throws ClassNotFoundException
-         */
-        private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {
-            return !MOCKITO_PROXY_MARKER.equals(marker);
-        }
-    }
-
-
-    /**
-     * Special Mockito aware <code>ObjectOutputStream</code>.
-     * <p/>
-     * <p>
-     * This output stream has the role of marking in the stream the Mockito class. This
-     * marking process is necessary to identify the proxy class that will need to be recreated.
-     * <p/>
-     * The mirror method used for deserializing the mock is
-     * {@link MockitoMockObjectInputStream#resolveClass(ObjectStreamClass)}.
-     * </p>
-     */
-    private static class MockitoMockObjectOutputStream extends ObjectOutputStream {
-        private static final String NOTHING = "";
-
-        public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {
-            super(out);
-        }
-
-        /**
-         * Annotates (marks) the class if this class is a Mockito mock.
-         *
-         * @param cl The class to annotate.
-         * @throws IOException
-         */
-        @Override
-        protected void annotateClass(Class<?> cl) throws IOException {
-            writeObject(mockitoProxyClassMarker(cl));
-            // might be also useful later, for embedding classloader info ...maybe ...maybe not
-        }
-
-        /**
-         * Returns the Mockito marker if this class is a Mockito mock.
-         *
-         * @param cl The class to mark.
-         * @return The marker if this is a Mockito proxy class, otherwise returns a void marker.
-         */
-        private String mockitoProxyClassMarker(Class<?> cl) {
-            if (AcrossJVMMockitoMockSerializable.class.isAssignableFrom(cl)) {
-                return MOCKITO_PROXY_MARKER;
-            } else {
-                return NOTHING;
-            }
-        }
-    }
-
-
-    /**
-     * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an
-     * <code>ObjectOutputStream</code>.
-     * <p/>
-     * It will be applied before the creation of the mock when the mock setting says it should serializable.
-     *
-     * @see #enableSerializationAcrossJVM(org.mockito.mock.MockCreationSettings)
-     */
-    public interface AcrossJVMMockitoMockSerializable {
-        public Object writeReplace() throws java.io.ObjectStreamException;
-    }
-}
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/CGLIBHacker.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/CGLIBHacker.java
deleted file mode 100644
index 6f62be1a4..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/CGLIBHacker.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.proxy.MethodProxy;
-
-import java.io.Serializable;
-import java.lang.reflect.Field;
-
-class CGLIBHacker {
-
-    public void setMockitoNamingPolicy(MethodProxy methodProxy) {
-        try {
-            Field createInfoField = reflectOnCreateInfo(methodProxy);
-            createInfoField.setAccessible(true);
-            Object createInfo = createInfoField.get(methodProxy);
-            Field namingPolicyField = createInfo.getClass().getDeclaredField("namingPolicy");
-            namingPolicyField.setAccessible(true);
-            if (namingPolicyField.get(createInfo) == null) {
-                namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);
-            }
-        } catch (Exception e) {
-            throw new RuntimeException(
-                            "Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses", e);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws SecurityException, NoSuchFieldException {
-
-        Class cglibMethodProxyClass = methodProxy.getClass();
-        // in case methodProxy was extended by user, let's traverse the object
-        // graph to find the cglib methodProxy
-        // with all the fields we would like to change
-        while (cglibMethodProxyClass != MethodProxy.class) {
-            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();
-        }
-        return cglibMethodProxyClass.getDeclaredField("createInfo");
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/CglibMockMaker.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/CglibMockMaker.java
deleted file mode 100644
index fbda0a688..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/CglibMockMaker.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.proxy.Callback;
-import org.mockito.cglib.proxy.Factory;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.InternalMockHandler;
-import org.mockito.internal.creation.instance.InstantiatorProvider;
-import org.mockito.invocation.MockHandler;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.plugins.MockMaker;
-
-import java.lang.reflect.Modifier;
-
-
-/**
- * A MockMaker that uses cglib to generate mocks on a JVM.
- */
-public class CglibMockMaker implements MockMaker {
-
-    @Override
-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
-        InternalMockHandler mockitoHandler = cast(handler);
-        new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);
-        return new ClassImposterizer(new InstantiatorProvider().getInstantiator(settings)).imposterise(
-                new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());
-    }
-
-    private InternalMockHandler cast(MockHandler handler) {
-        if (!(handler instanceof InternalMockHandler)) {
-            throw new MockitoException("At the moment you cannot provide own implementations of MockHandler." +
-                    "\nPlease see the javadocs for the MockMaker interface.");
-        }
-        return (InternalMockHandler) handler;
-    }
-
-    @Override
-    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));
-    }
-
-    @Override
-    public MockHandler getHandler(Object mock) {
-        if (!(mock instanceof Factory)) {
-            return null;
-        }
-        Factory factory = (Factory) mock;
-        Callback callback = factory.getCallback(0);
-        if (!(callback instanceof MethodInterceptorFilter)) {
-            return null;
-        }
-        return ((MethodInterceptorFilter) callback).getHandler();
-    }
-
-    @Override
-    public TypeMockability isTypeMockable(final Class<?> type) {
-        return new TypeMockability() {
-            @Override
-            public boolean mockable() {
-                return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());
-            }
-
-            @Override
-            public String nonMockableReason() {
-                if(type.isPrimitive()) {
-                    return "primitive type";
-                }
-                if(Modifier.isFinal(type.getModifiers())) {
-                    return "final or anonymous class";
-                }
-                return join("not handled type");
-            }
-        };
-    }
-}
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/ClassImposterizer.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/ClassImposterizer.java
deleted file mode 100644
index 2d84a066e..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/ClassImposterizer.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import static org.mockito.internal.util.StringJoiner.join;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.Collection;
-import java.util.List;
-import org.mockito.cglib.core.CodeGenerationException;
-import org.mockito.cglib.core.NamingPolicy;
-import org.mockito.cglib.core.Predicate;
-import org.mockito.cglib.proxy.Callback;
-import org.mockito.cglib.proxy.CallbackFilter;
-import org.mockito.cglib.proxy.Enhancer;
-import org.mockito.cglib.proxy.Factory;
-import org.mockito.cglib.proxy.MethodInterceptor;
-import org.mockito.cglib.proxy.NoOp;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.creation.instance.InstantiationException;
-import org.mockito.internal.creation.instance.Instantiator;
-import org.mockito.internal.creation.util.SearchingClassLoader;
-
-/**
- * Inspired on jMock (thanks jMock guys!!!)
- */
-class ClassImposterizer {
-
-    private final Instantiator instantiator;
-
-    public ClassImposterizer(Instantiator instantiator) {
-        this.instantiator = instantiator;
-    }
-
-    private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {
-        @Override
-        public String getClassName(String prefix, String source, Object key, Predicate names) {
-            return "codegen." + super.getClassName(prefix, source, key, names);
-        }
-    };
-
-    private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {
-        public int accept(Method method) {
-            return method.isBridge() ? 1 : 0;
-        }
-    };
-
-    @SuppressWarnings("unchecked")
-    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {
-        return (T) imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));
-    }
-
-    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {
-        Class<Factory> proxyClass = null;
-        Object proxyInstance = null;
-        try {
-            setConstructorsAccessible(mockedType, true);
-            proxyClass = createProxyClass(mockedType, ancillaryTypes);
-            proxyInstance = createProxy(proxyClass, interceptor);
-            return mockedType.cast(proxyInstance);
-        } catch (ClassCastException cce) {
-            throw new MockitoException(join(
-                "ClassCastException occurred while creating the mockito proxy :",
-                "  class to mock : " + describeClass(mockedType),
-                "  created class : " + describeClass(proxyClass),
-                "  proxy instance class : " + describeClass(proxyInstance),
-                "  instance creation by : " + instantiator.getClass().getSimpleName(),
-                "",
-                "You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)"
-            ), cce);
-        } finally {
-            setConstructorsAccessible(mockedType, false);
-        }
-    }
-
-    private static String describeClass(Class type) {
-        return type == null? "null" : "'" + type.getCanonicalName() + "', loaded by classloader : '" + type.getClassLoader() + "'";
-    }
-
-    private static String describeClass(Object instance) {
-        return instance == null? "null" : describeClass(instance.getClass());
-    }
-
-    //TODO this method does not belong here
-    public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {
-        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {
-            constructor.setAccessible(accessible);
-        }
-    }
-
-    public Class<Factory> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {
-        if (mockedType == Object.class) {
-            mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;
-        }
-
-        Enhancer enhancer = new Enhancer() {
-            @Override
-            @SuppressWarnings("unchecked")
-            protected void filterConstructors(Class sc, List constructors) {
-                // Don't filter
-            }
-        };
-        Class<?>[] allMockedTypes = prepend(mockedType, interfaces);
-        enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));
-        enhancer.setUseFactory(true);
-        if (mockedType.isInterface()) {
-            enhancer.setSuperclass(Object.class);
-            enhancer.setInterfaces(allMockedTypes);
-        } else {
-            enhancer.setSuperclass(mockedType);
-            enhancer.setInterfaces(interfaces);
-        }
-        enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});
-        enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);
-        if (mockedType.getSigners() != null) {
-            enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);
-        } else {
-            enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);
-        }
-
-        enhancer.setSerialVersionUID(42L);
-
-        try {
-            return enhancer.createClass();
-        } catch (CodeGenerationException e) {
-            if (Modifier.isPrivate(mockedType.getModifiers())) {
-                throw new MockitoException("\n"
-                        + "Mockito cannot mock this class: " + mockedType
-                        + ".\n"
-                        + "Most likely it is a private class that is not visible by Mockito");
-            }
-            throw new MockitoException("\n"
-                    + "Mockito cannot mock this class: " + mockedType
-                    + "\n"
-                    + "Mockito can only mock visible & non-final classes."
-                    + "\n"
-                    + "If you're not sure why you're getting this error, please report to the mailing list.", e);
-        }
-    }
-
-    private Object createProxy(Class<Factory> proxyClass, final MethodInterceptor interceptor) {
-        Factory proxy;
-        try {
-            proxy = instantiator.newInstance(proxyClass);
-        } catch (InstantiationException e) {
-            throw new MockitoException("Unable to create mock instance of type '" + proxyClass.getSuperclass().getSimpleName() + "'", e);
-        }
-        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });
-        return proxy;
-    }
-
-    private Class<?>[] prepend(Class<?> first, Class<?>... rest) {
-        Class<?>[] all = new Class<?>[rest.length+1];
-        all[0] = first;
-        System.arraycopy(rest, 0, all, 1, rest.length);
-        return all;
-    }
-
-    public static class ClassWithSuperclassToWorkAroundCglibBug {}
-
-}
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java
deleted file mode 100644
index 9a8e963b7..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockito.internal.creation.util.MockitoMethodProxy;
-
-class DelegatingMockitoMethodProxy implements MockitoMethodProxy {
-
-    private final MethodProxy methodProxy;
-
-    public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {
-        this.methodProxy = methodProxy;
-    }
-
-    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {
-        return methodProxy.invokeSuper(target, arguments);
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java
deleted file mode 100644
index bcb2c19b2..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.proxy.MethodInterceptor;
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockito.internal.InternalMockHandler;
-import org.mockito.internal.creation.DelegatingMethod;
-import org.mockito.internal.creation.util.MockitoMethodProxy;
-import org.mockito.internal.invocation.InvocationImpl;
-import org.mockito.internal.invocation.MockitoMethod;
-import org.mockito.internal.invocation.SerializableMethod;
-import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod;
-import org.mockito.internal.progress.SequenceNumber;
-import org.mockito.internal.util.ObjectMethodsGuru;
-import org.mockito.invocation.Invocation;
-import org.mockito.invocation.MockHandler;
-import org.mockito.mock.MockCreationSettings;
-
-import java.io.Serializable;
-import java.lang.reflect.Method;
-
-/**
- * Should be one instance per mock instance, see CglibMockMaker.
- */
-class MethodInterceptorFilter implements MethodInterceptor, Serializable {
-
-    private static final long serialVersionUID = 6182795666612683784L;
-    private final InternalMockHandler handler;
-    final ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();
-    private final MockCreationSettings mockSettings;
-    private final AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();
-
-    public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {
-        this.handler = handler;
-        this.mockSettings = mockSettings;
-    }
-
-    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)
-            throws Throwable {
-        if (objectMethodsGuru.isEqualsMethod(method)) {
-            return proxy == args[0];
-        } else if (objectMethodsGuru.isHashCodeMethod(method)) {
-            return hashCodeForMock(proxy);
-        } else if (acrossJVMSerializationFeature.isWriteReplace(method)) {
-            return acrossJVMSerializationFeature.writeReplace(proxy);
-        }
-        
-        MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);
-        new CGLIBHacker().setMockitoNamingPolicy(methodProxy);
-        
-        MockitoMethod mockitoMethod = createMockitoMethod(method);
-        
-        CleanTraceRealMethod realMethod = new CleanTraceRealMethod(mockitoMethodProxy);
-        Invocation invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);
-        return handler.handle(invocation);
-    }
-   
-    public MockHandler getHandler() {
-        return handler;
-    }
-
-    private int hashCodeForMock(Object mock) {
-        return System.identityHashCode(mock);
-    }
-
-    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {
-        if (mockSettings.isSerializable())
-            return new SerializableMockitoMethodProxy(methodProxy);
-        return new DelegatingMockitoMethodProxy(methodProxy);
-    }
-    
-    public MockitoMethod createMockitoMethod(Method method) {
-        if (mockSettings.isSerializable()) {
-            return new SerializableMethod(method);
-        } else {
-            return new DelegatingMethod(method);
-        }
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java
deleted file mode 100644
index 873b27349..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.core.DefaultNamingPolicy;
-
-class MockitoNamingPolicy extends DefaultNamingPolicy {
-    
-    public static final MockitoNamingPolicy INSTANCE = new MockitoNamingPolicy(); 
-    
-    @Override
-    protected String getTag() {
-        return "ByMockitoWithCGLIB";
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java
deleted file mode 100644
index 7542294c6..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockito.internal.creation.util.MockitoMethodProxy;
-import org.mockito.internal.util.reflection.Whitebox;
-
-import java.io.Serializable;
-
-class SerializableMockitoMethodProxy implements MockitoMethodProxy, Serializable {
-
-    private static final long serialVersionUID = -5337859962876770632L;
-    private final Class<?> c1;
-    private final Class<?> c2;
-    private final String desc;
-    private final String name;
-    private final String superName;
-    transient MethodProxy methodProxy;
-
-    public SerializableMockitoMethodProxy(MethodProxy methodProxy) {
-        assert methodProxy != null;
-        Object info = Whitebox.getInternalState(methodProxy, "createInfo");
-        c1 = (Class<?>) Whitebox.getInternalState(info, "c1");
-        c2 = (Class<?>) Whitebox.getInternalState(info, "c2");
-        desc = methodProxy.getSignature().getDescriptor();
-        name = methodProxy.getSignature().getName();
-        superName = methodProxy.getSuperName();
-        this.methodProxy = methodProxy;
-    }
-
-    private MethodProxy getMethodProxy() {
-        if (methodProxy == null) {
-            methodProxy = MethodProxy.create(c1, c2, desc, name, superName);
-        }
-        return methodProxy;
-    }
-
-    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {
-        return getMethodProxy().invokeSuper(target, arguments);
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/SerializableNoOp.java b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/SerializableNoOp.java
deleted file mode 100644
index 807a6ebf4..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/SerializableNoOp.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.mockito.cglib.proxy.Callback;
-import org.mockito.cglib.proxy.NoOp;
-
-import java.io.Serializable;
-
-/**
- * Offer a Serializable implementation of the NoOp CGLIB callback.
- */
-class SerializableNoOp implements NoOp, Serializable {
-
-    private static final long serialVersionUID = 7434976328690189159L;
-    public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();
-
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/package.html b/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/package.html
deleted file mode 100644
index d195d542e..000000000
--- a/mockmaker/cglib/main/java/org/mockito/internal/creation/cglib/package.html
+++ /dev/null
@@ -1,6 +0,0 @@
-<!--
-  ~ Copyright (c) 2007 Mockito contributors
-  ~ This program is made available under the terms of the MIT License.
-  -->
-
-<body>CGLIB related stuff</body>
\ No newline at end of file
diff --git a/mockmaker/cglib/main/resources/mockito-extensions/org.mockito.plugins.MockMaker b/mockmaker/cglib/main/resources/mockito-extensions/org.mockito.plugins.MockMaker
deleted file mode 100644
index bcfd25b30..000000000
--- a/mockmaker/cglib/main/resources/mockito-extensions/org.mockito.plugins.MockMaker
+++ /dev/null
@@ -1 +0,0 @@
-org.mockito.internal.creation.cglib.CglibMockMaker
diff --git a/mockmaker/cglib/test/java/org/mockito/cglibintegration/DeserializeMockFromFile.java b/mockmaker/cglib/test/java/org/mockito/cglibintegration/DeserializeMockFromFile.java
deleted file mode 100644
index a11064fb8..000000000
--- a/mockmaker/cglib/test/java/org/mockito/cglibintegration/DeserializeMockFromFile.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.cglibintegration;
-
-import org.mockito.Mockito;
-
-import java.io.BufferedInputStream;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.util.Observable;
-
-/**
- * These classes are here purely to show that mocks can be serialized in a different VM
- *
- * Just run as standalone app {@link SerializeMockToFile}, then {@link DeserializeMockFromFile}
- */
-
-public class DeserializeMockFromFile {
-
-    public static void main(String[] args) {
-        Observable o = (Observable) deSerializeObject("mockito_mock.ser");
-
-        // then verify
-        Mockito.verify(o).addObserver(null);
-        Mockito.verify(o).countObservers();
-    }
-
-    private static Object deSerializeObject(String filename) {
-        InputStream is = null;
-        ObjectInputStream ois = null;
-        Object returnObject = null;
-        try {
-
-            is = new BufferedInputStream(new FileInputStream(filename));
-            ois = new ObjectInputStream(is);
-            returnObject = ois.readObject();
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                if (is != null)
-                    is.close();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-            try {
-                if (ois != null)
-                    ois.close();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-        return returnObject;
-    }
-
-}
-
diff --git a/mockmaker/cglib/test/java/org/mockito/cglibintegration/MockUtilTest.java b/mockmaker/cglib/test/java/org/mockito/cglibintegration/MockUtilTest.java
deleted file mode 100644
index cbfa14a69..000000000
--- a/mockmaker/cglib/test/java/org/mockito/cglibintegration/MockUtilTest.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package org.mockito.cglibintegration;
-
-import static org.junit.Assert.fail;
-import java.util.ArrayList;
-import org.junit.Test;
-import org.mockito.cglib.proxy.Enhancer;
-import org.mockito.cglib.proxy.NoOp;
-import org.mockito.exceptions.misusing.NotAMockException;
-import org.mockito.internal.util.MockUtil;
-
-public class MockUtilTest {
-    private MockUtil mockUtil = new MockUtil();
-
-    @Test
-    public void should_scream_when_enhanced_but_not_a_mock_passed() {
-        Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);
-        try {
-            mockUtil.getMockHandler(o);
-            fail();
-        } catch (NotAMockException e) {}
-    }
-}
diff --git a/mockmaker/cglib/test/java/org/mockito/cglibintegration/SerializeMockToFile.java b/mockmaker/cglib/test/java/org/mockito/cglibintegration/SerializeMockToFile.java
deleted file mode 100644
index 97dd32865..000000000
--- a/mockmaker/cglib/test/java/org/mockito/cglibintegration/SerializeMockToFile.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.cglibintegration;
-
-import java.io.BufferedOutputStream;
-import java.io.FileOutputStream;
-import java.io.ObjectOutputStream;
-import java.io.OutputStream;
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.util.Observable;
-import org.mockito.Mockito;
-import org.mockito.cglib.proxy.MethodInterceptor;
-import org.mockito.cglib.proxy.MethodProxy;
-
-/**
- * These classes are here purely to show that mocks can be serialized in a different VM
- *
- * Just run as standalone app {@link SerializeMockToFile}, then {@link DeserializeMockFromFile}
- */
-public class SerializeMockToFile {
-
-    public static void main(String[] args) {
-
-        Observable observable = Mockito.mock(
-                Observable.class,
-                Mockito.withSettings().serializable()
-        );
-
-        // play with mock
-        observable.addObserver(null);
-        observable.countObservers();
-
-        // serialize to file
-        serializeMock(observable, "mockito_mock.ser");
-    }
-
-    private static void serializeMock(Object obj, String filename) {
-        OutputStream os = null;
-        ObjectOutputStream oos = null;
-
-        try {
-            os = new BufferedOutputStream(new FileOutputStream(filename, false));
-            oos = new ObjectOutputStream(os);
-
-            oos.writeObject(obj);
-
-        } catch (Exception e) {
-            e.printStackTrace();
-        } finally {
-            try {
-                if (os != null) os.close();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-            try {
-                if (oos != null) oos.close();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-
-    }
-
-    private static class DefaultMethodInterceptor implements MethodInterceptor, Serializable {
-        private static final long serialVersionUID = 6606245777399406255L;
-
-        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
-            return methodProxy.invokeSuper(o, objects);
-        }
-    }
-}
diff --git a/mockmaker/cglib/test/java/org/mockito/cglibintegration/ThreadsRunAllTestsHalfManualTest.java b/mockmaker/cglib/test/java/org/mockito/cglibintegration/ThreadsRunAllTestsHalfManualTest.java
deleted file mode 100644
index 9532582e1..000000000
--- a/mockmaker/cglib/test/java/org/mockito/cglibintegration/ThreadsRunAllTestsHalfManualTest.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.cglibintegration;
-
-import java.util.LinkedList;
-import java.util.List;
-import org.concurrentmockito.VerificationInOrderFromMultipleThreadsTest;
-import org.junit.Test;
-import org.junit.runner.JUnitCore;
-import org.junit.runner.Result;
-import org.junit.runner.notification.Failure;
-import org.mockito.MockitoTest;
-import org.mockito.exceptions.ReporterTest;
-import org.mockito.exceptions.base.MockitoAssertionErrorTest;
-import org.mockito.exceptions.base.MockitoExceptionTest;
-import org.mockito.internal.AllInvocationsFinderTest;
-import org.mockito.internal.InvalidStateDetectionTest;
-import org.mockito.internal.creation.cglib.ClassImposterizerTest;
-import org.mockito.internal.handler.MockHandlerImplTest;
-import org.mockito.internal.invocation.InvocationImplTest;
-import org.mockito.internal.invocation.InvocationMatcherTest;
-import org.mockito.internal.invocation.InvocationsFinderTest;
-import org.mockito.internal.matchers.ComparableMatchersTest;
-import org.mockito.internal.matchers.EqualsTest;
-import org.mockito.internal.matchers.MatchersToStringTest;
-import org.mockito.internal.progress.MockingProgressImplTest;
-import org.mockito.internal.progress.TimesTest;
-import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;
-import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest;
-import org.mockito.internal.util.MockUtilTest;
-import org.mockito.internal.util.collections.ListUtilTest;
-import org.mockito.internal.verification.DefaultRegisteredInvocationsTest;
-import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;
-import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;
-import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;
-import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;
-import org.mockitousage.basicapi.ReplacingObjectMethodsTest;
-import org.mockitousage.basicapi.ResetTest;
-import org.mockitousage.basicapi.UsingVarargsTest;
-import org.mockitousage.examples.use.ExampleTest;
-import org.mockitousage.matchers.CustomMatchersTest;
-import org.mockitousage.matchers.InvalidUseOfMatchersTest;
-import org.mockitousage.matchers.MatchersTest;
-import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;
-import org.mockitousage.misuse.InvalidUsageTest;
-import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;
-import org.mockitousage.puzzlers.OverloadingPuzzleTest;
-import org.mockitousage.stacktrace.ClickableStackTracesTest;
-import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;
-import org.mockitousage.stacktrace.StackTraceFilteringTest;
-import org.mockitousage.stubbing.BasicStubbingTest;
-import org.mockitousage.stubbing.ReturningDefaultValuesTest;
-import org.mockitousage.stubbing.StubbingWithThrowablesTest;
-import org.mockitousage.verification.AtMostXVerificationTest;
-import org.mockitousage.verification.BasicVerificationInOrderTest;
-import org.mockitousage.verification.BasicVerificationTest;
-import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;
-import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;
-import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;
-import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;
-import org.mockitousage.verification.NoMoreInteractionsVerificationTest;
-import org.mockitousage.verification.RelaxedVerificationInOrderTest;
-import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;
-import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;
-import org.mockitousage.verification.VerificationInOrderTest;
-import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;
-import org.mockitousage.verification.VerificationUsingMatchersTest;
-import org.mockitoutil.TestBase;
-
-public class ThreadsRunAllTestsHalfManualTest extends TestBase {
-
-    private static class AllTestsRunner extends Thread {
-
-        private boolean failed;
-
-        public void run() {
-            Result result = JUnitCore.runClasses(
-                    EqualsTest.class,
-                    ListUtilTest.class,
-                    MockingProgressImplTest.class,
-                    TimesTest.class,
-                    MockHandlerImplTest.class,
-                    AllInvocationsFinderTest.class,
-                    ReturnsEmptyValuesTest.class,
-                    NumberOfInvocationsCheckerTest.class,
-                    DefaultRegisteredInvocationsTest.class,
-                    MissingInvocationCheckerTest.class,
-                    NumberOfInvocationsInOrderCheckerTest.class,
-                    MissingInvocationInOrderCheckerTest.class,
-                    ClassImposterizerTest.class,
-                    InvocationMatcherTest.class,
-                    InvocationsFinderTest.class,
-                    InvocationImplTest.class,
-                    MockitoTest.class,
-                    MockUtilTest.class,
-                    ReporterTest.class,
-                    MockitoAssertionErrorTest.class,
-                    MockitoExceptionTest.class,
-                    StackTraceFilteringTest.class,
-                    BridgeMethodPuzzleTest.class,
-                    OverloadingPuzzleTest.class,
-                    InvalidUsageTest.class,
-                    UsingVarargsTest.class,
-                    CustomMatchersTest.class,
-                    ComparableMatchersTest.class,
-                    InvalidUseOfMatchersTest.class,
-                    MatchersTest.class,
-                    MatchersToStringTest.class,
-                    VerificationAndStubbingUsingMatchersTest.class,
-                    BasicStubbingTest.class,
-                    ReturningDefaultValuesTest.class,
-                    StubbingWithThrowablesTest.class,
-                    AtMostXVerificationTest.class,
-                    BasicVerificationTest.class,
-                    ExactNumberOfTimesVerificationTest.class,
-                    VerificationInOrderTest.class,
-                    NoMoreInteractionsVerificationTest.class,
-                    SelectedMocksInOrderVerificationTest.class,
-                    VerificationOnMultipleMocksUsingMatchersTest.class,
-                    VerificationUsingMatchersTest.class,
-                    RelaxedVerificationInOrderTest.class,
-                    DescriptiveMessagesWhenVerificationFailsTest.class,
-                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,
-                    BasicVerificationInOrderTest.class,
-                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,
-                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,
-                    InvalidStateDetectionTest.class,
-                    ReplacingObjectMethodsTest.class,
-                    ClickableStackTracesTest.class,
-                    ExampleTest.class,
-                    PointingStackTraceToActualInvocationTest.class,
-                    VerificationInOrderFromMultipleThreadsTest.class,
-                    ResetTest.class,
-                    ReturnsGenericDeepStubsTest.class
-                );
-
-                if (!result.wasSuccessful()) {
-                    System.err.println("Thread[" + Thread.currentThread().getId() + "]: error!");
-                    List<Failure> failures = result.getFailures();
-                    System.err.println(failures.size());
-                    for (Failure failure : failures) {
-                        System.err.println(failure.getTrace());
-                        failed = true;
-                    }
-                }
-        }
-
-        public boolean isFailed() {
-            return failed;
-        }
-    }
-
-    @Test
-    public void shouldRunInMultipleThreads() throws Exception {
-        //this test ALWAYS fails if there is a single failing unit
-        assertFalse("Run in multiple thread failed", runInMultipleThreads(3));
-    }
-
-    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {
-        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();
-        for (int i = 1; i <= numberOfThreads; i++) {
-            threads.add(new AllTestsRunner());
-        }
-
-        for (Thread t : threads) {
-            t.start();
-        }
-
-        boolean failed = false;
-        for (AllTestsRunner t : threads) {
-            t.join();
-            failed = failed ? true : t.isFailed();
-        }
-
-        return failed;
-    }
-
-    public static void main(String[] args) throws Exception {
-        int numberOfThreads = 20;
-        long before = System.currentTimeMillis();
-        runInMultipleThreads(numberOfThreads);
-        long after = System.currentTimeMillis();
-        long executionTime = (after-before)/1000;
-        System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds.");
-    }
-}
diff --git a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/CGLIBHackerTest.java b/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/CGLIBHackerTest.java
deleted file mode 100644
index cefc4d780..000000000
--- a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/CGLIBHackerTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.junit.Ignore;
-import org.junit.Test;
-import org.mockito.cglib.core.NamingPolicy;
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockitoutil.TestBase;
-import org.powermock.reflect.Whitebox;
-
-import static org.mockito.Mockito.spy;
-
-@Ignore("Testing Byte Buddy")
-public class CGLIBHackerTest extends TestBase {
-
-    @Test
-    public void shouldSetMockitoNamingPolicy() throws Exception {
-        //given
-        MethodProxy methodProxy = MethodProxy.create(String.class, Integer.class, "", "", "");
-
-        //when
-        new CGLIBHacker().setMockitoNamingPolicy(methodProxy);
-
-        //then
-        Object createInfo = Whitebox.getInternalState(methodProxy, "createInfo");
-        NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, "namingPolicy");
-        assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);
-    }
-
-    @Test
-    public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied() throws Exception {
-        //given
-        MethodProxy proxiedMethodProxy = spy(MethodProxy.create(String.class, Integer.class, "", "", ""));
-
-        //when
-        new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);
-
-        //then
-        Object createInfo = Whitebox.getInternalState(proxiedMethodProxy, "createInfo");
-        NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, "namingPolicy");
-        assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);
-    }
-}
diff --git a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/ClassImposterizerTest.java b/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/ClassImposterizerTest.java
deleted file mode 100644
index 118053d76..000000000
--- a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/ClassImposterizerTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.junit.Test;
-import org.mockito.cglib.proxy.Factory;
-import org.mockito.cglib.proxy.MethodInterceptor;
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockito.internal.creation.instance.ConstructorInstantiator;
-import org.mockito.internal.creation.instance.InstantiatorProvider;
-import org.mockito.internal.creation.settings.CreationSettings;
-import org.mockitoutil.TestBase;
-
-import java.lang.reflect.Method;
-
-import static org.hamcrest.CoreMatchers.instanceOf;
-import static org.hamcrest.CoreMatchers.is;
-
-@SuppressWarnings("unchecked")
-public class ClassImposterizerTest extends TestBase {
-
-    ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator(new CreationSettings()));
-
-    @Test
-    public void shouldCreateMockFromInterface() throws Exception {
-        SomeInterface proxy = imposterizer.imposterise(new MethodInterceptorStub(), SomeInterface.class);
-        
-        Class superClass = proxy.getClass().getSuperclass();
-        assertEquals(Object.class, superClass);
-    }
-    
-    @Test
-    public void shouldCreateMockFromClass() throws Exception {
-        ClassWithoutConstructor proxy = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);
-        
-        Class superClass = proxy.getClass().getSuperclass();
-        assertEquals(ClassWithoutConstructor.class, superClass);
-    }
-    
-    @Test
-    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {
-        try {
-            new ClassWithDodgyConstructor();
-            fail();
-        } catch (Exception e) {}
-        
-        ClassWithDodgyConstructor mock = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);
-        assertNotNull(mock);
-    }
-    
-    @Test 
-    public void shouldMocksHaveDifferentInterceptors() throws Exception {
-        SomeClass mockOne = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);
-        SomeClass mockTwo = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);
-        
-        Factory cglibFactoryOne = (Factory) mockOne;
-        Factory cglibFactoryTwo = (Factory) mockTwo;
-        
-        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));
-    }
-    
-    @Test
-    public void shouldUseAnicilliaryTypes() {
-        SomeClass mock = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);
-        
-        assertThat(mock, is(instanceOf(SomeInterface.class)));
-    }
-
-    @Test
-    public void shouldCreateClassByConstructor() {
-        imposterizer = new ClassImposterizer(new ConstructorInstantiator(null));
-        OtherClass mock = imposterizer.imposterise(new MethodInterceptorStub(), OtherClass.class);
-        assertNotNull(mock);
-    }
-
-    class SomeClass {}
-    interface SomeInterface {}
-    static class OtherClass {}
-    
-    private class ClassWithoutConstructor {}
-
-    private class ClassWithDodgyConstructor {
-        public ClassWithDodgyConstructor() {
-            throw new RuntimeException();
-        }
-    }
-
-    private final class MethodInterceptorStub implements MethodInterceptor {
-
-        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java b/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java
deleted file mode 100644
index 757871034..000000000
--- a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.junit.Test;
-import org.mockito.Mockito;
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockito.internal.InternalMockHandler;
-import org.mockito.internal.creation.DelegatingMethod;
-import org.mockito.internal.creation.MockSettingsImpl;
-import org.mockito.internal.creation.util.MockitoMethodProxy;
-import org.mockito.internal.invocation.InvocationBuilder;
-import org.mockito.internal.invocation.InvocationImpl;
-import org.mockito.internal.invocation.MockitoMethod;
-import org.mockito.internal.invocation.SerializableMethod;
-import org.mockitousage.MethodsImpl;
-import org.mockitoutil.TestBase;
-
-import java.io.ByteArrayOutputStream;
-import java.io.ObjectOutputStream;
-import java.lang.reflect.Method;
-
-import static org.hamcrest.core.IsInstanceOf.instanceOf;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.withSettings;
-
-public class MethodInterceptorFilterTest extends TestBase {
-
-    InternalMockHandler handler = Mockito.mock(InternalMockHandler.class);
-    MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
-
-    @Test
-    public void shouldBeSerializable() throws Exception {
-        new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null, null));
-    }
-
-    @Test
-    public void shouldProvideOwnImplementationOfHashCode() throws Throwable {
-        //when
-        Object ret = filter.intercept(new MethodsImpl(), MethodsImpl.class.getMethod("hashCode"), new Object[0], null);
-
-        //then
-        assertTrue((Integer) ret != 0);
-        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));
-    }
-
-    @Test
-    public void shouldProvideOwnImplementationOfEquals() throws Throwable {
-        //when
-        MethodsImpl proxy = new MethodsImpl();
-        Object ret = filter.intercept(proxy, MethodsImpl.class.getMethod("equals", Object.class), new Object[] {proxy}, null);
-
-        //then
-        assertTrue((Boolean) ret);
-        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));
-    }
-    
-    //TODO: move to separate factory
-    @Test
-    public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {
-        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());
-        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, "", "toString", "toString");
-        
-        // when
-        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);
-        
-        // then
-        assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));
-    }
-    
-    @Test
-    public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {
-        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
-        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, "", "toString", "toString");
-        
-        // when
-        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);
-        
-        // then
-        assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));
-    }
-    
-    @Test
-    public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {
-        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());
-        Method method = new InvocationBuilder().toInvocation().getMethod();
-        
-        // when
-        MockitoMethod mockitoMethod = filter.createMockitoMethod(method);
-        
-        // then
-        assertThat(mockitoMethod, instanceOf(SerializableMethod.class));
-    }
-    
-    @Test
-    public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock() throws Exception {
-        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());
-        Method method = new InvocationBuilder().toInvocation().getMethod();
-        
-        // when
-        MockitoMethod mockitoMethod = filter.createMockitoMethod(method);
-        
-        // then
-        assertThat(mockitoMethod, instanceOf(DelegatingMethod.class));
-    }
-}
\ No newline at end of file
diff --git a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxyTest.java b/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxyTest.java
deleted file mode 100644
index 649cfc5d2..000000000
--- a/mockmaker/cglib/test/java/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxyTest.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.cglib;
-
-import org.junit.Test;
-import org.mockito.cglib.proxy.MethodProxy;
-import org.mockitoutil.TestBase;
-import org.powermock.reflect.Whitebox;
-
-public class SerializableMockitoMethodProxyTest extends TestBase {
-
-    @Test
-    public void shouldCreateCorrectCreationInfo() throws Exception {
-        // given
-        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, "", "", "");
-        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);
-        serializableMockitoMethodProxy.methodProxy = null;
-
-        // when
-        Object methodProxy = Whitebox.invokeMethod(serializableMockitoMethodProxy, "getMethodProxy",  new Object[0]);
-
-        // then
-        Object info = Whitebox.getInternalState(methodProxy, "createInfo");
-        assertEquals(String.class, Whitebox.getInternalState(info, "c1"));
-        assertEquals(Integer.class, Whitebox.getInternalState(info, "c2"));
-    }
-
-    @Test
-    public void shouldCreateCorrectSignatures() throws Exception {
-        // given
-        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, "a", "b", "c");
-        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);
-        serializableMockitoMethodProxy.methodProxy = null;
-
-        // when
-        MethodProxy methodProxy = (MethodProxy) Whitebox.invokeMethod(serializableMockitoMethodProxy, "getMethodProxy",  new Object[0]);
-
-        // then
-        assertEquals("a", methodProxy.getSignature().getDescriptor());
-        assertEquals("b", methodProxy.getSignature().getName());
-        assertEquals("c", methodProxy.getSuperName());
-    }
-
-    @Override
-    public String toString() {
-        return "SerializableMockitoMethodProxyTest []";
-    }
-
-}
