diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
index 50baa3c2f..8d150ff78 100644
--- a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
+++ b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
@@ -62,6 +62,48 @@ public abstract class GenericMetadataSupport {
      */
     protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();
 
+    /**
+     * Registers the type variables for the given type and all of its superclasses and superinterfaces.
+     */
+    protected void registerAllTypeVariables(Type classType) {
+        Queue<Type> typesToRegister = new LinkedList<Type>();
+        Set<Type> registeredTypes = new HashSet<Type>();
+        typesToRegister.add(classType);
+
+        while (!typesToRegister.isEmpty()) {
+            Type typeToRegister = typesToRegister.poll();
+            if (typeToRegister == null || registeredTypes.contains(typeToRegister)) {
+                continue;
+            }
+
+            registerTypeVariablesOn(typeToRegister);
+            registeredTypes.add(typeToRegister);
+
+            Class<?> rawType = extractRawTypeOf(typeToRegister);
+            typesToRegister.add(rawType.getGenericSuperclass());
+            typesToRegister.addAll(Arrays.asList(rawType.getGenericInterfaces()));
+        }
+    }
+
+    protected Class<?> extractRawTypeOf(Type type) {
+        if (type instanceof Class) {
+            return (Class<?>) type;
+        }
+        if (type instanceof ParameterizedType) {
+            return (Class<?>) ((ParameterizedType) type).getRawType();
+        }
+        if (type instanceof BoundedType) {
+            return extractRawTypeOf(((BoundedType) type).firstBound());
+        }
+        if (type instanceof TypeVariable) {
+            /*
+             * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
+             * on the class definition, such as such as List<E>.
+             */
+            return extractRawTypeOf(contextualActualTypeParameters.get(type));
+        }
+        throw new MockitoException("Raw extraction not supported for : '" + type + "'");
+    }
 
     protected void registerTypeVariablesOn(Type classType) {
         if (!(classType instanceof ParameterizedType)) {
@@ -270,28 +312,8 @@ public abstract class GenericMetadataSupport {
         public FromClassGenericMetadataSupport(Class<?> clazz) {
             this.clazz = clazz;
 
-            for (Class<?> currentExploredClass = clazz;
-                 currentExploredClass != null && currentExploredClass != Object.class;
-                 currentExploredClass = superClassOf(currentExploredClass)) {
-                readActualTypeParametersOnDeclaringClass(currentExploredClass);
-            }
-        }
-
-        private Class superClassOf(Class<?> currentExploredClass) {
-            Type genericSuperclass = currentExploredClass.getGenericSuperclass();
-            if (genericSuperclass instanceof ParameterizedType) {
-                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();
-                return (Class<?>) rawType;
-            }
-            return (Class<?>) genericSuperclass;
-        }
-
-        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {
             registerTypeParametersOn(clazz.getTypeParameters());
-            registerTypeVariablesOn(clazz.getGenericSuperclass());
-            for (Type genericInterface : clazz.getGenericInterfaces()) {
-                registerTypeVariablesOn(genericInterface);
-            }
+            registerAllTypeVariables(clazz);
         }
 
         @Override
@@ -321,8 +343,7 @@ public abstract class GenericMetadataSupport {
         }
 
         private void readActualTypeParameters() {
-            registerTypeVariablesOn(parameterizedType.getRawType());
-            registerTypeVariablesOn(parameterizedType);
+            registerAllTypeVariables(parameterizedType);
         }
 
         @Override
@@ -403,26 +424,6 @@ public abstract class GenericMetadataSupport {
             return rawType;
         }
 
-        private Class<?> extractRawTypeOf(Type type) {
-            if (type instanceof Class) {
-                return (Class<?>) type;
-            }
-            if (type instanceof ParameterizedType) {
-                return (Class<?>) ((ParameterizedType) type).getRawType();
-            }
-            if (type instanceof BoundedType) {
-                return extractRawTypeOf(((BoundedType) type).firstBound());
-            }
-            if (type instanceof TypeVariable) {
-                /*
-                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared
-                 * on the class definition, such as such as List<E>.
-                 */
-                return extractRawTypeOf(contextualActualTypeParameters.get(type));
-            }
-            throw new MockitoException("Raw extraction not supported for : '" + type + "'");
-        }
-
         @Override
         public List<Type> extraInterfaces() {
             Type type = extractActualBoundedTypeOf(typeVariable);
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
index 44066b8ce..f580b359a 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
@@ -19,6 +19,8 @@ import static org.mockito.Mockito.mock;
 public class ReturnsGenericDeepStubsTest {
     interface ListOfInteger extends List<Integer> {}
 
+    interface AnotherListOfInteger extends ListOfInteger {}
+
     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
         Set<Number> remove(Object key); // override with fixed ParameterizedType
         List<? super Number> returningWildcard();
@@ -93,9 +95,11 @@ public class ReturnsGenericDeepStubsTest {
     public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {
         GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);
         ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);
+        AnotherListOfInteger anotherListOfInteger = mock(AnotherListOfInteger.class, RETURNS_DEEP_STUBS);
 
         assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();
         assertThat(listOfInteger.get(25)).isEqualTo(0);
+        assertThat(anotherListOfInteger.get(25)).isEqualTo(0);
     }
 
     @Test(expected = ClassCastException.class)
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
index d068e043d..dff0d7f3e 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
@@ -28,6 +28,11 @@ public class GenericMetadataSupportTest {
         E get();
     }
     interface ListOfNumbers extends List<Number> {}
+    interface AnotherListOfNumbers extends ListOfNumbers {}
+
+    abstract class ListOfNumbersImpl implements ListOfNumbers {}
+    abstract class AnotherListOfNumbersImpl extends ListOfNumbersImpl {}
+
     interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}
 
     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
@@ -76,6 +81,13 @@ public class GenericMetadataSupportTest {
         assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();
     }
 
+    @Test
+    public void can_resolve_type_variables_from_ancestors() throws Exception {
+        Method listGet = List.class.getMethod("get", int.class);
+        assertThat(inferFrom(AnotherListOfNumbers.class).resolveGenericReturnType(listGet).rawType()).isEqualTo(Number.class);
+        assertThat(inferFrom(AnotherListOfNumbersImpl.class).resolveGenericReturnType(listGet).rawType()).isEqualTo(Number.class);
+    }
+
     @Test
     public void can_get_type_variables_from_ParameterizedType() throws Exception {
         assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).extracting("name").contains("K", "V");
