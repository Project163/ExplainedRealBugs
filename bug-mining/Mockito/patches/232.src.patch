diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldReader.java b/src/main/java/org/mockito/internal/util/reflection/FieldReader.java
index e202c714a..6c3c120ee 100644
--- a/src/main/java/org/mockito/internal/util/reflection/FieldReader.java
+++ b/src/main/java/org/mockito/internal/util/reflection/FieldReader.java
@@ -30,7 +30,7 @@ public class FieldReader {
             return accessor.get(field, target);
         } catch (Exception e) {
             throw new MockitoException(
-                    "Cannot read state from field: " + field + ", on instance: " + target);
+                    "Cannot read state from field: " + field + ", on instance: " + target, e);
         }
     }
 }
diff --git a/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleAccessTest.java b/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleAccessTest.java
index 6382a253b..55923e77b 100644
--- a/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleAccessTest.java
+++ b/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleAccessTest.java
@@ -5,6 +5,8 @@
 package org.mockito.moduletest;
 
 import org.junit.Test;
+import org.mockito.Mockito;
+import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.ModuleMemberAccessor;
 import org.mockito.internal.util.reflection.ReflectionMemberAccessor;
 
@@ -68,4 +70,25 @@ public class ModuleAccessTest {
             Thread.currentThread().setContextClassLoader(contextLoader);
         }
     }
+
+    @Test
+    public void cannot_read_unopened_private_field_but_exception_includes_cause() throws Exception {
+        Path jar = modularJar(true, true, false, true);
+        ModuleLayer layer = layer(jar, true, true);
+
+        ClassLoader loader = layer.findLoader("mockito.test");
+        Class<?> type = loader.loadClass("sample.MyCallable");
+
+        @SuppressWarnings("unchecked")
+        Callable<String> testInstance = (Callable<String>) type.getDeclaredConstructor().newInstance();
+        try {
+            Mockito.mockitoSession()
+                .initMocks(testInstance)
+                .startMocking();
+            fail("Expected MockitoException caused by IllegalAccessException");
+        } catch (MockitoException ex) {
+            assertThat(ex.getCause()).isInstanceOf(IllegalAccessException.class);
+        }
+    }
+
 }
diff --git a/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleUtil.java b/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleUtil.java
index 49632fd71..14838043c 100644
--- a/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleUtil.java
+++ b/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleUtil.java
@@ -6,6 +6,7 @@ package org.mockito.moduletest;
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.modifier.Visibility;
+import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.implementation.FixedValue;
 import net.bytebuddy.jar.asm.ClassWriter;
 import net.bytebuddy.jar.asm.ModuleVisitor;
@@ -30,23 +31,31 @@ import static net.bytebuddy.matcher.ElementMatchers.named;
 public class ModuleUtil {
 
     public static Path modularJar(boolean isPublic, boolean isExported, boolean isOpened) throws IOException {
+        return modularJar(isPublic, isExported, isOpened, false);
+    }
+    public static Path modularJar(boolean isPublic, boolean isExported, boolean isOpened, boolean addField) throws IOException {
         Path jar = Files.createTempFile("sample-module", ".jar");
         try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jar))) {
             out.putNextEntry(new JarEntry("module-info.class"));
             out.write(moduleInfo(isExported, isOpened));
             out.closeEntry();
             out.putNextEntry(new JarEntry("sample/MyCallable.class"));
-            out.write(type(isPublic));
+            out.write(type(isPublic, addField));
             out.closeEntry();
         }
         return jar;
     }
 
-    private static byte[] type(boolean isPublic) {
-        return new ByteBuddy()
+    private static byte[] type(boolean isPublic, boolean addField) {
+        DynamicType.Builder<?> typeBuilder = new ByteBuddy()
             .subclass(Callable.class)
             .name("sample.MyCallable")
-            .merge(isPublic ? Visibility.PUBLIC : Visibility.PACKAGE_PRIVATE)
+            .merge(isPublic ? Visibility.PUBLIC : Visibility.PACKAGE_PRIVATE);
+        if (addField) {
+            typeBuilder = typeBuilder
+                .defineField("runnable", Runnable.class, Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL);
+        }
+        return typeBuilder
             .method(named("call"))
             .intercept(FixedValue.value("foo"))
             .make()
