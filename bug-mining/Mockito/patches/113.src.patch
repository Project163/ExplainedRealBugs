diff --git a/src/main/java/org/mockito/MockSettings.java b/src/main/java/org/mockito/MockSettings.java
index 137764c35..29745d407 100644
--- a/src/main/java/org/mockito/MockSettings.java
+++ b/src/main/java/org/mockito/MockSettings.java
@@ -240,19 +240,25 @@ public interface MockSettings extends Serializable {
      * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
      *   .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
      *
+     * //Mocking an abstract class with constructor arguments
+     * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
+     *   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));
+     *
      * //Mocking a non-static inner abstract class:
      * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
      *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
      * </code></pre>
      *
+     * @param args The arguments to pass to the constructor. Not passing any arguments means that a parameter-less
+     *             constructor will be called
      * @return settings instance so that you can fluently specify other settings
-     * @since 1.10.12
+     * @since 2.7.14 (useConstructor with no arguments was supported since 1.10.12)
      */
     @Incubating
-    MockSettings useConstructor();
+    MockSettings useConstructor(Object... args);
 
     /**
-     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor()}.
+     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor(Object...)}.
      * <p>
      * Example:
      * <pre class="code"><code class="java">
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index 8db730489..5e74aa779 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -65,7 +65,7 @@ import org.mockito.verification.*;
  *      <a href="#27">27. Delegate calls to real instance (Since 1.9.5)</a><br/>
  *      <a href="#28">28. <code>MockMaker</code> API (Since 1.9.5)</a><br/>
  *      <a href="#29">29. BDD style verification (Since 1.10.0)</a><br/>
- *      <a href="#30">30. Spying or mocking abstract classes (Since 1.10.12) and Java 8 default methods (Since release 2.x)</a><br/>
+ *      <a href="#30">30. Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)</a><br/>
  *      <a href="#31">31. Mockito mocks can be <em>serialized</em> / <em>deserialized</em> across classloaders (Since 1.10.0)</a></h3><br/>
  *      <a href="#32">32. Better generic support with deep stubs (Since 1.10.0)</a></h3><br/>
  *      <a href="#32">33. Mockito JUnit rule (Since 1.10.17)</a><br/>
@@ -1017,7 +1017,7 @@ import org.mockito.verification.*;
  *
  *
  *
- * <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">Spying or mocking abstract classes (Since 1.10.12) and Java 8 default methods (Since release 2.x)</a></h3>
+ * <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)</a></h3>
  *
  * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).
  * <p>
@@ -1030,19 +1030,23 @@ import org.mockito.verification.*;
  * //convenience API, new overloaded spy() method:
  * SomeAbstract spy = spy(SomeAbstract.class);
  *
- * // Mocking abstract methods, spying default methods of an interface
+ * //Mocking abstract methods, spying default methods of an interface (only avilable since 2.7.13)
  * Function<Foo, Bar> function = spy(Function.class);
  *
  * //Robust API, via settings builder:
  * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
  *    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
  *
+ * //Mocking an abstract class with constructor arguments (only available since 2.7.14)
+ * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
+ *   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));
+ *
  * //Mocking a non-static inner abstract class:
  * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
  *    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
  * </code></pre>
  *
- * For more information please see {@link MockSettings#useConstructor()}.
+ * For more information please see {@link MockSettings#useConstructor(Object...)}.
  *
  *
  *
diff --git a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
index 0b761747c..ec0109afc 100644
--- a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
+++ b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
@@ -9,6 +9,7 @@ import org.mockito.MockSettings;
 import static org.mockito.internal.exceptions.Reporter.*;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.debugging.VerboseMockInvocationLogger;
+import org.mockito.internal.util.Checks;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockNameImpl;
 import org.mockito.listeners.InvocationListener;
@@ -18,6 +19,8 @@ import org.mockito.mock.SerializableMode;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -30,6 +33,7 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
     private static final long serialVersionUID = 4475297236197939569L;
     private boolean useConstructor;
     private Object outerClassInstance;
+    private Object[] constructorArgs;
 
     public MockSettings serializable() {
         return serializable(SerializableMode.BASIC);
@@ -95,8 +99,12 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return this;
     }
 
-    public MockSettings useConstructor() {
+    public MockSettings useConstructor(Object... constructorArgs) {
+        Checks.checkNotNull(constructorArgs,
+            "constructorArgs",
+            "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
         this.useConstructor = true;
+        this.constructorArgs = constructorArgs;
         return this;
     }
 
@@ -113,6 +121,16 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return outerClassInstance;
     }
 
+    public Object[] getConstructorArgs() {
+        if (outerClassInstance == null) {
+            return constructorArgs;
+        }
+        List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
+        resultArgs.add(outerClassInstance);
+        resultArgs.addAll(Arrays.asList(constructorArgs));
+        return resultArgs.toArray(new Object[constructorArgs.length + 1]);
+    }
+
     public boolean isStubOnly() {
         return this.stubOnly;
     }
diff --git a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
index 049d1b8e3..7161fa78e 100644
--- a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
+++ b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
@@ -5,59 +5,110 @@
 package org.mockito.internal.creation.instance;
 
 import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.mockito.internal.util.Primitives;
 import org.mockito.internal.util.reflection.AccessibilityChanger;
 
 import static org.mockito.internal.util.StringUtil.join;
 
 public class ConstructorInstantiator implements Instantiator {
 
-    private final Object outerClassInstance;
+    /**
+     * Whether or not the constructors used for creating an object refer to an outer instance or not.
+     * This member is only used to for constructing error messages.
+     * If an outer inject exists, it would be the first ([0]) element of the {@link #constructorArgs} array.
+     */
+    private final boolean hasOuterClassInstance;
+    private final Object[] constructorArgs;
 
-    public ConstructorInstantiator(Object outerClassInstance) {
-        this.outerClassInstance = outerClassInstance;
+    public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
+        this.hasOuterClassInstance = hasOuterClassInstance;
+        this.constructorArgs = constructorArgs;
     }
 
     public <T> T newInstance(Class<T> cls) {
-        if (outerClassInstance == null) {
-            return noArgConstructor(cls);
-        }
-        return withParams(cls, outerClassInstance);
+        return withParams(cls, constructorArgs);
     }
 
-    private static <T> T withParams(Class<T> cls, Object... params) {
+    private <T> T withParams(Class<T> cls, Object... params) {
+        List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
         try {
-            //this is kind of over-engineered because we don't need to support more params
-            //however, I know we will be needing it :)
             for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
                 Class<?>[] types = constructor.getParameterTypes();
                 if (paramsMatch(types, params)) {
-                    return invokeConstructor(constructor, params);
+                    matchingConstructors.add(constructor);
                 }
             }
+
+            if (matchingConstructors.size() == 1) {
+                return invokeConstructor(matchingConstructors.get(0), params);
+            }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
-        throw noMatchingConstructor(cls);
+        if (matchingConstructors.size() == 0) {
+            throw noMatchingConstructor(cls);
+        } else {
+            throw multipleMatchingConstructors(cls, matchingConstructors);
+        }
     }
 
     @SuppressWarnings("unchecked")
-    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
+    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
         AccessibilityChanger accessibility = new AccessibilityChanger();
         accessibility.enableAccess(constructor);
         return (T) constructor.newInstance(params);
     }
 
-    private static <T> InstantiationException paramsException(Class<T> cls, Exception cause) {
-        return new InstantiationException(
-                join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                     "Please ensure that the outer instance has correct type and that the target class has 0-arg constructor."),
-                cause);
+    private InstantiationException paramsException(Class<?> cls, Exception e) {
+        return new InstantiationException(join(
+                "Unable to create instance of '" + cls.getSimpleName() + "'.",
+                "Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
+                , e);
     }
 
-    private static <T> InstantiationException noMatchingConstructor(Class<T> cls) {
-        return new InstantiationException(
-                join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                     "Unable to find a matching 1-arg constructor for the outer instance.")
+    private String constructorArgTypes() {
+        int argPos = 0;
+        if (hasOuterClassInstance) {
+            ++argPos;
+        }
+        String[] constructorArgTypes = new String[constructorArgs.length - argPos];
+        for (int i = argPos; i < constructorArgs.length; ++i) {
+            constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
+        }
+        return Arrays.toString(constructorArgTypes);
+    }
+
+    private InstantiationException noMatchingConstructor(Class<?> cls) {
+        String constructorString = constructorArgsString();
+        String outerClassString = "";
+        if (hasOuterClassInstance) {
+            outerClassString = " and that it's indeed an inner class of the passed instance of type " +
+                constructorArgs[0].getClass().getName();
+        }
+        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
+                "Please ensure that the target class has " + constructorString + outerClassString + ".")
+                , null);
+    }
+
+    private String constructorArgsString() {
+        String constructorString;
+        if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
+            constructorString = "a 0-arg constructor";
+        } else {
+            constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
+        }
+        return constructorString;
+    }
+
+    private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
+        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
+                "Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
+                join("", constructors))
                 , null);
     }
 
@@ -66,21 +117,15 @@ public class ConstructorInstantiator implements Instantiator {
             return false;
         }
         for (int i = 0; i < params.length; i++) {
-            if (!types[i].isInstance(params[i])) {
+            if (params[i] == null) {
+                if (types[i].isPrimitive()) {
+                    return false;
+                }
+            } else if ((!types[i].isPrimitive() && !types[i].isInstance(params[i])) ||
+                    (types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
                 return false;
             }
         }
         return true;
     }
-
-    private static <T> T noArgConstructor(Class<T> cls) {
-        try {
-            return invokeConstructor(cls.getDeclaredConstructor());
-        } catch (Throwable t) {
-            throw new InstantiationException(join(
-                    "Unable to create instance of '" + cls.getSimpleName() + "'.",
-                    "Please ensure it has 0-arg constructor which invokes cleanly."),
-                                             t);
-        }
-    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
index fe44b6fd3..22d06d116 100644
--- a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
+++ b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
@@ -12,8 +12,8 @@ public class DefaultInstantiatorProvider implements InstantiatorProvider {
     private final static Instantiator INSTANCE = new ObjenesisInstantiator();
 
     public Instantiator getInstantiator(MockCreationSettings<?> settings) {
-        if (settings != null && settings.isUsingConstructor()) {
-            return new ConstructorInstantiator(settings.getOuterClassInstance());
+        if (settings != null && settings.getConstructorArgs() != null) {
+            return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
         } else {
             return INSTANCE;
         }
diff --git a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
index f40450cfe..3fe179999 100644
--- a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
+++ b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
@@ -32,6 +32,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
     protected boolean stubOnly;
     private boolean useConstructor;
     private Object outerClassInstance;
+    private Object[] constructorArgs;
 
     public CreationSettings() {}
 
@@ -48,6 +49,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         this.stubOnly = copy.stubOnly;
         this.useConstructor = copy.isUsingConstructor();
         this.outerClassInstance = copy.getOuterClassInstance();
+        this.constructorArgs = copy.getConstructorArgs();
     }
 
     public Class<T> getTypeToMock() {
@@ -114,6 +116,11 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         return useConstructor;
     }
 
+    @Override
+    public Object[] getConstructorArgs() {
+        return constructorArgs;
+    }
+
     public Object getOuterClassInstance() {
         return outerClassInstance;
     }
diff --git a/src/main/java/org/mockito/mock/MockCreationSettings.java b/src/main/java/org/mockito/mock/MockCreationSettings.java
index f27d48146..a0c088b87 100644
--- a/src/main/java/org/mockito/mock/MockCreationSettings.java
+++ b/src/main/java/org/mockito/mock/MockCreationSettings.java
@@ -72,6 +72,18 @@ public interface MockCreationSettings<T> {
     @Incubating
     boolean isUsingConstructor();
 
+    /**
+     * Used when arguments should be passed to the mocked object's constructor, regardless of whether these
+     * arguments are supplied directly, or whether they include the outer instance.
+     *
+     * @return An array of arguments that are passed to the mocked object's constructor. If
+     * {@link #getOuterClassInstance()} is available, it is prepended to the passed arguments.
+     *
+     * @since 2.7.14
+     */
+    @Incubating
+    public Object[] getConstructorArgs();
+
     /**
      * Used when mocking non-static inner classes in conjunction with {@link #isUsingConstructor()}
      *
diff --git a/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java b/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
index b669fa0a2..cf30bc1ce 100644
--- a/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
+++ b/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
@@ -28,25 +28,52 @@ public class ConstructorInstantiatorTest extends TestBase {
         }
     }
 
+    static class SomeClass3 {
+
+        SomeClass3(int i) {
+
+        }
+    }
+
     @Test
     public void creates_instances() {
-        assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);
+        assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
     }
 
     @Test
     public void creates_instances_of_inner_classes() {
-        assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
-        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
+        assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
+        assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
+    }
+
+    @Test
+    public void creates_instances_with_arguments() {
+        assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
+    }
+
+    @Test
+    public void creates_instances_with_null_arguments() {
+        assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
+    }
+
+    @Test
+    public void creates_instances_with_primitive_arguments() {
+        assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
+    }
+
+    @Test(expected = InstantiationException.class)
+    public void fails_when_null_is_passed_for_a_primitive() {
+        assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
     }
 
     @Test
     public void explains_when_constructor_cannot_be_found() {
         try {
-            new ConstructorInstantiator(null).newInstance(SomeClass2.class);
+            new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
             fail();
         } catch (InstantiationException e) {
             assertThat(e).hasMessageContaining("Unable to create instance of 'SomeClass2'.\n" +
-                    "Please ensure it has 0-arg constructor which invokes cleanly.");
+                    "Please ensure that the target class has a 0-arg constructor.");
         }
     }
 }
diff --git a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
index 2295593e3..e1843d570 100644
--- a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
+++ b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
@@ -24,6 +24,12 @@ public class CreatingMocksWithConstructorTest extends TestBase {
         AbstractMessage() {
             this.message = "hey!";
         }
+        AbstractMessage(String message) {
+            this.message = message;
+        }
+        AbstractMessage(int i) {
+            this.message = String.valueOf(i);
+        }
         String getMessage() {
             return message;
         }
@@ -51,12 +57,64 @@ public class CreatingMocksWithConstructorTest extends TestBase {
         assertEquals("hey!", mock.getMessage());
     }
 
+    @Test
+    public void can_spy_abstract_classes_with_constructor_args() {
+        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("hello!", mock.getMessage());
+    }
+
+    @Test
+    public void can_spy_abstract_classes_with_constructor_primitive_args() {
+        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("7", mock.getMessage());
+    }
+
+    @Test
+    public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
+        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
+        assertNull(mock.getMessage());
+    }
+
+    @Test
+    public void can_spy_abstract_classes_with_casted_null() {
+        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
+        assertNull(mock.getMessage());
+    }
+
+    @Test
+    public void can_spy_abstract_classes_with_null_varargs() {
+        try {
+            mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
+                "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
+        }
+    }
+
     @Test
     public void can_mock_inner_classes() {
         InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("hey!", mock.getMessage());
     }
 
+    public static class ThrowingConstructorClass{
+        public ThrowingConstructorClass() {
+            throw new RuntimeException();
+        }
+    }
+
+    @Test
+    public void explains_constructor_exceptions() {
+        try {
+            ThrowingConstructorClass mock = mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
+            fail();
+        } catch (MockitoException e) {
+            assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
+            assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
+        }
+    }
+
     static class HasConstructor {
         HasConstructor(String x) {}
     }
@@ -70,7 +128,49 @@ public class CreatingMocksWithConstructorTest extends TestBase {
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessage("Unable to create mock instance of type 'HasConstructor'");
-            assertThat(e.getCause()).hasMessageContaining("0-arg constructor");
+            assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
+        }
+    }
+
+    static class Base {}
+    static class ExtendsBase extends Base {}
+    static class ExtendsExtendsBase extends ExtendsBase {}
+
+    static class UsesBase {
+        public UsesBase(Base b) {}
+        public UsesBase(ExtendsBase b) {}
+    }
+
+    @Test
+    public void can_mock_unambigous_constructor_with_inheritence() {
+        UsesBase mock = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
+    }
+
+    @Test
+    public void exception_message_when_ambiguous_constructor_found_exact_exists() {
+        try {
+            //when
+            UsesBase mock = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+            //then
+            fail();
+        } catch (MockitoException e) {
+            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
+            assertThat(e.getCause()).hasMessageContaining
+                ("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]");
+        }
+    }
+
+    @Test
+    public void exception_message_when_ambiguous_constructor_found_exact_doesnt_exist() {
+        try {
+            //when
+            UsesBase mock = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+            //then
+            fail();
+        } catch (MockitoException e) {
+            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
+            assertThat(e.getCause()).hasMessageContaining
+                ("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsExtendsBase]");
         }
     }
 
@@ -78,12 +178,14 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     public void mocking_inner_classes_with_wrong_outer_instance() {
         try {
             //when
-            mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));
+            mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
             //then
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessage("Unable to create mock instance of type 'InnerClass'");
-            assertThat(e.getCause()).hasMessageContaining("Unable to find a matching 1-arg constructor for the outer instance.");
+            assertThat(e.getCause()).hasMessageContaining(
+                "Please ensure that the target class has a 0-arg constructor"
+                    + " and that it's indeed an inner class of the passed instance of type java.lang.Integer");
         }
     }
 
