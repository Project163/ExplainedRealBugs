diff --git a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
index 802834ee3..edf47c911 100644
--- a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
+++ b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
@@ -40,7 +40,7 @@ public class ConstructorInstantiator implements Instantiator {
             for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
                 Class<?>[] types = constructor.getParameterTypes();
                 if (paramsMatch(types, params)) {
-                    matchingConstructors.add(constructor);
+                    evaluateConstructor(matchingConstructors, constructor);
                 }
             }
 
@@ -108,7 +108,7 @@ public class ConstructorInstantiator implements Instantiator {
         return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
                 "Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
                 join("", " - ", constructors),
-                "If you believe that Mockito could do a better join deciding on which constructor to use, please let us know.",
+                "If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.",
                 "Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.",
                 "See https://github.com/mockito/mockito/issues/685"
             ), null);
@@ -130,4 +130,55 @@ public class ConstructorInstantiator implements Instantiator {
         }
         return true;
     }
+
+    /**
+     * Evalutes {@code constructor} against the currently found {@code matchingConstructors} and determines if
+     * it's a better match to the given arguments, a worse match, or an equivalently good match.
+     * <p>
+     * This method tries to emulate the behavior specified in
+     * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2">JLS 15.12.2. Compile-Time
+     * Step 2: Determine Method Signature</a>. A constructor X is deemed to be a better match than constructor Y to the
+     * given argument list if they are both applicable, constructor X has at least one parameter than is more specific
+     * than the corresponding parameter of constructor Y, and constructor Y has no parameter than is more specific than
+     * the corresponding parameter in constructor X.
+     * </p>
+     * <p>
+     * If {@code constructor} is a better match than the constructors in the {@code matchingConstructors} list, the list
+     * is cleared, and it's added to the list as a singular best matching constructor (so far).<br/>
+     * If {@code constructor} is an equivalently good of a match as the constructors in the {@code matchingConstructors}
+     * list, it's added to the list.<br/>
+     * If {@code constructor} is a worse match than the constructors in the {@code matchingConstructors} list, the list
+     * will remain unchanged.
+     * </p>
+     *
+     * @param matchingConstructors A list of equivalently best matching constructors found so far
+     * @param constructor The constructor to be evaluated against this list
+     */
+    private void evaluateConstructor(List<Constructor<?>> matchingConstructors, Constructor<?> constructor) {
+        boolean newHasBetterParam = false;
+        boolean existingHasBetterParam = false;
+
+        Class<?>[] paramTypes = constructor.getParameterTypes();
+        for (int i = 0; i < paramTypes.length; ++i) {
+            Class<?> paramType = paramTypes[i];
+            if (!paramType.isPrimitive()) {
+                for (Constructor<?> existingCtor : matchingConstructors) {
+                    Class<?> existingParamType = existingCtor.getParameterTypes()[i];
+                    if (paramType != existingParamType) {
+                        if (paramType.isAssignableFrom(existingParamType)) {
+                            existingHasBetterParam = true;
+                        } else {
+                            newHasBetterParam = true;
+                        }
+                    }
+                }
+            }
+        }
+        if (!existingHasBetterParam) {
+            matchingConstructors.clear();
+        }
+        if (newHasBetterParam || !existingHasBetterParam) {
+            matchingConstructors.add(constructor);
+        }
+    }
 }
diff --git a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
index 2a4e5034a..cd8596cd5 100644
--- a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
+++ b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
@@ -137,43 +137,91 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     static class ExtendsExtendsBase extends ExtendsBase {}
 
     static class UsesBase {
-        public UsesBase(Base b) {}
-        public UsesBase(ExtendsBase b) {}
+        public UsesBase(Base b) {
+            constructorUsed = "Base";
+        }
+        public UsesBase(ExtendsBase b) {
+            constructorUsed = "ExtendsBase";
+        }
+
+        private String constructorUsed = null;
+        String getConstructorUsed() {
+            return constructorUsed;
+        }
     }
 
     @Test
-    public void can_mock_unambigous_constructor_with_inheritence() {
-        mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
+    public void can_mock_unambigous_constructor_with_inheritance_base_class_exact_match() {
+        UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("Base", u.getConstructorUsed());
     }
 
     @Test
-    public void exception_message_when_ambiguous_constructor_found_exact_exists() throws Exception {
-        try {
-            //when
-            mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
-            //then
-            fail();
-        } catch (MockitoException e) {
-            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
-            assertThat(e.getCause()).hasMessageContaining
-                ("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]");
+    public void can_mock_unambigous_constructor_with_inheritance_extending_class_exact_match() {
+        UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("ExtendsBase", u.getConstructorUsed());
+    }
+
+    @Test
+    public void can_mock_unambigous_constructor_with_inheritance_non_exact_match() {
+        UsesBase u = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("ExtendsBase", u.getConstructorUsed());
+    }
+
+    static class UsesTwoBases {
+        public UsesTwoBases(Base b1, Base b2) {
+            constructorUsed = "Base,Base";
+        }
+        public UsesTwoBases(ExtendsBase b1, Base b2) {
+            constructorUsed = "ExtendsBase,Base";
+        }
+        public UsesTwoBases(Base b1, ExtendsBase b2) {
+            constructorUsed = "Base,ExtendsBase";
+        }
+
+        private String constructorUsed = null;
+        String getConstructorUsed() {
+            return constructorUsed;
         }
     }
 
     @Test
-    public void fail_when_multiple_matching_constructors() {
+    public void can_mock_unambigous_constructor_with_inheritance_multiple_base_class_exact_match() {
+        UsesTwoBases u =
+            mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("Base,Base", u.getConstructorUsed());
+    }
+
+    @Test
+    public void can_mock_unambigous_constructor_with_inheritance_first_extending_class_exact_match() {
+        UsesTwoBases u =
+            mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new Base()).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("ExtendsBase,Base", u.getConstructorUsed());
+    }
+
+    @Test
+    public void can_mock_unambigous_constructor_with_inheritance_second_extending_class_exact_match() {
+        UsesTwoBases u =
+            mock(UsesTwoBases.class, withSettings().useConstructor(new Base(), new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("Base,ExtendsBase", u.getConstructorUsed());
+    }
+
+    @Test
+    public void fail_when_multiple_matching_constructors_with_inheritence() {
         try {
             //when
-            mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
+            mock(UsesTwoBases.class, withSettings().useConstructor(new ExtendsBase(), new ExtendsBase()));
             //then
             fail();
         } catch (MockitoException e) {
             //TODO the exception message includes Mockito internals like the name of the generated class name.
             //I suspect that we could make this exception message nicer.
-            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
+            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesTwoBases'");
             assertThat(e.getCause())
-                .hasMessageContaining("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsExtendsBase]")
-                .hasMessageContaining("If you believe that Mockito could do a better join deciding on which constructor to use, please let us know.\n" +
+                .hasMessageContaining("Multiple constructors could be matched to arguments of types "
+                    + "[org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase, "
+                    + "org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]")
+                .hasMessageContaining("If you believe that Mockito could do a better job deciding on which constructor to use, please let us know.\n" +
                     "Ticket 685 contains the discussion and a workaround for ambiguous constructors using inner class.\n" +
                     "See https://github.com/mockito/mockito/issues/685");
         }
@@ -271,4 +319,24 @@ public class CreatingMocksWithConstructorTest extends TestBase {
             return "value";
         }
     }
+
+    private static class AmbiguousWithPrimitive {
+        public AmbiguousWithPrimitive(String s, int i) {
+            data = s;
+        }
+        public AmbiguousWithPrimitive(Object o, int i) {
+            data = "just an object";
+        }
+
+        private String data;
+        public String getData() {
+            return data;
+        }
+    }
+
+    @Test
+    public void can_spy_ambiguius_constructor_with_primitive() {
+        AmbiguousWithPrimitive mock = mock(AmbiguousWithPrimitive.class, withSettings().useConstructor("String", 7).defaultAnswer(CALLS_REAL_METHODS));
+        assertEquals("String", mock.getData());
+    }
 }
