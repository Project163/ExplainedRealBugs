diff --git a/gradle/errorprone.gradle b/gradle/errorprone.gradle
index 1d9cf7428..43c8633fc 100644
--- a/gradle/errorprone.gradle
+++ b/gradle/errorprone.gradle
@@ -10,3 +10,7 @@ if (JavaVersion.current() == JavaVersion.VERSION_1_8) {
 dependencies {
     errorprone libraries.errorprone
 }
+
+tasks.named("compileTestJava").configure {
+    options.errorprone.errorproneArgs << "-Xep:MockitoCast:OFF"
+}
diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
index 3909ff041..872917125 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
@@ -53,6 +53,15 @@ public class ReturnsDeepStubs implements Answer<Object>, Serializable {
             return delegate().returnValueFor(rawType);
         }
 
+        // When dealing with erasured generics, we only receive the Object type as rawType. At this
+        // point, there is nothing to salvage for Mockito. Instead of trying to be smart and generate
+        // a mock that would potentially match the return signature, instead return `null`. This
+        // is valid per the CheckCast JVM instruction and is better than causing a ClassCastException
+        // on runtime.
+        if (rawType.equals(Object.class)) {
+            return null;
+        }
+
         return deepStub(invocation, returnTypeGenericMetadata);
     }
 
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
index d91df8c40..5890f5db0 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java
@@ -14,6 +14,7 @@ import java.util.Set;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 @SuppressWarnings("unused")
 public class ReturnsGenericDeepStubsTest {
@@ -110,4 +111,26 @@ public class ReturnsGenericDeepStubsTest {
         StringBuilder stringBuilder_assignment_that_should_throw_a_CCE =
                 mock.twoTypeParams(new StringBuilder()).append(2).append(3);
     }
+
+    class WithGenerics<T> {
+        T execute() {
+            throw new IllegalArgumentException();
+        }
+    }
+    class SubClass<S> extends WithGenerics<S> {}
+
+    class UserOfSubClass {
+        SubClass<String> generate() {
+            return null;
+        }
+    }
+
+    @Test
+    public void can_handle_deep_stubs_with_generics_at_end_of_deep_invocation() {
+        UserOfSubClass mock = mock(UserOfSubClass.class, RETURNS_DEEP_STUBS);
+
+        when(mock.generate().execute()).thenReturn("sub");
+
+        assertThat(mock.generate().execute()).isEqualTo("sub");
+    }
 }
diff --git a/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java b/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
index 3294614c2..989d3a195 100644
--- a/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
+++ b/src/test/java/org/mockitousage/serialization/DeepStubsSerializableTest.java
@@ -45,7 +45,7 @@ public class DeepStubsSerializableTest {
         assertThat(deserialized_deep_stub.iterator().next().add("yes")).isEqualTo(true);
     }
 
-    @Test(expected = ClassCastException.class)
+    @Test(expected = NullPointerException.class)
     public void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {
         // given
         ListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());
