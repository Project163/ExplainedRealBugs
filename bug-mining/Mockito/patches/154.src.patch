diff --git a/gradle/dependencies.gradle b/gradle/dependencies.gradle
index 6cbe008c0..792696c21 100644
--- a/gradle/dependencies.gradle
+++ b/gradle/dependencies.gradle
@@ -4,7 +4,7 @@ ext {
 
 def versions = [:]
 
-versions.bytebuddy = '1.9.3'
+versions.bytebuddy = '1.9.6'
 versions.junitJupiter = '5.1.1'
 
 libraries.junit4 = 'junit:junit:4.12'
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index b659c7335..a6d52c974 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -15,6 +15,7 @@ import net.bytebuddy.implementation.FieldAccessor;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
 import net.bytebuddy.matcher.ElementMatcher;
+import org.mockito.Mockito;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
 import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.DispatcherDefaultingToRealMethod;
@@ -23,6 +24,7 @@ import org.mockito.mock.SerializableMode;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -40,6 +42,26 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
 
     private static final String CODEGEN_PACKAGE = "org.mockito.codegen.";
 
+    private static final Object MOCKITO_MODULE;
+    private static final Method GET_MODULE, IS_OPEN;
+
+    static {
+        Object mockitoModule;
+        Method getModule, isOpen;
+        try {
+            getModule = Class.class.getMethod("getModule");
+            isOpen = getModule.getReturnType().getMethod("isOpen", String.class, getModule.getReturnType());
+            mockitoModule = getModule.invoke(Mockito.class);
+        } catch (Throwable ignored) {
+            mockitoModule = null;
+            getModule = null;
+            isOpen = null;
+        }
+        MOCKITO_MODULE = mockitoModule;
+        GET_MODULE = getModule;
+        IS_OPEN = isOpen;
+    }
+
     private final SubclassLoader loader;
 
     private final ByteBuddy byteBuddy;
@@ -75,7 +97,13 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
 
     @Override
     public <T> Class<? extends T> mockClass(MockFeatures<T> features) {
-        String name = nameFor(features.mockedType);
+        ClassLoader classLoader = new MultipleParentClassLoader.Builder()
+            .append(features.mockedType)
+            .append(features.interfaces)
+            .append(currentThread().getContextClassLoader())
+            .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
+            .append(MockMethodInterceptor.class).build(MockMethodInterceptor.class.getClassLoader());
+        String name = nameFor(features.mockedType, classLoader);
         DynamicType.Builder<T> builder =
                 byteBuddy.subclass(features.mockedType)
                          .name(name)
@@ -108,14 +136,6 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                     .throwing(ClassNotFoundException.class, IOException.class)
                     .intercept(readReplace);
         }
-        ClassLoader classLoader = new MultipleParentClassLoader.Builder()
-            .append(features.mockedType)
-            .append(features.interfaces)
-            .append(currentThread().getContextClassLoader())
-            .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
-            .append(MockMethodInterceptor.class,
-                MockMethodInterceptor.ForHashCode.class,
-                MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader());
         if (classLoader != features.mockedType.getClassLoader()) {
             assertVisibility(features.mockedType);
             for (Class<?> iFace : features.interfaces) {
@@ -134,13 +154,14 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
         return isDeclaredBy(named("groovy.lang.GroovyObjectSupport"));
     }
 
-    // TODO inspect naming strategy (for OSGI, signed package, java.* (and bootstrap classes), etc...)
-    private String nameFor(Class<?> type) {
-        String typeName = type.getName();
-        if (isComingFromJDK(type)
-                || isComingFromSignedJar(type)
-                || isComingFromSealedPackage(type)) {
+    private String nameFor(Class<?> type, ClassLoader classLoader) {
+        String typeName;
+        if (classLoader == type.getClassLoader()
+            ? loader.isUsingLookup() && !isOpenedToMockito(type)
+            : isComingFromJDK(type) || isComingFromSignedJar(type) || isComingFromSealedPackage(type)) {
             typeName = CODEGEN_PACKAGE + type.getSimpleName();
+        } else {
+            typeName = type.getName();
         }
         return String.format("%s$%s$%d", typeName, "MockitoMock", Math.abs(random.nextInt()));
     }
@@ -158,6 +179,20 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
         return type.getPackage() != null && type.getPackage().isSealed();
     }
 
+    private boolean isOpenedToMockito(Class<?> type) {
+        if (type.getPackage() == null) {
+            return true;
+        }
+        try {
+            return MOCKITO_MODULE != null && (Boolean) IS_OPEN.invoke(GET_MODULE.invoke(type), type.getPackage().getName(), MOCKITO_MODULE);
+        } catch (Exception e) {
+            throw new MockitoException(join("Cannot assert if " + type + " is opened to Mockito",
+                "",
+                "Error during reflective access of expected methods of the Java module system"
+            ), e);
+        }
+    }
+
     private boolean isComingFromSignedJar(Class<?> type) {
         return type.getSigners() != null;
     }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
index 454dd8e4c..e7f710a96 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
@@ -48,6 +48,11 @@ class SubclassInjectionLoader implements SubclassLoader {
 
     private static class WithReflection implements SubclassLoader {
 
+        @Override
+        public boolean isUsingLookup() {
+            return false;
+        }
+
         @Override
         public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
             return ClassLoadingStrategy.Default.INJECTION.with(codegen ? InjectionBase.class.getProtectionDomain() : mockedType.getProtectionDomain());
@@ -68,6 +73,11 @@ class SubclassInjectionLoader implements SubclassLoader {
             this.privateLookupIn = privateLookupIn;
         }
 
+        @Override
+        public boolean isUsingLookup() {
+            return true;
+        }
+
         @Override
         public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
             if (codegen) {
@@ -100,6 +110,11 @@ class SubclassInjectionLoader implements SubclassLoader {
         }
     }
 
+    @Override
+    public boolean isUsingLookup() {
+        return loader.isUsingLookup();
+    }
+
     @Override
     public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
         return loader.resolveStrategy(mockedType, classLoader, codegen);
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
index 194c282b5..293abc87a 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
@@ -11,6 +11,8 @@ import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
  */
 public interface SubclassLoader {
 
+    boolean isUsingLookup();
+
     /**
      * Resolves a class loading strategy.
      *
diff --git a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
index 5a66ab162..676de577a 100644
--- a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
+++ b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
@@ -15,6 +15,11 @@ import static org.mockito.internal.util.StringUtil.join;
 
 class AndroidLoadingStrategy implements SubclassLoader {
 
+    @Override
+    public boolean isUsingLookup() {
+        return false;
+    }
+
     @Override
     public ClassLoadingStrategy<ClassLoader> resolveStrategy(Class<?> mockedType, ClassLoader classLoader, boolean codegen) {
         File target = AndroidTempFileLocator.target;
