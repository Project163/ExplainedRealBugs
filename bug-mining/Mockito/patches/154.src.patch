diff --git a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
index d7838fb61..3c519c1a5 100644
--- a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
+++ b/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java
@@ -8,8 +8,23 @@ package org.mockito.internal.util.reflection;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.Checks;
 
-import java.lang.reflect.*;
-import java.util.*;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
 
 
 /**
@@ -17,20 +32,20 @@ import java.util.*;
  * and accessible members.
  *
  * <p>
- *     The main idea of this code is to create a Map that will help to resolve return types.
- *     In order to actually work with nested generics, this map will have to be passed along new instances
- *     as a type context.
+ * The main idea of this code is to create a Map that will help to resolve return types.
+ * In order to actually work with nested generics, this map will have to be passed along new instances
+ * as a type context.
  * </p>
  *
  * <p>
- *     Hence :
- *     <ul>
- *         <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real
- *         <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>
+ * Hence :
+ * <ul>
+ * <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real
+ * <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>
  *
- *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using
- *         {@link #resolveGenericReturnType(Method)}.</li>
- *     </ul>
+ * <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using
+ * {@link #resolveGenericReturnType(Method)}.</li>
+ * </ul>
  * </p>
  *
  * <p>
@@ -98,19 +113,10 @@ public abstract class GenericMetadataSupport {
         if (type instanceof TypeVariable) {
             /*
              * If type is a TypeVariable, then it is needed to gather data elsewhere.
-             * Usually TypeVariables are declared on the class definition, such as
-             * such as List<E>.
-             *
-             * If the data cannot be found in the contextual map, try harder on the
-             * TypeVariable itself looking for defined bounds.
+             * Usually TypeVariables are declared on the class definition, such as such
+             * as List<E>.
              */
-            Type typeArgument = contextualActualTypeParameters.get(type);
-            if (typeArgument == null) {
-                BoundedType boundedType = boundsOf((TypeVariable<?>) type);
-                contextualActualTypeParameters.put((TypeVariable<?>) type, boundedType);
-                return extractRawTypeOf(boundedType);
-            }
-            return extractRawTypeOf(typeArgument);
+            return extractRawTypeOf(contextualActualTypeParameters.get(type));
         }
         throw new MockitoException("Raw extraction not supported for : '" + type + "'");
     }
@@ -126,10 +132,21 @@ public abstract class GenericMetadataSupport {
             TypeVariable<?> typeParameter = typeParameters[i];
             Type actualTypeArgument = actualTypeArguments[i];
 
-            // Prevent registration of a cycle of TypeVariables. This can happen when we are processing
-            // type parameters in a Method, while we already processed the type parameters of a class.
-            if (actualTypeArgument instanceof TypeVariable && contextualActualTypeParameters.containsKey(typeParameter)) {
-                continue;
+            if (actualTypeArgument instanceof TypeVariable) {
+                /*
+                 * If actualTypeArgument is a TypeVariable, and it is not present in
+                 * the context map then it is needed to try harder to gather more data
+                 * from the type argument itself. In some case the type argument do
+                 * define upper bounds, this allow to look for them if not in the
+                 * context map.
+                 */
+                registerTypeVariableIfNotPresent((TypeVariable<?>) actualTypeArgument);
+
+                // Prevent registration of a cycle of TypeVariables. This can happen when we are processing
+                // type parameters in a Method, while we already processed the type parameters of a class.
+                if (contextualActualTypeParameters.containsKey(typeParameter)) {
+                    continue;
+                }
             }
 
             if (actualTypeArgument instanceof WildcardType) {
@@ -157,7 +174,7 @@ public abstract class GenericMetadataSupport {
     /**
      * @param typeParameter The TypeVariable parameter
      * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable
-     *         then retrieve BoundedType of this TypeVariable
+     * then retrieve BoundedType of this TypeVariable
      */
     private BoundedType boundsOf(TypeVariable<?> typeParameter) {
         if (typeParameter.getBounds()[0] instanceof TypeVariable) {
@@ -169,7 +186,7 @@ public abstract class GenericMetadataSupport {
     /**
      * @param wildCard The WildCard type
      * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable
-     *         then retrieve BoundedType of this TypeVariable
+     * then retrieve BoundedType of this TypeVariable
      */
     private BoundedType boundsOf(WildcardType wildCard) {
         /*
@@ -255,7 +272,7 @@ public abstract class GenericMetadataSupport {
         // logger.log("Method '" + method.toGenericString() + "' has return type : " + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + " : " + genericReturnType);
 
         int arity = 0;
-        while(genericReturnType instanceof GenericArrayType) {
+        while (genericReturnType instanceof GenericArrayType) {
             arity++;
             genericReturnType = ((GenericArrayType) genericReturnType).getGenericComponentType();
         }
@@ -287,8 +304,8 @@ public abstract class GenericMetadataSupport {
      * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.
      *
      * <p>
-     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise
-     *     it'll throw a {@link MockitoException}.
+     * At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise
+     * it'll throw a {@link MockitoException}.
      * </p>
      *
      * @param type The class from which the {@link GenericMetadataSupport} should be built.
@@ -314,7 +331,7 @@ public abstract class GenericMetadataSupport {
 
     /**
      * Generic metadata implementation for {@link Class}.
-     *
+     * <p>
      * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on
      * the class and its ancestors and interfaces.
      */
@@ -336,10 +353,10 @@ public abstract class GenericMetadataSupport {
 
     /**
      * Generic metadata implementation for "standalone" {@link ParameterizedType}.
-     *
+     * <p>
      * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of
      * the related raw type and declared type variable of this parameterized type.
-     *
+     * <p>
      * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as
      * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).
      * That's what meant the "standalone" word at the beginning of the Javadoc.
@@ -419,7 +436,7 @@ public abstract class GenericMetadataSupport {
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
-            registerTypeParametersOn(new TypeVariable[] { typeVariable });
+            registerTypeParametersOn(new TypeVariable[]{typeVariable});
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
@@ -456,7 +473,7 @@ public abstract class GenericMetadataSupport {
             for (Type extraInterface : extraInterfaces) {
                 Class<?> rawInterface = extractRawTypeOf(extraInterface);
                 // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)
-                if(!rawType().equals(rawInterface)) {
+                if (!rawType().equals(rawInterface)) {
                     rawExtraInterfaces.add(rawInterface);
                 }
             }
@@ -528,7 +545,6 @@ public abstract class GenericMetadataSupport {
     }
 
 
-
     /**
      * Type representing bounds of a type
      *
@@ -551,7 +567,7 @@ public abstract class GenericMetadataSupport {
      *
      * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and
      * interfacesBound will be an array of the additional interfaces.
-     *
+     * <p>
      * i.e. <code>SomeClass</code>.
      * <pre class="code"><code class="java">
      *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {
diff --git a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
index 57d0cb292..cc5b5885d 100644
--- a/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java
@@ -8,9 +8,11 @@ import org.junit.Test;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -26,42 +28,66 @@ public class GenericMetadataSupportTest {
     interface GenericsSelfReference<T extends GenericsSelfReference<T>> {
         T self();
     }
+
     interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {
         E get();
     }
+
     interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {
         E get();
     }
-    interface ListOfNumbers extends List<Number> {}
-    interface AnotherListOfNumbers extends ListOfNumbers {}
 
-    abstract class ListOfNumbersImpl implements ListOfNumbers {}
-    abstract class AnotherListOfNumbersImpl extends ListOfNumbersImpl {}
+    interface ListOfNumbers extends List<Number> {
+    }
 
-    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}
+    interface AnotherListOfNumbers extends ListOfNumbers {
+    }
+
+    abstract class ListOfNumbersImpl implements ListOfNumbers {
+    }
+
+    abstract class AnotherListOfNumbersImpl extends ListOfNumbersImpl {
+    }
+
+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {
+    }
 
     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {
         Set<Number> remove(Object key); // override with fixed ParameterizedType
+
         List<? super Integer> returning_wildcard_with_class_lower_bound();
+
         List<? super K> returning_wildcard_with_typeVar_lower_bound();
+
         List<? extends K> returning_wildcard_with_typeVar_upper_bound();
+
         K returningK();
+
         <O extends K> List<O> paramType_with_type_params();
+
         <S, T extends S> T two_type_params();
+
         <O extends K> O typeVar_with_type_params();
     }
 
-    static class StringList extends ArrayList<String> { }
+    static class StringList extends ArrayList<String> {
+    }
 
     public interface TopInterface<T> {
         T generic();
     }
-    public interface MiddleInterface<T> extends TopInterface<T> { }
-    public class OwningClassWithDeclaredUpperBounds<T extends List<String> & Comparable> {
-        public abstract class AbstractInner implements MiddleInterface<T> { }
+
+    public interface MiddleInterface<T> extends TopInterface<T> {
+    }
+
+    public class OwningClassWithDeclaredUpperBounds<T extends List<String> & Comparable<String> & Cloneable> {
+        public abstract class AbstractInner implements MiddleInterface<T> {
+        }
     }
+
     public class OwningClassWithNoDeclaredUpperBounds<T> {
-        public abstract class AbstractInner implements MiddleInterface<T> { }
+        public abstract class AbstractInner implements MiddleInterface<T> {
+        }
     }
 
     @Test
@@ -183,7 +209,6 @@ public class GenericMetadataSupportTest {
     }
 
 
-
     @Test
     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() {
         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_class_lower_bound", GenericsNest.class));
@@ -202,7 +227,8 @@ public class GenericMetadataSupportTest {
         GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");
 
         assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);
-        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }
+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);
+    }
 
     @Test
     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() {
@@ -227,6 +253,63 @@ public class GenericMetadataSupportTest {
                   ).isEqualTo(Object.class);
     }
 
+    @Test
+    public void can_extract_interface_type_from_bounds_on_terminal_typeVariable() {
+
+        assertThat(inferFrom(OwningClassWithDeclaredUpperBounds.AbstractInner.class)
+                       .resolveGenericReturnType(firstNamedMethod("generic", OwningClassWithDeclaredUpperBounds.AbstractInner.class))
+                       .rawExtraInterfaces()
+                  ).containsExactly(Comparable.class, Cloneable.class);
+        assertThat(inferFrom(OwningClassWithDeclaredUpperBounds.AbstractInner.class)
+                       .resolveGenericReturnType(firstNamedMethod("generic", OwningClassWithDeclaredUpperBounds.AbstractInner.class))
+                       .extraInterfaces()
+                  ).containsExactly(parameterizedTypeOf(Comparable.class, null, String.class),
+                                                                                                                                                                         Cloneable.class);
+
+        assertThat(inferFrom(OwningClassWithNoDeclaredUpperBounds.AbstractInner.class)
+                       .resolveGenericReturnType(firstNamedMethod("generic", OwningClassWithNoDeclaredUpperBounds.AbstractInner.class))
+                       .extraInterfaces()
+                  ).isEmpty();
+    }
+
+    private ParameterizedType parameterizedTypeOf(final Class<?> rawType, final Class<?> ownerType, final Type... actualTypeArguments) {
+        return new ParameterizedType() {
+            @Override
+            public Type[] getActualTypeArguments() {
+                return actualTypeArguments;
+            }
+
+            @Override
+            public Type getRawType() {
+                return rawType;
+            }
+
+            @Override
+            public Type getOwnerType() {
+                return ownerType;
+            }
+
+            public boolean equals(Object other) {
+                if (other instanceof ParameterizedType) {
+                    ParameterizedType otherParamType = (ParameterizedType) other;
+                    if (this == otherParamType) {
+                        return true;
+                    } else {
+                        return equals(ownerType, otherParamType.getOwnerType())
+                               && equals(rawType, otherParamType.getRawType())
+                               && Arrays.equals(actualTypeArguments, otherParamType.getActualTypeArguments());
+                    }
+                } else {
+                    return false;
+                }
+            }
+
+            private boolean equals(Object a, Object b) {
+                return (a == b) || (a != null && a.equals(b));
+            }
+        };
+    }
+
     private Type typeVariableValue(Map<TypeVariable<?>, Type> typeVariables, String typeVariableName) {
         for (Map.Entry<TypeVariable<?>, Type> typeVariableTypeEntry : typeVariables.entrySet()) {
             if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {
