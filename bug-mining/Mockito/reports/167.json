{"url":"https://api.github.com/repos/mockito/mockito/issues/1614","repository_url":"https://api.github.com/repos/mockito/mockito","labels_url":"https://api.github.com/repos/mockito/mockito/issues/1614/labels{/name}","comments_url":"https://api.github.com/repos/mockito/mockito/issues/1614/comments","events_url":"https://api.github.com/repos/mockito/mockito/issues/1614/events","html_url":"https://github.com/mockito/mockito/issues/1614","id":408479033,"node_id":"MDU6SXNzdWU0MDg0NzkwMzM=","number":1614,"title":"Memory leak in mockito-inline calling method on mock with at least a mock as parameter","user":{"login":"ttanxu","id":3538432,"node_id":"MDQ6VXNlcjM1Mzg0MzI=","avatar_url":"https://avatars.githubusercontent.com/u/3538432?v=4","gravatar_id":"","url":"https://api.github.com/users/ttanxu","html_url":"https://github.com/ttanxu","followers_url":"https://api.github.com/users/ttanxu/followers","following_url":"https://api.github.com/users/ttanxu/following{/other_user}","gists_url":"https://api.github.com/users/ttanxu/gists{/gist_id}","starred_url":"https://api.github.com/users/ttanxu/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ttanxu/subscriptions","organizations_url":"https://api.github.com/users/ttanxu/orgs","repos_url":"https://api.github.com/users/ttanxu/repos","events_url":"https://api.github.com/users/ttanxu/events{/privacy}","received_events_url":"https://api.github.com/users/ttanxu/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2019-02-09T22:46:45Z","updated_at":"2020-06-01T04:04:31Z","closed_at":"2019-03-05T16:10:23Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"# Summary\r\nWe found a memory leak with mockito-inline. A short example is shown as below. A more detailed example can be found at the end.\r\n\r\n```java\r\nclass BigClass {\r\n  void accept(SmallClass small) {}\r\n}\r\n\r\nclass SmallClass {\r\n  void accept(BigClass big) {}\r\n}\r\n\r\nvoid leak() {\r\n  BigClass a = Mockito.mock(BigClass.class);\r\n  SmallClass b = Mockito.mock(SmallClass.class);\r\n\r\n  // Remove any one of the 2 lines below will stop leaking\r\n  a.accept(b);\r\n  b.accept(a);\r\n}\r\n\r\n```\r\n\r\n# Analysis\r\nLooking at the [memory dump][MemDump]. Mock of `BigClass` and `SmallClass` are held as a weak ref in a map of type `WeakConcurrentMap$WithInlinedExpunction` used to map the mock and its invocation handler. When the mock can be reclaimed by GC the map will remove the record from it.\r\n\r\nIn the case with memory leak, the mock instance of `BigClass` was held as a strong reference by `rawArguments` and `arguments` in [`InvocationMatcher`][InvocationMatcher],  as `invocation` in [`InterceptedInvocation`][InterceptedInvocation], as `invocationForStubbing` in [`InvocationContainerImpl`][InvocationContainerImpl], as `invocationContainer` in [`MockHandlerImpl`][MockHandlerImpl]. That eventually leads to a value in the `WeakConcurrentMap` for `SmallClass`. Similar thing happens to the mock instance of `SmallClass`. That creates a ring of reference and no mock can be reclaimed by GC because they are all referenced transitively by a value in the map.\r\n\r\nSimilar things can also happen for stubbed methods, saved in `stubbed` in `InvocationContainerImpl`.\r\n\r\nSubclass mock makers don't suffer from it because there is no map from mock to handler -- it's just a strong reference. GC can handle non-accessible rings well, but GC doesn't know the mock map purging semantic in inline mock makers.\r\n\r\n# Potential Solution\r\nUnlike #1533 where converting `spiedInstance` to a weak reference may be an acceptable solution, we can't convert arguments in stubbing method calls into weak references because there are stubbing calls with an object (or a mock) that doesn't have strong ref anywhere else than arguments in Mockito.\r\n\r\nTherefore I failed to see a solution that's transparent to callers. The possible solution below is the one that I think has the least change.\r\n\r\nThe possible solution is we can somehow reset the mock when their lives end, which clears the stubbing records. Maybe we can tie their lives to a `MockitoSession`. We can track all mocks created after a session is created, and reset them when the session is finished. Now we only have events for mock creation in the same thread, we may need to expand that to include other threads.\r\n\r\nWe may be able to set `spiedInstance` to `null` when their lives end, which should also be able to fix #1532 and #1533. That would be a solution with least risk.\r\n\r\nOf course any solution that's transparent to callers is still more desirable.\r\n\r\n# A Detailed Example\r\nSee GitHub project [MockitoMethodCallMemLeak][MockitoMethodCallMemLeak]. One can open it in IntelliJ and the run configuration is already configured (with mem dump at OOM and 4M java heap size).\r\n\r\n[MemDump]: https://github.com/ttanxu/MockitoMethodCallMemLeak/blob/master/java_pid13027.hprof\r\n[InvocationMatcher]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java\r\n[InterceptedInvocation]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java\r\n[InvocationContainerImpl]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/stubbing/InvocationContainerImpl.java\r\n[MockHandlerImpl]: https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/handler/MockHandlerImpl.java\r\n[MockitoMethodCallMemLeak]: https://github.com/ttanxu/MockitoMethodCallMemLeak","closed_by":{"login":"mockitoguy","id":24743,"node_id":"MDQ6VXNlcjI0NzQz","avatar_url":"https://avatars.githubusercontent.com/u/24743?v=4","gravatar_id":"","url":"https://api.github.com/users/mockitoguy","html_url":"https://github.com/mockitoguy","followers_url":"https://api.github.com/users/mockitoguy/followers","following_url":"https://api.github.com/users/mockitoguy/following{/other_user}","gists_url":"https://api.github.com/users/mockitoguy/gists{/gist_id}","starred_url":"https://api.github.com/users/mockitoguy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mockitoguy/subscriptions","organizations_url":"https://api.github.com/users/mockitoguy/orgs","repos_url":"https://api.github.com/users/mockitoguy/repos","events_url":"https://api.github.com/users/mockitoguy/events{/privacy}","received_events_url":"https://api.github.com/users/mockitoguy/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mockito/mockito/issues/1614/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mockito/mockito/issues/1614/timeline","performed_via_github_app":null,"state_reason":"completed"}