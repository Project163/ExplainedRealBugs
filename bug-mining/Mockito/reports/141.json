{"url":"https://api.github.com/repos/mockito/mockito/issues/1313","repository_url":"https://api.github.com/repos/mockito/mockito","labels_url":"https://api.github.com/repos/mockito/mockito/issues/1313/labels{/name}","comments_url":"https://api.github.com/repos/mockito/mockito/issues/1313/comments","events_url":"https://api.github.com/repos/mockito/mockito/issues/1313/events","html_url":"https://github.com/mockito/mockito/issues/1313","id":297632101,"node_id":"MDU6SXNzdWUyOTc2MzIxMDE=","number":1313,"title":"InlineByteBuddyMockMaker does not clean up stale mocks","user":{"login":"moltmann","id":20428192,"node_id":"MDQ6VXNlcjIwNDI4MTky","avatar_url":"https://avatars.githubusercontent.com/u/20428192?v=4","gravatar_id":"","url":"https://api.github.com/users/moltmann","html_url":"https://github.com/moltmann","followers_url":"https://api.github.com/users/moltmann/followers","following_url":"https://api.github.com/users/moltmann/following{/other_user}","gists_url":"https://api.github.com/users/moltmann/gists{/gist_id}","starred_url":"https://api.github.com/users/moltmann/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/moltmann/subscriptions","organizations_url":"https://api.github.com/users/moltmann/orgs","repos_url":"https://api.github.com/users/moltmann/repos","events_url":"https://api.github.com/users/moltmann/events{/privacy}","received_events_url":"https://api.github.com/users/moltmann/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":10,"created_at":"2018-02-15T23:19:06Z","updated_at":"2018-03-13T04:00:19Z","closed_at":"2018-03-13T04:00:19Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"**Repro:**\r\n\r\n1. Mockito 2.15.2 using mockito-inline\r\n2. With -Xmx64m run\r\n```\r\n@RunWith(JUnit4.class)\r\npublic class Stress {\r\n    private static final int NUM_RUNS = 20000;\r\n\r\n    public static class TestClass {\r\n        public String returnA() {\r\n            return \"A\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test that mocks that are not referenced anymore are properly cleaned up.\r\n     */\r\n    @Test\r\n    public void callALotOfMocks() {\r\n        for (int i = 0; i < NUM_RUNS; i++) {\r\n            TestClass mock = mock(TestClass.class);\r\n            when(mock.returnA()).thenReturn(\"B\");\r\n\r\n            assertEquals(\"B\", mock.returnA());\r\n\r\n            if (i % 1024 == 0) {\r\n                System.out.println(\"Mocked \" + i + \"/\" + NUM_RUNS);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Expected:**\r\n\r\nThe test eventually finishes\r\n\r\n**Observed:**\r\n\r\n> Mocked 0/20000\r\n> Mocked 1024/20000\r\n> Mocked 2048/20000\r\n> Mocked 3072/20000\r\n> Mocked 4096/20000\r\n> Mocked 5120/20000\r\n> Mocked 6144/20000\r\n> Mocked 7168/20000\r\n> Mocked 8192/20000\r\n> Mocked 9216/20000\r\n> Mocked 10240/20000\r\n> Mocked 11264/20000\r\n> Exception in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\r\n> \tat java.lang.StringCoding$StringDecoder.decode(StringCoding.java:149)\r\n> \tat java.lang.StringCoding.decode(StringCoding.java:193)\r\n> \tat java.lang.String.<init>(String.java:426)\r\n> \tat java.util.jar.Attributes.read(Attributes.java:418)\r\n> \tat java.util.jar.Manifest.read(Manifest.java:199)\r\n> \r\n> Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread \"main\"\r\n> \r\n> Process finished with exit code 1\r\n\r\n**Analysis:**\r\n\r\nThe `InlineByteBuddyMockMaker` uses a Map<WeakRef\\<Mock\\>, Handler> in the `mocks` field to store the mocks and their handlers. It relies that the mocks get garbage collected to remove the entry in the map. Unfortunately if there is an invocation on the mock, the handlers keep strong references to the mock in `InterceptedInvocation.mock`, `RealMethodCall.instance`, and `SerializableRealMethodCall.instance`. These are (strong) references by the handler. Hence the mock never gets cleaned up and the map grows indefinitely.\r\n\r\nThis is not a problem if the mocks get `Mockito.reset` properly or if using a mock maker that does not store the handlers.","closed_by":{"login":"mockitoguy","id":24743,"node_id":"MDQ6VXNlcjI0NzQz","avatar_url":"https://avatars.githubusercontent.com/u/24743?v=4","gravatar_id":"","url":"https://api.github.com/users/mockitoguy","html_url":"https://github.com/mockitoguy","followers_url":"https://api.github.com/users/mockitoguy/followers","following_url":"https://api.github.com/users/mockitoguy/following{/other_user}","gists_url":"https://api.github.com/users/mockitoguy/gists{/gist_id}","starred_url":"https://api.github.com/users/mockitoguy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mockitoguy/subscriptions","organizations_url":"https://api.github.com/users/mockitoguy/orgs","repos_url":"https://api.github.com/users/mockitoguy/repos","events_url":"https://api.github.com/users/mockitoguy/events{/privacy}","received_events_url":"https://api.github.com/users/mockitoguy/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mockito/mockito/issues/1313/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mockito/mockito/issues/1313/timeline","performed_via_github_app":null,"state_reason":"completed"}