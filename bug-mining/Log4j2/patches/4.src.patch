diff --git a/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java b/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java
index 12364421bb..152b0b7483 100644
--- a/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java
+++ b/core/src/main/java/org/apache/logging/log4j/core/config/BaseConfiguration.java
@@ -83,7 +83,9 @@ public class BaseConfiguration extends Filterable implements Configuration {
 
     private ConcurrentMap<String, LoggerConfig> loggers = new ConcurrentHashMap<String, LoggerConfig>();
 
-    private StrSubstitutor subst = new StrSubstitutor();
+    private StrLookup tempLookup = new Interpolator();
+
+    private StrSubstitutor subst = new StrSubstitutor(tempLookup);
 
     private LoggerConfig root = new LoggerConfig();
 
@@ -150,13 +152,13 @@ public class BaseConfiguration extends Filterable implements Configuration {
                 continue;
             }
             if (child.getName().equalsIgnoreCase("properties")) {
-                if (subst.getVariableResolver() == null) {
+                if (tempLookup == subst.getVariableResolver()) {
                     subst.setVariableResolver((StrLookup) child.getObject());
                 } else {
                     LOGGER.error("Properties declaration must be the first element in the configuration");
                 }
                 continue;
-            } else if (subst.getVariableResolver() == null) {
+            } else if (tempLookup == subst.getVariableResolver()) {
                 subst.setVariableResolver(new Interpolator(null));
             }
             if (child.getName().equalsIgnoreCase("appenders")) {
diff --git a/core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java b/core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java
index bc2601ddcf..385a77ff42 100644
--- a/core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java
+++ b/core/src/main/java/org/apache/logging/log4j/core/config/JSONConfiguration.java
@@ -51,6 +51,8 @@ public class JSONConfiguration extends BaseConfiguration {
 
     private JsonNode root;
 
+    private List<String> messages = new ArrayList<String>();
+
     public JSONConfiguration(InputSource source, File configFile) {
         byte[] buffer;
 
@@ -69,18 +71,22 @@ public class JSONConfiguration extends BaseConfiguration {
             boolean verbose = false;
             for (Map.Entry<String, String> entry : rootNode.getAttributes().entrySet()) {
                 if ("status".equalsIgnoreCase(entry.getKey())) {
-                    status = Level.toLevel(entry.getValue().toUpperCase(), Level.OFF);
+                    status = Level.toLevel(getSubst().replace(entry.getValue()).toUpperCase(), null);
+                    if (status == null) {
+                        status = Level.ERROR;
+                        messages.add("Invalid status specified: " + entry.getValue() + ". Defaulting to ERROR");
+                    }
                 } else if ("verbose".equalsIgnoreCase(entry.getKey())) {
-                    verbose = Boolean.parseBoolean(entry.getValue());
+                    verbose = Boolean.parseBoolean(getSubst().replace(entry.getValue()));
                 } else if ("packages".equalsIgnoreCase(entry.getKey())) {
-                    String[] packages = entry.getValue().split(",");
+                    String[] packages = getSubst().replace(entry.getValue()).split(",");
                     for (String p : packages) {
                         PluginManager.addPackage(p);
                     }
                 } else if ("name".equalsIgnoreCase(entry.getKey())) {
-                    setName(entry.getValue());
+                    setName(getSubst().replace(entry.getValue()));
                 } else if ("monitorInterval".equalsIgnoreCase(entry.getKey())) {
-                    int interval = Integer.parseInt(entry.getValue());
+                    int interval = Integer.parseInt(getSubst().replace(entry.getValue()));
                     if (interval > 0 && configFile != null) {
                         monitor = new FileConfigurationMonitor(configFile, listeners, interval);
                     }
@@ -105,6 +111,9 @@ public class JSONConfiguration extends BaseConfiguration {
                     listener.setFilters(VERBOSE_CLASSES);
                 }
                 ((StatusLogger) LOGGER).registerListener(listener);
+                for (String msg : messages) {
+                    LOGGER.error(msg);
+                }
             }
             if (getName() == null) {
                 setName(source.getSystemId());
diff --git a/core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java b/core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java
index 8d386e2602..39ae66231b 100644
--- a/core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java
+++ b/core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java
@@ -360,7 +360,13 @@ public class LoggerConfig extends Filterable implements LogEventFactory {
         }
 
         List<AppenderRef> appenderRefs = Arrays.asList(refs);
-        Level level = loggerLevel == null ? Level.ERROR : Level.valueOf(loggerLevel.toUpperCase());
+        Level level;
+        try {
+            level = loggerLevel == null ? Level.ERROR : Level.valueOf(loggerLevel.toUpperCase());
+        } catch (Exception ex) {
+            LOGGER.error("Invalid Log level specified: {}. Defaulting to Error", loggerLevel);
+            level = Level.ERROR;
+        }
         String name = loggerName.equals("root") ? "" : loggerName;
         boolean additive = additivity == null ? true : Boolean.parseBoolean(additivity);
 
@@ -379,7 +385,13 @@ public class LoggerConfig extends Filterable implements LogEventFactory {
                                             @PluginElement("appender-ref") AppenderRef[] refs,
                                             @PluginElement("filters") Filter filter) {
             List<AppenderRef> appenderRefs = Arrays.asList(refs);
-            Level level = loggerLevel == null ? Level.ERROR : Level.valueOf(loggerLevel.toUpperCase());
+            Level level;
+            try {
+                level = loggerLevel == null ? Level.ERROR : Level.valueOf(loggerLevel.toUpperCase());
+            } catch (Exception ex) {
+                LOGGER.error("Invalid Log level specified: {}. Defaulting to Error", loggerLevel);
+                level = Level.ERROR;
+            }
             boolean additive = additivity == null ? true : Boolean.parseBoolean(additivity);
 
             return new LoggerConfig(LogManager.ROOT_LOGGER_NAME, appenderRefs, filter, level, additive);
diff --git a/core/src/main/java/org/apache/logging/log4j/core/config/XMLConfiguration.java b/core/src/main/java/org/apache/logging/log4j/core/config/XMLConfiguration.java
index 1131ddf607..4c3b814b2d 100644
--- a/core/src/main/java/org/apache/logging/log4j/core/config/XMLConfiguration.java
+++ b/core/src/main/java/org/apache/logging/log4j/core/config/XMLConfiguration.java
@@ -72,6 +72,8 @@ public class XMLConfiguration extends BaseConfiguration {
 
     private Validator validator;
 
+    private List<String> messages = new ArrayList<String>();
+
     public XMLConfiguration(InputSource source, File configFile) {
         byte[] buffer = null;
 
@@ -87,22 +89,26 @@ public class XMLConfiguration extends BaseConfiguration {
 
             for (Map.Entry<String, String> entry : attrs.entrySet()) {
                 if ("status".equalsIgnoreCase(entry.getKey())) {
-                    status = Level.toLevel(entry.getValue().toUpperCase(), Level.OFF);
+                    status = Level.toLevel(getSubst().replace(entry.getValue()).toUpperCase(), null);
+                    if (status == null) {
+                        status = Level.ERROR;
+                        messages.add("Invalid status specified: " + entry.getValue() + ". Defaulting to ERROR");
+                    }
                 } else if ("verbose".equalsIgnoreCase(entry.getKey())) {
-                    verbose = Boolean.parseBoolean(entry.getValue());
-                } else if ("packages".equalsIgnoreCase(entry.getKey())) {
+                    verbose = Boolean.parseBoolean(getSubst().replace(entry.getValue()));
+                } else if ("packages".equalsIgnoreCase(getSubst().replace(entry.getKey()))) {
                     String[] packages = entry.getValue().split(",");
                     for (String p : packages) {
                         PluginManager.addPackage(p);
                     }
                 } else if ("name".equalsIgnoreCase(entry.getKey())) {
-                    setName(entry.getValue());
+                    setName(getSubst().replace(entry.getValue()));
                 } else if ("strict".equalsIgnoreCase(entry.getKey())) {
-                    strict = Boolean.parseBoolean(entry.getValue());
+                    strict = Boolean.parseBoolean(getSubst().replace(entry.getValue()));
                 } else if ("schema".equalsIgnoreCase(entry.getKey())) {
-                    schema = entry.getValue();
+                    schema = getSubst().replace(entry.getValue());
                 } else if ("monitorInterval".equalsIgnoreCase(entry.getKey())) {
-                    int interval = Integer.parseInt(entry.getValue());
+                    int interval = Integer.parseInt(getSubst().replace(entry.getValue()));
                     if (interval > 0 && configFile != null) {
                         monitor = new FileConfigurationMonitor(configFile, listeners, interval);
                     }
@@ -126,6 +132,9 @@ public class XMLConfiguration extends BaseConfiguration {
                     listener.setFilters(VERBOSE_CLASSES);
                 }
                 ((StatusLogger) LOGGER).registerListener(listener);
+                for (String msg : messages) {
+                    LOGGER.error(msg);
+                }
             }
 
         } catch (SAXException domEx) {
diff --git a/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java b/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java
index bace0e8860..090e2ba329 100644
--- a/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java
+++ b/core/src/main/java/org/apache/logging/log4j/core/lookup/Interpolator.java
@@ -55,6 +55,11 @@ public class Interpolator implements StrLookup {
         }
     }
 
+    public Interpolator() {
+        this.defaultLookup= new MapLookup(new HashMap<String, String>());
+        lookups.put("sys", new SystemPropertiesLookup());
+    }
+
      /**
      * Resolves the specified variable. This implementation will try to extract
      * a variable prefix from the given variable name (the first colon (':') is
diff --git a/core/src/test/java/org/apache/logging/log4j/core/config/XMLConfigurationPropsTest.java b/core/src/test/java/org/apache/logging/log4j/core/config/XMLConfigurationPropsTest.java
new file mode 100644
index 0000000000..f160cdd451
--- /dev/null
+++ b/core/src/test/java/org/apache/logging/log4j/core/config/XMLConfigurationPropsTest.java
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.config;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.core.Appender;
+import org.apache.logging.log4j.core.Filter;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.filter.ThreadContextMapFilter;
+import org.apache.logging.log4j.status.StatusLogger;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.util.Iterator;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+/**
+ *
+ */
+public class XMLConfigurationPropsTest {
+
+    private static final String CONFIG = "log4j-props.xml";
+    private static final String LOGFILE = "target/test.log";
+
+    @BeforeClass
+    public static void setupClass() {
+    }
+
+    @AfterClass
+    public static void cleanupClass() {
+        System.clearProperty(XMLConfigurationFactory.CONFIGURATION_FILE_PROPERTY);
+        LoggerContext ctx = (LoggerContext) LogManager.getContext();
+        ctx.reconfigure();
+        StatusLogger.getLogger().reset();
+    }
+
+    @Test
+    public void testNoProps() {
+        System.setProperty(XMLConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
+        LoggerContext ctx = (LoggerContext) LogManager.getContext();
+        ctx.reconfigure();
+        Configuration config = ctx.getConfiguration();
+        assertTrue("Configuration is not an XMLConfiguration", config instanceof XMLConfiguration);
+    }
+
+    @Test
+    public void testWithConfigProp() {
+        System.setProperty(XMLConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
+        System.setProperty("log4j.level", "debug");
+        try {
+            LoggerContext ctx = (LoggerContext) LogManager.getContext();
+            ctx.reconfigure();
+            Configuration config = ctx.getConfiguration();
+            assertTrue("Configuration is not an XMLConfiguration", config instanceof XMLConfiguration);
+        } finally {
+            System.clearProperty("log4j.level");
+
+        }
+    }
+
+    @Test
+    public void testWithProps() {
+        System.setProperty(XMLConfigurationFactory.CONFIGURATION_FILE_PROPERTY, CONFIG);
+        System.setProperty("log4j.level", "debug");
+        System.setProperty("log.level", "debug");
+        try {
+            LoggerContext ctx = (LoggerContext) LogManager.getContext();
+            ctx.reconfigure();
+            Configuration config = ctx.getConfiguration();
+            assertTrue("Configuration is not an XMLConfiguration", config instanceof XMLConfiguration);
+        } finally {
+            System.clearProperty("log4j.level");
+            System.clearProperty("log.level");
+        }
+    }
+}
diff --git a/core/src/test/resources/log4j-props.xml b/core/src/test/resources/log4j-props.xml
new file mode 100644
index 0000000000..9612574a43
--- /dev/null
+++ b/core/src/test/resources/log4j-props.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<configuration status="${sys:log4j.level}" strict="false" name="DSI" packages="com.terradue.dsione">
+  <appenders>
+    <Console name="Console" target="SYSTEM_OUT">
+      <PatternLayout pattern="[%-5level] %msg%n" />
+    </Console>
+  </appenders>
+
+  <loggers>
+    <root level="${sys:log.level}">
+      <appender-ref ref="Console" />
+    </root>
+  </loggers>
+</configuration>
\ No newline at end of file
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index eb54eba9e7..7acf56f2e0 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,6 +22,11 @@
   </properties>
 
   <body>
+    <release version="2.0-alpha2" date="TBD" description="Bug fixes and minor enhancements">
+      <action issue="LOG4J2-65" dev="rgoers">
+        Allow variable substitution on the configuration attributes and on the root log level.
+      </action>
+    </release>
     <release version="2.0-alpha1" date="2012-07-29" description="Rewrite of Log4j">
       <action issue="LOG4J2-60" dev="rgoers" type="add" due-to="Shane Kelly">
         Added ability to filter on the appender-ref by adding either a level or a filter.
