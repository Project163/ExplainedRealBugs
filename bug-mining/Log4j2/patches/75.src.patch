diff --git a/core/src/main/java/org/apache/logging/log4j/core/appender/AsynchAppender.java b/core/src/main/java/org/apache/logging/log4j/core/appender/AsynchAppender.java
index 004e796aa7..477b144f22 100644
--- a/core/src/main/java/org/apache/logging/log4j/core/appender/AsynchAppender.java
+++ b/core/src/main/java/org/apache/logging/log4j/core/appender/AsynchAppender.java
@@ -76,7 +76,8 @@ public final class AsynchAppender<T extends Serializable> extends AbstractAppend
         final List<AppenderControl> appenders = new ArrayList<AppenderControl>();
         for (final AppenderRef appenderRef : appenderRefs) {
             if (map.containsKey(appenderRef.getRef())) {
-                appenders.add(new AppenderControl(map.get(appenderRef.getRef()), null, null));
+                appenders.add(new AppenderControl(map.get(appenderRef.getRef()), appenderRef.getLevel(),
+                    appenderRef.getFilter()));
             } else {
                 LOGGER.error("No appender named {} was configured", appenderRef);
             }
@@ -119,18 +120,21 @@ public final class AsynchAppender<T extends Serializable> extends AbstractAppend
             throw new IllegalStateException("AsynchAppender " + getName() + " is not active");
         }
         if (event instanceof Log4jLogEvent) {
-            if (blocking && queue.remainingCapacity() > 0) {
+            boolean appendSuccessful = false;
+            if (blocking){
                 try {
-                    queue.add(Log4jLogEvent.serialize((Log4jLogEvent) event));
-                    return;
-                } catch (final IllegalStateException ex) {
-                    error("Appender " + getName() + " is unable to write primary appenders. queue is full");
+                    queue.put(Log4jLogEvent.serialize((Log4jLogEvent) event)); // wait for free slots in the queue
+                    appendSuccessful = true;
+                } catch (InterruptedException e) {
+                    LOGGER.warn("Interrupted while waiting for a free slots in the LogEvent-queue at the AsynchAppender {}", getName());
                 }
-            }
-            if (errorAppender != null) {
-                if (!blocking) {
+            } else {
+                appendSuccessful = queue.offer(Log4jLogEvent.serialize((Log4jLogEvent) event));
+                if (!appendSuccessful) {
                     error("Appender " + getName() + " is unable to write primary appenders. queue is full");
                 }
+            }
+            if ((!appendSuccessful) && (errorAppender != null)){
                 errorAppender.callAppender(event);
             }
         }
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index c588982992..d159dbf347 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -23,6 +23,12 @@
 
   <body>
     <release version="2.0-beta5" date="@TBD@" description="Bug fixes and enhancements">
+      <action issue="LOG4J2-189" dev="rgoers" type="fix" due-to="Werner">
+        The blocking parameter did not work properly on AsynchAppender.
+      </action>
+      <action issue="LOG4J2-188" dev="rgoers" type="fix" due-to="Werner">
+        appender-refs on AsynchAppender didn't support the level and filter elements.
+      </action>
       <action issue="LOG4J2-176" dev="rgoers" type="fix" due-to="Remko Popma">
         Avoid IllegalArgumentException in AsynchAppender.
       </action>
