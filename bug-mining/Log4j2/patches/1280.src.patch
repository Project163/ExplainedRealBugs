diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/DatePatternConverterTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/DatePatternConverterTest.java
index 3bb36772d7..34f0b08a26 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/DatePatternConverterTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/DatePatternConverterTest.java
@@ -43,6 +43,25 @@ import static org.junit.Assert.*;
 @RunWith(Parameterized.class)
 public class DatePatternConverterTest {
 
+    private class MyLogEvent extends AbstractLogEvent {
+        private static final long serialVersionUID = 0;
+
+        @Override
+        public Instant getInstant() {
+            final MutableInstant result = new MutableInstant();
+            result.initFromEpochMilli(getTimeMillis(), 123456);
+            return result;
+        }
+
+        @Override
+        public long getTimeMillis() {
+            final Calendar cal = Calendar.getInstance();
+            cal.set(2011, Calendar.DECEMBER, 30, 10, 56, 35);
+            cal.set(Calendar.MILLISECOND, 987);
+            return cal.getTimeInMillis();
+        }
+    }
+
     /**
      * SimpleTimePattern for DEFAULT.
      */
@@ -84,9 +103,72 @@ public class DatePatternConverterTest {
         field.setBoolean(null, threadLocalEnabled.booleanValue());
     }
 
+    private Date date(final int year, final int month, final int date) {
+        final Calendar cal = Calendar.getInstance();
+        cal.set(year, month, date, 14, 15, 16);
+        cal.set(Calendar.MILLISECOND, 123);
+        return cal.getTime();
+    }
+
+    private String precisePattern(final String pattern, final int precision) {
+        String search = "SSS";
+        int foundIndex = pattern.indexOf(search);
+        final String seconds = pattern.substring(0, foundIndex);
+        final String remainder = pattern.substring(foundIndex + search.length());
+        return seconds + "nnnnnnnnn".substring(0, precision) + remainder;
+    }
+
     @Test
-    public void testNewInstanceAllowsNullParameter() {
-        DatePatternConverter.newInstance(null); // no errors
+    public void testFormatDateStringBuilderDefaultPattern() {
+        final DatePatternConverter converter = DatePatternConverter.newInstance(null);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(date(2001, 1, 1), sb);
+
+        final String expected = "2001-02-01 14:15:16,123";
+        assertEquals(expected, sb.toString());
+    }
+
+    @Test
+    public void testFormatDateStringBuilderIso8601() {
+        final DatePatternConverter converter = DatePatternConverter.newInstance(ISO8601_FORMAT_OPTIONS);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(date(2001, 1, 1), sb);
+
+        final String expected = "2001-02-01T14:15:16,123";
+        assertEquals(expected, sb.toString());
+    }
+
+    @Test
+    public void testFormatDateStringBuilderIso8601BasicWithPeriod() {
+        final String[] pattern = {FixedDateFormat.FixedFormat.ISO8601_BASIC_PERIOD.name()};
+        final DatePatternConverter converter = DatePatternConverter.newInstance(pattern);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(date(2001, 1, 1), sb);
+
+        final String expected = "20010201T141516.123";
+        assertEquals(expected, sb.toString());
+    }
+
+    @Test
+    public void testFormatDateStringBuilderIso8601WithPeriod() {
+        final String[] pattern = {FixedDateFormat.FixedFormat.ISO8601_PERIOD.name()};
+        final DatePatternConverter converter = DatePatternConverter.newInstance(pattern);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(date(2001, 1, 1), sb);
+
+        final String expected = "2001-02-01T14:15:16.123";
+        assertEquals(expected, sb.toString());
+    }
+
+    @Test
+    public void testFormatDateStringBuilderOriginalPattern() {
+        final String[] pattern = {"yyyy/MM/dd HH-mm-ss.SSS"};
+        final DatePatternConverter converter = DatePatternConverter.newInstance(pattern);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(date(2001, 1, 1), sb);
+
+        final String expected = "2001/02/01 14-15-16.123";
+        assertEquals(expected, sb.toString());
     }
 
     @Test
@@ -112,36 +194,64 @@ public class DatePatternConverterTest {
     }
 
     @Test
-    public void testFormatLogEventStringBuilderIso8601TimezoneUTC() {
+    public void testFormatLogEventStringBuilderIso8601TimezoneJST() {
         final LogEvent event = new MyLogEvent();
-        final DatePatternConverter converter = DatePatternConverter.newInstance(new String[] {"ISO8601", "UTC"});
+        final String[] optionsWithTimezone = { ISO8601, "JST" };
+        final DatePatternConverter converter = DatePatternConverter.newInstance(optionsWithTimezone);
         final StringBuilder sb = new StringBuilder();
         converter.format(event, sb);
 
-        final TimeZone tz = TimeZone.getTimeZone("UTC");
+        // JST=Japan Standard Time: UTC+9:00
+        final TimeZone tz = TimeZone.getTimeZone("JST");
         final SimpleDateFormat sdf = new SimpleDateFormat(converter.getPattern());
         sdf.setTimeZone(tz);
         final long adjusted = event.getTimeMillis() + tz.getDSTSavings();
         final String expected = sdf.format(new Date(adjusted));
-        // final String expected = "2011-12-30T09:56:35,987";
+        // final String expected = "2011-12-30T18:56:35,987"; // in CET (Central Eastern Time: Amsterdam)
         assertEquals(expected, sb.toString());
     }
 
     @Test
-    public void testFormatLogEventStringBuilderIso8601TimezoneJST() {
+    public void testFormatLogEventStringBuilderIso8601TimezoneOffset() {
         final LogEvent event = new MyLogEvent();
-        final String[] optionsWithTimezone = { ISO8601, "JST" };
+        final String[] optionsWithTimezone = { ISO8601_OFFSET_DATE_TIME_HHCMM };
+        final DatePatternConverter converter = DatePatternConverter.newInstance(optionsWithTimezone);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(event, sb);
+
+        final SimpleDateFormat sdf = new SimpleDateFormat(converter.getPattern());
+        final String format = sdf.format(new Date(event.getTimeMillis()));
+        final String expected = format.endsWith("Z") ? format.substring(0, format.length() - 1) + "+00:00" : format;
+        assertEquals(expected, sb.toString());
+    }
+
+    @Test
+    public void testFormatLogEventStringBuilderIso8601TimezoneOffsetXX() {
+        final LogEvent event = new MyLogEvent();
+        final String[] optionsWithTimezone = { ISO8601_OFFSET_DATE_TIME_HHMM };
         final DatePatternConverter converter = DatePatternConverter.newInstance(optionsWithTimezone);
         final StringBuilder sb = new StringBuilder();
         converter.format(event, sb);
 
-        // JST=Japan Standard Time: UTC+9:00
-        final TimeZone tz = TimeZone.getTimeZone("JST");
+        final SimpleDateFormat sdf = new SimpleDateFormat(converter.getPattern());
+        final String format = sdf.format(new Date(event.getTimeMillis()));
+        final String expected = format.endsWith("Z") ? format.substring(0, format.length() - 1) + "+0000" : format;
+        assertEquals(expected, sb.toString());
+    }
+
+    @Test
+    public void testFormatLogEventStringBuilderIso8601TimezoneUTC() {
+        final LogEvent event = new MyLogEvent();
+        final DatePatternConverter converter = DatePatternConverter.newInstance(new String[] {"ISO8601", "UTC"});
+        final StringBuilder sb = new StringBuilder();
+        converter.format(event, sb);
+
+        final TimeZone tz = TimeZone.getTimeZone("UTC");
         final SimpleDateFormat sdf = new SimpleDateFormat(converter.getPattern());
         sdf.setTimeZone(tz);
         final long adjusted = event.getTimeMillis() + tz.getDSTSavings();
         final String expected = sdf.format(new Date(adjusted));
-        // final String expected = "2011-12-30T18:56:35,987"; // in CET (Central Eastern Time: Amsterdam)
+        // final String expected = "2011-12-30T09:56:35,987";
         assertEquals(expected, sb.toString());
     }
 
@@ -163,102 +273,71 @@ public class DatePatternConverterTest {
     }
 
     @Test
-    public void testFormatLogEventStringBuilderIso8601TimezoneOffset() {
-        final LogEvent event = new MyLogEvent();
-        final String[] optionsWithTimezone = { ISO8601_OFFSET_DATE_TIME_HHCMM };
-        final DatePatternConverter converter = DatePatternConverter.newInstance(optionsWithTimezone);
+    public void testFormatObjectStringBuilderDefaultPattern() {
+        final DatePatternConverter converter = DatePatternConverter.newInstance(null);
         final StringBuilder sb = new StringBuilder();
-        converter.format(event, sb);
+        converter.format("nondate", sb);
 
-        final SimpleDateFormat sdf = new SimpleDateFormat(converter.getPattern());
-        final String format = sdf.format(new Date(event.getTimeMillis()));
-        final String expected = format.endsWith("Z") ? format.substring(0, format.length() - 1) + "+00:00" : format;
+        final String expected = ""; // only process dates
         assertEquals(expected, sb.toString());
     }
 
     @Test
-    public void testFormatLogEventStringBuilderIso8601TimezoneOffsetXX() {
-        final LogEvent event = new MyLogEvent();
-        final String[] optionsWithTimezone = { ISO8601_OFFSET_DATE_TIME_HHMM };
-        final DatePatternConverter converter = DatePatternConverter.newInstance(optionsWithTimezone);
+    public void testFormatStringBuilderObjectArrayDefaultPattern() {
+        final DatePatternConverter converter = DatePatternConverter.newInstance(null);
         final StringBuilder sb = new StringBuilder();
-        converter.format(event, sb);
+        converter.format(sb, date(2001, 1, 1), date(2002, 2, 2), date(2003, 3, 3));
 
-        final SimpleDateFormat sdf = new SimpleDateFormat(converter.getPattern());
-        final String format = sdf.format(new Date(event.getTimeMillis()));
-        final String expected = format.endsWith("Z") ? format.substring(0, format.length() - 1) + "+0000" : format;
+        final String expected = "2001-02-01 14:15:16,123"; // only process first date
         assertEquals(expected, sb.toString());
     }
 
     @Test
-    public void testPredefinedFormatWithTimezone() {
-        for (final FixedDateFormat.FixedFormat format : FixedDateFormat.FixedFormat.values()) {
-            final String[] options = {format.name(), "PDT"}; // Pacific Daylight Time=UTC-8:00
-            final DatePatternConverter converter = DatePatternConverter.newInstance(options);
-            assertEquals(format.getPattern(), converter.getPattern());
-        }
+    public void testFormatStringBuilderObjectArrayIso8601() {
+        final DatePatternConverter converter = DatePatternConverter.newInstance(ISO8601_FORMAT_OPTIONS);
+        final StringBuilder sb = new StringBuilder();
+        converter.format(sb, date(2001, 1, 1), date(2002, 2, 2), date(2003, 3, 3));
+
+        final String expected = "2001-02-01T14:15:16,123"; // only process first date
+        assertEquals(expected, sb.toString());
     }
 
     @Test
-    public void testPredefinedFormatWithoutTimezone() {
-        for (final FixedDateFormat.FixedFormat format : FixedDateFormat.FixedFormat.values()) {
-            final String[] options = {format.name()};
-            final DatePatternConverter converter = DatePatternConverter.newInstance(options);
-            assertEquals(format.getPattern(), converter.getPattern());
-        }
+    public void testGetPatternReturnsDefaultForEmptyOptionsArray() {
+        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(new String[0]).getPattern());
     }
 
-    private String precisePattern(final String pattern, final int precision) {
-        String search = "SSS";
-        int foundIndex = pattern.indexOf(search);
-        final String seconds = pattern.substring(0, foundIndex);
-        final String remainder = pattern.substring(foundIndex + search.length());
-        return seconds + "nnnnnnnnn".substring(0, precision) + remainder;
+    @Test
+    public void testGetPatternReturnsDefaultForInvalidPattern() {
+        final String[] invalid = {"ABC I am not a valid date pattern"};
+        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(invalid).getPattern());
     }
 
-    // test with all formats from one 'n' (100s of millis) to 'nnnnnnnnn' (nanosecond precision)
     @Test
-    public void testPredefinedFormatWithAnyValidNanoPrecision() {
-        final StringBuilder preciseBuilder = new StringBuilder();
-        final StringBuilder milliBuilder = new StringBuilder();
-        final LogEvent event = new MyLogEvent();
+    public void testGetPatternReturnsDefaultForNullOptions() {
+        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(null).getPattern());
+    }
 
-        for (final String timeZone : new String[]{"PDT", null}) { // Pacific Daylight Time=UTC-8:00
-            for (final FixedDateFormat.FixedFormat format : FixedDateFormat.FixedFormat.values()) {
-                for (int i = 1; i <= 9; i++) {
-                    final String pattern = format.getPattern();
-                    if (pattern.endsWith("n") || pattern.matches(".+n+X*") || pattern.matches(".+n+Z*")
-                            || pattern.indexOf("SSS") < 0) {
-                        // ignore patterns that already have precise time formats
-                        // ignore patterns that do not use seconds.
-                        continue;
-                    }
-                    preciseBuilder.setLength(0);
-                    milliBuilder.setLength(0);
+    @Test
+    public void testGetPatternReturnsDefaultForSingleNullElementOptionsArray() {
+        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(new String[1]).getPattern());
+    }
 
-                    final String precisePattern = precisePattern(pattern, i);
-                    final String[] preciseOptions = { precisePattern, timeZone };
-                    final DatePatternConverter preciseConverter = DatePatternConverter.newInstance(preciseOptions);
-                    preciseConverter.format(event, preciseBuilder);
+    @Test
+    public void testGetPatternReturnsDefaultForTwoNullElementsOptionsArray() {
+        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(new String[2]).getPattern());
+    }
 
-                    final String[] milliOptions = { pattern, timeZone };
-                    DatePatternConverter.newInstance(milliOptions).format(event, milliBuilder);
-                    FixedTimeZoneFormat timeZoneFormat = format.getFixedTimeZoneFormat();
-                    final int truncateLen = 3 + (timeZoneFormat != null ? timeZoneFormat.getLength() : 0);
-                    final String tz = timeZoneFormat != null
-                            ? milliBuilder.substring(milliBuilder.length() - timeZoneFormat.getLength(),
-                                    milliBuilder.length())
-                            : Strings.EMPTY;
-                    milliBuilder.setLength(milliBuilder.length() - truncateLen); // truncate millis
-                    final String expected = milliBuilder.append("987123456".substring(0, i)).append(tz).toString();
+    @Test
+    public void testGetPatternReturnsNullForUnix() {
+        final String[] options = {"UNIX"};
+        assertNull(DatePatternConverter.newInstance(options).getPattern());
+    }
 
-                    assertEquals(
-                            "format = " + format + ", pattern = " + pattern + ", precisePattern = " + precisePattern,
-                            expected, preciseBuilder.toString());
-                    // System.out.println(preciseOptions[0] + ": " + precise);
-                }
-            }
-        }
+    @Test
+    public void testGetPatternReturnsNullForUnixMillis() {
+        final String[] options = {"UNIX_MILLIS"};
+        assertNull(DatePatternConverter.newInstance(options).getPattern());
     }
 
     @Test
@@ -311,151 +390,72 @@ public class DatePatternConverterTest {
         }
     }
 
-    private class MyLogEvent extends AbstractLogEvent {
-        private static final long serialVersionUID = 0;
-
-        @Override
-        public long getTimeMillis() {
-            final Calendar cal = Calendar.getInstance();
-            cal.set(2011, Calendar.DECEMBER, 30, 10, 56, 35);
-            cal.set(Calendar.MILLISECOND, 987);
-            return cal.getTimeInMillis();
-        }
-
-        @Override
-        public Instant getInstant() {
-            final MutableInstant result = new MutableInstant();
-            result.initFromEpochMilli(getTimeMillis(), 123456);
-            return result;
-        }
-    }
-
-    @Test
-    public void testFormatObjectStringBuilderDefaultPattern() {
-        final DatePatternConverter converter = DatePatternConverter.newInstance(null);
-        final StringBuilder sb = new StringBuilder();
-        converter.format("nondate", sb);
-
-        final String expected = ""; // only process dates
-        assertEquals(expected, sb.toString());
-    }
-
-    @Test
-    public void testFormatDateStringBuilderDefaultPattern() {
-        final DatePatternConverter converter = DatePatternConverter.newInstance(null);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(date(2001, 1, 1), sb);
-
-        final String expected = "2001-02-01 14:15:16,123";
-        assertEquals(expected, sb.toString());
-    }
-
-    @Test
-    public void testFormatDateStringBuilderIso8601() {
-        final DatePatternConverter converter = DatePatternConverter.newInstance(ISO8601_FORMAT_OPTIONS);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(date(2001, 1, 1), sb);
-
-        final String expected = "2001-02-01T14:15:16,123";
-        assertEquals(expected, sb.toString());
-    }
-
-    @Test
-    public void testFormatDateStringBuilderIso8601WithPeriod() {
-        final String[] pattern = {FixedDateFormat.FixedFormat.ISO8601_PERIOD.name()};
-        final DatePatternConverter converter = DatePatternConverter.newInstance(pattern);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(date(2001, 1, 1), sb);
-
-        final String expected = "2001-02-01T14:15:16.123";
-        assertEquals(expected, sb.toString());
-    }
-
-    @Test
-    public void testFormatDateStringBuilderIso8601BasicWithPeriod() {
-        final String[] pattern = {FixedDateFormat.FixedFormat.ISO8601_BASIC_PERIOD.name()};
-        final DatePatternConverter converter = DatePatternConverter.newInstance(pattern);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(date(2001, 1, 1), sb);
-
-        final String expected = "20010201T141516.123";
-        assertEquals(expected, sb.toString());
-    }
-
-    @Test
-    public void testFormatDateStringBuilderOriginalPattern() {
-        final String[] pattern = {"yyyy/MM/dd HH-mm-ss.SSS"};
-        final DatePatternConverter converter = DatePatternConverter.newInstance(pattern);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(date(2001, 1, 1), sb);
-
-        final String expected = "2001/02/01 14-15-16.123";
-        assertEquals(expected, sb.toString());
-    }
-
     @Test
-    public void testFormatStringBuilderObjectArrayDefaultPattern() {
-        final DatePatternConverter converter = DatePatternConverter.newInstance(null);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(sb, date(2001, 1, 1), date(2002, 2, 2), date(2003, 3, 3));
-
-        final String expected = "2001-02-01 14:15:16,123"; // only process first date
-        assertEquals(expected, sb.toString());
-    }
-
-    @Test
-    public void testFormatStringBuilderObjectArrayIso8601() {
-        final DatePatternConverter converter = DatePatternConverter.newInstance(ISO8601_FORMAT_OPTIONS);
-        final StringBuilder sb = new StringBuilder();
-        converter.format(sb, date(2001, 1, 1), date(2002, 2, 2), date(2003, 3, 3));
-
-        final String expected = "2001-02-01T14:15:16,123"; // only process first date
-        assertEquals(expected, sb.toString());
-    }
-
-    private Date date(final int year, final int month, final int date) {
-        final Calendar cal = Calendar.getInstance();
-        cal.set(year, month, date, 14, 15, 16);
-        cal.set(Calendar.MILLISECOND, 123);
-        return cal.getTime();
+    public void testNewInstanceAllowsNullParameter() {
+        DatePatternConverter.newInstance(null); // no errors
     }
 
+    // test with all formats from one 'n' (100s of millis) to 'nnnnnnnnn' (nanosecond precision)
     @Test
-    public void testGetPatternReturnsDefaultForNullOptions() {
-        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(null).getPattern());
-    }
+    public void testPredefinedFormatWithAnyValidNanoPrecision() {
+        final StringBuilder preciseBuilder = new StringBuilder();
+        final StringBuilder milliBuilder = new StringBuilder();
+        final LogEvent event = new MyLogEvent();
 
-    @Test
-    public void testGetPatternReturnsDefaultForEmptyOptionsArray() {
-        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(new String[0]).getPattern());
-    }
+        for (final String timeZone : new String[]{"PDT", null}) { // Pacific Daylight Time=UTC-8:00
+            for (final FixedDateFormat.FixedFormat format : FixedDateFormat.FixedFormat.values()) {
+                for (int i = 1; i <= 9; i++) {
+                    final String pattern = format.getPattern();
+                    if (pattern.endsWith("n") || pattern.matches(".+n+X*") || pattern.matches(".+n+Z*")
+                            || pattern.indexOf("SSS") < 0) {
+                        // ignore patterns that already have precise time formats
+                        // ignore patterns that do not use seconds.
+                        continue;
+                    }
+                    preciseBuilder.setLength(0);
+                    milliBuilder.setLength(0);
 
-    @Test
-    public void testGetPatternReturnsDefaultForSingleNullElementOptionsArray() {
-        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(new String[1]).getPattern());
-    }
+                    final String precisePattern = precisePattern(pattern, i);
+                    final String[] preciseOptions = { precisePattern, timeZone };
+                    final DatePatternConverter preciseConverter = DatePatternConverter.newInstance(preciseOptions);
+                    preciseConverter.format(event, preciseBuilder);
 
-    @Test
-    public void testGetPatternReturnsDefaultForTwoNullElementsOptionsArray() {
-        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(new String[2]).getPattern());
-    }
+                    final String[] milliOptions = { pattern, timeZone };
+                    DatePatternConverter.newInstance(milliOptions).format(event, milliBuilder);
+                    FixedTimeZoneFormat timeZoneFormat = format.getFixedTimeZoneFormat();
+                    final int truncateLen = 3 + (timeZoneFormat != null ? timeZoneFormat.getLength() : 0);
+                    final String tz = timeZoneFormat != null
+                            ? milliBuilder.substring(milliBuilder.length() - timeZoneFormat.getLength(),
+                                    milliBuilder.length())
+                            : Strings.EMPTY;
+                    milliBuilder.setLength(milliBuilder.length() - truncateLen); // truncate millis
+                    final String expected = milliBuilder.append("987123456".substring(0, i)).append(tz).toString();
 
-    @Test
-    public void testGetPatternReturnsDefaultForInvalidPattern() {
-        final String[] invalid = {"ABC I am not a valid date pattern"};
-        assertEquals(DEFAULT_PATTERN, DatePatternConverter.newInstance(invalid).getPattern());
+                    assertEquals(
+                            "format = " + format + ", pattern = " + pattern + ", precisePattern = " + precisePattern,
+                            expected, preciseBuilder.toString());
+                    // System.out.println(preciseOptions[0] + ": " + precise);
+                }
+            }
+        }
     }
 
     @Test
-    public void testGetPatternReturnsNullForUnix() {
-        final String[] options = {"UNIX"};
-        assertNull(DatePatternConverter.newInstance(options).getPattern());
+    public void testPredefinedFormatWithoutTimezone() {
+        for (final FixedDateFormat.FixedFormat format : FixedDateFormat.FixedFormat.values()) {
+            final String[] options = {format.name()};
+            final DatePatternConverter converter = DatePatternConverter.newInstance(options);
+            assertEquals(format.getPattern(), converter.getPattern());
+        }
     }
 
     @Test
-    public void testGetPatternReturnsNullForUnixMillis() {
-        final String[] options = {"UNIX_MILLIS"};
-        assertNull(DatePatternConverter.newInstance(options).getPattern());
+    public void testPredefinedFormatWithTimezone() {
+        for (final FixedDateFormat.FixedFormat format : FixedDateFormat.FixedFormat.values()) {
+            final String[] options = {format.name(), "PDT"}; // Pacific Daylight Time=UTC-8:00
+            final DatePatternConverter converter = DatePatternConverter.newInstance(options);
+            assertEquals(format.getPattern(), converter.getPattern());
+        }
     }
 
 }
