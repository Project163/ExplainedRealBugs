diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java b/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java
index 649772d2f3..48f7ec7b0c 100644
--- a/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java
+++ b/log4j-api/src/main/java/org/apache/logging/log4j/message/MapMessage.java
@@ -21,6 +21,7 @@ import java.util.Map;
 import java.util.TreeMap;
 
 import org.apache.logging.log4j.util.BiConsumer;
+import org.apache.logging.log4j.util.Chars;
 import org.apache.logging.log4j.util.EnglishEnums;
 import org.apache.logging.log4j.util.IndexedReadOnlyStringMap;
 import org.apache.logging.log4j.util.IndexedStringMap;
@@ -344,9 +345,11 @@ public class MapMessage<M extends MapMessage<M, V>, V> implements MultiformatMes
         for (int i = 0; i < data.size(); i++) {
             sb.append("  <Entry key=\"")
                     .append(data.getKeyAt(i))
-                    .append("\">")
-                    .append(data.<Object>getValueAt(i))
-                    .append("</Entry>\n");
+                    .append("\">");
+            int size = sb.length();
+            sb.append(data.<Object>getValueAt(i));
+            StringBuilders.escapeXml(sb, size);
+            sb.append("</Entry>\n");
         }
         sb.append("</Map>");
     }
@@ -400,8 +403,15 @@ public class MapMessage<M extends MapMessage<M, V>, V> implements MultiformatMes
             if (i > 0) {
                 sb.append(", ");
             }
-            StringBuilders.appendDqValue(sb, data.getKeyAt(i)).append(':');
-            StringBuilders.appendDqValue(sb, data.getValueAt(i));
+            sb.append(Chars.DQUOTE);
+            int start = sb.length();
+            sb.append(data.getKeyAt(i));
+            StringBuilders.escapeJson(sb, start);
+            sb.append(Chars.DQUOTE).append(':').append(Chars.DQUOTE);
+            start = sb.length();
+            sb.append(data.<Object>getValueAt(i));
+            StringBuilders.escapeJson(sb, start);
+            sb.append(Chars.DQUOTE);
         }
         sb.append('}');
     }
diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/util/StringBuilders.java b/log4j-api/src/main/java/org/apache/logging/log4j/util/StringBuilders.java
index 2d6ae9cef4..1ab09092dc 100644
--- a/log4j-api/src/main/java/org/apache/logging/log4j/util/StringBuilders.java
+++ b/log4j-api/src/main/java/org/apache/logging/log4j/util/StringBuilders.java
@@ -158,4 +158,48 @@ public final class StringBuilders {
             stringBuilder.trimToSize();
         }
     }
+
+    public static void escapeJson(final StringBuilder toAppendTo, final int start) {
+        for (int i = toAppendTo.length() - 1; i >= start; i--) { // backwards: length may change
+            final char c = toAppendTo.charAt(i);
+            if (Character.isISOControl(c)) {
+                // all iso control characters are in U+00xx
+                toAppendTo.setCharAt(i, '\\');
+                toAppendTo.insert(i + 1, "u0000");
+                toAppendTo.setCharAt(i + 4, Chars.getUpperCaseHex((c & 0xF0) >> 4));
+                toAppendTo.setCharAt(i + 5, Chars.getUpperCaseHex(c & 0xF));
+            } else if (c == '"' || c == '\\') {
+                // only " and \ need to be escaped; other escapes are optional
+                toAppendTo.insert(i, '\\');
+            }
+        }
+    }
+
+    public static void escapeXml(final StringBuilder toAppendTo, final int start) {
+        for (int i = toAppendTo.length() - 1; i >= start; i--) { // backwards: length may change
+            final char c = toAppendTo.charAt(i);
+            switch (c) {
+                case '&':
+                    toAppendTo.setCharAt(i, '&');
+                    toAppendTo.insert(i + 1, "amp;");
+                    break;
+                case '<':
+                    toAppendTo.setCharAt(i, '&');
+                    toAppendTo.insert(i + 1, "lt;");
+                    break;
+                case '>':
+                    toAppendTo.setCharAt(i, '&');
+                    toAppendTo.insert(i + 1, "gt;");
+                    break;
+                case '"':
+                    toAppendTo.setCharAt(i, '&');
+                    toAppendTo.insert(i + 1, "quot;");
+                    break;
+                case '\'':
+                    toAppendTo.setCharAt(i, '&');
+                    toAppendTo.insert(i + 1, "apos;");
+                    break;
+            }
+        }
+    }
 }
diff --git a/log4j-api/src/test/java/org/apache/logging/log4j/message/MapMessageTest.java b/log4j-api/src/test/java/org/apache/logging/log4j/message/MapMessageTest.java
index 9aae448396..781d46d460 100644
--- a/log4j-api/src/test/java/org/apache/logging/log4j/message/MapMessageTest.java
+++ b/log4j-api/src/test/java/org/apache/logging/log4j/message/MapMessageTest.java
@@ -63,6 +63,17 @@ public class MapMessageTest {
         assertEquals(expected, result);
     }
 
+    @Test
+    public void testXMLEscape() {
+        final String testMsg = "Test message <foo>";
+        final StringMapMessage msg = new StringMapMessage();
+        msg.put("message", testMsg);
+        final String result = msg.getFormattedMessage(new String[]{"XML"});
+        final String expected = "<Map>\n  <Entry key=\"message\">Test message &lt;foo&gt;</Entry>\n" +
+                "</Map>";
+        assertEquals(expected, result);
+    }
+
     @Test
     public void testJSON() {
         final String testMsg = "Test message {}";
@@ -74,6 +85,16 @@ public class MapMessageTest {
         assertEquals(expected, result);
     }
 
+    @Test
+    public void testJSONEscape() {
+        final String testMsg = "Test message \"Hello, World!\"";
+        final StringMapMessage msg = new StringMapMessage();
+        msg.put("message", testMsg);
+        final String result = msg.getFormattedMessage(new String[]{"JSON"});
+        final String expected = "{\"message\":\"Test message \\\"Hello, World!\\\"\"}";
+        assertEquals(expected, result);
+    }
+
     @Test
     public void testJava() {
         final String testMsg = "Test message {}";
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/EncodingPatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/EncodingPatternConverter.java
index 4d22ee0650..2699b1f364 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/EncodingPatternConverter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/EncodingPatternConverter.java
@@ -25,6 +25,7 @@ import org.apache.logging.log4j.core.layout.PatternLayout;
 import org.apache.logging.log4j.util.Chars;
 import org.apache.logging.log4j.util.EnglishEnums;
 import org.apache.logging.log4j.util.PerformanceSensitive;
+import org.apache.logging.log4j.util.StringBuilders;
 
 /**
  * Converter that encodes the output from a pattern using a specified format. Supported formats include HTML
@@ -139,19 +140,7 @@ public final class EncodingPatternConverter extends LogEventPatternConverter {
         JSON {
             @Override
             void escape(final StringBuilder toAppendTo, final int start) {
-                for (int i = toAppendTo.length() - 1; i >= start; i--) { // backwards: length may change
-                    final char c = toAppendTo.charAt(i);
-                    if (Character.isISOControl(c)) {
-                        // all iso control characters are in U+00xx
-                        toAppendTo.setCharAt(i, '\\');
-                        toAppendTo.insert(i + 1, "u0000");
-                        toAppendTo.setCharAt(i + 4, Chars.getUpperCaseHex((c & 0xF0) >> 4));
-                        toAppendTo.setCharAt(i + 5, Chars.getUpperCaseHex(c & 0xF));
-                    } else if (c == '"' || c == '\\') {
-                        // only " and \ need to be escaped; other escapes are optional
-                        toAppendTo.insert(i, '\\');
-                    }
-                }
+                StringBuilders.escapeJson(toAppendTo, start);
             }
         },
 
@@ -182,31 +171,7 @@ public final class EncodingPatternConverter extends LogEventPatternConverter {
         XML {
             @Override
             void escape(final StringBuilder toAppendTo, final int start) {
-                for (int i = toAppendTo.length() - 1; i >= start; i--) { // backwards: length may change
-                    final char c = toAppendTo.charAt(i);
-                    switch (c) {
-                        case '&':
-                            toAppendTo.setCharAt(i, '&');
-                            toAppendTo.insert(i + 1, "amp;");
-                            break;
-                        case '<':
-                            toAppendTo.setCharAt(i, '&');
-                            toAppendTo.insert(i + 1, "lt;");
-                            break;
-                        case '>':
-                            toAppendTo.setCharAt(i, '&');
-                            toAppendTo.insert(i + 1, "gt;");
-                            break;
-                        case '"':
-                            toAppendTo.setCharAt(i, '&');
-                            toAppendTo.insert(i + 1, "quot;");
-                            break;
-                        case '\'':
-                            toAppendTo.setCharAt(i, '&');
-                            toAppendTo.insert(i + 1, "apos;");
-                            break;
-                    }
-                }
+                StringBuilders.escapeXml(toAppendTo, start);
             }
         };
 
