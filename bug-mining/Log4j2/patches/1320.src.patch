diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/IdlePurgePolicy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/IdlePurgePolicy.java
index 65a0f455a5..0f75ec335c 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/IdlePurgePolicy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/IdlePurgePolicy.java
@@ -73,9 +73,10 @@ public class IdlePurgePolicy extends AbstractLifeCycle implements PurgePolicy, R
     public void purge() {
         final long createTime = System.currentTimeMillis() - timeToLive;
         for (final Entry<String, Long> entry : appendersUsage.entrySet()) {
-            if (entry.getValue() < createTime) {
-                LOGGER.debug("Removing appender {}", entry.getKey());
-                if (appendersUsage.remove(entry.getKey(), entry.getValue())) {
+            long entryValue = entry.getValue();
+            if (entryValue < createTime) {
+                if (appendersUsage.remove(entry.getKey(), entryValue)) {
+                    LOGGER.debug("Removing appender {}", entry.getKey());
                     routingAppender.deleteAppender(entry.getKey());
                 }
             }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/PurgePolicy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/PurgePolicy.java
index f780b15cfc..98af15451b 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/PurgePolicy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/PurgePolicy.java
@@ -24,13 +24,13 @@ import org.apache.logging.log4j.core.LogEvent;
 public interface PurgePolicy {
 
 	/**
-	 * Activates purging appenders
+	 * Activates purging appenders. Note that {@link PurgePolicy} implementations are responsible for invoking
+	 * this method themselves.
 	 */
 	void purge();
 
 	/**
-	 *
-	 * @param routed appender key
+	 * @param key routed appender key
 	 * @param event
 	 */
 	void update(String key, LogEvent event);
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/RoutingAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/RoutingAppender.java
index b70877c2a8..0ce202965f 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/RoutingAppender.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/routing/RoutingAppender.java
@@ -22,6 +22,7 @@ import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.script.Bindings;
 
@@ -134,10 +135,10 @@ public final class RoutingAppender extends AbstractAppender {
     private final Routes routes;
     private Route defaultRoute;
     private final Configuration configuration;
-    private final ConcurrentMap<String, AppenderControl> createdAppenders = new ConcurrentHashMap<>();
+    private final ConcurrentMap<String, CreatedRouteAppenderControl> createdAppenders = new ConcurrentHashMap<>();
     private final Map<String, AppenderControl> createdAppendersUnmodifiableView
             = Collections.unmodifiableMap(createdAppenders);
-    private final ConcurrentMap<String, AppenderControl> referencedAppenders = new ConcurrentHashMap<>();
+    private final ConcurrentMap<String, RouteAppenderControl> referencedAppenders = new ConcurrentHashMap<>();
     private final RewritePolicy rewritePolicy;
     private final PurgePolicy purgePolicy;
     private final AbstractScript defaultRouteScript;
@@ -191,7 +192,7 @@ public final class RoutingAppender extends AbstractAppender {
                 final Appender appender = configuration.getAppender(route.getAppenderRef());
                 if (appender != null) {
                     final String key = route == defaultRoute ? DEFAULT_KEY : route.getKey();
-                    referencedAppenders.put(key, new AppenderControl(appender, null, null));
+                    referencedAppenders.put(key, new ReferencedRouteAppenderControl(appender));
                 } else {
                     error("Appender " + route.getAppenderRef() + " cannot be located. Route ignored");
                 }
@@ -205,7 +206,7 @@ public final class RoutingAppender extends AbstractAppender {
         setStopping();
         super.stop(timeout, timeUnit, false);
         // Only stop appenders that were created by this RoutingAppender
-        for (final Map.Entry<String, AppenderControl> entry : createdAppenders.entrySet()) {
+        for (final Map.Entry<String, CreatedRouteAppenderControl> entry : createdAppenders.entrySet()) {
             final Appender appender = entry.getValue().getAppender();
             if (appender instanceof LifeCycle2) {
                 ((LifeCycle2) appender).stop(timeout, timeUnit);
@@ -224,11 +225,18 @@ public final class RoutingAppender extends AbstractAppender {
         }
         final String pattern = routes.getPattern(event, scriptStaticVariables);
         final String key = pattern != null ? configuration.getStrSubstitutor().replace(event, pattern) : defaultRoute.getKey();
-        final AppenderControl control = getControl(key, event);
+        final RouteAppenderControl control = getControl(key, event);
         if (control != null) {
-            control.callAppender(event);
+            try {
+                control.callAppender(event);
+            } finally {
+                control.release();
+            }
         }
+        updatePurgePolicy(key, event);
+    }
 
+    private void updatePurgePolicy(final String key, final LogEvent event) {
         if (purgePolicy != null
                 // LOG4J2-2631: PurgePolicy implementations do not need to be aware of appenders that
                 // were not created by this RoutingAppender.
@@ -237,9 +245,10 @@ public final class RoutingAppender extends AbstractAppender {
         }
     }
 
-    private synchronized AppenderControl getControl(final String key, final LogEvent event) {
-        AppenderControl control = getAppender(key);
+    private synchronized RouteAppenderControl getControl(final String key, final LogEvent event) {
+        RouteAppenderControl control = getAppender(key);
         if (control != null) {
+            control.checkout();
             return control;
         }
         Route route = null;
@@ -253,6 +262,7 @@ public final class RoutingAppender extends AbstractAppender {
             route = defaultRoute;
             control = getAppender(DEFAULT_KEY);
             if (control != null) {
+                control.checkout();
                 return control;
             }
         }
@@ -261,15 +271,19 @@ public final class RoutingAppender extends AbstractAppender {
             if (app == null) {
                 return null;
             }
-            control = new AppenderControl(app, null, null);
-            createdAppenders.put(key, control);
+            CreatedRouteAppenderControl created = new CreatedRouteAppenderControl(app);
+            control = created;
+            createdAppenders.put(key, created);
         }
 
+        if (control != null) {
+            control.checkout();
+        }
         return control;
     }
 
-    private AppenderControl getAppender(final String key) {
-        final AppenderControl result = referencedAppenders.get(key);
+    private RouteAppenderControl getAppender(final String key) {
+        final RouteAppenderControl result = referencedAppenders.get(key);
         if (result == null) {
             return createdAppenders.get(key);
         }
@@ -311,10 +325,17 @@ public final class RoutingAppender extends AbstractAppender {
     public void deleteAppender(final String key) {
         LOGGER.debug("Deleting route with {} key ", key);
         // LOG4J2-2631: Only appenders created by this RoutingAppender are eligible for deletion.
-        final AppenderControl control = createdAppenders.remove(key);
+        final CreatedRouteAppenderControl control = createdAppenders.remove(key);
         if (null != control) {
             LOGGER.debug("Stopping route with {} key", key);
-            control.getAppender().stop();
+            // Synchronize with getControl to avoid triggering stopAppender before RouteAppenderControl.checkout
+            // can be invoked.
+            synchronized (this) {
+                control.pendingDeletion = true;
+            }
+            // Don't attempt to stop the appender in a synchronized block, since it may block flushing events
+            // to disk.
+            control.tryStopAppender();
         } else {
             if (referencedAppenders.containsKey(key)) {
                 LOGGER.debug("Route {} using an appender reference may not be removed because " +
@@ -386,4 +407,82 @@ public final class RoutingAppender extends AbstractAppender {
     public ConcurrentMap<Object, Object> getScriptStaticVariables() {
         return scriptStaticVariables;
     }
+
+    /**
+     * LOG4J2-2629: PurgePolicy implementations can invoke {@link #deleteAppender(String)} after we have looked up
+     * an instance of a target appender but before events are appended, which could result in events not being
+     * recorded to any appender.
+     * This extension of {@link AppenderControl} allows to to mark usage of an appender, allowing deferral of
+     * {@link Appender#stop()} until events have successfully been recorded.
+     * Alternative approaches considered:
+     * - More aggressive synchronization: Appenders may do expensive I/O that shouldn't block routing.
+     * - Move the 'updatePurgePolicy' invocation before appenders are called: Unfortunately this approach doesn't work
+     *   if we consider an ImmediatePurgePolicy (or IdlePurgePolicy with a very small timeout) because it may attempt
+     *   to remove an appender that doesn't exist yet. It's counterintuitive to get an event that a route has been
+     *   used at a point when we expect the route doesn't exist in {@link #getAppenders()}.
+     */
+    private static abstract class RouteAppenderControl extends AppenderControl {
+
+        RouteAppenderControl(Appender appender) {
+            super(appender, null, null);
+        }
+
+        abstract void checkout();
+
+        abstract void release();
+    }
+
+    private static final class CreatedRouteAppenderControl extends RouteAppenderControl {
+
+        private volatile boolean pendingDeletion = false;
+        private final AtomicInteger depth = new AtomicInteger();
+
+        CreatedRouteAppenderControl(Appender appender) {
+            super(appender);
+        }
+
+        @Override
+        void checkout() {
+            if (pendingDeletion) {
+                LOGGER.warn("CreatedRouteAppenderControl.checkout invoked on a " +
+                        "RouteAppenderControl that is pending deletion");
+            }
+            depth.incrementAndGet();
+        }
+
+        @Override
+        void release() {
+            depth.decrementAndGet();
+            tryStopAppender();
+        }
+
+        void tryStopAppender() {
+            if (pendingDeletion
+                    // Only attempt to stop the appender if we can CaS the depth away from zero, otherwise either
+                    // 1. Another invocation of tryStopAppender has succeeded, or
+                    // 2. Events are being appended, and will trigger stop when they complete
+                    && depth.compareAndSet(0, -100_000)) {
+                Appender appender = getAppender();
+                LOGGER.debug("Stopping appender {}", appender);
+                appender.stop();
+            }
+        }
+    }
+
+    private static final class ReferencedRouteAppenderControl extends RouteAppenderControl {
+
+        ReferencedRouteAppenderControl(Appender appender) {
+            super(appender);
+        }
+
+        @Override
+        void checkout() {
+            // nop
+        }
+
+        @Override
+        void release() {
+            // nop
+        }
+    }
 }
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index e058176e52..f45e2fa0a3 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -96,6 +96,10 @@
         only those that have been created by the RoutingAppender. Note that RoutingAppender.getAppenders no longer
         includes entries for referenced appenders, only those which it has created.
       </action>
+      <action issue="LOG4J2-2629" dev="ckozak" type="fix">
+        Fix a race allowing events not to be recorded when a RoutingAppender purge policy attempts to delete an idle
+        appender at exactly the same time as a new event is recorded.
+      </action>
     </release>
     <release version="2.11.2" date="2019-02-04" description="GA Release 2.11.2">
       <action issue="LOG4J2-2500" dev="rgoers" type="fix">
