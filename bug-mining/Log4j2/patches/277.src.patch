diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java
index 2d7a08cf94..57de6bccd6 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java
@@ -112,12 +112,14 @@ public final class AsyncAppender extends AbstractAppender {
     @Override
     public void stop() {
         super.stop();
+        LOGGER.trace("AsyncAppender stopping. Queue still has {} events.", queue.size());
         thread.shutdown();
         try {
             thread.join();
         } catch (final InterruptedException ex) {
             LOGGER.warn("Interrupted while stopping AsyncAppender {}", getName());
         }
+        LOGGER.trace("AsyncAppender stopped. Queue has {} events.", queue.size());
     }
 
     /**
@@ -246,18 +248,29 @@ public final class AsyncAppender extends AbstractAppender {
                 }
             }
             // Process any remaining items in the queue.
+            LOGGER.trace("AsyncAppender.AsyncThread shutting down. Processing remaining {} queue events.",
+                    queue.size());
+            int count= 0;
+            int ignored = 0;
             while (!queue.isEmpty()) {
                 try {
                     final Serializable s = queue.take();
-                    if (s instanceof Log4jLogEvent) {
+                    if (Log4jLogEvent.canDeserialize(s)) {
                         final Log4jLogEvent event = Log4jLogEvent.deserialize(s);
                         event.setEndOfBatch(queue.isEmpty());
                         callAppenders(event);
+                        count++;
+                    } else {
+                        ignored++;
+                        LOGGER.trace("Ignoring event of class {}", s.getClass().getName());
                     }
                 } catch (final InterruptedException ex) {
                     // May have been interrupted to shut down.
                 }
             }
+            LOGGER.trace("AsyncAppender.AsyncThread stopped. Queue has {} events remaining. " +
+            		"Processed {} and ignored {} events since shutdown started.", 
+            		queue.size(), count, ignored);
         }
 
         /**
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java
index a29be386d3..c9acd9cb02 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/AbstractConfiguration.java
@@ -169,7 +169,8 @@ public abstract class AbstractConfiguration extends AbstractFilterable implement
      */
     @Override
     public void stop() {
-
+        LOGGER.trace("AbstractConfiguration stopping...");
+        
         // LOG4J2-392 first stop AsyncLogger Disruptor thread
         final LoggerContextFactory factory = LogManager.getFactory();
         if (factory instanceof Log4jContextFactory) {
@@ -181,9 +182,11 @@ public abstract class AbstractConfiguration extends AbstractFilterable implement
                 //
                 // Uncomment the line below after LOG4J2-493 is fixed
                 //AsyncLogger.stop();
+                //LOGGER.trace("AbstractConfiguration stopped AsyncLogger disruptor.");
             }
         }
         // similarly, first stop AsyncLoggerConfig Disruptor thread(s)
+        int asyncLoggerConfigCount = 0;
         for (final LoggerConfig logger : loggers.values()) {
             if (logger instanceof AsyncLoggerConfig) {
                 // LOG4J2-520, LOG4J2-392:
@@ -192,31 +195,46 @@ public abstract class AbstractConfiguration extends AbstractFilterable implement
                 // shut down the disruptor and wait for all enqueued events to be processed.
                 // Only *after this* the appenders can be cleared or events will be lost.
                 logger.stopFilter();
+                asyncLoggerConfigCount++;
             }
         }
         if (root instanceof AsyncLoggerConfig) {
             root.stopFilter();
+            asyncLoggerConfigCount++;
         }
+        LOGGER.trace("AbstractConfiguration stopped {} AsyncLoggerConfigs.", asyncLoggerConfigCount);
 
         // Stop the appenders in reverse order in case they still have activity.
         final Appender[] array = appenders.values().toArray(new Appender[appenders.size()]);
 
         // LOG4J2-511, LOG4J2-392 stop AsyncAppenders first
+        int asyncAppenderCount = 0;
         for (int i = array.length - 1; i >= 0; --i) {
             if (array[i] instanceof AsyncAppender) {
                 array[i].stop();
+                asyncAppenderCount++;
             }
         }
+        LOGGER.trace("AbstractConfiguration stopped {} AsyncAppenders.", asyncAppenderCount);
+
+        int appenderCount = 0;
         for (int i = array.length - 1; i >= 0; --i) {
             if (array[i].isStarted()) { // then stop remaining Appenders
                 array[i].stop();
+                appenderCount++;
             }
         }
+        LOGGER.trace("AbstractConfiguration stopped {} Appenders.", appenderCount);
+
+        int loggerCount = 0;
         for (final LoggerConfig logger : loggers.values()) {
             // AsyncLoggerConfig objects may be stopped multiple times, that's okay...
             logger.clearAppenders();
             logger.stopFilter();
+            loggerCount++;
         }
+        LOGGER.trace("AbstractConfiguration stopped {} Loggers.", loggerCount);
+
         // If root is an AsyncLoggerConfig it may already be stopped. Stopping it twice is okay.
         root.stopFilter();
         stopFilter();
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/Log4jLogEvent.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/Log4jLogEvent.java
index 895ea6a89e..4534b96885 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/Log4jLogEvent.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/Log4jLogEvent.java
@@ -359,6 +359,10 @@ public class Log4jLogEvent implements LogEvent {
         return new LogEventProxy(event, includeLocation);
     }
 
+    public static boolean canDeserialize(final Serializable event) {
+        return event instanceof LogEventProxy;
+    }
+    
     public static Log4jLogEvent deserialize(final Serializable event) {
         if (event == null) {
             throw new NullPointerException("Event cannot be null");
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 49d56d6fb6..513c3dce65 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,8 +22,12 @@
   </properties>
   <body>
     <release version="2.0-rc2" date="2014-MM-DD" description="Bug fixes and enhancements">
+      <action issue="LOG4J2-520" dev="rpopma" type="fix" due-to="JavaTech, Andre Bogus">
+        Resolved issue where AsyncAppender dropped events if queue still contained
+        events when application is stopped.
+      </action>
       <action issue="LOG4J2-392" dev="rpopma" type="fix" due-to="Andre Bogus">
-        Resolved a problem with the previous solution that resulted in dropped events
+        Resolved a problem with the previous solution for LOG4J2-392 that resulted in dropped events
         when using AsyncLoggerConfig with slow appenders when application is stopped.
       </action>
       <action issue="LOG4J2-613" dev="mattsicker" type="fix">
