diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java b/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java
index 56af2166ba..c43a11d5f5 100644
--- a/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java
+++ b/log4j-api/src/main/java/org/apache/logging/log4j/MarkerManager.java
@@ -83,14 +83,24 @@ public final class MarkerManager {
         markerMap.putIfAbsent(name, new Log4jMarker(name));
         return markerMap.get(name).addParents(parent);
     }
+    
     /**
+     * <em>Consider this class private, it is only public to satisfy Jackson for XML and JSON IO.</em>
+     * <p>
      * The actual Marker implementation.
+     * </p>
+     * <p>
+     * <em>Internal note: We could make this class package private instead of public if the class 
+     * {@link org.apache.logging.log4j.core.jackson.MarkerMixIn} 
+     * is moved to this package and would of course stay in its current module.</em>
+     * </p>
      */
-    private static class Log4jMarker implements Marker {
+    public static class Log4jMarker implements Marker {
 
         private static final long serialVersionUID = 100L;
 
         private final String name;
+        
         private volatile Marker[] parents;
 
         /**
diff --git a/log4j-core/pom.xml b/log4j-core/pom.xml
index 317472bcef..b32d496c54 100644
--- a/log4j-core/pom.xml
+++ b/log4j-core/pom.xml
@@ -68,6 +68,18 @@
       <artifactId>jackson-dataformat-yaml</artifactId>
       <optional>true</optional>
     </dependency>
+    <!-- Required for XML layout and receiver support -->
+    <dependency>
+      <groupId>com.fasterxml.jackson.dataformat</groupId>
+      <artifactId>jackson-dataformat-xml</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.codehaus.woodstox</groupId>
+      <artifactId>woodstox-core-asl</artifactId>
+      <version>4.3.0</version>
+      <optional>true</optional>
+    </dependency>    
     <!-- Required for console color support in Windows -->
     <dependency>
       <groupId>org.fusesource.jansi</groupId>
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/LogEventListener.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/LogEventListener.java
index 5c2c0e007e..a910fd33f9 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/LogEventListener.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/LogEventListener.java
@@ -29,7 +29,7 @@ public class LogEventListener {
         context = (LoggerContext) LogManager.getContext(false);
     }
 
-    protected void log(final LogEvent event) {
+    public void log(final LogEvent event) {
         if (event == null) {
             return;
         }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ExtendedStackTraceElement.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ExtendedStackTraceElement.java
new file mode 100644
index 0000000000..c8af063f4b
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ExtendedStackTraceElement.java
@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.impl;
+
+import java.io.Serializable;
+
+import org.apache.logging.log4j.util.Strings;
+
+/**
+ * Wraps and extends the concept of the JRE's final class {@link StackTraceElement} by adding more location information.
+ * <p>
+ * Complements a StackTraceElement with:
+ * <ul>
+ * <li>exact: whether the class was obtained via {@link Reflection#getCallerClass()}</li>
+ * <li>location: a classpath element or a jar</li>
+ * <li>version</li>
+ * </ul>
+ * </p>
+ */
+public class ExtendedStackTraceElement implements Serializable {
+
+    private static final long serialVersionUID = -2171069569241280505L;
+
+    private final boolean exact;
+
+    private final String location;
+
+    private final StackTraceElement stackTraceElement;
+
+    private final String version;
+
+    /**
+     * Constructor that takes the location, version, and exact match flag.
+     * 
+     * @param stackTraceElement TODO
+     * @param exact if true this is an exact package element.
+     * @param location The location of the Class.
+     * @param version The version of the component.
+     */
+    public ExtendedStackTraceElement(final StackTraceElement stackTraceElement, final boolean exact, final String location,
+            final String version) {
+        this.stackTraceElement = stackTraceElement;
+        this.location = location;
+        this.version = version;
+        this.exact = exact;
+    }
+
+    public ExtendedStackTraceElement(final String declaringClass, final String methodName, final String fileName, final int lineNumber,
+            final boolean exact, final String location, final String version) {
+        this(new StackTraceElement(declaringClass, methodName, fileName, lineNumber), exact, location, version);
+    }
+
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!(obj instanceof ExtendedStackTraceElement)) {
+            return false;
+        }
+        final ExtendedStackTraceElement other = (ExtendedStackTraceElement) obj;
+        if (this.exact != other.exact) {
+            return false;
+        }
+        if (this.location == null) {
+            if (other.location != null) {
+                return false;
+            }
+        } else if (!this.location.equals(other.location)) {
+            return false;
+        }
+        if (this.stackTraceElement == null) {
+            if (other.stackTraceElement != null) {
+                return false;
+            }
+        } else if (!this.stackTraceElement.equals(other.stackTraceElement)) {
+            return false;
+        }
+        if (this.version == null) {
+            if (other.version != null) {
+                return false;
+            }
+        } else if (!this.version.equals(other.version)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Returns the indicator of whether this is an exact match.
+     * 
+     * @return true if the location was determined exactly.
+     */
+    public boolean getExact() {
+        return this.exact;
+    }
+
+    /**
+     * Returns the location of the element.
+     * 
+     * @return The location of the element.
+     */
+    public String getLocation() {
+        return this.location;
+    }
+
+    public StackTraceElement getStackTraceElement() {
+        return this.stackTraceElement;
+    }
+
+    /**
+     * Returns the version of the element.
+     * 
+     * @return the version of the element.
+     */
+    public String getVersion() {
+        return this.version;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (this.exact ? 1231 : 1237);
+        result = prime * result + (this.location == null ? 0 : this.location.hashCode());
+        result = prime * result + (this.version == null ? 0 : this.version.hashCode());
+        result = prime * result + (this.stackTraceElement == null ? 0 : this.stackTraceElement.hashCode());
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        final String exactStr = this.exact ? Strings.EMPTY : "~";
+        return exactStr + '[' + this.location + ':' + this.version + ']';
+    }
+
+    public String getFileName() {
+        return this.stackTraceElement.getFileName();
+    }
+
+    public int getLineNumber() {
+        return this.stackTraceElement.getLineNumber();
+    }
+
+    public String getClassName() {
+        return this.stackTraceElement.getClassName();
+    }
+
+    public String getMethodName() {
+        return this.stackTraceElement.getMethodName();
+    }
+
+    public boolean isNativeMethod() {
+        return this.stackTraceElement.isNativeMethod();
+    }
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/StackTracePackageElement.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/StackTracePackageElement.java
deleted file mode 100644
index 0974b4a550..0000000000
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/StackTracePackageElement.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache license, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the license for the specific language governing permissions and
- * limitations under the license.
- */
-package org.apache.logging.log4j.core.impl;
-
-import java.io.Serializable;
-
-/**
- * Package data for a StackTraceElement.
- */
-public class StackTracePackageElement implements Serializable {
-
-    private static final long serialVersionUID = -2171069569241280505L;
-
-    private final boolean exact;
-
-    private final String location;
-
-    private final String version;
-
-    /**
-     * Constructor that takes the location, version, and exact match flag.
-     * 
-     * @param location The location of the Class.
-     * @param version The version of the component.
-     * @param exact if true this is an exact package element.
-     */
-    public StackTracePackageElement(final String location, final String version, final boolean exact) {
-        this.location = location;
-        this.version = version;
-        this.exact = exact;
-    }
-
-@Override
-public boolean equals(Object obj) {
-    if (this == obj) {
-        return true;
-    }
-    if (obj == null) {
-        return false;
-    }
-    if (getClass() != obj.getClass()) {
-        return false;
-    }
-    StackTracePackageElement other = (StackTracePackageElement) obj;
-    if (this.exact != other.exact) {
-        return false;
-    }
-    if (this.location == null) {
-        if (other.location != null) {
-            return false;
-        }
-    } else if (!this.location.equals(other.location)) {
-        return false;
-    }
-    if (this.version == null) {
-        if (other.version != null) {
-            return false;
-        }
-    } else if (!this.version.equals(other.version)) {
-        return false;
-    }
-    return true;
-}
-
-    /**
-     * Returns the indicator of whether this is an exact match.
-     * 
-     * @return true if the location was determined exactly.
-     */
-    public boolean getExact() {
-        return exact;
-    }
-
-    /**
-     * Returns the location of the element.
-     * 
-     * @return The location of the element.
-     */
-    public String getLocation() {
-        return location;
-    }
-
-    /**
-     * Returns the version of the element.
-     * 
-     * @return the version of the element.
-     */
-    public String getVersion() {
-        return version;
-    }
-
-    @Override
-public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + (this.exact ? 1231 : 1237);
-    result = prime * result + ((this.location == null) ? 0 : this.location.hashCode());
-    result = prime * result + ((this.version == null) ? 0 : this.version.hashCode());
-    return result;
-}
-
-    @Override
-    public String toString() {
-        final String exactStr = exact ? "" : "~";
-        return exactStr + '[' + location + ':' + version + ']';
-    }
-}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java
index d288c903d7..f5eb01ab88 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java
@@ -17,9 +17,9 @@
 package org.apache.logging.log4j.core.impl;
 
 import java.io.Serializable;
-import java.lang.reflect.Method;
 import java.net.URL;
 import java.security.CodeSource;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -27,43 +27,58 @@ import java.util.Stack;
 
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.core.helpers.Loader;
+import org.apache.logging.log4j.core.helpers.Throwables;
 import org.apache.logging.log4j.status.StatusLogger;
+import org.apache.logging.log4j.util.Strings;
 
 /**
  * Wraps a Throwable to add packaging information about each stack trace element.
+ * 
  * <p>
- * A proxy is used to represent a throwable that may not exist in a different class loader or JVM. When an application
- * deserializes a ThrowableProxy, the throwable will not be set, but the throwable's information is preserved in other
- * fields of the proxy.
+ * A proxy is used to represent a throwable that may not exist in a different class loader or JVM. When an application deserializes a
+ * ThrowableProxy, the throwable may not be set, but the throwable's information is preserved in other fields of the proxy like the message
+ * and stack trace.
  * </p>
+ * 
+ * TODO: Move this class to org.apache.logging.log4j.core because it is used from LogEvent.
+ * TODO: Deserialize: Try to rebuild Throwable if the target exception is in this class loader?
  */
 public class ThrowableProxy implements Serializable {
 
-    private static final char EOL = '\n';
-
-    private static final long serialVersionUID = -2752771578252251910L;
-
-    private static final Logger LOGGER = StatusLogger.getLogger();
-
-    private static final PrivateSecurityManager SECURITY_MANAGER;
-
-    private static final Method GET_SUPPRESSED;
+    /**
+     * Cached StackTracePackageElement and ClassLoader.
+     * <p>
+     * Consider this class private.
+     * </p>
+     */
+    class CacheEntry {
+        private final ExtendedStackTraceElement element;
+        private final ClassLoader loader;
 
-    private static final Method ADD_SUPPRESSED;
+        public CacheEntry(final ExtendedStackTraceElement element, final ClassLoader loader) {
+            this.element = element;
+            this.loader = loader;
+        }
+    }
 
-    private final ThrowableProxy causeProxy;
+    /**
+     * Security Manager for accessing the call stack.
+     */
+    private static class PrivateSecurityManager extends SecurityManager {
+        public Class<?>[] getClasses() {
+            return this.getClassContext();
+        }
+    }
 
-    private final transient Throwable throwable;
+    private static final ThrowableProxy[] EMPTY_THROWABLE_PROXY_ARRAY = new ThrowableProxy[0];
 
-    private final String message;
-    
-    private final String localizedMessage;
+    private static final char EOL = '\n';
 
-    private final String name;
+    private static final Logger LOGGER = StatusLogger.getLogger();
 
-    private final StackTracePackageElement[] stackTracePackages;
+    private static final PrivateSecurityManager SECURITY_MANAGER;
 
-    private int commonElementCount;
+    private static final long serialVersionUID = -2752771578252251910L;
 
     static {
         if (ReflectiveCallerClassUtility.isSupported()) {
@@ -83,20 +98,24 @@ public class ThrowableProxy implements Serializable {
             }
             SECURITY_MANAGER = securityManager;
         }
-
-        Method getSuppressed = null, addSuppressed = null;
-        final Method[] methods = Throwable.class.getMethods();
-        for (final Method method : methods) {
-            if (method.getName().equals("getSuppressed")) {
-                getSuppressed = method;
-            } else if (method.getName().equals("addSuppressed")) {
-                addSuppressed = method;
-            }
-        }
-        GET_SUPPRESSED = getSuppressed;
-        ADD_SUPPRESSED = addSuppressed;
     }
 
+    private final ThrowableProxy causeProxy;
+
+    private int commonElementCount;
+
+    private final ExtendedStackTraceElement[] extendedStackTrace;
+
+    private final String localizedMessage;
+
+    private final String message;
+
+    private final String name;
+
+    private final ThrowableProxy[] suppressedProxies;
+
+    private final transient Throwable throwable;
+    
     /**
      * For JSON and XML IO via Jackson.
      */
@@ -104,15 +123,17 @@ public class ThrowableProxy implements Serializable {
     private ThrowableProxy() {
         this.throwable = null;
         this.name = null;
-        this.stackTracePackages = null;
+        this.extendedStackTrace = null;
         this.causeProxy = null;
         this.message = null;
         this.localizedMessage = null;
+        this.suppressedProxies = EMPTY_THROWABLE_PROXY_ARRAY;
     }
 
     /**
-     * Construct the wrapper for the Throwable that includes packaging data.
-     * @param throwable The Throwable to wrap.
+     * Constructs the wrapper for the Throwable that includes packaging data.
+     * 
+     * @param throwable The Throwable to wrap, must not be null.
      */
     public ThrowableProxy(final Throwable throwable) {
         this.throwable = throwable;
@@ -120,228 +141,316 @@ public class ThrowableProxy implements Serializable {
         this.message = throwable.getMessage();
         this.localizedMessage = throwable.getLocalizedMessage();
         final Map<String, CacheEntry> map = new HashMap<String, CacheEntry>();
-        final Stack<Class<?>> stack = getCurrentStack();
-        stackTracePackages = resolvePackageData(stack, map, null, throwable.getStackTrace());
-        this.causeProxy = throwable.getCause() == null ? null :
-            new ThrowableProxy(throwable, stack, map, throwable.getCause());
-        setSuppressed(throwable);
+        final Stack<Class<?>> stack = this.getCurrentStack();
+        this.extendedStackTrace = this.toExtendedStackTrace(stack, map, null, throwable.getStackTrace());
+        final Throwable throwableCause = throwable.getCause();
+        this.causeProxy = throwableCause == null ? null : new ThrowableProxy(throwable, stack, map, throwableCause);
+        this.suppressedProxies = this.toSuppressedProxies(throwable);
     }
 
     /**
-     * Constructs the wrapper for a Throwable that is referenced as the cause by another
-     * Throwable.
+     * Constructs the wrapper for a Throwable that is referenced as the cause by another Throwable.
+     * 
      * @param parent The Throwable referencing this Throwable.
      * @param stack The Class stack.
      * @param map The cache containing the packaging data.
      * @param cause The Throwable to wrap.
      */
-    private ThrowableProxy(final Throwable parent, final Stack<Class<?>> stack, final Map<String, CacheEntry> map,
-                           final Throwable cause) {
+    private ThrowableProxy(final Throwable parent, final Stack<Class<?>> stack, final Map<String, CacheEntry> map, final Throwable cause) {
         this.throwable = cause;
         this.name = cause.getClass().getName();
-        this.message = throwable.getMessage();
-        this.localizedMessage = throwable.getLocalizedMessage();
-        stackTracePackages = resolvePackageData(stack, map, parent.getStackTrace(), cause.getStackTrace());
-        this.causeProxy = cause.getCause() == null ? null :
-            new ThrowableProxy(parent, stack, map, cause.getCause());
-        setSuppressed(cause);
+        this.message = this.throwable.getMessage();
+        this.localizedMessage = this.throwable.getLocalizedMessage();
+        this.extendedStackTrace = this.toExtendedStackTrace(stack, map, parent.getStackTrace(), cause.getStackTrace());
+        this.causeProxy = cause.getCause() == null ? null : new ThrowableProxy(parent, stack, map, cause.getCause());
+        this.suppressedProxies = this.toSuppressedProxies(cause);
     }
 
-    public Throwable getThrowable() {
-        return throwable;
-    }
-
-    public ThrowableProxy getCauseProxy() {
-        return causeProxy;
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (this.getClass() != obj.getClass()) {
+            return false;
+        }
+        final ThrowableProxy other = (ThrowableProxy) obj;
+        if (this.causeProxy == null) {
+            if (other.causeProxy != null) {
+                return false;
+            }
+        } else if (!this.causeProxy.equals(other.causeProxy)) {
+            return false;
+        }
+        if (this.commonElementCount != other.commonElementCount) {
+            return false;
+        }
+        if (this.name == null) {
+            if (other.name != null) {
+                return false;
+            }
+        } else if (!this.name.equals(other.name)) {
+            return false;
+        }
+        if (!Arrays.equals(this.extendedStackTrace, other.extendedStackTrace)) {
+            return false;
+        }
+        if (!Arrays.equals(this.suppressedProxies, other.suppressedProxies)) {
+            return false;
+        }
+        return true;
     }
 
-    public String getMessage() {
-        return message;
+    @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
+    private void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> packages) {
+        sb.append("Caused by: ").append(cause).append(EOL);
+        this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, packages);
+        if (cause.getCauseProxy() != null) {
+            this.formatCause(sb, cause.causeProxy, packages);
+        }
     }
 
-    public String getLocalizedMessage() {
-        return localizedMessage;
+    private void formatElements(final StringBuilder sb, final int commonCount, final StackTraceElement[] causedTrace,
+            final ExtendedStackTraceElement[] packageData, final List<String> packages) {
+        if (packages == null || packages.size() == 0) {
+            for (int i = 0; i < packageData.length; ++i) {
+                this.formatEntry(causedTrace[i], packageData[i], sb);
+            }
+        } else {
+            int count = 0;
+            for (int i = 0; i < packageData.length; ++i) {
+                if (!this.isSuppressed(causedTrace[i], packages)) {
+                    if (count > 0) {
+                        if (count == 1) {
+                            sb.append("\t....\n");
+                        } else {
+                            sb.append("\t... suppressed ").append(count).append(" lines\n");
+                        }
+                        count = 0;
+                    }
+                    this.formatEntry(causedTrace[i], packageData[i], sb);
+                } else {
+                    ++count;
+                }
+            }
+            if (count > 0) {
+                if (count == 1) {
+                    sb.append("\t...\n");
+                } else {
+                    sb.append("\t... suppressed ").append(count).append(" lines\n");
+                }
+            }
+        }
+        if (commonCount != 0) {
+            sb.append("\t... ").append(commonCount).append(" more").append('\n');
+        }
     }
 
-    /**
-     * Return the FQCN of the Throwable.
-     * @return The FQCN of the Throwable.
-     */
-    public String getName() {
-        return name;
+    private void formatEntry(final StackTraceElement element, final ExtendedStackTraceElement packageData, final StringBuilder sb) {
+        sb.append("\tat ");
+        sb.append(element);
+        sb.append(' ');
+        sb.append(packageData);
+        sb.append('\n');
     }
 
     /**
-     * Return the number of elements that are being ommitted because they are common with the parent Throwable's
-     * stack trace.
-     * @return The number of elements ommitted from the stack trace.
+     * Formats the specified Throwable.
+     * 
+     * @param sb StringBuilder to contain the formatted Throwable.
+     * @param cause The Throwable to format.
      */
-    public int getCommonElementCount() {
-        return commonElementCount;
+    public void formatWrapper(final StringBuilder sb, final ThrowableProxy cause) {
+        this.formatWrapper(sb, cause, null);
     }
 
     /**
-     * Return the package data associated with the stack trace.
-     * @return The package data associated with the stack trace.
+     * Formats the specified Throwable.
+     * 
+     * @param sb StringBuilder to contain the formatted Throwable.
+     * @param cause The Throwable to format.
+     * @param packages The List of packages to be suppressed from the trace.
      */
-    public StackTracePackageElement[] getStackTracePackages() {
-        return stackTracePackages;
+    @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
+    public void formatWrapper(final StringBuilder sb, final ThrowableProxy cause, final List<String> packages) {
+        final Throwable caused = cause.getCauseProxy() != null ? cause.getCauseProxy().getThrowable() : null;
+        if (caused != null) {
+            this.formatWrapper(sb, cause.causeProxy);
+            sb.append("Wrapped by: ");
+        }
+        sb.append(cause).append('\n');
+        this.formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.extendedStackTrace, packages);
     }
 
-    @Override
-    public String toString() {
-        final String msg = this.message;
-        return msg != null ? name + ": " + msg : name;
+    public ThrowableProxy getCauseProxy() {
+        return this.causeProxy;
     }
 
     /**
      * Format the Throwable that is the cause of this Throwable.
+     * 
      * @return The formatted Throwable that caused this Throwable.
      */
-    public String getRootCauseStackTrace() {
-        return getRootCauseStackTrace(null);
+    public String getCauseStackTraceAsString() {
+        return this.getCauseStackTraceAsString(null);
     }
 
     /**
      * Format the Throwable that is the cause of this Throwable.
+     * 
      * @param packages The List of packages to be suppressed from the trace.
      * @return The formatted Throwable that caused this Throwable.
      */
-    public String getRootCauseStackTrace(final List<String> packages) {
+    public String getCauseStackTraceAsString(final List<String> packages) {
         final StringBuilder sb = new StringBuilder();
-        if (causeProxy != null) {
-            formatWrapper(sb, causeProxy);
+        if (this.causeProxy != null) {
+            this.formatWrapper(sb, this.causeProxy);
             sb.append("Wrapped by: ");
         }
-        sb.append(toString());
-        sb.append(EOL);
-        formatElements(sb, 0, throwable.getStackTrace(), stackTracePackages, packages);
+        sb.append(this.toString());
+        sb.append('\n');
+        this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, packages);
         return sb.toString();
     }
 
     /**
-     * Formats the specified Throwable.
-     * @param sb StringBuilder to contain the formatted Throwable.
-     * @param cause The Throwable to format.
+     * Return the number of elements that are being omitted because they are common with the parent Throwable's stack trace.
+     * 
+     * @return The number of elements omitted from the stack trace.
      */
-    public void formatWrapper(final StringBuilder sb, final ThrowableProxy cause) {
-        formatWrapper(sb, cause, null);
+    public int getCommonElementCount() {
+        return this.commonElementCount;
     }
 
     /**
-     * Formats the specified Throwable.
-     * @param sb StringBuilder to contain the formatted Throwable.
-     * @param cause The Throwable to format.
-     * @param packages The List of packages to be suppressed from the trace.
+     * Initialize the cache by resolving everything in the current stack trace via Reflection.getCallerClass or via the SecurityManager if
+     * either are available. These are the only Classes that can be trusted to be accurate.
+     * 
+     * @return A Stack containing the current stack of Class objects.
      */
-    @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-    public void formatWrapper(final StringBuilder sb, final ThrowableProxy cause, final List<String> packages) {
-        final Throwable caused = cause.getCauseProxy() != null ? cause.getCauseProxy().getThrowable() : null;
-        if (caused != null) {
-            formatWrapper(sb, cause.causeProxy);
-            sb.append("Wrapped by: ");
+    private Stack<Class<?>> getCurrentStack() {
+        if (ReflectiveCallerClassUtility.isSupported()) {
+            final Stack<Class<?>> classes = new Stack<Class<?>>();
+            int index = 1;
+            Class<?> clazz = ReflectiveCallerClassUtility.getCaller(index);
+            while (clazz != null) {
+                classes.push(clazz);
+                clazz = ReflectiveCallerClassUtility.getCaller(++index);
+            }
+            return classes;
+        } else if (SECURITY_MANAGER != null) {
+            final Class<?>[] array = SECURITY_MANAGER.getClasses();
+            final Stack<Class<?>> classes = new Stack<Class<?>>();
+            for (final Class<?> clazz : array) {
+                classes.push(clazz);
+            }
+            return classes;
         }
-        sb.append(cause).append(EOL);
-        formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.stackTracePackages,
-            packages);
+        return new Stack<Class<?>>();
+    }
+
+    /**
+     * Gets the stack trace including packaging information.
+     * 
+     * @return The stack trace including packaging information.
+     */
+    public ExtendedStackTraceElement[] getExtendedStackTrace() {
+        return this.extendedStackTrace;
     }
 
     /**
      * Format the stack trace including packaging information.
+     * 
      * @return The formatted stack trace including packaging information.
      */
-    public String getExtendedStackTrace() {
-        return getExtendedStackTrace(null);
+    public String getExtendedStackTraceAsString() {
+        return this.getExtendedStackTraceAsString(null);
     }
 
     /**
      * Format the stack trace including packaging information.
+     * 
      * @param packages List of packages to be suppressed from the trace.
      * @return The formatted stack trace including packaging information.
      */
-    public String getExtendedStackTrace(final List<String> packages) {
-        final StringBuilder sb = new StringBuilder(name);
-        final String msg = throwable.getMessage();
+    public String getExtendedStackTraceAsString(final List<String> packages) {
+        final StringBuilder sb = new StringBuilder(this.name);
+        final String msg = this.message;
         if (msg != null) {
-            sb.append(": ").append(throwable.getMessage());
+            sb.append(": ").append(msg);
         }
-        sb.append(EOL);
-        formatElements(sb, 0, throwable.getStackTrace(), stackTracePackages, packages);
-        if (causeProxy != null) {
-            formatCause(sb, causeProxy, packages);
+        sb.append('\n');
+        this.formatElements(sb, 0, this.throwable.getStackTrace(), this.extendedStackTrace, packages);
+        if (this.causeProxy != null) {
+            this.formatCause(sb, this.causeProxy, packages);
         }
         return sb.toString();
     }
 
+    public String getLocalizedMessage() {
+        return this.localizedMessage;
+    }
+
+    public String getMessage() {
+        return this.message;
+    }
+
+    /**
+     * Return the FQCN of the Throwable.
+     * 
+     * @return The FQCN of the Throwable.
+     */
+    public String getName() {
+        return this.name;
+    }
+
+    public StackTraceElement[] getStackTrace() {
+        return this.throwable == null ? null : this.throwable.getStackTrace();
+    }
+
+    /**
+     * Gets proxies for suppressed exceptions.
+     * 
+     * @return proxies for suppressed exceptions.
+     */
+    public ThrowableProxy[] getSuppressedProxies() {
+        return this.suppressedProxies;
+    }
+
     /**
      * Format the suppressed Throwables.
+     * 
      * @return The formatted suppressed Throwables.
      */
     public String getSuppressedStackTrace() {
-        final ThrowableProxy[] suppressed = getSuppressed();
+        final ThrowableProxy[] suppressed = this.getSuppressedProxies();
         if (suppressed == null || suppressed.length == 0) {
-            return "";
+            return Strings.EMPTY;
         }
         final StringBuilder sb = new StringBuilder("Suppressed Stack Trace Elements:\n");
         for (final ThrowableProxy proxy : suppressed) {
-            sb.append(proxy.getExtendedStackTrace());
+            sb.append(proxy.getExtendedStackTraceAsString());
         }
         return sb.toString();
     }
 
-    @SuppressWarnings("ThrowableResultOfMethodCallIgnored")
-    private void formatCause(final StringBuilder sb, final ThrowableProxy cause, final List<String> packages) {
-        sb.append("Caused by: ").append(cause).append(EOL);
-        formatElements(sb, cause.commonElementCount, cause.getThrowable().getStackTrace(), cause.stackTracePackages,
-            packages);
-        if (cause.getCauseProxy() != null) {
-            formatCause(sb, cause.causeProxy, packages);
-        }
-    }
-
-    private void formatElements(final StringBuilder sb, final int commonCount, final StackTraceElement[] causedTrace,
-                                final StackTracePackageElement[] packageData, final List<String> packages) {
-        if (packages == null || packages.size() == 0) {
-            for (int i = 0; i < packageData.length; ++i) {
-                formatEntry(causedTrace[i], packageData[i], sb);
-            }
-        } else {
-            int count = 0;
-            for (int i = 0; i < packageData.length; ++i) {
-                if (!isSuppressed(causedTrace[i], packages)) {
-                    if (count > 0) {
-                        if (count == 1) {
-                            sb.append("\t....\n");
-                        } else {
-                            sb.append("\t... suppressed ").append(count).append(" lines\n");
-                        }
-                        count = 0;
-                    }
-                    formatEntry(causedTrace[i], packageData[i], sb);
-                } else {
-                    ++count;
-                }
-            }
-            if (count > 0) {
-                if (count == 1) {
-                    sb.append("\t...\n");
-                } else {
-                    sb.append("\t... suppressed ").append(count).append(" lines\n");
-                }
-            }
-        }
-        if (commonCount != 0) {
-            sb.append("\t... ").append(commonCount).append(" more").append(EOL);
-        }
+    public Throwable getThrowable() {
+        return this.throwable;
     }
 
-    private void formatEntry(final StackTraceElement element, final StackTracePackageElement packageData,
-                             final StringBuilder sb) {
-        sb.append("\tat ");
-        sb.append(element);
-        sb.append(' ');
-        sb.append(packageData);
-        sb.append(EOL);
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (this.causeProxy == null ? 0 : this.causeProxy.hashCode());
+        result = prime * result + this.commonElementCount;
+        result = prime * result + (this.extendedStackTrace == null ? 0 : Arrays.hashCode(this.extendedStackTrace));
+        result = prime * result + (this.suppressedProxies == null ? 0 : Arrays.hashCode(this.suppressedProxies));
+        result = prime * result + (this.name == null ? 0 : this.name.hashCode());
+        return result;
     }
 
     private boolean isSuppressed(final StackTraceElement element, final List<String> packages) {
@@ -355,44 +464,92 @@ public class ThrowableProxy implements Serializable {
     }
 
     /**
-     * Initialize the cache by resolving everything in the current stack trace via Reflection.getCallerClass
-     * or via the SecurityManager if either are available. These are the only Classes that can be trusted
-     * to be accurate.
-     * @return A Deque containing the current stack of Class objects.
+     * Loads classes not located via Reflection.getCallerClass.
+     * 
+     * @param lastLoader The ClassLoader that loaded the Class that called this Class.
+     * @param className The name of the Class.
+     * @return The Class object for the Class or null if it could not be located.
      */
-    private Stack<Class<?>> getCurrentStack() {
-        if (ReflectiveCallerClassUtility.isSupported()) {
-            final Stack<Class<?>> classes = new Stack<Class<?>>();
-            int index = 1;
-            Class<?> clazz = ReflectiveCallerClassUtility.getCaller(index);
-            while (clazz != null) {
-                classes.push(clazz);
-                clazz = ReflectiveCallerClassUtility.getCaller(++index);
+    private Class<?> loadClass(final ClassLoader lastLoader, final String className) {
+        // XXX: this is overly complicated
+        Class<?> clazz;
+        if (lastLoader != null) {
+            try {
+                clazz = Loader.initializeClass(className, lastLoader);
+                if (clazz != null) {
+                    return clazz;
+                }
+            } catch (final Exception ignore) {
+                // Ignore exception.
             }
-            return classes;
-        } else if (SECURITY_MANAGER != null) {
-            final Class<?>[] array = SECURITY_MANAGER.getClasses();
-            final Stack<Class<?>> classes = new Stack<Class<?>>();
-            for (final Class<?> clazz : array) {
-                classes.push(clazz);
+        }
+        try {
+            clazz = Loader.loadClass(className);
+        } catch (final ClassNotFoundException ignored) {
+            try {
+                clazz = Loader.initializeClass(className, this.getClass().getClassLoader());
+            } catch (final ClassNotFoundException ignore) {
+                return null;
             }
-            return classes;
         }
-        return new Stack<Class<?>>();
+        return clazz;
+    }
+
+    /**
+     * Construct the CacheEntry from the Class's information.
+     * 
+     * @param stackTraceElement The stack trace element
+     * @param callerClass The Class.
+     * @param exact True if the class was obtained via Reflection.getCallerClass.
+     * 
+     * @return The CacheEntry.
+     */
+    private CacheEntry resolvePackageElement(final StackTraceElement stackTraceElement, final Class<?> callerClass, final boolean exact) {
+        String location = "?";
+        String version = "?";
+        ClassLoader lastLoader = null;
+        if (callerClass != null) {
+            try {
+                final CodeSource source = callerClass.getProtectionDomain().getCodeSource();
+                if (source != null) {
+                    final URL locationURL = source.getLocation();
+                    if (locationURL != null) {
+                        final String str = locationURL.toString().replace('\\', '/');
+                        int index = str.lastIndexOf("/");
+                        if (index >= 0 && index == str.length() - 1) {
+                            index = str.lastIndexOf("/", index - 1);
+                            location = str.substring(index + 1);
+                        } else {
+                            location = str.substring(index + 1);
+                        }
+                    }
+                }
+            } catch (final Exception ex) {
+                // Ignore the exception.
+            }
+            final Package pkg = callerClass.getPackage();
+            if (pkg != null) {
+                final String ver = pkg.getImplementationVersion();
+                if (ver != null) {
+                    version = ver;
+                }
+            }
+            lastLoader = callerClass.getClassLoader();
+        }
+        return new CacheEntry(new ExtendedStackTraceElement(stackTraceElement, exact, location, version), lastLoader);
     }
 
     /**
      * Resolve all the stack entries in this stack trace that are not common with the parent.
+     * 
      * @param stack The callers Class stack.
      * @param map The cache of CacheEntry objects.
      * @param rootTrace The first stack trace resolve or null.
      * @param stackTrace The stack trace being resolved.
      * @return The StackTracePackageElement array.
      */
-    StackTracePackageElement[] resolvePackageData(final Stack<Class<?>> stack, final Map<String,
-                                                          CacheEntry> map,
-                                                          final StackTraceElement[] rootTrace,
-                                                          final StackTraceElement[] stackTrace) {
+    ExtendedStackTraceElement[] toExtendedStackTrace(final Stack<Class<?>> stack, final Map<String, CacheEntry> map,
+            final StackTraceElement[] rootTrace, final StackTraceElement[] stackTrace) {
         int stackLength;
         if (rootTrace != null) {
             int rootIndex = rootTrace.length - 1;
@@ -401,22 +558,23 @@ public class ThrowableProxy implements Serializable {
                 --rootIndex;
                 --stackIndex;
             }
-            commonElementCount = stackTrace.length - 1 - stackIndex;
+            this.commonElementCount = stackTrace.length - 1 - stackIndex;
             stackLength = stackIndex + 1;
         } else {
-            commonElementCount = 0;
+            this.commonElementCount = 0;
             stackLength = stackTrace.length;
         }
-        final StackTracePackageElement[] packageArray = new StackTracePackageElement[stackLength];
+        final ExtendedStackTraceElement[] packageArray = new ExtendedStackTraceElement[stackLength];
         Class<?> clazz = stack.isEmpty() ? null : stack.peek();
         ClassLoader lastLoader = null;
         for (int i = stackLength - 1; i >= 0; --i) {
-            final String className = stackTrace[i].getClassName();
-            // The stack returned from getCurrentStack will be missing entries for  java.lang.reflect.Method.invoke()
+            final StackTraceElement stackTraceElement = stackTrace[i];
+            final String className = stackTraceElement.getClassName();
+            // The stack returned from getCurrentStack will be missing entries for java.lang.reflect.Method.invoke()
             // and its implementation. The Throwable might also contain stack entries that are no longer
             // present as those methods have returned.
             if (clazz != null && className.equals(clazz.getName())) {
-                final CacheEntry entry = resolvePackageElement(clazz, true);
+                final CacheEntry entry = this.resolvePackageElement(stackTraceElement, clazz, true);
                 packageArray[i] = entry.element;
                 lastLoader = entry.loader;
                 stack.pop();
@@ -429,7 +587,7 @@ public class ThrowableProxy implements Serializable {
                         lastLoader = entry.loader;
                     }
                 } else {
-                    final CacheEntry entry = resolvePackageElement(loadClass(lastLoader, className), false);
+                    final CacheEntry entry = this.resolvePackageElement(stackTraceElement, this.loadClass(lastLoader, className), false);
                     packageArray[i] = entry.element;
                     map.put(className, entry);
                     if (entry.loader != null) {
@@ -441,122 +599,26 @@ public class ThrowableProxy implements Serializable {
         return packageArray;
     }
 
-
-    /**
-     * Construct the CacheEntry from the Class's information.
-     * @param callerClass The Class.
-     * @param exact True if the class was obtained via Reflection.getCallerClass.
-     * @return The CacheEntry.
-     */
-    private CacheEntry resolvePackageElement(final Class<?> callerClass, final boolean exact) {
-        String location = "?";
-        String version = "?";
-        ClassLoader lastLoader = null;
-        if (callerClass != null) {
-            try {
-                final CodeSource source = callerClass.getProtectionDomain().getCodeSource();
-                if (source != null) {
-                    final URL locationURL = source.getLocation();
-                    if (locationURL != null) {
-                        final String str = locationURL.toString().replace('\\', '/');
-                        int index = str.lastIndexOf("/");
-                        if (index >= 0 && index == str.length() - 1) {
-                            index = str.lastIndexOf("/", index - 1);
-                            location = str.substring(index + 1);
-                        } else {
-                            location = str.substring(index + 1);
-                        }
-                    }
-                }
-            } catch (final Exception ex) {
-                // Ignore the exception.
-            }
-            final Package pkg = callerClass.getPackage();
-            if (pkg != null) {
-                final String ver = pkg.getImplementationVersion();
-                if (ver != null) {
-                    version = ver;
-                }
-            }
-            lastLoader = callerClass.getClassLoader();
-        }
-        return new CacheEntry(new StackTracePackageElement(location, version, exact), lastLoader);
+    @Override
+    public String toString() {
+        final String msg = this.message;
+        return msg != null ? this.name + ": " + msg : this.name;
     }
 
-    /**
-     * Loads classes not located via Reflection.getCallerClass.
-     * @param lastLoader The ClassLoader that loaded the Class that called this Class.
-     * @param className The name of the Class.
-     * @return The Class object for the Class or null if it could not be located.
-     */
-    private Class<?> loadClass(final ClassLoader lastLoader, final String className) {
-        // XXX: this is overly complicated
-        Class<?> clazz;
-        if (lastLoader != null) {
-            try {
-                clazz = Loader.initializeClass(className, lastLoader);
-                if (clazz != null) {
-                    return clazz;
-                }
-            } catch (final Exception ignore) {
-                // Ignore exception.
-            }
-        }
+    private ThrowableProxy[] toSuppressedProxies(final Throwable thrown) {
         try {
-            clazz = Loader.loadClass(className);
-        } catch (final ClassNotFoundException ignored) {
-            try {
-                clazz = Loader.initializeClass(className, getClass().getClassLoader());
-            } catch (final ClassNotFoundException ignore) {
+            final Throwable[] suppressed = Throwables.getSuppressed(thrown);
+            if (suppressed == null) {
                 return null;
             }
-        }
-        return clazz;
-    }
-
-    public ThrowableProxy[] getSuppressed() {
-        if (GET_SUPPRESSED != null) {
-            try {
-                return (ThrowableProxy[]) GET_SUPPRESSED.invoke(throwable);
-            } catch (final Exception ignore) {
-                return null;
+            final ThrowableProxy[] proxies = new ThrowableProxy[suppressed.length];
+            for (int i = 0; i < suppressed.length; i++) {
+                proxies[i] = new ThrowableProxy(suppressed[i]);
             }
+            return proxies;
+        } catch (final Exception e) {
+            StatusLogger.getLogger().error(e);
         }
         return null;
     }
-
-    private void setSuppressed(final Throwable throwable) {
-        if (GET_SUPPRESSED != null && ADD_SUPPRESSED != null) {
-            try {
-                final Throwable[] array = (Throwable[]) GET_SUPPRESSED.invoke(throwable);
-                for (final Throwable t : array) {
-                    ADD_SUPPRESSED.invoke(this, new ThrowableProxy(t));
-                }
-            } catch (final Exception ignore) {
-                //
-            }
-        }
-    }
-
-    /**
-     * Cached StackTracePackageElement and the ClassLoader.
-     */
-    class CacheEntry {
-        private final StackTracePackageElement element;
-        private final ClassLoader loader;
-
-        public CacheEntry(final StackTracePackageElement element, final ClassLoader loader) {
-            this.element = element;
-            this.loader = loader;
-        }
-    }
-
-    /**
-     * Security Manager for accessing the call stack.
-     */
-    private static class PrivateSecurityManager extends SecurityManager {
-        public Class<?>[] getClasses() {
-            return getClassContext();
-        }
-    }
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Initializers.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Initializers.java
new file mode 100644
index 0000000000..9c41b079a0
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Initializers.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.ThreadContext.ContextStack;
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.impl.ExtendedStackTraceElement;
+import org.apache.logging.log4j.core.impl.ThrowableProxy;
+
+import com.fasterxml.jackson.databind.Module.SetupContext;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+
+/**
+ * Initialization utils.
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+class Initializers {
+
+    /**
+     * Used to set up {@link SetupContext} from different {@link SimpleModule}s.
+     */
+    static class SetupContextInitializer {
+
+        void setupModule(final SetupContext context) {
+            // JRE classes: we cannot edit those with Jackson annotations
+            context.setMixInAnnotations(StackTraceElement.class, StackTraceElementMixIn.class);
+            // Log4j API classes: we do not want to edit those with Jackson annotations because the API module should not depend on Jackson.
+            context.setMixInAnnotations(Marker.class, MarkerMixIn.class);
+            context.setMixInAnnotations(Level.class, LevelMixIn.class);
+            context.setMixInAnnotations(LogEvent.class, LogEventMixIn.class);
+            // Log4j Core classes: we do not want to bring in Jackson at runtime if we do not have to.
+            context.setMixInAnnotations(ExtendedStackTraceElement.class, StackTracePackageElementMixIn.class);
+            context.setMixInAnnotations(ThrowableProxy.class, ThrowableProxyMixIn.class);            
+        }
+    }
+
+    /**
+     * Used to set up {@link SimpleModule} from different {@link SimpleModule} subclasses.
+     */
+    static class SimpleModuleInitializer {
+        void initialize(final SimpleModule simpleModule) {
+            // Workaround because mix-ins do not work for classes that already have a built-in deserializer.
+            // See Jackson issue 429.
+            simpleModule.addDeserializer(StackTraceElement.class, new Log4jStackTraceElementDeserializer());
+            simpleModule.addDeserializer(ContextStack.class, new MutableThreadContextStackDeserializer());
+        }
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/LevelMixIn.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/LevelMixIn.java
new file mode 100644
index 0000000000..870e81779b
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/LevelMixIn.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.Marker;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonValue;
+
+/**
+ * Jackson mix-in for {@link Level}.
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ * @see Marker
+ */
+@JsonIgnoreProperties({ "name", "declaringClass", "standardLevel" })
+abstract class LevelMixIn {
+
+    @JsonCreator
+    public static Level getLevel(@JsonProperty("name") final String name) {
+        return null;
+    }
+
+    @JsonValue
+    public abstract String name();
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ListOfMapEntryDeserializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ListOfMapEntryDeserializer.java
new file mode 100644
index 0000000000..13cbb23fcb
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ListOfMapEntryDeserializer.java
@@ -0,0 +1,55 @@
+/*;
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+public class ListOfMapEntryDeserializer extends StdDeserializer<Map<String, String>> {
+
+    private static final long serialVersionUID = 1L;
+
+    ListOfMapEntryDeserializer() {
+        super(Map.class);
+    }
+
+    @Override
+    public Map<String, String> deserialize(final JsonParser jp, final DeserializationContext ctxt) throws IOException,
+            JsonProcessingException {
+        final List<MapEntry> list = jp.readValueAs(new TypeReference<List<MapEntry>>() {
+            // empty
+        });
+        final HashMap<String, String> map = new HashMap<String, String>(list.size());
+        for (final MapEntry mapEntry : list) {
+            map.put(mapEntry.getKey(), mapEntry.getValue());
+        }
+        return map;
+    }
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ListOfMapEntrySerializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ListOfMapEntrySerializer.java
new file mode 100644
index 0000000000..15d96d7241
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ListOfMapEntrySerializer.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import com.fasterxml.jackson.core.JsonGenerationException;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.ser.std.StdSerializer;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+public class ListOfMapEntrySerializer extends StdSerializer<Map> {
+
+    protected ListOfMapEntrySerializer() {
+        super(Map.class);
+    }
+
+    @Override
+    public void serialize(final Map map, final JsonGenerator jgen, final SerializerProvider provider) throws IOException, JsonGenerationException {
+        final Set<Entry<String, String>> entrySet = map.entrySet();
+        final MapEntry[] pairs = new MapEntry[entrySet.size()];
+        int i = 0;
+        for (final Entry<String, String> entry : entrySet) {
+            pairs[i++] = new MapEntry(entry.getKey(), entry.getValue());
+        }
+        jgen.writeObject(pairs);
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jJsonModule.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jJsonModule.java
new file mode 100644
index 0000000000..04487ce87d
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jJsonModule.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.core.jackson.Initializers.SetupContextInitializer;
+import org.apache.logging.log4j.core.jackson.Initializers.SimpleModuleInitializer;
+
+import com.fasterxml.jackson.core.Version;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+class Log4jJsonModule extends SimpleModule {
+
+    private static final long serialVersionUID = 1L;
+
+    Log4jJsonModule() {
+        super(Log4jJsonModule.class.getName(), new Version(2, 0, 0, null, null, null));
+        // MUST init here.
+        // Calling this from setupModule is too late!
+        new SimpleModuleInitializer().initialize(this);
+    }
+
+    @Override
+    public void setupModule(final SetupContext context) {
+        // Calling super is a MUST!
+        super.setupModule(context);
+        new SetupContextInitializer().setupModule(context);
+    }
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jJsonObjectMapper.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jJsonObjectMapper.java
new file mode 100644
index 0000000000..71b1585f22
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jJsonObjectMapper.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+/**
+ * A Jackson {@link ObjectMapper} initialized for Log4j.
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+public class Log4jJsonObjectMapper extends ObjectMapper {
+
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Create a new instance using the {@link Log4jJsonModule}.
+     */
+    public Log4jJsonObjectMapper() {
+        this.registerModule(new Log4jJsonModule());
+        this.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jStackTraceElementDeserializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jStackTraceElementDeserializer.java
new file mode 100644
index 0000000000..9a99d5474c
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jStackTraceElementDeserializer.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
+
+/**
+ * Copy and edit the Jackson (Apache License 2.0) class to use Log4j attribute names. Does not work as of Jackson 2.3.2.
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+public class Log4jStackTraceElementDeserializer extends StdScalarDeserializer<StackTraceElement> {
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Constructs a new initialized instance.
+     */
+    public Log4jStackTraceElementDeserializer() {
+        super(StackTraceElement.class);
+    }
+
+    @Override
+    public StackTraceElement deserialize(final JsonParser jp, final DeserializationContext ctxt) throws IOException,
+            JsonProcessingException {
+        JsonToken t = jp.getCurrentToken();
+        // Must get an Object
+        if (t == JsonToken.START_OBJECT) {
+            String className = null, methodName = null, fileName = null;
+            int lineNumber = -1;
+
+            while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {
+                final String propName = jp.getCurrentName();
+                if ("class".equals(propName)) {
+                    className = jp.getText();
+                } else if ("file".equals(propName)) {
+                    fileName = jp.getText();
+                } else if ("line".equals(propName)) {
+                    if (t.isNumeric()) {
+                        lineNumber = jp.getIntValue();
+                    } else {
+                        // An XML number always comes in a string since there is no syntax help as with JSON.
+                        try {
+                            lineNumber = Integer.valueOf(jp.getText().trim()).intValue();
+                        } catch (final NumberFormatException e) {
+                            throw JsonMappingException.from(jp, "Non-numeric token (" + t + ") for property 'line'", e);
+                        }
+                    }
+                } else if ("method".equals(propName)) {
+                    methodName = jp.getText();
+                } else if ("nativeMethod".equals(propName)) {
+                    // no setter, not passed via constructor: ignore
+                } else {
+                    this.handleUnknownProperty(jp, ctxt, this._valueClass, propName);
+                }
+            }
+            return new StackTraceElement(className, methodName, fileName, lineNumber);
+        }
+        throw ctxt.mappingException(this._valueClass, t);
+    }
+}
\ No newline at end of file
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jXmlModule.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jXmlModule.java
new file mode 100644
index 0000000000..2ce34a5b77
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jXmlModule.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.core.jackson.Initializers.SetupContextInitializer;
+import org.apache.logging.log4j.core.jackson.Initializers.SimpleModuleInitializer;
+
+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+class Log4jXmlModule extends JacksonXmlModule {
+
+    private static final long serialVersionUID = 1L;
+
+    Log4jXmlModule() {
+        super();
+        // MUST init here.
+        // Calling this from setupModule is too late!
+        new SimpleModuleInitializer().initialize(this);
+    }
+
+    @Override
+    public void setupModule(final SetupContext context) {
+        // Calling super is a MUST!
+        super.setupModule(context);
+        new SetupContextInitializer().setupModule(context);
+    }
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jXmlObjectMapper.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jXmlObjectMapper.java
new file mode 100644
index 0000000000..6a16603e16
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/Log4jXmlObjectMapper.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.dataformat.xml.XmlMapper;
+
+/**
+ * A Jackson {@link ObjectMapper} initialized for Log4j.
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+public class Log4jXmlObjectMapper extends XmlMapper {
+
+    private static final long serialVersionUID = 1L;
+
+    /**
+     * Create a new instance using the {@link Log4jXmlModule}.
+     */
+    public Log4jXmlObjectMapper() {
+        super(new Log4jXmlModule());
+        this.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/LogEventMixIn.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/LogEventMixIn.java
new file mode 100644
index 0000000000..ff9241dc26
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/LogEventMixIn.java
@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.util.Map;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.ThreadContext.ContextStack;
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.impl.ThrowableProxy;
+import org.apache.logging.log4j.core.layout.JSONConstants;
+import org.apache.logging.log4j.core.layout.XMLConstants;
+import org.apache.logging.log4j.message.Message;
+
+import com.fasterxml.jackson.annotation.JsonFilter;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+import com.fasterxml.jackson.annotation.JsonRootName;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;
+
+@JsonRootName("Event")
+@JacksonXmlRootElement(namespace = XMLConstants.XML_NAMESPACE, localName = "Event")
+@JsonFilter("org.apache.logging.log4j.core.impl.Log4jLogEvent")
+@JsonPropertyOrder({ "timeMillis", "threadName", "level", "loggerName", "marker", "message", "thrown", XMLConstants.TAG_CONTEXT_MAP,
+        "ContextStack", "loggerFQCN", "Source", "endOfBatch" })
+abstract class LogEventMixIn implements LogEvent {
+
+    private static final long serialVersionUID = 1L;
+
+    @JsonProperty(JSONConstants.PROP_CONTEXT_MAP)
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = XMLConstants.TAG_CONTEXT_MAP)
+    @JsonSerialize(using = ListOfMapEntrySerializer.class)
+    @JsonDeserialize(using = ListOfMapEntryDeserializer.class)
+    @Override
+    public abstract Map<String, String> getContextMap();
+
+    @JsonProperty("contextStack")
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "ContextStack")
+    @Override
+    public abstract ContextStack getContextStack();
+
+    @JsonProperty()
+    @JacksonXmlProperty(isAttribute = true)
+    @Override
+    public abstract Level getLevel();
+
+    @JsonProperty()
+    @JacksonXmlProperty(isAttribute = true)
+    @Override
+    public abstract String getLoggerFQCN();
+
+    @JsonProperty()
+    @JacksonXmlProperty(isAttribute = true)
+    @Override
+    public abstract String getLoggerName();
+
+    @JsonProperty("marker")
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "Marker")
+    @Override
+    public abstract Marker getMarker();
+
+    @JsonSerialize(using = MessageSerializer.class)
+    @JsonDeserialize(using = SimpleMessageDeserializer.class)
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "Message")
+    @Override
+    public abstract Message getMessage();
+
+    @JsonProperty(JSONConstants.PROP_SOURCE)
+    @JsonDeserialize(using = Log4jStackTraceElementDeserializer.class)
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = XMLConstants.TAG_SOURCE)
+    @Override
+    public abstract StackTraceElement getSource();
+
+    @Override
+    @JsonProperty("thread")
+    @JacksonXmlProperty(isAttribute = true, localName = "thread")
+    public abstract String getThreadName();
+
+    @JsonIgnore
+    @Override
+    public abstract Throwable getThrown();
+
+    @JsonProperty("thrown")
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "Thrown")
+    @Override
+    public abstract ThrowableProxy getThrownProxy();
+
+    @JsonProperty()
+    @JacksonXmlProperty(isAttribute = true)
+    @Override
+    public abstract long getTimeMillis();
+
+    @JsonProperty()
+    @JacksonXmlProperty(isAttribute = true)
+    @Override
+    public abstract boolean isEndOfBatch();
+
+    @JsonIgnore
+    @Override
+    public abstract boolean isIncludeLocation();
+
+    @Override
+    public abstract void setEndOfBatch(boolean endOfBatch);
+
+    @Override
+    public abstract void setIncludeLocation(boolean locationRequired);
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MapEntry.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MapEntry.java
new file mode 100644
index 0000000000..862becb46d
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MapEntry.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.util.Strings;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ * <p>
+ * Used to represent map entries in a generic fashion because the default Jackson behavior uses the key as the element tag. Using the key as
+ * an element/property name would mean that you cannot have a generic JSON/XML schema for all log event.
+ * </p>
+ */
+@JsonPropertyOrder({ "key", "value" })
+class MapEntry {
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    private String key;
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    private String value;
+
+    @JsonCreator
+    public MapEntry(@JsonProperty("key") final String key, @JsonProperty("value") final String value) {
+        this.setKey(key);
+        this.setValue(value);
+    }
+
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!(obj instanceof MapEntry)) {
+            return false;
+        }
+        final MapEntry other = (MapEntry) obj;
+        if (this.getKey() == null) {
+            if (other.getKey() != null) {
+                return false;
+            }
+        } else if (!this.getKey().equals(other.getKey())) {
+            return false;
+        }
+        if (this.getValue() == null) {
+            if (other.getValue() != null) {
+                return false;
+            }
+        } else if (!this.getValue().equals(other.getValue())) {
+            return false;
+        }
+        return true;
+    }
+
+    public String getKey() {
+        return this.key;
+    }
+
+    public String getValue() {
+        return this.value;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((this.getKey() == null) ? 0 : this.getKey().hashCode());
+        result = prime * result + ((this.getValue() == null) ? 0 : this.getValue().hashCode());
+        return result;
+    }
+
+    public void setKey(final String key) {
+        this.key = key;
+    }
+
+    public void setValue(final String value) {
+        this.value = value;
+    }
+
+    @Override
+    public String toString() {
+        return Strings.EMPTY + this.getKey() + "=" + this.getValue();
+    }
+}
\ No newline at end of file
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MarkerMixIn.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MarkerMixIn.java
new file mode 100644
index 0000000000..3eb166bda6
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MarkerMixIn.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.core.layout.XMLConstants;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+
+/**
+ * Jackson mix-in for {@link Marker}.
+ * <p>
+ * If we want to deal with more than one {@link Marker} implementation then recode these annotations to include metadata.
+ * </p>
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ * @see Marker
+ */
+// Alternate for multiple Marker implementation.
+// @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = "@class")
+@JsonDeserialize(as = org.apache.logging.log4j.MarkerManager.Log4jMarker.class)
+abstract class MarkerMixIn implements Marker {
+    private static final long serialVersionUID = 1L;
+
+    @JsonCreator
+    MarkerMixIn(@JsonProperty("name") final String name) {
+        // empty
+    }
+
+    @Override
+    @JsonProperty("name")
+    @JacksonXmlProperty(isAttribute = true)
+    public abstract String getName();
+
+    @JsonIgnore
+    @Override
+    public abstract Marker getParent();
+
+    @Override
+    @JsonProperty("parents")
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "Parents")
+    public abstract Marker[] getParents();
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MessageSerializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MessageSerializer.java
new file mode 100644
index 0000000000..8c7fcd74b4
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MessageSerializer.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import org.apache.logging.log4j.message.Message;
+
+import com.fasterxml.jackson.core.JsonGenerationException;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+class MessageSerializer extends StdScalarSerializer<Message> {
+
+    MessageSerializer() {
+        super(Message.class);
+    }
+
+    @Override
+    public void serialize(final Message value, final JsonGenerator jgen, final SerializerProvider provider) throws IOException,
+            JsonGenerationException {
+        jgen.writeString(value.getFormattedMessage());
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MutableThreadContextStackDeserializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MutableThreadContextStackDeserializer.java
new file mode 100644
index 0000000000..22e9f2a869
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/MutableThreadContextStackDeserializer.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.logging.log4j.spi.MutableThreadContextStack;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+class MutableThreadContextStackDeserializer extends StdDeserializer<MutableThreadContextStack> {
+
+    private static final long serialVersionUID = 1L;
+
+    MutableThreadContextStackDeserializer() {
+        super(MutableThreadContextStack.class);
+    }
+
+    @Override
+    public MutableThreadContextStack deserialize(final JsonParser jp, final DeserializationContext ctxt) throws IOException,
+            JsonProcessingException {
+        final List<String> list = jp.readValueAs(new TypeReference<List<String>>() {
+            // empty
+        });
+        return new MutableThreadContextStack(list);
+    }
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/SimpleMessageDeserializer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/SimpleMessageDeserializer.java
new file mode 100644
index 0000000000..8599302d18
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/SimpleMessageDeserializer.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import org.apache.logging.log4j.message.SimpleMessage;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
+
+/**
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ */
+public class SimpleMessageDeserializer extends StdScalarDeserializer<SimpleMessage> {
+
+    private static final long serialVersionUID = 1L;
+
+    SimpleMessageDeserializer() {
+        super(SimpleMessage.class);
+    }
+
+    @Override
+    public SimpleMessage deserialize(final JsonParser jp, final DeserializationContext ctxt) throws IOException,
+            JsonProcessingException {
+        return new SimpleMessage(jp.getValueAsString());
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/StackTraceElementMixIn.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/StackTraceElementMixIn.java
new file mode 100644
index 0000000000..9a3b0223f8
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/StackTraceElementMixIn.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+
+/**
+ * Jackson mix-in for {@link StackTraceElement}.
+ * <p>
+ * <em>Consider this class private.</em>
+ * </p>
+ * 
+ * @see StackTraceElement
+ */
+@JsonIgnoreProperties("nativeMethod")
+abstract class StackTraceElementMixIn {
+    @JsonCreator
+    StackTraceElementMixIn(
+            // @formatter:off
+            @JsonProperty("class") final String declaringClass, 
+            @JsonProperty("method") final String methodName,
+            @JsonProperty("file") final String fileName, 
+            @JsonProperty("line") final int lineNumber)
+            // @formatter:on
+    {
+        // empty
+    }
+
+    @JsonProperty("class")
+    @JacksonXmlProperty(localName = "class", isAttribute = true)
+    abstract String getClassName();
+
+    @JsonProperty("file")
+    @JacksonXmlProperty(localName = "file", isAttribute = true)
+    abstract String getFileName();
+
+    @JsonProperty("line")
+    @JacksonXmlProperty(localName = "line", isAttribute = true)
+    abstract int getLineNumber();
+
+    @JsonProperty("method")
+    @JacksonXmlProperty(localName = "method", isAttribute = true)
+    abstract String getMethodName();
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/StackTracePackageElementMixIn.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/StackTracePackageElementMixIn.java
new file mode 100644
index 0000000000..6f2d9d181f
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/StackTracePackageElementMixIn.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.Serializable;
+
+import org.apache.logging.log4j.core.impl.ExtendedStackTraceElement;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+
+/**
+ * Mix-in for {@link ExtendedStackTraceElement}.
+ */
+@JsonPropertyOrder({ "class", "method", "file", "line", "exact", "location", "version" })
+abstract class StackTracePackageElementMixIn implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    @JsonCreator
+    public StackTracePackageElementMixIn(
+            // @formatter:off
+            @JsonProperty("class") final String declaringClass,
+            @JsonProperty("method") final String methodName,
+            @JsonProperty("file") final String fileName,
+            @JsonProperty("line") final int lineNumber,
+            @JsonProperty("exact") final boolean exact,
+            @JsonProperty("location") final String location,
+            @JsonProperty("version") final String version
+            // @formatter:on
+    ) {
+        // empty
+    }
+
+    @JsonProperty("class")
+    @JacksonXmlProperty(localName = "class", isAttribute = true)
+    public abstract String getClassName();
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    public abstract boolean getExact();
+
+    @JsonProperty("file")
+    @JacksonXmlProperty(localName = "file", isAttribute = true)
+    public abstract String getFileName();
+
+    @JsonProperty("line")
+    @JacksonXmlProperty(localName = "line", isAttribute = true)
+    public abstract int getLineNumber();
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    public abstract String getLocation();
+
+    @JsonProperty("method")
+    @JacksonXmlProperty(localName = "method", isAttribute = true)
+    public abstract String getMethodName();
+
+    @JsonIgnore
+    abstract StackTraceElement getStackTraceElement();
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    public abstract String getVersion();
+
+    @JsonIgnore
+    public abstract boolean isNativeMethod();
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ThrowableProxyMixIn.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ThrowableProxyMixIn.java
new file mode 100644
index 0000000000..35835ab648
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/jackson/ThrowableProxyMixIn.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import org.apache.logging.log4j.core.impl.ExtendedStackTraceElement;
+import org.apache.logging.log4j.core.impl.ThrowableProxy;
+import org.apache.logging.log4j.core.layout.XMLConstants;
+
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
+
+/**
+ * Mix-in for {@link ThrowableProxy}.
+ */
+abstract class ThrowableProxyMixIn {
+
+    @JsonProperty("cause")
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "Cause")
+    private ThrowableProxyMixIn causeProxy;
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    private int commonElementCount;
+
+    @JsonProperty
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "ExtendedStackTrace")
+    private ExtendedStackTraceElement[] extendedStackTrace;
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    private String localizedMessage;
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    private String message;
+
+    @JsonProperty
+    @JacksonXmlProperty(isAttribute = true)
+    private String name;
+
+    @JsonIgnore
+    private transient Throwable throwable;
+
+    @JsonIgnore
+    public abstract String getCauseStackTraceAsString();
+
+    @JsonIgnore
+    public abstract String getExtendedStackTraceAsString();
+
+    @JsonIgnore
+    public abstract StackTraceElement[] getStackTrace();
+
+    @JsonProperty("suppressed")
+    @JacksonXmlProperty(namespace = XMLConstants.XML_NAMESPACE, localName = "Suppressed")
+    public abstract ThrowableProxy[] getSuppressedProxies();
+
+    @JsonIgnore
+    public abstract String getSuppressedStackTrace();
+
+    @JsonIgnore
+    public abstract Throwable getThrowable();
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractJacksonLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractJacksonLayout.java
new file mode 100644
index 0000000000..8f74f3b8f0
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/AbstractJacksonLayout.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.layout;
+
+import java.nio.charset.Charset;
+
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.util.Strings;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectWriter;
+
+abstract class AbstractJacksonLayout extends AbstractStringLayout {
+
+    protected static final String DEFAULT_EOL = "\r\n";
+    protected static final String COMPACT_EOL = Strings.EMPTY;
+    protected final String eol;
+    protected final ObjectWriter objectWriter;
+    protected final boolean compact;
+    protected final boolean complete;
+
+    protected AbstractJacksonLayout(ObjectWriter objectWriter, Charset charset, boolean compact, boolean complete) {
+        super(charset);
+        this.objectWriter = objectWriter;
+        this.compact = compact;
+        this.complete = complete;
+        this.eol = compact ? COMPACT_EOL : DEFAULT_EOL;
+    }
+
+    /**
+     * Formats a {@link org.apache.logging.log4j.core.LogEvent}.
+     * 
+     * @param event The LogEvent.
+     * @return The XML representation of the LogEvent.
+     */
+    @Override
+    public String toSerializable(final LogEvent event) {
+        try {
+            return this.objectWriter.writeValueAsString(event);
+        } catch (final JsonProcessingException e) {
+            // Should this be an ISE or IAE?
+            LOGGER.error(e);
+            return Strings.EMPTY;
+        }
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/XMLLogEventInput.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONConstants.java
similarity index 65%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/XMLLogEventInput.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONConstants.java
index bf1ede28ea..a1503081f3 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/XMLLogEventInput.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONConstants.java
@@ -14,21 +14,12 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-import org.apache.logging.log4j.core.LogEvent;
+package org.apache.logging.log4j.core.layout;
 
 /**
- * Reads XML {@link LogEvent}s.
+ * Keeps constants separate from any class that may depend on third party jars.
  */
-public class XMLLogEventInput extends AbstractLogEventInput<InputStream> {
-
-    @Override
-    public LogEvent readLogEvent(final InputStream inputStream) throws IOException {
-        throw new UnsupportedOperationException("Not implemented yet");
-    }
-
-}
+public class JSONConstants {
+    public static final String PROP_SOURCE = "source";
+    public static final String PROP_CONTEXT_MAP = "contextMap";
+}
\ No newline at end of file
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java
index 58e23470a1..83c279e057 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JSONLayout.java
@@ -18,272 +18,788 @@ package org.apache.logging.log4j.core.layout;
 
 import java.nio.charset.Charset;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
 
-import org.apache.logging.log4j.core.LogEvent;
 import org.apache.logging.log4j.core.config.plugins.Plugin;
 import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
 import org.apache.logging.log4j.core.config.plugins.PluginFactory;
 import org.apache.logging.log4j.core.helpers.Charsets;
-import org.apache.logging.log4j.core.helpers.Throwables;
-import org.apache.logging.log4j.core.helpers.Transform;
-import org.apache.logging.log4j.message.Message;
-import org.apache.logging.log4j.message.MultiformatMessage;
 
 /**
  * Appends a series of JSON events as strings serialized as bytes.
- *
- * TODO: Marker.
- *
+ * 
  * <h4>Complete well-formed JSON vs. fragment JSON</h4>
  * <p>
- * If you configure {@code complete="true"}, the appender outputs a well-formed JSON document.
- * By default, with {@code complete="false"}, you should include the
- * output as an <em>external file</em> in a separate file to form a well-formed JSON document.
+ * If you configure {@code complete="true"}, the appender outputs a well-formed JSON document. By default, with {@code complete="false"},
+ * you should include the output as an <em>external file</em> in a separate file to form a well-formed JSON document.
  * </p>
  * <p>
- * A well-formed JSON document follows this pattern:
+ * A well-formed JSON event follows this pattern:
  * </p>
- *
- * <pre>[
- *   {
- *     "logger":"com.foo.Bar",
- *     "timestamp":"1376681196470",
- *     "level":"INFO",
- *     "thread":"main",
- *     "message":"Message flushed with immediate flush=true"
- *   },
- *   {
- *     "logger":"com.foo.Bar",
- *     "timestamp":"1376681196471",
- *     "level":"ERROR",
- *     "thread":"main",
- *     "message":"Message flushed with immediate flush=true",
- *     "throwable":"java.lang.IllegalArgumentException: badarg\\n\\tat org.apache.logging.log4j.core.appender.JSONCompleteFileAppenderTest.testFlushAtEndOfBatch(JSONCompleteFileAppenderTest.java:54)\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\\n\\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat java.lang.reflect.Method.invoke(Method.java:606)\\n\\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\\n\\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\\n\\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\\n\\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\\n\\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\\n\\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\\n\\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\\n\\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\\n\\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\\n\\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\\n\\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\\n\\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\\n\\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\\n\\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\\n\\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\\n\\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\\n"
- *   }
- * ]</pre>
+ * 
+ * <pre>
+ * {
+  "timeMillis": 1,
+  "thread": "MyThreadName",
+  "level": "DEBUG",
+  "loggerName": "a.B",
+  "marker": {
+    "name": "Marker1",
+    "parents": [{
+      "name": "ParentMarker1",
+      "parents": [{
+        "name": "GrandMotherMarker"
+      }, {
+        "name": "GrandFatherMarker"
+      }]
+    }, {
+      "name": "GrandFatherMarker"
+    }]
+  },
+  "message": "Msg",
+  "thrown": {
+    "cause": {
+      "commonElementCount": 27,
+      "extendedStackTrace": [{
+        "class": "org.apache.logging.log4j.core.layout.LogEventFixtures",
+        "method": "createLogEvent",
+        "file": "LogEventFixtures.java",
+        "line": 53,
+        "exact": false,
+        "location": "test-classes/",
+        "version": "?"
+      }],
+      "localizedMessage": "testNPEx",
+      "message": "testNPEx",
+      "name": "java.lang.NullPointerException"
+    },
+    "commonElementCount": 0,
+    "extendedStackTrace": [{
+      "class": "org.apache.logging.log4j.core.layout.LogEventFixtures",
+      "method": "createLogEvent",
+      "file": "LogEventFixtures.java",
+      "line": 56,
+      "exact": true,
+      "location": "test-classes/",
+      "version": "?"
+    }, {
+      "class": "org.apache.logging.log4j.core.layout.JSONLayoutTest",
+      "method": "testAllFeatures",
+      "file": "JSONLayoutTest.java",
+      "line": 105,
+      "exact": true,
+      "location": "test-classes/",
+      "version": "?"
+    }, {
+      "class": "org.apache.logging.log4j.core.layout.JSONLayoutTest",
+      "method": "testLocationOnCompactOnMdcOn",
+      "file": "JSONLayoutTest.java",
+      "line": 268,
+      "exact": true,
+      "location": "test-classes/",
+      "version": "?"
+    }, {
+      "class": "sun.reflect.NativeMethodAccessorImpl",
+      "method": "invoke",
+      "line": -1,
+      "exact": false,
+      "location": "?",
+      "version": "1.7.0_55"
+    }, {
+      "class": "sun.reflect.NativeMethodAccessorImpl",
+      "method": "invoke",
+      "line": -1,
+      "exact": false,
+      "location": "?",
+      "version": "1.7.0_55"
+    }, {
+      "class": "sun.reflect.DelegatingMethodAccessorImpl",
+      "method": "invoke",
+      "line": -1,
+      "exact": false,
+      "location": "?",
+      "version": "1.7.0_55"
+    }, {
+      "class": "java.lang.reflect.Method",
+      "method": "invoke",
+      "line": -1,
+      "exact": false,
+      "location": "?",
+      "version": "1.7.0_55"
+    }, {
+      "class": "org.junit.runners.model.FrameworkMethod$1",
+      "method": "runReflectiveCall",
+      "file": "FrameworkMethod.java",
+      "line": 47,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.internal.runners.model.ReflectiveCallable",
+      "method": "run",
+      "file": "ReflectiveCallable.java",
+      "line": 12,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.model.FrameworkMethod",
+      "method": "invokeExplosively",
+      "file": "FrameworkMethod.java",
+      "line": 44,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.internal.runners.statements.InvokeMethod",
+      "method": "evaluate",
+      "file": "InvokeMethod.java",
+      "line": 17,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner",
+      "method": "runLeaf",
+      "file": "ParentRunner.java",
+      "line": 271,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.BlockJUnit4ClassRunner",
+      "method": "runChild",
+      "file": "BlockJUnit4ClassRunner.java",
+      "line": 70,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.BlockJUnit4ClassRunner",
+      "method": "runChild",
+      "file": "BlockJUnit4ClassRunner.java",
+      "line": 50,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner$3",
+      "method": "run",
+      "file": "ParentRunner.java",
+      "line": 238,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner$1",
+      "method": "schedule",
+      "file": "ParentRunner.java",
+      "line": 63,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner",
+      "method": "runChildren",
+      "file": "ParentRunner.java",
+      "line": 236,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner",
+      "method": "access$000",
+      "file": "ParentRunner.java",
+      "line": 53,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner$2",
+      "method": "evaluate",
+      "file": "ParentRunner.java",
+      "line": 229,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.internal.runners.statements.RunBefores",
+      "method": "evaluate",
+      "file": "RunBefores.java",
+      "line": 26,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.internal.runners.statements.RunAfters",
+      "method": "evaluate",
+      "file": "RunAfters.java",
+      "line": 27,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.junit.runners.ParentRunner",
+      "method": "run",
+      "file": "ParentRunner.java",
+      "line": 309,
+      "exact": true,
+      "location": "junit-4.11.jar",
+      "version": "?"
+    }, {
+      "class": "org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference",
+      "method": "run",
+      "file": "JUnit4TestReference.java",
+      "line": 50,
+      "exact": true,
+      "location": ".cp/",
+      "version": "?"
+    }, {
+      "class": "org.eclipse.jdt.internal.junit.runner.TestExecution",
+      "method": "run",
+      "file": "TestExecution.java",
+      "line": 38,
+      "exact": true,
+      "location": ".cp/",
+      "version": "?"
+    }, {
+      "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+      "method": "runTests",
+      "file": "RemoteTestRunner.java",
+      "line": 467,
+      "exact": true,
+      "location": ".cp/",
+      "version": "?"
+    }, {
+      "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+      "method": "runTests",
+      "file": "RemoteTestRunner.java",
+      "line": 683,
+      "exact": true,
+      "location": ".cp/",
+      "version": "?"
+    }, {
+      "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+      "method": "run",
+      "file": "RemoteTestRunner.java",
+      "line": 390,
+      "exact": true,
+      "location": ".cp/",
+      "version": "?"
+    }, {
+      "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+      "method": "main",
+      "file": "RemoteTestRunner.java",
+      "line": 197,
+      "exact": true,
+      "location": ".cp/",
+      "version": "?"
+    }],
+    "localizedMessage": "testIOEx",
+    "message": "testIOEx",
+    "name": "java.io.IOException",
+    "suppressed": [{
+      "commonElementCount": 0,
+      "extendedStackTrace": [{
+        "class": "org.apache.logging.log4j.core.layout.LogEventFixtures",
+        "method": "createLogEvent",
+        "file": "LogEventFixtures.java",
+        "line": 57,
+        "exact": true,
+        "location": "test-classes/",
+        "version": "?"
+      }, {
+        "class": "org.apache.logging.log4j.core.layout.JSONLayoutTest",
+        "method": "testAllFeatures",
+        "file": "JSONLayoutTest.java",
+        "line": 105,
+        "exact": true,
+        "location": "test-classes/",
+        "version": "?"
+      }, {
+        "class": "org.apache.logging.log4j.core.layout.JSONLayoutTest",
+        "method": "testLocationOnCompactOnMdcOn",
+        "file": "JSONLayoutTest.java",
+        "line": 268,
+        "exact": true,
+        "location": "test-classes/",
+        "version": "?"
+      }, {
+        "class": "sun.reflect.NativeMethodAccessorImpl",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "sun.reflect.NativeMethodAccessorImpl",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "sun.reflect.DelegatingMethodAccessorImpl",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "java.lang.reflect.Method",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "org.junit.runners.model.FrameworkMethod$1",
+        "method": "runReflectiveCall",
+        "file": "FrameworkMethod.java",
+        "line": 47,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.model.ReflectiveCallable",
+        "method": "run",
+        "file": "ReflectiveCallable.java",
+        "line": 12,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.model.FrameworkMethod",
+        "method": "invokeExplosively",
+        "file": "FrameworkMethod.java",
+        "line": 44,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.statements.InvokeMethod",
+        "method": "evaluate",
+        "file": "InvokeMethod.java",
+        "line": 17,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "runLeaf",
+        "file": "ParentRunner.java",
+        "line": 271,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.BlockJUnit4ClassRunner",
+        "method": "runChild",
+        "file": "BlockJUnit4ClassRunner.java",
+        "line": 70,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.BlockJUnit4ClassRunner",
+        "method": "runChild",
+        "file": "BlockJUnit4ClassRunner.java",
+        "line": 50,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner$3",
+        "method": "run",
+        "file": "ParentRunner.java",
+        "line": 238,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner$1",
+        "method": "schedule",
+        "file": "ParentRunner.java",
+        "line": 63,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "runChildren",
+        "file": "ParentRunner.java",
+        "line": 236,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "access$000",
+        "file": "ParentRunner.java",
+        "line": 53,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner$2",
+        "method": "evaluate",
+        "file": "ParentRunner.java",
+        "line": 229,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.statements.RunBefores",
+        "method": "evaluate",
+        "file": "RunBefores.java",
+        "line": 26,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.statements.RunAfters",
+        "method": "evaluate",
+        "file": "RunAfters.java",
+        "line": 27,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "run",
+        "file": "ParentRunner.java",
+        "line": 309,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference",
+        "method": "run",
+        "file": "JUnit4TestReference.java",
+        "line": 50,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.TestExecution",
+        "method": "run",
+        "file": "TestExecution.java",
+        "line": 38,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "runTests",
+        "file": "RemoteTestRunner.java",
+        "line": 467,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "runTests",
+        "file": "RemoteTestRunner.java",
+        "line": 683,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "run",
+        "file": "RemoteTestRunner.java",
+        "line": 390,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "main",
+        "file": "RemoteTestRunner.java",
+        "line": 197,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }],
+      "localizedMessage": "I am suppressed exception 1",
+      "message": "I am suppressed exception 1",
+      "name": "java.lang.IndexOutOfBoundsException"
+    }, {
+      "commonElementCount": 0,
+      "extendedStackTrace": [{
+        "class": "org.apache.logging.log4j.core.layout.LogEventFixtures",
+        "method": "createLogEvent",
+        "file": "LogEventFixtures.java",
+        "line": 58,
+        "exact": true,
+        "location": "test-classes/",
+        "version": "?"
+      }, {
+        "class": "org.apache.logging.log4j.core.layout.JSONLayoutTest",
+        "method": "testAllFeatures",
+        "file": "JSONLayoutTest.java",
+        "line": 105,
+        "exact": true,
+        "location": "test-classes/",
+        "version": "?"
+      }, {
+        "class": "org.apache.logging.log4j.core.layout.JSONLayoutTest",
+        "method": "testLocationOnCompactOnMdcOn",
+        "file": "JSONLayoutTest.java",
+        "line": 268,
+        "exact": true,
+        "location": "test-classes/",
+        "version": "?"
+      }, {
+        "class": "sun.reflect.NativeMethodAccessorImpl",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "sun.reflect.NativeMethodAccessorImpl",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "sun.reflect.DelegatingMethodAccessorImpl",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "java.lang.reflect.Method",
+        "method": "invoke",
+        "line": -1,
+        "exact": false,
+        "location": "?",
+        "version": "1.7.0_55"
+      }, {
+        "class": "org.junit.runners.model.FrameworkMethod$1",
+        "method": "runReflectiveCall",
+        "file": "FrameworkMethod.java",
+        "line": 47,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.model.ReflectiveCallable",
+        "method": "run",
+        "file": "ReflectiveCallable.java",
+        "line": 12,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.model.FrameworkMethod",
+        "method": "invokeExplosively",
+        "file": "FrameworkMethod.java",
+        "line": 44,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.statements.InvokeMethod",
+        "method": "evaluate",
+        "file": "InvokeMethod.java",
+        "line": 17,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "runLeaf",
+        "file": "ParentRunner.java",
+        "line": 271,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.BlockJUnit4ClassRunner",
+        "method": "runChild",
+        "file": "BlockJUnit4ClassRunner.java",
+        "line": 70,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.BlockJUnit4ClassRunner",
+        "method": "runChild",
+        "file": "BlockJUnit4ClassRunner.java",
+        "line": 50,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner$3",
+        "method": "run",
+        "file": "ParentRunner.java",
+        "line": 238,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner$1",
+        "method": "schedule",
+        "file": "ParentRunner.java",
+        "line": 63,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "runChildren",
+        "file": "ParentRunner.java",
+        "line": 236,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "access$000",
+        "file": "ParentRunner.java",
+        "line": 53,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner$2",
+        "method": "evaluate",
+        "file": "ParentRunner.java",
+        "line": 229,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.statements.RunBefores",
+        "method": "evaluate",
+        "file": "RunBefores.java",
+        "line": 26,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.internal.runners.statements.RunAfters",
+        "method": "evaluate",
+        "file": "RunAfters.java",
+        "line": 27,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.junit.runners.ParentRunner",
+        "method": "run",
+        "file": "ParentRunner.java",
+        "line": 309,
+        "exact": true,
+        "location": "junit-4.11.jar",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference",
+        "method": "run",
+        "file": "JUnit4TestReference.java",
+        "line": 50,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.TestExecution",
+        "method": "run",
+        "file": "TestExecution.java",
+        "line": 38,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "runTests",
+        "file": "RemoteTestRunner.java",
+        "line": 467,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "runTests",
+        "file": "RemoteTestRunner.java",
+        "line": 683,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "run",
+        "file": "RemoteTestRunner.java",
+        "line": 390,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }, {
+        "class": "org.eclipse.jdt.internal.junit.runner.RemoteTestRunner",
+        "method": "main",
+        "file": "RemoteTestRunner.java",
+        "line": 197,
+        "exact": true,
+        "location": ".cp/",
+        "version": "?"
+      }],
+      "localizedMessage": "I am suppressed exception 2",
+      "message": "I am suppressed exception 2",
+      "name": "java.lang.IndexOutOfBoundsException"
+    }]
+  },
+  "loggerFQCN": "f.q.c.n",
+  "endOfBatch": false,
+  "contextMap": [{
+    "key": "MDC.B",
+    "value": "B_Value"
+  }, {
+    "key": "MDC.A",
+    "value": "A_Value"
+  }],
+  "contextStack": ["stack_msg1", "stack_msg2"],
+  "source": {
+    "class": "org.apache.logging.log4j.core.layout.LogEventFixtures",
+    "method": "createLogEvent",
+    "file": "LogEventFixtures.java",
+    "line": 54
+  }
+}
+ * </pre>
  * <p>
- * If {@code complete="false"}, the appender does not write the JSON open array character "[" at the start of the document.
- * and "]" and the end.
+ * If {@code complete="false"}, the appender does not write the JSON open array character "[" at the start of the document. and "]" and the
+ * end.
  * </p>
  * <p>
  * This approach enforces the independence of the JSONLayout and the appender where you embed it.
  * </p>
  * <h4>Encoding</h4>
  * <p>
- * Appenders using this layout should have their {@code charset} set to {@code UTF-8} or {@code UTF-16}, otherwise
- * events containing non ASCII characters could result in corrupted log files.
+ * Appenders using this layout should have their {@code charset} set to {@code UTF-8} or {@code UTF-16}, otherwise events containing non
+ * ASCII characters could result in corrupted log files.
  * </p>
  * <h4>Pretty vs. compact XML</h4>
  * <p>
- * By default, the JSON layout is not compact (a.k.a. not "pretty") with {@code compact="false"}, which means the
- * appender uses end-of-line characters and indents lines to format the text. If {@code compact="true"}, then no
- * end-of-line or indentation is used. Message content may contain, of course, escaped end-of-lines.
+ * By default, the JSON layout is not compact (a.k.a. not "pretty") with {@code compact="false"}, which means the appender uses end-of-line
+ * characters and indents lines to format the text. If {@code compact="true"}, then no end-of-line or indentation is used. Message content
+ * may contain, of course, escaped end-of-lines.
  * </p>
  */
 @Plugin(name = "JSONLayout", category = "Core", elementType = "layout", printObject = true)
-public class JSONLayout extends AbstractStringLayout {
-
-    private static final int DEFAULT_SIZE = 256;
+public class JSONLayout extends AbstractJacksonLayout {
 
-    // We yield to \r\n for the default.
-    private static final String DEFAULT_EOL = "\r\n";
-    private static final String COMPACT_EOL = "";
-    private static final String DEFAULT_INDENT = "  ";
-    private static final String COMPACT_INDENT = "";
-
-    private static final String[] FORMATS = new String[] { "json" };
-
-    private final boolean locationInfo;
-    private final boolean properties;
-    private final boolean complete;
-    private final String eol;
-    private final String indent1;
-    private final String indent2;
-    private final String indent3;
-    private final String indent4;
-    private volatile boolean firstLayoutDone;
-
-    protected JSONLayout(final boolean locationInfo, final boolean properties, final boolean complete, boolean compact,
+    protected JSONLayout(final boolean locationInfo, final boolean properties, final boolean complete, final boolean compact,
             final Charset charset) {
-        super(charset);
-        this.locationInfo = locationInfo;
-        this.properties = properties;
-        this.complete = complete;
-        this.eol = compact ? COMPACT_EOL : DEFAULT_EOL;
-        this.indent1 = compact ? COMPACT_INDENT : DEFAULT_INDENT;
-        this.indent2 = this.indent1 + this.indent1;
-        this.indent3 = this.indent2 + this.indent1;
-        this.indent4 = this.indent3 + this.indent1;
-    }
-
-    /**
-     * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.
-     *
-     * @param event
-     *            The LogEvent.
-     * @return The XML representation of the LogEvent.
-     */
-    @Override
-    public String toSerializable(final LogEvent event) {
-        final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);
-        // DC locking to avoid synchronizing the whole layout.
-        boolean check = this.firstLayoutDone;
-        if (!this.firstLayoutDone) {
-            synchronized(this) {
-                check = this.firstLayoutDone;
-                if (!check) {
-                    this.firstLayoutDone = true;
-                } else {
-                    buf.append(',');
-                    buf.append(this.eol);
-                }
-            }
-        } else {
-            buf.append(',');
-            buf.append(this.eol);
-        }
-        buf.append(this.indent1);
-        buf.append('{');
-        buf.append(this.eol);
-        buf.append(this.indent2);
-        buf.append("\"logger\":\"");
-        String name = event.getLoggerName();
-        if (name.isEmpty()) {
-            name = "root";
-        }
-        buf.append(Transform.escapeJsonControlCharacters(name));
-        buf.append("\",");
-        buf.append(this.eol);
-        buf.append(this.indent2);
-        buf.append("\"timestamp\":\"");
-        buf.append(event.getTimeMillis());
-        buf.append("\",");
-        buf.append(this.eol);
-        buf.append(this.indent2);
-        buf.append("\"level\":\"");
-        buf.append(Transform.escapeJsonControlCharacters(String.valueOf(event.getLevel())));
-        buf.append("\",");
-        buf.append(this.eol);
-        buf.append(this.indent2);
-        buf.append("\"thread\":\"");
-        buf.append(Transform.escapeJsonControlCharacters(event.getThreadName()));
-        buf.append("\",");
-        buf.append(this.eol);
-
-        final Message msg = event.getMessage();
-        if (msg != null) {
-            boolean jsonSupported = false;
-            if (msg instanceof MultiformatMessage) {
-                final String[] formats = ((MultiformatMessage) msg).getFormats();
-                for (final String format : formats) {
-                    if (format.equalsIgnoreCase("JSON")) {
-                        jsonSupported = true;
-                        break;
-                    }
-                }
-            }
-            buf.append(this.indent2);
-            buf.append("\"message\":\"");
-            if (jsonSupported) {
-                buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));
-            } else {
-                buf.append(Transform.escapeJsonControlCharacters(event.getMessage().getFormattedMessage()));
-            }
-            buf.append('\"');
-        }
-
-        if (event.getContextStack().getDepth() > 0) {
-            buf.append(',');
-            buf.append(this.eol);
-            buf.append("\"ndc\":");
-            buf.append(Transform.escapeJsonControlCharacters(event.getContextStack().toString()));
-            buf.append('"');
-        }
-
-        final Throwable throwable = event.getThrown();
-        if (throwable != null) {
-            buf.append(',');
-            buf.append(this.eol);
-            buf.append(this.indent2);
-            buf.append("\"throwable\":\"");
-            final List<String> list = Throwables.toStringList(throwable);
-            for (final String str : list) {
-                buf.append(Transform.escapeJsonControlCharacters(str));
-                buf.append("\\\\n");
-            }
-            buf.append('"');
-        }
-
-        if (this.locationInfo) {
-            final StackTraceElement element = event.getSource();
-            buf.append(',');
-            buf.append(this.eol);
-            buf.append(this.indent2);
-            buf.append("\"LocationInfo\":{");
-            buf.append(this.eol);
-            buf.append(this.indent3);
-            buf.append("\"class\":\"");
-            buf.append(Transform.escapeJsonControlCharacters(element.getClassName()));
-            buf.append("\",");
-            buf.append(this.eol);
-            buf.append(this.indent3);
-            buf.append("\"method\":\"");
-            buf.append(Transform.escapeJsonControlCharacters(element.getMethodName()));
-            buf.append("\",");
-            buf.append(this.eol);
-            buf.append(this.indent3);
-            buf.append("\"file\":\"");
-            buf.append(Transform.escapeJsonControlCharacters(element.getFileName()));
-            buf.append("\",");
-            buf.append(this.eol);
-            buf.append(this.indent3);
-            buf.append("\"line\":\"");
-            buf.append(element.getLineNumber());
-            buf.append('"');
-            buf.append(this.eol);
-            buf.append(this.indent2);
-            buf.append('}');
-        }
-
-        if (this.properties && event.getContextMap().size() > 0) {
-            buf.append(',');
-            buf.append(this.eol);
-            buf.append(this.indent2);
-            buf.append("\"Properties\": {");
-            final Set<Entry<String, String>> entrySet = event.getContextMap().entrySet();
-            int i = 1;
-            for (final Map.Entry<String, String> entry : entrySet) {
-                buf.append(this.eol);
-                buf.append(this.indent3);
-                buf.append("\"");
-                buf.append(Transform.escapeJsonControlCharacters(entry.getKey()));
-                buf.append("\": \"");
-                buf.append(Transform.escapeJsonControlCharacters(String.valueOf(entry.getValue())));
-                buf.append("\"");
-                if (i < entrySet.size()) {
-                    buf.append(',');
-                }
-                i++;
-            }
-            buf.append(this.eol);
-            buf.append(this.indent2);
-            buf.append('}');
-        }
-
-        buf.append(this.eol);
-        buf.append(this.indent1);
-        buf.append('}');
-
-        return buf.toString();
+        super(new JacksonFactory.JSON().newWriter(locationInfo, properties, compact), charset, compact, complete);
     }
 
     /**
      * Returns appropriate JSON headers.
-     *
+     * 
      * @return a byte array containing the header, opening the JSON array.
      */
     @Override
@@ -299,7 +815,7 @@ public class JSONLayout extends AbstractStringLayout {
 
     /**
      * Returns appropriate JSON footer.
-     *
+     * 
      * @return a byte array containing the footer, closing the JSON array.
      */
     @Override
@@ -310,15 +826,6 @@ public class JSONLayout extends AbstractStringLayout {
         return (this.eol + ']' + this.eol).getBytes(this.getCharset());
     }
 
-    /**
-     * XMLLayout's content format is specified by:
-     * <p/>
-     * Key: "dtd" Value: "log4j-events.dtd"
-     * <p/>
-     * Key: "version" Value: "2.0"
-     *
-     * @return Map of content format keys supporting XMLLayout
-     */
     @Override
     public Map<String, String> getContentFormat() {
         final Map<String, String> result = new HashMap<String, String>();
@@ -336,26 +843,24 @@ public class JSONLayout extends AbstractStringLayout {
 
     /**
      * Creates an XML Layout.
-     *
-     * @param locationInfo
-     *            If "true", includes the location information in the generated JSON.
-     * @param properties
-     *            If "true", includes the thread context in the generated JSON.
-     * @param completeStr
-     *            If "true", includes the JSON header and footer, defaults to "false".
-     * @param compactStr
-     *            If "true", does not use end-of-lines and indentation, defaults to "false".
-     * @param charsetName
-     *            The character set to use, if {@code null}, uses "UTF-8".
+     * 
+     * @param locationInfo If "true", includes the location information in the generated JSON.
+     * @param properties If "true", includes the thread context in the generated JSON.
+     * @param completeStr If "true", includes the JSON header and footer, defaults to "false".
+     * @param compactStr If "true", does not use end-of-lines and indentation, defaults to "false".
+     * @param charsetName The character set to use, if {@code null}, uses "UTF-8".
      * @return An XML Layout.
      */
     @PluginFactory
-    public static JSONLayout createLayout(
+    public static AbstractJacksonLayout createLayout(
+            // @formatter:off
             @PluginAttribute("locationInfo") final String locationInfo,
             @PluginAttribute("properties") final String properties,
-            @PluginAttribute("complete") final String completeStr,
+            @PluginAttribute("complete") final String completeStr, 
             @PluginAttribute("compact") final String compactStr,
-            @PluginAttribute("charset") final String charsetName) {
+            @PluginAttribute("charset") final String charsetName
+            // @formatter:on
+    ) {
         final Charset charset = Charsets.getSupportedCharset(charsetName, Charsets.UTF_8);
         final boolean info = Boolean.parseBoolean(locationInfo);
         final boolean props = Boolean.parseBoolean(properties);
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java
new file mode 100644
index 0000000000..223e5db837
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/JacksonFactory.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.layout;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.logging.log4j.core.impl.Log4jLogEvent;
+import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;
+import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;
+
+import com.fasterxml.jackson.core.PrettyPrinter;
+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
+import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectWriter;
+import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
+import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
+import com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;
+
+abstract class JacksonFactory {
+
+    static class JSON extends JacksonFactory {
+
+        @Override
+        protected String getPropertNameForContextMap() {
+            return JSONConstants.PROP_CONTEXT_MAP;
+        }
+
+        @Override
+        protected String getPropertNameForSource() {
+            return JSONConstants.PROP_SOURCE;
+        }
+
+        @Override
+        protected PrettyPrinter newCompactPrinter() {
+            return new MinimalPrettyPrinter();
+        }
+
+        @Override
+        protected ObjectMapper newObjectMapper() {
+            return new Log4jJsonObjectMapper();
+        }
+
+        @Override
+        protected PrettyPrinter newPrettyPrinter() {
+            return new DefaultPrettyPrinter();
+        }
+    }
+
+    static class XML extends JacksonFactory {
+
+        @Override
+        protected String getPropertNameForContextMap() {
+            return XMLConstants.TAG_CONTEXT_MAP;
+        }
+
+        @Override
+        protected String getPropertNameForSource() {
+            return XMLConstants.TAG_SOURCE;
+        }
+
+        @Override
+        protected PrettyPrinter newCompactPrinter() {
+            // Yes, null is the proper answer.
+            return null;
+        }
+
+        @Override
+        protected ObjectMapper newObjectMapper() {
+            return new Log4jXmlObjectMapper();
+        }
+
+        @Override
+        protected PrettyPrinter newPrettyPrinter() {
+            return new DefaultXmlPrettyPrinter();
+        }
+    }
+
+    abstract protected String getPropertNameForContextMap();
+
+    abstract protected String getPropertNameForSource();
+
+    abstract protected PrettyPrinter newCompactPrinter();
+
+    abstract protected ObjectMapper newObjectMapper();
+
+    abstract protected PrettyPrinter newPrettyPrinter();
+
+    ObjectWriter newWriter(final boolean locationInfo, final boolean properties, final boolean compact) {
+        final SimpleFilterProvider filters = new SimpleFilterProvider();
+        final Set<String> except = new HashSet<String>(2);
+        if (!locationInfo) {
+            except.add(this.getPropertNameForSource());
+        }
+        if (!properties) {
+            except.add(this.getPropertNameForContextMap());
+        }
+        filters.addFilter(Log4jLogEvent.class.getName(), SimpleBeanPropertyFilter.serializeAllExcept(except));
+        final ObjectWriter writer = this.newObjectMapper().writer(compact ? this.newCompactPrinter() : this.newPrettyPrinter());
+        return writer.with(filters);
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/JSONLogEventInput.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLConstants.java
similarity index 64%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/JSONLogEventInput.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLConstants.java
index e80ea3e961..c261ff84a6 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/JSONLogEventInput.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLConstants.java
@@ -14,21 +14,13 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-import org.apache.logging.log4j.core.LogEvent;
+package org.apache.logging.log4j.core.layout;
 
 /**
- * Reads JSON {@link LogEvent}s.
+ * Keeps constants separate from any class that may depend on third party jars.
  */
-public class JSONLogEventInput extends AbstractLogEventInput<InputStream> {
-
-    @Override
-    public LogEvent readLogEvent(final InputStream inputStream) throws IOException {
-        throw new UnsupportedOperationException("Not implemented yet");
-    }
-
-}
+public class XMLConstants {
+    public static final String TAG_SOURCE = "Source";
+    public static final String TAG_CONTEXT_MAP = "ContextMap";
+    public static final String XML_NAMESPACE = "http://logging.apache.org/log4j/2.0/events";
+}
\ No newline at end of file
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java
index 8be641ea41..cdd521370f 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/layout/XMLLayout.java
@@ -18,47 +18,153 @@ package org.apache.logging.log4j.core.layout;
 
 import java.nio.charset.Charset;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
-import org.apache.logging.log4j.Marker;
-import org.apache.logging.log4j.core.LogEvent;
 import org.apache.logging.log4j.core.config.plugins.Plugin;
 import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
 import org.apache.logging.log4j.core.config.plugins.PluginFactory;
 import org.apache.logging.log4j.core.helpers.Charsets;
-import org.apache.logging.log4j.core.helpers.Strings;
-import org.apache.logging.log4j.core.helpers.Throwables;
-import org.apache.logging.log4j.core.helpers.Transform;
-import org.apache.logging.log4j.message.Message;
-import org.apache.logging.log4j.message.MultiformatMessage;
-
 
 /**
  * Appends a series of {@code event} elements as defined in the <a href="log4j.dtd">log4j.dtd</a>.
- *
+ * 
  * <h4>Complete well-formed XML vs. fragment XML</h4>
  * <p>
- * If you configure {@code complete="true"}, the appender outputs a well-formed XML document where the default namespace
- * is the log4j namespace {@value #XML_NAMESPACE}. By default, with {@code complete="false"}, you should include the
- * output as an <em>external entity</em> in a separate file to form a well-formed XML document, in which case the
- * appender uses {@code namespacePrefix} with a default of {@value #DEFAULT_NS_PREFIX}.
+ * If you configure {@code complete="true"}, the appender outputs a well-formed XML document where the default namespace is the log4j
+ * namespace {@value XMLConstants#XML_NAMESPACE}. By default, with {@code complete="false"}, you should include the output as an
+ * <em>external entity</em> in a separate file to form a well-formed XML document.
  * </p>
  * <p>
  * A well-formed XML document follows this pattern:
  * </p>
- *
  * <pre>
- * &lt;?xml version="1.0" encoding=&quotUTF-8&quot?&gt;
- * &lt;Events xmlns="http://logging.apache.org/log4j/2.0/events"&gt;
- * &nbsp;&nbsp;&lt;Event logger="com.foo.Bar" timestamp="1373436580419" level="INFO" thread="main"&gt;
- * &nbsp;&nbsp;&nbsp;&nbsp;&lt;Message>&lt;![CDATA[This is a log message 1]]&gt;&lt;/Message&gt;
- * &nbsp;&nbsp;&lt;/Event&gt;
- * &nbsp;&nbsp;&lt;Event logger="com.foo.Baz" timestamp="1373436580420" level="INFO" thread="main"&gt;
- * &nbsp;&nbsp;&nbsp;&nbsp;&lt;Message>&lt;![CDATA[This is a log message 2]]&gt;&lt;/Message&gt;
- * &nbsp;&nbsp;&lt;/Event&gt;
- * &lt;/Events&gt;
- * </pre>
+&lt;Event xmlns=&quot;http://logging.apache.org/log4j/2.0/events&quot; timeMillis=&quot;1&quot; thread=&quot;MyThreadName&quot; level=&quot;DEBUG&quot; loggerName=&quot;a.B&quot; loggerFQCN=&quot;f.q.c.n&quot; endOfBatch=&quot;false&quot;&gt;
+    &lt;Marker name=&quot;Marker1&quot;&gt;
+        &lt;Parents&gt;
+            &lt;Parents name=&quot;ParentMarker1&quot;&gt;
+                &lt;Parents&gt;
+                    &lt;Parents name=&quot;GrandMotherMarker&quot;/&gt;
+                    &lt;Parents name=&quot;GrandFatherMarker&quot;/&gt;
+                &lt;/Parents&gt;
+            &lt;/Parents&gt;
+            &lt;Parents name=&quot;GrandFatherMarker&quot;/&gt;
+        &lt;/Parents&gt;
+    &lt;/Marker&gt;
+    &lt;Message&gt;Msg&lt;/Message&gt;
+    &lt;ContextMap&gt;
+        &lt;item key=&quot;MDC.B&quot; value=&quot;B_Value&quot;/&gt;
+        &lt;item key=&quot;MDC.A&quot; value=&quot;A_Value&quot;/&gt;
+    &lt;/ContextMap&gt;
+    &lt;ContextStack&gt;
+        &lt;ContextStack&gt;stack_msg1&lt;/ContextStack&gt;
+        &lt;ContextStack&gt;stack_msg2&lt;/ContextStack&gt;
+    &lt;/ContextStack&gt;
+    &lt;Source class=&quot;org.apache.logging.log4j.core.layout.LogEventFixtures&quot; method=&quot;createLogEvent&quot; file=&quot;LogEventFixtures.java&quot; line=&quot;54&quot;/&gt;
+    &lt;Thrown commonElementCount=&quot;0&quot; localizedMessage=&quot;testIOEx&quot; message=&quot;testIOEx&quot; name=&quot;java.io.IOException&quot;&gt;
+        &lt;Cause commonElementCount=&quot;27&quot; localizedMessage=&quot;testNPEx&quot; message=&quot;testNPEx&quot; name=&quot;java.lang.NullPointerException&quot;&gt;
+            &lt;ExtendedStackTrace&gt;
+                &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.LogEventFixtures&quot; method=&quot;createLogEvent&quot; file=&quot;LogEventFixtures.java&quot; line=&quot;53&quot; exact=&quot;false&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+            &lt;/ExtendedStackTrace&gt;
+        &lt;/Cause&gt;
+        &lt;ExtendedStackTrace&gt;
+            &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.LogEventFixtures&quot; method=&quot;createLogEvent&quot; file=&quot;LogEventFixtures.java&quot; line=&quot;56&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.XMLLayoutTest&quot; method=&quot;testAllFeatures&quot; file=&quot;XMLLayoutTest.java&quot; line=&quot;122&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.XMLLayoutTest&quot; method=&quot;testLocationOnCompactOnMdcOn&quot; file=&quot;XMLLayoutTest.java&quot; line=&quot;270&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;sun.reflect.NativeMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;sun.reflect.NativeMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;sun.reflect.DelegatingMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;java.lang.reflect.Method&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.model.FrameworkMethod$1&quot; method=&quot;runReflectiveCall&quot; file=&quot;FrameworkMethod.java&quot; line=&quot;47&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.model.ReflectiveCallable&quot; method=&quot;run&quot; file=&quot;ReflectiveCallable.java&quot; line=&quot;12&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.model.FrameworkMethod&quot; method=&quot;invokeExplosively&quot; file=&quot;FrameworkMethod.java&quot; line=&quot;44&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.InvokeMethod&quot; method=&quot;evaluate&quot; file=&quot;InvokeMethod.java&quot; line=&quot;17&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;runLeaf&quot; file=&quot;ParentRunner.java&quot; line=&quot;271&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.BlockJUnit4ClassRunner&quot; method=&quot;runChild&quot; file=&quot;BlockJUnit4ClassRunner.java&quot; line=&quot;70&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.BlockJUnit4ClassRunner&quot; method=&quot;runChild&quot; file=&quot;BlockJUnit4ClassRunner.java&quot; line=&quot;50&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$3&quot; method=&quot;run&quot; file=&quot;ParentRunner.java&quot; line=&quot;238&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$1&quot; method=&quot;schedule&quot; file=&quot;ParentRunner.java&quot; line=&quot;63&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;runChildren&quot; file=&quot;ParentRunner.java&quot; line=&quot;236&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;access$000&quot; file=&quot;ParentRunner.java&quot; line=&quot;53&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$2&quot; method=&quot;evaluate&quot; file=&quot;ParentRunner.java&quot; line=&quot;229&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.RunBefores&quot; method=&quot;evaluate&quot; file=&quot;RunBefores.java&quot; line=&quot;26&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.RunAfters&quot; method=&quot;evaluate&quot; file=&quot;RunAfters.java&quot; line=&quot;27&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;run&quot; file=&quot;ParentRunner.java&quot; line=&quot;309&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference&quot; method=&quot;run&quot; file=&quot;JUnit4TestReference.java&quot; line=&quot;50&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.TestExecution&quot; method=&quot;run&quot; file=&quot;TestExecution.java&quot; line=&quot;38&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;runTests&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;467&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;runTests&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;683&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;run&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;390&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+            &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;main&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;197&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+        &lt;/ExtendedStackTrace&gt;
+        &lt;Suppressed&gt;
+            &lt;Suppressed commonElementCount=&quot;0&quot; localizedMessage=&quot;I am suppressed exception 1&quot; message=&quot;I am suppressed exception 1&quot; name=&quot;java.lang.IndexOutOfBoundsException&quot;&gt;
+                &lt;ExtendedStackTrace&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.LogEventFixtures&quot; method=&quot;createLogEvent&quot; file=&quot;LogEventFixtures.java&quot; line=&quot;57&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.XMLLayoutTest&quot; method=&quot;testAllFeatures&quot; file=&quot;XMLLayoutTest.java&quot; line=&quot;122&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.XMLLayoutTest&quot; method=&quot;testLocationOnCompactOnMdcOn&quot; file=&quot;XMLLayoutTest.java&quot; line=&quot;270&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;sun.reflect.NativeMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;sun.reflect.NativeMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;sun.reflect.DelegatingMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;java.lang.reflect.Method&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.model.FrameworkMethod$1&quot; method=&quot;runReflectiveCall&quot; file=&quot;FrameworkMethod.java&quot; line=&quot;47&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.model.ReflectiveCallable&quot; method=&quot;run&quot; file=&quot;ReflectiveCallable.java&quot; line=&quot;12&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.model.FrameworkMethod&quot; method=&quot;invokeExplosively&quot; file=&quot;FrameworkMethod.java&quot; line=&quot;44&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.InvokeMethod&quot; method=&quot;evaluate&quot; file=&quot;InvokeMethod.java&quot; line=&quot;17&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;runLeaf&quot; file=&quot;ParentRunner.java&quot; line=&quot;271&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.BlockJUnit4ClassRunner&quot; method=&quot;runChild&quot; file=&quot;BlockJUnit4ClassRunner.java&quot; line=&quot;70&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.BlockJUnit4ClassRunner&quot; method=&quot;runChild&quot; file=&quot;BlockJUnit4ClassRunner.java&quot; line=&quot;50&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$3&quot; method=&quot;run&quot; file=&quot;ParentRunner.java&quot; line=&quot;238&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$1&quot; method=&quot;schedule&quot; file=&quot;ParentRunner.java&quot; line=&quot;63&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;runChildren&quot; file=&quot;ParentRunner.java&quot; line=&quot;236&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;access$000&quot; file=&quot;ParentRunner.java&quot; line=&quot;53&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$2&quot; method=&quot;evaluate&quot; file=&quot;ParentRunner.java&quot; line=&quot;229&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.RunBefores&quot; method=&quot;evaluate&quot; file=&quot;RunBefores.java&quot; line=&quot;26&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.RunAfters&quot; method=&quot;evaluate&quot; file=&quot;RunAfters.java&quot; line=&quot;27&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;run&quot; file=&quot;ParentRunner.java&quot; line=&quot;309&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference&quot; method=&quot;run&quot; file=&quot;JUnit4TestReference.java&quot; line=&quot;50&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.TestExecution&quot; method=&quot;run&quot; file=&quot;TestExecution.java&quot; line=&quot;38&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;runTests&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;467&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;runTests&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;683&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;run&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;390&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;main&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;197&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                &lt;/ExtendedStackTrace&gt;
+            &lt;/Suppressed&gt;
+            &lt;Suppressed commonElementCount=&quot;0&quot; localizedMessage=&quot;I am suppressed exception 2&quot; message=&quot;I am suppressed exception 2&quot; name=&quot;java.lang.IndexOutOfBoundsException&quot;&gt;
+                &lt;ExtendedStackTrace&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.LogEventFixtures&quot; method=&quot;createLogEvent&quot; file=&quot;LogEventFixtures.java&quot; line=&quot;58&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.XMLLayoutTest&quot; method=&quot;testAllFeatures&quot; file=&quot;XMLLayoutTest.java&quot; line=&quot;122&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.apache.logging.log4j.core.layout.XMLLayoutTest&quot; method=&quot;testLocationOnCompactOnMdcOn&quot; file=&quot;XMLLayoutTest.java&quot; line=&quot;270&quot; exact=&quot;true&quot; location=&quot;test-classes/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;sun.reflect.NativeMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;sun.reflect.NativeMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;sun.reflect.DelegatingMethodAccessorImpl&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;java.lang.reflect.Method&quot; method=&quot;invoke&quot; line=&quot;-1&quot; exact=&quot;false&quot; location=&quot;?&quot; version=&quot;1.7.0_55&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.model.FrameworkMethod$1&quot; method=&quot;runReflectiveCall&quot; file=&quot;FrameworkMethod.java&quot; line=&quot;47&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.model.ReflectiveCallable&quot; method=&quot;run&quot; file=&quot;ReflectiveCallable.java&quot; line=&quot;12&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.model.FrameworkMethod&quot; method=&quot;invokeExplosively&quot; file=&quot;FrameworkMethod.java&quot; line=&quot;44&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.InvokeMethod&quot; method=&quot;evaluate&quot; file=&quot;InvokeMethod.java&quot; line=&quot;17&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;runLeaf&quot; file=&quot;ParentRunner.java&quot; line=&quot;271&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.BlockJUnit4ClassRunner&quot; method=&quot;runChild&quot; file=&quot;BlockJUnit4ClassRunner.java&quot; line=&quot;70&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.BlockJUnit4ClassRunner&quot; method=&quot;runChild&quot; file=&quot;BlockJUnit4ClassRunner.java&quot; line=&quot;50&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$3&quot; method=&quot;run&quot; file=&quot;ParentRunner.java&quot; line=&quot;238&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$1&quot; method=&quot;schedule&quot; file=&quot;ParentRunner.java&quot; line=&quot;63&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;runChildren&quot; file=&quot;ParentRunner.java&quot; line=&quot;236&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;access$000&quot; file=&quot;ParentRunner.java&quot; line=&quot;53&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner$2&quot; method=&quot;evaluate&quot; file=&quot;ParentRunner.java&quot; line=&quot;229&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.RunBefores&quot; method=&quot;evaluate&quot; file=&quot;RunBefores.java&quot; line=&quot;26&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.internal.runners.statements.RunAfters&quot; method=&quot;evaluate&quot; file=&quot;RunAfters.java&quot; line=&quot;27&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.junit.runners.ParentRunner&quot; method=&quot;run&quot; file=&quot;ParentRunner.java&quot; line=&quot;309&quot; exact=&quot;true&quot; location=&quot;junit-4.11.jar&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference&quot; method=&quot;run&quot; file=&quot;JUnit4TestReference.java&quot; line=&quot;50&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.TestExecution&quot; method=&quot;run&quot; file=&quot;TestExecution.java&quot; line=&quot;38&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;runTests&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;467&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;runTests&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;683&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;run&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;390&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                    &lt;ExtendedStackTrace class=&quot;org.eclipse.jdt.internal.junit.runner.RemoteTestRunner&quot; method=&quot;main&quot; file=&quot;RemoteTestRunner.java&quot; line=&quot;197&quot; exact=&quot;true&quot; location=&quot;.cp/&quot; version=&quot;?&quot;/&gt;
+                &lt;/ExtendedStackTrace&gt;
+            &lt;/Suppressed&gt;
+        &lt;/Suppressed&gt;
+    &lt;/Thrown&gt;
+&lt;/Event&gt;
+</pre>
  * <p>
  * If {@code complete="false"}, the appender does not write the XML processing instruction and the root element.
  * </p>
@@ -67,244 +173,23 @@ import org.apache.logging.log4j.message.MultiformatMessage;
  * </p>
  * <h4>Encoding</h4>
  * <p>
- * Appenders using this layout should have their {@code charset} set to {@code UTF-8} or {@code UTF-16}, otherwise
- * events containing non ASCII characters could result in corrupted log files.
+ * Appenders using this layout should have their {@code charset} set to {@code UTF-8} or {@code UTF-16}, otherwise events containing non
+ * ASCII characters could result in corrupted log files.
  * </p>
  * <h4>Pretty vs. compact XML</h4>
  * <p>
- * By default, the XML layout is not compact (a.k.a. not "pretty") with {@code compact="false"}, which means the
- * appender uses end-of-line characters and indents lines to format the XML. If {@code compact="true"}, then no
- * end-of-line or indentation is used. Message content may contain, of course, end-of-lines.
+ * By default, the XML layout is not compact (compact = not "pretty") with {@code compact="false"}, which means the appender uses
+ * end-of-line characters and indents lines to format the XML. If {@code compact="true"}, then no end-of-line or indentation is used.
+ * Message content may contain, of course, end-of-lines.
  * </p>
  */
 @Plugin(name = "XMLLayout", category = "Core", elementType = "layout", printObject = true)
-public class XMLLayout extends AbstractStringLayout {
+public class XMLLayout extends AbstractJacksonLayout {
 
-    private static final String XML_NAMESPACE = "http://logging.apache.org/log4j/2.0/events";
     private static final String ROOT_TAG = "Events";
-    private static final int DEFAULT_SIZE = 256;
-
-    // We yield to \r\n for the default.
-    private static final String DEFAULT_EOL = "\r\n";
-    private static final String COMPACT_EOL = "";
-    private static final String DEFAULT_INDENT = "  ";
-    private static final String COMPACT_INDENT = "";
-    private static final String DEFAULT_NS_PREFIX = "log4j";
-
-    private static final String[] FORMATS = new String[] {"xml"};
 
-    private final boolean locationInfo;
-    private final boolean properties;
-    private final boolean complete;
-    private final String namespacePrefix;
-    private final String eol;
-    private final String indent1;
-    private final String indent2;
-    private final String indent3;
-
-    protected XMLLayout(final boolean locationInfo, final boolean properties, final boolean complete,
-                        boolean compact, final String nsPrefix, final Charset charset) {
-        super(charset);
-        this.locationInfo = locationInfo;
-        this.properties = properties;
-        this.complete = complete;
-        this.eol = compact ? COMPACT_EOL : DEFAULT_EOL;
-        this.indent1 = compact ? COMPACT_INDENT : DEFAULT_INDENT;
-        this.indent2 = this.indent1 + this.indent1;
-        this.indent3 = this.indent2 + this.indent1;
-        this.namespacePrefix = (Strings.isEmpty(nsPrefix) ? DEFAULT_NS_PREFIX : nsPrefix) + ':';
-    }
-
-    /**
-     * Formats a {@link org.apache.logging.log4j.core.LogEvent} in conformance with the log4j.dtd.
-     *
-     * @param event The LogEvent.
-     * @return The XML representation of the LogEvent.
-     */
-    @Override
-    public String toSerializable(final LogEvent event) {
-        final StringBuilder buf = new StringBuilder(DEFAULT_SIZE);
-
-        buf.append(this.indent1);
-        buf.append('<');
-        if (!complete) {
-            buf.append(this.namespacePrefix);
-        }
-        buf.append("Event logger=\"");
-        String name = event.getLoggerName();
-        if (name.isEmpty()) {
-            name = "root";
-        }
-        buf.append(Transform.escapeHtmlTags(name));
-        buf.append("\" timestamp=\"");
-        buf.append(event.getTimeMillis());
-        buf.append("\" level=\"");
-        buf.append(Transform.escapeHtmlTags(String.valueOf(event.getLevel())));
-        buf.append("\" thread=\"");
-        buf.append(Transform.escapeHtmlTags(event.getThreadName()));
-        buf.append("\">");
-        buf.append(this.eol);
-
-        final Message msg = event.getMessage();
-        if (msg != null) {
-            boolean xmlSupported = false;
-            if (msg instanceof MultiformatMessage) {
-                final String[] formats = ((MultiformatMessage) msg).getFormats();
-                for (final String format : formats) {
-                    if (format.equalsIgnoreCase("XML")) {
-                        xmlSupported = true;
-                        break;
-                    }
-                }
-            }
-            buf.append(this.indent2);
-            buf.append('<');
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Message>");
-            if (xmlSupported) {
-                buf.append(((MultiformatMessage) msg).getFormattedMessage(FORMATS));
-            } else {
-                buf.append("<![CDATA[");
-                // Append the rendered message. Also make sure to escape any
-                // existing CDATA sections.
-                Transform.appendEscapingCDATA(buf, event.getMessage().getFormattedMessage());
-                buf.append("]]>");
-            }
-            buf.append("</");
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Message>");
-            buf.append(this.eol);
-        }
-
-        if (event.getContextStack().getDepth() > 0) {
-            buf.append(this.indent2);
-            buf.append('<');
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("NDC><![CDATA[");
-            Transform.appendEscapingCDATA(buf, event.getContextStack().toString());
-            buf.append("]]></");
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("NDC>");
-            buf.append(this.eol);
-        }
-
-        if (event.getMarker() != null) {
-            final Marker marker = event.getMarker();
-            buf.append(this.indent2);
-            buf.append('<');
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Marker");
-            final Marker[] parents = marker.getParents();
-            if (parents != null && parents.length > 0) {
-                buf.append(" parents=\"");
-                boolean first = true;
-                for (Marker parent : parents) {
-                    if (!first) {
-                        buf.append(", ");
-                    }
-                    buf.append(parent.getName());
-                }
-                buf.append("\"");
-            }
-            buf.append('>');
-            buf.append(Transform.escapeHtmlTags(marker.getName()));
-            buf.append("</");
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Marker>");
-            buf.append(this.eol);
-        }
-
-        final Throwable throwable = event.getThrown();
-        if (throwable != null) {
-            final List<String> s = Throwables.toStringList(throwable);
-            buf.append(this.indent2);
-            buf.append('<');
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Throwable><![CDATA[");
-            for (final String str : s) {
-                Transform.appendEscapingCDATA(buf, str);
-                buf.append(this.eol);
-            }
-            buf.append("]]></");
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Throwable>");
-            buf.append(this.eol);
-        }
-
-        if (locationInfo) {
-            final StackTraceElement element = event.getSource();
-            buf.append(this.indent2);
-            buf.append('<');
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("LocationInfo class=\"");
-            buf.append(Transform.escapeHtmlTags(element.getClassName()));
-            buf.append("\" method=\"");
-            buf.append(Transform.escapeHtmlTags(element.getMethodName()));
-            buf.append("\" file=\"");
-            buf.append(Transform.escapeHtmlTags(element.getFileName()));
-            buf.append("\" line=\"");
-            buf.append(element.getLineNumber());
-            buf.append("\"/>");
-            buf.append(this.eol);
-        }
-
-        if (properties && event.getContextMap().size() > 0) {
-            buf.append(this.indent2);
-            buf.append('<');
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Properties>");
-            buf.append(this.eol);
-            for (final Map.Entry<String, String> entry : event.getContextMap().entrySet()) {
-                buf.append(this.indent3);
-                buf.append('<');
-                if (!complete) {
-                    buf.append(this.namespacePrefix);
-                }
-                buf.append("Data name=\"");
-                buf.append(Transform.escapeHtmlTags(entry.getKey()));
-                buf.append("\" value=\"");
-                buf.append(Transform.escapeHtmlTags(String.valueOf(entry.getValue())));
-                buf.append("\"/>");
-                buf.append(this.eol);
-            }
-            buf.append(this.indent2);
-            buf.append("</");
-            if (!complete) {
-                buf.append(this.namespacePrefix);
-            }
-            buf.append("Properties>");
-            buf.append(this.eol);
-        }
-
-        buf.append(this.indent1);
-        buf.append("</");
-        if (!complete) {
-            buf.append(this.namespacePrefix);
-        }
-        buf.append("Event>");
-        buf.append(this.eol);
-
-        return buf.toString();
+    protected XMLLayout(final boolean locationInfo, final boolean properties, final boolean complete, boolean compact, final Charset charset) {
+        super(new JacksonFactory.XML().newWriter(locationInfo, properties, compact), charset, compact, complete);
     }
 
     /**
@@ -313,7 +198,7 @@ public class XMLLayout extends AbstractStringLayout {
      * <li>XML processing instruction</li>
      * <li>XML root element</li>
      * </ol>
-     *
+     * 
      * @return a byte array containing the header.
      */
     @Override
@@ -329,15 +214,14 @@ public class XMLLayout extends AbstractStringLayout {
         // Make the log4j namespace the default namespace, no need to use more space with a namespace prefix.
         buf.append('<');
         buf.append(ROOT_TAG);
-        buf.append(" xmlns=\"" + XML_NAMESPACE + "\">");
+        buf.append(" xmlns=\"" + XMLConstants.XML_NAMESPACE + "\">");
         buf.append(this.eol);
         return buf.toString().getBytes(this.getCharset());
     }
 
-
     /**
      * Returns appropriate XML footer.
-     *
+     * 
      * @return a byte array containing the footer, closing the XML root element.
      */
     @Override
@@ -349,15 +233,18 @@ public class XMLLayout extends AbstractStringLayout {
     }
 
     /**
-     * XMLLayout's content format is specified by:<p/>
-     * Key: "dtd" Value: "log4j-events.dtd"<p/>
+     * XMLLayout's content format is specified by:
+     * <p/>
+     * Key: "dtd" Value: "log4j-events.dtd"
+     * <p/>
      * Key: "version" Value: "2.0"
+     * 
      * @return Map of content format keys supporting XMLLayout
      */
     @Override
     public Map<String, String> getContentFormat() {
         final Map<String, String> result = new HashMap<String, String>();
-        //result.put("dtd", "log4j-events.dtd");
+        // result.put("dtd", "log4j-events.dtd");
         result.put("xsd", "log4j-events.xsd");
         result.put("version", "2.0");
         return result;
@@ -373,28 +260,29 @@ public class XMLLayout extends AbstractStringLayout {
 
     /**
      * Creates an XML Layout.
-     *
-     * @param locationInfo If "true", includes the location information in the generated XML.
-     * @param properties If "true", includes the thread context in the generated XML.
+     * 
+     * @param locationInfoStr If "true", includes the location information in the generated XML.
+     * @param propertiesStr If "true", includes the thread context in the generated XML.
      * @param completeStr If "true", includes the XML header and footer, defaults to "false".
      * @param compactStr If "true", does not use end-of-lines and indentation, defaults to "false".
-     * @param namespacePrefix The namespace prefix, defaults to {@value #DEFAULT_NS_PREFIX}
      * @param charsetName The character set to use, if {@code null}, uses "UTF-8".
      * @return An XML Layout.
      */
     @PluginFactory
     public static XMLLayout createLayout(
-            @PluginAttribute("locationInfo") final String locationInfo,
-            @PluginAttribute("properties") final String properties,
+            // @formatter:off
+            @PluginAttribute("locationInfo") final String locationInfoStr,
+            @PluginAttribute("properties") final String propertiesStr, 
             @PluginAttribute("complete") final String completeStr,
-            @PluginAttribute("compact") final String compactStr,
-            @PluginAttribute("namespacePrefix") final String namespacePrefix,
-            @PluginAttribute("charset") final String charsetName) {
+            @PluginAttribute("compact") final String compactStr, 
+            @PluginAttribute("charset") final String charsetName)
+            // @formatter:on
+    {
         final Charset charset = Charsets.getSupportedCharset(charsetName, Charsets.UTF_8);
-        final boolean info = Boolean.parseBoolean(locationInfo);
-        final boolean props = Boolean.parseBoolean(properties);
+        final boolean info = Boolean.parseBoolean(locationInfoStr);
+        final boolean props = Boolean.parseBoolean(propertiesStr);
         final boolean complete = Boolean.parseBoolean(completeStr);
         final boolean compact = Boolean.parseBoolean(compactStr);
-        return new XMLLayout(info, props, complete, compact, namespacePrefix, charset);
+        return new XMLLayout(info, props, complete, compact, charset);
     }
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/AbstractLogEventInput.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/AbstractLogEventBridge.java
similarity index 65%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/AbstractLogEventInput.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/AbstractLogEventBridge.java
index c8dd6561b6..59b889b2d0 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/AbstractLogEventInput.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/AbstractLogEventBridge.java
@@ -14,19 +14,27 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.status.StatusLogger;
+
 /**
- * Abstract class for implementations of {@link LogEventInput}.
+ * Abstract class for implementations of {@link LogEventBridge}.
  * 
- * @param <T> The kind of input stream read
+ * @param <T>
+ *            The kind of input stream read
  */
-public abstract class AbstractLogEventInput<T extends InputStream> implements LogEventInput<T> {
+public abstract class AbstractLogEventBridge<T extends InputStream> implements LogEventBridge<T> {
+
+    protected static final int END = -1;
+
+    protected static final Logger logger = StatusLogger.getLogger();
 
-    // @SuppressWarnings("unchecked"): The default is to return the same object as given.
+    // The default is to return the same object as given.
     @SuppressWarnings("unchecked")
     @Override
     public T wrapStream(final InputStream inputStream) throws IOException {
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/AbstractSocketServer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/AbstractSocketServer.java
similarity index 90%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/AbstractSocketServer.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/AbstractSocketServer.java
index 9ebc3ebed9..4dee740cec 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/AbstractSocketServer.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/AbstractSocketServer.java
@@ -14,7 +14,7 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -36,7 +36,8 @@ import org.apache.logging.log4j.core.helpers.Assert;
 /**
  * Abstract socket server for TCP and UDP implementations.
  * 
- * @param <T> The kind of input stream read
+ * @param <T>
+ *            The kind of input stream read
  */
 public abstract class AbstractSocketServer<T extends InputStream> extends LogEventListener {
 
@@ -87,21 +88,23 @@ public abstract class AbstractSocketServer<T extends InputStream> extends LogEve
         }
     }
 
-    protected final Logger logger;
-
     protected static final int MAX_PORT = 65534;
 
     private volatile boolean active = true;
 
-    protected final LogEventInput<T> logEventInput;
+    protected final LogEventBridge<T> logEventInput;
+
+    protected final Logger logger;
 
     /**
      * Creates a new socket server.
      * 
-     * @param port listen to this port
-     * @param logEventInput Use this input to read log events.
+     * @param port
+     *            listen to this port
+     * @param logEventInput
+     *            Use this input to read log events.
      */
-    public AbstractSocketServer(final int port, final LogEventInput<T> logEventInput) {
+    public AbstractSocketServer(final int port, final LogEventBridge<T> logEventInput) {
         this.logger = LogManager.getLogger(this.getClass().getName() + '.' + port);
         this.logEventInput = Assert.requireNonNull(logEventInput, "LogEventInput");
     }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/InputStreamLogEventBridge.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/InputStreamLogEventBridge.java
new file mode 100644
index 0000000000..a3f4c2c20c
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/InputStreamLogEventBridge.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.net.server;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.LogEventListener;
+import org.apache.logging.log4j.core.impl.Log4jLogEvent;
+import org.apache.logging.log4j.util.Strings;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+
+/**
+ * Reads and logs {@link LogEvent}s from an {@link InputStream}.
+ */
+public abstract class InputStreamLogEventBridge extends AbstractLogEventBridge<InputStream> {
+
+    private final int bufferSize;
+
+    private final Charset charset;
+
+    private final String eventEndMarker;
+    
+    private final ObjectReader objectReader;
+    
+    public InputStreamLogEventBridge(ObjectMapper mapper, final int bufferSize, final Charset charset, final String eventEndMarker) {
+        this.bufferSize = bufferSize;
+        this.charset = charset;
+        this.eventEndMarker = eventEndMarker;
+        this.objectReader = mapper.reader(Log4jLogEvent.class);
+    }
+
+    abstract protected int[] getEventIndices(final String text, int beginIndex);
+
+    @Override
+    public void logEvents(final InputStream inputStream, final LogEventListener logEventListener) throws IOException {
+        String workingText = Strings.EMPTY;
+        try {
+            // Allocate buffer once
+            final byte[] buffer = new byte[bufferSize];
+            String textRemains = workingText = Strings.EMPTY;
+            while (true) {
+                // Process until the stream is EOF.
+                final int streamReadLength = inputStream.read(buffer);
+                if (streamReadLength == END) {
+                    // The input stream is EOF
+                    break;
+                }
+                final String text = workingText = textRemains + new String(buffer, 0, streamReadLength, charset);
+                int beginIndex = 0;
+                while (true) {
+                    // Extract and log all XML events in the buffer
+                    final int[] pair = getEventIndices(text, beginIndex);
+                    final int eventStartMarkerIndex = pair[0];
+                    if (eventStartMarkerIndex < 0) {
+                        // No more events or partial XML only in the buffer.
+                        // Save the unprocessed string part
+                        textRemains = text.substring(beginIndex);
+                        break;
+                    }
+                    final int eventEndMarkerIndex = pair[1];
+                    if (eventEndMarkerIndex > 0) {
+                        final int eventEndXmlIndex = eventEndMarkerIndex + eventEndMarker.length();
+                        final String textEvent = workingText = text.substring(eventStartMarkerIndex, eventEndXmlIndex);
+                        final LogEvent logEvent = unmarshal(textEvent);
+                        logEventListener.log(logEvent);
+                        beginIndex = eventEndXmlIndex;
+                    } else {
+                        // No more events or partial XML only in the buffer.
+                        // Save the unprocessed string part
+                        textRemains = text.substring(beginIndex);
+                        break;
+                    }
+                }
+            }
+        } catch (final IOException ex) {
+            logger.error(workingText, ex);
+        }
+    }
+
+    protected Log4jLogEvent unmarshal(final String jsonEvent) throws IOException {
+        return this.objectReader.readValue(jsonEvent);
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java
new file mode 100644
index 0000000000..dbfa75555d
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/JsonInputStreamLogEventBridge.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.net.server;
+
+import java.io.InputStream;
+import java.nio.charset.Charset;
+
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;
+
+/**
+ * Reads and logs JSON {@link LogEvent}s from an {@link InputStream}..
+ */
+public class JsonInputStreamLogEventBridge extends InputStreamLogEventBridge {
+
+    private static final int[] END_PAIR = new int[] { END, END };
+    private static final char EVENT_END_MARKER = '}';
+    private static final char EVENT_START_MARKER = '{';
+    private static final char JSON_ESC = '\\';
+    private static final char JSON_STR_DELIM = '"';
+
+    public JsonInputStreamLogEventBridge() {
+        this(1024, Charset.defaultCharset());
+    }
+
+    public JsonInputStreamLogEventBridge(final int bufferSize, final Charset charset) {
+        super(new Log4jJsonObjectMapper(), bufferSize, charset, String.valueOf(EVENT_END_MARKER));
+    }
+
+    @Override
+    protected int[] getEventIndices(final String text, final int beginIndex) {
+        // Scan the text for the end of the next JSON object.
+        final int start = text.indexOf(EVENT_START_MARKER, beginIndex);
+        if (start == END) {
+            return END_PAIR;
+        }
+        final char[] charArray = text.toCharArray();
+        int stack = 0;
+        boolean inStr = false;
+        boolean inEsc = false;
+        for (int i = start; i < charArray.length; i++) {
+            final char c = charArray[i];
+            if (!inEsc) {
+                inEsc = false;
+                switch (c) {
+                case EVENT_START_MARKER:
+                    if (!inStr) {
+                        stack++;
+                    }
+                    break;
+                case EVENT_END_MARKER:
+                    if (!inStr) {
+                        stack--;
+                    }
+                    break;
+                case JSON_STR_DELIM:
+                    inStr = !inStr;
+                    break;
+                case JSON_ESC:
+                    inEsc = true;
+                    break;
+                }
+                if (stack == 0) {
+                    return new int[] { start, i };
+                }
+            }
+        }
+        return END_PAIR;
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/LogEventInput.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/LogEventBridge.java
similarity index 60%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/LogEventInput.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/LogEventBridge.java
index 104b3debc2..ba45bb6932 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/LogEventInput.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/LogEventBridge.java
@@ -14,33 +14,42 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.IOException;
 import java.io.InputStream;
 
 import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.LogEventListener;
 
 /**
- * Reads {@link LogEvent}s from an input stream.
+ * Reads {@link LogEvent}s from the given input stream and logs them as they are discovered on the given logger.
  * 
- * @param <T> The kind of {@link InputStream} to wrap and read.
+ * <p>
+ * Should be stateless.
+ * </p>
+ * 
+ * @param <T>
+ *            The kind of {@link InputStream} to wrap and read.
  */
-public interface LogEventInput<T extends InputStream> {
+public interface LogEventBridge<T extends InputStream> {
 
     /**
-     * Reads a {@link LogEvent} from the given input stream.
+     * Reads {@link LogEvent}s from the given input stream and logs them as they are discovered on the given logger.
      * 
-     * @param inputStream the input stream to read
-     * @return a LogEvent
+     * @param inputStream
+     *            the input stream to read
+     * @param logEventListener
+     *            TODO
      * @throws IOException
      */
-    LogEvent readLogEvent(T inputStream) throws IOException;
+    void logEvents(T inputStream, LogEventListener logEventListener) throws IOException;
 
     /**
      * Wraps the given stream if needed.
      * 
-     * @param inputStream the stream to wrap
+     * @param inputStream
+     *            the stream to wrap
      * @return the wrapped stream or the given stream.
      * @throws IOException
      */
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SerializedLogEventInput.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/ObjectInputStreamLogEventBridge.java
similarity index 71%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/SerializedLogEventInput.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/ObjectInputStreamLogEventBridge.java
index 15888f1ee4..059f069e60 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/SerializedLogEventInput.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/ObjectInputStreamLogEventBridge.java
@@ -14,23 +14,25 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 
 import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.LogEventListener;
 
 /**
- * Reads serialized {@link LogEvent}s.
+ * Reads and logs serialized {@link LogEvent} objects from an {@link ObjectInputStream}.
  */
-public class SerializedLogEventInput extends AbstractLogEventInput<ObjectInputStream> {
+public class ObjectInputStreamLogEventBridge extends AbstractLogEventBridge<ObjectInputStream> {
 
     @Override
-    public LogEvent readLogEvent(final ObjectInputStream inputStream) throws IOException {
+    public void logEvents(final ObjectInputStream inputStream, final LogEventListener logEventListener)
+            throws IOException {
         try {
-            return (LogEvent) inputStream.readObject();
+            logEventListener.log((LogEvent) inputStream.readObject());
         } catch (final ClassNotFoundException e) {
             throw new IOException(e);
         }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/TCPSocketServer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/TCPSocketServer.java
similarity index 79%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/TCPSocketServer.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/TCPSocketServer.java
index 70f6f6be2a..9cd7667919 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/TCPSocketServer.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/TCPSocketServer.java
@@ -14,7 +14,7 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.BufferedReader;
 import java.io.EOFException;
@@ -35,7 +35,8 @@ import org.apache.logging.log4j.core.config.ConfigurationFactory;
 /**
  * Listens for events over a socket connection.
  * 
- * @param <T> The kind of input stream read
+ * @param <T>
+ *            The kind of input stream read
  */
 public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer<T> implements Runnable {
 
@@ -58,7 +59,7 @@ public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer
             try {
                 try {
                     while (!shutdown) {
-                        log(logEventInput.readLogEvent(inputStream));
+                        logEventInput.logEvents(inputStream, TCPSocketServer.this);
                     }
                 } catch (final EOFException e) {
                     closed = true;
@@ -88,41 +89,49 @@ public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer
     /**
      * Creates a socket server that reads JSON log events.
      * 
-     * @param port the port to listen
+     * @param port
+     *            the port to listen
      * @return a new a socket server
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
     public static TCPSocketServer<InputStream> createJsonSocketServer(final int port) throws IOException {
-        return new TCPSocketServer<InputStream>(port, new JSONLogEventInput());
+        return new TCPSocketServer<InputStream>(port, new JsonInputStreamLogEventBridge());
     }
 
     /**
      * Creates a socket server that reads serialized log events.
      * 
-     * @param port the port to listen
+     * @param port
+     *            the port to listen
      * @return a new a socket server
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
     public static TCPSocketServer<ObjectInputStream> createSerializedSocketServer(final int port) throws IOException {
-        return new TCPSocketServer<ObjectInputStream>(port, new SerializedLogEventInput());
+        return new TCPSocketServer<ObjectInputStream>(port, new ObjectInputStreamLogEventBridge());
     }
 
     /**
      * Creates a socket server that reads XML log events.
      * 
-     * @param port the port to listen
+     * @param port
+     *            the port to listen
      * @return a new a socket server
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
     public static TCPSocketServer<InputStream> createXmlSocketServer(final int port) throws IOException {
-        return new TCPSocketServer<InputStream>(port, new XMLLogEventInput());
+        return new TCPSocketServer<InputStream>(port, new XmlInputStreamLogEventBridge());
     }
 
     /**
      * Main startup for the server.
      * 
-     * @param args The command line arguments.
-     * @throws Exception if an error occurs.
+     * @param args
+     *            The command line arguments.
+     * @throws Exception
+     *             if an error occurs.
      */
     public static void main(final String[] args) throws Exception {
         if (args.length < 1 || args.length > 2) {
@@ -146,7 +155,8 @@ public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer
         final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, enc));
         while (true) {
             final String line = reader.readLine();
-            if (line == null || line.equalsIgnoreCase("Quit") || line.equalsIgnoreCase("Stop") || line.equalsIgnoreCase("Exit")) {
+            if (line == null || line.equalsIgnoreCase("Quit") || line.equalsIgnoreCase("Stop")
+                    || line.equalsIgnoreCase("Exit")) {
                 socketServer.shutdown();
                 serverThread.join();
                 break;
@@ -160,18 +170,21 @@ public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer
 
     private final ConcurrentMap<Long, SocketHandler> handlers = new ConcurrentHashMap<Long, SocketHandler>();
 
-    private final ServerSocket server;
+    private final ServerSocket serverSocket;
 
     /**
      * Constructor.
      * 
-     * @param port to listen.
-     * @param logEventInput the log even input
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @param port
+     *            to listen.
+     * @param logEventInput
+     *            the log even input
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
-    public TCPSocketServer(final int port, final LogEventInput<T> logEventInput) throws IOException {
+    public TCPSocketServer(final int port, final LogEventBridge<T> logEventInput) throws IOException {
         super(port, logEventInput);
-        this.server = new ServerSocket(port);
+        this.serverSocket = new ServerSocket(port);
     }
 
     /**
@@ -182,7 +195,7 @@ public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer
         while (isActive()) {
             try {
                 // Accept incoming connections.
-                final Socket clientSocket = server.accept();
+                final Socket clientSocket = serverSocket.accept();
                 clientSocket.setSoLinger(true, 0);
 
                 // accept() will block until a client connects to the server.
@@ -210,9 +223,12 @@ public class TCPSocketServer<T extends InputStream> extends AbstractSocketServer
 
     /**
      * Shutdown the server.
+     * 
+     * @throws IOException
      */
-    public void shutdown() {
+    public void shutdown() throws IOException {
         setActive(false);
         Thread.currentThread().interrupt();
+        serverSocket.close();
     }
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/UDPSocketServer.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/UDPSocketServer.java
similarity index 72%
rename from log4j-core/src/main/java/org/apache/logging/log4j/core/net/UDPSocketServer.java
rename to log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/UDPSocketServer.java
index a452bca1d1..caf088124b 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/UDPSocketServer.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/UDPSocketServer.java
@@ -14,7 +14,7 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.BufferedReader;
 import java.io.ByteArrayInputStream;
@@ -32,65 +32,57 @@ import org.apache.logging.log4j.core.config.ConfigurationFactory;
 /**
  * Listens for events over a socket connection.
  * 
- * @param <T> The kind of input stream read
+ * @param <T>
+ *            The kind of input stream read
  */
 public class UDPSocketServer<T extends InputStream> extends AbstractSocketServer<T> implements Runnable {
 
     /**
      * Creates a socket server that reads JSON log events.
      * 
-     * @param port the port to listen
+     * @param port
+     *            the port to listen
      * @return a new a socket server
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
     public static UDPSocketServer<InputStream> createJsonSocketServer(final int port) throws IOException {
-        return new UDPSocketServer<InputStream> (port, new JSONLogEventInput());
+        return new UDPSocketServer<InputStream>(port, new JsonInputStreamLogEventBridge());
     }
 
     /**
      * Creates a socket server that reads serialized log events.
      * 
-     * @param port the port to listen
+     * @param port
+     *            the port to listen
      * @return a new a socket server
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
-    public static UDPSocketServer<ObjectInputStream>  createSerializedSocketServer(final int port) throws IOException {
-        return new UDPSocketServer<ObjectInputStream> (port, new SerializedLogEventInput());
+    public static UDPSocketServer<ObjectInputStream> createSerializedSocketServer(final int port) throws IOException {
+        return new UDPSocketServer<ObjectInputStream>(port, new ObjectInputStreamLogEventBridge());
     }
 
     /**
      * Creates a socket server that reads XML log events.
      * 
-     * @param port the port to listen
+     * @param port
+     *            the port to listen
      * @return a new a socket server
-     * @throws IOException if an I/O error occurs when opening the socket.
+     * @throws IOException
+     *             if an I/O error occurs when opening the socket.
      */
-    public static UDPSocketServer<InputStream>  createXmlSocketServer(final int port) throws IOException {
-        return new UDPSocketServer<InputStream> (port, new XMLLogEventInput());
-    }
-
-    private final DatagramSocket datagramSocket;
-
-    // max size so we only have to deal with one packet
-    private final int maxBufferSize = 1024 * 65 + 1024;
-
-    /**
-     * Constructor.
-     * 
-     * @param port to listen on.
-     * @param logEventInput
-     * @throws IOException If an error occurs.
-     */
-    public UDPSocketServer(final int port, final LogEventInput<T> logEventInput) throws IOException {
-        super(port, logEventInput);
-        this.datagramSocket = new DatagramSocket(port);
+    public static UDPSocketServer<InputStream> createXmlSocketServer(final int port) throws IOException {
+        return new UDPSocketServer<InputStream>(port, new XmlInputStreamLogEventBridge());
     }
 
     /**
      * Main startup for the server.
      * 
-     * @param args The command line arguments.
-     * @throws Exception if an error occurs.
+     * @param args
+     *            The command line arguments.
+     * @throws Exception
+     *             if an error occurs.
      */
     public static void main(final String[] args) throws Exception {
         if (args.length < 1 || args.length > 2) {
@@ -113,7 +105,8 @@ public class UDPSocketServer<T extends InputStream> extends AbstractSocketServer
         final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
         while (true) {
             final String line = reader.readLine();
-            if (line == null || line.equalsIgnoreCase("Quit") || line.equalsIgnoreCase("Stop") || line.equalsIgnoreCase("Exit")) {
+            if (line == null || line.equalsIgnoreCase("Quit") || line.equalsIgnoreCase("Stop")
+                    || line.equalsIgnoreCase("Exit")) {
                 socketServer.shutdown();
                 server.join();
                 break;
@@ -125,12 +118,23 @@ public class UDPSocketServer<T extends InputStream> extends AbstractSocketServer
         System.out.println("Usage: ServerSocket port configFilePath");
     }
 
+    private final DatagramSocket datagramSocket;
+
+    // max size so we only have to deal with one packet
+    private final int maxBufferSize = 1024 * 65 + 1024;
+
     /**
-     * Shutdown the server.
+     * Constructor.
+     * 
+     * @param port
+     *            to listen on.
+     * @param logEventInput
+     * @throws IOException
+     *             If an error occurs.
      */
-    public void shutdown() {
-        this.setActive(false);
-        Thread.currentThread().interrupt();
+    public UDPSocketServer(final int port, final LogEventBridge<T> logEventInput) throws IOException {
+        super(port, logEventInput);
+        this.datagramSocket = new DatagramSocket(port);
     }
 
     /**
@@ -143,8 +147,9 @@ public class UDPSocketServer<T extends InputStream> extends AbstractSocketServer
                 final byte[] buf = new byte[maxBufferSize];
                 final DatagramPacket packet = new DatagramPacket(buf, buf.length);
                 datagramSocket.receive(packet);
-                final ByteArrayInputStream bais = new ByteArrayInputStream(packet.getData(), packet.getOffset(), packet.getLength());
-                log(logEventInput.readLogEvent(logEventInput.wrapStream(bais)));
+                final ByteArrayInputStream bais = new ByteArrayInputStream(packet.getData(), packet.getOffset(),
+                        packet.getLength());
+                logEventInput.logEvents(logEventInput.wrapStream(bais), this);
             } catch (final OptionalDataException e) {
                 logger.error("OptionalDataException eof=" + e.eof + " length=" + e.length, e);
             } catch (final EOFException e) {
@@ -154,4 +159,13 @@ public class UDPSocketServer<T extends InputStream> extends AbstractSocketServer
             }
         }
     }
+
+    /**
+     * Shutdown the server.
+     */
+    public void shutdown() {
+        this.setActive(false);
+        Thread.currentThread().interrupt();
+        datagramSocket.close();
+    }
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/XmlInputStreamLogEventBridge.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/XmlInputStreamLogEventBridge.java
new file mode 100644
index 0000000000..785339871e
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/net/server/XmlInputStreamLogEventBridge.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.net.server;
+
+import java.io.InputStream;
+import java.nio.charset.Charset;
+
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;
+
+/**
+ * Reads and logs {@link LogEvent}s from an {@link InputStream}.
+ */
+public class XmlInputStreamLogEventBridge extends InputStreamLogEventBridge {
+
+    private static final String EVENT_END = "</Event>";
+    private static final String EVENT_START_NS_N = "<Event>";
+    private static final String EVENT_START_NS_Y = "<Event ";
+
+    public XmlInputStreamLogEventBridge() {
+        this(1024, Charset.defaultCharset());
+    }
+
+    public XmlInputStreamLogEventBridge(final int bufferSize, final Charset charset) {
+        super(new Log4jXmlObjectMapper(), bufferSize, charset, EVENT_END);
+    }
+
+    @Override
+    protected int[] getEventIndices(final String text, final int beginIndex) {
+        int start = text.indexOf(EVENT_START_NS_Y, beginIndex);
+        int startLen = EVENT_START_NS_Y.length();
+        if (start < 0) {
+            start = text.indexOf(EVENT_START_NS_N, beginIndex);
+            startLen = EVENT_START_NS_N.length();
+        }
+        final int end = start < 0 ? -1 : text.indexOf(EVENT_END, start + startLen);
+        return new int[] { start, end };
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java
index eeacccc5d2..df2db832fb 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/ExtendedThrowablePatternConverter.java
@@ -69,7 +69,7 @@ public final class ExtendedThrowablePatternConverter extends ThrowablePatternCon
                 super.format(event, toAppendTo);
                 return;
             }
-            final String trace = proxy.getExtendedStackTrace(options.getPackages());
+            final String trace = proxy.getExtendedStackTraceAsString(options.getPackages());
             final int len = toAppendTo.length();
             if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
                 toAppendTo.append(' ');
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java
index 9548135e76..e2a461ddc1 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/RootThrowablePatternConverter.java
@@ -69,7 +69,7 @@ public final class RootThrowablePatternConverter extends ThrowablePatternConvert
                 super.format(event, toAppendTo);
                 return;
             }
-            final String trace = proxy.getRootCauseStackTrace(options.getPackages());
+            final String trace = proxy.getCauseStackTraceAsString(options.getPackages());
             final int len = toAppendTo.length();
             if (len > 0 && !Character.isWhitespace(toAppendTo.charAt(len - 1))) {
                 toAppendTo.append(' ');
diff --git a/log4j-core/src/main/resources/Log4j-levels.xsd b/log4j-core/src/main/resources/Log4j-levels.xsd
new file mode 100644
index 0000000000..3ca10bbb0c
--- /dev/null
+++ b/log4j-core/src/main/resources/Log4j-levels.xsd
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:log4j="http://logging.apache.org/log4j/2.0/events" targetNamespace="http://logging.apache.org/log4j/2.0/events" elementFormDefault="qualified" attributeFormDefault="unqualified">
+    <xs:simpleType name="LevelEnum">
+        <xs:restriction base="xs:string">
+            <xs:enumeration value="OFF"/>
+            <xs:enumeration value="FATAL"/>
+            <xs:enumeration value="ERROR"/>
+            <xs:enumeration value="WARN"/>
+            <xs:enumeration value="INFO"/>
+            <xs:enumeration value="DEBUG"/>
+            <xs:enumeration value="TRACE"/>
+            <xs:enumeration value="ALL"/>
+        </xs:restriction>
+    </xs:simpleType>
+</xs:schema>
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/MarkerMixInTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/MarkerMixInTest.java
new file mode 100644
index 0000000000..7440ef953f
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/MarkerMixInTest.java
@@ -0,0 +1,77 @@
+package org.apache.logging.log4j;
+
+import java.io.IOException;
+
+import org.apache.logging.log4j.MarkerManager.Log4jMarker;
+import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+
+/**
+ * Tests {@link MarkerMixIn}.
+ * 
+ * This class is in this package to let {@link Log4jMarker} have the least visibility.
+ */
+public class MarkerMixInTest {
+
+    private ObjectReader reader;
+    private ObjectWriter writer;
+
+    @Before
+    public void setUp() {
+        final Log4jJsonObjectMapper log4jObjectMapper = new Log4jJsonObjectMapper();
+        writer = log4jObjectMapper.writer();
+        reader = log4jObjectMapper.reader(Log4jMarker.class);
+        MarkerManager.clear();
+    }
+
+    @Test
+    public void testNameOnly() throws IOException {
+        final Marker expected = MarkerManager.getMarker("A");
+        final String str = writeValueAsString(expected);
+        Assert.assertFalse(str.contains("parents"));
+        final Marker actual = reader.readValue(str);
+        Assert.assertEquals(expected, actual);
+    }
+
+    @Test
+    public void testOneParent() throws IOException {
+        final Marker expected = MarkerManager.getMarker("A");
+        final Marker parent = MarkerManager.getMarker("PARENT_MARKER");
+        expected.addParents(parent);
+        final String str = writeValueAsString(expected);
+        Assert.assertTrue(str.contains("PARENT_MARKER"));
+        final Marker actual = reader.readValue(str);
+        Assert.assertEquals(expected, actual);
+    }
+
+    /**
+     * @param expected
+     * @return
+     * @throws JsonProcessingException
+     */
+    private String writeValueAsString(final Marker expected) throws JsonProcessingException {
+        final String str = writer.writeValueAsString(expected);
+        // System.out.println(str);
+        return str;
+    }
+
+    @Test
+    public void testTwoParents() throws IOException {
+        final Marker expected = MarkerManager.getMarker("A");
+        final Marker parent1 = MarkerManager.getMarker("PARENT_MARKER1");
+        final Marker parent2 = MarkerManager.getMarker("PARENT_MARKER2");
+        expected.addParents(parent1);
+        expected.addParents(parent2);
+        final String str = writeValueAsString(expected);
+        Assert.assertTrue(str.contains("PARENT_MARKER1"));
+        Assert.assertTrue(str.contains("PARENT_MARKER2"));
+        final Marker actual = reader.readValue(str);
+        Assert.assertEquals(expected, actual);
+    }
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/JSONCompleteFileAppenderTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/JSONCompleteFileAppenderTest.java
index c5223ad52a..e5eee76686 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/JSONCompleteFileAppenderTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/JSONCompleteFileAppenderTest.java
@@ -54,6 +54,7 @@ public class JSONCompleteFileAppenderTest {
         String line3;
         String line4;
         String line5;
+        String line6;
         final BufferedReader reader = new BufferedReader(new FileReader(this.logFile));
         try {
             line1 = reader.readLine();
@@ -61,6 +62,7 @@ public class JSONCompleteFileAppenderTest {
             line3 = reader.readLine();
             line4 = reader.readLine();
             line5 = reader.readLine();
+            line6 = reader.readLine();
         } finally {
             reader.close();
         }
@@ -69,21 +71,25 @@ public class JSONCompleteFileAppenderTest {
         assertTrue("line1 incorrect: [" + line1 + "], does not contain: [" + msg1 + ']', line1.equals(msg1));
 
         assertNotNull("line2", line2);
-        final String msg2 = "  {";
+        final String msg2 = "{";
         assertTrue("line2 incorrect: [" + line2 + "], does not contain: [" + msg2 + ']', line2.equals(msg2));
 
         assertNotNull("line3", line3);
-        final String msg3 = "    \"logger\":\"com.foo.Bar\",";
+        final String msg3 = "  \"timeMillis\" : ";
         assertTrue("line3 incorrect: [" + line3 + "], does not contain: [" + msg3 + ']', line3.contains(msg3));
 
         assertNotNull("line4", line4);
-        final String msg4 = "\"timestamp\":";
+        final String msg4 = "  \"thread\" : \"main\",";
         assertTrue("line4 incorrect: [" + line4 + "], does not contain: [" + msg4 + ']', line4.contains(msg4));
 
         assertNotNull("line5", line5);
-        final String msg5 = "    \"level\":\"INFO\",";
+        final String msg5 = "  \"level\" : \"INFO\",";
         assertTrue("line5 incorrect: [" + line5 + "], does not contain: [" + msg5 + ']', line5.contains(msg5));
 
+        assertNotNull("line6", line6);
+        final String msg6 = "  \"loggerName\" : \"com.foo.Bar\",";
+        assertTrue("line5 incorrect: [" + line6 + "], does not contain: [" + msg6 + ']', line6.contains(msg6));
+
         final String location = "testFlushAtEndOfBatch";
         assertTrue("no location", !line1.contains(location));
     }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/XmlFileAppenderTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/XmlFileAppenderTest.java
index 21c8615b37..1c5eafd228 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/XmlFileAppenderTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/XmlFileAppenderTest.java
@@ -66,7 +66,7 @@ public class XmlFileAppenderTest {
         assertNotNull("line1", line1);
 
         assertNotNull("line1", line1);
-        final String msg1 = "<log4j:Event ";
+        final String msg1 = "<Event ";
         assertTrue("line1 incorrect: [" + line1 + "], does not contain: [" + msg1 + ']', line1.contains(msg1));
 
         assertNotNull("line2", line2);
@@ -74,7 +74,7 @@ public class XmlFileAppenderTest {
         assertTrue("line2 incorrect: [" + line2 + "], does not contain: [" + msg2 + ']', line2.contains(msg2));
 
         assertNotNull("line3", line3);
-        final String msg3 = "</log4j:Event>";
+        final String msg3 = "</Event>";
         assertTrue("line3 incorrect: [" + line3 + "], does not contain: [" + msg3 + ']', line3.contains(msg3));
 
         final String location = "testFlushAtEndOfBatch";
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rewrite/MapRewritePolicyTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rewrite/MapRewritePolicyTest.java
index 5993adfde5..06a07a5336 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rewrite/MapRewritePolicyTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rewrite/MapRewritePolicyTest.java
@@ -140,7 +140,7 @@ public class MapRewritePolicyTest {
         Assert.assertEquals("Marker changed", orig.getMarker(), changed.getMarker());
         Assert.assertEquals("FQCN changed", orig.getLoggerFQCN(), changed.getLoggerFQCN());
         Assert.assertEquals("Level changed", orig.getLevel(), changed.getLevel());
-        Assert.assertEquals("Throwable changed", orig.getThrown() == null //
+        Assert.assertArrayEquals("Throwable changed", orig.getThrown() == null //
                 ? null //
                 : ((Log4jLogEvent) orig).getThrownProxy().getExtendedStackTrace(), //
                 changed.getThrown() == null //
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java
index 3ad79109bc..a363a89d7c 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java
@@ -16,26 +16,50 @@
  */
 package org.apache.logging.log4j.core.impl;
 
-import org.junit.Assert;
-import org.junit.Test;
-
+import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Stack;
 
+import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
 /**
  *
  */
 public class ThrowableProxyTest {
 
+    static class Fixture {
+        @JsonProperty
+        ThrowableProxy proxy = new ThrowableProxy(new IOException("test"));
+    }
+
+    @Test
+    public void testJsonIoContainer() throws IOException {
+        ObjectMapper objectMapper = new Log4jJsonObjectMapper();
+        Fixture expected = new Fixture();
+        final String s = objectMapper.writeValueAsString(expected);
+        Fixture actual = objectMapper.readValue(s, Fixture.class);
+        Assert.assertEquals(expected.proxy.getName(), actual.proxy.getName());
+        Assert.assertEquals(expected.proxy.getMessage(), actual.proxy.getMessage());
+        Assert.assertEquals(expected.proxy.getLocalizedMessage(), actual.proxy.getLocalizedMessage());
+        Assert.assertEquals(expected.proxy.getCommonElementCount(), actual.proxy.getCommonElementCount());
+        Assert.assertArrayEquals(expected.proxy.getExtendedStackTrace(), actual.proxy.getExtendedStackTrace());        
+        Assert.assertEquals(expected.proxy, actual.proxy);
+    }
+
     @Test
     public void testStack() {
         final Map<String, ThrowableProxy.CacheEntry> map = new HashMap<String, ThrowableProxy.CacheEntry>();
         final Stack<Class<?>> stack = new Stack<Class<?>>();
         final Throwable throwable = new IllegalStateException("This is a test");
         final ThrowableProxy proxy = new ThrowableProxy(throwable);
-        final StackTracePackageElement[] callerPackageData = proxy.resolvePackageData(stack, map, null,
-            throwable.getStackTrace());
+        final ExtendedStackTraceElement[] callerPackageData = proxy.toExtendedStackTrace(stack, map, null,
+                throwable.getStackTrace());
         Assert.assertNotNull("No package data returned", callerPackageData);
     }
 }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/JacksonIssue429MyNamesTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/JacksonIssue429MyNamesTest.java
new file mode 100644
index 0000000000..d49a415058
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/JacksonIssue429MyNamesTest.java
@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+
+public class JacksonIssue429MyNamesTest {
+
+    @SuppressWarnings("serial")
+    static class MyStackTraceElementDeserializer extends StdScalarDeserializer<StackTraceElement> {
+        private static final long serialVersionUID = 1L;
+
+        public final static MyStackTraceElementDeserializer instance = new MyStackTraceElementDeserializer();
+
+        public MyStackTraceElementDeserializer() {
+            super(StackTraceElement.class);
+        }
+
+        @Override
+        public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException,
+                JsonProcessingException {
+            JsonToken t = jp.getCurrentToken();
+            // Must get an Object
+            if (t == JsonToken.START_OBJECT) {
+                String className = "", methodName = "", fileName = "";
+                int lineNumber = -1;
+
+                while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {
+                    String propName = jp.getCurrentName();
+                    if ("class".equals(propName)) {
+                        className = jp.getText();
+                    } else if ("file".equals(propName)) {
+                        fileName = jp.getText();
+                    } else if ("line".equals(propName)) {
+                        if (t.isNumeric()) {
+                            lineNumber = jp.getIntValue();
+                        } else {
+                            throw JsonMappingException.from(jp, "Non-numeric token (" + t
+                                    + ") for property 'lineNumber'");
+                        }
+                    } else if ("method".equals(propName)) {
+                        methodName = jp.getText();
+                    } else if ("nativeMethod".equals(propName)) {
+                        // no setter, not passed via constructor: ignore
+                    } else {
+                        handleUnknownProperty(jp, ctxt, _valueClass, propName);
+                    }
+                }
+                return new StackTraceElement(className, methodName, fileName, lineNumber);
+            }
+            throw ctxt.mappingException(_valueClass, t);
+        }
+    }
+
+    static class StackTraceBean {
+        public final static int NUM = 13;
+
+        @JsonProperty("Location")
+        @JsonDeserialize(using = MyStackTraceElementDeserializer.class)
+        private StackTraceElement location;
+    }
+
+    private final static ObjectMapper SHARED_MAPPER = new ObjectMapper();
+
+    private final ObjectMapper MAPPER = objectMapper();
+
+    protected String aposToQuotes(String json) {
+        return json.replace("'", "\"");
+    }
+
+    protected ObjectMapper objectMapper() {
+        return SHARED_MAPPER;
+    }
+
+    @Test
+    public void testStackTraceElementWithCustom() throws Exception {
+        // first, via bean that contains StackTraceElement
+        StackTraceBean bean = MAPPER
+                .readValue(
+                        aposToQuotes("{'Location':{'class':'package.SomeClass','method':'someMethod','file':'SomeClass.java','line':13}}"),
+                        StackTraceBean.class);
+        Assert.assertNotNull(bean);
+        Assert.assertNotNull(bean.location);
+        Assert.assertEquals(StackTraceBean.NUM, bean.location.getLineNumber());
+
+        // and then directly, iff registered
+        ObjectMapper mapper = new ObjectMapper();
+        SimpleModule module = new SimpleModule();
+        module.addDeserializer(StackTraceElement.class, new MyStackTraceElementDeserializer());
+        mapper.registerModule(module);
+
+        StackTraceElement elem = mapper.readValue(
+                aposToQuotes("{'class':'package.SomeClass','method':'someMethod','file':'SomeClass.java','line':13}"),
+                StackTraceElement.class);
+        Assert.assertNotNull(elem);
+        Assert.assertEquals(StackTraceBean.NUM, elem.getLineNumber());
+    }
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/JacksonIssue429Test.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/JacksonIssue429Test.java
new file mode 100644
index 0000000000..17375de39d
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/JacksonIssue429Test.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+
+public class JacksonIssue429Test {
+
+    @SuppressWarnings("serial")
+    static class Jackson429StackTraceElementDeserializer extends StdDeserializer<StackTraceElement> {
+        public Jackson429StackTraceElementDeserializer() {
+            super(StackTraceElement.class);
+        }
+
+        @Override
+        public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException,
+                JsonProcessingException {
+            jp.skipChildren();
+            return new StackTraceElement("a", "b", "b", StackTraceBean.NUM);
+        }
+
+    }
+
+    static class StackTraceBean {
+        public final static int NUM = 13;
+
+        @JsonProperty("Location")
+        @JsonDeserialize(using = Jackson429StackTraceElementDeserializer.class)
+        private StackTraceElement location;
+    }
+
+    private final static ObjectMapper SHARED_MAPPER = new ObjectMapper();
+
+    private final ObjectMapper MAPPER = objectMapper();
+
+    protected String aposToQuotes(String json) {
+        return json.replace("'", "\"");
+    }
+
+    protected ObjectMapper objectMapper() {
+        return SHARED_MAPPER;
+    }
+
+    @Test
+    public void testStackTraceElementWithCustom() throws Exception {
+        // first, via bean that contains StackTraceElement
+        StackTraceBean bean = MAPPER.readValue(aposToQuotes("{'Location':'foobar'}"), StackTraceBean.class);
+        Assert.assertNotNull(bean);
+        Assert.assertNotNull(bean.location);
+        Assert.assertEquals(StackTraceBean.NUM, bean.location.getLineNumber());
+
+        // and then directly, iff registered
+        ObjectMapper mapper = new ObjectMapper();
+        SimpleModule module = new SimpleModule();
+        module.addDeserializer(StackTraceElement.class, new Jackson429StackTraceElementDeserializer());
+        mapper.registerModule(module);
+
+        StackTraceElement elem = mapper.readValue(
+                aposToQuotes("{'class':'package.SomeClass','method':'someMethod','file':'SomeClass.java','line':123}"),
+                StackTraceElement.class);
+        Assert.assertNotNull(elem);
+        Assert.assertEquals(StackTraceBean.NUM, elem.getLineNumber());
+    }
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/LevelMixInTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/LevelMixInTest.java
new file mode 100644
index 0000000000..7ce9fd17ec
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/LevelMixInTest.java
@@ -0,0 +1,84 @@
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import org.apache.logging.log4j.Level;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.ObjectWriter;
+
+/**
+ * Tests {@link LevelMixIn}.
+ */
+public class LevelMixInTest {
+
+    static class Fixture {
+        @JsonProperty
+        private final Level level = Level.DEBUG;
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            final Fixture other = (Fixture) obj;
+            if (this.level == null) {
+                if (other.level != null) {
+                    return false;
+                }
+            } else if (!this.level.equals(other.level)) {
+                return false;
+            }
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((this.level == null) ? 0 : this.level.hashCode());
+            return result;
+        }
+    }
+    private Log4jJsonObjectMapper log4jObjectMapper;
+
+    private ObjectReader reader;
+
+    private ObjectWriter writer;
+    
+    @Before
+    public void setUp() {
+        log4jObjectMapper = new Log4jJsonObjectMapper();
+        writer = log4jObjectMapper.writer();
+        reader = log4jObjectMapper.reader(Level.class);
+    }
+
+    @Test
+    public void testContainer() throws IOException {
+        final Fixture expected = new Fixture();
+        final String str = writer.writeValueAsString(expected);
+        Assert.assertTrue(str.contains("DEBUG"));
+        final ObjectReader fixtureReader = log4jObjectMapper.reader(Fixture.class);
+        final Fixture actual = fixtureReader.readValue(str);
+        Assert.assertEquals(expected, actual);
+    }
+
+    @Test
+    public void testNameOnly() throws IOException {
+        final Level expected = Level.getLevel("DEBUG");
+        final String str = writer.writeValueAsString(expected);
+        Assert.assertTrue(str.contains("DEBUG"));
+        final Level actual = reader.readValue(str);
+        Assert.assertEquals(expected, actual);
+    }
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/StackTraceElementMixInTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/StackTraceElementMixInTest.java
new file mode 100644
index 0000000000..ed9b3dafc3
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/jackson/StackTraceElementMixInTest.java
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.jackson;
+
+import java.io.IOException;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.fasterxml.jackson.core.JsonParseException;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+
+public class StackTraceElementMixInTest {
+
+    @Test
+    public void testLog4jJsonObjectMapper() throws Exception {
+        this.roundtrip(new Log4jJsonObjectMapper());
+    }
+
+    /**
+     * @param mapper
+     * @throws JsonProcessingException
+     * @throws IOException
+     * @throws JsonParseException
+     * @throws JsonMappingException
+     */
+    private void roundtrip(final ObjectMapper mapper) throws JsonProcessingException, IOException, JsonParseException, JsonMappingException {
+        final StackTraceElement expected = new StackTraceElement("package.SomeClass", "someMethod", "SomeClass.java", 123);
+        final String s = mapper.writeValueAsString(expected);
+        final StackTraceElement actual = mapper.readValue(s, StackTraceElement.class);
+        Assert.assertEquals(expected, actual);
+    }
+
+    @Test
+    public void testLog4jXmlObjectMapper() throws Exception {
+        this.roundtrip(new Log4jXmlObjectMapper());
+    }
+
+    protected String aposToQuotes(final String json) {
+        return json.replace("'", "\"");
+    }
+
+    @Test
+    public void testFromJsonWithSimpleModule() throws Exception {
+        final ObjectMapper mapper = new ObjectMapper();
+        final SimpleModule module = new SimpleModule();
+        module.addDeserializer(StackTraceElement.class, new Log4jStackTraceElementDeserializer());
+        mapper.registerModule(module);
+        final StackTraceElement expected = new StackTraceElement("package.SomeClass", "someMethod", "SomeClass.java", 123);
+        final String s = this.aposToQuotes("{'class':'package.SomeClass','method':'someMethod','file':'SomeClass.java','line':123}");
+        final StackTraceElement actual = mapper.readValue(s, StackTraceElement.class);
+        Assert.assertEquals(expected, actual);
+    }
+
+    @Test
+    public void testFromJsonWithLog4jModule() throws Exception {
+        final ObjectMapper mapper = new ObjectMapper();
+        final SimpleModule module = new Log4jJsonModule();
+        module.addDeserializer(StackTraceElement.class, new Log4jStackTraceElementDeserializer());
+        mapper.registerModule(module);
+        final StackTraceElement expected = new StackTraceElement("package.SomeClass", "someMethod", "SomeClass.java", 123);
+        final String s = this.aposToQuotes("{'class':'package.SomeClass','method':'someMethod','file':'SomeClass.java','line':123}");
+        final StackTraceElement actual = mapper.readValue(s, StackTraceElement.class);
+        Assert.assertEquals(expected, actual);
+    }
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/JSONLayoutTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/JSONLayoutTest.java
index 7ddba0a3de..a48e0c7ad8 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/JSONLayoutTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/JSONLayoutTest.java
@@ -17,8 +17,8 @@
 package org.apache.logging.log4j.core.layout;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 import java.util.List;
 import java.util.Map;
@@ -32,8 +32,12 @@ import org.apache.logging.log4j.core.Logger;
 import org.apache.logging.log4j.core.LoggerContext;
 import org.apache.logging.log4j.core.config.ConfigurationFactory;
 import org.apache.logging.log4j.core.helpers.Charsets;
+import org.apache.logging.log4j.core.impl.Log4jLogEvent;
+import org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper;
+import org.apache.logging.log4j.message.SimpleMessage;
 import org.apache.logging.log4j.test.appender.ListAppender;
 import org.junit.AfterClass;
+import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -43,13 +47,17 @@ import org.junit.Test;
 public class JSONLayoutTest {
     static ConfigurationFactory cf = new BasicConfigurationFactory();
 
+    private static final String DQUOTE = "\"";
+
     @AfterClass
     public static void cleanupClass() {
         ConfigurationFactory.removeConfigurationFactory(cf);
+        ThreadContext.clearAll();
     }
 
     @BeforeClass
     public static void setupClass() {
+        ThreadContext.clearAll();
         ConfigurationFactory.setConfigurationFactory(cf);
         final LoggerContext ctx = (LoggerContext) LogManager.getContext();
         ctx.reconfigure();
@@ -57,103 +65,172 @@ public class JSONLayoutTest {
 
     LoggerContext ctx = (LoggerContext) LogManager.getContext();
 
-    Logger root = this.ctx.getLogger("");
+    Logger rootLogger = this.ctx.getLogger("");
+
+    private void checkAt(final String expected, final int lineIndex, final List<String> list) {
+        final String trimedLine = list.get(lineIndex).trim();
+        assertTrue("Incorrect line index " + lineIndex + ": \"" + trimedLine + '"', trimedLine.equals(expected));
+    }
+
+    private void checkContains(final String expected, final List<String> list) {
+        for (final String string : list) {
+            final String trimedLine = string.trim();
+            if (trimedLine.equals(expected)) {
+                return;
+            }
+        }
+        Assert.fail("Cannot find " + expected + " in " + list);
+    }
+
+    private void checkMapEntry(final String key, final String value, final boolean compact, final String str) {
+        final String propSep = this.toPropertySeparator(compact);
+        // "name":"value"
+        final String expected = String.format("{\"key\":\"%s\",\"value\":\"%s\"}", key, value);
+        assertTrue("Cannot find " + expected + " in " + str, str.contains(expected));
+    }
+
+    private void checkProperty(final String key, final String value, final boolean compact, final String str) {
+        final String propSep = this.toPropertySeparator(compact);
+        // {"key":"MDC.B","value":"B_Value"}
+        final String expected = String.format("\"%s\"%s\"%s\"", key, propSep, value);
+        assertTrue("Cannot find " + expected + " in " + str, str.contains(expected));
+    }
+
+    private void checkPropertyName(final String name, final boolean compact, final String str) {
+        final String propSep = this.toPropertySeparator(compact);
+        assertTrue(str, str.contains(DQUOTE + name + DQUOTE + propSep));
+    }
+
+    private void testAllFeatures(final boolean includeSource, final boolean compact, final boolean includeContext) throws Exception {
+        final Log4jLogEvent expected = LogEventFixtures.createLogEvent();
+        final AbstractJacksonLayout layout = JSONLayout.createLayout(Boolean.toString(includeSource), Boolean.toString(includeContext),
+                "false", Boolean.toString(compact), "UTF-8");
+        final String str = layout.toSerializable(expected);
+        final String propSep = this.toPropertySeparator(compact);
+        // Just check for \n since \r might or might not be there.
+        assertEquals(str, !compact, str.contains("\n"));
+        assertEquals(str, includeSource, str.contains("source"));
+        assertEquals(str, includeContext, str.contains("contextMap"));
+        final Log4jLogEvent actual = new Log4jJsonObjectMapper().readValue(str, Log4jLogEvent.class);
+        LogEventFixtures.assertEqualLogEvents(expected, actual, includeSource, includeContext);
+        if (includeContext) {
+            this.checkMapEntry("MDC.A", "A_Value", compact, str);
+            this.checkMapEntry("MDC.B", "B_Value", compact, str);
+        }
+        //
+        assertNull(actual.getThrown());
+        // make sure the names we want are used
+        this.checkPropertyName("timeMillis", compact, str);
+        this.checkPropertyName("thread", compact, str); // and not threadName
+        this.checkPropertyName("level", compact, str);
+        this.checkPropertyName("loggerName", compact, str);
+        this.checkPropertyName("marker", compact, str);
+        this.checkPropertyName("name", compact, str);
+        this.checkPropertyName("parents", compact, str);
+        this.checkPropertyName("message", compact, str);
+        this.checkPropertyName("thrown", compact, str);
+        this.checkPropertyName("cause", compact, str);
+        this.checkPropertyName("class", compact, str);
+        this.checkPropertyName("method", compact, str);
+        this.checkPropertyName("file", compact, str);
+        this.checkPropertyName("line", compact, str);
+        this.checkPropertyName("exact", compact, str);
+        this.checkPropertyName("location", compact, str);
+        this.checkPropertyName("version", compact, str);
+        this.checkPropertyName("commonElementCount", compact, str);
+        this.checkPropertyName("localizedMessage", compact, str);
+        this.checkPropertyName("extendedStackTrace", compact, str);
+        this.checkPropertyName("suppressed", compact, str);
+        this.checkPropertyName("loggerFQCN", compact, str);
+        this.checkPropertyName("endOfBatch", compact, str);
+        if (includeContext) {
+            this.checkPropertyName("contextMap", compact, str);
+        }
+        this.checkPropertyName("contextStack", compact, str);
+        if (includeSource) {
+            this.checkPropertyName("source", compact, str);
+        }
+        // check some attrs
+        this.checkProperty("loggerFQCN", "f.q.c.n", compact, str);
+        this.checkProperty("loggerName", "a.B", compact, str);
+    }
 
     @Test
     public void testContentType() {
-        final JSONLayout layout = JSONLayout.createLayout(null, null, null, null, null);
+        final AbstractJacksonLayout layout = JSONLayout.createLayout(null, null, null, null, null);
         assertEquals("application/json; charset=UTF-8", layout.getContentType());
     }
 
     @Test
     public void testDefaultCharset() {
-        final JSONLayout layout = JSONLayout.createLayout(null, null, null, null, null);
+        final AbstractJacksonLayout layout = JSONLayout.createLayout(null, null, null, null, null);
         assertEquals(Charsets.UTF_8, layout.getCharset());
     }
 
-    /**
-     * Test case for MDC conversion pattern.
-     */
     @Test
-    public void testLayout() throws Exception {
-        final Map<String, Appender> appenders = root.getAppenders();
-        for (Appender appender : appenders.values()) {
-            root.removeAppender(appender);
+    public void testEscapeLayout() throws Exception {
+        final Map<String, Appender> appenders = this.rootLogger.getAppenders();
+        for (final Appender appender : appenders.values()) {
+            this.rootLogger.removeAppender(appender);
         }
         // set up appender
-        final JSONLayout layout = JSONLayout.createLayout("true", "true", "true", "false", null);
+        final AbstractJacksonLayout layout = JSONLayout.createLayout("true", "true", "true", "false", null);
         final ListAppender appender = new ListAppender("List", null, layout, true, false);
         appender.start();
 
         // set appender on root and set level to debug
-        this.root.addAppender(appender);
-        this.root.setLevel(Level.DEBUG);
+        this.rootLogger.addAppender(appender);
+        this.rootLogger.setLevel(Level.DEBUG);
 
         // output starting message
-        this.root.debug("starting mdc pattern test");
-
-        this.root.debug("empty mdc");
-
-        ThreadContext.put("key1", "value1");
-        ThreadContext.put("key2", "value2");
-
-        this.root.debug("filled mdc");
-
-        ThreadContext.remove("key1");
-        ThreadContext.remove("key2");
-
-        this.root.error("finished mdc pattern test", new NullPointerException("test"));
+        this.rootLogger.debug("Here is a quote ' and then a double quote \"");
 
         appender.stop();
 
         final List<String> list = appender.getMessages();
 
-        // System.out.println(list);
-        // [[, {, "logger":"root",, "timestamp":"1376676700199",, "level":"DEBUG",, "thread":"main",,
-        // "message":"starting mdc pattern test",, "LocationInfo":{,
-        // "class":"org.apache.logging.log4j.core.layout.JSONLayoutTest",, "method":"testLayout",,
-        // "file":"JSONLayoutTest.java",, "line":"87", }, },, {, "logger":"root",, "timestamp":"1376676700203",,
-        // "level":"DEBUG",, "thread":"main",, "message":"empty mdc",, "LocationInfo":{,
-        // "class":"org.apache.logging.log4j.core.layout.JSONLayoutTest",, "method":"testLayout",,
-        // "file":"JSONLayoutTest.java",, "line":"89", }, },, {, "logger":"root",, "timestamp":"1376676700204",,
-        // "level":"DEBUG",, "thread":"main",, "message":"filled mdc",, "LocationInfo":{,
-        // "class":"org.apache.logging.log4j.core.layout.JSONLayoutTest",, "method":"testLayout",,
-        // "file":"JSONLayoutTest.java",, "line":"94", },, "Properties":[, {, "name":"key2",, "value":"value2", },, {,
-        // "name":"key1",, "value":"value1", }, ], },, {, "logger":"root",, "timestamp":"1376676700204",,
-        // "level":"ERROR",, "thread":"main",, "message":"finished mdc pattern test",,
-        // "throwable":"java.lang.NullPointerException: test\\n\\tat org.apache.logging.log4j.core.layout.JSONLayoutTest.testLayout(JSONLayoutTest.java:99)\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\\n\\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\\tat java.lang.reflect.Method.invoke(Method.java:606)\\n\\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\\n\\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\\n\\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\\n\\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\\n\\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\\n\\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\\n\\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\\n\\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\\n\\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\\n\\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\\n\\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\\n\\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\\n\\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\\n\\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\\n\\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\\n\\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\\n\\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\\n\\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\\n",,
-        // "LocationInfo":{, "class":"org.apache.logging.log4j.core.layout.JSONLayoutTest",, "method":"testLayout",,
-        // "file":"JSONLayoutTest.java",, "line":"99", }, },, ]]
-
         this.checkAt("[", 0, list);
         this.checkAt("{", 1, list);
-        this.checkAt("\"logger\":\"root\",", 2, list);
-        this.checkAt("\"level\":\"DEBUG\",", 4, list);
-        this.checkAt("\"message\":\"starting mdc pattern test\",", 6, list);
-        this.checkAt("\"Properties\": {", 41, list);
-        this.checkAt("\"key2\": \"value2\"", list, 42, 43);
-        for (Appender app : appenders.values()) {
-            root.addAppender(app);
+        this.checkContains("\"level\" : \"DEBUG\",", list);
+        this.checkContains("\"message\" : \"Here is a quote ' and then a double quote \\\"\",", list);
+        this.checkContains("\"loggerFQCN\" : \"org.apache.logging.log4j.spi.AbstractLoggerProvider\",", list);
+        for (final Appender app : appenders.values()) {
+            this.rootLogger.addAppender(app);
         }
     }
 
+    /**
+     * Test case for MDC conversion pattern.
+     */
     @Test
-    public void testEscapeLayout() throws Exception {
-        final Map<String, Appender> appenders = root.getAppenders();
-        for (Appender appender : appenders.values()) {
-            root.removeAppender(appender);
+    public void testLayout() throws Exception {
+        final Map<String, Appender> appenders = this.rootLogger.getAppenders();
+        for (final Appender appender : appenders.values()) {
+            this.rootLogger.removeAppender(appender);
         }
         // set up appender
-        final JSONLayout layout = JSONLayout.createLayout("true", "true", "true", "false", null);
+        final AbstractJacksonLayout layout = JSONLayout.createLayout("true", "true", "true", "false", null);
         final ListAppender appender = new ListAppender("List", null, layout, true, false);
         appender.start();
 
         // set appender on root and set level to debug
-        this.root.addAppender(appender);
-        this.root.setLevel(Level.DEBUG);
+        this.rootLogger.addAppender(appender);
+        this.rootLogger.setLevel(Level.DEBUG);
 
         // output starting message
-        this.root.debug("Here is a quote ' and then a double quote \"");
+        this.rootLogger.debug("starting mdc pattern test");
+
+        this.rootLogger.debug("empty mdc");
+
+        ThreadContext.put("key1", "value1");
+        ThreadContext.put("key2", "value2");
+
+        this.rootLogger.debug("filled mdc");
+
+        ThreadContext.remove("key1");
+        ThreadContext.remove("key2");
+
+        this.rootLogger.error("finished mdc pattern test", new NullPointerException("test"));
 
         appender.stop();
 
@@ -161,26 +238,37 @@ public class JSONLayoutTest {
 
         this.checkAt("[", 0, list);
         this.checkAt("{", 1, list);
-        this.checkAt("\"logger\":\"root\",", 2, list);
-        this.checkAt("\"level\":\"DEBUG\",", 4, list);
-        this.checkAt("\"message\":\"Here is a quote ' and then a double quote \\\"\",", 6, list);
-        for (Appender app : appenders.values()) {
-            root.addAppender(app);
+        this.checkContains("\"loggerFQCN\" : \"org.apache.logging.log4j.spi.AbstractLoggerProvider\",", list);
+        this.checkContains("\"level\" : \"DEBUG\",", list);
+        this.checkContains("\"message\" : \"starting mdc pattern test\",", list);
+        for (final Appender app : appenders.values()) {
+            this.rootLogger.addAppender(app);
         }
     }
 
-    private void checkAt(String expected, int lineIndex, List<String> list) {
-        final String trimmedLine = list.get(lineIndex).trim();
-        assertTrue("Incorrect line index " + lineIndex + ": \"" + trimmedLine + '"', trimmedLine.equals(expected));
+    @Test
+    public void testLayoutLoggerName() throws Exception {
+        final AbstractJacksonLayout layout = JSONLayout.createLayout("false", null, "false", "true", "UTF-8");
+        final Log4jLogEvent expected = Log4jLogEvent.createEvent("a.B", null, "f.q.c.n", Level.DEBUG, new SimpleMessage("M"), null, null,
+                null, "threadName", null, 1);
+        final String str = layout.toSerializable(expected);
+        assertTrue(str, str.contains("\"loggerName\":\"a.B\""));
+        final Log4jLogEvent actual = new Log4jJsonObjectMapper().readValue(str, Log4jLogEvent.class);
+        assertEquals(expected.getLoggerName(), actual.getLoggerName());
+        assertEquals(expected, actual);
     }
 
-    private void checkAt(String expected, List<String> list, int... lineIndexes) {
-        for (int lineIndex : lineIndexes) {
-            final String trimmedLine = list.get(lineIndex).trim();
-            if (trimmedLine.startsWith(expected)) {
-                return;
-            }
-        }
-        fail("Incorrect lines. Expected: " + expected);
+    @Test
+    public void testLocationOffCompactOffMdcOff() throws Exception {
+        this.testAllFeatures(false, false, false);
+    }
+
+    @Test
+    public void testLocationOnCompactOnMdcOn() throws Exception {
+        this.testAllFeatures(true, true, true);
+    }
+
+    private String toPropertySeparator(final boolean compact) {
+        return compact ? ":" : " : ";
     }
 }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/LogEventFixtures.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/LogEventFixtures.java
new file mode 100644
index 0000000000..042334645c
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/LogEventFixtures.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.layout;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.MarkerManager;
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.helpers.Throwables;
+import org.apache.logging.log4j.core.impl.Log4jLogEvent;
+import org.apache.logging.log4j.core.impl.ThrowableProxy;
+import org.apache.logging.log4j.message.SimpleMessage;
+import org.apache.logging.log4j.spi.DefaultThreadContextStack;
+
+class LogEventFixtures {
+
+    /**
+     * @return a log event that uses all the bells and whistles, features, nooks and crannies
+     */
+    static Log4jLogEvent createLogEvent() {
+        final Marker cMarker = MarkerManager.getMarker("Marker1");
+        final Marker pMarker1 = MarkerManager.getMarker("ParentMarker1");
+        final Marker pMarker2 = MarkerManager.getMarker("ParentMarker2");
+        final Marker gfMarker = MarkerManager.getMarker("GrandFatherMarker");
+        final Marker gmMarker = MarkerManager.getMarker("GrandMotherMarker");
+        cMarker.addParents(pMarker1);
+        cMarker.addParents(gfMarker);
+        pMarker1.addParents(gmMarker);
+        pMarker1.addParents(gfMarker);
+        final Exception sourceHelper = new Exception();
+        sourceHelper.fillInStackTrace();
+        final Exception cause = new NullPointerException("testNPEx");
+        sourceHelper.fillInStackTrace();
+        final StackTraceElement source = sourceHelper.getStackTrace()[0];
+        final IOException ioException = new IOException("testIOEx", cause);
+        Throwables.addSuppressed(ioException, new IndexOutOfBoundsException("I am suppressed exception 1"));
+        Throwables.addSuppressed(ioException, new IndexOutOfBoundsException("I am suppressed exception 2"));
+        final ThrowableProxy throwable = new ThrowableProxy(ioException);
+        final Map<String, String> contextMap = new HashMap<String, String>();
+        contextMap.put("MDC.A", "A_Value");
+        contextMap.put("MDC.B", "B_Value");
+        final DefaultThreadContextStack contextStack = new DefaultThreadContextStack(true);
+        contextStack.clear();
+        contextStack.push("stack_msg1");
+        contextStack.add("stack_msg2");
+        final Log4jLogEvent expected = Log4jLogEvent.createEvent("a.B", cMarker, "f.q.c.n", Level.DEBUG, new SimpleMessage("Msg"),
+                throwable, contextMap, contextStack, "MyThreadName", source, 1);
+        // validate event?
+        return expected;
+    }
+
+    static void assertEqualLogEvents(final LogEvent expected, final LogEvent actual, final boolean includeSource, final boolean includeContext) {
+        assertEquals(expected.getClass(), actual.getClass());
+        assertEquals(includeContext ? expected.getContextMap() : Collections.EMPTY_MAP, actual.getContextMap());
+        assertEquals(expected.getContextStack(), actual.getContextStack());
+        assertEquals(expected.getLevel(), actual.getLevel());
+        assertEquals(expected.getLoggerName(), actual.getLoggerName());
+        assertEquals(expected.getLoggerFQCN(), actual.getLoggerFQCN());
+        assertEquals(expected.getMarker(), actual.getMarker());
+        assertEquals(expected.getMessage(), actual.getMessage());
+        assertEquals(expected.getTimeMillis(), actual.getTimeMillis());
+        assertEquals(includeSource ? expected.getSource() : null, actual.getSource());
+        assertEquals(expected.getThreadName(), actual.getThreadName());
+        assertEquals(expected.getThrownProxy(), actual.getThrownProxy());
+        assertEquals(expected.isEndOfBatch(), actual.isEndOfBatch());
+        assertEquals(expected.isIncludeLocation(), actual.isIncludeLocation());
+        if (includeSource) {
+            assertEquals(expected.hashCode(), actual.hashCode());
+            assertEquals(expected, actual);
+        }
+    }
+
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/XMLLayoutTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/XMLLayoutTest.java
index f97a1ecaa2..1fd2840e3f 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/XMLLayoutTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/layout/XMLLayoutTest.java
@@ -17,8 +17,10 @@
 package org.apache.logging.log4j.core.layout;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
+import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 
@@ -33,26 +35,35 @@ import org.apache.logging.log4j.core.Logger;
 import org.apache.logging.log4j.core.LoggerContext;
 import org.apache.logging.log4j.core.config.ConfigurationFactory;
 import org.apache.logging.log4j.core.helpers.Charsets;
+import org.apache.logging.log4j.core.impl.Log4jLogEvent;
+import org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper;
+import org.apache.logging.log4j.message.SimpleMessage;
 import org.apache.logging.log4j.test.appender.ListAppender;
 import org.junit.AfterClass;
+import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
+import com.fasterxml.jackson.core.JsonParseException;
+import com.fasterxml.jackson.databind.JsonMappingException;
+
 /**
- *
+ * Tests {@link XMLLayout}.
  */
 public class XMLLayoutTest {
-    private static final String body = "<Message><![CDATA[empty mdc]]></Message>";
-    private static final String markerTag = "<Marker>EVENT</Marker>";
+    private static final String body = "<Message>empty mdc</Message>";
     static ConfigurationFactory cf = new BasicConfigurationFactory();
+    private static final String markerTag = "<Marker name=\"EVENT\"/>";
 
     @AfterClass
     public static void cleanupClass() {
         ConfigurationFactory.removeConfigurationFactory(cf);
+        ThreadContext.clearAll();
     }
 
     @BeforeClass
     public static void setupClass() {
+        ThreadContext.clearAll();
         ConfigurationFactory.setConfigurationFactory(cf);
         final LoggerContext ctx = (LoggerContext) LogManager.getContext();
         ctx.reconfigure();
@@ -60,17 +71,126 @@ public class XMLLayoutTest {
 
     LoggerContext ctx = (LoggerContext) LogManager.getContext();
 
-    Logger root = ctx.getLogger("");
+    Logger rootLogger = this.ctx.getLogger("");
+
+    private void checkAttribute(final String name, final String value, final boolean compact, final String str) {
+        Assert.assertTrue(str, str.contains(name + "=\"" + value + "\""));
+    }
+
+    private void checkAttributeName(final String name, final boolean compact, final String str) {
+        Assert.assertTrue(str, str.contains(name + "=\""));
+    }
+
+    private void checkContains(final String expected, final List<String> list) {
+        for (final String string : list) {
+            final String trimedLine = string.trim();
+            if (trimedLine.contains(expected)) {
+                return;
+            }
+        }
+        Assert.fail("Cannot find " + expected + " in " + list);
+    }
+
+    private void checkElement(final String key, final String value, final boolean compact, final String str) {
+        // <item key="MDC.A" value="A_Value"/>
+        assertTrue(str, str.contains(String.format("<item key=\"%s\" value=\"%s\"/>", key, value)));
+    }
+
+    private void checkElementName(final String name, final boolean compact, final String str, final boolean withAttributes,
+            final boolean withChildren) {
+        // simple checks, don't try to be too smart here, we're just looking for the names and basic shape.
+        // start
+        final String startStr = withAttributes ? "<" + name + " " : "<" + name + ">";
+        final int startPos = str.indexOf(startStr);
+        Assert.assertTrue(str, startPos >= 0);
+        // end
+        final String endStr = withChildren ? "</" + name + ">" : "/>";
+        final int endPos = str.indexOf(endStr, startPos + startStr.length());
+        Assert.assertTrue(str, endPos >= 0);
+    }
+
+    /**
+     * @param includeSource TODO
+     * @param compact
+     * @param includeContext TODO
+     * @throws IOException
+     * @throws JsonParseException
+     * @throws JsonMappingException
+     */
+    private void testAllFeatures(final boolean includeSource, final boolean compact, final boolean includeContext) throws IOException,
+            JsonParseException, JsonMappingException {
+        final Log4jLogEvent expected = LogEventFixtures.createLogEvent();
+        final XMLLayout layout = XMLLayout.createLayout(Boolean.toString(includeSource), Boolean.toString(includeContext), "false",
+                Boolean.toString(compact), "UTF-8");
+        final String str = layout.toSerializable(expected);
+        assertEquals(str, !compact, str.contains("\n"));
+        assertEquals(str, includeSource, str.contains("Source"));
+        assertEquals(str, includeContext, str.contains("ContextMap"));
+        final Log4jLogEvent actual = new Log4jXmlObjectMapper().readValue(str, Log4jLogEvent.class);
+        LogEventFixtures.assertEqualLogEvents(expected, actual, includeSource, includeContext);
+        if (includeContext) {
+            this.checkElement("MDC.A", "A_Value", compact, str);
+            this.checkElement("MDC.B", "B_Value", compact, str);
+        }
+
+        //
+        assertNull(actual.getThrown());
+        // check some attrs
+        assertTrue(str, str.contains("loggerFQCN=\"f.q.c.n\""));
+        assertTrue(str, str.contains("loggerName=\"a.B\""));
+        // make sure short names are used
+        assertTrue(str, str.contains("<Event "));
+        assertTrue(str, str.contains("class="));
+        assertTrue(str, str.contains("method="));
+        assertTrue(str, str.contains("file="));
+        assertTrue(str, str.contains("line="));
+        //
+        // make sure the names we want are used
+        this.checkAttributeName("timeMillis", compact, str);
+        this.checkAttributeName("thread", compact, str); // and not threadName
+        this.checkAttributeName("level", compact, str);
+        this.checkAttributeName("loggerName", compact, str);
+        this.checkElementName("Marker", compact, str, true, true);
+        this.checkAttributeName("name", compact, str);
+        this.checkElementName("Parents", compact, str, false, true);
+        this.checkElementName("Message", compact, str, false, true);
+        this.checkElementName("Thrown", compact, str, true, true);
+        this.checkElementName("Cause", compact, str, true, true);
+        this.checkAttributeName("class", compact, str);
+        this.checkAttributeName("method", compact, str);
+        this.checkAttributeName("file", compact, str);
+        this.checkAttributeName("line", compact, str);
+        this.checkAttributeName("exact", compact, str);
+        this.checkAttributeName("location", compact, str);
+        this.checkAttributeName("version", compact, str);
+        this.checkAttributeName("commonElementCount", compact, str);
+        this.checkAttributeName("message", compact, str);
+        this.checkAttributeName("localizedMessage", compact, str);
+        this.checkElementName("ExtendedStackTrace", compact, str, false, true);
+        this.checkElementName("Suppressed", compact, str, false, true);
+        this.checkAttributeName("loggerFQCN", compact, str);
+        this.checkAttributeName("endOfBatch", compact, str);
+        if (includeContext) {
+            this.checkElementName("ContextMap", compact, str, false, true);
+        }
+        this.checkElementName("ContextStack", compact, str, false, true);
+        if (includeSource) {
+            this.checkElementName("Source", compact, str, true, false);
+        }
+        // check some attrs
+        this.checkAttribute("loggerFQCN", "f.q.c.n", compact, str);
+        this.checkAttribute("loggerName", "a.B", compact, str);
+    }
 
     @Test
     public void testContentType() {
-        final XMLLayout layout = XMLLayout.createLayout(null, null, null, null, null, null);
+        final XMLLayout layout = XMLLayout.createLayout(null, null, null, null, null);
         assertEquals("text/xml; charset=UTF-8", layout.getContentType());
     }
 
     @Test
     public void testDefaultCharset() {
-        final XMLLayout layout = XMLLayout.createLayout(null, null, null, null, null, null);
+        final XMLLayout layout = XMLLayout.createLayout(null, null, null, null, null);
         assertEquals(Charsets.UTF_8, layout.getCharset());
     }
 
@@ -79,51 +199,74 @@ public class XMLLayoutTest {
      */
     @Test
     public void testLayout() throws Exception {
-        final Map<String, Appender> appenders = root.getAppenders();
-        for (Appender appender : appenders.values()) {
-            root.removeAppender(appender);
+        final Map<String, Appender> appenders = this.rootLogger.getAppenders();
+        for (final Appender appender : appenders.values()) {
+            this.rootLogger.removeAppender(appender);
         }
         // set up appender
-        final XMLLayout layout = XMLLayout.createLayout("true", "true", "true", null, null, null);
+        final XMLLayout layout = XMLLayout.createLayout("true", "true", "true", null, null);
         final ListAppender appender = new ListAppender("List", null, layout, true, false);
         appender.start();
 
         // set appender on root and set level to debug
-        root.addAppender(appender);
-        root.setLevel(Level.DEBUG);
+        this.rootLogger.addAppender(appender);
+        this.rootLogger.setLevel(Level.DEBUG);
 
         // output starting message
-        root.debug("starting mdc pattern test");
+        this.rootLogger.debug("starting mdc pattern test");
 
-        root.debug("empty mdc");
+        this.rootLogger.debug("empty mdc");
 
         ThreadContext.put("key1", "value1");
         ThreadContext.put("key2", "value2");
 
-        root.debug("filled mdc");
+        this.rootLogger.debug("filled mdc");
 
         ThreadContext.remove("key1");
         ThreadContext.remove("key2");
 
-        root.error("finished mdc pattern test", new NullPointerException("test"));
+        this.rootLogger.error("finished mdc pattern test", new NullPointerException("test"));
 
         final Marker marker = MarkerManager.getMarker("EVENT");
-        root.error(marker, "marker test");
+        this.rootLogger.error(marker, "marker test");
 
         appender.stop();
 
         final List<String> list = appender.getMessages();
 
-        assertTrue("Incorrect number of lines. Require at least 50 " + list.size(), list.size() > 50);
         final String string = list.get(0);
         assertTrue("Incorrect header: " + string, string.equals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
         assertTrue("Incorrect footer", list.get(list.size() - 1).equals("</Events>"));
-        assertTrue("Incorrect body. Expected " + body + " Actual: " + list.get(7), list.get(7).trim().equals(body));
+        this.checkContains("loggerFQCN=\"org.apache.logging.log4j.spi.AbstractLoggerProvider\"", list);
+        this.checkContains("level=\"DEBUG\"", list);
+        this.checkContains(">starting mdc pattern test</Message>", list);
+        // this.checkContains("<Message>starting mdc pattern test</Message>", list);
+
+        // <Marker xmlns="" _class="org.apache.logging.log4j.MarkerManager..Log4jMarker" name="EVENT"/>
+        this.checkContains("<Marker", list);
+        this.checkContains("name=\"EVENT\"/>", list);
 
-        assertTrue("Missing Marker-Tag, Expected " + markerTag + ", Actual" + list.get(list.size() - 4),
-                list.get(list.size() - 4).contains(markerTag));
-        for (Appender app : appenders.values()) {
-            root.addAppender(app);
+        for (final Appender app : appenders.values()) {
+            this.rootLogger.addAppender(app);
         }
     }
+
+    @Test
+    public void testLayoutLoggerName() {
+        final XMLLayout layout = XMLLayout.createLayout("false", "true", "true", null, null);
+        final Log4jLogEvent event = Log4jLogEvent.createEvent("a.B", null, "f.q.c.n", Level.DEBUG, new SimpleMessage("M"), null, null,
+                null, "threadName", null, 1);
+        final String str = layout.toSerializable(event);
+        assertTrue(str, str.contains("loggerName=\"a.B\""));
+    }
+
+    @Test
+    public void testLocationOffCompactOffMdcOff() throws Exception {
+        this.testAllFeatures(false, false, false);
+    }
+
+    @Test
+    public void testLocationOnCompactOnMdcOn() throws Exception {
+        this.testAllFeatures(true, true, true);
+    }
 }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/AbstractSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/AbstractSocketServerTest.java
similarity index 72%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/AbstractSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/AbstractSocketServerTest.java
index 56c9595f9c..21778e152b 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/AbstractSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/AbstractSocketServerTest.java
@@ -14,8 +14,9 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
@@ -42,6 +43,7 @@ import org.apache.logging.log4j.core.layout.PatternLayout;
 import org.apache.logging.log4j.core.layout.XMLLayout;
 import org.apache.logging.log4j.test.appender.ListAppender;
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Test;
 
 /**
@@ -61,20 +63,24 @@ public abstract class AbstractSocketServerTest {
         }
     }
 
-    private static final String MESSAGE_1 = "This is a test message";
+    private static final String MESSAGE = "This is test message";
 
     private static final String MESSAGE_2 = "This is test message 2";
 
+    static final String PORT = "8199";
+
+    static final int PORT_NUM = Integer.parseInt(PORT);
+
     private final LoggerContext ctx = (LoggerContext) LogManager.getContext(false);
-    
+
     private final boolean expectLengthException;
 
     private final String port;
 
     private final String protocol;
-    
+
     private final Logger root = ctx.getLogger(AbstractSocketServerTest.class.getSimpleName());
-    
+
     protected AbstractSocketServerTest(final String protocol, final String port, final boolean expectLengthException) {
         this.protocol = protocol;
         this.port = port;
@@ -82,7 +88,7 @@ public abstract class AbstractSocketServerTest {
     }
 
     protected Layout<String> createJsonLayout() {
-        return JSONLayout.createLayout("true", "true", "true", "false", null);
+        return JSONLayout.createLayout("true", "true", "false", "false", null);
     }
 
     protected abstract Layout<? extends Serializable> createLayout();
@@ -92,19 +98,46 @@ public abstract class AbstractSocketServerTest {
     }
 
     protected Layout<String> createXmlLayout() {
-        return XMLLayout.createLayout("true", "true", "true", null, null, null);
+        return XMLLayout.createLayout("true", "true", "false", null, null);
     }
 
     @After
     public void tearDown() {
         final Map<String, Appender> map = root.getAppenders();
         for (final Map.Entry<String, Appender> entry : map.entrySet()) {
-            final Appender app = entry.getValue();
-            root.removeAppender(app);
-            app.stop();
+            final Appender appender = entry.getValue();
+            root.removeAppender(appender);
+            appender.stop();
         }
     }
 
+    @Test
+    @Ignore("Broken test?")
+    public void test1000ShortMessages() throws Exception {
+        testServer(1000);
+    }
+
+    @Test
+    @Ignore("Broken test?")
+    public void test100ShortMessages() throws Exception {
+        testServer(100);
+    }
+
+    @Test
+    public void test10ShortMessages() throws Exception {
+        testServer(10);
+    }
+
+    @Test
+    public void test1ShortMessages() throws Exception {
+        testServer(1);
+    }
+
+    @Test
+    public void test2ShortMessages() throws Exception {
+        testServer(2);
+    }
+
     @Test
     public void test64KMessages() throws Exception {
         final char[] a64K = new char[1024 * 64];
@@ -114,7 +147,6 @@ public abstract class AbstractSocketServerTest {
         if (expectLengthException) {
             try {
                 testServer(m1, m2);
-
             } catch (final AppenderLoggingException are) {
                 assertTrue("", are.getCause() != null && are.getCause() instanceof IOException);
                 // Failure expected.
@@ -124,17 +156,26 @@ public abstract class AbstractSocketServerTest {
         }
     }
 
-    protected void testServer(final String message1, final String message2) throws Exception {
+    private void testServer(final int size) throws Exception {
+        final String[] messages = new String[size];
+        for (int i = 0; i < messages.length; i++) {
+            messages[i] = MESSAGE + " " + i;
+        }
+        testServer(messages);
+    }
+
+    protected void testServer(final String... messages) throws Exception {
         final Filter socketFilter = new ThreadFilter(Filter.Result.NEUTRAL, Filter.Result.DENY);
         final Filter serverFilter = new ThreadFilter(Filter.Result.DENY, Filter.Result.NEUTRAL);
         final Layout<? extends Serializable> socketLayout = createLayout();
-        final SocketAppender appender = SocketAppender.createAppender("localhost", this.port, this.protocol, "-1", null, "Test", null,
-                "false", socketLayout, socketFilter, null, null);
+        final SocketAppender appender = SocketAppender.createAppender("localhost", this.port, this.protocol, "-1",
+                null, "Test", null, "false", socketLayout, socketFilter, null, null);
         appender.start();
         final ListAppender listApp = new ListAppender("Events", serverFilter, null, false, false);
         listApp.start();
         final PatternLayout layout = PatternLayout.createLayout("%m %ex%n", null, null, null, null, null, null, null);
-        final ConsoleAppender console = ConsoleAppender.createAppender(layout, null, "SYSTEM_OUT", "Console", "false", "true");
+        final ConsoleAppender console = ConsoleAppender.createAppender(layout, null, "SYSTEM_OUT", "Console", "false",
+                "true");
         final Logger serverLogger = ctx.getLogger(this.getClass().getName());
         serverLogger.addAppender(console);
         serverLogger.setAdditive(false);
@@ -144,20 +185,16 @@ public abstract class AbstractSocketServerTest {
         root.addAppender(listApp);
         root.setAdditive(false);
         root.setLevel(Level.DEBUG);
-        root.debug(message1);
-        root.debug(message2);
-        Thread.sleep(100);
+        for (final String message : messages) {
+            root.debug(message);
+        }
+        Thread.sleep(2000);
         final List<LogEvent> events = listApp.getEvents();
         assertNotNull("No event retrieved", events);
-        assertTrue("No events retrieved", events.size() > 0);
-        assertTrue("Incorrect event", events.get(0).getMessage().getFormattedMessage().equals(message1));
-        assertTrue("Incorrect number of events received: " + events.size(), events.size() == 2);
-        assertTrue("Incorrect event", events.get(1).getMessage().getFormattedMessage().equals(message2));
-    }
-
-    @Test
-    public void testShortMessages() throws Exception {
-        testServer(MESSAGE_1, MESSAGE_2);
+        assertEquals("Incorrect number of events received", messages.length, events.size());
+        for (int i = 0; i < messages.length; i++) {
+            assertTrue("Incorrect event", events.get(i).getMessage().getFormattedMessage().equals(messages[i]));
+        }
     }
 
 }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpJsonSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpJsonSocketServerTest.java
similarity index 88%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpJsonSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpJsonSocketServerTest.java
index db14b19f6f..df47314dc1 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpJsonSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpJsonSocketServerTest.java
@@ -14,8 +14,9 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
+import java.io.IOException;
 import java.io.InputStream;
 
 import org.apache.logging.log4j.LogManager;
@@ -25,10 +26,8 @@ import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
 
-@Ignore("Not implemented yet")
+//@Ignore("Not implemented yet")
 public class TcpJsonSocketServerTest extends AbstractSocketServerTest {
-    private static final String PORT = "8198";
-    private static final int PORT_NUM = Integer.parseInt(PORT);
     private static TCPSocketServer<InputStream> tcpSocketServer;
 
     private static Thread thread;
@@ -43,7 +42,11 @@ public class TcpJsonSocketServerTest extends AbstractSocketServerTest {
 
     @AfterClass
     public static void tearDownClass() {
-        tcpSocketServer.shutdown();
+        try {
+            tcpSocketServer.shutdown();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
         try {
             thread.join();
         } catch (final InterruptedException e) {
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpSerializedSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpSerializedSocketServerTest.java
similarity index 90%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpSerializedSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpSerializedSocketServerTest.java
index 5142cba7dc..237baf3ac6 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpSerializedSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpSerializedSocketServerTest.java
@@ -14,8 +14,9 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
+import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 
@@ -26,8 +27,6 @@ import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
 public class TcpSerializedSocketServerTest extends AbstractSocketServerTest {
-    private static final String PORT = "8198";
-    private static final int PORT_NUM = Integer.parseInt(PORT);
     private static TCPSocketServer<ObjectInputStream> tcpSocketServer;
 
     private static Thread thread;
@@ -42,7 +41,11 @@ public class TcpSerializedSocketServerTest extends AbstractSocketServerTest {
 
     @AfterClass
     public static void tearDownClass() {
-        tcpSocketServer.shutdown();
+        try {
+            tcpSocketServer.shutdown();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
         try {
             thread.join();
         } catch (final InterruptedException e) {
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpXmlSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpXmlSocketServerTest.java
similarity index 74%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpXmlSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpXmlSocketServerTest.java
index c4f860641c..aecfc55199 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/TcpXmlSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/TcpXmlSocketServerTest.java
@@ -14,36 +14,39 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
+import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.Charset;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.core.Layout;
 import org.apache.logging.log4j.core.LoggerContext;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 
-@Ignore("Not implemented yet")
 public class TcpXmlSocketServerTest extends AbstractSocketServerTest {
-    private static final String PORT = "8198";
-    private static final int PORT_NUM = Integer.parseInt(PORT);
-    private static TCPSocketServer<InputStream> tcpSocketServer;
-
+    private static TCPSocketServer<InputStream> socketServer;
     private static Thread thread;
 
     @BeforeClass
     public static void setupClass() throws Exception {
         ((LoggerContext) LogManager.getContext(false)).reconfigure();
-        tcpSocketServer = TCPSocketServer.createXmlSocketServer(PORT_NUM);
-        thread = new Thread(tcpSocketServer);
+        // Use a large buffer just to test the code, the UDP test uses a tiny buffer
+        socketServer = new TCPSocketServer<InputStream>(PORT_NUM, new XmlInputStreamLogEventBridge(1024 * 100,
+                Charset.defaultCharset()));
+        thread = new Thread(socketServer);
         thread.start();
     }
 
     @AfterClass
     public static void tearDownClass() {
-        tcpSocketServer.shutdown();
+        try {
+            socketServer.shutdown();
+        } catch (final IOException e) {
+            e.printStackTrace();
+        }
         try {
             thread.join();
         } catch (final InterruptedException e) {
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpJsonSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpJsonSocketServerTest.java
similarity index 91%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpJsonSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpJsonSocketServerTest.java
index 0f4fba8168..d4276f0b7c 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpJsonSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpJsonSocketServerTest.java
@@ -14,7 +14,7 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.InputStream;
 import java.io.Serializable;
@@ -26,10 +26,8 @@ import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Ignore;
 
-@Ignore("Not implemented yet")
+//@Ignore("Not implemented yet")
 public class UdpJsonSocketServerTest extends AbstractSocketServerTest {
-    private static final String PORT = "8199";
-    private static final int PORT_NUM = Integer.parseInt(PORT);
     private static Thread thread;
     private static UDPSocketServer<InputStream> udpSocketServer;
 
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpSerializedSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpSerializedSocketServerTest.java
similarity index 92%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpSerializedSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpSerializedSocketServerTest.java
index efce24ba38..9678b7d15e 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpSerializedSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpSerializedSocketServerTest.java
@@ -14,7 +14,7 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.ObjectInputStream;
 import java.io.Serializable;
@@ -26,8 +26,6 @@ import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
 public class UdpSerializedSocketServerTest extends AbstractSocketServerTest {
-    private static final String PORT = "8199";
-    private static final int PORT_NUM = Integer.parseInt(PORT);
     private static Thread thread;
     private static UDPSocketServer<ObjectInputStream> udpSocketServer;
 
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpXmlSocketServerTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpXmlSocketServerTest.java
similarity index 79%
rename from log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpXmlSocketServerTest.java
rename to log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpXmlSocketServerTest.java
index 28225f25e8..a0d41a72fa 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/net/UdpXmlSocketServerTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/net/server/UdpXmlSocketServerTest.java
@@ -14,36 +14,35 @@
  * See the license for the specific language governing permissions and
  * limitations under the license.
  */
-package org.apache.logging.log4j.core.net;
+package org.apache.logging.log4j.core.net.server;
 
 import java.io.InputStream;
 import java.io.Serializable;
+import java.nio.charset.Charset;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.core.Layout;
 import org.apache.logging.log4j.core.LoggerContext;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Ignore;
 
-@Ignore("Not implemented yet")
 public class UdpXmlSocketServerTest extends AbstractSocketServerTest {
-    private static final String PORT = "8199";
-    private static final int PORT_NUM = Integer.parseInt(PORT);
+    private static UDPSocketServer<InputStream> socketServer;
     private static Thread thread;
-    private static UDPSocketServer<InputStream> udpSocketServer;
 
     @BeforeClass
     public static void setupClass() throws Exception {
         ((LoggerContext) LogManager.getContext(false)).reconfigure();
-        udpSocketServer = UDPSocketServer.createXmlSocketServer(PORT_NUM);
-        thread = new Thread(udpSocketServer);
+        // Use a tiny buffer just to test the code, the TCP test uses a large buffer
+        socketServer = new UDPSocketServer<InputStream>(PORT_NUM, new XmlInputStreamLogEventBridge(100,
+                Charset.defaultCharset()));
+        thread = new Thread(socketServer);
         thread.start();
     }
 
     @AfterClass
     public static void tearDownClass() {
-        udpSocketServer.shutdown();
+        socketServer.shutdown();
         try {
             thread.join();
         } catch (final InterruptedException e) {
diff --git a/pom.xml b/pom.xml
index bd733f068a..8716a7b634 100644
--- a/pom.xml
+++ b/pom.xml
@@ -455,6 +455,18 @@
         <version>${jackson2.version}</version>
         <optional>true</optional>
       </dependency>
+      <dependency>
+        <groupId>com.fasterxml.jackson.dataformat</groupId>
+        <artifactId>jackson-dataformat-xml</artifactId>
+        <version>${jackson2.version}</version>
+        <optional>true</optional>
+      </dependency>
+      <dependency>
+        <groupId>com.fasterxml.jackson.module</groupId>
+        <artifactId>jackson-module-jaxb-annotations</artifactId>
+        <version>${jackson2.version}</version>
+        <optional>true</optional>
+      </dependency>      
       <!-- Jackson 2 end -->
       <dependency>
         <groupId>com.sun.mail</groupId>
