diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java
index 4c692e25ed..b288510734 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java
@@ -66,7 +66,7 @@ public class PatternProcessor {
         final PatternParser parser = createPatternParser();
         final List<PatternConverter> converters = new ArrayList<PatternConverter>();
         final List<FormattingInfo> fields = new ArrayList<FormattingInfo>();
-        parser.parse(pattern, converters, fields, false);
+        parser.parse(pattern, converters, fields, false, false);
         final FormattingInfo[] infoArray = new FormattingInfo[fields.size()];
         patternFields = fields.toArray(infoArray);
         final ArrayPatternConverter[] converterArray = new ArrayPatternConverter[converters.size()];
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverter.java
index 6474c29853..7574750d0e 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverter.java
@@ -39,10 +39,12 @@ public final class LiteralPatternConverter extends LogEventPatternConverter impl
      *
      * @param config The Configuration.
      * @param literal string literal.
+     * @param convertBackslashes if {@code true}, backslash characters are treated as escape characters and character
+     *            sequences like "\" followed by "t" (backslash+t) are converted to special characters like '\t' (tab).
      */
-    public LiteralPatternConverter(final Configuration config, final String literal) {
+    public LiteralPatternConverter(final Configuration config, final String literal, boolean convertBackslashes) {
         super("Literal", "literal");
-        this.literal = OptionConverter.convertSpecialChars(literal);
+        this.literal = convertBackslashes ? OptionConverter.convertSpecialChars(literal) : literal; // LOG4J2-829
         this.config = config;
         substitute = config != null && literal.contains("${");
     }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java
index 531ae2e4f0..08ae3eb2ef 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/PatternParser.java
@@ -166,7 +166,7 @@ public final class PatternParser {
         final List<PatternConverter> converters = new ArrayList<PatternConverter>();
         final List<FormattingInfo> fields = new ArrayList<FormattingInfo>();
 
-        parse(pattern, converters, fields, noConsoleNoAnsi);
+        parse(pattern, converters, fields, noConsoleNoAnsi, true);
 
         final Iterator<FormattingInfo> fieldIter = fields.iterator();
         boolean handlesThrowable = false;
@@ -177,7 +177,7 @@ public final class PatternParser {
                 pc = (LogEventPatternConverter) converter;
                 handlesThrowable |= pc.handlesThrowable();
             } else {
-                pc = new LiteralPatternConverter(config, Strings.EMPTY);
+                pc = new LiteralPatternConverter(config, Strings.EMPTY, true);
             }
 
             FormattingInfo field;
@@ -294,9 +294,12 @@ public final class PatternParser {
      *            list to receive field specifiers corresponding to pattern converters.
      * @param noConsoleNoAnsi
      *            TODO
+     * @param convertBackslashes if {@code true}, backslash characters are treated as escape characters and character
+     *            sequences like "\" followed by "t" (backslash+t) are converted to special characters like '\t' (tab).
      */
     public void parse(final String pattern, final List<PatternConverter> patternConverters,
-            final List<FormattingInfo> formattingInfos, final boolean noConsoleNoAnsi) {
+            final List<FormattingInfo> formattingInfos, final boolean noConsoleNoAnsi,
+            final boolean convertBackslashes) {
         if (pattern == null) {
             throw new NullPointerException("pattern");
         }
@@ -334,7 +337,8 @@ public final class PatternParser {
                     default:
 
                         if (currentLiteral.length() != 0) {
-                            patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString()));
+                            patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString(),
+                                    convertBackslashes));
                             formattingInfos.add(FormattingInfo.getDefault());
                         }
 
@@ -370,7 +374,7 @@ public final class PatternParser {
                         state = ParserState.MIN_STATE;
                     } else {
                         i = finalizeConverter(c, pattern, i, currentLiteral, formattingInfo, converterRules,
-                                patternConverters, formattingInfos, noConsoleNoAnsi);
+                                patternConverters, formattingInfos, noConsoleNoAnsi, convertBackslashes);
 
                         // Next pattern is assumed to be a literal.
                         state = ParserState.LITERAL_STATE;
@@ -392,7 +396,7 @@ public final class PatternParser {
                     state = ParserState.DOT_STATE;
                 } else {
                     i = finalizeConverter(c, pattern, i, currentLiteral, formattingInfo, converterRules,
-                            patternConverters, formattingInfos, noConsoleNoAnsi);
+                            patternConverters, formattingInfos, noConsoleNoAnsi, convertBackslashes);
                     state = ParserState.LITERAL_STATE;
                     formattingInfo = FormattingInfo.getDefault();
                     currentLiteral.setLength(0);
@@ -425,7 +429,7 @@ public final class PatternParser {
                             formattingInfo.getMaxLength() * DECIMAL + c - '0');
                 } else {
                     i = finalizeConverter(c, pattern, i, currentLiteral, formattingInfo, converterRules,
-                            patternConverters, formattingInfos, noConsoleNoAnsi);
+                            patternConverters, formattingInfos, noConsoleNoAnsi, convertBackslashes);
                     state = ParserState.LITERAL_STATE;
                     formattingInfo = FormattingInfo.getDefault();
                     currentLiteral.setLength(0);
@@ -437,7 +441,7 @@ public final class PatternParser {
 
         // while
         if (currentLiteral.length() != 0) {
-            patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString()));
+            patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString(), convertBackslashes));
             formattingInfos.add(FormattingInfo.getDefault());
         }
     }
@@ -560,12 +564,14 @@ public final class PatternParser {
      *            list to receive corresponding field specifier.
      * @param noConsoleNoAnsi
      *            TODO
+     * @param convertBackslashes if {@code true}, backslash characters are treated as escape characters and character
+     *            sequences like "\" followed by "t" (backslash+t) are converted to special characters like '\t' (tab).
      * @return position after format specifier sequence.
      */
     private int finalizeConverter(final char c, final String pattern, int i, final StringBuilder currentLiteral,
             final FormattingInfo formattingInfo, final Map<String, Class<PatternConverter>> rules,
             final List<PatternConverter> patternConverters, final List<FormattingInfo> formattingInfos,
-            final boolean noConsoleNoAnsi) {
+            final boolean noConsoleNoAnsi, boolean convertBackslashes) {
         final StringBuilder convBuf = new StringBuilder();
         i = extractConverter(c, pattern, i, convBuf, currentLiteral);
 
@@ -592,14 +598,15 @@ public final class PatternParser {
 
             LOGGER.error(msg.toString());
 
-            patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString()));
+            patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString(), convertBackslashes));
             formattingInfos.add(FormattingInfo.getDefault());
         } else {
             patternConverters.add(pc);
             formattingInfos.add(formattingInfo);
 
             if (currentLiteral.length() > 0) {
-                patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString()));
+                patternConverters.add(new LiteralPatternConverter(config, currentLiteral.toString(),
+                        convertBackslashes));
                 formattingInfos.add(FormattingInfo.getDefault());
             }
         }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessorTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessorTest.java
index 7e5ebedb07..babce8902d 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessorTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessorTest.java
@@ -195,4 +195,13 @@ public class PatternProcessorTest {
         expected.set(Calendar.MILLISECOND, 124);
         assertEquals(format(expected.getTimeInMillis()), format(actual));
     }
+    
+    @Test
+    public void testDontInterpretBackslashAsEscape() {
+        final PatternProcessor pp = new PatternProcessor("c:\\test\\new/app-%d{HH-mm-ss}.log");
+        final StringBuilder buf = new StringBuilder();
+        final Date date = new Date(1411142535260L); // Sat Sep 20 01:02:15 JST 2014
+        pp.formatFileName(buf, date, 23);
+        assertEquals("c:\\test\\new/app-01-02-15.log", buf.toString());
+    }
 }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverterTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverterTest.java
new file mode 100644
index 0000000000..3b8835b31f
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/LiteralPatternConverterTest.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+
+package org.apache.logging.log4j.core.pattern;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Tests the LiteralPatternConverter.
+ */
+public class LiteralPatternConverterTest {
+
+    @Test
+    public void testConvertBackslashes() {
+        final String literal = "ABC\\tDEF\\nGHI\\rJKL\\'MNO\\f \\b \\\\DROPPED:\\x";
+        final LiteralPatternConverter converter = new LiteralPatternConverter(null, literal, true);
+        assertEquals("ABC\tDEF\nGHI\rJKL\'MNO\f \b \\DROPPED:x", converter.getLiteral());
+    }
+
+    @Test
+    public void testDontConvertBackslashes() {
+        final String literal = "ABC\\tDEF\\nGHI\\rJKL\\'MNO\\f \\b \\\\DROPPED:\\x";
+        final LiteralPatternConverter converter = new LiteralPatternConverter(null, literal, false);
+        assertEquals(literal, converter.getLiteral());
+    }
+
+}
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/PatternParserTest2.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/PatternParserTest2.java
new file mode 100644
index 0000000000..72c385110b
--- /dev/null
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/pattern/PatternParserTest2.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+package org.apache.logging.log4j.core.pattern;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ *
+ */
+public class PatternParserTest2 {
+
+    @Test
+    public void testParseConvertBackslashes() {
+        final boolean convert = true;
+        final StringBuilder buf = new StringBuilder();
+        final String pattern = "%d{HHmmss} \\t ...";
+
+        final Date date = new Date(1411142535260L); // Sat Sep 20 01:02:15 JST 2014
+        parse(pattern, convert, buf, date, 123);
+
+        assertEquals("010215 \t ...", buf.toString());
+    }
+
+    @Test
+    public void testParseDontConvertBackslashes() {
+        final boolean convert = false;
+        final StringBuilder buf = new StringBuilder();
+        final String pattern = "%d{HHmmss} \\t---";
+
+        final Date date = new Date(1411142535260L); // Sat Sep 20 01:02:15 JST 2014
+        parse(pattern, convert, buf, date, new Integer(3));
+
+        assertEquals("010215 \\t---", buf.toString());
+    }
+
+    private void parse(String pattern, boolean convert, StringBuilder buf, Date date, int i) {
+        final PatternParser parser0 = new PatternParser(null, "Converter", null);
+        final List<PatternConverter> converters = new ArrayList<PatternConverter>();
+        final List<FormattingInfo> fields = new ArrayList<FormattingInfo>();
+        parser0.parse(pattern, converters, fields, false, convert);
+        final FormattingInfo[] infoArray = new FormattingInfo[fields.size()];
+        final FormattingInfo[] patternFields = fields.toArray(infoArray);
+        final ArrayPatternConverter[] converterArray = new ArrayPatternConverter[converters.size()];
+        final ArrayPatternConverter[] patternConverters = converters.toArray(converterArray);
+        formatFileName(patternConverters, patternFields, buf, date, i);
+    }
+
+    /**
+     * Format file name.
+     * 
+     * @param buf string buffer to which formatted file name is appended, may not be null.
+     * @param objects objects to be evaluated in formatting, may not be null.
+     */
+    protected final void formatFileName(final ArrayPatternConverter[] patternConverters,
+            final FormattingInfo[] patternFields, final StringBuilder buf, final Object... objects) {
+        for (int i = 0; i < patternConverters.length; i++) {
+            final int fieldStart = buf.length();
+            patternConverters[i].format(buf, objects);
+
+            if (patternFields[i] != null) {
+                patternFields[i].format(fieldStart, buf);
+            }
+        }
+    }
+}
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 9da023b8a9..274a31dbca 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -24,6 +24,9 @@
   </properties>
   <body>
     <release version="2.1" date="2014-??-??" description="Bug fixes and enhancements">
+      <action issue="LOG4J2-829" dev="rpopma" type="fix">
+        Fixed issue in RollingFile filePattern: backslashes are path separators, not escape characters.
+      </action>
       <action issue="LOG4J2-547" dev="mattsicker" type="add">
         Add the Log4j IOStreams component.
       </action>
