diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java
index e9c7790655..22ce948a78 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java
@@ -39,6 +39,7 @@ import org.apache.logging.log4j.core.appender.rolling.action.AbstractAction;
 import org.apache.logging.log4j.core.appender.rolling.action.Action;
 import org.apache.logging.log4j.core.config.Configuration;
 import org.apache.logging.log4j.core.util.Constants;
+import org.apache.logging.log4j.core.util.Log4jThreadFactory;
 
 /**
  * The Rolling File Manager.
@@ -52,6 +53,7 @@ public class RollingFileManager extends FileManager {
     private long initialTime;
     private final PatternProcessor patternProcessor;
     private final Semaphore semaphore = new Semaphore(1);
+    private final Log4jThreadFactory threadFactory = Log4jThreadFactory.createThreadFactory("RollingFileManager");
     private volatile TriggeringPolicy triggeringPolicy;
     private volatile RolloverStrategy rolloverStrategy;
     private volatile boolean renameEmptyFiles = false;
@@ -278,7 +280,7 @@ public class RollingFileManager extends FileManager {
         }
 
         boolean success = false;
-        Future<?> future = null;
+        Thread thread = null;
 
         try {
             final RolloverDescription descriptor = strategy.rollover(this);
@@ -296,13 +298,14 @@ public class RollingFileManager extends FileManager {
 
                 if (success && descriptor.getAsynchronous() != null) {
                     LOGGER.debug("RollingFileManager executing async {}", descriptor.getAsynchronous());
-                    future = LoggerContext.getContext(false).getConfiguration().getScheduler().submit(new AsyncAction(descriptor.getAsynchronous(), this));
+                    thread = threadFactory.newThread(new AsyncAction(descriptor.getAsynchronous(), this));
+                    thread.start();
                 }
                 return true;
             }
             return false;
         } finally {
-            if (future == null || future.isDone() || future.isCancelled()) {
+            if (thread == null || thread.isAlive()) {
                 semaphore.release();
             }
         }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationScheduler.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationScheduler.java
index a5cfddf76d..03723c8fdc 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationScheduler.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/ConfigurationScheduler.java
@@ -19,7 +19,6 @@ package org.apache.logging.log4j.core.config;
 import java.util.Date;
 import java.util.Queue;
 import java.util.concurrent.Callable;
-import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
@@ -63,7 +62,7 @@ public class ConfigurationScheduler extends AbstractLifeCycle {
             } catch (final InterruptedException ie) {
                 executorService.shutdownNow();
                 try {
-                    executorService.awaitTermination(timeout, timeUnit);
+                    executorService.awaitTermination(timeoutToUse, timeUnitToUse);
                 } catch (final InterruptedException inner) {
                     LOGGER.warn("ConfigurationScheduler stopped but some scheduled services may not have completed.");
                 }
@@ -99,28 +98,6 @@ public class ConfigurationScheduler extends AbstractLifeCycle {
         }
     }
 
-    /**
-     * Creates and executes a Future that becomes enabled immediately.
-     * @param <V> The result type returned by this Future
-     * @param callable the function to execute.
-     * @return a Future that can be used to extract result or cancel.
-     *
-     */
-    public <V> Future<V> submit(final Callable<V> callable) {
-        return getExecutorService().submit(callable);
-    }
-
-    /**
-     * Creates and executes a Future that becomes enabled immediately.
-     * @param runnable the function to execute.
-     * @return a Future representing pending completion of the task and whose get() method will return null
-     * upon completion.
-     */
-    public Future<?> submit(final Runnable runnable) {
-        return getExecutorService().submit(runnable);
-    }
-
-
     /**
      * Creates and executes a ScheduledFuture that becomes enabled after the given delay.
      * @param <V> The result type returned by this Future
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/Log4jThreadFactory.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/Log4jThreadFactory.java
index 2318feb1d2..8b636f6f43 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/Log4jThreadFactory.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/Log4jThreadFactory.java
@@ -40,6 +40,21 @@ public class Log4jThreadFactory implements ThreadFactory {
         return new Log4jThreadFactory(threadFactoryName, true, Thread.NORM_PRIORITY);
     }
 
+    /**
+     * Creates a new thread factory.
+     *
+     * This is mainly used for tests. Production code should be very careful with creating
+     * non-daemon threads since those will block application shutdown
+     * (see https://issues.apache.org/jira/browse/LOG4J2-1748).
+     *
+     * @param threadFactoryName
+     *            The thread factory name.
+     * @return a new daemon thread factory.
+     */
+    public static Log4jThreadFactory createThreadFactory(final String threadFactoryName) {
+        return new Log4jThreadFactory(threadFactoryName, false, Thread.NORM_PRIORITY);
+    }
+
     private static final AtomicInteger FACTORY_NUMBER = new AtomicInteger(1);
     private static final AtomicInteger THREAD_NUMBER = new AtomicInteger(1);
     private final boolean daemon;
diff --git a/log4j-nosql/src/test/java/org/apache/logging/log4j/nosql/appender/cassandra/CassandraRule.java b/log4j-nosql/src/test/java/org/apache/logging/log4j/nosql/appender/cassandra/CassandraRule.java
index 900f794189..bec97ea018 100644
--- a/log4j-nosql/src/test/java/org/apache/logging/log4j/nosql/appender/cassandra/CassandraRule.java
+++ b/log4j-nosql/src/test/java/org/apache/logging/log4j/nosql/appender/cassandra/CassandraRule.java
@@ -37,7 +37,7 @@ import org.junit.rules.ExternalResource;
  */
 public class CassandraRule extends ExternalResource {
 
-    private static final ThreadFactory THREAD_FACTORY = new Log4jThreadFactory("Cassandra", false, Thread.NORM_PRIORITY);
+    private static final ThreadFactory THREAD_FACTORY = Log4jThreadFactory.createThreadFactory("Cassandra");
 
     private final CountDownLatch latch = new CountDownLatch(1);
     private final Cancellable embeddedCassandra = new EmbeddedCassandra(latch);
