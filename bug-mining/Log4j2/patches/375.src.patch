diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/util/Activator.java b/log4j-api/src/main/java/org/apache/logging/log4j/util/Activator.java
index af2643cdd3..880aa079a6 100644
--- a/log4j-api/src/main/java/org/apache/logging/log4j/util/Activator.java
+++ b/log4j-api/src/main/java/org/apache/logging/log4j/util/Activator.java
@@ -45,6 +45,10 @@ public class Activator implements BundleActivator, SynchronousBundleListener {
 
     private static final Logger LOGGER = StatusLogger.getLogger();
 
+    // until we have at least one Provider, we'll lock ProviderUtil which locks LogManager.<clinit> by extension.
+    // this variable needs to be reset once the lock has been released
+    private boolean lockingProviderUtil;
+
     private static void checkPermission(final Permission permission) {
         if (SECURITY_MANAGER != null) {
             SECURITY_MANAGER.checkPermission(permission);
@@ -75,6 +79,8 @@ public class Activator implements BundleActivator, SynchronousBundleListener {
 
     @Override
     public void start(final BundleContext context) throws Exception {
+        ProviderUtil.STARTUP_LOCK.lock();
+        lockingProviderUtil = true;
         final BundleWiring self = context.getBundle().adapt(BundleWiring.class);
         final List<BundleWire> required = self.getRequiredWires(LoggerContextFactory.class.getName());
         for (BundleWire wire : required) {
@@ -85,19 +91,28 @@ public class Activator implements BundleActivator, SynchronousBundleListener {
         for (final Bundle bundle : bundles) {
             loadProvider(bundle);
         }
+        unlockIfReady();
+    }
+
+    private void unlockIfReady() {
+        if (lockingProviderUtil && !ProviderUtil.PROVIDERS.isEmpty()) {
+            ProviderUtil.STARTUP_LOCK.unlock();
+            lockingProviderUtil = false;
+        }
     }
 
     @Override
     public void stop(final BundleContext context) throws Exception {
         context.removeBundleListener(this);
+        unlockIfReady();
     }
 
     @Override
     public void bundleChanged(final BundleEvent event) {
         switch (event.getType()) {
             case BundleEvent.STARTED:
-                // FIXME: LogManager won't see this update if it happens after LogManager is loaded
                 loadProvider(event.getBundle());
+                unlockIfReady();
                 break;
 
             default:
diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/util/ProviderUtil.java b/log4j-api/src/main/java/org/apache/logging/log4j/util/ProviderUtil.java
index c9cddd994c..7fbbfd5841 100644
--- a/log4j-api/src/main/java/org/apache/logging/log4j/util/ProviderUtil.java
+++ b/log4j-api/src/main/java/org/apache/logging/log4j/util/ProviderUtil.java
@@ -20,8 +20,10 @@ import java.io.IOException;
 import java.net.URL;
 import java.util.Collection;
 import java.util.Enumeration;
+import java.util.HashSet;
 import java.util.Properties;
-import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.spi.Provider;
@@ -44,12 +46,13 @@ public final class ProviderUtil {
 
     private static final Logger LOGGER = StatusLogger.getLogger();
 
-    private static final Collection<Provider> PROVIDERS = new CopyOnWriteArraySet<Provider>();
+    protected static final Collection<Provider> PROVIDERS = new HashSet<Provider>();
+    protected static final Lock STARTUP_LOCK = new ReentrantLock();
+    // STARTUP_LOCK guards INSTANCE for lazy initialization; this allows the OSGi Activator to pause the startup and
+    // wait for a Provider to be installed. See LOG4J2-373
+    private static volatile ProviderUtil INSTANCE;
 
     private ProviderUtil() {
-    }
-
-    static {
         final ClassLoader cl = findClassLoader();
         Enumeration<URL> enumResources = null;
         try {
@@ -88,13 +91,32 @@ public final class ProviderUtil {
     }
 
     public static Iterable<Provider> getProviders() {
+        lazyInit();
         return PROVIDERS;
     }
 
     public static boolean hasProviders() {
+        lazyInit();
         return !PROVIDERS.isEmpty();
     }
 
+    protected static void lazyInit() {
+        //noinspection DoubleCheckedLocking
+        if (INSTANCE == null) {
+            try {
+                STARTUP_LOCK.lockInterruptibly();
+                if (INSTANCE == null) {
+                    INSTANCE = new ProviderUtil();
+                }
+            } catch (final InterruptedException e) {
+                LOGGER.fatal("Interrupted before Log4j Providers could be loaded.", e);
+                Thread.currentThread().interrupt();
+            } finally {
+                STARTUP_LOCK.unlock();
+            }
+        }
+    }
+
     public static ClassLoader findClassLoader() {
         return LoaderUtil.getThreadContextClassLoader();
     }
