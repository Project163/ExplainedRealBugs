diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/AbstractRolloverStrategy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/AbstractRolloverStrategy.java
index c66cf755df..7981c7cc0a 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/AbstractRolloverStrategy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/AbstractRolloverStrategy.java
@@ -38,6 +38,7 @@ import org.apache.logging.log4j.core.appender.rolling.action.CommonsCompressActi
 import org.apache.logging.log4j.core.appender.rolling.action.CompositeAction;
 import org.apache.logging.log4j.core.appender.rolling.action.GzCompressAction;
 import org.apache.logging.log4j.core.appender.rolling.action.ZipCompressAction;
+import org.apache.logging.log4j.core.lookup.StrSubstitutor;
 import org.apache.logging.log4j.status.StatusLogger;
 
 /**
@@ -50,6 +51,17 @@ public abstract class AbstractRolloverStrategy implements RolloverStrategy {
      */
     protected static final Logger LOGGER = StatusLogger.getLogger();
 
+    protected final StrSubstitutor strSubstitutor;
+
+    protected AbstractRolloverStrategy(final StrSubstitutor strSubstitutor) {
+        this.strSubstitutor = strSubstitutor;
+    }
+
+
+    public StrSubstitutor getStrSubstitutor() {
+        return strSubstitutor;
+    }
+
     protected Action merge(final Action compressAction, final List<Action> custom, final boolean stopOnError) {
         if (custom.isEmpty()) {
             return compressAction;
@@ -72,8 +84,24 @@ public abstract class AbstractRolloverStrategy implements RolloverStrategy {
         return 0;
     }
 
+
+    protected SortedMap<Integer, Path> getEligibleFiles(final RollingFileManager manager) {
+        return getEligibleFiles(manager, true);
+    }
+
+    protected SortedMap<Integer, Path> getEligibleFiles(final RollingFileManager manager,
+                                                        final boolean isAscending) {
+        final StringBuilder buf = new StringBuilder();
+        manager.getPatternProcessor().formatFileName(strSubstitutor, buf, -1);
+        return getEligibleFiles(buf.toString(), isAscending);
+    }
+
     protected SortedMap<Integer, Path> getEligibleFiles(String path) {
-        SortedMap<Integer, Path> eligibleFiles = new TreeMap<>();
+        return getEligibleFiles(path, true);
+    }
+
+    protected SortedMap<Integer, Path> getEligibleFiles(String path, boolean isAscending) {
+        TreeMap<Integer, Path> eligibleFiles = new TreeMap<>();
         File file = new File(path);
         File parent = file.getParentFile();
         parent.mkdirs();
@@ -100,6 +128,6 @@ public abstract class AbstractRolloverStrategy implements RolloverStrategy {
         } catch (IOException ioe) {
             throw new LoggingException("Error reading folder " + dir + " " + ioe.getMessage(), ioe);
         }
-        return eligibleFiles;
+        return isAscending? eligibleFiles : eligibleFiles.descendingMap();
     }
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java
index 6feffd5664..1c9e5d527a 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java
@@ -17,21 +17,21 @@
 package org.apache.logging.log4j.core.appender.rolling;
 
 import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import java.util.Objects;
+import java.util.Map;
+import java.util.SortedMap;
 import java.util.concurrent.TimeUnit;
 import java.util.zip.Deflater;
 
 import org.apache.logging.log4j.core.Core;
 import org.apache.logging.log4j.core.appender.rolling.action.Action;
-import org.apache.logging.log4j.core.appender.rolling.action.CommonsCompressAction;
-import org.apache.logging.log4j.core.appender.rolling.action.CompositeAction;
 import org.apache.logging.log4j.core.appender.rolling.action.FileRenameAction;
-import org.apache.logging.log4j.core.appender.rolling.action.GzCompressAction;
-import org.apache.logging.log4j.core.appender.rolling.action.ZipCompressAction;
 import org.apache.logging.log4j.core.config.Configuration;
 import org.apache.logging.log4j.core.config.plugins.Plugin;
 import org.apache.logging.log4j.core.config.plugins.PluginAttribute;
@@ -105,21 +105,31 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
                     final boolean stopCustomActionsOnError,
             @PluginConfiguration final Configuration config) {
             // @formatter:on
-        final boolean useMax = fileIndex == null ? true : fileIndex.equalsIgnoreCase("max");
-        int minIndex = MIN_WINDOW_SIZE;
-        if (min != null) {
-            minIndex = Integer.parseInt(min);
-            if (minIndex < 1) {
-                LOGGER.error("Minimum window size too small. Limited to " + MIN_WINDOW_SIZE);
-                minIndex = MIN_WINDOW_SIZE;
+        int minIndex;
+        int maxIndex;
+        boolean useMax;
+
+        if (fileIndex != null && fileIndex.equalsIgnoreCase("nomax")) {
+            minIndex = Integer.MIN_VALUE;
+            maxIndex = Integer.MAX_VALUE;
+            useMax = false;
+        } else {
+            useMax = fileIndex == null ? true : fileIndex.equalsIgnoreCase("max");
+            minIndex = MIN_WINDOW_SIZE;
+            if (min != null) {
+                minIndex = Integer.parseInt(min);
+                if (minIndex < 1) {
+                    LOGGER.error("Minimum window size too small. Limited to " + MIN_WINDOW_SIZE);
+                    minIndex = MIN_WINDOW_SIZE;
+                }
             }
-        }
-        int maxIndex = DEFAULT_WINDOW_SIZE;
-        if (max != null) {
-            maxIndex = Integer.parseInt(max);
-            if (maxIndex < minIndex) {
-                maxIndex = minIndex < DEFAULT_WINDOW_SIZE ? DEFAULT_WINDOW_SIZE : minIndex;
-                LOGGER.error("Maximum window size must be greater than the minimum windows size. Set to " + maxIndex);
+            maxIndex = DEFAULT_WINDOW_SIZE;
+            if (max != null) {
+                maxIndex = Integer.parseInt(max);
+                if (maxIndex < minIndex) {
+                    maxIndex = minIndex < DEFAULT_WINDOW_SIZE ? DEFAULT_WINDOW_SIZE : minIndex;
+                    LOGGER.error("Maximum window size must be greater than the minimum windows size. Set to " + maxIndex);
+                }
             }
         }
         final int compressionLevel = Integers.parseInt(compressionLevelStr, Deflater.DEFAULT_COMPRESSION);
@@ -137,7 +147,6 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
      */
     private final int minIndex;
     private final boolean useMax;
-    private final StrSubstitutor strSubstitutor;
     private final int compressionLevel;
     private final List<Action> customActions;
     private final boolean stopCustomActionsOnError;
@@ -153,11 +162,11 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
     protected DefaultRolloverStrategy(final int minIndex, final int maxIndex, final boolean useMax,
             final int compressionLevel, final StrSubstitutor strSubstitutor, final Action[] customActions,
             final boolean stopCustomActionsOnError) {
+        super(strSubstitutor);
         this.minIndex = minIndex;
         this.maxIndex = maxIndex;
         this.useMax = useMax;
         this.compressionLevel = compressionLevel;
-        this.strSubstitutor = strSubstitutor;
         this.stopCustomActionsOnError = stopCustomActionsOnError;
         this.customActions = customActions == null ? Collections.<Action> emptyList() : Arrays.asList(customActions);
     }
@@ -178,10 +187,6 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
         return this.minIndex;
     }
 
-    public StrSubstitutor getStrSubstitutor() {
-        return strSubstitutor;
-    }
-
     public boolean isStopCustomActionsOnError() {
         return stopCustomActionsOnError;
     }
@@ -204,101 +209,50 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
      * @return true if purge was successful and rollover should be attempted.
      */
     private int purgeAscending(final int lowIndex, final int highIndex, final RollingFileManager manager) {
-        final List<FileRenameAction> renames = new ArrayList<>();
-        final StringBuilder buf = new StringBuilder();
-
-        // LOG4J2-531: directory scan & rollover must use same format
-        manager.getPatternProcessor().formatFileName(strSubstitutor, buf, highIndex);
-        String highFilename = strSubstitutor.replace(buf);
-        final int suffixLength = suffixLength(highFilename);
-        int curMaxIndex = 0;
+        final SortedMap<Integer, Path> eligibleFiles = getEligibleFiles(manager);
+        final int maxFiles = highIndex - lowIndex + 1;
 
-        for (int i = highIndex; i >= lowIndex; i--) {
-            File toRename = new File(highFilename);
-            if (i == highIndex && toRename.exists()) {
-                curMaxIndex = highIndex;
-            } else if (curMaxIndex == 0 && toRename.exists()) {
-                curMaxIndex = i + 1;
+        boolean renameFiles = false;
+        while (eligibleFiles.size() >= maxFiles) {
+            try {
+                LOGGER.debug("Eligible files: {}", eligibleFiles);
+                Integer key = eligibleFiles.firstKey();
+                LOGGER.debug("Deleting {}", eligibleFiles.get(key).toFile().getAbsolutePath());
+                Files.delete(eligibleFiles.get(key));
+                eligibleFiles.remove(key);
+                renameFiles = true;
+            } catch (IOException ioe) {
+                LOGGER.error("Unable to delete {}", eligibleFiles.firstKey(), ioe);
                 break;
             }
-
-            boolean isBase = false;
-
-            if (suffixLength > 0) {
-                final File toRenameBase = new File(highFilename.substring(0, highFilename.length() - suffixLength));
-
-                if (toRename.exists()) {
-                    if (toRenameBase.exists()) {
-                        LOGGER.debug("DefaultRolloverStrategy.purgeAscending deleting {} base of {}.", //
-                                toRenameBase, toRename);
-                        toRenameBase.delete();
-                    }
-                } else {
-                    toRename = toRenameBase;
-                    isBase = true;
-                }
-            }
-
-            if (toRename.exists()) {
-                //
-                // if at lower index and then all slots full
-                // attempt to delete last file
-                // if that fails then abandon purge
-                if (i == lowIndex) {
-                    LOGGER.debug("DefaultRolloverStrategy.purgeAscending deleting {} at low index {}: all slots full.",
-                            toRename, i);
-                    if (!toRename.delete()) {
-                        return -1;
-                    }
-
-                    break;
-                }
-
-                //
-                // if intermediate index
-                // add a rename action to the list
+        }
+        final StringBuilder buf = new StringBuilder();
+        if (renameFiles) {
+            for (Map.Entry<Integer, Path> entry : eligibleFiles.entrySet()) {
                 buf.setLength(0);
                 // LOG4J2-531: directory scan & rollover must use same format
-                manager.getPatternProcessor().formatFileName(strSubstitutor, buf, i - 1);
-
-                final String lowFilename = strSubstitutor.replace(buf);
-                String renameTo = lowFilename;
-
-                if (isBase) {
-                    renameTo = lowFilename.substring(0, lowFilename.length() - suffixLength);
+                manager.getPatternProcessor().formatFileName(strSubstitutor, buf, entry.getKey() - 1);
+                String currentName = entry.getValue().toFile().getName();
+                String renameTo = buf.toString();
+                int suffixLength = suffixLength(renameTo);
+                if (suffixLength > 0 && suffixLength(currentName) == 0) {
+                   renameTo = renameTo.substring(0, renameTo.length() - suffixLength);
                 }
-
-                renames.add(new FileRenameAction(toRename, new File(renameTo), true));
-                highFilename = lowFilename;
-            } else {
-                buf.setLength(0);
-                // LOG4J2-531: directory scan & rollover must use same format
-                manager.getPatternProcessor().formatFileName(strSubstitutor, buf, i - 1);
-
-                highFilename = strSubstitutor.replace(buf);
-            }
-        }
-        if (curMaxIndex == 0) {
-            curMaxIndex = lowIndex;
-        }
-
-        //
-        // work renames backwards
-        //
-        for (int i = renames.size() - 1; i >= 0; i--) {
-            final Action action = renames.get(i);
-            try {
-                LOGGER.debug("DefaultRolloverStrategy.purgeAscending executing {} of {}: {}", //
-                        i, renames.size(), action);
-                if (!action.execute()) {
+                Action action = new FileRenameAction(entry.getValue().toFile(), new File(renameTo), true);
+                try {
+                    LOGGER.debug("DefaultRolloverStrategy.purgeAscending executing {}", action);
+                    if (!action.execute()) {
+                        return -1;
+                    }
+                } catch (final Exception ex) {
+                    LOGGER.warn("Exception during purge in RollingFileAppender", ex);
                     return -1;
                 }
-            } catch (final Exception ex) {
-                LOGGER.warn("Exception during purge in RollingFileAppender", ex);
-                return -1;
             }
         }
-        return curMaxIndex;
+
+        return eligibleFiles.size() > 0 ?
+                (eligibleFiles.lastKey() < highIndex ? eligibleFiles.lastKey() + 1 : highIndex) : lowIndex;
     }
 
     /**
@@ -311,79 +265,34 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
      * @return true if purge was successful and rollover should be attempted.
      */
     private int purgeDescending(final int lowIndex, final int highIndex, final RollingFileManager manager) {
-        final List<FileRenameAction> renames = new ArrayList<>();
-        final StringBuilder buf = new StringBuilder();
-
-        // LOG4J2-531: directory scan & rollover must use same format
-        manager.getPatternProcessor().formatFileName(strSubstitutor, buf, lowIndex);
-
-        String lowFilename = strSubstitutor.replace(buf);
-        final int suffixLength = suffixLength(lowFilename);
-
-        for (int i = lowIndex; i <= highIndex; i++) {
-            File toRename = new File(lowFilename);
-            boolean isBase = false;
-
-            if (suffixLength > 0) {
-                final File toRenameBase = new File(lowFilename.substring(0, lowFilename.length() - suffixLength));
-
-                if (toRename.exists()) {
-                    if (toRenameBase.exists()) {
-                        LOGGER.debug("DefaultRolloverStrategy.purgeDescending deleting {} base of {}.", //
-                                toRenameBase, toRename);
-                        toRenameBase.delete();
-                    }
-                } else {
-                    toRename = toRenameBase;
-                    isBase = true;
-                }
-            }
-
-            if (toRename.exists()) {
-                //
-                // if at upper index then
-                // attempt to delete last file
-                // if that fails then abandon purge
-                if (i == highIndex) {
-                    LOGGER.debug(
-                            "DefaultRolloverStrategy.purgeDescending deleting {} at high index {}: all slots full.", //
-                            toRename, i);
-                    if (!toRename.delete()) {
-                        return -1;
-                    }
+        // Retrieve the files in descending order, so the highest key will be first.
+        final SortedMap<Integer, Path> eligibleFiles = getEligibleFiles(manager, false);
+        final int maxFiles = highIndex - lowIndex + 1;
 
-                    break;
-                }
-
-                //
-                // if intermediate index
-                // add a rename action to the list
-                buf.setLength(0);
-                // LOG4J2-531: directory scan & rollover must use same format
-                manager.getPatternProcessor().formatFileName(strSubstitutor, buf, i + 1);
-
-                final String highFilename = strSubstitutor.replace(buf);
-                String renameTo = highFilename;
-
-                if (isBase) {
-                    renameTo = highFilename.substring(0, highFilename.length() - suffixLength);
-                }
-
-                renames.add(new FileRenameAction(toRename, new File(renameTo), true));
-                lowFilename = highFilename;
-            } else {
+        while (eligibleFiles.size() >= maxFiles) {
+            try {
+                Integer key = eligibleFiles.firstKey();
+                Files.delete(eligibleFiles.get(key));
+                eligibleFiles.remove(key);
+            } catch (IOException ioe) {
+                LOGGER.error("Unable to delete {}", eligibleFiles.firstKey(), ioe);
                 break;
             }
         }
-
-        //
-        // work renames backwards
-        //
-        for (int i = renames.size() - 1; i >= 0; i--) {
-            final Action action = renames.get(i);
+        final StringBuilder buf = new StringBuilder();
+        for (Map.Entry<Integer, Path> entry : eligibleFiles.entrySet()) {
+            buf.setLength(0);
+            // LOG4J2-531: directory scan & rollover must use same format
+            manager.getPatternProcessor().formatFileName(strSubstitutor, buf, entry.getKey() + 1);
+            String currentName = entry.getValue().toFile().getName();
+            String renameTo = buf.toString();
+            int suffixLength = suffixLength(renameTo);
+            if (suffixLength > 0 && suffixLength(currentName) == 0) {
+                renameTo = renameTo.substring(0, renameTo.length() - suffixLength);
+            }
+            Action action = new FileRenameAction(entry.getValue().toFile(), new File(renameTo), true);
             try {
-                LOGGER.debug("DefaultRolloverStrategy.purgeDescending executing {} of {}: {}", //
-                        i, renames.size(), action);
+                LOGGER.debug("DefaultRolloverStrategy.purgeDescending executing {}", action);
                 if (!action.execute()) {
                     return -1;
                 }
@@ -405,17 +314,23 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
      */
     @Override
     public RolloverDescription rollover(final RollingFileManager manager) throws SecurityException {
-        if (maxIndex < 0) {
-            return null;
-        }
-        final long startNanos = System.nanoTime();
-        final int fileIndex = purge(minIndex, maxIndex, manager);
-        if (fileIndex < 0) {
-            return null;
-        }
-        if (LOGGER.isTraceEnabled()) {
-            final double durationMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
-            LOGGER.trace("DefaultRolloverStrategy.purge() took {} milliseconds", durationMillis);
+        int fileIndex;
+        if (minIndex == Integer.MIN_VALUE) {
+            final SortedMap<Integer, Path> eligibleFiles = getEligibleFiles(manager);
+            fileIndex = eligibleFiles.size() > 0 ? eligibleFiles.lastKey() + 1 : 1;
+        } else {
+            if (maxIndex < 0) {
+                return null;
+            }
+            final long startNanos = System.nanoTime();
+            fileIndex = purge(minIndex, maxIndex, manager);
+            if (fileIndex < 0) {
+                return null;
+            }
+            if (LOGGER.isTraceEnabled()) {
+                final double durationMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos);
+                LOGGER.trace("DefaultRolloverStrategy.purge() took {} milliseconds", durationMillis);
+            }
         }
         final StringBuilder buf = new StringBuilder(255);
         manager.getPatternProcessor().formatFileName(strSubstitutor, buf, fileIndex);
@@ -446,7 +361,7 @@ public class DefaultRolloverStrategy extends AbstractRolloverStrategy {
 
     @Override
     public String toString() {
-        return "DefaultRolloverStrategy(min=" + minIndex + ", max=" + maxIndex + ')';
+        return "DefaultRolloverStrategy(min=" + minIndex + ", max=" + maxIndex + ", useMax=" + useMax + ")";
     }
 
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DirectWriteRolloverStrategy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DirectWriteRolloverStrategy.java
index 6861db2b33..92e9cca06f 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DirectWriteRolloverStrategy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DirectWriteRolloverStrategy.java
@@ -93,7 +93,6 @@ public class DirectWriteRolloverStrategy extends AbstractRolloverStrategy implem
      * Index for most recent log file.
      */
     private final int maxFiles;
-    private final StrSubstitutor strSubstitutor;
     private final int compressionLevel;
     private final List<Action> customActions;
     private final boolean stopCustomActionsOnError;
@@ -110,9 +109,9 @@ public class DirectWriteRolloverStrategy extends AbstractRolloverStrategy implem
     protected DirectWriteRolloverStrategy(final int maxFiles, final int compressionLevel,
                                           final StrSubstitutor strSubstitutor, final Action[] customActions,
                                           final boolean stopCustomActionsOnError) {
+        super(strSubstitutor);
         this.maxFiles = maxFiles;
         this.compressionLevel = compressionLevel;
-        this.strSubstitutor = strSubstitutor;
         this.stopCustomActionsOnError = stopCustomActionsOnError;
         this.customActions = customActions == null ? Collections.<Action> emptyList() : Arrays.asList(customActions);
     }
@@ -129,20 +128,10 @@ public class DirectWriteRolloverStrategy extends AbstractRolloverStrategy implem
         return this.maxFiles;
     }
 
-    public StrSubstitutor getStrSubstitutor() {
-        return strSubstitutor;
-    }
-
     public boolean isStopCustomActionsOnError() {
         return stopCustomActionsOnError;
     }
 
-    private SortedMap<Integer, Path> getEligibleFiles(final RollingFileManager manager) {
-        final StringBuilder buf = new StringBuilder();
-        manager.getPatternProcessor().formatFileName(strSubstitutor, buf, -1);
-        return getEligibleFiles(buf.toString());
-    }
-
     private int purge(final RollingFileManager manager) {
         SortedMap<Integer, Path> eligibleFiles = getEligibleFiles(manager);
         LOGGER.debug("Found {} eligible files, max is  {}", eligibleFiles.size(), maxFiles);
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/EligibleFilesTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/EligibleFilesTest.java
index 1f99ef520a..3f29b2dbf2 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/EligibleFilesTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/appender/rolling/EligibleFilesTest.java
@@ -39,6 +39,10 @@ public class EligibleFilesTest {
 
     private class TestRolloverStrategy extends AbstractRolloverStrategy {
 
+        public TestRolloverStrategy() {
+            super(null);
+        }
+
         @Override
         public RolloverDescription rollover(RollingFileManager manager) throws SecurityException {
             return null;
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 002012571f..5fde873653 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -24,6 +24,9 @@
   </properties>
   <body>
     <release version="2.8" date="2017-MM-DD" description="GA Release 2.8">
+      <action issue="LOG4J2-1032" dev="rgoers" type="add">
+        Make DefaultRolloverStrategy more efficent when renaming files. Add nomax option to the fileIndex attribute.
+      </action>
       <action issue="LOG4J2-1101" dev="rgoers" type="add">
         RollingFileAppender now supports omitting the file name and writing directly to the archive files.
       </action>
diff --git a/src/site/xdoc/manual/appenders.xml b/src/site/xdoc/manual/appenders.xml
index 46f0ab830f..b956c4a5f4 100644
--- a/src/site/xdoc/manual/appenders.xml
+++ b/src/site/xdoc/manual/appenders.xml
@@ -2609,7 +2609,7 @@ public class JpaLogEntity extends AbstractLogEventWrapperEntity {
                 The pattern may also contain lookup references that can be resolved at runtime such as is shown in the example
                 below.
               </p>
-              <p>The default rollover strategy supports two variations for incrementing the counter. The first is
+              <p>The default rollover strategy supports three variations for incrementing the counter. The first is
                 the "fixed window" strategy. To illustrate how it works, suppose that the min attribute is set to 1,
                 the max attribute is set to 3, the file name is "foo.log", and the file name pattern is "foo-%i.log".
               </p>
@@ -2703,6 +2703,11 @@ public class JpaLogEntity extends AbstractLogEventWrapperEntity {
                     created and starts being written to.</td>
                 </tr>
               </table>
+              <p>
+                Finally, as of release 2.8, if the fileIndex attribute is set to "nomax" then the min and max values
+                will be ignored and file numbering will increment by 1 and each rollover will have an incrementally
+                higher value with no maximum number of files.
+              </p>
               <table>
                 <caption align="top">DefaultRolloverStrategy Parameters</caption>
                 <tr>
