diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java
index 0273ca5fac..7a373714dc 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/DefaultRolloverStrategy.java
@@ -179,7 +179,9 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
 
         final List<FileRenameAction> renames = new ArrayList<FileRenameAction>();
         final StringBuilder buf = new StringBuilder();
-        manager.getPatternProcessor().formatFileName(buf, highIndex);
+        
+        // LOG4J2-531: directory scan & rollover must use same format
+        manager.getPatternProcessor().formatFileName(subst, buf, highIndex);
 
         String highFilename = subst.replace(buf);
 
@@ -208,6 +210,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
 
                 if (toRename.exists()) {
                     if (toRenameBase.exists()) {
+                        LOGGER.debug("DefaultRolloverStrategy.purgeAscending deleting {} base of {}.", //
+                                toRenameBase, toRename);
                         toRenameBase.delete();
                     }
                 } else {
@@ -222,6 +226,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
                 //        attempt to delete last file
                 //        if that fails then abandon purge
                 if (i == lowIndex) {
+                    LOGGER.debug("DefaultRolloverStrategy.purgeAscending deleting {} at low index {}: all slots full.", //
+                            toRename, i);
                     if (!toRename.delete()) {
                         return -1;
                     }
@@ -233,7 +239,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
                 //   if intermediate index
                 //     add a rename action to the list
                 buf.setLength(0);
-                manager.getPatternProcessor().formatFileName(buf, i - 1);
+                // LOG4J2-531: directory scan & rollover must use same format
+                manager.getPatternProcessor().formatFileName(subst, buf, i - 1);
 
                 final String lowFilename = subst.replace(buf);
                 String renameTo = lowFilename;
@@ -246,7 +253,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
                 highFilename = lowFilename;
             } else {
                 buf.setLength(0);
-                manager.getPatternProcessor().formatFileName(buf, i - 1);
+                // LOG4J2-531: directory scan & rollover must use same format
+                manager.getPatternProcessor().formatFileName(subst, buf, i - 1);
 
                 highFilename = subst.replace(buf);
             }
@@ -260,8 +268,9 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
         //
         for (int i = renames.size() - 1; i >= 0; i--) {
             final Action action = renames.get(i);
-
             try {
+                LOGGER.debug("DefaultRolloverStrategy.purgeAscending executing {} of {}: {}", //
+                        i, renames.size(), action);
                 if (!action.execute()) {
                     return -1;
                 }
@@ -287,7 +296,9 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
 
         final List<FileRenameAction> renames = new ArrayList<FileRenameAction>();
         final StringBuilder buf = new StringBuilder();
-        manager.getPatternProcessor().formatFileName(buf, lowIndex);
+
+        // LOG4J2-531: directory scan & rollover must use same format
+        manager.getPatternProcessor().formatFileName(subst, buf, lowIndex);
 
         String lowFilename = subst.replace(buf);
 
@@ -307,6 +318,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
 
                 if (toRename.exists()) {
                     if (toRenameBase.exists()) {
+                        LOGGER.debug("DefaultRolloverStrategy.purgeDescending deleting {} base of {}.", //
+                                toRenameBase, toRename);
                         toRenameBase.delete();
                     }
                 } else {
@@ -321,6 +334,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
                 //        attempt to delete last file
                 //        if that fails then abandon purge
                 if (i == highIndex) {
+                    LOGGER.debug("DefaultRolloverStrategy.purgeDescending deleting {} at high index {}: all slots full.", //
+                            toRename, i);
                     if (!toRename.delete()) {
                         return -1;
                     }
@@ -332,7 +347,8 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
                 //   if intermediate index
                 //     add a rename action to the list
                 buf.setLength(0);
-                manager.getPatternProcessor().formatFileName(buf, i + 1);
+                // LOG4J2-531: directory scan & rollover must use same format
+                manager.getPatternProcessor().formatFileName(subst, buf, i + 1);
 
                 final String highFilename = subst.replace(buf);
                 String renameTo = highFilename;
@@ -353,8 +369,9 @@ public class DefaultRolloverStrategy implements RolloverStrategy {
         //
         for (int i = renames.size() - 1; i >= 0; i--) {
             final Action action = renames.get(i);
-
             try {
+                LOGGER.debug("DefaultRolloverStrategy.purgeDescending executing {} of {}: {}", //
+                        i, renames.size(), action);
                 if (!action.execute()) {
                     return -1;
                 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java
index 82fc0ca257..de5822c45e 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/PatternProcessor.java
@@ -16,11 +16,13 @@
  */
 package org.apache.logging.log4j.core.appender.rolling;
 
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
 
+import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.core.LogEvent;
 import org.apache.logging.log4j.core.impl.Log4jLogEvent;
 import org.apache.logging.log4j.core.lookup.StrSubstitutor;
@@ -29,12 +31,14 @@ import org.apache.logging.log4j.core.pattern.DatePatternConverter;
 import org.apache.logging.log4j.core.pattern.FormattingInfo;
 import org.apache.logging.log4j.core.pattern.PatternConverter;
 import org.apache.logging.log4j.core.pattern.PatternParser;
+import org.apache.logging.log4j.status.StatusLogger;
 
 /**
  * Parse the rollover pattern.
  */
 public class PatternProcessor {
 
+    protected static final Logger LOGGER = StatusLogger.getLogger();
     private static final String KEY = "FileConverter";
 
     private static final char YEAR_CHAR = 'y';
@@ -100,7 +104,7 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.YEAR, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         cal.set(Calendar.MONTH, currentCal.get(Calendar.MONTH));
         if (frequency == RolloverFrequency.MONTHLY) {
@@ -108,7 +112,7 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.MONTH, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         if (frequency == RolloverFrequency.WEEKLY) {
             cal.set(Calendar.WEEK_OF_YEAR, currentCal.get(Calendar.WEEK_OF_YEAR));
@@ -117,7 +121,7 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.WEEK_OF_YEAR, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         cal.set(Calendar.DAY_OF_YEAR, currentCal.get(Calendar.DAY_OF_YEAR));
         if (frequency == RolloverFrequency.DAILY) {
@@ -125,7 +129,7 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.DAY_OF_YEAR, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         cal.set(Calendar.HOUR_OF_DAY, currentCal.get(Calendar.HOUR_OF_DAY));
         if (frequency == RolloverFrequency.HOURLY) {
@@ -133,7 +137,7 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.HOUR_OF_DAY, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         cal.set(Calendar.MINUTE, currentCal.get(Calendar.MINUTE));
         if (frequency == RolloverFrequency.EVERY_MINUTE) {
@@ -141,7 +145,7 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.MINUTE, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         cal.set(Calendar.SECOND, currentCal.get(Calendar.SECOND));
         if (frequency == RolloverFrequency.EVERY_SECOND) {
@@ -149,16 +153,28 @@ public class PatternProcessor {
             nextTime = cal.getTimeInMillis();
             cal.add(Calendar.SECOND, -1);
             nextFileTime = cal.getTimeInMillis();
-            return nextTime;
+            return debugGetNextTime(nextTime);
         }
         cal.set(Calendar.MILLISECOND, currentCal.get(Calendar.MILLISECOND));
         increment(cal, Calendar.MILLISECOND, increment, modulus);
         nextTime = cal.getTimeInMillis();
         cal.add(Calendar.MILLISECOND, -1);
         nextFileTime = cal.getTimeInMillis();
+        return debugGetNextTime(nextTime);
+    }
+
+    private long debugGetNextTime(long nextTime) {
+        if (LOGGER.isTraceEnabled()) {
+            LOGGER.trace("PatternProcessor.getNextTime returning {}, nextFileTime={}, prevFileTime={}, freq={}", //
+                    format(nextTime), format(nextFileTime), format(prevFileTime), frequency);
+        }
         return nextTime;
     }
 
+    private String format(long time) {
+        return new SimpleDateFormat("yyyy/MM/dd-HH:mm:ss.SSS").format(new Date(time));
+    }
+
     private void increment(final Calendar cal, final int type, final int increment, final boolean modulate) {
         final int interval =  modulate ? increment - (cal.get(type) % increment) : increment;
         cal.add(type, interval);
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java
index cf7e2960ae..ac7746a30d 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/RollingFileManager.java
@@ -300,7 +300,6 @@ public class RollingFileManager extends FileManager {
                 return null;
             }
             final long size = data.append ? file.length() : 0;
-            final long time = file.lastModified();
 
             OutputStream os;
             try {
@@ -308,6 +307,7 @@ public class RollingFileManager extends FileManager {
                 if (data.bufferedIO) {
                     os = new BufferedOutputStream(os);
                 }
+                final long time = file.lastModified(); // LOG4J2-531 create file first so time has valid value
                 return new RollingFileManager(name, data.pattern, os, data.append, size, time, data.policy,
                     data.strategy, data.advertiseURI, data.layout);
             } catch (final FileNotFoundException ex) {
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/TimeBasedTriggeringPolicy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/TimeBasedTriggeringPolicy.java
index 07262639c7..4de9ec4fc0 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/TimeBasedTriggeringPolicy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/rolling/TimeBasedTriggeringPolicy.java
@@ -46,6 +46,10 @@ public final class TimeBasedTriggeringPolicy implements TriggeringPolicy {
     @Override
     public void initialize(final RollingFileManager manager) {
         this.manager = manager;
+        
+        // LOG4J2-531: call getNextTime twice to force initialization of both prevFileTime and nextFileTime
+        manager.getPatternProcessor().getNextTime(manager.getFileTime(), interval, modulate);
+        
         nextRollover = manager.getPatternProcessor().getNextTime(manager.getFileTime(), interval, modulate);
     }
 
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index f87381e032..bcf5ff3269 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -39,6 +39,10 @@
       <action issue="LOG4J2-507" dev="ggregory" type="update">
         Space Level numbers by 100 instead of 1.
       </action>
+      <action issue="LOG4J2-531" dev="rpopma" type="fix" due-to="Geoff Ballinger">
+        Fixed bugs where rolled log files were overwritten by RollingFile appender with 
+        composite time and size based policies.
+      </action>
       <action issue="LOG4J2-475" dev="nickwilliams" type="fix" due-to="Matt Sicker">
         Changed the MongoDBConnection to add a MongoDB encoding hook instead of a decoding hook.
       </action>
