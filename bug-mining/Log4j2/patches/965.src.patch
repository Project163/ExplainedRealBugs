diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/DatePatternConverter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/DatePatternConverter.java
index 4f21d480a3..d2dbc2c211 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/DatePatternConverter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/pattern/DatePatternConverter.java
@@ -76,7 +76,7 @@ public final class DatePatternConverter extends LogEventPatternConverter impleme
 
         @Override
         public String toPattern() {
-            return fastDateFormat.toPattern();
+            return fastDateFormat.getPattern();
         }
     }
 
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DateParser.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DateParser.java
index f21a527b85..16940c6fa7 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DateParser.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DateParser.java
@@ -24,29 +24,40 @@ import java.util.Locale;
 import java.util.TimeZone;
 
 /**
- * Copied from Commons Lang 3.
+ * DateParser is the "missing" interface for the parsing methods of
+ * {@link java.text.DateFormat}. You can obtain an object implementing this
+ * interface by using one of the FastDateFormat factory methods.
+ * <p>
+ * Warning: Since binary compatible methods may be added to this interface in any
+ * release, developers are not expected to implement this interface.
+ * 
+ * <p>
+ * Copied and modified from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.
+ * </p>
+ * 
+ * @since Apache Commons Lang 3.2
  */
 public interface DateParser {
 
     /**
-     * Equivalent to DateFormat.parse(String).
+     * Equivalent to DateFormat.parse(String). 
      * 
-     * See {@link java.text.DateFormat#parse(String)} for more information.
-     * 
-     * @param source A <code>String</code> whose beginning should be parsed.
+     * See {@link java.text.DateFormat#parse(String)} for more information. 
+     * @param source A <code>String</code> whose beginning should be parsed. 
      * @return A <code>Date</code> parsed from the string
      * @throws ParseException if the beginning of the specified string cannot be parsed.
      */
     Date parse(String source) throws ParseException;
 
     /**
-     * Equivalent to DateFormat.parse(String, ParsePosition).
+     * Equivalent to DateFormat.parse(String, ParsePosition). 
      * 
-     * See {@link java.text.DateFormat#parse(String, ParsePosition)} for more information.
+     * See {@link java.text.DateFormat#parse(String, ParsePosition)} for more information. 
      * 
      * @param source A <code>String</code>, part of which should be parsed.
-     * @param pos A <code>ParsePosition</code> object with index and error index information as described above.
-     * @return A <code>Date</code> parsed from the string. In case of error, returns null.
+     * @param pos A <code>ParsePosition</code> object with index and error index information 
+     * as described above. 
+     * @return A <code>Date</code> parsed from the string. In case of error, returns null. 
      * @throws NullPointerException if text or pos is null.
      */
     Date parse(String source, ParsePosition pos);
@@ -63,24 +74,28 @@ public interface DateParser {
      * @return true, if source has been parsed (pos parsePosition is updated); otherwise false (and pos errorIndex is updated)
      * @throws IllegalArgumentException when Calendar has been set to be not lenient, and a parsed field is
      * out of range.
+     * 
+     * @since 3.5
      */
     boolean parse(String source, ParsePosition pos, Calendar calendar);
 
     // Accessors
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * Gets the pattern used by this parser.
+     * <p>Gets the pattern used by this parser.</p>
      * 
      * @return the pattern, {@link java.text.SimpleDateFormat} compatible
      */
     String getPattern();
 
     /**
+     * <p>
      * Gets the time zone used by this parser.
+     * </p>
      * 
      * <p>
-     * The default {@link TimeZone} used to create a {@link Date} when the {@link TimeZone} is not specified by the
-     * format pattern.
+     * The default {@link TimeZone} used to create a {@link Date} when the {@link TimeZone} is not specified by
+     * the format pattern.
      * </p>
      * 
      * @return the time zone
@@ -88,7 +103,7 @@ public interface DateParser {
     TimeZone getTimeZone();
 
     /**
-     * Gets the locale used by this parser.
+     * <p>Gets the locale used by this parser.</p>
      * 
      * @return the locale
      */
@@ -100,7 +115,7 @@ public interface DateParser {
      * @param source A <code>String</code> whose beginning should be parsed.
      * @return a <code>java.util.Date</code> object
      * @throws ParseException if the beginning of the specified string cannot be parsed.
-     * @see java.text.DateFormat#parseObject(String)
+     * @see java.text.DateFormat#parseObject(String) 
      */
     Object parseObject(String source) throws ParseException;
 
@@ -110,8 +125,7 @@ public interface DateParser {
      * @param source A <code>String</code> whose beginning should be parsed.
      * @param pos the parse position
      * @return a <code>java.util.Date</code> object
-     * @see java.text.DateFormat#parseObject(String, ParsePosition)
+     * @see java.text.DateFormat#parseObject(String, ParsePosition) 
      */
     Object parseObject(String source, ParsePosition pos);
-
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DatePrinter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DatePrinter.java
index fb89214ec7..91f5e1a0ad 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DatePrinter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/DatePrinter.java
@@ -23,7 +23,19 @@ import java.util.Locale;
 import java.util.TimeZone;
 
 /**
- * Copied from Commons Lang 3.
+ * DatePrinter is the "missing" interface for the format methods of 
+ * {@link java.text.DateFormat}. You can obtain an object implementing this
+ * interface by using one of the FastDateFormat factory methods.
+ * <p>
+ * Warning: Since binary compatible methods may be added to this interface in any
+ * release, developers are not expected to implement this interface.
+ * </p>
+ * 
+ * <p>
+ * Copied and modified from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.
+ * </p>
+ * 
+ * @since Apache Commons Lang 3.2
  */
 public interface DatePrinter {
 
@@ -56,36 +68,43 @@ public interface DatePrinter {
     String format(Calendar calendar);
 
     /**
-     * <p>Formats a milliseond {@code long} value into the
-     * supplied {@code StringBuilder}.</p>
+     * <p>Formats a millisecond {@code long} value into the
+     * supplied {@code Appendable}.</p>
      *
      * @param millis  the millisecond value to format
      * @param buf  the buffer to format into
+     * @param <B> the Appendable class type, usually StringBuilder or StringBuffer.
      * @return the specified string buffer
+     * @since 3.5
      */
-    StringBuilder format(long millis, StringBuilder buf);
+    <B extends Appendable> B format(long millis, B buf);
 
     /**
      * <p>Formats a {@code Date} object into the
-     * supplied {@code StringBuilder} using a {@code GregorianCalendar}.</p>
+     * supplied {@code Appendable} using a {@code GregorianCalendar}.</p>
      *
      * @param date  the date to format
      * @param buf  the buffer to format into
+     * @param <B> the Appendable class type, usually StringBuilder or StringBuffer.
      * @return the specified string buffer
+     * @since 3.5
      */
-    StringBuilder format(Date date, StringBuilder buf);
+    <B extends Appendable> B format(Date date, B buf);
 
     /**
-     * <p>Formats a {@code Calendar} object into the supplied {@code StringBuilder}.</p>
+     * <p>Formats a {@code Calendar} object into the supplied {@code Appendable}.</p>
      * The TimeZone set on the Calendar is only used to adjust the time offset.
      * The TimeZone specified during the construction of the Parser will determine the TimeZone
      * used in the formatted string.
      *
      * @param calendar  the calendar to format
      * @param buf  the buffer to format into
+     * @param <B> the Appendable class type, usually StringBuilder or StringBuffer.
      * @return the specified string buffer
+     * @since 3.5
      */
-    StringBuilder format(Calendar calendar, StringBuilder buf);
+    <B extends Appendable> B format(Calendar calendar, B buf);
+
 
     // Accessors
     //-----------------------------------------------------------------------
@@ -115,13 +134,12 @@ public interface DatePrinter {
     /**
      * <p>Formats a {@code Date}, {@code Calendar} or
      * {@code Long} (milliseconds) object.</p>
-     * 
-     * See {@link java.text.DateFormat#format(Object, StringBuffer, FieldPosition)}
-     * 
+     *
      * @param obj  the object to format
      * @param toAppendTo  the buffer to append to
      * @param pos  the position - ignored
      * @return the buffer passed in
+     * @see java.text.DateFormat#format(Object, StringBuffer, FieldPosition)
      */
     StringBuilder format(Object obj, StringBuilder toAppendTo, FieldPosition pos);
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateFormat.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateFormat.java
index 6f68a6eaf6..db38bd12e9 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateFormat.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateFormat.java
@@ -16,7 +16,6 @@
  */
 package org.apache.logging.log4j.core.util.datetime;
 
-import java.io.Serializable;
 import java.text.DateFormat;
 import java.text.FieldPosition;
 import java.text.ParseException;
@@ -27,9 +26,61 @@ import java.util.Locale;
 import java.util.TimeZone;
 
 /**
- * This is a copy of Commons Lang's Fast Date Formatter.
+ * <p>FastDateFormat is a fast and thread-safe version of
+ * {@link java.text.SimpleDateFormat}.</p>
+ *
+ * <p>To obtain an instance of FastDateFormat, use one of the static factory methods: 
+ * {@link #getInstance(String, TimeZone, Locale)}, {@link #getDateInstance(int, TimeZone, Locale)}, 
+ * {@link #getTimeInstance(int, TimeZone, Locale)}, or {@link #getDateTimeInstance(int, int, TimeZone, Locale)} 
+ * </p>
+ * 
+ * <p>Since FastDateFormat is thread safe, you can use a static member instance:</p>
+ * <code>
+ *   private static final FastDateFormat DATE_FORMATTER = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT);
+ * </code>
+ * 
+ * <p>This class can be used as a direct replacement to
+ * {@code SimpleDateFormat} in most formatting and parsing situations.
+ * This class is especially useful in multi-threaded server environments.
+ * {@code SimpleDateFormat} is not thread-safe in any JDK version,
+ * nor will it be as Sun have closed the bug/RFE.
+ * </p>
+ *
+ * <p>All patterns are compatible with
+ * SimpleDateFormat (except time zones and some year patterns - see below).</p>
+ *
+ * <p>Since 3.2, FastDateFormat supports parsing as well as printing.</p>
+ *
+ * <p>Java 1.4 introduced a new pattern letter, {@code 'Z'}, to represent
+ * time zones in RFC822 format (eg. {@code +0800} or {@code -1100}).
+ * This pattern letter can be used here (on all JDK versions).</p>
+ *
+ * <p>In addition, the pattern {@code 'ZZ'} has been made to represent
+ * ISO 8601 extended format time zones (eg. {@code +08:00} or {@code -11:00}).
+ * This introduces a minor incompatibility with Java 1.4, but at a gain of
+ * useful functionality.</p>
+ *
+ * <p>Javadoc cites for the year pattern: <i>For formatting, if the number of
+ * pattern letters is 2, the year is truncated to 2 digits; otherwise it is
+ * interpreted as a number.</i> Starting with Java 1.7 a pattern of 'Y' or
+ * 'YYY' will be formatted as '2003', while it was '03' in former Java
+ * versions. FastDateFormat implements the behavior of Java 7.</p>
+ * 
+ * <p>
+ * Copied and modified from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.
+ * </p>
+ * 
+ * @since Apache Commons Lang 2.0
  */
-public class FastDateFormat extends Format implements DatePrinter, DateParser, Serializable {
+public class FastDateFormat extends Format implements DateParser, DatePrinter {
+    
+    /**
+     * Required for serialization support.
+     *
+     * @see java.io.Serializable
+     */
+    @SuppressWarnings("unused")
+    private static final long serialVersionUID = 2L;
 
     /**
      * FULL locale dependent date or time style.
@@ -48,14 +99,7 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
      */
     public static final int SHORT = DateFormat.SHORT;
 
-    /**
-     * Required for serialization support.
-     *
-     * @see java.io.Serializable
-     */
-    private static final long serialVersionUID = 2L;
-
-    private static final FormatCache<FastDateFormat> CACHE = new FormatCache<FastDateFormat>() {
+    private static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {
         @Override
         protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {
             return new FastDateFormat(pattern, timeZone, locale);
@@ -65,319 +109,317 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     private final FastDatePrinter printer;
     private final FastDateParser parser;
 
-    // Constructor
-    // -----------------------------------------------------------------------
-    /**
-     * <p>
-     * Constructs a new FastDateFormat.
-     * </p>
-     *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
-     * @param timeZone non-null time zone to use
-     * @param locale non-null locale to use
-     * @throws NullPointerException if pattern, timeZone, or locale is null.
-     */
-    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) {
-        this(pattern, timeZone, locale, null);
-    }
-
-    // Constructor
-    // -----------------------------------------------------------------------
-    /**
-     * <p>
-     * Constructs a new FastDateFormat.
-     * </p>
-     *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
-     * @param timeZone non-null time zone to use
-     * @param locale non-null locale to use
-     * @param centuryStart The start of the 100 year period to use as the "default century" for 2 digit year parsing.
-     *            If centuryStart is null, defaults to now - 80 years
-     * @throws NullPointerException if pattern, timeZone, or locale is null.
-     */
-    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale,
-            final Date centuryStart) {
-        printer = new FastDatePrinter(pattern, timeZone, locale);
-        parser = new FastDateParser(pattern, timeZone, locale, centuryStart);
-    }
-
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Gets a formatter instance using the default pattern in the default locale.
-     * </p>
+     * <p>Gets a formatter instance using the default pattern in the
+     * default locale.</p>
      *
      * @return a date/time formatter
      */
     public static FastDateFormat getInstance() {
-        return CACHE.getInstance();
+        return cache.getInstance();
     }
 
     /**
-     * <p>
-     * Gets a formatter instance using the specified pattern in the default locale.
-     * </p>
+     * <p>Gets a formatter instance using the specified pattern in the
+     * default locale.</p>
      *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible
+     *  pattern
      * @return a pattern based date/time formatter
      * @throws IllegalArgumentException if pattern is invalid
      */
     public static FastDateFormat getInstance(final String pattern) {
-        return CACHE.getInstance(pattern, null, null);
+        return cache.getInstance(pattern, null, null);
     }
 
     /**
-     * <p>
-     * Gets a formatter instance using the specified pattern and time zone.
-     * </p>
+     * <p>Gets a formatter instance using the specified pattern and
+     * time zone.</p>
      *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
-     * @param timeZone optional time zone, overrides time zone of formatted date
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible
+     *  pattern
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date
      * @return a pattern based date/time formatter
      * @throws IllegalArgumentException if pattern is invalid
      */
     public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone) {
-        return CACHE.getInstance(pattern, timeZone, null);
+        return cache.getInstance(pattern, timeZone, null);
     }
 
     /**
-     * <p>
-     * Gets a formatter instance using the specified pattern and locale.
-     * </p>
+     * <p>Gets a formatter instance using the specified pattern and
+     * locale.</p>
      *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
-     * @param locale optional locale, overrides system locale
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible
+     *  pattern
+     * @param locale  optional locale, overrides system locale
      * @return a pattern based date/time formatter
      * @throws IllegalArgumentException if pattern is invalid
      */
     public static FastDateFormat getInstance(final String pattern, final Locale locale) {
-        return CACHE.getInstance(pattern, null, locale);
+        return cache.getInstance(pattern, null, locale);
     }
 
     /**
-     * <p>
-     * Gets a formatter instance using the specified pattern, time zone and locale.
-     * </p>
+     * <p>Gets a formatter instance using the specified pattern, time zone
+     * and locale.</p>
      *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
-     * @param timeZone optional time zone, overrides time zone of formatted date
-     * @param locale optional locale, overrides system locale
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible
+     *  pattern
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date
+     * @param locale  optional locale, overrides system locale
      * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid or {@code null}
+     * @throws IllegalArgumentException if pattern is invalid
+     *  or {@code null}
      */
     public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {
-        return CACHE.getInstance(pattern, timeZone, locale);
+        return cache.getInstance(pattern, timeZone, locale);
     }
 
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Gets a date formatter instance using the specified style in the default time zone and locale.
-     * </p>
+     * <p>Gets a date formatter instance using the specified style in the
+     * default time zone and locale.</p>
      *
-     * @param style date style: FULL, LONG, MEDIUM, or SHORT
+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
      * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date pattern defined
+     * @throws IllegalArgumentException if the Locale has no date
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getDateInstance(final int style) {
-        return CACHE.getDateInstance(style, null, null);
+        return cache.getDateInstance(style, null, null);
     }
 
     /**
-     * <p>
-     * Gets a date formatter instance using the specified style and locale in the default time zone.
-     * </p>
+     * <p>Gets a date formatter instance using the specified style and
+     * locale in the default time zone.</p>
      *
-     * @param style date style: FULL, LONG, MEDIUM, or SHORT
-     * @param locale optional locale, overrides system locale
+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date pattern defined
+     * @throws IllegalArgumentException if the Locale has no date
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getDateInstance(final int style, final Locale locale) {
-        return CACHE.getDateInstance(style, null, locale);
+        return cache.getDateInstance(style, null, locale);
     }
 
     /**
-     * <p>
-     * Gets a date formatter instance using the specified style and time zone in the default locale.
-     * </p>
+     * <p>Gets a date formatter instance using the specified style and
+     * time zone in the default locale.</p>
      *
-     * @param style date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date
+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date
      * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date pattern defined
+     * @throws IllegalArgumentException if the Locale has no date
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone) {
-        return CACHE.getDateInstance(style, timeZone, null);
+        return cache.getDateInstance(style, timeZone, null);
     }
 
     /**
-     * <p>
-     * Gets a date formatter instance using the specified style, time zone and locale.
-     * </p>
+     * <p>Gets a date formatter instance using the specified style, time
+     * zone and locale.</p>
      *
-     * @param style date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date
-     * @param locale optional locale, overrides system locale
+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date pattern defined
+     * @throws IllegalArgumentException if the Locale has no date
+     *  pattern defined
      */
     public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {
-        return CACHE.getDateInstance(style, timeZone, locale);
+        return cache.getDateInstance(style, timeZone, locale);
     }
 
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Gets a time formatter instance using the specified style in the default time zone and locale.
-     * </p>
+     * <p>Gets a time formatter instance using the specified style in the
+     * default time zone and locale.</p>
      *
-     * @param style time style: FULL, LONG, MEDIUM, or SHORT
+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
      * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time pattern defined
+     * @throws IllegalArgumentException if the Locale has no time
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getTimeInstance(final int style) {
-        return CACHE.getTimeInstance(style, null, null);
+        return cache.getTimeInstance(style, null, null);
     }
 
     /**
-     * <p>
-     * Gets a time formatter instance using the specified style and locale in the default time zone.
-     * </p>
+     * <p>Gets a time formatter instance using the specified style and
+     * locale in the default time zone.</p>
      *
-     * @param style time style: FULL, LONG, MEDIUM, or SHORT
-     * @param locale optional locale, overrides system locale
+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time pattern defined
+     * @throws IllegalArgumentException if the Locale has no time
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getTimeInstance(final int style, final Locale locale) {
-        return CACHE.getTimeInstance(style, null, locale);
+        return cache.getTimeInstance(style, null, locale);
     }
 
     /**
-     * <p>
-     * Gets a time formatter instance using the specified style and time zone in the default locale.
-     * </p>
+     * <p>Gets a time formatter instance using the specified style and
+     * time zone in the default locale.</p>
      *
-     * @param style time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted time
+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted time
      * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time pattern defined
+     * @throws IllegalArgumentException if the Locale has no time
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone) {
-        return CACHE.getTimeInstance(style, timeZone, null);
+        return cache.getTimeInstance(style, timeZone, null);
     }
 
     /**
-     * <p>
-     * Gets a time formatter instance using the specified style, time zone and locale.
-     * </p>
+     * <p>Gets a time formatter instance using the specified style, time
+     * zone and locale.</p>
      *
-     * @param style time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted time
-     * @param locale optional locale, overrides system locale
+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted time
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time pattern defined
+     * @throws IllegalArgumentException if the Locale has no time
+     *  pattern defined
      */
     public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {
-        return CACHE.getTimeInstance(style, timeZone, locale);
+        return cache.getTimeInstance(style, timeZone, locale);
     }
 
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Gets a date/time formatter instance using the specified style in the default time zone and locale.
-     * </p>
+     * <p>Gets a date/time formatter instance using the specified style
+     * in the default time zone and locale.</p>
      *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle) {
-        return CACHE.getDateTimeInstance(dateStyle, timeStyle, null, null);
+        return cache.getDateTimeInstance(dateStyle, timeStyle, null, null);
     }
 
     /**
-     * <p>
-     * Gets a date/time formatter instance using the specified style and locale in the default time zone.
-     * </p>
+     * <p>Gets a date/time formatter instance using the specified style and
+     * locale in the default time zone.</p>
      *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
-     * @param locale optional locale, overrides system locale
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      * @since 2.1
      */
     public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale) {
-        return CACHE.getDateTimeInstance(dateStyle, timeStyle, null, locale);
+        return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);
     }
 
     /**
-     * <p>
-     * Gets a date/time formatter instance using the specified style and time zone in the default locale.
-     * </p>
+     * <p>Gets a date/time formatter instance using the specified style and
+     * time zone in the default locale.</p>
      *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      * @since 2.1
      */
-    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle,
-            final TimeZone timeZone) {
+    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone) {
         return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
     }
-
     /**
-     * <p>
-     * Gets a date/time formatter instance using the specified style, time zone and locale.
-     * </p>
+     * <p>Gets a date/time formatter instance using the specified style,
+     * time zone and locale.</p>
      *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date
-     * @param locale optional locale, overrides system locale
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      */
-    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle,
-            final TimeZone timeZone, final Locale locale) {
-        return CACHE.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);
+    public static FastDateFormat getDateTimeInstance(
+            final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {
+        return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);
+    }
+
+    // Constructor
+    //-----------------------------------------------------------------------
+    /**
+     * <p>Constructs a new FastDateFormat.</p>
+     *
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
+     * @param timeZone  non-null time zone to use
+     * @param locale  non-null locale to use
+     * @throws NullPointerException if pattern, timeZone, or locale is null.
+     */
+    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) {
+        this(pattern, timeZone, locale, null);
+    }
+
+    // Constructor
+    //-----------------------------------------------------------------------
+    /**
+     * <p>Constructs a new FastDateFormat.</p>
+     *
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
+     * @param timeZone  non-null time zone to use
+     * @param locale  non-null locale to use
+     * @param centuryStart The start of the 100 year period to use as the "default century" for 2 digit year parsing.  If centuryStart is null, defaults to now - 80 years
+     * @throws NullPointerException if pattern, timeZone, or locale is null.
+     */
+    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart) {
+        printer= new FastDatePrinter(pattern, timeZone, locale);
+        parser= new FastDateParser(pattern, timeZone, locale, centuryStart);
     }
 
     // Format methods
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Formats a {@code Date}, {@code Calendar} or {@code Long} (milliseconds) object.
-     * </p>
+     * <p>Formats a {@code Date}, {@code Calendar} or
+     * {@code Long} (milliseconds) object.</p>
+     * This method is an implementation of {@link Format#format(Object, StringBuilder, FieldPosition)}
      *
-     * @param obj the object to format
-     * @param toAppendTo the buffer to append to
-     * @param pos the position - ignored
+     * @param obj  the object to format
+     * @param toAppendTo  the buffer to append to
+     * @param pos  the position - ignored
      * @return the buffer passed in
      */
     @Override
     public StringBuilder format(final Object obj, final StringBuilder toAppendTo, final FieldPosition pos) {
-        return printer.format(obj, toAppendTo, pos);
+        return toAppendTo.append(printer.format(obj));
     }
 
     /**
-     * <p>
-     * Formats a millisecond {@code long} value.
-     * </p>
+     * <p>Formats a millisecond {@code long} value.</p>
      *
-     * @param millis the millisecond value to format
+     * @param millis  the millisecond value to format
      * @return the formatted string
      * @since 2.1
      */
@@ -387,11 +429,9 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Formats a {@code Date} object using a {@code GregorianCalendar}.
-     * </p>
+     * <p>Formats a {@code Date} object using a {@code GregorianCalendar}.</p>
      *
-     * @param date the date to format
+     * @param date  the date to format
      * @return the formatted string
      */
     @Override
@@ -400,11 +440,9 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Formats a {@code Calendar} object.
-     * </p>
+     * <p>Formats a {@code Calendar} object.</p>
      *
-     * @param calendar the calendar to format
+     * @param calendar  the calendar to format
      * @return the formatted string
      */
     @Override
@@ -413,54 +451,52 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Formats a millisecond {@code long} value into the supplied {@code StringBuilder}.
-     * </p>
+     * <p>Formats a millisecond {@code long} value into the
+     * supplied {@code StringBuffer}.</p>
      *
-     * @param millis the millisecond value to format
-     * @param buf the buffer to format into
+     * @param millis  the millisecond value to format
+     * @param buf  the buffer to format into
      * @return the specified string buffer
-     * @since 2.1
+     * @since 3.5
      */
     @Override
-    public StringBuilder format(final long millis, final StringBuilder buf) {
+    public <B extends Appendable> B format(final long millis, final B buf) {
         return printer.format(millis, buf);
     }
 
     /**
-     * <p>
-     * Formats a {@code Date} object into the supplied {@code StringBuilder} using a {@code GregorianCalendar}.
-     * </p>
+     * <p>Formats a {@code Date} object into the
+     * supplied {@code StringBuffer} using a {@code GregorianCalendar}.</p>
      *
-     * @param date the date to format
-     * @param buf the buffer to format into
+     * @param date  the date to format
+     * @param buf  the buffer to format into
      * @return the specified string buffer
+     * @since 3.5
      */
     @Override
-    public StringBuilder format(final Date date, final StringBuilder buf) {
+    public <B extends Appendable> B format(final Date date, final B buf) {
         return printer.format(date, buf);
     }
 
     /**
-     * <p>
-     * Formats a {@code Calendar} object into the supplied {@code StringBuilder}.
-     * </p>
+     * <p>Formats a {@code Calendar} object into the
+     * supplied {@code StringBuffer}.</p>
      *
-     * @param calendar the calendar to format
-     * @param buf the buffer to format into
+     * @param calendar  the calendar to format
+     * @param buf  the buffer to format into
      * @return the specified string buffer
-     */
+     * @since 3.5
+    */
     @Override
-    public StringBuilder format(final Calendar calendar, final StringBuilder buf) {
+    public <B extends Appendable> B format(final Calendar calendar, final B buf) {
         return printer.format(calendar, buf);
     }
 
     // Parsing
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
 
-    /*
-     * (non-Javadoc)
-     * 
+
+    /* (non-Javadoc)
      * @see DateParser#parse(java.lang.String)
      */
     @Override
@@ -468,9 +504,7 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
         return parser.parse(source);
     }
 
-    /*
-     * (non-Javadoc)
-     * 
+    /* (non-Javadoc)
      * @see DateParser#parse(java.lang.String, java.text.ParsePosition)
      */
     @Override
@@ -480,7 +514,14 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
 
     /*
      * (non-Javadoc)
-     * 
+     * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String, java.text.ParsePosition, java.util.Calendar)
+     */
+    @Override
+    public boolean parse(final String source, final ParsePosition pos, final Calendar calendar) {
+        return parser.parse(source, pos, calendar);
+    }
+
+    /* (non-Javadoc)
      * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)
      */
     @Override
@@ -489,11 +530,9 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     // Accessors
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Gets the pattern used by this formatter.
-     * </p>
+     * <p>Gets the pattern used by this formatter.</p>
      *
      * @return the pattern, {@link java.text.SimpleDateFormat} compatible
      */
@@ -503,13 +542,9 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Gets the time zone used by this formatter.
-     * </p>
+     * <p>Gets the time zone used by this formatter.</p>
      *
-     * <p>
-     * This zone is always used for {@code Date} formatting.
-     * </p>
+     * <p>This zone is always used for {@code Date} formatting. </p>
      *
      * @return the time zone
      */
@@ -519,9 +554,7 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Gets the locale used by this formatter.
-     * </p>
+     * <p>Gets the locale used by this formatter.</p>
      *
      * @return the locale
      */
@@ -531,13 +564,11 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Gets an estimate for the maximum string length that the formatter will produce.
-     * </p>
+     * <p>Gets an estimate for the maximum string length that the
+     * formatter will produce.</p>
      *
-     * <p>
-     * The actual formatted length will almost always be less than or equal to this amount.
-     * </p>
+     * <p>The actual formatted length will almost always be less than or
+     * equal to this amount.</p>
      *
      * @return the maximum formatted length
      */
@@ -545,23 +576,17 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
         return printer.getMaxLengthEstimate();
     }
 
-    public String toPattern() {
-        return printer.getPattern();
-    }
-
     // Basics
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Compares two objects for equality.
-     * </p>
+     * <p>Compares two objects for equality.</p>
      *
-     * @param obj the object to compare to
+     * @param obj  the object to compare to
      * @return {@code true} if equal
      */
     @Override
     public boolean equals(final Object obj) {
-        if (!(obj instanceof FastDateFormat)) {
+        if (obj instanceof FastDateFormat == false) {
             return false;
         }
         final FastDateFormat other = (FastDateFormat) obj;
@@ -570,9 +595,7 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Returns a hash code compatible with equals.
-     * </p>
+     * <p>Returns a hash code compatible with equals.</p>
      *
      * @return a hash code compatible with equals
      */
@@ -582,34 +605,12 @@ public class FastDateFormat extends Format implements DatePrinter, DateParser, S
     }
 
     /**
-     * <p>
-     * Gets a debugging string version of this formatter.
-     * </p>
+     * <p>Gets a debugging string version of this formatter.</p>
      *
      * @return a debugging string
      */
     @Override
     public String toString() {
-        return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + ","
-                + printer.getTimeZone().getID() + "]";
+        return "FastDateFormat[" + printer.getPattern() + "," + printer.getLocale() + "," + printer.getTimeZone().getID() + "]";
     }
-
-    /**
-     * <p>
-     * Performs the formatting by applying the rules to the specified calendar.
-     * </p>
-     *
-     * @param calendar the calendar to format
-     * @param buf the buffer to format into
-     * @return the specified string buffer
-     */
-    protected StringBuilder applyRules(final Calendar calendar, final StringBuilder buf) {
-        return printer.applyRules(calendar, buf);
-    }
-
-    @Override
-    public boolean parse(String source, ParsePosition pos, Calendar calendar) {
-        return parser.parse(source, pos, calendar);
-    }
-
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateParser.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateParser.java
index 19821a2545..4ba5668572 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateParser.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDateParser.java
@@ -66,8 +66,12 @@ import java.util.regex.Pattern;
  *
  * <p>Timing tests indicate this class is as about as fast as SimpleDateFormat
  * in single thread applications and about 25% faster in multi-thread applications.</p>
- *
- * @since 3.2
+ * 
+ * <p>
+ * Copied and modified from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.
+ * </p>
+ * 
+ * @since Apache Commons Lang 3.2
  * @see FastDatePrinter
  */
 public class FastDateParser implements DateParser, Serializable {
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDatePrinter.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDatePrinter.java
index 1a439be031..4f33b6bd11 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDatePrinter.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FastDatePrinter.java
@@ -25,29 +25,82 @@ import java.text.FieldPosition;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
-import java.util.GregorianCalendar;
 import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import org.apache.logging.log4j.core.util.Throwables;
+
 /**
- * Copied from Commons Lang 3.
+ * <p>FastDatePrinter is a fast and thread-safe version of
+ * {@link java.text.SimpleDateFormat}.</p>
+ *
+ * <p>To obtain a FastDatePrinter, use {@link FastDateFormat#getInstance(String, TimeZone, Locale)} 
+ * or another variation of the factory methods of {@link FastDateFormat}.</p>
+ * 
+ * <p>Since FastDatePrinter is thread safe, you can use a static member instance:</p>
+ * <code>
+ *     private static final DatePrinter DATE_PRINTER = FastDateFormat.getInstance("yyyy-MM-dd");
+ * </code>
+ * 
+ * <p>This class can be used as a direct replacement to
+ * {@code SimpleDateFormat} in most formatting situations.
+ * This class is especially useful in multi-threaded server environments.
+ * {@code SimpleDateFormat} is not thread-safe in any JDK version,
+ * nor will it be as Sun have closed the bug/RFE.
+ * </p>
+ *
+ * <p>Only formatting is supported by this class, but all patterns are compatible with
+ * SimpleDateFormat (except time zones and some year patterns - see below).</p>
+ *
+ * <p>Java 1.4 introduced a new pattern letter, {@code 'Z'}, to represent
+ * time zones in RFC822 format (eg. {@code +0800} or {@code -1100}).
+ * This pattern letter can be used here (on all JDK versions).</p>
+ *
+ * <p>In addition, the pattern {@code 'ZZ'} has been made to represent
+ * ISO 8601 extended format time zones (eg. {@code +08:00} or {@code -11:00}).
+ * This introduces a minor incompatibility with Java 1.4, but at a gain of
+ * useful functionality.</p>
+ * 
+ * <p>Starting with JDK7, ISO 8601 support was added using the pattern {@code 'X'}.
+ * To maintain compatibility, {@code 'ZZ'} will continue to be supported, but using
+ * one of the {@code 'X'} formats is recommended.
+ *
+ * <p>Javadoc cites for the year pattern: <i>For formatting, if the number of
+ * pattern letters is 2, the year is truncated to 2 digits; otherwise it is
+ * interpreted as a number.</i> Starting with Java 1.7 a pattern of 'Y' or
+ * 'YYY' will be formatted as '2003', while it was '03' in former Java
+ * versions. FastDatePrinter implements the behavior of Java 7.</p>
+ * 
+ * <p>
+ * Copied and modified from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.
+ * </p>
+ * 
+ * @since Apache Commons Lang 3.2
+ * @see FastDateParser
  */
 public class FastDatePrinter implements DatePrinter, Serializable {
     // A lot of the speed in this class comes from caching, but some comes
-    // from the special int to StringBuilder conversion.
+    // from the special int to StringBuffer conversion.
     //
     // The following produces a padded 2 digit number:
-    // buffer.append((char)(value / 10 + '0'));
-    // buffer.append((char)(value % 10 + '0'));
+    //   buffer.append((char)(value / 10 + '0'));
+    //   buffer.append((char)(value % 10 + '0'));
     //
-    // Note that the fastest append to StringBuilder is a single char (used here).
+    // Note that the fastest append to StringBuffer is a single char (used here).
     // Note that Integer.toString() is not called, the conversion is simply
     // taking the value and adding (mathematically) the ASCII value for '0'.
     // So, don't change this code! It works and is very fast.
 
+    /**
+     * Required for serialization support.
+     *
+     * @see java.io.Serializable
+     */
+    private static final long serialVersionUID = 1L;
+
     /**
      * FULL locale dependent date or time style.
      */
@@ -65,13 +118,6 @@ public class FastDatePrinter implements DatePrinter, Serializable {
      */
     public static final int SHORT = DateFormat.SHORT;
 
-    /**
-     * Required for serialization support.
-     *
-     * @see java.io.Serializable
-     */
-    private static final long serialVersionUID = 1L;
-
     /**
      * The pattern.
      */
@@ -94,17 +140,15 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     private transient int mMaxLengthEstimate;
 
     // Constructor
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Constructs a new FastDatePrinter.
-     * </p>
-     * Use {@link FastDateFormat#getInstance(String, TimeZone, Locale)} or another variation of the factory methods of
-     * {@link FastDateFormat} to get a cached FastDatePrinter instance.
+     * <p>Constructs a new FastDatePrinter.</p>
+     * Use {@link FastDateFormat#getInstance(String, TimeZone, Locale)}  or another variation of the 
+     * factory methods of {@link FastDateFormat} to get a cached FastDatePrinter instance.
      *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern
-     * @param timeZone non-null time zone to use
-     * @param locale non-null locale to use
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
+     * @param timeZone  non-null time zone to use
+     * @param locale  non-null locale to use
      * @throws NullPointerException if pattern, timeZone, or locale is null.
      */
     protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale) {
@@ -116,16 +160,14 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Initializes the instance for first use.
-     * </p>
+     * <p>Initializes the instance for first use.</p>
      */
     private void init() {
         final List<Rule> rulesList = parsePattern();
         mRules = rulesList.toArray(new Rule[rulesList.size()]);
 
         int len = 0;
-        for (int i = mRules.length; --i >= 0;) {
+        for (int i=mRules.length; --i >= 0; ) {
             len += mRules[i].estimateLength();
         }
 
@@ -133,11 +175,9 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     // Parse the pattern
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Returns a list of Rules given a pattern.
-     * </p>
+     * <p>Returns a list of Rules given a pattern.</p>
      *
      * @return a {@code List} of Rule objects
      * @throws IllegalArgumentException if pattern is invalid
@@ -174,11 +214,15 @@ public class FastDatePrinter implements DatePrinter, Serializable {
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y': // year (number)
+            case 'Y': // week year
                 if (tokenLen == 2) {
                     rule = TwoDigitYearField.INSTANCE;
                 } else {
                     rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
                 }
+                if (c == 'Y') {
+                    rule = new WeekYear((NumberRule) rule);
+                }
                 break;
             case 'M': // month in year (text and number)
                 if (tokenLen >= 4) {
@@ -212,6 +256,9 @@ public class FastDatePrinter implements DatePrinter, Serializable {
             case 'E': // day in week (text)
                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                 break;
+            case 'u': // day in week (number)
+                rule = new DayInWeekField(selectNumberRule(Calendar.DAY_OF_WEEK, tokenLen));
+                break;
             case 'D': // day in year (number)
                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                 break;
@@ -233,12 +280,9 @@ public class FastDatePrinter implements DatePrinter, Serializable {
             case 'K': // hour in am/pm (0..11)
                 rule = selectNumberRule(Calendar.HOUR, tokenLen);
                 break;
-            case 'u': // day of week (1..7)
-                rule = selectNumberRule(Calendar.DAY_OF_WEEK, tokenLen);
-                break;
-            case 'X': // ISO 8601
+            case 'X': // ISO 8601 
                 rule = Iso8601_Rule.getRule(tokenLen);
-                break;
+                break;    
             case 'z': // time zone (text)
                 if (tokenLen >= 4) {
                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);
@@ -274,12 +318,10 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Performs the parsing of tokens.
-     * </p>
+     * <p>Performs the parsing of tokens.</p>
      *
-     * @param pattern the pattern
-     * @param indexRef index references
+     * @param pattern  the pattern
+     * @param indexRef  index references
      * @return parsed token
      */
     protected String parseToken(final String pattern, final int[] indexRef) {
@@ -320,7 +362,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {
                     } else {
                         inLiteral = !inLiteral;
                     }
-                } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
+                } else if (!inLiteral &&
+                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                     i--;
                     break;
                 } else {
@@ -334,12 +377,10 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Gets an appropriate rule for the padding required.
-     * </p>
+     * <p>Gets an appropriate rule for the padding required.</p>
      *
-     * @param field the field to get a rule for
-     * @param padding the padding required
+     * @param field  the field to get a rule for
+     * @param padding  the padding required
      * @return a new rule with the correct padding
      */
     protected NumberRule selectNumberRule(final int field, final int padding) {
@@ -354,17 +395,17 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     // Format methods
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Formats a {@code Date}, {@code Calendar} or {@code Long} (milliseconds) object.
-     * </p>
-     *
-     * @param obj the object to format
-     * @param toAppendTo the buffer to append to
-     * @param pos the position - ignored
+     * <p>Formats a {@code Date}, {@code Calendar} or
+     * {@code Long} (milliseconds) object.</p>
+     * @deprecated Use {{@link #format(Date)}, {{@link #format(Calendar)}, {{@link #format(long)}, or {{@link #format(Object)}
+     * @param obj  the object to format
+     * @param toAppendTo  the buffer to append to
+     * @param pos  the position - ignored
      * @return the buffer passed in
      */
+    @Deprecated
     @Override
     public StringBuilder format(final Object obj, final StringBuilder toAppendTo, final FieldPosition pos) {
         if (obj instanceof Date) {
@@ -374,25 +415,43 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         } else if (obj instanceof Long) {
             return format(((Long) obj).longValue(), toAppendTo);
         } else {
-            throw new IllegalArgumentException("Unknown class: " + (obj == null ? "<null>" : obj.getClass().getName()));
+            throw new IllegalArgumentException("Unknown class: " +
+                (obj == null ? "<null>" : obj.getClass().getName()));
         }
     }
 
-    /*
-     * (non-Javadoc)
-     * 
+    /**
+     * <p>Formats a {@code Date}, {@code Calendar} or
+     * {@code Long} (milliseconds) object.</p>
+     * @since 3.5
+     * @param obj  the object to format
+     * @return The formatted value.
+     */
+    String format(final Object obj) {
+        if (obj instanceof Date) {
+            return format((Date) obj);
+        } else if (obj instanceof Calendar) {
+            return format((Calendar) obj);
+        } else if (obj instanceof Long) {
+            return format(((Long) obj).longValue());
+        } else {
+            throw new IllegalArgumentException("Unknown class: " +
+                (obj == null ? "<null>" : obj.getClass().getName()));
+        }
+    }
+
+    /* (non-Javadoc)
      * @see org.apache.commons.lang3.time.DatePrinter#format(long)
      */
     @Override
     public String format(final long millis) {
-        final Calendar c = newCalendar(); // hard code GregorianCalendar
+        final Calendar c = newCalendar();
         c.setTimeInMillis(millis);
         return applyRulesToString(c);
     }
 
     /**
      * Creates a String representation of the given Calendar by applying the rules of this printer to it.
-     * 
      * @param c the Calender to apply the rules to.
      * @return a String representation of the given Calendar.
      */
@@ -401,30 +460,24 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * Creation method for ne calender instances.
-     * 
+     * Creation method for new calender instances.
      * @return a new Calendar instance.
      */
-    private GregorianCalendar newCalendar() {
-        // hard code GregorianCalendar
-        return new GregorianCalendar(mTimeZone, mLocale);
+    private Calendar newCalendar() {
+        return Calendar.getInstance(mTimeZone, mLocale);
     }
 
-    /*
-     * (non-Javadoc)
-     * 
+    /* (non-Javadoc)
      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date)
      */
     @Override
     public String format(final Date date) {
-        final Calendar c = newCalendar(); // hard code GregorianCalendar
+        final Calendar c = newCalendar();
         c.setTime(date);
         return applyRulesToString(c);
     }
 
-    /*
-     * (non-Javadoc)
-     * 
+    /* (non-Javadoc)
      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar)
      */
     @Override
@@ -432,60 +485,77 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         return format(calendar, new StringBuilder(mMaxLengthEstimate)).toString();
     }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.lang3.time.DatePrinter#format(long, java.lang.StringBuilder)
+    /* (non-Javadoc)
+     * @see org.apache.commons.lang3.time.DatePrinter#format(long, java.lang.Appendable)
      */
     @Override
-    public StringBuilder format(final long millis, final StringBuilder buf) {
-        return format(new Date(millis), buf);
+    public <B extends Appendable> B format(final long millis, final B buf) {
+        final Calendar c = newCalendar();
+        c.setTimeInMillis(millis);
+        return applyRules(c, buf);
     }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date, java.lang.StringBuilder)
+    /* (non-Javadoc)
+     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date, java.lang.Appendable)
      */
     @Override
-    public StringBuilder format(final Date date, final StringBuilder buf) {
-        final Calendar c = newCalendar(); // hard code GregorianCalendar
+    public <B extends Appendable> B format(final Date date, final B buf) {
+        final Calendar c = newCalendar();
         c.setTime(date);
         return applyRules(c, buf);
     }
 
-    /*
-     * (non-Javadoc)
-     * 
-     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar, java.lang.StringBuilder)
+    /* (non-Javadoc)
+     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar, java.lang.Appendable)
      */
     @Override
-    public StringBuilder format(final Calendar calendar, final StringBuilder buf) {
+    public <B extends Appendable> B format(Calendar calendar, final B buf) {
         // do not pass in calendar directly, this will cause TimeZone of FastDatePrinter to be ignored
-        return format(calendar.getTime(), buf);
+        if(!calendar.getTimeZone().equals(mTimeZone)) {
+            calendar = (Calendar)calendar.clone();
+            calendar.setTimeZone(mTimeZone);
+        }
+        return applyRules(calendar, buf);
     }
 
     /**
-     * <p>
-     * Performs the formatting by applying the rules to the specified calendar.
-     * </p>
+     * Performs the formatting by applying the rules to the
+     * specified calendar.
      *
      * @param calendar the calendar to format
      * @param buf the buffer to format into
      * @return the specified string buffer
+     *
+     * @deprecated use {@link #format(Calendar)} or {@link #format(Calendar, Appendable)}
+     */
+    @Deprecated
+    protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {
+        return (StringBuffer) applyRules(calendar, (Appendable)buf);
+    }
+
+    /**
+     * <p>Performs the formatting by applying the rules to the
+     * specified calendar.</p>
+     *
+     * @param calendar  the calendar to format
+     * @param buf  the buffer to format into
+     * @param <B> the Appendable class type, usually StringBuilder or StringBuffer.
+     * @return the specified string buffer
      */
-    protected StringBuilder applyRules(final Calendar calendar, final StringBuilder buf) {
-        for (final Rule rule : mRules) {
-            rule.appendTo(buf, calendar);
+    private <B extends Appendable> B applyRules(final Calendar calendar, final B buf) {
+        try {
+            for (final Rule rule : mRules) {
+                rule.appendTo(buf, calendar);
+            }
+        } catch (final IOException ioe) {
+            Throwables.rethrow(ioe);
         }
         return buf;
     }
 
     // Accessors
-    // -----------------------------------------------------------------------
-    /*
-     * (non-Javadoc)
-     * 
+    //-----------------------------------------------------------------------
+    /* (non-Javadoc)
      * @see org.apache.commons.lang3.time.DatePrinter#getPattern()
      */
     @Override
@@ -493,9 +563,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         return mPattern;
     }
 
-    /*
-     * (non-Javadoc)
-     * 
+    /* (non-Javadoc)
      * @see org.apache.commons.lang3.time.DatePrinter#getTimeZone()
      */
     @Override
@@ -503,9 +571,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         return mTimeZone;
     }
 
-    /*
-     * (non-Javadoc)
-     * 
+    /* (non-Javadoc)
      * @see org.apache.commons.lang3.time.DatePrinter#getLocale()
      */
     @Override
@@ -514,13 +580,11 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Gets an estimate for the maximum string length that the formatter will produce.
-     * </p>
+     * <p>Gets an estimate for the maximum string length that the
+     * formatter will produce.</p>
      *
-     * <p>
-     * The actual formatted length will almost always be less than or equal to this amount.
-     * </p>
+     * <p>The actual formatted length will almost always be less than or
+     * equal to this amount.</p>
      *
      * @return the maximum formatted length
      */
@@ -529,13 +593,11 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     // Basics
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Compares two objects for equality.
-     * </p>
+     * <p>Compares two objects for equality.</p>
      *
-     * @param obj the object to compare to
+     * @param obj  the object to compare to
      * @return {@code true} if equal
      */
     @Override
@@ -544,13 +606,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
             return false;
         }
         final FastDatePrinter other = (FastDatePrinter) obj;
-        return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
+        return mPattern.equals(other.mPattern)
+            && mTimeZone.equals(other.mTimeZone) 
+            && mLocale.equals(other.mLocale);
     }
 
     /**
-     * <p>
-     * Returns a hash code compatible with equals.
-     * </p>
+     * <p>Returns a hash code compatible with equals.</p>
      *
      * @return a hash code compatible with equals
      */
@@ -560,9 +622,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Gets a debugging string version of this formatter.
-     * </p>
+     * <p>Gets a debugging string version of this formatter.</p>
      *
      * @return a debugging string
      */
@@ -572,9 +632,10 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     // Serializing
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * Create the object after serialization. This implementation reinitializes the transient properties.
+     * Create the object after serialization. This implementation reinitializes the
+     * transient properties.
      *
      * @param in ObjectInputStream from which the object is being deserialized.
      * @throws IOException if there is an IO issue.
@@ -586,22 +647,94 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * Appends digits to the given buffer.
-     * 
+     * Appends two digits to the given buffer.
+     *
+     * @param buffer the buffer to append to.
+     * @param value the value to append digits from.
+     */
+    private static void appendDigits(final Appendable buffer, final int value) throws IOException {
+        buffer.append((char)(value / 10 + '0'));
+        buffer.append((char)(value % 10 + '0'));
+    }
+
+    private static final int MAX_DIGITS = 10; // log10(Integer.MAX_VALUE) ~= 9.3
+
+    /**
+     * Appends all digits to the given buffer.
+     *
      * @param buffer the buffer to append to.
      * @param value the value to append digits from.
      */
-    private static void appendDigits(final StringBuilder buffer, final int value) {
-        buffer.append((char) (value / 10 + '0'));
-        buffer.append((char) (value % 10 + '0'));
+    private static void appendFullDigits(final Appendable buffer, int value, int minFieldWidth) throws IOException {
+        // specialized paths for 1 to 4 digits -> avoid the memory allocation from the temporary work array
+        // see LANG-1248
+        if (value < 10000) {
+            // less memory allocation path works for four digits or less
+
+            int nDigits = 4;
+            if (value < 1000) {
+                --nDigits;
+                if (value < 100) {
+                    --nDigits;
+                    if (value < 10) {
+                        --nDigits;
+                    }
+                }
+            }
+            // left zero pad
+            for (int i = minFieldWidth - nDigits; i > 0; --i) {
+                buffer.append('0');
+            }
+
+            switch (nDigits) {
+            case 4:
+                buffer.append((char) (value / 1000 + '0'));
+                value %= 1000;
+            case 3:
+                if (value >= 100) {
+                    buffer.append((char) (value / 100 + '0'));
+                    value %= 100;
+                } else {
+                    buffer.append('0');
+                }
+            case 2:
+                if (value >= 10) {
+                    buffer.append((char) (value / 10 + '0'));
+                    value %= 10;
+                } else {
+                    buffer.append('0');
+                }
+            case 1:
+                buffer.append((char) (value + '0'));
+            }
+        } else {
+            // more memory allocation path works for any digits
+
+            // build up decimal representation in reverse
+            final char[] work = new char[MAX_DIGITS];
+            int digit = 0;
+            while (value != 0) {
+                work[digit++] = (char) (value % 10 + '0');
+                value = value / 10;
+            }
+
+            // pad with zeros
+            while (digit < minFieldWidth) {
+                buffer.append('0');
+                --minFieldWidth;
+            }
+
+            // reverse
+            while (--digit >= 0) {
+                buffer.append(work[digit]);
+            }
+        }
     }
 
     // Rules
-    // -----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
     /**
-     * <p>
-     * Inner class defining a rule.
-     * </p>
+     * <p>Inner class defining a rule.</p>
      */
     private interface Rule {
         /**
@@ -614,16 +747,15 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         /**
          * Appends the value of the specified calendar to the output buffer based on the rule implementation.
          *
-         * @param buffer the output buffer
+         * @param buf the output buffer
          * @param calendar calendar to be appended
+         * @throws IOException if an I/O error occurs
          */
-        void appendTo(StringBuilder buffer, Calendar calendar);
+        void appendTo(Appendable buf, Calendar calendar) throws IOException;
     }
 
     /**
-     * <p>
-     * Inner class defining a numeric rule.
-     * </p>
+     * <p>Inner class defining a numeric rule.</p>
      */
     private interface NumberRule extends Rule {
         /**
@@ -631,20 +763,20 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          *
          * @param buffer the output buffer
          * @param value the value to be appended
+         * @throws IOException if an I/O error occurs
          */
-        void appendTo(StringBuilder buffer, int value);
+        void appendTo(Appendable buffer, int value) throws IOException;
     }
 
     /**
-     * <p>
-     * Inner class to output a constant single character.
-     * </p>
+     * <p>Inner class to output a constant single character.</p>
      */
     private static class CharacterLiteral implements Rule {
         private final char mValue;
 
         /**
-         * Constructs a new instance of {@code CharacterLiteral} to hold the specified value.
+         * Constructs a new instance of {@code CharacterLiteral}
+         * to hold the specified value.
          *
          * @param value the character literal
          */
@@ -664,21 +796,20 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             buffer.append(mValue);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output a constant string.
-     * </p>
+     * <p>Inner class to output a constant string.</p>
      */
     private static class StringLiteral implements Rule {
         private final String mValue;
 
         /**
-         * Constructs a new instance of {@code StringLiteral} to hold the specified value.
+         * Constructs a new instance of {@code StringLiteral}
+         * to hold the specified value.
          *
          * @param value the string literal
          */
@@ -698,22 +829,21 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             buffer.append(mValue);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output one of a set of values.
-     * </p>
+     * <p>Inner class to output one of a set of values.</p>
      */
     private static class TextField implements Rule {
         private final int mField;
         private final String[] mValues;
 
         /**
-         * Constructs an instance of {@code TextField} with the specified field and values.
+         * Constructs an instance of {@code TextField}
+         * with the specified field and values.
          *
          * @param field the field
          * @param values the field values
@@ -729,7 +859,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         @Override
         public int estimateLength() {
             int max = 0;
-            for (int i = mValues.length; --i >= 0;) {
+            for (int i=mValues.length; --i >= 0; ) {
                 final int len = mValues[i].length();
                 if (len > max) {
                     max = len;
@@ -742,15 +872,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             buffer.append(mValues[calendar.get(mField)]);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output an unpadded number.
-     * </p>
+     * <p>Inner class to output an unpadded number.</p>
      */
     private static class UnpaddedNumberField implements NumberRule {
         private final int mField;
@@ -776,7 +904,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             appendTo(buffer, calendar.get(mField));
         }
 
@@ -784,21 +912,19 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public final void appendTo(final StringBuilder buffer, final int value) {
+        public final void appendTo(final Appendable buffer, final int value) throws IOException {
             if (value < 10) {
-                buffer.append((char) (value + '0'));
+                buffer.append((char)(value + '0'));
             } else if (value < 100) {
                 appendDigits(buffer, value);
             } else {
-                buffer.append(value);
+               appendFullDigits(buffer, value, 1);
             }
         }
     }
 
     /**
-     * <p>
-     * Inner class to output an unpadded month.
-     * </p>
+     * <p>Inner class to output an unpadded month.</p>
      */
     private static class UnpaddedMonthField implements NumberRule {
         static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();
@@ -823,7 +949,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             appendTo(buffer, calendar.get(Calendar.MONTH) + 1);
         }
 
@@ -831,9 +957,9 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public final void appendTo(final StringBuilder buffer, final int value) {
+        public final void appendTo(final Appendable buffer, final int value) throws IOException {
             if (value < 10) {
-                buffer.append((char) (value + '0'));
+                buffer.append((char)(value + '0'));
             } else {
                 appendDigits(buffer, value);
             }
@@ -841,9 +967,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Inner class to output a padded number.
-     * </p>
+     * <p>Inner class to output a padded number.</p>
      */
     private static class PaddedNumberField implements NumberRule {
         private final int mField;
@@ -876,7 +1000,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             appendTo(buffer, calendar.get(mField));
         }
 
@@ -884,23 +1008,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public final void appendTo(final StringBuilder buffer, int value) {
-            // pad the buffer with adequate zeros
-            for (int digit = 0; digit < mSize; ++digit) {
-                buffer.append('0');
-            }
-            // backfill the buffer with non-zero digits
-            int index = buffer.length();
-            for (; value > 0; value /= 10) {
-                buffer.setCharAt(--index, (char) ('0' + value % 10));
-            }
+        public final void appendTo(final Appendable buffer, final int value) throws IOException {
+            appendFullDigits(buffer, value, mSize);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output a two digit number.
-     * </p>
+     * <p>Inner class to output a two digit number.</p>
      */
     private static class TwoDigitNumberField implements NumberRule {
         private final int mField;
@@ -926,7 +1040,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             appendTo(buffer, calendar.get(mField));
         }
 
@@ -934,19 +1048,17 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public final void appendTo(final StringBuilder buffer, final int value) {
+        public final void appendTo(final Appendable buffer, final int value) throws IOException {
             if (value < 100) {
                 appendDigits(buffer, value);
             } else {
-                buffer.append(value);
+                appendFullDigits(buffer, value, 2);
             }
         }
     }
 
     /**
-     * <p>
-     * Inner class to output a two digit year.
-     * </p>
+     * <p>Inner class to output a two digit year.</p>
      */
     private static class TwoDigitYearField implements NumberRule {
         static final TwoDigitYearField INSTANCE = new TwoDigitYearField();
@@ -970,7 +1082,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             appendTo(buffer, calendar.get(Calendar.YEAR) % 100);
         }
 
@@ -978,15 +1090,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public final void appendTo(final StringBuilder buffer, final int value) {
+        public final void appendTo(final Appendable buffer, final int value) throws IOException {
             appendDigits(buffer, value);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output a two digit month.
-     * </p>
+     * <p>Inner class to output a two digit month.</p>
      */
     private static class TwoDigitMonthField implements NumberRule {
         static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();
@@ -1010,7 +1120,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             appendTo(buffer, calendar.get(Calendar.MONTH) + 1);
         }
 
@@ -1018,21 +1128,20 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public final void appendTo(final StringBuilder buffer, final int value) {
+        public final void appendTo(final Appendable buffer, final int value) throws IOException {
             appendDigits(buffer, value);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output the twelve hour field.
-     * </p>
+     * <p>Inner class to output the twelve hour field.</p>
      */
     private static class TwelveHourField implements NumberRule {
         private final NumberRule mRule;
 
         /**
-         * Constructs an instance of {@code TwelveHourField} with the specified {@code NumberRule}.
+         * Constructs an instance of {@code TwelveHourField} with the specified
+         * {@code NumberRule}.
          *
          * @param rule the rule
          */
@@ -1052,7 +1161,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             int value = calendar.get(Calendar.HOUR);
             if (value == 0) {
                 value = calendar.getLeastMaximum(Calendar.HOUR) + 1;
@@ -1064,21 +1173,20 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final int value) {
+        public void appendTo(final Appendable buffer, final int value) throws IOException {
             mRule.appendTo(buffer, value);
         }
     }
 
     /**
-     * <p>
-     * Inner class to output the twenty four hour field.
-     * </p>
+     * <p>Inner class to output the twenty four hour field.</p>
      */
     private static class TwentyFourHourField implements NumberRule {
         private final NumberRule mRule;
 
         /**
-         * Constructs an instance of {@code TwentyFourHourField} with the specified {@code NumberRule}.
+         * Constructs an instance of {@code TwentyFourHourField} with the specified
+         * {@code NumberRule}.
          *
          * @param rule the rule
          */
@@ -1098,7 +1206,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             int value = calendar.get(Calendar.HOUR_OF_DAY);
             if (value == 0) {
                 value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;
@@ -1110,25 +1218,75 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final int value) {
+        public void appendTo(final Appendable buffer, final int value) throws IOException {
             mRule.appendTo(buffer, value);
         }
     }
 
-    // -----------------------------------------------------------------------
+    /**
+     * <p>Inner class to output the numeric day in week.</p>
+     */
+    private static class DayInWeekField implements NumberRule {
+        private final NumberRule mRule;
+
+        DayInWeekField(final NumberRule rule) {
+            mRule = rule;
+        }
+
+        @Override
+        public int estimateLength() {
+            return mRule.estimateLength();
+        }
 
-    private static final ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<>(
-            7);
+        @Override
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
+            final int value = calendar.get(Calendar.DAY_OF_WEEK);
+            mRule.appendTo(buffer, value != Calendar.SUNDAY ? value - 1 : 7);
+        }
 
+        @Override
+        public void appendTo(final Appendable buffer, final int value) throws IOException {
+            mRule.appendTo(buffer, value);
+        }
+    }
+
+    /**
+     * <p>Inner class to output the numeric day in week.</p>
+     */
+    private static class WeekYear implements NumberRule {
+        private final NumberRule mRule;
+
+        WeekYear(final NumberRule rule) {
+            mRule = rule;
+        }
+
+        @Override
+        public int estimateLength() {
+            return mRule.estimateLength();
+        }
+
+        @Override
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
+            mRule.appendTo(buffer, calendar.getWeekYear());
+        }
+
+        @Override
+        public void appendTo(final Appendable buffer, final int value) throws IOException {
+            mRule.appendTo(buffer, value);
+        }
+    }
+
+    //-----------------------------------------------------------------------
+
+    private static final ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =
+        new ConcurrentHashMap<>(7);
     /**
-     * <p>
-     * Gets the time zone display name, using a cache for performance.
-     * </p>
+     * <p>Gets the time zone display name, using a cache for performance.</p>
      *
-     * @param tz the zone to query
-     * @param daylight true if daylight savings
-     * @param style the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}
-     * @param locale the locale to use
+     * @param tz  the zone to query
+     * @param daylight  true if daylight savings
+     * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}
+     * @param locale  the locale to use
      * @return the textual name of the time zone
      */
     static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) {
@@ -1139,16 +1297,14 @@ public class FastDatePrinter implements DatePrinter, Serializable {
             value = tz.getDisplayName(daylight, style, locale);
             final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);
             if (prior != null) {
-                value = prior;
+                value= prior;
             }
         }
         return value;
     }
 
     /**
-     * <p>
-     * Inner class to output a time zone name.
-     * </p>
+     * <p>Inner class to output a time zone name.</p>
      */
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
@@ -1166,7 +1322,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
         TimeZoneNameRule(final TimeZone timeZone, final Locale locale, final int style) {
             mLocale = locale;
             mStyle = style;
-
+            
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
         }
@@ -1186,7 +1342,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             final TimeZone zone = calendar.getTimeZone();
             if (calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
@@ -1197,14 +1353,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Inner class to output a time zone as a number {@code +/-HHMM} or {@code +/-HH:MM}.
-     * </p>
+     * <p>Inner class to output a time zone as a number {@code +/-HHMM}
+     * or {@code +/-HH:MM}.</p>
      */
     private static class TimeZoneNumberRule implements Rule {
         static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);
         static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);
-
+        
         final boolean mColon;
 
         /**
@@ -1228,8 +1383,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
-
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
+            
             int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
 
             if (offset < 0) {
@@ -1252,14 +1407,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
     }
 
     /**
-     * <p>
-     * Inner class to output a time zone as a number {@code +/-HHMM} or {@code +/-HH:MM}.
-     * </p>
+     * <p>Inner class to output a time zone as a number {@code +/-HHMM}
+     * or {@code +/-HH:MM}.</p>
      */
     private static class Iso8601_Rule implements Rule {
-
+        
         // Sign TwoDigitHours or Z
-        static final Iso8601_Rule ISO8601_HOURS = new Iso8601_Rule(3);
+        static final Iso8601_Rule ISO8601_HOURS = new Iso8601_Rule(3);       
         // Sign TwoDigitHours Minutes or Z
         static final Iso8601_Rule ISO8601_HOURS_MINUTES = new Iso8601_Rule(5);
         // Sign TwoDigitHours : Minutes or Z
@@ -1269,11 +1423,11 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * Factory method for Iso8601_Rules.
          *
          * @param tokenLen a token indicating the length of the TimeZone String to be formatted.
-         * @return a Iso8601_Rule that can format TimeZone String of length {@code tokenLen}. If no such rule exists, an
-         *         IllegalArgumentException will be thrown.
+         * @return a Iso8601_Rule that can format TimeZone String of length {@code tokenLen}. If no such
+         *          rule exists, an IllegalArgumentException will be thrown.
          */
         static Iso8601_Rule getRule(final int tokenLen) {
-            switch (tokenLen) {
+            switch(tokenLen) {
             case 1:
                 return Iso8601_Rule.ISO8601_HOURS;
             case 2:
@@ -1281,10 +1435,10 @@ public class FastDatePrinter implements DatePrinter, Serializable {
             case 3:
                 return Iso8601_Rule.ISO8601_HOURS_COLON_MINUTES;
             default:
-                throw new IllegalArgumentException("invalid number of X");
+                throw new IllegalArgumentException("invalid number of X");                    
             }
-        }
-
+        }        
+        
         final int length;
 
         /**
@@ -1308,13 +1462,13 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * {@inheritDoc}
          */
         @Override
-        public void appendTo(final StringBuilder buffer, final Calendar calendar) {
+        public void appendTo(final Appendable buffer, final Calendar calendar) throws IOException {
             int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
             if (offset == 0) {
                 buffer.append("Z");
                 return;
             }
-
+            
             if (offset < 0) {
                 buffer.append('-');
                 offset = -offset;
@@ -1325,11 +1479,11 @@ public class FastDatePrinter implements DatePrinter, Serializable {
             final int hours = offset / (60 * 60 * 1000);
             appendDigits(buffer, hours);
 
-            if (length < 5) {
+            if (length<5) {
                 return;
             }
-
-            if (length == 6) {
+            
+            if (length==6) {
                 buffer.append(':');
             }
 
@@ -1340,9 +1494,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
 
     // ----------------------------------------------------------------------
     /**
-     * <p>
-     * Inner class that acts as a compound key for time zone names.
-     * </p>
+     * <p>Inner class that acts as a compound key for time zone names.</p>
      */
     private static class TimeZoneDisplayKey {
         private final TimeZone mTimeZone;
@@ -1357,7 +1509,8 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          * @param style the timezone style
          * @param locale the timezone locale
          */
-        TimeZoneDisplayKey(final TimeZone timeZone, final boolean daylight, final int style, final Locale locale) {
+        TimeZoneDisplayKey(final TimeZone timeZone,
+                           final boolean daylight, final int style, final Locale locale) {
             mTimeZone = timeZone;
             if (daylight) {
                 mStyle = style | 0x80000000;
@@ -1372,7 +1525,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {
          */
         @Override
         public int hashCode() {
-            return (mStyle * 31 + mLocale.hashCode()) * 31 + mTimeZone.hashCode();
+            return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();
         }
 
         /**
@@ -1384,8 +1537,11 @@ public class FastDatePrinter implements DatePrinter, Serializable {
                 return true;
             }
             if (obj instanceof TimeZoneDisplayKey) {
-                final TimeZoneDisplayKey other = (TimeZoneDisplayKey) obj;
-                return mTimeZone.equals(other.mTimeZone) && mStyle == other.mStyle && mLocale.equals(other.mLocale);
+                final TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;
+                return
+                    mTimeZone.equals(other.mTimeZone) &&
+                    mStyle == other.mStyle &&
+                    mLocale.equals(other.mLocale);
             }
             return false;
         }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FormatCache.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FormatCache.java
index 98d494a87c..e146a1dda2 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FormatCache.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/util/datetime/FormatCache.java
@@ -26,29 +26,32 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 /**
+ * <p>FormatCache is a cache and factory for {@link Format}s.</p>
+ * 
  * <p>
- * FormatCache is a cache and factory for {@link Format}s.
+ * Copied and modified from <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>.
  * </p>
- *
- * @since 3.0
+ * 
+ * @since Apache Commons Lang 3.0
  */
 // TODO: Before making public move from getDateTimeInstance(Integer,...) to int; or some other approach.
 abstract class FormatCache<F extends Format> {
+    
     /**
-     * No date or no time. Used in same parameters as DateFormat.SHORT or DateFormat.LONG
+     * No date or no time.  Used in same parameters as DateFormat.SHORT or DateFormat.LONG
      */
-    static final int NONE = -1;
-
-    private static final ConcurrentMap<MultipartKey, String> DATETIME_INSTANCE_CACHE =
-            new ConcurrentHashMap<>(7);
-
-    private final ConcurrentMap<MultipartKey, F> cInstanceCache = new ConcurrentHashMap<>(7);
+    static final int NONE= -1;
+    
+    private final ConcurrentMap<MultipartKey, F> cInstanceCache 
+        = new ConcurrentHashMap<>(7);
+    
+    private static final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache 
+        = new ConcurrentHashMap<>(7);
 
     /**
-     * <p>
-     * Gets a formatter instance using the default pattern in the default timezone and locale.
-     * </p>
-     *
+     * <p>Gets a formatter instance using the default pattern in the
+     * default timezone and locale.</p>
+     * 
      * @return a date/time formatter
      */
     public F getInstance() {
@@ -56,15 +59,16 @@ abstract class FormatCache<F extends Format> {
     }
 
     /**
-     * <p>
-     * Gets a formatter instance using the specified pattern, time zone and locale.
-     * </p>
-     *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern, non-null
-     * @param timeZone the time zone, null means use the default TimeZone
-     * @param locale the locale, null means use the default Locale
+     * <p>Gets a formatter instance using the specified pattern, time zone
+     * and locale.</p>
+     * 
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible
+     *  pattern, non-null
+     * @param timeZone  the time zone, null means use the default TimeZone
+     * @param locale  the locale, null means use the default Locale
      * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid or <code>null</code>
+     * @throws IllegalArgumentException if pattern is invalid
+     *  or <code>null</code>
      */
     public F getInstance(final String pattern, TimeZone timeZone, Locale locale) {
         if (pattern == null) {
@@ -78,46 +82,46 @@ abstract class FormatCache<F extends Format> {
         }
         final MultipartKey key = new MultipartKey(pattern, timeZone, locale);
         F format = cInstanceCache.get(key);
-        if (format == null) {
+        if (format == null) {           
             format = createInstance(pattern, timeZone, locale);
-            final F previousValue = cInstanceCache.putIfAbsent(key, format);
+            final F previousValue= cInstanceCache.putIfAbsent(key, format);
             if (previousValue != null) {
                 // another thread snuck in and did the same work
                 // we should return the instance that is in ConcurrentMap
-                format = previousValue;
+                format= previousValue;              
             }
         }
         return format;
     }
-
+    
     /**
-     * <p>
-     * Create a format instance using the specified pattern, time zone and locale.
-     * </p>
-     *
-     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern, this will not be null.
-     * @param timeZone time zone, this will not be null.
-     * @param locale locale, this will not be null.
+     * <p>Create a format instance using the specified pattern, time zone
+     * and locale.</p>
+     * 
+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern, this will not be null.
+     * @param timeZone  time zone, this will not be null.
+     * @param locale  locale, this will not be null.
      * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid or <code>null</code>
+     * @throws IllegalArgumentException if pattern is invalid
+     *  or <code>null</code>
      */
     abstract protected F createInstance(String pattern, TimeZone timeZone, Locale locale);
-
+        
     /**
-     * <p>
-     * Gets a date/time formatter instance using the specified style, time zone and locale.
-     * </p>
-     *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT, null indicates no date in format
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT, null indicates no time in format
-     * @param timeZone optional time zone, overrides time zone of formatted date, null means use default Locale
-     * @param locale optional locale, overrides system locale
+     * <p>Gets a date/time formatter instance using the specified style,
+     * time zone and locale.</p>
+     * 
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT, null indicates no date in format
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT, null indicates no time in format
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date, null means use default Locale
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      */
-    // This must remain private, see LANG-884
-    private F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone,
-            Locale locale) {
+    // This must remain private, see LANG-884 
+    private F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone, Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
@@ -126,16 +130,17 @@ abstract class FormatCache<F extends Format> {
     }
 
     /**
-     * <p>
-     * Gets a date/time formatter instance using the specified style, time zone and locale.
-     * </p>
-     *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date, null means use default Locale
-     * @param locale optional locale, overrides system locale
+     * <p>Gets a date/time formatter instance using the specified style,
+     * time zone and locale.</p>
+     * 
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date, null means use default Locale
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      */
     // package protected, for access from FastDateFormat; do not make public or protected
     F getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {
@@ -143,15 +148,16 @@ abstract class FormatCache<F extends Format> {
     }
 
     /**
-     * <p>
-     * Gets a date formatter instance using the specified style, time zone and locale.
-     * </p>
-     *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date, null means use default Locale
-     * @param locale optional locale, overrides system locale
+     * <p>Gets a date formatter instance using the specified style,
+     * time zone and locale.</p>
+     * 
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date, null means use default Locale
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      */
     // package protected, for access from FastDateFormat; do not make public or protected
     F getDateInstance(final int dateStyle, final TimeZone timeZone, final Locale locale) {
@@ -159,15 +165,16 @@ abstract class FormatCache<F extends Format> {
     }
 
     /**
-     * <p>
-     * Gets a time formatter instance using the specified style, time zone and locale.
-     * </p>
-     *
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone optional time zone, overrides time zone of formatted date, null means use default Locale
-     * @param locale optional locale, overrides system locale
+     * <p>Gets a time formatter instance using the specified style,
+     * time zone and locale.</p>
+     * 
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
+     * @param timeZone  optional time zone, overrides time zone of
+     *  formatted date, null means use default Locale
+     * @param locale  optional locale, overrides system locale
      * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time pattern defined
+     * @throws IllegalArgumentException if the Locale has no date/time
+     *  pattern defined
      */
     // package protected, for access from FastDateFormat; do not make public or protected
     F getTimeInstance(final int timeStyle, final TimeZone timeZone, final Locale locale) {
@@ -175,13 +182,11 @@ abstract class FormatCache<F extends Format> {
     }
 
     /**
-     * <p>
-     * Gets a date/time format for the specified styles and locale.
-     * </p>
-     *
-     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT, null indicates no date in format
-     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT, null indicates no time in format
-     * @param locale The non-null locale of the desired format
+     * <p>Gets a date/time format for the specified styles and locale.</p>
+     * 
+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT, null indicates no date in format
+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT, null indicates no time in format
+     * @param locale  The non-null locale of the desired format
      * @return a localized standard date/time format
      * @throws IllegalArgumentException if the Locale has no date/time pattern defined
      */
@@ -189,24 +194,26 @@ abstract class FormatCache<F extends Format> {
     static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {
         final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);
 
-        String pattern = DATETIME_INSTANCE_CACHE.get(key);
+        String pattern = cDateTimeInstanceCache.get(key);
         if (pattern == null) {
             try {
                 DateFormat formatter;
                 if (dateStyle == null) {
-                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);
-                } else if (timeStyle == null) {
-                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);
-                } else {
+                    formatter = DateFormat.getTimeInstance(timeStyle.intValue(), locale);                    
+                }
+                else if (timeStyle == null) {
+                    formatter = DateFormat.getDateInstance(dateStyle.intValue(), locale);                    
+                }
+                else {
                     formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);
                 }
-                pattern = ((SimpleDateFormat) formatter).toPattern();
-                final String previous = DATETIME_INSTANCE_CACHE.putIfAbsent(key, pattern);
+                pattern = ((SimpleDateFormat)formatter).toPattern();
+                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);
                 if (previous != null) {
                     // even though it doesn't matter if another thread put the pattern
                     // it's still good practice to return the String instance that is
                     // actually in the ConcurrentMap
-                    pattern = previous;
+                    pattern= previous;
                 }
             } catch (final ClassCastException ex) {
                 throw new IllegalArgumentException("No date time pattern for locale: " + locale);
@@ -217,9 +224,7 @@ abstract class FormatCache<F extends Format> {
 
     // ----------------------------------------------------------------------
     /**
-     * <p>
-     * Helper class to hold multi-part Map keys
-     * </p>
+     * <p>Helper class to hold multi-part Map keys</p>
      */
     private static class MultipartKey {
         private final Object[] keys;
@@ -227,8 +232,7 @@ abstract class FormatCache<F extends Format> {
 
         /**
          * Constructs an instance of <code>MultipartKey</code> to hold the specified objects.
-         * 
-         * @param keys the set of objects that make up the key. Each key may be null.
+         * @param keys the set of objects that make up the key.  Each key may be null.
          */
         public MultipartKey(final Object... keys) {
             this.keys = keys;
@@ -242,7 +246,7 @@ abstract class FormatCache<F extends Format> {
             // Eliminate the usual boilerplate because
             // this inner static class is only used in a generic ConcurrentHashMap
             // which will not compare against other Object types
-            return obj != null && Arrays.equals(keys, ((MultipartKey) obj).keys);
+            return Arrays.equals(keys, ((MultipartKey)obj).keys);
         }
 
         /**
@@ -250,14 +254,14 @@ abstract class FormatCache<F extends Format> {
          */
         @Override
         public int hashCode() {
-            if (hashCode == 0) {
-                int rc = 0;
-                for (final Object key : keys) {
-                    if (key != null) {
-                        rc = rc * 7 + key.hashCode();
+            if(hashCode==0) {
+                int rc= 0;
+                for(final Object key : keys) {
+                    if(key!=null) {
+                        rc= rc*7 + key.hashCode();
                     }
                 }
-                hashCode = rc;
+                hashCode= rc;
             }
             return hashCode;
         }
