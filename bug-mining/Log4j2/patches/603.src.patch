diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java
index 57409ace06..872c01d8ab 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java
@@ -460,12 +460,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
                 LOGGER.error("Could not reconfigure JMX", t);
             }
             Log4jLogEvent.setNanoClock(NanoClockFactory.createNanoClock());
-            try {
-                AsyncLogger.setNanoClock(NanoClockFactory.createNanoClock());
-            } catch (Throwable ignored) {
-                // LMAX Disruptor jar may not be in the classpath. Ignore this.
-                LOGGER.debug("Could not set AsyncLogger NanoClock. Ignoring: " + ignored.toString());
-            }
+            AsyncLogger.setNanoClock(NanoClockFactory.createNanoClock());
             return prev;
         } finally {
             configLock.unlock();
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java
index 032ecd138b..c2214f8544 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLogger.java
@@ -19,7 +19,6 @@ package org.apache.logging.log4j.core.async;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 
 import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.Marker;
@@ -33,8 +32,6 @@ import org.apache.logging.log4j.core.jmx.RingBufferAdmin;
 import org.apache.logging.log4j.core.util.Clock;
 import org.apache.logging.log4j.core.util.ClockFactory;
 import org.apache.logging.log4j.core.util.DummyNanoClock;
-import org.apache.logging.log4j.core.util.Integers;
-import org.apache.logging.log4j.core.util.Loader;
 import org.apache.logging.log4j.core.util.NanoClock;
 import org.apache.logging.log4j.message.Message;
 import org.apache.logging.log4j.message.MessageFactory;
@@ -42,14 +39,7 @@ import org.apache.logging.log4j.message.TimestampMessage;
 import org.apache.logging.log4j.status.StatusLogger;
 import org.apache.logging.log4j.util.PropertiesUtil;
 
-import com.lmax.disruptor.BlockingWaitStrategy;
-import com.lmax.disruptor.ExceptionHandler;
-import com.lmax.disruptor.RingBuffer;
-import com.lmax.disruptor.SleepingWaitStrategy;
-import com.lmax.disruptor.WaitStrategy;
-import com.lmax.disruptor.YieldingWaitStrategy;
 import com.lmax.disruptor.dsl.Disruptor;
-import com.lmax.disruptor.dsl.ProducerType;
 
 /**
  * AsyncLogger is a logger designed for high throughput and low latency logging. It does not perform any I/O in the
@@ -71,13 +61,6 @@ import com.lmax.disruptor.dsl.ProducerType;
  * never be any items left in the buffer; all log events will all be written to disk in a very efficient manner.
  */
 public class AsyncLogger extends Logger {
-    private static final long serialVersionUID = 1L;
-    private static final int SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS = 50;
-    private static final int MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN = 200;
-    private static final int RINGBUFFER_MIN_SIZE = 128;
-    private static final int RINGBUFFER_DEFAULT_SIZE = 256 * 1024;
-    private static final StatusLogger LOGGER = StatusLogger.getLogger();
-    private static final ThreadNameStrategy THREAD_NAME_STRATEGY = ThreadNameStrategy.create();
 
     /**
      * Strategy for deciding whether thread name should be cached or not.
@@ -101,7 +84,9 @@ public class AsyncLogger extends Logger {
             final String name = PropertiesUtil.getProperties().getStringProperty("AsyncLogger.ThreadNameStrategy",
                     CACHED.name());
             try {
-                return ThreadNameStrategy.valueOf(name);
+                final ThreadNameStrategy result = ThreadNameStrategy.valueOf(name);
+                LOGGER.debug("AsyncLogger.ThreadNameStrategy={}", result);
+                return result;
             } catch (final Exception ex) {
                 LOGGER.debug("Using AsyncLogger.ThreadNameStrategy.CACHED: '{}' not valid: {}", name, ex.toString());
                 return CACHED;
@@ -109,141 +94,83 @@ public class AsyncLogger extends Logger {
         }
     }
 
-    private static volatile Disruptor<RingBufferLogEvent> disruptor;
-    private static final Clock CLOCK = ClockFactory.getClock();
-    private static volatile NanoClock nanoClock = new DummyNanoClock();
-
-    private static final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor(new DaemonThreadFactory(
-            "AsyncLogger-"));
-
-    static {
-        initInfoForExecutorThread();
-        LOGGER.debug("AsyncLogger.ThreadNameStrategy={}", THREAD_NAME_STRATEGY);
-        final int ringBufferSize = calculateRingBufferSize();
-
-        final WaitStrategy waitStrategy = createWaitStrategy();
-        disruptor = new Disruptor<>(RingBufferLogEvent.FACTORY, ringBufferSize, EXECUTOR, ProducerType.MULTI,
-                waitStrategy);
-        disruptor.handleExceptionsWith(getExceptionHandler());
-        disruptor.handleEventsWith(new RingBufferLogEventHandler());
-
-        LOGGER.debug("Starting AsyncLogger disruptor with ringbuffer size {}...", disruptor.getRingBuffer()
-                .getBufferSize());
-        disruptor.start();
-    }
-
-    /**
-     * Constructs an {@code AsyncLogger} with the specified context, name and message factory.
-     *
-     * @param context context of this logger
-     * @param name name of this logger
-     * @param messageFactory message factory of this logger
-     */
-    public AsyncLogger(final LoggerContext context, final String name, final MessageFactory messageFactory) {
-        super(context, name, messageFactory);
-    }
-
-    private static int calculateRingBufferSize() {
-        int ringBufferSize = RINGBUFFER_DEFAULT_SIZE;
-        final String userPreferredRBSize = PropertiesUtil.getProperties().getStringProperty(
-                "AsyncLogger.RingBufferSize", String.valueOf(ringBufferSize));
-        try {
-            int size = Integer.parseInt(userPreferredRBSize);
-            if (size < RINGBUFFER_MIN_SIZE) {
-                size = RINGBUFFER_MIN_SIZE;
-                LOGGER.warn("Invalid RingBufferSize {}, using minimum size {}.", userPreferredRBSize,
-                        RINGBUFFER_MIN_SIZE);
-            }
-            ringBufferSize = size;
-        } catch (final Exception ex) {
-            LOGGER.warn("Invalid RingBufferSize {}, using default size {}.", userPreferredRBSize, ringBufferSize);
-        }
-        return Integers.ceilingNextPowerOfTwo(ringBufferSize);
-    }
-
-    /**
-     * Initialize an {@code Info} object that is threadlocal to the consumer/appender thread. This Info object uniquely
-     * has attribute {@code isAppenderThread} set to {@code true}. All other Info objects will have this attribute set
-     * to {@code false}. This allows us to detect Logger.log() calls initiated from the appender thread, which may cause
-     * deadlock when the RingBuffer is full. (LOG4J2-471)
-     */
-    private static void initInfoForExecutorThread() {
-        EXECUTOR.submit(new Runnable() {
-            @Override
-            public void run() {
-                final boolean isAppenderThread = true;
-                final Info info = new Info(new RingBufferLogEventTranslator(), //
-                        Thread.currentThread().getName(), isAppenderThread);
-                Info.THREADLOCAL.set(info);
-            }
-        });
-    }
-
-    private static WaitStrategy createWaitStrategy() {
-        final String strategy = PropertiesUtil.getProperties().getStringProperty("AsyncLogger.WaitStrategy");
-        LOGGER.debug("property AsyncLogger.WaitStrategy={}", strategy);
-        if ("Sleep".equals(strategy)) {
-            return new SleepingWaitStrategy();
-        } else if ("Yield".equals(strategy)) {
-            return new YieldingWaitStrategy();
-        } else if ("Block".equals(strategy)) {
-            return new BlockingWaitStrategy();
-        }
-        LOGGER.debug("disruptor event handler uses BlockingWaitStrategy");
-        return new BlockingWaitStrategy();
-    }
-
-    private static ExceptionHandler<RingBufferLogEvent> getExceptionHandler() {
-        final String cls = PropertiesUtil.getProperties().getStringProperty("AsyncLogger.ExceptionHandler");
-        if (cls == null) {
-            LOGGER.debug("No AsyncLogger.ExceptionHandler specified");
-            return null;
-        }
-        try {
-            @SuppressWarnings("unchecked")
-            final ExceptionHandler<RingBufferLogEvent> result = Loader
-                    .newCheckedInstanceOf(cls, ExceptionHandler.class);
-            LOGGER.debug("AsyncLogger.ExceptionHandler={}", result);
-            return result;
-        } catch (final Exception ignored) {
-            LOGGER.debug("AsyncLogger.ExceptionHandler not set: error creating " + cls + ": ", ignored);
-            return null;
-        }
-    }
-
     /**
      * Tuple with the event translator and thread name for a thread.
      */
     static class Info {
-        private static final ThreadLocal<Info> THREADLOCAL = new ThreadLocal<Info>() {
-            @Override
-            protected Info initialValue() {
-                // by default, set isAppenderThread to false
-                return new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);
-            }
-        };
         private final RingBufferLogEventTranslator translator;
         private final String cachedThreadName;
         private final boolean isAppenderThread;
 
-        public Info(final RingBufferLogEventTranslator translator, final String threadName,
-                final boolean appenderThread) {
+        public Info(final RingBufferLogEventTranslator translator, final String threadName, final boolean appenderThread) {
             this.translator = translator;
             this.cachedThreadName = threadName;
             this.isAppenderThread = appenderThread;
         }
 
+        /**
+         * Initialize an {@code Info} object that is threadlocal to the consumer/appender thread. This Info object
+         * uniquely has attribute {@code isAppenderThread} set to {@code true}. All other Info objects will have this
+         * attribute set to {@code false}. This allows us to detect Logger.log() calls initiated from the appender
+         * thread, which may cause deadlock when the RingBuffer is full. (LOG4J2-471)
+         * 
+         * @param executor runs the appender thread
+         */
+        public static void initExecutorThreadInstance(final ExecutorService executor) {
+            executor.submit(new Runnable() {
+                @Override
+                public void run() {
+                    final boolean isAppenderThread = true;
+                    final Info info = new Info(new RingBufferLogEventTranslator(), //
+                            Thread.currentThread().getName(), isAppenderThread);
+                    THREADLOCAL.set(info);
+                }
+            });
+        }
+        
+        private static Info get() {
+            Info result = THREADLOCAL.get();
+            if (result == null) {
+                // by default, set isAppenderThread to false
+                result = new Info(new RingBufferLogEventTranslator(), Thread.currentThread().getName(), false);
+                THREADLOCAL.set(result);
+            }
+            return result;
+        }
+
         // LOG4J2-467
         private String threadName() {
             return THREAD_NAME_STRATEGY.getThreadName(this);
         }
     }
+    
+    private static final long serialVersionUID = 1L;
+    private static final StatusLogger LOGGER = StatusLogger.getLogger();
+
+    private static final ThreadNameStrategy THREAD_NAME_STRATEGY = ThreadNameStrategy.create();
+    private static final ThreadLocal<Info> THREADLOCAL = new ThreadLocal<Info>();
+
+    private static final Clock CLOCK = ClockFactory.getClock();
+    private static volatile NanoClock nanoClock = new DummyNanoClock();
+
+
+    /**
+     * Constructs an {@code AsyncLogger} with the specified context, name and message factory.
+     *
+     * @param context context of this logger
+     * @param name name of this logger
+     * @param messageFactory message factory of this logger
+     */
+    public AsyncLogger(final LoggerContext context, final String name, final MessageFactory messageFactory) {
+        super(context, name, messageFactory);
+        LOGGER.info("Created AsyncLogger " + name);
+    }
 
     @Override
     public void logMessage(final String fqcn, final Level level, final Marker marker, final Message message,
             final Throwable thrown) {
 
-        final Disruptor<RingBufferLogEvent> temp = disruptor;
+        final Disruptor<RingBufferLogEvent> temp = AsyncLoggerHelper.getDisruptor();
         if (temp == null) { // LOG4J2-639
             LOGGER.fatal("Ignoring log event after log4j was shut down");
         } else {
@@ -253,7 +180,7 @@ public class AsyncLogger extends Logger {
 
     private void logMessage0(final Disruptor<RingBufferLogEvent> theDisruptor, final String fqcn, final Level level,
             final Marker marker, final Message message, final Throwable thrown) {
-        final Info info = Info.THREADLOCAL.get();
+        final Info info = Info.get();
         logMessageInAppropriateThread(info, theDisruptor, fqcn, level, marker, message, thrown);
     }
 
@@ -305,7 +232,7 @@ public class AsyncLogger extends Logger {
         message.getFormattedMessage(); // LOG4J2-763: ask message to freeze parameters
 
         initLogMessageInfo(info, fqcn, level, marker, message, thrown);
-        enqueueLogMessageInfo(info);
+        AsyncLoggerHelper.enqueueLogMessageInfo(info.translator);
     }
 
     private void initLogMessageInfo(Info info, final String fqcn, final Level level, final Marker marker,
@@ -357,18 +284,6 @@ public class AsyncLogger extends Logger {
         return includeLocation ? location(fqcn) : null;
     }
 
-    private void enqueueLogMessageInfo(Info info) {
-        // LOG4J2-639: catch NPE if disruptor field was set to null after our check above
-        try {
-            // Note: do NOT use the temp variable above!
-            // That could result in adding a log event to the disruptor after it was shut down,
-            // which could cause the publishEvent method to hang and never return.
-            disruptor.publishEvent(info.translator);
-        } catch (final NullPointerException npe) {
-            LOGGER.fatal("Ignoring log event after log4j was shut down.");
-        }
-    }
-
     private static StackTraceElement location(final String fqcnOfLogger) {
         return Log4jLogEvent.calcLocation(fqcnOfLogger);
     }
@@ -385,38 +300,6 @@ public class AsyncLogger extends Logger {
         strategy.log(this, event);
     }
 
-    public static void stop() {
-        final Disruptor<RingBufferLogEvent> temp = disruptor;
-
-        // Must guarantee that publishing to the RingBuffer has stopped
-        // before we call disruptor.shutdown()
-        disruptor = null; // client code fails with NPE if log after stop = OK
-        if (temp == null) {
-            return; // stop() has already been called
-        }
-
-        // Calling Disruptor.shutdown() will wait until all enqueued events are fully processed,
-        // but this waiting happens in a busy-spin. To avoid (postpone) wasting CPU,
-        // we sleep in short chunks, up to 10 seconds, waiting for the ringbuffer to drain.
-        for (int i = 0; hasBacklog(temp) && i < MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN; i++) {
-            try {
-                Thread.sleep(SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS); // give up the CPU for a while
-            } catch (final InterruptedException e) { // ignored
-            }
-        }
-        temp.shutdown(); // busy-spins until all events currently in the disruptor have been processed
-        EXECUTOR.shutdown(); // finally, kill the processor thread
-        Info.THREADLOCAL.remove(); // LOG4J2-323
-    }
-
-    /**
-     * Returns {@code true} if the specified disruptor still has unprocessed events.
-     */
-    private static boolean hasBacklog(final Disruptor<?> theDisruptor) {
-        final RingBuffer<?> ringBuffer = theDisruptor.getRingBuffer();
-        return !ringBuffer.hasAvailableCapacity(ringBuffer.getBufferSize());
-    }
-
     /**
      * Creates and returns a new {@code RingBufferAdmin} that instruments the ringbuffer of the {@code AsyncLogger}.
      *
@@ -424,7 +307,7 @@ public class AsyncLogger extends Logger {
      * @return a new {@code RingBufferAdmin} that instruments the ringbuffer
      */
     public static RingBufferAdmin createRingBufferAdmin(final String contextName) {
-        return RingBufferAdmin.forAsyncLogger(disruptor.getRingBuffer(), contextName);
+        return AsyncLoggerHelper.createRingBufferAdmin(contextName);
     }
 
     /**
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContext.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContext.java
index 438e723c79..44bc41f314 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContext.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContext.java
@@ -20,6 +20,7 @@ import java.net.URI;
 
 import org.apache.logging.log4j.core.Logger;
 import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.Configuration;
 import org.apache.logging.log4j.message.MessageFactory;
 
 /**
@@ -53,9 +54,27 @@ public class AsyncLoggerContext extends LoggerContext {
         return new AsyncLogger(ctx, name, messageFactory);
     }
 
+    /* (non-Javadoc)
+     * @see org.apache.logging.log4j.core.LoggerContext#start()
+     */
+    @Override
+    public void start() {
+        AsyncLoggerHelper.start();
+        super.start();
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.logging.log4j.core.LoggerContext#start(org.apache.logging.log4j.core.config.Configuration)
+     */
+    @Override
+    public void start(Configuration config) {
+        AsyncLoggerHelper.start();
+        super.start(config);
+    }
+
     @Override
     public void stop() {
-        AsyncLogger.stop();
+        AsyncLoggerHelper.stop(); // first stop Disruptor
         super.stop();
     }
 }
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContextSelector.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContextSelector.java
index c871a39c21..0dfe867789 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContextSelector.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerContextSelector.java
@@ -23,6 +23,8 @@ import java.util.List;
 
 import org.apache.logging.log4j.core.LoggerContext;
 import org.apache.logging.log4j.core.selector.ContextSelector;
+import org.apache.logging.log4j.core.util.Constants;
+import org.apache.logging.log4j.util.PropertiesUtil;
 
 /**
  * {@code ContextSelector} that returns the singleton {@code AsyncLoggerContext}.
@@ -33,6 +35,11 @@ public class AsyncLoggerContextSelector implements ContextSelector {
     private static final AsyncLoggerContext CONTEXT = new AsyncLoggerContext("AsyncLoggerContext@"
             + AsyncLoggerContext.class.hashCode());
 
+    public static boolean isSelected() {
+    	return AsyncLoggerContextSelector.class.getName().equals(
+                PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR));
+    }
+    
     @Override
     public LoggerContext getContext(final String fqcn, final ClassLoader loader, final boolean currentContext) {
         return CONTEXT;
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerHelper.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerHelper.java
new file mode 100644
index 0000000000..65f76e0ecb
--- /dev/null
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/async/AsyncLoggerHelper.java
@@ -0,0 +1,217 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache license, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the license for the specific language governing permissions and
+ * limitations under the license.
+ */
+
+package org.apache.logging.log4j.core.async;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import org.apache.logging.log4j.core.async.AsyncLogger.Info;
+import org.apache.logging.log4j.core.jmx.RingBufferAdmin;
+import org.apache.logging.log4j.core.util.Integers;
+import org.apache.logging.log4j.core.util.Loader;
+import org.apache.logging.log4j.status.StatusLogger;
+import org.apache.logging.log4j.util.PropertiesUtil;
+
+import com.lmax.disruptor.BlockingWaitStrategy;
+import com.lmax.disruptor.ExceptionHandler;
+import com.lmax.disruptor.RingBuffer;
+import com.lmax.disruptor.SleepingWaitStrategy;
+import com.lmax.disruptor.WaitStrategy;
+import com.lmax.disruptor.YieldingWaitStrategy;
+import com.lmax.disruptor.dsl.Disruptor;
+import com.lmax.disruptor.dsl.ProducerType;
+
+/**
+ * Helper class for AsyncLogger:
+ * <ul>
+ * <li>Separates the AsyncLogger business logic (logging) from the mechanics of working with the LMAX Disruptor.</li>
+ * <li>Disruptor initialization no longer happens in a static initializer block in AsyncLogger to prevent problems where
+ * the Disruptor is unintentionally initialized (and a thread started) because a static method in AsyncLogger is called
+ * (LOG4J2-1159).</li>
+ * <li>Enable a reference counting scheme tracking the total number of starts and stops, so the Disruptor and associated
+ * Executor can be shut down when usage becomes zero. This fixes a long-standing issue that made AsyncLoggers unsuitable
+ * for use in web applications (LOG4J2-493).</li>
+ * </ul>
+ */
+public class AsyncLoggerHelper {
+    private static final int SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS = 50;
+    private static final int MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN = 200;
+    private static final int RINGBUFFER_MIN_SIZE = 128;
+    private static final int RINGBUFFER_DEFAULT_SIZE = 256 * 1024;
+    private static final StatusLogger LOGGER = StatusLogger.getLogger();
+
+    private static ExecutorService executor;
+    private static volatile Disruptor<RingBufferLogEvent> disruptor;
+    private static volatile int count = 0;
+
+    static Disruptor<RingBufferLogEvent> getDisruptor() {
+        return disruptor;
+    }
+
+    /**
+     * Increases the reference count and creates and starts a new Disruptor and associated thread if none currently
+     * exists.
+     * 
+     * @see #release()
+     */
+    static synchronized void start() {
+        count++;
+        initDisruptor();
+    }
+
+    private static synchronized void initDisruptor() {
+        if (disruptor != null) {
+            LOGGER.trace("AsyncLoggerHelper not starting new disruptor, using existing object. Ref count is {}.", count);
+            return;
+        }
+        LOGGER.trace("AsyncLoggerHelper creating new disruptor. Ref count is {}.", count);
+        final int ringBufferSize = calculateRingBufferSize();
+        final WaitStrategy waitStrategy = createWaitStrategy();
+        executor = Executors.newSingleThreadExecutor(new DaemonThreadFactory("AsyncLogger-"));
+        Info.initExecutorThreadInstance(executor);
+
+        disruptor = new Disruptor<>(RingBufferLogEvent.FACTORY, ringBufferSize, executor, ProducerType.MULTI,
+                waitStrategy);
+        disruptor.handleExceptionsWith(getExceptionHandler());
+
+        final RingBufferLogEventHandler[] handlers = {new RingBufferLogEventHandler()};
+        disruptor.handleEventsWith(handlers);
+
+        LOGGER.debug("Starting AsyncLogger disruptor with ringbuffer size {}...", disruptor.getRingBuffer()
+                .getBufferSize());
+        disruptor.start();
+    }
+
+    private static int calculateRingBufferSize() {
+        int ringBufferSize = RINGBUFFER_DEFAULT_SIZE;
+        final String userPreferredRBSize = PropertiesUtil.getProperties().getStringProperty(
+                "AsyncLogger.RingBufferSize", String.valueOf(ringBufferSize));
+        try {
+            int size = Integer.parseInt(userPreferredRBSize);
+            if (size < RINGBUFFER_MIN_SIZE) {
+                size = RINGBUFFER_MIN_SIZE;
+                LOGGER.warn("Invalid RingBufferSize {}, using minimum size {}.", userPreferredRBSize,
+                        RINGBUFFER_MIN_SIZE);
+            }
+            ringBufferSize = size;
+        } catch (final Exception ex) {
+            LOGGER.warn("Invalid RingBufferSize {}, using default size {}.", userPreferredRBSize, ringBufferSize);
+        }
+        return Integers.ceilingNextPowerOfTwo(ringBufferSize);
+    }
+
+    private static WaitStrategy createWaitStrategy() {
+        final String strategy = PropertiesUtil.getProperties().getStringProperty("AsyncLogger.WaitStrategy");
+        LOGGER.debug("property AsyncLogger.WaitStrategy={}", strategy);
+        if ("Sleep".equals(strategy)) {
+            return new SleepingWaitStrategy();
+        } else if ("Yield".equals(strategy)) {
+            return new YieldingWaitStrategy();
+        } else if ("Block".equals(strategy)) {
+            return new BlockingWaitStrategy();
+        }
+        LOGGER.debug("disruptor event handler uses BlockingWaitStrategy");
+        return new BlockingWaitStrategy();
+    }
+
+    private static ExceptionHandler<RingBufferLogEvent> getExceptionHandler() {
+        final String cls = PropertiesUtil.getProperties().getStringProperty("AsyncLogger.ExceptionHandler");
+        if (cls == null) {
+            LOGGER.debug("No AsyncLogger.ExceptionHandler specified");
+            return null;
+        }
+        try {
+            @SuppressWarnings("unchecked")
+            final ExceptionHandler<RingBufferLogEvent> result = Loader
+                    .newCheckedInstanceOf(cls, ExceptionHandler.class);
+            LOGGER.debug("AsyncLogger.ExceptionHandler={}", result);
+            return result;
+        } catch (final Exception ignored) {
+            LOGGER.debug("AsyncLogger.ExceptionHandler not set: error creating " + cls + ": ", ignored);
+            return null;
+        }
+    }
+
+    static void enqueueLogMessageInfo(final RingBufferLogEventTranslator translator) {
+        // LOG4J2-639: catch NPE if disruptor field was set to null in release()
+        try {
+            // Note: we deliberately access the volatile disruptor field afresh here.
+            // Avoiding this and using an older refrence could result in adding a log event to the disruptor after it
+            // was shut down, which could cause the publishEvent method to hang and never return.
+            disruptor.publishEvent(translator);
+        } catch (final NullPointerException npe) {
+            LOGGER.fatal("Ignoring log event after log4j was shut down.");
+        }
+    }
+
+    /**
+     * Creates and returns a new {@code RingBufferAdmin} that instruments the ringbuffer of the {@code AsyncLogger}.
+     *
+     * @param contextName name of the global {@code AsyncLoggerContext}
+     * @return a new {@code RingBufferAdmin} that instruments the ringbuffer
+     */
+    public static RingBufferAdmin createRingBufferAdmin(final String contextName) {
+        return RingBufferAdmin.forAsyncLogger(disruptor.getRingBuffer(), contextName);
+    }
+
+    /**
+     * Decreases the reference count. If the reference count reached zero, the Disruptor and its associated thread are
+     * shut down and their references set to {@code null}.
+     */
+    static synchronized void stop() {
+        if (--count > 0) {
+            LOGGER.trace("AsyncLoggerHelper: not shutting down disruptor: ref count is {}.", count);
+            return;
+        }
+
+        final Disruptor<RingBufferLogEvent> temp = getDisruptor();
+        if (temp == null) {
+            LOGGER.trace("AsyncLoggerHelper: disruptor already shut down: ref count is {}. (Resetting to zero.)", count);
+            count = 0; // ref count must not be negative or #claim() will not work correctly
+            return; // disruptor was already shut down by another thread
+        }
+        LOGGER.trace("AsyncLoggerHelper: shutting down disruptor: ref count is {}.", count);
+
+        // Must guarantee that publishing to the RingBuffer has stopped
+        // before we call disruptor.shutdown()
+        disruptor = null; // client code fails with NPE if log after stop. This is by design.
+
+        // Calling Disruptor.shutdown() will wait until all enqueued events are fully processed,
+        // but this waiting happens in a busy-spin. To avoid (postpone) wasting CPU,
+        // we sleep in short chunks, up to 10 seconds, waiting for the ringbuffer to drain.
+        for (int i = 0; hasBacklog(temp) && i < MAX_DRAIN_ATTEMPTS_BEFORE_SHUTDOWN; i++) {
+            try {
+                Thread.sleep(SLEEP_MILLIS_BETWEEN_DRAIN_ATTEMPTS); // give up the CPU for a while
+            } catch (final InterruptedException e) { // ignored
+            }
+        }
+        temp.shutdown(); // busy-spins until all events currently in the disruptor have been processed
+        executor.shutdown(); // finally, kill the processor thread
+        executor = null;
+        // Info.THREADLOCAL.remove(); // LOG4J2-323
+    }
+
+    /**
+     * Returns {@code true} if the specified disruptor still has unprocessed events.
+     */
+    private static boolean hasBacklog(final Disruptor<?> theDisruptor) {
+        final RingBuffer<?> ringBuffer = theDisruptor.getRingBuffer();
+        return !ringBuffer.hasAvailableCapacity(ringBuffer.getBufferSize());
+    }
+
+}
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java
index 98400cec32..fa7a9ddd2b 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/config/LoggerConfig.java
@@ -433,8 +433,7 @@ public class LoggerConfig extends AbstractFilterable {
     // for synchronous loggers, includeLocation default is TRUE.
     protected static boolean includeLocation(final String includeLocationConfigValue) {
         if (includeLocationConfigValue == null) {
-            final boolean sync = !AsyncLoggerContextSelector.class.getName().equals(
-                    PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR));
+            final boolean sync = !AsyncLoggerContextSelector.isSelected();
             return sync;
         }
         return Boolean.parseBoolean(includeLocationConfigValue);
