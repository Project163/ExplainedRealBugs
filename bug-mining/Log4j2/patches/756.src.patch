diff --git a/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLoggerContext.java b/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLoggerContext.java
index 41d96296c1..4f71a10161 100644
--- a/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLoggerContext.java
+++ b/log4j-api/src/main/java/org/apache/logging/log4j/simple/SimpleLoggerContext.java
@@ -19,15 +19,13 @@ package org.apache.logging.log4j.simple;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
 
 import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.message.MessageFactory;
 import org.apache.logging.log4j.spi.AbstractLogger;
 import org.apache.logging.log4j.spi.ExtendedLogger;
 import org.apache.logging.log4j.spi.LoggerContext;
-import org.apache.logging.log4j.spi.LoggerContextKey;
+import org.apache.logging.log4j.spi.LoggerRegistry;
 import org.apache.logging.log4j.util.PropertiesUtil;
 
 /**
@@ -45,7 +43,7 @@ public class SimpleLoggerContext implements LoggerContext {
 
     /** Include the instance name in the log message? */
     private final boolean showLogName;
-    
+
     /**
      * Include the short name (last component) of the logger in the log message. Defaults to true - otherwise we'll be
      * lost in a flood of messages without knowing who sends them.
@@ -62,7 +60,7 @@ public class SimpleLoggerContext implements LoggerContext {
 
     private final PrintStream stream;
 
-    private final ConcurrentMap<String, ExtendedLogger> loggers = new ConcurrentHashMap<>();
+    private final LoggerRegistry<ExtendedLogger> loggerRegistry = new LoggerRegistry<>();
 
     public SimpleLoggerContext() {
         props = new PropertiesUtil("log4j2.simplelog.properties");
@@ -101,20 +99,16 @@ public class SimpleLoggerContext implements LoggerContext {
 
     @Override
     public ExtendedLogger getLogger(final String name, final MessageFactory messageFactory) {
-        // Note: This is the only method where we add entries to the 'loggers' ivar.
-        // The loggers map key is the logger name plus the messageFactory FQCN.
-        String key = LoggerContextKey.create(name, messageFactory);
-        final ExtendedLogger extendedLogger = loggers.get(key);
+        // Note: This is the only method where we add entries to the 'loggerRegistry' ivar.
+        final ExtendedLogger extendedLogger = loggerRegistry.getLogger(name, messageFactory);
         if (extendedLogger != null) {
             AbstractLogger.checkMessageFactory(extendedLogger, messageFactory);
             return extendedLogger;
         }
         final SimpleLogger simpleLogger = new SimpleLogger(name, defaultLevel, showLogName, showShortName, showDateTime,
                 showContextMap, dateTimeFormat, messageFactory, props, stream);
-        // If messageFactory was null then we need to pull it out of the logger now
-        key = LoggerContextKey.create(name, simpleLogger.getMessageFactory());
-        loggers.putIfAbsent(key, simpleLogger);
-        return loggers.get(key);
+        loggerRegistry.putIfAbsent(name, messageFactory, simpleLogger);
+        return loggerRegistry.getLogger(name, messageFactory);
     }
 
     @Override
@@ -126,12 +120,12 @@ public class SimpleLoggerContext implements LoggerContext {
     public boolean hasLogger(String name, MessageFactory messageFactory) {
         return false;
     }
-    
+
     @Override
     public boolean hasLogger(String name, Class<? extends MessageFactory> messageFactoryClass) {
         return false;
     }
-    
+
     @Override
     public Object getExternalContext() {
         return null;
diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java
index 3937805174..82a6de8eb7 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/LoggerContext.java
@@ -22,7 +22,6 @@ import java.io.File;
 import java.net.URI;
 import java.util.Collection;
 import java.util.Objects;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.locks.Lock;
@@ -44,7 +43,7 @@ import org.apache.logging.log4j.core.util.ShutdownCallbackRegistry;
 import org.apache.logging.log4j.message.MessageFactory;
 import org.apache.logging.log4j.spi.AbstractLogger;
 import org.apache.logging.log4j.spi.LoggerContextFactory;
-import org.apache.logging.log4j.spi.LoggerContextKey;
+import org.apache.logging.log4j.spi.LoggerRegistry;
 import org.apache.logging.log4j.spi.Terminable;
 
 import static org.apache.logging.log4j.core.util.ShutdownCallbackRegistry.*;
@@ -64,7 +63,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
 
     private static final Configuration NULL_CONFIGURATION = new NullConfiguration();
 
-    private final ConcurrentMap<String, Logger> loggers = new ConcurrentHashMap<>();
+    private final LoggerRegistry<Logger> loggerRegistry = new LoggerRegistry<>();
     private final CopyOnWriteArrayList<PropertyChangeListener> propertyChangeListeners = new CopyOnWriteArrayList<>();
 
     /**
@@ -382,7 +381,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
      * @return a collection of the current loggers.
      */
     public Collection<Logger> getLoggers() {
-        return loggers.values();
+        return loggerRegistry.getLoggers();
     }
 
     /**
@@ -395,20 +394,16 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
      */
     @Override
     public Logger getLogger(final String name, final MessageFactory messageFactory) {
-        // Note: This is the only method where we add entries to the 'loggers' ivar.
-        // The loggers map key is the logger name plus the messageFactory FQCN.
-        String key = LoggerContextKey.create(name, messageFactory);
-        Logger logger = loggers.get(key);
+        // Note: This is the only method where we add entries to the 'loggerRegistry' ivar.
+        Logger logger = loggerRegistry.getLogger(name, messageFactory);
         if (logger != null) {
             AbstractLogger.checkMessageFactory(logger, messageFactory);
             return logger;
         }
 
         logger = newInstance(this, name, messageFactory);
-        // If messageFactory was null then we need to pull it out of the logger now
-        key = LoggerContextKey.create(name, logger.getMessageFactory());
-        final Logger prev = loggers.putIfAbsent(key, logger);
-        return prev == null ? logger : prev;
+        loggerRegistry.putIfAbsent(name, messageFactory, logger);
+        return loggerRegistry.getLogger(name, messageFactory);
     }
 
     /**
@@ -419,7 +414,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
      */
     @Override
     public boolean hasLogger(final String name) {
-        return loggers.containsKey(LoggerContextKey.create(name));
+        return loggerRegistry.hasLogger(name);
     }
 
     /**
@@ -430,7 +425,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
      */
     @Override
     public boolean hasLogger(final String name, MessageFactory messageFactory) {
-        return loggers.containsKey(LoggerContextKey.create(name, messageFactory));
+        return loggerRegistry.hasLogger(name, messageFactory);
     }
 
     /**
@@ -441,7 +436,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
      */
     @Override
     public boolean hasLogger(final String name, Class<? extends MessageFactory> messageFactoryClass) {
-        return loggers.containsKey(LoggerContextKey.create(name, messageFactoryClass));
+        return loggerRegistry.hasLogger(name, messageFactoryClass);
     }
 
     /**
@@ -596,7 +591,7 @@ public class LoggerContext extends AbstractLifeCycle implements org.apache.loggi
      */
     public void updateLoggers(final Configuration config) {
         final Configuration old = this.configuration;
-        for (final Logger logger : loggers.values()) {
+        for (final Logger logger : loggerRegistry.getLoggers()) {
             logger.updateConfiguration(config);
         }
         firePropertyChangeEvent(new PropertyChangeEvent(this, PROPERTY_CONFIG, old, config));
diff --git a/log4j-taglib/src/main/java/org/apache/logging/log4j/taglib/Log4jTaglibLoggerContext.java b/log4j-taglib/src/main/java/org/apache/logging/log4j/taglib/Log4jTaglibLoggerContext.java
index 2c7b0a34ed..fb95d9719b 100644
--- a/log4j-taglib/src/main/java/org/apache/logging/log4j/taglib/Log4jTaglibLoggerContext.java
+++ b/log4j-taglib/src/main/java/org/apache/logging/log4j/taglib/Log4jTaglibLoggerContext.java
@@ -25,7 +25,7 @@ import org.apache.logging.log4j.message.MessageFactory;
 import org.apache.logging.log4j.spi.AbstractLogger;
 import org.apache.logging.log4j.spi.ExtendedLogger;
 import org.apache.logging.log4j.spi.LoggerContext;
-import org.apache.logging.log4j.spi.LoggerContextKey;
+import org.apache.logging.log4j.spi.LoggerRegistry;
 
 /**
  * This bridge between the tag library and the Log4j API ensures that instances of {@link Log4jTaglibLogger} are
@@ -36,11 +36,10 @@ import org.apache.logging.log4j.spi.LoggerContextKey;
 final class Log4jTaglibLoggerContext implements LoggerContext {
     // These were change to WeakHashMaps to avoid ClassLoader (memory) leak, something that's particularly
     // important in Servlet containers.
-    private static final WeakHashMap<ServletContext, Log4jTaglibLoggerContext> CONTEXTS =
-            new WeakHashMap<>();
+    private static final WeakHashMap<ServletContext, Log4jTaglibLoggerContext> CONTEXTS = new WeakHashMap<>();
 
-    private final WeakHashMap<String, Log4jTaglibLogger> loggers =
-            new WeakHashMap<>();
+    private final LoggerRegistry<Log4jTaglibLogger> loggerRegistry = new LoggerRegistry<>(
+            new LoggerRegistry.WeakMapFactory<Log4jTaglibLogger>());
 
     private final ServletContext servletContext;
 
@@ -60,25 +59,22 @@ final class Log4jTaglibLoggerContext implements LoggerContext {
 
     @Override
     public Log4jTaglibLogger getLogger(final String name, final MessageFactory messageFactory) {
-        // Note: This is the only method where we add entries to the 'loggers' ivar. 
-        // The loggers map key is the logger name plus the messageFactory FQCN.
-        String key = LoggerContextKey.create(name, messageFactory);
-        Log4jTaglibLogger logger = this.loggers.get(key);
+        // Note: This is the only method where we add entries to the 'loggerRegistry' ivar.
+        Log4jTaglibLogger logger = this.loggerRegistry.getLogger(name, messageFactory);
         if (logger != null) {
             AbstractLogger.checkMessageFactory(logger, messageFactory);
             return logger;
         }
 
-        synchronized (this.loggers) {
-            logger = this.loggers.get(key);
+        synchronized (this.loggerRegistry) {
+            logger = this.loggerRegistry.getLogger(name, messageFactory);
             if (logger == null) {
                 final LoggerContext context = LogManager.getContext(false);
                 final ExtendedLogger original = messageFactory == null ?
                         context.getLogger(name) : context.getLogger(name, messageFactory);
                 // wrap a logger from an underlying implementation
                 logger = new Log4jTaglibLogger(original, name, original.getMessageFactory());
-                key = LoggerContextKey.create(name, original.getMessageFactory());
-                this.loggers.put(key, logger);
+                this.loggerRegistry.putIfAbsent(name, messageFactory, logger);
             }
         }
 
@@ -87,17 +83,17 @@ final class Log4jTaglibLoggerContext implements LoggerContext {
 
     @Override
     public boolean hasLogger(final String name) {
-        return loggers.containsKey(LoggerContextKey.create(name));
+        return loggerRegistry.hasLogger(name);
     }
 
     @Override
     public boolean hasLogger(String name, MessageFactory messageFactory) {
-        return loggers.containsKey(LoggerContextKey.create(name, messageFactory));
+        return loggerRegistry.hasLogger(name, messageFactory);
     }
 
     @Override
     public boolean hasLogger(String name, Class<? extends MessageFactory> messageFactoryClass) {
-        return loggers.containsKey(LoggerContextKey.create(name, messageFactoryClass));
+        return loggerRegistry.hasLogger(name, messageFactoryClass);
     }
 
     static synchronized Log4jTaglibLoggerContext getInstance(final ServletContext servletContext) {
diff --git a/log4j-to-slf4j/src/main/java/org/apache/logging/slf4j/SLF4JLoggerContext.java b/log4j-to-slf4j/src/main/java/org/apache/logging/slf4j/SLF4JLoggerContext.java
index c4e6a997e1..7923b2b761 100644
--- a/log4j-to-slf4j/src/main/java/org/apache/logging/slf4j/SLF4JLoggerContext.java
+++ b/log4j-to-slf4j/src/main/java/org/apache/logging/slf4j/SLF4JLoggerContext.java
@@ -16,20 +16,17 @@
  */
 package org.apache.logging.slf4j;
 
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-
 import org.apache.logging.log4j.message.MessageFactory;
 import org.apache.logging.log4j.spi.ExtendedLogger;
 import org.apache.logging.log4j.spi.LoggerContext;
-import org.apache.logging.log4j.spi.LoggerContextKey;
+import org.apache.logging.log4j.spi.LoggerRegistry;
 import org.slf4j.LoggerFactory;
 
 /**
  *
  */
 public class SLF4JLoggerContext implements LoggerContext {
-    private final ConcurrentMap<String, SLF4JLogger> loggers = new ConcurrentHashMap<>();
+    private final LoggerRegistry<ExtendedLogger> loggerRegistry = new LoggerRegistry<>();
 
     @Override
     public Object getExternalContext() {
@@ -38,32 +35,39 @@ public class SLF4JLoggerContext implements LoggerContext {
 
     @Override
     public ExtendedLogger getLogger(final String name) {
-        if (!loggers.containsKey(name)) {
-            loggers.putIfAbsent(name, new SLF4JLogger(name, LoggerFactory.getLogger(name)));
+        if (!loggerRegistry.hasLogger(name)) {
+            loggerRegistry.putIfAbsent(name, null, new SLF4JLogger(name, LoggerFactory.getLogger(name)));
         }
-        return loggers.get(name);
+        return loggerRegistry.getLogger(name);
     }
 
     @Override
     public ExtendedLogger getLogger(final String name, final MessageFactory messageFactory) {
-        if (!loggers.containsKey(name)) {
-            loggers.putIfAbsent(name, new SLF4JLogger(name, messageFactory, LoggerFactory.getLogger(name)));
+        // FIXME according to LOG4J2-1180, the below line should be:
+        // FIXME if (!loggerRegistry.hasLogger(name, messageFactory)) {
+        if (!loggerRegistry.hasLogger(name)) {
+            // FIXME: should be loggerRegistry.putIfAbsent(name, messageFactory,
+            loggerRegistry.putIfAbsent(name, null,
+                    new SLF4JLogger(name, messageFactory, LoggerFactory.getLogger(name)));
         }
-        return loggers.get(name);
+        // FIXME should be return loggerRegistry.getLogger(name, messageFactory);
+        return loggerRegistry.getLogger(name);
+
+        // TODO applying the above fixes causes (log4j-to-slf4j) LoggerTest to fail
     }
 
     @Override
     public boolean hasLogger(final String name) {
-        return loggers.containsKey(LoggerContextKey.create(name));
+        return loggerRegistry.hasLogger(name);
     }
 
     @Override
     public boolean hasLogger(String name, MessageFactory messageFactory) {
-        return loggers.containsKey(LoggerContextKey.create(name, messageFactory));
+        return loggerRegistry.hasLogger(name, messageFactory);
     }
 
     @Override
     public boolean hasLogger(String name, Class<? extends MessageFactory> messageFactoryClass) {
-        return loggers.containsKey(LoggerContextKey.create(name, messageFactoryClass));
+        return loggerRegistry.hasLogger(name, messageFactoryClass);
     }
 }
