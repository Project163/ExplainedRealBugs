diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java
index 4dd19682cc..4cff083e5c 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/impl/ThrowableProxy.java
@@ -557,7 +557,7 @@ public class ThrowableProxy implements Serializable {
 
     private Class<?> loadClass(final String className) {
         try {
-            return Loader.loadClass(className,this.getClass().getClassLoader());
+            return Loader.loadClass(className, this.getClass().getClassLoader());
         } catch (final ClassNotFoundException | NoClassDefFoundError | SecurityException e) {
             return null;
         }
@@ -602,7 +602,11 @@ public class ThrowableProxy implements Serializable {
                     version = ver;
                 }
             }
-            lastLoader = callerClass.getClassLoader();
+            try {
+                lastLoader = callerClass.getClassLoader();
+            } catch (final SecurityException e) {
+                lastLoader = null;
+            }
         }
         return new CacheEntry(new ExtendedClassInfo(exact, location, version), lastLoader);
     }
diff --git a/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java b/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java
index 9c0b861314..76fe83b5fe 100644
--- a/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java
+++ b/log4j-core/src/test/java/org/apache/logging/log4j/core/impl/ThrowableProxyTest.java
@@ -29,16 +29,17 @@ import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.net.BindException;
 import java.net.InetSocketAddress;
-import java.net.SocketPermission;
 import java.nio.channels.ServerSocketChannel;
-import java.security.CodeSource;
-import java.security.PermissionCollection;
-import java.security.Permissions;
-import java.security.Policy;
+import java.security.Permission;
+import java.security.SecureRandom;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Stack;
 
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.spec.IvParameterSpec;
 import javax.xml.bind.DatatypeConverter;
 
 import org.apache.logging.log4j.LogManager;
@@ -133,41 +134,20 @@ public class ThrowableProxyTest {
 
     @Test
     public void testLogStackTraceWithClassThatWillCauseSecurityException() throws IOException {
-        class SimplePolicy extends Policy {
-
-            private final Permissions permissions;
-
-            public SimplePolicy(final Permissions permissions) {
-                this.permissions = permissions;
-            }
-
-            @Override
-            public PermissionCollection getPermissions(final CodeSource codesource) {
-                return permissions;
-            }
-
-        }
-
         final SecurityManager sm = System.getSecurityManager();
         try {
-            final Permissions permissions = new Permissions();
-
-            // you know, for binding
-            permissions.add(new SocketPermission("localhost:9300", "listen,resolve"));
-
-            /**
-             * the JUnit test runner uses reflection to invoke the test; while leaving this
-             * permission out would display the same issue, it's clearer to grant this
-             * permission and show the real issue that would arise
-             */
-            // TODO: other JDKs might need a different permission here
-            permissions.add(new RuntimePermission("accessClassInPackage.sun.reflect"));
-
-            // for restoring the security manager after test execution
-            permissions.add(new RuntimePermission("setSecurityManager"));
-
-            Policy.setPolicy(new SimplePolicy(permissions));
-            System.setSecurityManager(new SecurityManager());
+            System.setSecurityManager(
+                    new SecurityManager() {
+                        @Override
+                        public void checkPermission(Permission perm) {
+                            if (perm instanceof RuntimePermission) {
+                                // deny access to the class to trigger the security exception
+                                if ("accessClassInPackage.sun.nio.ch".equals(perm.getName())) {
+                                    throw new SecurityException(perm.toString());
+                                }
+                            }
+                        }
+                    });
             ServerSocketChannel.open().socket().bind(new InetSocketAddress("localhost", 9300));
             ServerSocketChannel.open().socket().bind(new InetSocketAddress("localhost", 9300));
             fail("expected a java.net.BindException");
@@ -179,6 +159,45 @@ public class ThrowableProxyTest {
         }
     }
 
+    @Test
+    public void testLogStackTraceWithClassLoaderThatWithCauseSecurityException() throws Exception {
+        final SecurityManager sm = System.getSecurityManager();
+        try {
+            System.setSecurityManager(
+                    new SecurityManager() {
+                        @Override
+                        public void checkPermission(Permission perm) {
+                            if (perm instanceof RuntimePermission) {
+                                // deny access to the classloader to trigger the security exception
+                                if ("getClassLoader".equals(perm.getName())) {
+                                    throw new SecurityException(perm.toString());
+                                }
+                            }
+                        }
+                    });
+            final String algorithm = "AES/CBC/PKCS5Padding";
+            final Cipher ec = Cipher.getInstance(algorithm);
+            final byte[] bytes = new byte[16]; // initialization vector
+            final SecureRandom secureRandom = new SecureRandom();
+            secureRandom.nextBytes(bytes);
+            final KeyGenerator generator = KeyGenerator.getInstance("AES");
+            generator.init(128);
+            final IvParameterSpec algorithmParameterSpec = new IvParameterSpec(bytes);
+            ec.init(Cipher.ENCRYPT_MODE, generator.generateKey(), algorithmParameterSpec, secureRandom);
+            final byte[] raw = new byte[0];
+            final byte[] encrypted = ec.doFinal(raw);
+            final Cipher dc = Cipher.getInstance(algorithm);
+            dc.init(Cipher.DECRYPT_MODE, generator.generateKey(), algorithmParameterSpec, secureRandom);
+            dc.doFinal(encrypted);
+            fail("expected a javax.crypto.BadPaddingException");
+        } catch (final BadPaddingException e) {
+            new ThrowableProxy(e);
+        } finally {
+            // restore the existing security manager
+            System.setSecurityManager(sm);
+        }
+    }
+
     // DO NOT REMOVE THIS COMMENT:
     // UNCOMMENT WHEN GENERATING SERIALIZED THROWABLEPROXY FOR #testSerializationWithUnknownThrowable
     // public static class DeletedException extends Exception {
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 2304bab791..40ab620883 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -37,6 +37,9 @@
       <action issue="LOG4J2-1831" dev="ggregory" type="fix" due-to="Edward Serebrinskiy">
         NullPointerException in HtmlLayout.
       </action>
+      <action issue="LOG4J2-1820" dev="ggregory" type="fix" due-to="Jason Tedor">
+        Log4j 2.8 can lose exceptions when a security manager is present.
+      </action>
     </release>
     <release version="2.8.1" date="2017-02-26" description="GA Release 2.8.1">
       <action issue="LOG4J2-1804" dev="rgoers" type="fix" due-to="Pierrick Hymbert">
