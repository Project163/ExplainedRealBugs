diff --git a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java
index d2d3bfd7a2..fc860e2651 100644
--- a/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java
+++ b/log4j-core/src/main/java/org/apache/logging/log4j/core/appender/AsyncAppender.java
@@ -150,13 +150,30 @@ public final class AsyncAppender extends AbstractAppender {
                 coreEvent.setEndOfBatch(false); // queue is definitely not empty!
                 appendSuccessful = thread.callAppenders(coreEvent);
             } else {
+                final Serializable serialized = Log4jLogEvent.serialize(coreEvent, includeLocation);
                 try {
                     // wait for free slots in the queue
-                    queue.put(Log4jLogEvent.serialize(coreEvent, includeLocation));
+                    queue.put(serialized);
                     appendSuccessful = true;
                 } catch (final InterruptedException e) {
-                    LOGGER.warn("Interrupted while waiting for a free slot in the AsyncAppender LogEvent-queue {}",
-                            getName());
+                    // LOG4J2-1049: Some applications use Thread.interrupt() to send
+                    // messages between application threads. This does not necessarily
+                    // mean that the queue is full. To prevent dropping a log message,
+                    // quickly try to offer the event to the queue again.
+                    // (Yes, this means there is a possibility the same event is logged twice.)
+                    //
+                    // Finally, catching the InterruptedException means the
+                    // interrupted flag has been cleared on the current thread.
+                    // This may interfere with the application's expectation of
+                    // being interrupted, so when we are done, we set the interrupted
+                    // flag again.
+                    appendSuccessful = queue.offer(serialized);
+                    if (!appendSuccessful) {
+                        LOGGER.warn("Interrupted while waiting for a free slot in the AsyncAppender LogEvent-queue {}",
+                        getName());
+                    }
+                    // set the interrupted flag again.
+                    Thread.currentThread().interrupt();
                 }
             }
         } else {
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index e22441f9e6..d383b1fc9e 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -24,6 +24,9 @@
   </properties>
   <body>
     <release version="2.4" date="2015-MM-DD" description="GA Release 2.4">
+      <action issue="LOG4J2-1049" dev="rpopma" type="fix" due-to="Robert Schaft">
+        AsyncAppender now resets the thread interrupted flag after catching InterruptedException.
+      </action>
       <action issue="LOG4J2-1048" dev="rpopma" type="fix" due-to="Nikhil">
         FileConfigurationMonitor unnecessarily calls System.currentTimeMillis causing high CPU usage.
       </action>
