<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 19:31:16 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[LOG4J2-254] Race condition when setting new filename in RollingFileAppender related code</title>
                <link>https://issues.apache.org/jira/browse/LOG4J2-254</link>
                <project id="12310790" key="LOG4J2">Log4j 2</project>
                    <description>&lt;p&gt;I&apos;ve come across what very much looks like a race condition in log4j1. In reviewing the log4j 2 code I believe the same condition exists.&lt;/p&gt;

&lt;p&gt;OutputStreamManager.setOutputStream and OutputStreamManager.write need to have a happens-before edge inserted. You could either make OutputStreamManager.os volatile (best) or make setOutputStream synchronized.&lt;/p&gt;

&lt;p&gt;When the RollingFileAppender decides to roll the file it creates a new OutputStream and calls setOutputStream with it. If there is no happens-before edge then that write to OutputStreamManager.os may not be visible to all threads.&lt;/p&gt;

&lt;p&gt;Background:&lt;br/&gt;
I&apos;ve been attempting to find a way to have applications write logs to Flume without being halted if Flume is down or its channels fill up. My approach was to use the RollingFileAppender from apache-log4j-extras and configure it to roll every minute. Then I setup a Flume spooling directory source to read those files and forward them on.&lt;/p&gt;

&lt;p&gt;I&apos;ve been having problems with Flume complaining that the rolled log file has changed. The spooling directory source checks this so that people do not attempt to use it on logs that are currently being written to.&lt;/p&gt;

&lt;p&gt;I caught an instance of this this afternoon.&lt;/p&gt;

&lt;p&gt;File: castellan-reader.20130514T2058.log.COMPLETED&lt;br/&gt;
2013-05-14 20:57:05,330  INFO ...&lt;/p&gt;

&lt;p&gt;File: castellan-reader.20130514T2058.log&lt;br/&gt;
2013-05-14 21:23:05,709 DEBUG ...&lt;/p&gt;

&lt;p&gt;Why would an event from 2123 be written into a file from 2058?&lt;/p&gt;

&lt;p&gt;My analysis of log4j 1 code is:&lt;br/&gt;
My understanding of log4j shows that the RollingFileAppenders end up calling this:&lt;br/&gt;
FileAppender:&lt;br/&gt;
public  synchronized  void setFile(String fileName, boolean append, boolean bufferedIO, int bufferSize)&lt;/p&gt;

&lt;p&gt;Which shortly calls:&lt;br/&gt;
this.qw = new QuietWriter(writer, errorHandler);&lt;/p&gt;

&lt;p&gt;However, the code to actually write to the writer is this:&lt;br/&gt;
protected&lt;br/&gt;
  void subAppend(LoggingEvent event) {&lt;br/&gt;
    this.qw.write(this.layout.format(event));&lt;/p&gt;

&lt;p&gt;Unless I&apos;m mistaken there&apos;s no happens-before edge between setting the qw and calling subappend. The code path to get to subAppend appears not to go through any method synchronized on FileAppender&apos;s monitor. this.qw is not volatile.&lt;/p&gt;

&lt;p&gt;Note that I haven&apos;t tested log4j 2 for this probable defect - I am raising this work item based on my reading of the code.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12647640">LOG4J2-254</key>
            <summary>Race condition when setting new filename in RollingFileAppender related code</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ejsarge">Edward Sargisson</reporter>
                        <labels>
                    </labels>
                <created>Tue, 14 May 2013 23:48:43 +0000</created>
                <updated>Mon, 27 May 2013 20:54:46 +0000</updated>
                            <resolved>Sun, 26 May 2013 15:56:22 +0000</resolved>
                                    <version>2.0-beta7</version>
                                    <fixVersion>2.0-beta7</fixVersion>
                                    <component>Appenders</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="13657712" author="ejsarge" created="Tue, 14 May 2013 23:57:29 +0000"  >&lt;p&gt;&quot;OutputStreamManager.os volatile (best)&quot;&lt;br/&gt;
Well, perhaps not best. That would now inject memory fences into client code (and prevent instruction reordering) every time somebody writes to a file appender.&lt;/p&gt;</comment>
                            <comment id="13657722" author="garydgregory" created="Wed, 15 May 2013 00:04:13 +0000"  >&lt;p&gt;Why? The sync point would only happen when the instance variable changes value, not when the object is accessed.&lt;/p&gt;</comment>
                            <comment id="13657772" author="garydgregory" created="Wed, 15 May 2013 00:58:56 +0000"  >&lt;p&gt;Looking at OutputStreamManager, it looks like the footer and header should also be volatile. Alternatively, and preferably, they should be &lt;b&gt;final&lt;/b&gt;. In order to make them final, the OutputStreamManager should be passed in the layout, which trickles down into the factory code. The current logic of not overwritting the foot and layout feels like a workaround for the fact that footer and headers are not declared final. &lt;/p&gt;</comment>
                            <comment id="13657791" author="remkop@yahoo.com" created="Wed, 15 May 2013 01:34:08 +0000"  >&lt;p&gt;Edward, nice work on finding this!&lt;/p&gt;

&lt;p&gt;I took a look at OutputStreamManager and I agree that the current code is not correct from a concurrency point of view.&lt;br/&gt;
Specifically, only some methods that access the header, footer or os fields are synchronized, others are not. This means it may break in multi-threaded scenarios.&lt;/p&gt;

&lt;p&gt;One way to fix this would be to synchronize all of the following methods:&lt;br/&gt;
flush()&lt;br/&gt;
close()&lt;br/&gt;
getOutputStream()&lt;br/&gt;
setOutputStream(OutputStream)&lt;br/&gt;
releaseSub()&lt;/p&gt;

&lt;p&gt;Another way is to make the header, footer and os fields volatile, but then the code needs to be modified because code like&lt;br/&gt;
if (this.footer != null) &lt;/p&gt;
{ write(this.footer); }
&lt;p&gt;  // as in releaseSub()&lt;br/&gt;
is still broken in concurrent scenarios even if footer is volatile (may give NullPointerExceptions, for example).&lt;/p&gt;

&lt;p&gt;Code like this would need to be replaced by something like this:&lt;br/&gt;
byte[] localVarFooter = this.footer;&lt;br/&gt;
if (localVarFooter != null) &lt;/p&gt;
{ write(localVarFooter); }

&lt;p&gt;I like Gary&apos;s suggestion of making header and footer final fields. That would simplify things quite a bit.&lt;/p&gt;

&lt;p&gt;If header and footer are final, and if the os (OutputStream) field is volatile, then synchronization can be removed from the write() method and only the setOutputStream() and close() methods would need a slight modification to avoid problems with concurrent invocations.&lt;/p&gt;</comment>
                            <comment id="13658104" author="ralph.goers@dslextreme.com" created="Wed, 15 May 2013 06:28:10 +0000"  >&lt;p&gt;First, rather than using the RollingFileAppender I suggest you just use the FlumeAppender provided in Log4j 2.  Specify type=&quot;persistent&quot; or type=&quot;embedded&quot;, depending on how much of Flume you want to drag into your application.&lt;/p&gt;

&lt;p&gt;As to this problem, yes, the outputstream should be volatile. In the other places where volatile is used I haven&apos;t noticed much of a performance hit so I&apos;m not too worried about that.  &lt;/p&gt;

&lt;p&gt;I would be very much against having the Manager exposed to Layouts. Actually, that would be impossible since the Layouts are plugins and are created by the configuration before the Appender they will reside in is constructed.&lt;/p&gt;

&lt;p&gt;Obviously the header and footer cannot be declared final since they aren&apos;t set in the constructor. I suppose all the OutputStreamAppenders could pass the layout t in their factory methods when they call getManager so that the header and footer could be obtained in the constructor.&lt;/p&gt;</comment>
                            <comment id="13658144" author="ralph.goers@dslextreme.com" created="Wed, 15 May 2013 07:33:10 +0000"  >&lt;p&gt;OutputStream was made volatile and header and footer are final in revision 1482707. Please verify and close.&lt;/p&gt;</comment>
                            <comment id="13658164" author="remkop@yahoo.com" created="Wed, 15 May 2013 08:20:50 +0000"  >&lt;p&gt;That was fast!&lt;br/&gt;
Can I suggest 3 small improvements?&lt;/p&gt;

&lt;p&gt;(1)&lt;br/&gt;
setOutputStream (line 95)&lt;br/&gt;
replace:&lt;br/&gt;
    this.os.write(header, 0, header.length);&lt;br/&gt;
with:&lt;br/&gt;
    os.write(header, 0, header.length);&lt;/p&gt;

&lt;p&gt;(2)&lt;br/&gt;
write(byte[], int, int) (line 110)&lt;br/&gt;
remove (now unnecessary) method synchronization&lt;/p&gt;

&lt;p&gt;(3)&lt;br/&gt;
close() (line 131-135)&lt;br/&gt;
replace:&lt;br/&gt;
    if (os == System.out || os == System.err) &lt;/p&gt;
{
        return;
    }&lt;br/&gt;
    try {&lt;br/&gt;
        os.close();&lt;br/&gt;
with:&lt;br/&gt;
    OutputStream local = os; // read volatile field only once to avoid potential inconsistent behavior&lt;br/&gt;
    if (local == System.out || local == System.err) {        return;    }
&lt;p&gt;    try {&lt;br/&gt;
        local.close();&lt;/p&gt;


&lt;p&gt;If no objections I will commit these tonight after work.&lt;/p&gt;</comment>
                            <comment id="13658313" author="garydgregory" created="Wed, 15 May 2013 12:41:14 +0000"  >

&lt;p&gt;IMO, that is not an improvement. At work we always use &quot;this&quot; to make&lt;br/&gt;
it clear who the receiver is (instance vs static).&lt;/p&gt;

&lt;p&gt;Gary&lt;/p&gt;</comment>
                            <comment id="13658320" author="beamerblvd" created="Wed, 15 May 2013 12:50:21 +0000"  >&lt;p&gt;Yea, not using &quot;this&quot; is a pet peeve of mine, too.&lt;/p&gt;</comment>
                            <comment id="13658323" author="remkop@yahoo.com" created="Wed, 15 May 2013 12:53:51 +0000"  >&lt;p&gt;Gary, there is a subtle difference. It is hard to see from just the code snippet, so here is the method in full:&lt;/p&gt;

&lt;p&gt;    protected void setOutputStream(final OutputStream os) {&lt;br/&gt;
        this.os = os; // replace value of volatile field&lt;br/&gt;
        if (header != null) {&lt;br/&gt;
            try &lt;/p&gt;
{
                this.os.write(header, 0, header.length);  // volatile field value may have changed again...
            }
&lt;p&gt; catch (final IOException ioe) &lt;/p&gt;
{
                LOGGER.error(&quot;Unable to write header&quot;, ioe);
            }
&lt;p&gt;        }&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;Now, imagine a multithreaded scenario where threads t1 and t2 access this method at the same time.&lt;br/&gt;
One possible sequence of events would be:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;t1&amp;#93;&lt;/span&gt; this.os = os; // os is now os1&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;t2&amp;#93;&lt;/span&gt; this.os = os; // os is now os2&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;t1&amp;#93;&lt;/span&gt; this.os.write(header, 0, header.length); // t1 writes header to os2&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;t2&amp;#93;&lt;/span&gt; this.os.write(header, 0, header.length); // t2 writes the same header to os2 again&lt;/p&gt;

&lt;p&gt;In this scenario os1 has no headers written to it and os2 has the same header written to it twice.&lt;/p&gt;

&lt;p&gt;The solution is to call the write method on the &lt;b&gt;local&lt;/b&gt; parameter os, not on the field.&lt;br/&gt;
In general, within the same method a volatile field should only be accessed &lt;b&gt;once&lt;/b&gt;. Anything else is suspicious. &lt;br/&gt;
(Usage of the volatile field &quot;config&quot; in core.Logger violates this rule of thumb, but that is by design.)&lt;/p&gt;</comment>
                            <comment id="13658325" author="beamerblvd" created="Wed, 15 May 2013 13:00:01 +0000"  >&lt;p&gt;Oh. In that case, I think I agree with Remko here. It looks like we should be writing to the local variable.&lt;/p&gt;

&lt;p&gt;For that matter, however, shouldn&apos;t the call to this.os = os came AFTER writing to the header? ::&lt;/p&gt;

&lt;p&gt;    protected void setOutputStream(final OutputStream os) {&lt;br/&gt;
        if (header != null) {&lt;br/&gt;
            try &lt;/p&gt;
{
                os.write(header, 0, header.length);
            }
&lt;p&gt; catch (final IOException ioe) &lt;/p&gt;
{
                LOGGER.error(&quot;Unable to write header&quot;, ioe);
            }
&lt;p&gt;        }&lt;br/&gt;
        this.os = os;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;Otherwise, events may get written to the output stream before the header.&lt;/p&gt;</comment>
                            <comment id="13658330" author="remkop@yahoo.com" created="Wed, 15 May 2013 13:04:35 +0000"  >&lt;p&gt;Nick, I think you are right. Updating the field after writing the header is better.&lt;/p&gt;</comment>
                            <comment id="13658332" author="remkop@yahoo.com" created="Wed, 15 May 2013 13:07:40 +0000"  >&lt;p&gt;Well then, one more improvement: only update the field if writing to the stream was successful:&lt;/p&gt;

&lt;p&gt;    protected void setOutputStream(final OutputStream os) {&lt;br/&gt;
        if (header != null) {&lt;br/&gt;
            try &lt;/p&gt;
{
                os.write(header, 0, header.length);
                this.os = os; // only modify field if the header was successfully written
            }
&lt;p&gt; catch (final IOException ioe) &lt;/p&gt;
{
                LOGGER.error(&quot;Unable to write header&quot;, ioe);
            }
&lt;p&gt;        }&lt;br/&gt;
    }&lt;/p&gt;</comment>
                            <comment id="13658333" author="ralph.goers@dslextreme.com" created="Wed, 15 May 2013 13:08:00 +0000"  >&lt;p&gt;Remko, in practical terms what you are describing won&apos;t happen. RollingFileManager needs to insure that the file is being rolled by only a single thread or everything will be a mess. Notice that the setOutputStream is only ever called from methods that are within synchronized constructs. So the change in (1) is not needed.&lt;/p&gt;

&lt;p&gt;Removing the synchronization on the write method as you suggest in (2) may break things.  Look at the comments on the method. We aren&apos;t synchronizing because the value of os may change but because the OutputStream itself might not be thread safe.&lt;/p&gt;

&lt;p&gt;The third recommendation, while technically correct, has the problem that if you have multiple threads calling close something is very broken. Again, only one thread should ever attempt to close the stream. However, I don&apos;t see any harm in making this change.&lt;/p&gt;
</comment>
                            <comment id="13658347" author="ralph.goers@dslextreme.com" created="Wed, 15 May 2013 13:13:57 +0000"  >&lt;p&gt;The change you propose to setOutputStream above does seem reasonable.&lt;/p&gt;</comment>
                            <comment id="13658351" author="remkop@yahoo.com" created="Wed, 15 May 2013 13:21:23 +0000"  >&lt;p&gt;Ralph, you are right about the synchronization. I missed that access to the stream itself needs to be synchronized.&lt;/p&gt;

&lt;p&gt;About the volatile field usage (1 and 3), I was just looking at this from a multi-threading perspective and these are just noticeable little anti-patterns that caught my eye.&lt;br/&gt;
I realize that with current usage nobody will notice any issue.&lt;/p&gt;

&lt;p&gt;However I would still argue that it is better to fix them, if only because OutputStreamManager acts like a base class and future subclasses (or custom subclasses by users) may have different concurrency usage. (I&apos;m just in the habit of &quot;only one access to a volatile field per method&quot;. Just because I&apos;m paranoid, doesn&apos;t mean they aren&apos;t out to get me.... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )&lt;/p&gt;</comment>
                            <comment id="13658455" author="remkop@yahoo.com" created="Wed, 15 May 2013 15:27:46 +0000"  >&lt;p&gt;Improvements (1) and (3) are now committed to trunk.&lt;/p&gt;</comment>
                            <comment id="13658554" author="ejsarge" created="Wed, 15 May 2013 17:19:41 +0000"  >&lt;p&gt;Hi all,&lt;br/&gt;
Thank you for looking at this defect and fixing it so quickly. I&apos;ve had a look and I&apos;m not familiar enough with log4j2 code but it looks like setOutputStream(( will refuse to set the os field if header is null. AbstractLayout appears to be where header is stored and it states that header may be null. The header == null probably just needs to be this.os = os;&lt;/p&gt;</comment>
                            <comment id="13664617" author="ejsarge" created="Wed, 22 May 2013 22:27:19 +0000"  >&lt;p&gt;This code doesn&apos;t work the second time the file rolls. I get the following stack trace:&lt;/p&gt;

&lt;p&gt;2013-05-22 22:24:09,522 ERROR Unable to write to stream /var/log/flume-ng/flume.log for appender RollingFile&lt;br/&gt;
2013-05-22 22:24:09,522 ERROR An exception occurred processing Appender RollingFile org.apache.logging.log4j.core.appender.AppenderRuntimeException: Error flushing stream /var/log/flume-ng/flume.log&lt;br/&gt;
        at org.apache.logging.log4j.core.appender.OutputStreamManager.flush(OutputStreamManager.java:150)&lt;br/&gt;
        at org.apache.logging.log4j.core.appender.AbstractOutputStreamAppender.append(AbstractOutputStreamAppender.java:115)&lt;br/&gt;
        at org.apache.logging.log4j.core.appender.RollingFileAppender.append(RollingFileAppender.java:84)&lt;br/&gt;
        at org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:102)&lt;br/&gt;
        at org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:404)&lt;br/&gt;
        at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:385)&lt;br/&gt;
        at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:346)&lt;br/&gt;
        at org.apache.logging.log4j.core.Logger.log(Logger.java:110)&lt;br/&gt;
        at org.apache.logging.log4j.spi.AbstractLoggerWrapper.log(AbstractLoggerWrapper.java:55)&lt;br/&gt;
        at org.slf4j.impl.SLF4JLogger.warn(SLF4JLogger.java:311)&lt;br/&gt;
        at org.elasticsearch.common.logging.slf4j.Slf4jESLogger.internalWarn(Slf4jESLogger.java:104)&lt;br/&gt;
        at org.elasticsearch.common.logging.support.AbstractESLogger.warn(AbstractESLogger.java:100)&lt;br/&gt;
        at org.elasticsearch.client.transport.TransportClientNodesService$SimpleNodeSampler.sample(TransportClientNodesService.java:319)&lt;br/&gt;
        at org.elasticsearch.client.transport.TransportClientNodesService$ScheduledNodeSampler.run(TransportClientNodesService.java:281)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:722)&lt;br/&gt;
Caused by: java.io.IOException: Stream Closed&lt;br/&gt;
        at java.io.FileOutputStream.writeBytes(Native Method)&lt;br/&gt;
        at java.io.FileOutputStream.write(FileOutputStream.java:318)&lt;br/&gt;
        at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)&lt;br/&gt;
        at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)&lt;br/&gt;
        at org.apache.logging.log4j.core.appender.OutputStreamManager.flush(OutputStreamManager.java:147)&lt;br/&gt;
        ... 16 more&lt;/p&gt;


&lt;p&gt;This is from a log4j2.xml with the following snippet:&lt;br/&gt;
&amp;lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;/var/log/flume-ng/flume.log&quot;&lt;br/&gt;
       filePattern=&quot;/var/log/flume-ng/spool/flume.%d&lt;/p&gt;
{yyyyMMdd&apos;T&apos;HHmm}
&lt;p&gt;.log&quot;&amp;gt;&lt;/p&gt;

&lt;p&gt;       &amp;lt;!-- date level &lt;span class=&quot;error&quot;&gt;&amp;#91;thread&amp;#93;&lt;/span&gt; logger message exception newline  --&amp;gt;&lt;br/&gt;
       &amp;lt;PatternLayout pattern=&quot;%d %5p &lt;span class=&quot;error&quot;&gt;&amp;#91;%t&amp;#93;&lt;/span&gt; %25c&lt;/p&gt;
{1.}
&lt;p&gt; %m%xEx%n&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;Policies&amp;gt;&lt;br/&gt;
         &amp;lt;TimeBasedTriggeringPolicy /&amp;gt;&lt;br/&gt;
       &amp;lt;/Policies&amp;gt;&lt;br/&gt;
       &amp;lt;DefaultRolloverStrategy max=&quot;20&quot;/&amp;gt;&lt;br/&gt;
    &amp;lt;/RollingFile&amp;gt;&lt;/p&gt;

&lt;p&gt;Since this now breaks logging, and because I can&apos;t find a way to set the header so there appears to be no workaround, I&apos;ve taken the liberty of setting this defect to critical.&lt;/p&gt;
</comment>
                            <comment id="13666732" author="ejsarge" created="Fri, 24 May 2013 22:09:38 +0000"  >&lt;p&gt;I have manually patched my copy of log4j2 and confirmed the defect and fix mentioned above. Without this fix log4j2 will rollover precisely once and then stop logging.&lt;/p&gt;

&lt;p&gt;OutputStreeamManager.setOutputStream needs to be as follows:&lt;br/&gt;
    protected void setOutputStream(final OutputStream os) {&lt;br/&gt;
        if (header != null) {&lt;br/&gt;
            try &lt;/p&gt;
{
                os.write(header, 0, header.length);
                this.os = os; // only update field if os.write() succeeded
            }
&lt;p&gt; catch (final IOException ioe) &lt;/p&gt;
{
                LOGGER.error(&quot;Unable to write header&quot;, ioe);
            }
&lt;p&gt;        } else &lt;/p&gt;
{
            this.os = os;
        }
&lt;p&gt;    }&lt;/p&gt;</comment>
                            <comment id="13667343" author="ralph.goers@dslextreme.com" created="Sun, 26 May 2013 15:55:14 +0000"  >&lt;p&gt;Thanks for catching that! Fix was applied in revision 1486421.&lt;/p&gt;</comment>
                            <comment id="13667344" author="ralph.goers@dslextreme.com" created="Sun, 26 May 2013 15:56:22 +0000"  >&lt;p&gt;Please verify and close.&lt;/p&gt;</comment>
                            <comment id="13667949" author="ejsarge" created="Mon, 27 May 2013 20:54:40 +0000"  >&lt;p&gt;I have verified the code by inspection - and by running a test that fails unless the new code is used.&lt;/p&gt;

&lt;p&gt;Verified and closing.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>327996</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 26 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1klb3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>328340</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>