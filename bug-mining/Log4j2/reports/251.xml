<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 19:32:22 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[LOG4J2-407] JDBCAppender cannot recover from loss of database connectivity</title>
                <link>https://issues.apache.org/jira/browse/LOG4J2-407</link>
                <project id="12310790" key="LOG4J2">Log4j 2</project>
                    <description>&lt;p&gt;The JDBCAppender holds a single database connection for all its logging. If that database connection is closed, it does not attempt to make a new connection.&lt;/p&gt;

&lt;p&gt;Many connection pools automatically close connections after a certain amount of inactivity. (This can be worked around by properly configuring a pool).&lt;/p&gt;

&lt;p&gt;Database connectivity issues are also common enough that a long running application may experience temporary network issues. When the network comes back online, the logging will not resume.&lt;/p&gt;

&lt;p&gt;I&apos;ve been meaning to submit a patch for this, but I haven&apos;t gotten to it. Since I saw that you are looking to come out of beta soon, I thought I would log this issue in case someone else has time to write the patch before I get to it.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12669607">LOG4J2-407</key>
            <summary>JDBCAppender cannot recover from loss of database connectivity</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="beamerblvd">Nick Williams</assignee>
                                    <reporter username="mikekloster">Michael Kloster</reporter>
                        <labels>
                    </labels>
                <created>Fri, 20 Sep 2013 06:12:14 +0000</created>
                <updated>Mon, 12 May 2014 06:20:53 +0000</updated>
                            <resolved>Sat, 8 Feb 2014 02:56:58 +0000</resolved>
                                    <version>2.0-beta9</version>
                                    <fixVersion>2.0-rc1</fixVersion>
                                    <component>Appenders</component>
                        <due></due>
                            <votes>3</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="13772649" author="beamerblvd" created="Fri, 20 Sep 2013 06:17:39 +0000"  >&lt;p&gt;I&apos;ve been mulling over the best way to approach this for several weeks now. Want it to be elegant and simple but still robust like you say. I have a few ideas that I&apos;m playing with. I intend to make this happen before GA.&lt;/p&gt;</comment>
                            <comment id="13821043" author="dredalious" created="Wed, 13 Nov 2013 07:53:06 +0000"  >&lt;p&gt;Any progress on this? I logged an issue yesterday concerning this (before I found this one) &lt;a href=&quot;https://issues.apache.org/jira/browse/LOG4J2-449&quot; title=&quot;JDBCDatabaseManager not closing timed-out connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LOG4J2-449&quot;&gt;&lt;del&gt;LOG4J2-449&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
I&apos;m available to test any solution you have for this. We are also conducting some MySQL database tests next week (failover, network failures, ...), if you can provide me with a patched version we can check the behaviour of Log4J in these scenario&apos;s as well.&lt;/p&gt;</comment>
                            <comment id="13826566" author="tn" created="Tue, 19 Nov 2013 15:04:36 +0000"  >&lt;p&gt;A solution could be to use the new method Connection.isValid() which seems to query the database. Using the isClosed() can not be used for this purpose.&lt;br/&gt;
See the code snippet below, added to the JDBCDatabaseManager. The idea is that if we detect that the connection has been closed due to a timeout, we try to re-establish it.&lt;br/&gt;
I used a timeout of 1s, but this should maybe better made configurable.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;    @Override
    protected void writeInternal(final LogEvent event) {
        StringReader reader = null;
        try {
            if (!this.isConnected() || this.connection == null || this.connection.isClosed()) {
                throw new AppenderLoggingException(
                        &quot;Cannot write logging event; JDBC manager not connected to the database.&quot;);
            }

            // the connection was opened before but may have been closed automatically due to a timeout
            // try to re-establish connection to the database
            if ( !this.connection.isValid( 1 )) {
                disconnectInternal();
                connectInternal();
            }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13827503" author="dredalious" created="Wed, 20 Nov 2013 10:03:35 +0000"  >&lt;p&gt;I&apos;m guessing you would want to do that before the check that throws the AppenderLoggingExcpetion.&lt;br/&gt;
I created a similar solution yesterday with the intention to test this today or tomorrow. This is probably not the best nor the cleanest solution, but rather a quickfix that shouldn&apos;t impact performance too much.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; void writeInternal(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; LogEvent event) {
        StringReader reader = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ( !&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.isConnected() || &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connection == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connection.isClosed() ) {
                &lt;span class=&quot;code-comment&quot;&gt;// Check &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the connection has been closed
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// You don&apos;t want to execute isValid always, since &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; launches a query/ping to the server
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connection != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connection.isValid(3) ) {
                    &lt;span class=&quot;code-comment&quot;&gt;// Try to re-establish connection with database
&lt;/span&gt;                    disconnectInternal();
                    connectInternal();
                }

                &lt;span class=&quot;code-comment&quot;&gt;// Check &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; we were able to recover the connection
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ( &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connection == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; || &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connection.isClosed() ) {
                    &lt;span class=&quot;code-comment&quot;&gt;// Nope, connection is dead...
&lt;/span&gt;                    &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; AppenderLoggingException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Cannot write logging event; JDBC manager not connected to the database.&quot;&lt;/span&gt;);
                }
            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="13827656" author="tn" created="Wed, 20 Nov 2013 13:41:27 +0000"  >&lt;p&gt;No, if you place it there, it will not work.&lt;/p&gt;

&lt;p&gt;It was intentionally placed after the first check.&lt;br/&gt;
A complete fix would do it differently though:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;if an SQLException is caught -&amp;gt; check if the connection is still valid&lt;/li&gt;
	&lt;li&gt;re-connect&lt;/li&gt;
	&lt;li&gt;if re-connect was successful -&amp;gt; re-try writing the log entry&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13827669" author="dredalious" created="Wed, 20 Nov 2013 13:57:25 +0000"  >&lt;p&gt;Now the first check will fail because &apos;this.connection.isClosed()&apos; returns true, so it throws the AppenderLoggingException. I might be missing it, but placing code after that throw would result in the reconnect not being executed, so I placed it before the throw (but I might be overlooking something).&lt;/p&gt;

&lt;p&gt;For your complete fix, special attention should be given to cases in which the database or network is down, as to not end-up in a endless loop of reconnects and retries. This can offcourse be resolved as simple as by adding a counter that only tries x times. &lt;br/&gt;
Also, the SQLException is never thrown at this moment, the check on the connection returns with a AppenderLoggingException.&lt;br/&gt;
Offcourse, these are all small things that when programming a complete fix would probably be dealt with anyway&lt;/p&gt;

&lt;p&gt;PS: I wouldn&apos;t want to do a ping every time a logevent occurs, so always executing a  this.connection.isValid(t) seems a bit overkill. I think (although not tested) that this would decimate performance for both the application and the DB server.&lt;/p&gt;</comment>
                            <comment id="13827883" author="mikekloster" created="Wed, 20 Nov 2013 17:35:22 +0000"  >&lt;p&gt;Another approach to this problem would be to take advantage of the connection pool. At this point, you can set up a connection pool (via the JDBC Datasource) for the logger, but it is just used once to get a single connection that is held by the logger and never returned to the pool. &lt;/p&gt;

&lt;p&gt;If the logger requested a connection from the pool and returned it after each use, the connection pool can be configured to check connection validity (or not) depending on the application need for performance. If the pool can&apos;t give the logger a valid connection, then you can throw an exception without further logic. &lt;/p&gt;

&lt;p&gt;I have never benchmarked the processes of taking/returning a connection from a pool but I&apos;ve always imagined it to be about as fast as taking an object from a dictionary. Is that not the case?&lt;/p&gt;

&lt;p&gt;One issue I see with this suggestion is it makes an assumption that a pool is configured. Maybe this could be overcome with a &quot;isPooled&quot; flag. Then the appender could supply its own &apos;poor man&apos;s&apos; version of a pool like it does now if the connection is not marked as pooled.&lt;/p&gt;</comment>
                            <comment id="13827918" author="dredalious" created="Wed, 20 Nov 2013 18:06:54 +0000"  >&lt;p&gt;Michael, I like your idea very much. How we use the Log4J here, is through a fully configured BoneCP connection pool which indeed already does checking. As you stated, the problem is that the current implementation just uses a single connection.&lt;/p&gt;

&lt;p&gt;I think that in terms of performance it might actually be faster if you implement it so as it can request multiple connections from a pool for parallel processing. If this isn&apos;t possible you could mitigate performance drawbacks (if any) by using the buffer attribute and only requesting a new connection from the pool on each buffer iteration.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure if a &quot;isPooled&quot; flag would be needed, just close and open a connection by default and document this behaviour with a addition that a ConnectionPool is strongly required for intensive logging. I suspect that most enterprise applications or applications generating lots of data would already use a pool.&lt;/p&gt;

&lt;p&gt;I think there are now 2 approaches in this Issue that are under discussion:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Reconnect on exception/disconnect (as explained by Thomas Neidhart)&lt;/li&gt;
	&lt;li&gt;Redo the connection management and open/close on each (batch of) logging event, especially in the case when a connection pool is used (as explained by Michael Kloster)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;m more in favor of the second for a long term solution, but as a quickfix I wrote some code doing the first. I was unable to test my code today, I hope to be able to provide quickfix by friday (my application needs it bad),&lt;/p&gt;</comment>
                            <comment id="13828675" author="tn" created="Thu, 21 Nov 2013 10:13:19 +0000"  >&lt;p&gt;Yes, a connection pool would be the best solution imho, but make it flexible by providing a data source to the JDBCAppender.&lt;/p&gt;</comment>
                            <comment id="13863919" author="jvz" created="Tue, 7 Jan 2014 05:20:27 +0000"  >&lt;p&gt;The DataSourceConnectionSource is already a sort of connection pool considering how it&apos;s normally implemented. An actual connection pool would be necessary for the DriverManagerConnectionSource so that connections can be opened and closed for each log event or batch update.&lt;/p&gt;</comment>
                            <comment id="13865305" author="dredalious" created="Wed, 8 Jan 2014 10:58:42 +0000"  >&lt;p&gt;Would you retrieve a connection from the ConnectionSource on each writeInternal then? Something as such:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; void writeInternal(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; LogEvent event) {
        Connection connection = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connectionSource.getConnection();
        PreparedStatement statement = connection.prepareStatement(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.sqlStatement);
        ...
        Closer.closeSilent(connection);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Should work, I don&apos;t know the overhead of preparing the statement each time vs one-time prepare...&lt;/p&gt;</comment>
                            <comment id="13866734" author="jvz" created="Thu, 9 Jan 2014 15:58:46 +0000"  >&lt;p&gt;The problem with that is there&apos;s a contract on the AbstractDatabaseAppender that writeInternal() won&apos;t call connect() more than once. Then again, this isn&apos;t using the super.connect() method, so that might be a better idea.&lt;/p&gt;</comment>
                            <comment id="13889216" author="jvz" created="Mon, 3 Feb 2014 04:43:55 +0000"  >&lt;p&gt;One possibility would be to use Commons Pool for pooling Connection objects. It&apos;s no good to keep closing connection objects from what I recall.&lt;/p&gt;</comment>
                            <comment id="13895392" author="beamerblvd" created="Sat, 8 Feb 2014 02:56:58 +0000"  >&lt;p&gt;Fixed with r1565858 and r1565878. The database appenders now connect to the database (i.e., borrow from the connection pool) and begin a transaction on every flush or every non-buffered &lt;tt&gt;writeInternal&lt;/tt&gt;, then commit and disconnect (i.e., return to pool) at the end of the flush or non-buffered &lt;tt&gt;writeInternal&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Note also that the &lt;tt&gt;&amp;lt;DriverManager...&amp;gt;&lt;/tt&gt; connection source plugin is no longer available. It was removed because it was unsafe and didn&apos;t support connection pooling. Please use the &lt;tt&gt;&amp;lt;DataSource...&amp;gt;&lt;/tt&gt; or &lt;tt&gt;&amp;lt;ConnectionFactory...&amp;gt;&lt;/tt&gt; connection source plugins, instead.&lt;/p&gt;</comment>
                            <comment id="13895409" author="mikekloster" created="Sat, 8 Feb 2014 03:27:19 +0000"  >&lt;p&gt;Great news! I am on vacation but will be able to validate this fix on my&lt;br/&gt;
end mid next week if someone else has not validated sooner.&lt;/p&gt;

&lt;p&gt;Michael&lt;/p&gt;


</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12677945">LOG4J2-442</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12681887">LOG4J2-457</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12685353">LOG4J2-469</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12676000">LOG4J2-438</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12687584">LOG4J2-489</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12677945">LOG4J2-442</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12681887">LOG4J2-457</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12676000">LOG4J2-438</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12687584">LOG4J2-489</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>349539</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 41 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1o9qn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>349837</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>