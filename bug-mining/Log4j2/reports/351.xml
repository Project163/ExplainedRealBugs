<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 19:33:06 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[LOG4J2-763] Async loggers convert message parameters toString at log record writing not at log statement execution</title>
                <link>https://issues.apache.org/jira/browse/LOG4J2-763</link>
                <project id="12310790" key="LOG4J2">Log4j 2</project>
                    <description>&lt;p&gt;&lt;a href=&quot;http://javaadventure.blogspot.com/2014/07/log4j-20-async-loggers-and-immutability.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://javaadventure.blogspot.com/2014/07/log4j-20-async-loggers-and-immutability.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When using parameterized messages, the toString() method of the log messages is not called when the log message is enqueued, rather after the log message has been dequeued for writing. If any of the message parameters are mutable, they can thus have changed state before the log message is written, thus resulting in the logged message content being incorrect.&lt;/p&gt;

&lt;p&gt;From the blog post, code that demonstrates the problem:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.logging.log4j.LogManager;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.logging.log4j.Logger;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.atomic.AtomicLong;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;App {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; AtomicLong value = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; AtomicLong();
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString() {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;.toString(value.get());
    }
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; next() {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; value.incrementAndGet();
    }

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 32; i++) {
            &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;() {
                &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Logger logger = LogManager.getLogger(App.class);
                 &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; App instance = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; App();
                @Override
                 &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
                     &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++) {
                         logger.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;{} == {}&quot;&lt;/span&gt;, instance.next(), instance);
                     }
                 }
            }.start();
        }
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the first few lines of logging output&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-13] 13 == 13 
2014-07-28 15:59:45,730 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-29] 29 == 29 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-15] 15 == 15 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-6] 6 == 6 
2014-07-28 15:59:45,730 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-30] 30 == 30 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-20] 20 == 20 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-8] 8 == 8 
2014-07-28 15:59:45,730 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-28] 28 == 28 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-19] 19 == 19 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-18] 18 == 18 
2014-07-28 15:59:45,729 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-5] 5 == 6 
2014-07-28 15:59:45,731 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-13] 33 == 37 
2014-07-28 15:59:45,731 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-8] 39 == 39 
2014-07-28 15:59:45,731 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-28] 40 == 41 
2014-07-28 15:59:45,731 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-18] 42 == 43 
2014-07-28 15:59:45,731 WARN t.App [&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-5] 43 == 43
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To make my previous code work with Asynchronous loggers (other than by fixing the mutable state) I would need to log like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (logger.isWarnEnabled()) {
    logger.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;{} == {}&quot;&lt;/span&gt;, instance.next(), instance.toString());
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</description>
                <environment></environment>
        <key id="12731637">LOG4J2-763</key>
            <summary>Async loggers convert message parameters toString at log record writing not at log statement execution</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rpopma">Remko Popma</assignee>
                                    <reporter username="stephenc">Stephen Connolly</reporter>
                        <labels>
                    </labels>
                <created>Sun, 3 Aug 2014 23:18:32 +0000</created>
                <updated>Sun, 20 Nov 2016 13:04:53 +0000</updated>
                            <resolved>Mon, 11 Aug 2014 14:17:42 +0000</resolved>
                                    <version>2.0</version>
                                    <fixVersion>2.0.2</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="14084185" author="ralph.goers@dslextreme.com" created="Mon, 4 Aug 2014 00:44:02 +0000"  >&lt;p&gt;Thanks Stephen.  &lt;/p&gt;

&lt;p&gt;We actually read your blog and commented on it on the private list (along with a few other blogs mentioning Log4j 2).  Remko suggested that this may be solved by having SimpleMessage and ObjectMessage call toString() on the constructor argument. Since SimpleMessage takes a String already nothing probably needs to be done with it.&lt;/p&gt;

&lt;p&gt;However, I am not sure it is that simple.  ParamterizedMessage takes an array of objects for substitution. These objects should not be passed to another thread or the same problem will result. So really, the Message&apos;s getFormattedMessage method really needs to be called and the result should be passed as part of the log event.&lt;/p&gt;</comment>
                            <comment id="14084194" author="remkop@yahoo.com" created="Mon, 4 Aug 2014 01:06:15 +0000"  >&lt;p&gt;Ralph, I think ParameterizedMessage is already okay; its constructor accepts an Object[] array, and creates a String[] array by calling the &lt;tt&gt;deepToString&lt;/tt&gt; method on each of the elements of the object parameter array. This happens in the constructor, so in the application thread, not in the async background thread. The &lt;tt&gt;ParameterizedMessage.getFormattedMessage&lt;/tt&gt; method called by the background thread uses the resulting String[] array. &lt;/p&gt;

&lt;p&gt;So ParameterizedMessage already takes a String snapshot of each of the parameters when the message is constructed.&lt;/p&gt;

&lt;p&gt;Similar logic probably needs to be added to:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ObjectMessage&lt;/li&gt;
	&lt;li&gt;FormattedMessage&lt;/li&gt;
	&lt;li&gt;LocalizedMessage&lt;/li&gt;
	&lt;li&gt;MapMessage (hmm... this Message is mutable by design it seems. That may be a problem...)&lt;/li&gt;
	&lt;li&gt;StringFormattedMessage&lt;/li&gt;
	&lt;li&gt;StructuredDataMessage (subclass of MapMessage, also mutable)&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14084207" author="ralph.goers@dslextreme.com" created="Mon, 4 Aug 2014 01:32:07 +0000"  >&lt;p&gt;Well, I still have misgivings about this approach as it means that Messages have to be very careful how they are constructed, but it looks to me like it would work.&lt;/p&gt;

&lt;p&gt;In the case of MapMessage, if it is not a SortedMap it is copied into one. We could just always copy it. Since it is a Map&amp;lt;String, String&amp;gt; it can still be manipulated but I think it is OK to allow updates to the Map associated with the Message as that should only be done in special cases within the logging system. FWIW, I am doing that in one of my projects in a LoggerWrapper.  We just need to document what is thread safe and what isn&apos;t.&lt;/p&gt;
</comment>
                            <comment id="14084230" author="remkop@yahoo.com" created="Mon, 4 Aug 2014 02:21:35 +0000"  >&lt;p&gt;True, Messages need to be careful to either cache the formatted message, or the parameters needed to create a formatted message when requested.&lt;/p&gt;

&lt;p&gt;I don&apos;t mind calling &lt;tt&gt;getFormattedMessage&lt;/tt&gt; on the log event before passing it to the async background thread. Currently neither AsyncLoggers nor AsyncAppenders do this, but this can easily be changed. &lt;/p&gt;

&lt;p&gt;We still need to modify a few Message implementations to make sure that they cache the formatted message rather than recalculating it from scratch every time   &lt;tt&gt;getFormattedMessage&lt;/tt&gt; is called.&lt;/p&gt;

&lt;p&gt;On a related note: the &lt;tt&gt;formattedMessage&lt;/tt&gt; field is marked as &lt;tt&gt;transient&lt;/tt&gt; in a number of Message implementations. This may cause issues unless they also cache the parameters in a non-transient String[] array and &lt;tt&gt;getFormattedMessage&lt;/tt&gt; uses the String[] parameters and not the original Object[] parameters.&lt;/p&gt;</comment>
                            <comment id="14084247" author="remkop@yahoo.com" created="Mon, 4 Aug 2014 02:48:27 +0000"  >&lt;p&gt;Strange: I thought ParameterizedMessage was okay because it already takes a snapshot of the parameters when the LogEvent is created, but looking again at Stephen&apos;s blog post, he is using... parameterized messages.&lt;/p&gt;

&lt;p&gt;Looking at the resulting log output, I can&apos;t actually see what is wrong with it.&lt;br/&gt;
Stephen, what did you expect to see in the log output?&lt;/p&gt;

&lt;p&gt;The suggested solution:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (logger.isWarnEnabled()) {
    logger.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;{} == {}&quot;&lt;/span&gt;, instance.next(), instance.toString());
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I don&apos;t think this will produce different results, does it? The only difference I can see is that the window of opportunity for another thread to increment the counter is narrower now than in the original code. But it will still not &lt;b&gt;guarantee&lt;/b&gt; that you see the same number...&lt;/p&gt;

&lt;p&gt;The problem is that the &lt;tt&gt;value&lt;/tt&gt; field is static, so shared by all App instances. Giving each Thread its own App instance does not help since they all still share the same AtomicLong &lt;tt&gt;value&lt;/tt&gt; field.&lt;/p&gt;</comment>
                            <comment id="14084269" author="ralph.goers@dslextreme.com" created="Mon, 4 Aug 2014 03:29:45 +0000"  >&lt;p&gt;Actually, looking at the test in the blog and copied here, unless I am mistaken the test is at fault, not Log4j.&lt;/p&gt;

&lt;p&gt;Yes, every thread is creating a new App instance.  However, I don&apos;t see how that accomplishes anything as the AtomicLong is static so every thread shares it. So thread A will call instance.next() and then before it goes to populate the next parameter another thread can call instance.next() on its App object and cause the value being passed to Log4j to change in Thread A.  &lt;/p&gt;</comment>
                            <comment id="14085108" author="remkop@yahoo.com" created="Mon, 4 Aug 2014 19:05:15 +0000"  >&lt;p&gt;My conclusions:&lt;/p&gt;

&lt;p&gt;In this particular case the problem seems to be with the test case. Logging messages with parameters (like &lt;tt&gt;logger.info(&quot;some {} message&quot;, someParameter);&lt;/tt&gt; ) is thread-safe even if the &lt;tt&gt;someParameter&lt;/tt&gt; object changes after the logger call.&lt;/p&gt;

&lt;p&gt;Other messages can be improved. Especially logging an object directly (like &lt;tt&gt;logger.info(someParameter);&lt;/tt&gt; ) can give unexpected results if the parameter object changes before the async background thread has written the log message. Similarly for some other message implementations mentioned above. (We should also review which fields should be marked &lt;tt&gt;transient&lt;/tt&gt; on the message classes.)&lt;/p&gt;

&lt;p&gt;Apart from that, are there any documentation improvements we can make?&lt;br/&gt;
Any tips for using parameterized messages with async logging? I think it should &quot;just work&quot;, but are there any scenarios that fall through the cracks that we should mention in documentation?&lt;/p&gt;</comment>
                            <comment id="14087868" author="remkop@yahoo.com" created="Wed, 6 Aug 2014 16:29:58 +0000"  >&lt;p&gt;I&apos;ve taken the simple approach of calling &lt;tt&gt;getFormattedMessage&lt;/tt&gt; in the constructor to cache the formatted message string. For most message implementation classes this is sufficient.&lt;/p&gt;

&lt;p&gt;For ObjectMessage I added a String field to capture the value of &lt;tt&gt;obj.toString()&lt;/tt&gt; at message construction time.&lt;/p&gt;

&lt;p&gt;MapMessage and StructuredDataMessage are mutable by design. The simplest thing to do here is to document that they should not be modified after they have been logged.&lt;/p&gt;

&lt;p&gt;Please see attached patch.&lt;br/&gt;
If there are no objections to this approach I will commit this (still need to do unit tests and site changes to mention users should take care with MapMessage and StructuredDataMessage with async logging.)&lt;/p&gt;</comment>
                            <comment id="14092035" author="remkop@yahoo.com" created="Sun, 10 Aug 2014 06:42:33 +0000"  >&lt;p&gt;Improved FormattedMessage, StringFormattedMessage, LocalizedMessage, MessageFormatMessage and ObjectMessage for asynchronous logging to ensure the formatted message does not change even if parameters are modified by the application. Added JUnit tests.&lt;/p&gt;

&lt;p&gt;ParameterizedMessage and ThreadDumpMessage were already safe.&lt;/p&gt;

&lt;p&gt;Improved docs for MapMessage and StructuredDataMessage: these are mutable by design and users should take care when logging these messages asynchronously. Improved site docs.&lt;/p&gt;

&lt;p&gt;Fixed in revision 1617051. Please verify and close.&lt;/p&gt;</comment>
                            <comment id="14092349" author="remkop@yahoo.com" created="Mon, 11 Aug 2014 02:16:17 +0000"  >&lt;p&gt;Re-opening: the current implementation solves the problem but may have some performance impact. It is better to avoid creating the formatted string in the constructor because messages may be filtered out (e.g. because their log level is too low) and this formatted message string may end up not being used.&lt;/p&gt;

&lt;p&gt;A better solution is to revert to lazy initialization and have async components call the &lt;tt&gt;Message.getFormattedMessage()&lt;/tt&gt; method before passing the log event to another thread.&lt;/p&gt;

&lt;p&gt;In addition to reverting,  &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ObjectMessage should cache its formatted message string and initialize this cached string in &lt;tt&gt;getFormattedMessage&lt;/tt&gt;.&lt;/li&gt;
	&lt;li&gt;ParameterizedMessage should not take string snapshots in its constructor but should delay that work until the &lt;tt&gt;getFormattedMessage&lt;/tt&gt; method is called. - I created &lt;a href=&quot;https://issues.apache.org/jira/browse/LOG4J2-772&quot; title=&quot;Performance enhancement: ParameterizedMessage should not take String snapshots of its parameters in constructor&quot; class=&quot;issue-link&quot; data-issue-key=&quot;LOG4J2-772&quot;&gt;&lt;del&gt;LOG4J2-772&lt;/del&gt;&lt;/a&gt; for this as I may not have time for this refactoring at the moment and it is not as urgent.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14092804" author="remkop@yahoo.com" created="Mon, 11 Aug 2014 14:17:42 +0000"  >&lt;p&gt;Use the mechanism described in the comment above to solve the issue. Committed in revision 1617291. Please verify and close.&lt;/p&gt;</comment>
                            <comment id="14093546" author="remkop@yahoo.com" created="Tue, 12 Aug 2014 00:24:41 +0000"  >&lt;p&gt;Added below serialization JUnit tests in revision 1617465.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;// add to ObjectMessageTest
&lt;/span&gt;    @Test
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testSerializeWithSerializableParam() {
        BigDecimal big = BigDecimal.valueOf(123.456);
        ObjectMessage msg = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ObjectMessage(big);
        ObjectMessage other = SerialUtil.deserialize(SerialUtil.serialize(msg));
        assertEquals(msg, other);
    }
    
    
    @Test
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testDeserializeNonSerializableParamNotEqualIfToStringDiffers() {
        ObjectMessageTest nonSerializable = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ObjectMessageTest();
        assertFalse(nonSerializable &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; Serializable);
        ObjectMessage msg = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ObjectMessage(nonSerializable);
        ObjectMessage other = SerialUtil.deserialize(SerialUtil.serialize(msg));
        assertNotEquals(&lt;span class=&quot;code-quote&quot;&gt;&quot;Expected different: toString is different&quot;&lt;/span&gt;, msg, other);
    }
    
    @Test
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testDeserializeNonSerializableParamEqualIfToStringSame() {
        &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;NonSerializable {
            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; other) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; other &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; NonSerializable; &lt;span class=&quot;code-comment&quot;&gt;// a very lenient equals()
&lt;/span&gt;            }
        }
        NonSerializable nonSerializable = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NonSerializable();
        assertFalse(nonSerializable &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; Serializable);
        ObjectMessage msg = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ObjectMessage(nonSerializable);
        ObjectMessage other = SerialUtil.deserialize(SerialUtil.serialize(msg));

&lt;span class=&quot;code-comment&quot;&gt;// TODO &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; fails: msg.obj.equals(other.obj) is &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;...
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// TODO our equals() implementation does not match the serialization mechanism
&lt;/span&gt;        assertEquals(msg, other);
    }

&lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; helper class (src/test/java/org.apache.log4j.util?)
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;SerialUtil {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] serialize(Serializable obj) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            ByteArrayOutputStream bas = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream(8192);
            ObjectOutputStream oos = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ObjectOutputStream(bas);
            oos.writeObject(obj);
            oos.flush();
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; bas.toByteArray();
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) {
            &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Could not serialize&quot;&lt;/span&gt;, ex);
        }
    }
    
    @SuppressWarnings(&lt;span class=&quot;code-quote&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T deserialize(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] data) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            ByteArrayInputStream bas = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ByteArrayInputStream(data);
            ObjectInputStream ois = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ObjectInputStream(bas);
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (T) ois.readObject();
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) {
            &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Could not deserialize&quot;&lt;/span&gt;, ex);
        }
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14094122" author="remkop@yahoo.com" created="Tue, 12 Aug 2014 14:54:03 +0000"  >&lt;p&gt;Fixed ObjectMessage.equals() and JUnit test in revision 1617497.&lt;/p&gt;</comment>
                            <comment id="14207133" author="sgrssmn" created="Tue, 11 Nov 2014 21:42:02 +0000"  >&lt;p&gt;I appreciate the simplicity introduced by this patch, but it comes with a significant limitation of utility.  Formatting a message can be an expensive operation (e.g. String.format) and it is undesirable for this to be done in the calling thread when using an async logger.&lt;/p&gt;

&lt;p&gt;Would you consider bringing back the previous behavior via a config/system property?  &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13021996">LOG4J2-1718</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12756008">LOG4J2-898</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12733239">LOG4J2-772</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12660169" name="LOG4J2-763.patch" size="7647" author="rpopma" created="Wed, 6 Aug 2014 16:29:58 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>409666</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 2 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1yhhj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>409661</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>