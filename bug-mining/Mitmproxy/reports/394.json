{"url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/4701","repository_url":"https://api.github.com/repos/mitmproxy/mitmproxy","labels_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/4701/labels{/name}","comments_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/4701/comments","events_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/4701/events","html_url":"https://github.com/mitmproxy/mitmproxy/issues/4701","id":951802271,"node_id":"MDU6SXNzdWU5NTE4MDIyNzE=","number":4701,"title":"Unfragmented WebSocket messages getting fragmented","user":{"login":"Pilphe","id":49091240,"node_id":"MDQ6VXNlcjQ5MDkxMjQw","avatar_url":"https://avatars.githubusercontent.com/u/49091240?v=4","gravatar_id":"","url":"https://api.github.com/users/Pilphe","html_url":"https://github.com/Pilphe","followers_url":"https://api.github.com/users/Pilphe/followers","following_url":"https://api.github.com/users/Pilphe/following{/other_user}","gists_url":"https://api.github.com/users/Pilphe/gists{/gist_id}","starred_url":"https://api.github.com/users/Pilphe/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Pilphe/subscriptions","organizations_url":"https://api.github.com/users/Pilphe/orgs","repos_url":"https://api.github.com/users/Pilphe/repos","events_url":"https://api.github.com/users/Pilphe/events{/privacy}","received_events_url":"https://api.github.com/users/Pilphe/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":466930397,"node_id":"MDU6TGFiZWw0NjY5MzAzOTc=","url":"https://api.github.com/repos/mitmproxy/mitmproxy/labels/kind/triage","name":"kind/triage","color":"006b75","default":false,"description":"Unclassified issues"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2021-07-23T18:18:00Z","updated_at":"2021-08-02T12:23:58Z","closed_at":"2021-08-02T12:23:58Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"https://github.com/mitmproxy/mitmproxy/blob/e270399a3eba7b3212bf7325beaa50e159a7ca0a/mitmproxy/proxy/layers/websocket.py#L153-L175\r\n\r\nWhile handling WebSocket events, mitmproxy doesn't distinguish between `message_finished` and `frame_finished` ([Message class](https://python-hyper.org/projects/wsproto/en/stable/api.html#wsproto.events.Message)) which in my case led to continuation frames being sent while there were none in the initial WebSocket message.\r\n\r\nThis is because the wsproto API doesn't always emit complete frames (I guess this is caused by the TCP fragmentation?), they could be chunked while the original WebSocket message has no fragmentation and I think even WebSocket messages using fragmentation with large continuation frames could be emitted as chunks themselves?\r\n\r\nTo avoid this behavior each `frame_buf` entry must be a complete frame, here is my fix suggestion:\r\n\r\n```python\r\n        for ws_event in src_ws.events():\r\n            if isinstance(ws_event, wsproto.events.Message):\r\n                is_text = isinstance(ws_event.data, str)\r\n\r\n                # Add the data variable to avoid multiple conditions\r\n                if is_text:\r\n                    typ = Opcode.TEXT\r\n                    data = ws_event.data.encode()\r\n                else:\r\n                    typ = Opcode.BINARY\r\n                    data = ws_event.data\r\n\r\n                # Make each frame one entry to frame_buf, append if empty to avoid IndexError\r\n                if src_ws.frame_buf:\r\n                    src_ws.frame_buf[-1] += data\r\n                else:\r\n                    src_ws.frame_buf.append(data)\r\n\r\n                if ws_event.message_finished:\r\n                    content = b\"\".join(src_ws.frame_buf)\r\n\r\n                    fragmentizer = Fragmentizer(src_ws.frame_buf, is_text)\r\n                    src_ws.frame_buf.clear()\r\n\r\n                    message = websocket.WebSocketMessage(typ, from_client, content)\r\n                    self.flow.websocket.messages.append(message)\r\n                    yield WebsocketMessageHook(self.flow)\r\n\r\n                    if not message.dropped:\r\n                        for msg in fragmentizer(message.content):\r\n                            yield dst_ws.send2(msg)\r\n\r\n                # Initialize next frame entry\r\n                elif ws_event.frame_finished:\r\n                    src_ws.frame_buf.append(b\"\")\r\n```\r\n\r\nIt works for me but I didn't test it with in an environment using WebSocket continuation frames. Also this only works for unmodified WebSocket messages, injected or modified messages are still concerned by the issue because the `Fragmentizer` class compares the lengths so they will always fall into the else condition (unless you made the modified message keep its original length):\r\n\r\nhttps://github.com/mitmproxy/mitmproxy/blob/e270399a3eba7b3212bf7325beaa50e159a7ca0a/mitmproxy/proxy/layers/websocket.py#L229-L243\r\n\r\nFor my use case I didn't make a proper fix for this, I just made the first condition always true, maybe a boolean variable can be added to the `WebSocketMessage` and `Fragmentizer` classes or something like that?","closed_by":{"login":"mhils","id":1019198,"node_id":"MDQ6VXNlcjEwMTkxOTg=","avatar_url":"https://avatars.githubusercontent.com/u/1019198?v=4","gravatar_id":"","url":"https://api.github.com/users/mhils","html_url":"https://github.com/mhils","followers_url":"https://api.github.com/users/mhils/followers","following_url":"https://api.github.com/users/mhils/following{/other_user}","gists_url":"https://api.github.com/users/mhils/gists{/gist_id}","starred_url":"https://api.github.com/users/mhils/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mhils/subscriptions","organizations_url":"https://api.github.com/users/mhils/orgs","repos_url":"https://api.github.com/users/mhils/repos","events_url":"https://api.github.com/users/mhils/events{/privacy}","received_events_url":"https://api.github.com/users/mhils/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/4701/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/4701/timeline","performed_via_github_app":null,"state_reason":"completed"}