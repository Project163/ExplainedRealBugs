{"url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/7614","repository_url":"https://api.github.com/repos/mitmproxy/mitmproxy","labels_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/7614/labels{/name}","comments_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/7614/comments","events_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/7614/events","html_url":"https://github.com/mitmproxy/mitmproxy/issues/7614","id":2937791853,"node_id":"I_kwDOAAfumM6vGyVt","number":7614,"title":"Intermittent CI failures for UDP tests on Windows","user":{"login":"mhils","id":1019198,"node_id":"MDQ6VXNlcjEwMTkxOTg=","avatar_url":"https://avatars.githubusercontent.com/u/1019198?v=4","gravatar_id":"","url":"https://api.github.com/users/mhils","html_url":"https://github.com/mhils","followers_url":"https://api.github.com/users/mhils/followers","following_url":"https://api.github.com/users/mhils/following{/other_user}","gists_url":"https://api.github.com/users/mhils/gists{/gist_id}","starred_url":"https://api.github.com/users/mhils/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mhils/subscriptions","organizations_url":"https://api.github.com/users/mhils/orgs","repos_url":"https://api.github.com/users/mhils/repos","events_url":"https://api.github.com/users/mhils/events{/privacy}","received_events_url":"https://api.github.com/users/mhils/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":79336502,"node_id":"MDU6TGFiZWw3OTMzNjUwMg==","url":"https://api.github.com/repos/mitmproxy/mitmproxy/labels/kind/bug","name":"kind/bug","color":"d93f0b","default":false,"description":null},{"id":329157533,"node_id":"MDU6TGFiZWwzMjkxNTc1MzM=","url":"https://api.github.com/repos/mitmproxy/mitmproxy/labels/os/windows","name":"os/windows","color":"eeeeee","default":false,"description":null},{"id":429900935,"node_id":"MDU6TGFiZWw0Mjk5MDA5MzU=","url":"https://api.github.com/repos/mitmproxy/mitmproxy/labels/area/infra","name":"area/infra","color":"fef2c0","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2025-03-21T09:21:25Z","updated_at":"2025-03-28T20:24:05Z","closed_at":"2025-03-28T20:24:05Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Problem Description\n\nThis is flaky, and I'm not sure why it is happening at all:\n\nhttps://github.com/mitmproxy/mitmproxy/actions/runs/13987584687/job/39164146184\n\n```\n================================== FAILURES ===================================\n_____________________________ test_udp_start_stop _____________________________\n\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD46B944D0>\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:264: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD3EDB5F90>\nhost = '127.0.0.1', port = 55100\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-1222803291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n                ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\n                servers.append(ipv4)\n                try:\n                    ipv6 = await mitmproxy_rs.udp.start_udp_server(\n                        \"[::]\",\n                        ipv4.getsockname()[1],\n                        self.handle_stream,\n                    )\n                    servers.append(ipv6)  # pragma: no cover\n                except Exception:  # pragma: no cover\n                    logger.debug(\"Failed to listen on '::', listening on IPv4 only.\")\n            else:\n                servers.append(\n>                   await mitmproxy_rs.udp.start_udp_server(\n                        host,\n                        port,\n                        self.handle_stream,\n                    )\n                )\nE               RuntimeError: Failed to bind UDP socket to 127.0.0.1:55100\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:326: RuntimeError\n---------------------------- Captured log teardown ----------------------------\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\n___________________________ test_dual_stack[tcp-v4] ___________________________\n\nip_version = 'v4', protocol = 'tcp'\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD4AFA0550>\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:316: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD3E398050>\nhost = '', port = 55105\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-1222803291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n>               ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\nE               RuntimeError: Failed to bind UDP socket to 0.0.0.0:55105\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:309: RuntimeError\n---------------------------- Captured log teardown ----------------------------\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\n___________________________ test_dual_stack[tcp-v6] ___________________________\n\nip_version = 'v6', protocol = 'tcp'\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD3FF025D0>\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:316: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD4013EC40>\nhost = '', port = 55108\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-1222803291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n>               ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\nE               RuntimeError: Failed to bind UDP socket to 0.0.0.0:55108\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:309: RuntimeError\n---------------------------- Captured log teardown ----------------------------\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\n___________________________ test_dual_stack[udp-v4] ___________________________\n\nip_version = 'v4', protocol = 'udp'\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD3E6D50F0>\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:316: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD4013D350>\nhost = '', port = 55111\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-1222803291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n>               ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\nE               RuntimeError: Failed to bind UDP socket to 0.0.0.0:55111\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:309: RuntimeError\n---------------------------- Captured log teardown ----------------------------\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\n___________________________ test_dual_stack[udp-v6] ___________________________\n\nip_version = 'v6', protocol = 'udp'\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD3E6D5E80>\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:316: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD3E1B1C70>\nhost = '', port = 55114\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-1222803291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n>               ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\nE               RuntimeError: Failed to bind UDP socket to 0.0.0.0:55114\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:309: RuntimeError\n---------------------------- Captured log teardown ----------------------------\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\n__________________________ test_dns_start_stop[udp] ___________________________\n\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD4AF81CD0>\ntransport_protocol = 'udp'\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD3E343790>\nhost = '127.0.0.1', port = 55117\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-1[2228](https://github.com/mitmproxy/mitmproxy/actions/runs/13987584687/job/39164146184#step:5:2229)03291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n                ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\n                servers.append(ipv4)\n                try:\n                    ipv6 = await mitmproxy_rs.udp.start_udp_server(\n                        \"[::]\",\n                        ipv4.getsockname()[1],\n                        self.handle_stream,\n                    )\n                    servers.append(ipv6)  # pragma: no cover\n                except Exception:  # pragma: no cover\n                    logger.debug(\"Failed to listen on '::', listening on IPv4 only.\")\n            else:\n                servers.append(\n>                   await mitmproxy_rs.udp.start_udp_server(\n                        host,\n                        port,\n                        self.handle_stream,\n                    )\n                )\nE               RuntimeError: Failed to bind UDP socket to 127.0.0.1:55117\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:326: RuntimeError\n---------------------------- Captured log teardown ----------------------------\nERROR    asyncio:base_events.py:1871 Task was destroyed but it is pending!\ntask: <Task pending name='None' coro=<IocpProactor.accept.<locals>.accept_coro() running at C:\\hostedtoolcache\\windows\\Python\\3.13.2\\x64\\Lib\\asyncio\\windows_events.py:567> wait_for=<_OverlappedFuture cancelled>>\n__________________________ test_dns_start_stop[tcp] ___________________________\n\ncaplog_async = <test.conftest.AsyncLogCaptureFixture object at 0x000002DD4AF802F0>\ntransport_protocol = 'tcp'\n\n>   ???\n\ntest\\mitmproxy\\proxy\\test_mode_servers.py:341: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nmitmproxy\\proxy\\mode_servers.py:130: in start\n    await self._start()\nmitmproxy\\proxy\\mode_servers.py:251: in _start\n    self._servers = await self.listen(host, port)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <mitmproxy.proxy.mode_servers.DnsInstance object at 0x000002DD3E341BF0>\nhost = '127.0.0.1', port = 55120\n\n    async def listen(\n        self, host: str, port: int\n    ) -> list[asyncio.Server | mitmproxy_rs.udp.UdpServer]:\n        if self.mode.transport_protocol not in (\"tcp\", \"udp\", \"both\"):\n            raise AssertionError(self.mode.transport_protocol)\n    \n        servers: list[asyncio.Server | mitmproxy_rs.udp.UdpServer] = []\n        if self.mode.transport_protocol in (\"tcp\", \"both\"):\n            # workaround for https://github.com/python/cpython/issues/89856:\n            # We want both IPv4 and IPv6 sockets to bind to the same port.\n            # This may fail (https://github.com/mitmproxy/mitmproxy/pull/5542#issuecomment-12[2280](https://github.com/mitmproxy/mitmproxy/actions/runs/13987584687/job/39164146184#step:5:2281)3291),\n            # so we try to cover the 99% case and then give up and fall back to what asyncio does.\n            if port == 0:\n                try:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    s.bind((\"\", 0))\n                    port = s.getsockname()[1]\n                    s.close()\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n                except Exception as e:\n                    logger.debug(\n                        f\"Failed to listen on a single port ({e!r}), falling back to default behavior.\"\n                    )\n                    port = 0\n                    servers.append(\n                        await asyncio.start_server(self.handle_stream, host, port)\n                    )\n            else:\n                servers.append(\n                    await asyncio.start_server(self.handle_stream, host, port)\n                )\n        if self.mode.transport_protocol in (\"udp\", \"both\"):\n            # we start two servers for dual-stack support.\n            # On Linux, this would also be achievable by toggling IPV6_V6ONLY off, but this here works cross-platform.\n            if host == \"\":\n                ipv4 = await mitmproxy_rs.udp.start_udp_server(\n                    \"0.0.0.0\",\n                    port,\n                    self.handle_stream,\n                )\n                servers.append(ipv4)\n                try:\n                    ipv6 = await mitmproxy_rs.udp.start_udp_server(\n                        \"[::]\",\n                        ipv4.getsockname()[1],\n                        self.handle_stream,\n                    )\n                    servers.append(ipv6)  # pragma: no cover\n                except Exception:  # pragma: no cover\n                    logger.debug(\"Failed to listen on '::', listening on IPv4 only.\")\n            else:\n                servers.append(\n>                   await mitmproxy_rs.udp.start_udp_server(\n                        host,\n                        port,\n                        self.handle_stream,\n                    )\n                )\nE               RuntimeError: Failed to bind UDP socket to 127.0.0.1:55120\nE               \nE               Caused by:\nE                   An attempt was made to access a socket in a way forbidden by its access permissions. (os error 10013)\n\nmitmproxy\\proxy\\mode_servers.py:326: RuntimeError\n```\n\n### System Information\n\n```raw\n\n```\n\n### Checklist\n\n- [x] This bug affects the [latest mitmproxy release](https://github.com/mitmproxy/mitmproxy/releases).","closed_by":{"login":"mhils","id":1019198,"node_id":"MDQ6VXNlcjEwMTkxOTg=","avatar_url":"https://avatars.githubusercontent.com/u/1019198?v=4","gravatar_id":"","url":"https://api.github.com/users/mhils","html_url":"https://github.com/mhils","followers_url":"https://api.github.com/users/mhils/followers","following_url":"https://api.github.com/users/mhils/following{/other_user}","gists_url":"https://api.github.com/users/mhils/gists{/gist_id}","starred_url":"https://api.github.com/users/mhils/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mhils/subscriptions","organizations_url":"https://api.github.com/users/mhils/orgs","repos_url":"https://api.github.com/users/mhils/repos","events_url":"https://api.github.com/users/mhils/events{/privacy}","received_events_url":"https://api.github.com/users/mhils/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/7614/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/mitmproxy/mitmproxy/issues/7614/timeline","performed_via_github_app":null,"state_reason":"completed"}