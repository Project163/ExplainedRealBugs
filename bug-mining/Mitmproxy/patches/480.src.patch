diff --git a/CHANGELOG.md b/CHANGELOG.md
index b3149d880..c64c8cca9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -17,6 +17,8 @@
   ([#6732](https://github.com/mitmproxy/mitmproxy/pull/6732), @jaywor1)
 * Update aioquic dependency to >= 1.0.0, < 2.0.0.
   ([#6747](https://github.com/mitmproxy/mitmproxy/pull/6747), @jlaine)
+* Fix a bug where async `client_connected` handlers would crash mitmproxy.
+  ([#6749](https://github.com/mitmproxy/mitmproxy/pull/6749), @mhils)
 
 ## 07 March 2024: mitmproxy 10.2.4
 
diff --git a/mitmproxy/proxy/server.py b/mitmproxy/proxy/server.py
index debdb35ad..ebe23ed55 100644
--- a/mitmproxy/proxy/server.py
+++ b/mitmproxy/proxy/server.py
@@ -144,13 +144,13 @@ class ConnectionHandler(metaclass=abc.ABCMeta):
             assert writer
             writer.close()
         else:
+            self.server_event(events.Start())
             handler = asyncio_utils.create_task(
                 self.handle_connection(self.client),
                 name=f"client connection handler",
                 client=self.client.peername,
             )
             self.transports[self.client].handler = handler
-            self.server_event(events.Start())
             await asyncio.wait([handler])
             if not handler.cancelled() and (e := handler.exception()):
                 self.log(
@@ -249,20 +249,14 @@ class ConnectionHandler(metaclass=abc.ABCMeta):
                 await self.handle_hook(server_hooks.ServerConnectedHook(hook_data))
                 self.server_event(events.OpenConnectionCompleted(command, None))
 
-                # during connection opening, this function is the designated handler that can be cancelled.
-                # once we have a connection, we do want the teardown here to happen in any case, so we
-                # reassign the handler to .handle_connection and then clean up here once that is done.
-                new_handler = asyncio_utils.create_task(
-                    self.handle_connection(command.connection),
-                    name=f"server connection handler for {addr}",
-                    client=self.client.peername,
-                )
-                self.transports[command.connection].handler = new_handler
-                await asyncio.wait([new_handler])
-
-                self.log(f"server disconnect {addr}")
-                command.connection.timestamp_end = time.time()
-                await self.handle_hook(server_hooks.ServerDisconnectedHook(hook_data))
+                try:
+                    await self.handle_connection(command.connection)
+                finally:
+                    self.log(f"server disconnect {addr}")
+                    command.connection.timestamp_end = time.time()
+                    await self.handle_hook(
+                        server_hooks.ServerDisconnectedHook(hook_data)
+                    )
 
     async def wakeup(self, request: commands.RequestWakeup) -> None:
         await asyncio.sleep(request.delay)
@@ -383,7 +377,7 @@ class ConnectionHandler(metaclass=abc.ABCMeta):
                     assert command.connection not in self.transports
                     handler = asyncio_utils.create_task(
                         self.open_connection(command),
-                        name=f"server connection manager {command.connection.address}",
+                        name=f"server connection handler {command.connection.address}",
                         client=self.client.peername,
                     )
                     self.transports[command.connection] = ConnectionIO(handler=handler)
