diff --git a/examples/addons/websocket-inject-message.py b/examples/addons/websocket-inject-message.py
index 5916edc1a..722cab691 100644
--- a/examples/addons/websocket-inject-message.py
+++ b/examples/addons/websocket-inject-message.py
@@ -34,5 +34,12 @@ async def inject_async(flow: http.HTTPFlow):
         msg = msg[1:] + msg[:1]
 
 
+# Python 3.11: replace with TaskGroup
+tasks = set()
+
+
 def websocket_start(flow: http.HTTPFlow):
-    asyncio.create_task(inject_async(flow))
+    # we need to hold a reference to the task, otherwise it will be garbage collected.
+    t = asyncio.create_task(inject_async(flow))
+    tasks.add(t)
+    t.add_done_callback(tasks.remove)
diff --git a/mitmproxy/addons/clientplayback.py b/mitmproxy/addons/clientplayback.py
index 7abb83622..e6d7a8524 100644
--- a/mitmproxy/addons/clientplayback.py
+++ b/mitmproxy/addons/clientplayback.py
@@ -1,3 +1,5 @@
+from __future__ import annotations
+
 import asyncio
 import logging
 import time
@@ -136,11 +138,13 @@ class ClientPlayback:
     inflight: Optional[http.HTTPFlow]
     queue: asyncio.Queue
     options: Options
+    replay_tasks: set[asyncio.Task]
 
     def __init__(self):
         self.queue = asyncio.Queue()
         self.inflight = None
         self.task = None
+        self.replay_tasks = set()
 
     def running(self):
         self.playback_task = asyncio_utils.create_task(
@@ -159,9 +163,12 @@ class ClientPlayback:
                 assert self.inflight
                 h = ReplayHandler(self.inflight, self.options)
                 if ctx.options.client_replay_concurrency == -1:
-                    asyncio_utils.create_task(
+                    t = asyncio_utils.create_task(
                         h.replay(), name="client playback awaiting response"
                     )
+                    # keep a reference so this is not garbage collected
+                    self.replay_tasks.add(t)
+                    t.add_done_callback(self.replay_tasks.remove)
                 else:
                     await h.replay()
             except Exception:
diff --git a/mitmproxy/addons/keepserving.py b/mitmproxy/addons/keepserving.py
index 199cf2548..efe296ab3 100644
--- a/mitmproxy/addons/keepserving.py
+++ b/mitmproxy/addons/keepserving.py
@@ -1,9 +1,13 @@
+from __future__ import annotations
+
 import asyncio
 
 from mitmproxy import ctx
 
 
 class KeepServing:
+    _watch_task: asyncio.Task | None = None
+
     def load(self, loader):
         loader.add_option(
             "keepserving",
@@ -40,4 +44,4 @@ class KeepServing:
             ctx.options.rfile,
         ]
         if any(opts) and not ctx.options.keepserving:
-            asyncio.get_running_loop().create_task(self.watch())
+            self._watch_task = asyncio.get_running_loop().create_task(self.watch())
diff --git a/mitmproxy/addons/proxyserver.py b/mitmproxy/addons/proxyserver.py
index cb17bcfbf..10b6c7cc2 100644
--- a/mitmproxy/addons/proxyserver.py
+++ b/mitmproxy/addons/proxyserver.py
@@ -113,6 +113,7 @@ class Proxyserver(ServerManager):
 
     is_running: bool
     _connect_addr: Optional[Address] = None
+    _update_task: Optional[asyncio.Task] = None
 
     def __init__(self):
         self.connections = {}
@@ -274,7 +275,7 @@ class Proxyserver(ServerManager):
                     )
 
             if self.is_running:
-                asyncio.create_task(self.servers.update(modes))
+                self._update_task = asyncio.create_task(self.servers.update(modes))
 
     async def setup_servers(self) -> bool:
         return await self.servers.update(
diff --git a/mitmproxy/addons/readfile.py b/mitmproxy/addons/readfile.py
index e9f0a5cbf..63f7b1dbd 100644
--- a/mitmproxy/addons/readfile.py
+++ b/mitmproxy/addons/readfile.py
@@ -19,7 +19,7 @@ class ReadFile:
 
     def __init__(self):
         self.filter = None
-        self.is_reading = False
+        self._read_task: asyncio.Task | None = None
 
     def load(self, loader):
         loader.add_option("rfile", Optional[str], None, "Read flows from file.")
@@ -64,22 +64,21 @@ class ReadFile:
             logging.error(f"Cannot load flows: {e}")
             raise exceptions.FlowReadException(str(e)) from e
 
-    async def doread(self, rfile):
-        self.is_reading = True
+    async def doread(self, rfile: str) -> None:
         try:
-            await self.load_flows_from_path(ctx.options.rfile)
+            await self.load_flows_from_path(rfile)
         except exceptions.FlowReadException as e:
             raise exceptions.OptionsError(e) from e
         finally:
-            self.is_reading = False
+            self._read_task = None
 
     def running(self):
         if ctx.options.rfile:
-            asyncio.get_running_loop().create_task(self.doread(ctx.options.rfile))
+            self._read_task = asyncio.create_task(self.doread(ctx.options.rfile))
 
     @command.command("readfile.reading")
     def reading(self) -> bool:
-        return self.is_reading
+        return bool(self._read_task)
 
 
 class ReadFileStdin(ReadFile):
diff --git a/mitmproxy/addons/termlog.py b/mitmproxy/addons/termlog.py
index 9da47e141..f6d003864 100644
--- a/mitmproxy/addons/termlog.py
+++ b/mitmproxy/addons/termlog.py
@@ -11,6 +11,8 @@ from mitmproxy.utils import vt_codes
 
 
 class TermLog:
+    _teardown_task: asyncio.Task | None = None
+
     def __init__(self, out: IO[str] | None = None):
         self.logger = TermLogHandler(out)
         self.logger.install()
@@ -29,7 +31,7 @@ class TermLog:
         t = self._teardown()
         try:
             # try to delay teardown a bit.
-            asyncio.create_task(t)
+            self._teardown_task = asyncio.create_task(t)
         except RuntimeError:
             # no event loop, we're in a test.
             asyncio.run(t)
diff --git a/mitmproxy/proxy/mode_servers.py b/mitmproxy/proxy/mode_servers.py
index 0d64157ae..405348e6b 100644
--- a/mitmproxy/proxy/mode_servers.py
+++ b/mitmproxy/proxy/mode_servers.py
@@ -233,7 +233,9 @@ class ServerInstance(Generic[M], metaclass=ABCMeta):
 
             # pre-register here - we may get datagrams before the task is executed.
             self.manager.connections[connection_id] = handler
-            asyncio.create_task(self.handle_udp_connection(connection_id, handler))
+            t = asyncio.create_task(self.handle_udp_connection(connection_id, handler))
+            # assign it somewhere so that it does not get garbage-collected.
+            handler._handle_udp_task = t  # type: ignore
         else:
             handler = self.manager.connections[connection_id]
             reader = cast(udp.DatagramReader, handler.transports[handler.client].reader)
diff --git a/mitmproxy/proxy/server.py b/mitmproxy/proxy/server.py
index eeec51d5f..7094ce31a 100644
--- a/mitmproxy/proxy/server.py
+++ b/mitmproxy/proxy/server.py
@@ -107,12 +107,14 @@ class ConnectionHandler(metaclass=abc.ABCMeta):
     max_conns: collections.defaultdict[Address, asyncio.Semaphore]
     layer: "layer.Layer"
     wakeup_timer: set[asyncio.Task]
+    hook_tasks: set[asyncio.Task]
 
     def __init__(self, context: Context) -> None:
         self.client = context.client
         self.transports = {}
         self.max_conns = collections.defaultdict(lambda: asyncio.Semaphore(5))
         self.wakeup_timer = set()
+        self.hook_tasks = set()
 
         # Ask for the first layer right away.
         # In a reverse proxy scenario, this is necessary as we would otherwise hang
@@ -388,11 +390,14 @@ class ConnectionHandler(metaclass=abc.ABCMeta):
                 elif isinstance(command, commands.CloseConnection):
                     self.close_connection(command.connection, False)
                 elif isinstance(command, commands.StartHook):
-                    asyncio_utils.create_task(
+                    t = asyncio_utils.create_task(
                         self.hook_task(command),
                         name=f"handle_hook({command.name})",
                         client=self.client.peername,
                     )
+                    # Python 3.11 Use TaskGroup instead.
+                    self.hook_tasks.add(t)
+                    t.add_done_callback(self.hook_tasks.remove)
                 elif isinstance(command, commands.Log):
                     self.log(command.message, command.level)
                 else:
diff --git a/mitmproxy/tools/web/app.py b/mitmproxy/tools/web/app.py
index 334661cc1..7eb71f72f 100644
--- a/mitmproxy/tools/web/app.py
+++ b/mitmproxy/tools/web/app.py
@@ -284,6 +284,7 @@ class FilterHelp(RequestHandler):
 class WebSocketEventBroadcaster(tornado.websocket.WebSocketHandler):
     # raise an error if inherited class doesn't specify its own instance.
     connections: ClassVar[set[WebSocketEventBroadcaster]]
+    _send_tasks: ClassVar[set[asyncio.Task]] = set()
 
     def open(self):
         self.connections.add(self)
@@ -299,7 +300,9 @@ class WebSocketEventBroadcaster(tornado.websocket.WebSocketHandler):
             except tornado.websocket.WebSocketClosedError:
                 cls.connections.discard(conn)
 
-        asyncio.ensure_future(wrapper())
+        t = asyncio.create_task(wrapper())
+        cls._send_tasks.add(t)
+        t.add_done_callback(cls._send_tasks.remove)
 
     @classmethod
     def broadcast(cls, **kwargs):
@@ -345,11 +348,11 @@ class DumpFlows(RequestHandler):
                     fw.add(f)
             self.write(bio.getvalue())
 
-    def post(self):
+    async def post(self):
         self.view.clear()
         bio = BytesIO(self.filecontents)
-        for i in io.FlowReader(bio).stream():
-            asyncio.ensure_future(self.master.load_flow(i))
+        for f in io.FlowReader(bio).stream():
+            await self.master.load_flow(f)
         bio.close()
 
 
diff --git a/test/bench/benchmark.py b/test/bench/benchmark.py
index 289df5c16..b0d690274 100644
--- a/test/bench/benchmark.py
+++ b/test/bench/benchmark.py
@@ -56,7 +56,7 @@ class Benchmark:
     def running(self):
         if not self.started:
             self.started = True
-            asyncio.get_running_loop().create_task(self.procs())
+            self._task = asyncio.create_task(self.procs())
 
     def done(self):
         self.pr.dump_stats(ctx.options.benchmark_save_path + ".prof")
diff --git a/test/conftest.py b/test/conftest.py
index 77be0686b..63d216411 100644
--- a/test/conftest.py
+++ b/test/conftest.py
@@ -47,7 +47,7 @@ class AsyncLogCaptureFixture:
                 return True
             else:
                 await asyncio.sleep(0.01)
-        raise AssertionError(f"Did not find {text!r} in log:\n{self.caplog.text}.")
+        raise AssertionError(f"Did not find {text!r} in log:\n{self.caplog.text}")
 
     def clear(self) -> None:
         self.caplog.clear()
diff --git a/test/mitmproxy/test_master.py b/test/mitmproxy/test_master.py
index df0d2c85a..df7cea836 100644
--- a/test/mitmproxy/test_master.py
+++ b/test/mitmproxy/test_master.py
@@ -7,11 +7,17 @@ async def err():
     raise RuntimeError
 
 
-async def test_exception_handler(caplog):
+class TaskError:
+    def running(self):
+        # not assigned to anything
+        asyncio.create_task(err())
+
+
+async def test_exception_handler(caplog_async):
+    caplog_async.set_level("ERROR")
     m = Master(None)
+    m.addons.add(TaskError())
     running = asyncio.create_task(m.run())
-    asyncio.create_task(err())
-    await asyncio.sleep(0)
-    assert "Traceback" in caplog.text
+    await caplog_async.await_log("Traceback")
     m.shutdown()
     await running
