diff --git a/docs/scripts/api-events.py b/docs/scripts/api-events.py
index f365d8392..7802f603f 100644
--- a/docs/scripts/api-events.py
+++ b/docs/scripts/api-events.py
@@ -122,7 +122,8 @@ with outfile.open("w") as f, contextlib.redirect_stdout(f):
         "",
         [
             tls.TlsClienthelloHook,
-            tls.TlsStartHook,
+            tls.TlsStartClientHook,
+            tls.TlsStartServerHook,
         ]
     )
 
diff --git a/mitmproxy/addons/tlsconfig.py b/mitmproxy/addons/tlsconfig.py
index 0fca4756f..260be64d1 100644
--- a/mitmproxy/addons/tlsconfig.py
+++ b/mitmproxy/addons/tlsconfig.py
@@ -118,11 +118,11 @@ class TlsConfig:
                 )
         )
 
-    def tls_start(self, tls_start: tls.TlsStartData):
-        if tls_start.conn == tls_start.context.client:
-            self.create_client_proxy_ssl_conn(tls_start)
-        else:
-            self.create_proxy_server_ssl_conn(tls_start)
+    def tls_start_client(self, tls_start: tls.TlsStartData):
+        self.create_client_proxy_ssl_conn(tls_start)
+
+    def tls_start_server(self, tls_start: tls.TlsStartData):
+        self.create_proxy_server_ssl_conn(tls_start)
 
     def create_client_proxy_ssl_conn(self, tls_start: tls.TlsStartData) -> None:
         client: connection.Client = tls_start.context.client
diff --git a/mitmproxy/proxy/layers/tls.py b/mitmproxy/proxy/layers/tls.py
index 497e44cc4..052962be9 100644
--- a/mitmproxy/proxy/layers/tls.py
+++ b/mitmproxy/proxy/layers/tls.py
@@ -122,9 +122,20 @@ class TlsStartData:
 
 
 @dataclass
-class TlsStartHook(StartHook):
+class TlsStartClientHook(StartHook):
     """
-    TLS Negotation is about to start.
+    TLS Negotation between mitmproxy and a client is about to start.
+
+    An addon is expected to initialize data.ssl_conn.
+    (by default, this is done by mitmproxy.addons.TlsConfig)
+    """
+    data: TlsStartData
+
+
+@dataclass
+class TlsStartServerHook(StartHook):
+    """
+    TLS Negotation between mitmproxy and a server is about to start.
 
     An addon is expected to initialize data.ssl_conn.
     (by default, this is done by mitmproxy.addons.TlsConfig)
@@ -152,7 +163,10 @@ class _TLSLayer(tunnel.TunnelLayer):
         assert not self.tls
 
         tls_start = TlsStartData(self.conn, self.context)
-        yield TlsStartHook(tls_start)
+        if tls_start.conn == tls_start.context.client:
+            yield TlsStartClientHook(tls_start)
+        else:
+            yield TlsStartServerHook(tls_start)
         if not tls_start.ssl_conn:
             yield commands.Log("No TLS context was provided, failing connection.", "error")
             yield commands.CloseConnection(self.conn)
diff --git a/mitmproxy/proxy/server.py b/mitmproxy/proxy/server.py
index de0eb9c33..8bceffa6e 100644
--- a/mitmproxy/proxy/server.py
+++ b/mitmproxy/proxy/server.py
@@ -414,30 +414,31 @@ if __name__ == "__main__":  # pragma: no cover
             if "redirect" in flow.request.path:
                 flow.request.host = "httpbin.org"
 
-        def tls_start(tls_start: tls.TlsStartData):
+        def tls_start_client(tls_start: tls.TlsStartData):
             # INSECURE
             ssl_context = SSL.Context(SSL.SSLv23_METHOD)
-            if tls_start.conn == tls_start.context.client:
-                ssl_context.use_privatekey_file(
-                    pkg_data.path("../test/mitmproxy/data/verificationcerts/trusted-leaf.key")
-                )
-                ssl_context.use_certificate_chain_file(
-                    pkg_data.path("../test/mitmproxy/data/verificationcerts/trusted-leaf.crt")
-                )
-
+            ssl_context.use_privatekey_file(
+                pkg_data.path("../test/mitmproxy/data/verificationcerts/trusted-leaf.key")
+            )
+            ssl_context.use_certificate_chain_file(
+                pkg_data.path("../test/mitmproxy/data/verificationcerts/trusted-leaf.crt")
+            )
             tls_start.ssl_conn = SSL.Connection(ssl_context)
+            tls_start.ssl_conn.set_accept_state()
 
-            if tls_start.conn == tls_start.context.client:
-                tls_start.ssl_conn.set_accept_state()
-            else:
-                tls_start.ssl_conn.set_connect_state()
-                if tls_start.context.client.sni is not None:
-                    tls_start.ssl_conn.set_tlsext_host_name(tls_start.context.client.sni.encode())
+        def tls_start_server(tls_start: tls.TlsStartData):
+            # INSECURE
+            ssl_context = SSL.Context(SSL.SSLv23_METHOD)
+            tls_start.ssl_conn = SSL.Connection(ssl_context)
+            tls_start.ssl_conn.set_connect_state()
+            if tls_start.context.client.sni is not None:
+                tls_start.ssl_conn.set_tlsext_host_name(tls_start.context.client.sni.encode())
 
         await SimpleConnectionHandler(reader, writer, opts, {
             "next_layer": next_layer,
             "request": request,
-            "tls_start": tls_start,
+            "tls_start_client": tls_start_client,
+            "tls_start_server": tls_start_server,
         }).handle_client()
 
     coro = asyncio.start_server(handle, '127.0.0.1', 8080, loop=loop)
diff --git a/test/mitmproxy/addons/test_tlsconfig.py b/test/mitmproxy/addons/test_tlsconfig.py
index 731530071..46a7fd70c 100644
--- a/test/mitmproxy/addons/test_tlsconfig.py
+++ b/test/mitmproxy/addons/test_tlsconfig.py
@@ -126,7 +126,7 @@ class TestTlsConfig:
             ctx = context.Context(connection.Client(("client", 1234), ("127.0.0.1", 8080), 1605699329), tctx.options)
 
             tls_start = tls.TlsStartData(ctx.client, context=ctx)
-            ta.tls_start(tls_start)
+            ta.tls_start_client(tls_start)
             tssl_server = tls_start.ssl_conn
             tssl_client = test_tls.SSLTest()
             assert self.do_handshake(tssl_client, tssl_server)
@@ -141,7 +141,7 @@ class TestTlsConfig:
             ctx.server.address = ("example.mitmproxy.org", 443)
 
             tls_start = tls.TlsStartData(ctx.server, context=ctx)
-            ta.tls_start(tls_start)
+            ta.tls_start_server(tls_start)
             tssl_client = tls_start.ssl_conn
             tssl_server = test_tls.SSLTest(server_side=True)
             with pytest.raises(SSL.Error, match="certificate verify failed"):
@@ -156,7 +156,7 @@ class TestTlsConfig:
                 "mitmproxy/net/data/verificationcerts/trusted-root.crt"))
 
             tls_start = tls.TlsStartData(ctx.server, context=ctx)
-            ta.tls_start(tls_start)
+            ta.tls_start_server(tls_start)
             tssl_client = tls_start.ssl_conn
             tssl_server = test_tls.SSLTest(server_side=True)
             assert self.do_handshake(tssl_client, tssl_server)
@@ -175,7 +175,7 @@ class TestTlsConfig:
                 ciphers_server="ALL"
             )
             tls_start = tls.TlsStartData(ctx.server, context=ctx)
-            ta.tls_start(tls_start)
+            ta.tls_start_server(tls_start)
             tssl_client = tls_start.ssl_conn
             tssl_server = test_tls.SSLTest(server_side=True)
             assert self.do_handshake(tssl_client, tssl_server)
@@ -191,7 +191,7 @@ class TestTlsConfig:
                 tctx.configure(ta, http2=http2)
                 ctx.client.alpn_offers = client_offers
                 ctx.server.alpn_offers = None
-                ta.tls_start(tls_start)
+                ta.tls_start_server(tls_start)
                 assert ctx.server.alpn_offers == expected
 
             assert_alpn(True, tls.HTTP_ALPNS + (b"foo",), tls.HTTP_ALPNS + (b"foo",))
@@ -222,7 +222,7 @@ class TestTlsConfig:
             )
 
             tls_start = tls.TlsStartData(ctx.server, context=ctx)
-            ta.tls_start(tls_start)
+            ta.tls_start_server(tls_start)
             tssl_client = tls_start.ssl_conn
             tssl_server = test_tls.SSLTest(server_side=True)
 
diff --git a/test/mitmproxy/proxy/layers/test_modes.py b/test/mitmproxy/proxy/layers/test_modes.py
index 0c32c1069..927d2fb2f 100644
--- a/test/mitmproxy/proxy/layers/test_modes.py
+++ b/test/mitmproxy/proxy/layers/test_modes.py
@@ -11,9 +11,9 @@ from mitmproxy.proxy.layer import NextLayer, NextLayerHook
 from mitmproxy.proxy.layers import http, modes, tcp, tls
 from mitmproxy.proxy.layers.http import HTTPMode
 from mitmproxy.proxy.layers.tcp import TcpMessageHook, TcpStartHook
-from mitmproxy.proxy.layers.tls import ClientTLSLayer, TlsStartHook
+from mitmproxy.proxy.layers.tls import ClientTLSLayer, TlsStartClientHook, TlsStartServerHook
 from mitmproxy.tcp import TCPFlow
-from test.mitmproxy.proxy.layers.test_tls import reply_tls_start
+from test.mitmproxy.proxy.layers.test_tls import reply_tls_start_client, reply_tls_start_server
 from test.mitmproxy.proxy.tutils import Placeholder, Playbook, reply, reply_next_layer
 
 
@@ -64,8 +64,8 @@ def test_upstream_https(tctx):
         >> reply_next_layer(lambda ctx: http.HttpLayer(ctx, HTTPMode.upstream))
         << OpenConnection(upstream)
         >> reply(None)
-        << TlsStartHook(Placeholder())
-        >> reply_tls_start(alpn=b"http/1.1")
+        << TlsStartServerHook(Placeholder())
+        >> reply_tls_start_server(alpn=b"http/1.1")
         << SendData(upstream, clienthello)
     )
     assert upstream().address == ("example.mitmproxy.org", 8081)
@@ -74,8 +74,8 @@ def test_upstream_https(tctx):
         >> DataReceived(tctx2.client, clienthello())
         << NextLayerHook(Placeholder(NextLayer))
         >> reply_next_layer(ClientTLSLayer)
-        << TlsStartHook(Placeholder())
-        >> reply_tls_start(alpn=b"http/1.1")
+        << TlsStartClientHook(Placeholder())
+        >> reply_tls_start_client(alpn=b"http/1.1")
         << SendData(tctx2.client, serverhello)
     )
     assert (
@@ -195,8 +195,8 @@ def test_reverse_proxy_tcp_over_tls(tctx: Context, monkeypatch, patch, connectio
             )
         assert (
             playbook
-            << TlsStartHook(Placeholder())
-            >> reply_tls_start()
+            << TlsStartServerHook(Placeholder())
+            >> reply_tls_start_server()
             << SendData(tctx.server, data)
         )
         assert tls.parse_client_hello(data()).sni == "localhost"
diff --git a/test/mitmproxy/proxy/layers/test_tls.py b/test/mitmproxy/proxy/layers/test_tls.py
index 08f484b33..440490cc7 100644
--- a/test/mitmproxy/proxy/layers/test_tls.py
+++ b/test/mitmproxy/proxy/layers/test_tls.py
@@ -156,57 +156,63 @@ def interact(playbook: tutils.Playbook, conn: connection.Connection, tssl: SSLTe
     tssl.bio_write(data())
 
 
-def reply_tls_start(alpn: typing.Optional[bytes] = None, *args, **kwargs) -> tutils.reply:
+def reply_tls_start_client(alpn: typing.Optional[bytes] = None, *args, **kwargs) -> tutils.reply:
     """
-    Helper function to simplify the syntax for tls_start hooks.
+    Helper function to simplify the syntax for tls_start_client hooks.
     """
 
-    def make_conn(tls_start: tls.TlsStartData) -> None:
+    def make_client_conn(tls_start: tls.TlsStartData) -> None:
         ssl_context = SSL.Context(SSL.SSLv23_METHOD)
-        if tls_start.conn == tls_start.context.client:
-            ssl_context.use_privatekey_file(
-                tlsdata.path("../../net/data/verificationcerts/trusted-leaf.key")
-            )
-            ssl_context.use_certificate_chain_file(
-                tlsdata.path("../../net/data/verificationcerts/trusted-leaf.crt")
-            )
-        else:
-            ssl_context.load_verify_locations(
-                cafile=tlsdata.path("../../net/data/verificationcerts/trusted-root.crt")
-            )
+        ssl_context.use_privatekey_file(
+            tlsdata.path("../../net/data/verificationcerts/trusted-leaf.key")
+        )
+        ssl_context.use_certificate_chain_file(
+            tlsdata.path("../../net/data/verificationcerts/trusted-leaf.crt")
+        )
         if alpn is not None:
-            if tls_start.conn == tls_start.context.client:
-                ssl_context.set_alpn_select_callback(lambda conn, protos: alpn)
-            else:
-                ssl_context.set_alpn_protos([alpn])
-
-        if tls_start.conn == tls_start.context.client:
-            tls_start.ssl_conn = SSL.Connection(ssl_context)
-            tls_start.ssl_conn.set_accept_state()
-        else:
-            ssl_context.set_verify(SSL.VERIFY_PEER)
-
-            tls_start.ssl_conn = SSL.Connection(ssl_context)
-            tls_start.ssl_conn.set_connect_state()
-            # Set SNI
-            tls_start.ssl_conn.set_tlsext_host_name(tls_start.conn.sni.encode())
-
-            # Manually enable hostname verification.
-            # Recent OpenSSL versions provide slightly nicer ways to do this, but they are not exposed in
-            # cryptography and likely a PITA to add.
-            # https://wiki.openssl.org/index.php/Hostname_validation
-            param = SSL._lib.SSL_get0_param(tls_start.ssl_conn._ssl)
-            # Common Name matching is disabled in both Chrome and Firefox, so we should disable it, too.
-            # https://www.chromestatus.com/feature/4981025180483584
-            SSL._lib.X509_VERIFY_PARAM_set_hostflags(
-                param,
-                SSL._lib.X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS | SSL._lib.X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
-            )
-            SSL._openssl_assert(
-                SSL._lib.X509_VERIFY_PARAM_set1_host(param, tls_start.conn.sni.encode(), 0) == 1
-            )
+            ssl_context.set_alpn_select_callback(lambda conn, protos: alpn)
+
+        tls_start.ssl_conn = SSL.Connection(ssl_context)
+        tls_start.ssl_conn.set_accept_state()
+
+    return tutils.reply(*args, side_effect=make_client_conn, **kwargs)
+
+
+def reply_tls_start_server(alpn: typing.Optional[bytes] = None, *args, **kwargs) -> tutils.reply:
+    """
+    Helper function to simplify the syntax for tls_start_server hooks.
+    """
+
+    def make_server_conn(tls_start: tls.TlsStartData) -> None:
+        ssl_context = SSL.Context(SSL.SSLv23_METHOD)
+        ssl_context.load_verify_locations(
+            cafile=tlsdata.path("../../net/data/verificationcerts/trusted-root.crt")
+        )
+        if alpn is not None:
+            ssl_context.set_alpn_protos([alpn])
+        ssl_context.set_verify(SSL.VERIFY_PEER)
+
+        tls_start.ssl_conn = SSL.Connection(ssl_context)
+        tls_start.ssl_conn.set_connect_state()
+        # Set SNI
+        tls_start.ssl_conn.set_tlsext_host_name(tls_start.conn.sni.encode())
+
+        # Manually enable hostname verification.
+        # Recent OpenSSL versions provide slightly nicer ways to do this, but they are not exposed in
+        # cryptography and likely a PITA to add.
+        # https://wiki.openssl.org/index.php/Hostname_validation
+        param = SSL._lib.SSL_get0_param(tls_start.ssl_conn._ssl)
+        # Common Name matching is disabled in both Chrome and Firefox, so we should disable it, too.
+        # https://www.chromestatus.com/feature/4981025180483584
+        SSL._lib.X509_VERIFY_PARAM_set_hostflags(
+            param,
+            SSL._lib.X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS | SSL._lib.X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
+        )
+        SSL._openssl_assert(
+            SSL._lib.X509_VERIFY_PARAM_set1_host(param, tls_start.conn.sni.encode(), 0) == 1
+        )
 
-    return tutils.reply(*args, side_effect=make_conn, **kwargs)
+    return tutils.reply(*args, side_effect=make_server_conn, **kwargs)
 
 
 class TestServerTLS:
@@ -236,8 +242,8 @@ class TestServerTLS:
         data = tutils.Placeholder(bytes)
         assert (
                 playbook
-                << tls.TlsStartHook(tutils.Placeholder())
-                >> reply_tls_start()
+                << tls.TlsStartServerHook(tutils.Placeholder())
+                >> reply_tls_start_server()
                 << commands.SendData(tctx.server, data)
         )
 
@@ -294,8 +300,8 @@ class TestServerTLS:
                 >> tutils.reply_next_layer(TlsEchoLayer)
                 << commands.OpenConnection(tctx.server)
                 >> tutils.reply(None)
-                << tls.TlsStartHook(tutils.Placeholder())
-                >> reply_tls_start()
+                << tls.TlsStartServerHook(tutils.Placeholder())
+                >> reply_tls_start_server()
                 << commands.SendData(tctx.server, data)
         )
 
@@ -323,8 +329,8 @@ class TestServerTLS:
         data = tutils.Placeholder(bytes)
         assert (
                 playbook
-                << tls.TlsStartHook(tutils.Placeholder())
-                >> reply_tls_start()
+                << tls.TlsStartServerHook(tutils.Placeholder())
+                >> reply_tls_start_server()
                 << commands.SendData(tctx.server, data)
                 >> events.DataReceived(tctx.server, b"HTTP/1.1 404 Not Found\r\n")
                 << commands.Log("Server TLS handshake failed. The remote server does not speak TLS.", "warn")
@@ -370,8 +376,8 @@ class TestClientTLS:
                 >> events.DataReceived(tctx.client, tssl_client.bio_read())
                 << tls.TlsClienthelloHook(tutils.Placeholder())
                 >> tutils.reply()
-                << tls.TlsStartHook(tutils.Placeholder())
-                >> reply_tls_start()
+                << tls.TlsStartClientHook(tutils.Placeholder())
+                >> reply_tls_start_client()
                 << commands.SendData(tctx.client, data)
         )
         tssl_client.bio_write(data())
@@ -422,8 +428,8 @@ class TestClientTLS:
             )
         assert (
             playbook
-            << tls.TlsStartHook(tutils.Placeholder())
-            >> reply_tls_start(alpn=b"quux")
+            << tls.TlsStartServerHook(tutils.Placeholder())
+            >> reply_tls_start_server(alpn=b"quux")
             << commands.SendData(tctx.server, data)
         )
 
@@ -437,7 +443,7 @@ class TestClientTLS:
                 playbook
                 >> events.DataReceived(tctx.server, tssl_server.bio_read())
                 << commands.SendData(tctx.server, data)
-                << tls.TlsStartHook(tutils.Placeholder())
+                << tls.TlsStartClientHook(tutils.Placeholder())
         )
         tssl_server.bio_write(data())
         assert tctx.server.tls_established
@@ -446,7 +452,7 @@ class TestClientTLS:
         data = tutils.Placeholder(bytes)
         assert (
                 playbook
-                >> reply_tls_start(alpn=b"quux")
+                >> reply_tls_start_client(alpn=b"quux")
                 << commands.SendData(tctx.client, data)
         )
         tssl_client.bio_write(data())
@@ -496,8 +502,8 @@ class TestClientTLS:
                 >> events.DataReceived(tctx.client, tssl_client.bio_read())
                 << tls.TlsClienthelloHook(tutils.Placeholder())
                 >> tutils.reply()
-                << tls.TlsStartHook(tutils.Placeholder())
-                >> reply_tls_start()
+                << tls.TlsStartClientHook(tutils.Placeholder())
+                >> reply_tls_start_client()
                 << commands.SendData(tctx.client, data)
         )
         tssl_client.bio_write(data())
@@ -523,8 +529,8 @@ class TestClientTLS:
                 >> events.DataReceived(tctx.client, tssl_client.bio_read())
                 << tls.TlsClienthelloHook(tutils.Placeholder())
                 >> tutils.reply()
-                << tls.TlsStartHook(tutils.Placeholder())
-                >> reply_tls_start()
+                << tls.TlsStartClientHook(tutils.Placeholder())
+                >> reply_tls_start_client()
                 << commands.SendData(tctx.client, tutils.Placeholder())
                 >> events.ConnectionClosed(tctx.client)
                 << commands.Log("Client TLS handshake failed. The client may not trust the proxy's certificate "
