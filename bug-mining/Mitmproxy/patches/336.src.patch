diff --git a/mitmproxy/stateobject.py b/mitmproxy/stateobject.py
index 26468ccc2..2c16dcda1 100644
--- a/mitmproxy/stateobject.py
+++ b/mitmproxy/stateobject.py
@@ -1,6 +1,7 @@
 import typing
 from typing import Any  # noqa
 from typing import MutableMapping  # noqa
+import json
 
 from mitmproxy.coretypes import serializable
 from mitmproxy.utils import typecheck
@@ -77,8 +78,14 @@ def _process(typeinfo: typecheck.Type, val: typing.Any, make: bool) -> typing.An
             for k, v in val.items()
         }
     elif typename.startswith("typing.Any"):
-        # FIXME: Remove this when we remove flow.metadata
-        assert isinstance(val, (int, str, bool, bytes))
+        # This requires a bit of explanation. We can't import our IO layer here,
+        # because it causes a circular import. Rather than restructuring the
+        # code for this, we use JSON serialization, which has similar primitive
+        # type restrictions as tnetstring, to check for conformance.
+        try:
+            json.dumps(val)
+        except TypeError:
+            raise ValueError(f"Data not serializable: {val}")
         return val
     else:
         return typeinfo(val)
diff --git a/test/mitmproxy/test_stateobject.py b/test/mitmproxy/test_stateobject.py
index a642e0233..a2df57fc7 100644
--- a/test/mitmproxy/test_stateobject.py
+++ b/test/mitmproxy/test_stateobject.py
@@ -125,7 +125,7 @@ def test_any():
     assert a.x == b.x
 
     a = TAny(object())
-    with pytest.raises(AssertionError):
+    with pytest.raises(ValueError):
         a.get_state()
 
 
