diff --git a/crates/cli/src/lib.rs b/crates/cli/src/lib.rs
index 643d796..3cc6636 100644
--- a/crates/cli/src/lib.rs
+++ b/crates/cli/src/lib.rs
@@ -182,6 +182,7 @@ pub fn is_readable_stdin() -> bool {
         let file = File::from(fd);
         let Ok(md) = file.metadata() else { return false };
         let ft = md.file_type();
+        dbg!(&ft);
         ft.is_file() || ft.is_fifo() || ft.is_socket()
     }
 
diff --git a/crates/core/flags/hiargs.rs b/crates/core/flags/hiargs.rs
index e027a2c..f7ab9ea 100644
--- a/crates/core/flags/hiargs.rs
+++ b/crates/core/flags/hiargs.rs
@@ -1080,9 +1080,18 @@ impl Paths {
             }
             paths.push(path);
         }
+        log::debug!("number of paths given to search: {}", paths.len());
         if !paths.is_empty() {
             let is_one_file = paths.len() == 1
-                && (paths[0] == Path::new("-") || paths[0].is_file());
+                // Note that we specifically use `!paths[0].is_dir()` here
+                // instead of `paths[0].is_file()`. Namely, the latter can
+                // return `false` even when the path is something resembling
+                // a file. So instead, we just consider the path a file as
+                // long as we know it isn't a directory.
+                //
+                // See: https://github.com/BurntSushi/ripgrep/issues/2736
+                && (paths[0] == Path::new("-") || !paths[0].is_dir());
+            log::debug!("is_one_file? {is_one_file:?}");
             return Ok(Paths { paths, has_implicit_path: false, is_one_file });
         }
         // N.B. is_readable_stdin is a heuristic! Part of the issue is that a
