diff --git a/src/args.rs b/src/args.rs
index 48c9187..4245871 100644
--- a/src/args.rs
+++ b/src/args.rs
@@ -564,12 +564,21 @@ impl Args {
     /// to the writer given.
     pub fn out(&self) -> Out {
         let mut out = Out::new(self.color);
+        if let Some(filesep) = self.file_separator() {
+            out = out.file_separator(filesep);
+        }
+        out
+    }
+
+    /// Retrieve the configured file separator.
+    pub fn file_separator(&self) -> Option<Vec<u8>> {
         if self.heading && !self.count && !self.files_with_matches {
-            out = out.file_separator(b"".to_vec());
+            Some(b"".to_vec())
         } else if self.before_context > 0 || self.after_context > 0 {
-            out = out.file_separator(self.context_separator.clone());
+            Some(self.context_separator.clone())
+        } else {
+            None
         }
-        out
     }
 
     /// Create a new buffer for use with searching.
diff --git a/src/main.rs b/src/main.rs
index bdb8b58..7a40c07 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -22,7 +22,7 @@ extern crate winapi;
 
 use std::error::Error;
 use std::fs::File;
-use std::io;
+use std::io::{self, Write};
 use std::path::{Path, PathBuf};
 use std::process;
 use std::result;
@@ -88,6 +88,7 @@ fn main() {
 fn run(args: Args) -> Result<u64> {
     let args = Arc::new(args);
     let paths = args.paths();
+    let threads = cmp::max(1, args.threads() - 1);
     if args.files() {
         return run_files(args.clone());
     }
@@ -97,13 +98,16 @@ fn run(args: Args) -> Result<u64> {
     if paths.len() == 1 && (paths[0] == Path::new("-") || paths[0].is_file()) {
         return run_one(args.clone(), &paths[0]);
     }
+    if threads == 1 {
+        return run_one_thread(args.clone());
+    }
 
     let out = Arc::new(Mutex::new(args.out()));
     let mut workers = vec![];
 
     let workq = {
         let (workq, stealer) = deque::new();
-        for _ in 0..cmp::max(1, args.threads() - 1) {
+        for _ in 0..threads {
             let worker = MultiWorker {
                 chan_work: stealer.clone(),
                 out: out.clone(),
@@ -146,6 +150,52 @@ fn run(args: Args) -> Result<u64> {
     Ok(match_count)
 }
 
+fn run_one_thread(args: Arc<Args>) -> Result<u64> {
+    let mut worker = Worker {
+        args: args.clone(),
+        inpbuf: args.input_buffer(),
+        grep: args.grep(),
+        match_count: 0,
+    };
+    let paths = args.paths();
+    let filesep = args.file_separator();
+    let mut term = args.stdout();
+
+    let mut paths_searched: u64 = 0;
+    for p in paths {
+        if p == Path::new("-") {
+            if worker.match_count > 0 {
+                if let Some(ref sep) = filesep {
+                    let _ = term.write_all(sep);
+                    let _ = term.write_all(b"\n");
+                }
+            }
+            paths_searched += 1;
+            let mut printer = args.printer(&mut term);
+            worker.do_work(&mut printer, WorkReady::Stdin);
+        } else {
+            for ent in try!(args.walker(p)) {
+                if worker.match_count > 0 {
+                    if let Some(ref sep) = filesep {
+                        let _ = term.write_all(sep);
+                        let _ = term.write_all(b"\n");
+                    }
+                }
+                paths_searched += 1;
+                let mut printer = args.printer(&mut term);
+                let file = try!(File::open(ent.path()));
+                worker.do_work(&mut printer, WorkReady::DirFile(ent, file));
+            }
+        }
+    }
+    if !paths.is_empty() && paths_searched == 0 {
+        eprintln!("No files were searched, which means ripgrep probably \
+                   applied a filter you didn't expect. \
+                   Try running again with --debug.");
+    }
+    Ok(worker.match_count)
+}
+
 fn run_one(args: Arc<Args>, path: &Path) -> Result<u64> {
     let mut worker = Worker {
         args: args.clone(),
diff --git a/src/out.rs b/src/out.rs
index 32b581b..9ed0154 100644
--- a/src/out.rs
+++ b/src/out.rs
@@ -317,3 +317,60 @@ impl<T: Terminal + Send> term::Terminal for ColoredTerminal<T> {
         }
     }
 }
+
+impl<'a, T: Terminal + Send> term::Terminal for &'a mut ColoredTerminal<T> {
+    type Output = T::Output;
+
+    fn fg(&mut self, fg: term::color::Color) -> term::Result<()> {
+        (**self).fg(fg)
+    }
+
+    fn bg(&mut self, bg: term::color::Color) -> term::Result<()> {
+        (**self).bg(bg)
+    }
+
+    fn attr(&mut self, attr: term::Attr) -> term::Result<()> {
+        (**self).attr(attr)
+    }
+
+    fn supports_attr(&self, attr: term::Attr) -> bool {
+        (**self).supports_attr(attr)
+    }
+
+    fn reset(&mut self) -> term::Result<()> {
+        (**self).reset()
+    }
+
+    fn supports_reset(&self) -> bool {
+        (**self).supports_reset()
+    }
+
+    fn supports_color(&self) -> bool {
+        (**self).supports_color()
+    }
+
+    fn cursor_up(&mut self) -> term::Result<()> {
+        (**self).cursor_up()
+    }
+
+    fn delete_line(&mut self) -> term::Result<()> {
+        (**self).delete_line()
+    }
+
+    fn carriage_return(&mut self) -> term::Result<()> {
+        (**self).carriage_return()
+    }
+
+    fn get_ref(&self) -> &Self::Output {
+        (**self).get_ref()
+    }
+
+    fn get_mut(&mut self) -> &mut Self::Output {
+        (**self).get_mut()
+    }
+
+    fn into_inner(self) -> Self::Output {
+        // Good golly miss molly...
+        unimplemented!()
+    }
+}
