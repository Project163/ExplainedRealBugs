diff --git a/doc/rg.1 b/doc/rg.1
index f759567..0dfd3f0 100644
--- a/doc/rg.1
+++ b/doc/rg.1
@@ -1,6 +1,6 @@
 .\" Automatically generated by Pandoc 1.19.1
 .\"
-.TH "" "" "" "" ""
+.TH "rg" "1"
 .hy
 .SH NAME
 .PP
@@ -162,7 +162,7 @@ This flag may be provided multiple times.
 Settings are applied iteratively.
 Colors are limited to one of eight choices: red, blue, green, cyan,
 magenta, yellow, white and black.
-Styles are limited to either nobold or bold.
+Styles are limited to nobold, bold, nointense or intense.
 .RS
 .PP
 The format of the flag is {type}:{attribute}:{value}.
diff --git a/doc/rg.1.md b/doc/rg.1.md
index 3dc1a44..b6ed880 100644
--- a/doc/rg.1.md
+++ b/doc/rg.1.md
@@ -111,7 +111,7 @@ Project home page: https://github.com/BurntSushi/ripgrep
 : This flag specifies color settings for use in the output. This flag may be
   provided multiple times. Settings are applied iteratively. Colors are limited
   to one of eight choices: red, blue, green, cyan, magenta, yellow, white and
-  black. Styles are limited to either nobold or bold.
+  black. Styles are limited to nobold, bold, nointense or intense.
 
     The format of the flag is {type}:{attribute}:{value}. {type} should be one
     of path, line or match. {attribute} can be fg, bg or style. Value is either
diff --git a/src/app.rs b/src/app.rs
index 13b1ac6..8466b2b 100644
--- a/src/app.rs
+++ b/src/app.rs
@@ -237,14 +237,14 @@ lazy_static! {
               This flag may be provided multiple times. Settings are applied \
               iteratively. Colors are limited to one of eight choices: \
               red, blue, green, cyan, magenta, yellow, white and black. \
-              Styles are limited to either nobold or bold.\n\nThe format \
-              of the flag is {type}:{attribute}:{value}. {type} should be \
-              one of path, line or match. {attribute} can be fg, bg or style. \
-              {value} is either a color (for fg and bg) or a text style. \
-              A special format, {type}:none, will clear all color settings \
-              for {type}.\n\nFor example, the following command will change \
-              the match color to magenta and the background color for line \
-              numbers to yellow:\n\n\
+              Styles are limited to nobold, bold, nointense or intense.\n\n
+              The format of the flag is {type}:{attribute}:{value}. {type} \
+              should be one of path, line or match. {attribute} can be fg, bg \
+              or style. {value} is either a color (for fg and bg) or a text \
+              style. A special format, {type}:none, will clear all color \
+              settings for {type}.\n\nFor example, the following command will \
+              change the match color to magenta and the background color for \
+              line numbers to yellow:\n\n\
               rg --colors 'match:fg:magenta' --colors 'line:bg:yellow' foo.");
         doc!(h, "fixed-strings",
              "Treat the pattern as a literal string.",
diff --git a/src/args.rs b/src/args.rs
index 9ce572a..18da6f6 100644
--- a/src/args.rs
+++ b/src/args.rs
@@ -640,11 +640,10 @@ impl<'a> ArgMatches<'a> {
     fn color_specs(&self) -> Result<ColorSpecs> {
         // Start with a default set of color specs.
         let mut specs = vec![
-            "path:fg:green".parse().unwrap(),
-            "path:style:bold".parse().unwrap(),
-            "line:fg:blue".parse().unwrap(),
-            "line:style:bold".parse().unwrap(),
+            "path:fg:magenta".parse().unwrap(),
+            "line:fg:green".parse().unwrap(),
             "match:fg:red".parse().unwrap(),
+            "match:style:intense".parse().unwrap(),
             "match:style:bold".parse().unwrap(),
         ];
         for spec_str in self.values_of_lossy_vec("colors") {
diff --git a/src/printer.rs b/src/printer.rs
index 96b0444..c57e161 100644
--- a/src/printer.rs
+++ b/src/printer.rs
@@ -523,6 +523,8 @@ enum SpecType {
 enum Style {
     Bold,
     NoBold,
+    Intense,
+    NoIntense,
 }
 
 impl ColorSpecs {
@@ -574,6 +576,8 @@ impl SpecValue {
                 match *style {
                     Style::Bold => { cspec.set_bold(true); }
                     Style::NoBold => { cspec.set_bold(false); }
+                    Style::Intense => { cspec.set_intense(true); }
+                    Style::NoIntense => { cspec.set_intense(false); }
                 }
             }
         }
@@ -650,6 +654,8 @@ impl FromStr for Style {
         match &*s.to_lowercase() {
             "bold" => Ok(Style::Bold),
             "nobold" => Ok(Style::NoBold),
+            "intense" => Ok(Style::Intense),
+            "nointense" => Ok(Style::NoIntense),
             _ => Err(Error::UnrecognizedStyle(s.to_string())),
         }
     }
@@ -696,6 +702,12 @@ mod tests {
             value: SpecValue::Style(Style::Bold),
         });
 
+        let spec: Spec = "match:style:intense".parse().unwrap();
+        assert_eq!(spec, Spec {
+            ty: OutType::Match,
+            value: SpecValue::Style(Style::Intense),
+        });
+
         let spec: Spec = "line:none".parse().unwrap();
         assert_eq!(spec, Spec {
             ty: OutType::Line,
diff --git a/termcolor/src/lib.rs b/termcolor/src/lib.rs
index 6b6492b..8b434d9 100644
--- a/termcolor/src/lib.rs
+++ b/termcolor/src/lib.rs
@@ -760,12 +760,12 @@ impl<W: io::Write> WriteColor for Ansi<W> {
     fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
         try!(self.reset());
         if let Some(ref c) = spec.fg_color {
-            try!(self.write_color(true, c, spec.bold));
+            try!(self.write_color(true, c, spec.intense));
         }
         if let Some(ref c) = spec.bg_color {
-            try!(self.write_color(false, c, spec.bold));
+            try!(self.write_color(false, c, spec.intense));
         }
-        if spec.bold && spec.fg_color.is_none() && spec.bg_color.is_none() {
+        if spec.bold {
             try!(self.write_str("\x1B[1m"));
         }
         Ok(())
@@ -785,11 +785,8 @@ impl<W: io::Write> Ansi<W> {
         &mut self,
         fg: bool,
         c: &Color,
-        bold: bool,
+        intense: bool,
     ) -> io::Result<()> {
-        // *sigh*... The termion crate doesn't compile on Windows, and we
-        // need to be able to write ANSI escape sequences on Windows, so I
-        // guess we have to roll this ourselves.
         macro_rules! w {
             ($selfie:expr, $fg:expr, $clr:expr) => {
                 if $fg {
@@ -799,7 +796,7 @@ impl<W: io::Write> Ansi<W> {
                 }
             }
         }
-        if bold {
+        if intense {
             match *c {
                 Color::Black => w!(self, fg, "8"),
                 Color::Blue => w!(self, fg, "12"),
@@ -935,12 +932,13 @@ pub struct ColorSpec {
     fg_color: Option<Color>,
     bg_color: Option<Color>,
     bold: bool,
+    intense: bool,
 }
 
 impl ColorSpec {
     /// Create a new color specification that has no colors or styles.
     pub fn new() -> ColorSpec {
-        ColorSpec { fg_color: None, bg_color: None, bold: false }
+        ColorSpec::default()
     }
 
     /// Get the foreground color.
@@ -962,14 +960,27 @@ impl ColorSpec {
     }
 
     /// Get whether this is bold or not.
+    ///
+    /// Note that the bold setting has no effect in a Windows console.
     pub fn bold(&self) -> bool { self.bold }
 
     /// Set whether the text is bolded or not.
+    ///
+    /// Note that the bold setting has no effect in a Windows console.
     pub fn set_bold(&mut self, yes: bool) -> &mut ColorSpec {
         self.bold = yes;
         self
     }
 
+    /// Get whether this is intense or not.
+    pub fn intense(&self) -> bool { self.intense }
+
+    /// Set whether the text is intense or not.
+    pub fn set_intense(&mut self, yes: bool) -> &mut ColorSpec {
+        self.intense = yes;
+        self
+    }
+
     /// Returns true if this color specification has no colors or styles.
     pub fn is_none(&self) -> bool {
         self.fg_color.is_none() && self.bg_color.is_none() && !self.bold
@@ -990,7 +1001,7 @@ impl ColorSpec {
     ) -> io::Result<()> {
         use wincolor::Intense;
 
-        let intense = if self.bold { Intense::Yes } else { Intense::No };
+        let intense = if self.intense { Intense::Yes } else { Intense::No };
         if let Some(color) = self.fg_color.as_ref().map(|c| c.to_windows()) {
             try!(console.fg(intense, color));
         }
