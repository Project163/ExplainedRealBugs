diff --git a/src/printer.rs b/src/printer.rs
index 4d7966c..3b23e9b 100644
--- a/src/printer.rs
+++ b/src/printer.rs
@@ -361,8 +361,13 @@ impl<W: WriteColor> Printer<W> {
             let mut last_written = 0;
             for o in offsets {
                 self.write(&buf[last_written..o.start]);
-                self.write_colored(
-                    &buf[o.start..o.end], |colors| colors.matched());
+                // This conditional checks if the match is both empty *and*
+                // past the end of the line. In this case, we never want to
+                // emit an additional color escape.
+                if o.start != o.end || o.end != buf.len() {
+                    self.write_colored(
+                        &buf[o.start..o.end], |colors| colors.matched());
+                }
                 last_written = o.end;
             }
             self.write(&buf[last_written..]);
diff --git a/tests/tests.rs b/tests/tests.rs
index 0c9446c..2b1f3cc 100644
--- a/tests/tests.rs
+++ b/tests/tests.rs
@@ -1146,6 +1146,29 @@ clean!(regression_493, " 're ", "input.txt", |wd: WorkDir, mut cmd: Command| {
     assert_eq!(lines, " 're \n");
 });
 
+// See: https://github.com/BurntSushi/ripgrep/issues/599
+clean!(regression_599, "^$", "input.txt", |wd: WorkDir, mut cmd: Command| {
+    wd.create("input.txt", "\n\ntest\n");
+    cmd.args(&[
+        "--color", "ansi",
+        "--colors", "path:none",
+        "--colors", "line:none",
+        "--colors", "match:fg:red",
+        "--colors", "match:style:nobold",
+        "--line-number",
+    ]);
+
+    let lines: String = wd.stdout(&mut cmd);
+    // Technically, the expected output should only be two lines, but:
+    // https://github.com/BurntSushi/ripgrep/issues/441
+    let expected = "\
+[m1[m:[m[31m[m
+[m2[m:[m[31m[m
+[m4[m:
+";
+    assert_eq!(expected, lines);
+});
+
 // See: https://github.com/BurntSushi/ripgrep/issues/1
 clean!(feature_1_sjis, "–®–µ—Ä–ª–æ–∫ –•–æ–ª–º—Å", ".", |wd: WorkDir, mut cmd: Command| {
     let sherlock =
