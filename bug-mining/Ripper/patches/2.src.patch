diff --git a/grep/src/lib.rs b/grep/src/lib.rs
index 68f95a4..7526621 100644
--- a/grep/src/lib.rs
+++ b/grep/src/lib.rs
@@ -62,7 +62,7 @@ impl fmt::Display for Error {
         match *self {
             Error::Regex(ref err) => err.fmt(f),
             Error::LiteralNotAllowed(chr) => {
-                write!(f, "Literal '{}' not allowed.", chr)
+                write!(f, "Literal {:?} not allowed.", chr)
             }
             Error::__Nonexhaustive => unreachable!(),
         }
diff --git a/grep/src/nonl.rs b/grep/src/nonl.rs
index e4dad13..16fc103 100644
--- a/grep/src/nonl.rs
+++ b/grep/src/nonl.rs
@@ -10,6 +10,10 @@ use {Error, Result};
 /// If `byte` is not an ASCII character (i.e., greater than `0x7F`), then this
 /// function panics.
 pub fn remove(expr: Expr, byte: u8) -> Result<Expr> {
+    // TODO(burntsushi): There is a bug in this routine where only `\n` is
+    // handled correctly. Namely, `AnyChar` and `AnyByte` need to be translated
+    // to proper character classes instead of the special `AnyCharNoNL` and
+    // `AnyByteNoNL` classes.
     use syntax::Expr::*;
     assert!(byte <= 0x7F);
     let chr = byte as char;
