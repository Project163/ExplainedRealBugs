diff --git a/src/main.rs b/src/main.rs
index f7407ea..7d39aa6 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -9,6 +9,7 @@ extern crate grep;
 extern crate ignore;
 #[macro_use]
 extern crate lazy_static;
+extern crate libc;
 #[macro_use]
 extern crate log;
 extern crate memchr;
@@ -339,7 +340,6 @@ fn eprint_nothing_searched() {
 // https://github.com/BurntSushi/ripgrep/issues/200.
 #[cfg(unix)]
 fn reset_sigpipe() {
-    extern crate libc;
     unsafe {
         libc::signal(libc::SIGPIPE, libc::SIG_DFL);
     }
diff --git a/src/worker.rs b/src/worker.rs
index 3c00cc0..eee7c67 100644
--- a/src/worker.rs
+++ b/src/worker.rs
@@ -310,7 +310,10 @@ impl Worker {
             // regular read calls.
             return self.search(printer, path, file);
         }
-        let mmap = unsafe { Mmap::map(file)? };
+        let mmap = match self.mmap(file)? {
+            None => return self.search(printer, path, file),
+            Some(mmap) => mmap,
+        };
         let buf = &*mmap;
         if buf.len() >= 3 && Encoding::for_bom(buf).is_some() {
             // If we have a UTF-16 bom in our memory map, then we need to fall
@@ -330,4 +333,28 @@ impl Worker {
             .text(self.opts.text)
             .run())
     }
+
+    #[cfg(not(unix))]
+    fn mmap(&self, file: &File) -> Result<Option<Mmap>> {
+        Ok(Some(mmap_readonly(file)?))
+    }
+
+    #[cfg(unix)]
+    fn mmap(&self, file: &File) -> Result<Option<Mmap>> {
+        use libc::{ENODEV, EOVERFLOW};
+
+        let err = match mmap_readonly(file) {
+            Ok(mmap) => return Ok(Some(mmap)),
+            Err(err) => err,
+        };
+        let code = err.raw_os_error();
+        if code == Some(ENODEV) || code == Some(EOVERFLOW) {
+            return Ok(None);
+        }
+        Err(From::from(err))
+    }
+}
+
+fn mmap_readonly(file: &File) -> io::Result<Mmap> {
+    unsafe { Mmap::map(file) }
 }
