{"url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/978","repository_url":"https://api.github.com/repos/BurntSushi/ripgrep","labels_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/978/labels{/name}","comments_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/978/comments","events_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/978/events","html_url":"https://github.com/BurntSushi/ripgrep/issues/978","id":340692128,"node_id":"MDU6SXNzdWUzNDA2OTIxMjg=","number":978,"title":"Generic decoder program rather than/in addition to extension-based decompression","user":{"login":"c-blake","id":8928205,"node_id":"MDQ6VXNlcjg5MjgyMDU=","avatar_url":"https://avatars.githubusercontent.com/u/8928205?v=4","gravatar_id":"","url":"https://api.github.com/users/c-blake","html_url":"https://github.com/c-blake","followers_url":"https://api.github.com/users/c-blake/followers","following_url":"https://api.github.com/users/c-blake/following{/other_user}","gists_url":"https://api.github.com/users/c-blake/gists{/gist_id}","starred_url":"https://api.github.com/users/c-blake/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/c-blake/subscriptions","organizations_url":"https://api.github.com/users/c-blake/orgs","repos_url":"https://api.github.com/users/c-blake/repos","events_url":"https://api.github.com/users/c-blake/events{/privacy}","received_events_url":"https://api.github.com/users/c-blake/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":339721680,"node_id":"MDU6TGFiZWwzMzk3MjE2ODA=","url":"https://api.github.com/repos/BurntSushi/ripgrep/labels/enhancement","name":"enhancement","color":"84b6eb","default":true,"description":"An enhancement to the functionality of the software."},{"id":339721683,"node_id":"MDU6TGFiZWwzMzk3MjE2ODM=","url":"https://api.github.com/repos/BurntSushi/ripgrep/labels/question","name":"question","color":"cc317c","default":true,"description":"An issue that is lacking clarity on one or more points."}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2018-07-12T15:38:10Z","updated_at":"2018-07-21T21:25:13Z","closed_at":"2018-07-21T21:25:13Z","author_association":"NONE","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"#### What version of ripgrep are you using?\r\n\r\nripgrep 0.8.1\r\n-SIMD -AVX\r\n\r\n#### How did you install ripgrep?\r\n\r\nemerge sys-apps/ripgrep\r\n\r\n#### What operating system are you using ripgrep on?\r\n\r\nGentoo linux (kernel 4.17.5); Rust version 1.27.0, but none of these questions should be relevant to this feature suggestion/request.\r\n\r\n#### Describe your question, feature request, or bug.\r\n\r\nIn a recursive searching problem setting, one often has many types of (usually binary) files one would like to search through the \"decoded\" text of.  Here decoding is something that may even be idiosyncratic to a specific user on a specific system. For example, these may not only be compressed files - other encodings are possible/common such as PDF files where a text layer is extractable via a program like ``pdftotext`` in the poppler package or ``mutool draw`` or some similar tool.\r\n\r\n``ripgrep`` already does a better job than most greps here, but it could be much better.  Besides an ever growing/ultimately unknowable set of desired encodings/translations, file name extensions are not the most reliable way to detect file types.  The ``file`` program or its ``libmagic`` are more complete, but is quite slow and even it may omit classes of file a user wants to use.  Further, the transformation that counts as decoding could be idiosyncratic.  I give a concrete example with unidiffs below.\r\n\r\nIn light of both of the above considerations, the most flexible/robust approach is akin to what ``less`` does with its ``LESSOPEN`` environment variable - allow a user specified program to both classify and decode files that ``ripgrep`` cannot.  The dowside of this relative to the current ``ripgrep`` filename extension oriented approach is a \"double or triple ``exec``\" cost, but there are many upsides -- total generality, no shared library dependencies and so on.  { Many might not even pay attention to these extra fork/exec costs.  For example, many programs use ``system(3)`` rather than fork and exec which already incurs an extra ``exec``.  These days ``gunzip`` is even a shell script wrapper causing an extra exec of /bin/sh.  But in a recursive grep context the costs surely add up. }\r\n\r\nTo be concrete consider something like this script which a hypothetical new ``GREP_OPEN`` or ``RIPGREP_OPEN`` variable could point to:\r\n```sh\r\n#!/bin/sh\r\ncase \"$RIPGREP_INPUT\" in\r\n  *.gz) exec gzip -dc ;;                      # input name not needed for gzip..\r\n  *.pdf) exec pdftotext \"$RIPGREP_INPUT\" - ;; #..but MIGHT be. So, ripgrep exports it\r\n  *) exec cat ;; # unencoded\r\nesac\r\n```\r\nAnother possibility using ``file`` is:\r\n```sh\r\n#!/bin/sh\r\ncase \"$(file -)\" in\r\n  *unified diff output*) exec strip-unidiff-context ;;\r\n  *.zs) exec pzstd -cdqp8 ;;\r\nesac\r\n```\r\nwhere this second example assumes a few things - namely, ``ripgrep`` sets up stdin for the forked child and ``file -`` will do an ``lseek`` backward _post classification_ so that ``pzstd`` sees the _full_ input.   Also, it assumes a ``pzstd`` program is installed and some script/sed script/whatever program to, just as an example, strip the context from a unidiff so that ``ripgrep`` _only searches through actually changing_ text.  Note as part of this example that people often don't just name unified diff output ``foo.patch``, but sometimes ``foo.diff`` or other things.  The file type is almost always recognized from contents not filename extension.  The regular ``file`` does not do the seek, by the way, but a trivial backward compatible patch repairs that situation:\r\n```patch\r\ndiff -ruw file-5.32/src/file.c file-5.32-cb/src/file.c\r\n--- file-5.32/src/file.c        2018-04-05 12:47:37.522707019 -0400\r\n+++ file-5.32-cb/src/file.c     2018-04-05 12:49:45.406702873 -0400\r\n@@ -518,6 +518,9 @@\r\n\r\n        type = magic_file(ms, std_in ? NULL : inname);\r\n\r\n+        if (std_in)         /* Could be context where an invoking script may..*/\r\n+            rewind(stdin);  /*..want to \"exec gzip -dc\" based on our output */\r\n+\r\n        if (type == NULL) {\r\n                (void)printf(\"ERROR: %s%c\", magic_error(ms), c);\r\n                return 1;\r\n```\r\nThe ``/bin/sh-case-file`` approach can be a little slow mostly because file takes like 1 ms per file which can be a lot if files are small and IO is fast.  I personally have a little statically linked C program I used for this which looks at magic numbers and re-exec appropriate decoder/transformers all with more like 50 microsecond overhead (plus decoding/transforming time, of course).  Of course, you also want all your decoding C programs to be statically linked for minimum overhead.  In point of fact, a static C dispatcher + static decoder are already much lower overhead than the overhead from the current likely deployment of ``ripgrep`` doing filename extension dispatcher -> dynamically linked decoders.\r\n\r\nAnyway, the actual work to implement this in ``ripgrep`` is probably quite minor and the result is something much more general/powerful than the statically encoded list of filename extensions.  I have a personally patched GNU grep that does this and it is very useful to search through PDF collections of papers in various subdirectories and so on, just as one example use case.  I'm sure there are many more -- limited only by one's imagination, and the diversity/entropy of one's collections of files. :-)\r\n\r\nIt might be nice as an optimization to allow the \"binary file\" detection to trigger use of ``RIPGREP_OPEN`` so that it is only invoked when actually needed, although that would block the use case of transforming ordinary text files such as the unidiff patch file example.","closed_by":{"login":"BurntSushi","id":456674,"node_id":"MDQ6VXNlcjQ1NjY3NA==","avatar_url":"https://avatars.githubusercontent.com/u/456674?v=4","gravatar_id":"","url":"https://api.github.com/users/BurntSushi","html_url":"https://github.com/BurntSushi","followers_url":"https://api.github.com/users/BurntSushi/followers","following_url":"https://api.github.com/users/BurntSushi/following{/other_user}","gists_url":"https://api.github.com/users/BurntSushi/gists{/gist_id}","starred_url":"https://api.github.com/users/BurntSushi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/BurntSushi/subscriptions","organizations_url":"https://api.github.com/users/BurntSushi/orgs","repos_url":"https://api.github.com/users/BurntSushi/repos","events_url":"https://api.github.com/users/BurntSushi/events{/privacy}","received_events_url":"https://api.github.com/users/BurntSushi/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/978/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/978/timeline","performed_via_github_app":null,"state_reason":"completed"}