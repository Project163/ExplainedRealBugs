{"url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/990","repository_url":"https://api.github.com/repos/BurntSushi/ripgrep","labels_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/990/labels{/name}","comments_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/990/comments","events_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/990/events","html_url":"https://github.com/BurntSushi/ripgrep/issues/990","id":343356913,"node_id":"MDU6SXNzdWUzNDMzNTY5MTM=","number":990,"title":"read stderr when running external commands","user":{"login":"BurntSushi","id":456674,"node_id":"MDQ6VXNlcjQ1NjY3NA==","avatar_url":"https://avatars.githubusercontent.com/u/456674?v=4","gravatar_id":"","url":"https://api.github.com/users/BurntSushi","html_url":"https://github.com/BurntSushi","followers_url":"https://api.github.com/users/BurntSushi/followers","following_url":"https://api.github.com/users/BurntSushi/following{/other_user}","gists_url":"https://api.github.com/users/BurntSushi/gists{/gist_id}","starred_url":"https://api.github.com/users/BurntSushi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/BurntSushi/subscriptions","organizations_url":"https://api.github.com/users/BurntSushi/orgs","repos_url":"https://api.github.com/users/BurntSushi/repos","events_url":"https://api.github.com/users/BurntSushi/events{/privacy}","received_events_url":"https://api.github.com/users/BurntSushi/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":339721678,"node_id":"MDU6TGFiZWwzMzk3MjE2Nzg=","url":"https://api.github.com/repos/BurntSushi/ripgrep/labels/bug","name":"bug","color":"fc2929","default":true,"description":"A bug."}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2018-07-21T21:24:14Z","updated_at":"2018-09-05T03:18:57Z","closed_at":"2018-09-05T03:18:57Z","author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Some recent features of ripgrep have caused it to defer to external commands to produce output that is then searched. @c-blake notes in #989 that this can be problematic if the external command writes a lot of content to stderr. Namely, since ripgrep connects a pipe to the command's stderr but doesn't actually read from it until the process is finished, then it is possible for the program to fill up the pipe's buffer and result in a deadlock: the child process is waiting to write to stderr while ripgrep is waiting for the child process to finish.\r\n\r\nHere are some solutions to this that I'm aware of, including the ones @c-blake suggests:\r\n\r\n1. Don't fix the problem and just require that external programs redirect stderr to somewhere else.\r\n2. We can stop opening a pipe for stderr, which I believe will result in the external program inheriting ripgrep's stderr.\r\n3. We can redirect stderr to something like `/dev/null`. (This is kind of a riff on (1) I think, because it will just cause folks to redirect stderr somewhere else.)\r\n4. We can implement process execution in a way that reads from stdout and stderr such that no deadlock ever occurs (or available heap is exhausted).\r\n\r\nDo there exist other solutions I'm missing?\r\n\r\nI'm definitely not a huge fan of (3) since I think that makes failure modes harder to discover than they need be.\r\n\r\n(1) is not bad, particularly if the buffer size is large enough by default such that we don't often see this bug in practice. But if the bug does occur, it will be pretty gnarly to diagnose and probably bewildering for end users.\r\n\r\n(2) is decent too. I kind of like this option. It's simple. The only real downside is that the output from the external command and ripgrep's output become disassociated, which can make it difficult to understand the error message and correct it (especially if the file path isn't include in the error message). This could also be problematic for \"chatty\" programs that emit things to stderr, but I suspect such things can typically be quelled by enabling \"quiet\" mode or some such.\r\n\r\n(4) probably provides the best user experience, but is probably also the worst in terms of implementation complexity. I suspect this would require spinning up a thread that reads from stderr. It's not terrible, and it's definitely something that we could encapsulate. We should also be able to do this once for all external commands after a bit of refactoring. This might even be nice as an external crate for others to use. (With that said, are there standard solutions to this problem? If so, is spinning up a new thread the standard portable solution? I guess `select/poll` might work on Linux, but I've never actually written that code before.)","closed_by":{"login":"BurntSushi","id":456674,"node_id":"MDQ6VXNlcjQ1NjY3NA==","avatar_url":"https://avatars.githubusercontent.com/u/456674?v=4","gravatar_id":"","url":"https://api.github.com/users/BurntSushi","html_url":"https://github.com/BurntSushi","followers_url":"https://api.github.com/users/BurntSushi/followers","following_url":"https://api.github.com/users/BurntSushi/following{/other_user}","gists_url":"https://api.github.com/users/BurntSushi/gists{/gist_id}","starred_url":"https://api.github.com/users/BurntSushi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/BurntSushi/subscriptions","organizations_url":"https://api.github.com/users/BurntSushi/orgs","repos_url":"https://api.github.com/users/BurntSushi/repos","events_url":"https://api.github.com/users/BurntSushi/events{/privacy}","received_events_url":"https://api.github.com/users/BurntSushi/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/990/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/BurntSushi/ripgrep/issues/990/timeline","performed_via_github_app":null,"state_reason":"completed"}