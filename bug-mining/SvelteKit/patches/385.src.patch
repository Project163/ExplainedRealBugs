diff --git a/.changeset/swift-ads-itch.md b/.changeset/swift-ads-itch.md
new file mode 100644
index 000000000..92e930b90
--- /dev/null
+++ b/.changeset/swift-ads-itch.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': patch
+---
+
+fix: prevent unhandled exceptions for invalid header values
diff --git a/packages/kit/src/exports/node/index.js b/packages/kit/src/exports/node/index.js
index 2d7414d43..76233e074 100644
--- a/packages/kit/src/exports/node/index.js
+++ b/packages/kit/src/exports/node/index.js
@@ -105,17 +105,25 @@ export async function getRequest({ request, base, bodySizeLimit }) {
 
 /** @type {import('@sveltejs/kit/node').setResponse} */
 export async function setResponse(res, response) {
-	const headers = Object.fromEntries(response.headers);
-
-	if (response.headers.has('set-cookie')) {
-		const header = /** @type {string} */ (response.headers.get('set-cookie'));
-		const split = set_cookie_parser.splitCookiesString(header);
-
-		// @ts-expect-error
-		headers['set-cookie'] = split;
+	for (const [key, value] of response.headers) {
+		try {
+			res.setHeader(
+				key,
+				key === 'set-cookie'
+					? set_cookie_parser.splitCookiesString(
+							// This is absurd but necessary, TODO: investigate why
+							/** @type {string}*/ (response.headers.get(key))
+					  )
+					: value
+			);
+		} catch (error) {
+			res.getHeaderNames().forEach((name) => res.removeHeader(name));
+			res.writeHead(500).end(String(error));
+			return;
+		}
 	}
 
-	res.writeHead(response.status, headers);
+	res.writeHead(response.status);
 
 	if (!response.body) {
 		res.end();
@@ -123,11 +131,10 @@ export async function setResponse(res, response) {
 	}
 
 	if (response.body.locked) {
-		res.write(
+		res.end(
 			'Fatal error: Response body is locked. ' +
 				`This can happen when the response was already read (for example through 'response.json()' or 'response.text()').`
 		);
-		res.end();
 		return;
 	}
 
diff --git a/packages/kit/test/apps/basics/src/routes/endpoint-output/head-write-error/+server.js b/packages/kit/test/apps/basics/src/routes/endpoint-output/head-write-error/+server.js
new file mode 100644
index 000000000..72664eee7
--- /dev/null
+++ b/packages/kit/test/apps/basics/src/routes/endpoint-output/head-write-error/+server.js
@@ -0,0 +1,10 @@
+import { json } from '@sveltejs/kit';
+
+/** @type {import('@sveltejs/kit').RequestHandler} */
+export function GET({ setHeaders }) {
+	setHeaders({
+		'x-test': '\u001f'
+	});
+
+	return json({});
+}
diff --git a/packages/kit/test/apps/basics/test/server.test.js b/packages/kit/test/apps/basics/test/server.test.js
index d6fc639ab..8fcdef16c 100644
--- a/packages/kit/test/apps/basics/test/server.test.js
+++ b/packages/kit/test/apps/basics/test/server.test.js
@@ -177,6 +177,15 @@ test.describe('Endpoints', () => {
 		expect(await response.text()).toEqual(digest);
 	});
 
+	// TODO see above
+	test('invalid headers return a 500', async ({ request }) => {
+		const response = await request.get('/endpoint-output/head-write-error');
+		expect(response.status()).toBe(500);
+		expect(await response.text()).toMatch(
+			'TypeError [ERR_INVALID_CHAR]: Invalid character in header content ["x-test"]'
+		);
+	});
+
 	test('OPTIONS handler', async ({ request }) => {
 		const url = '/endpoint-output/options';
 
@@ -485,7 +494,9 @@ test.describe('setHeaders', () => {
 	test('allows multiple set-cookie headers with different values', async ({ page }) => {
 		const response = await page.goto('/headers/set-cookie/sub');
 		const cookies = (await response?.allHeaders())['set-cookie'];
-		expect(cookies.includes('cookie1=value1') && cookies.includes('cookie2=value2')).toBe(true);
+
+		expect(cookies).toMatch('cookie1=value1');
+		expect(cookies).toMatch('cookie2=value2');
 	});
 });
 
@@ -493,11 +504,10 @@ test.describe('cookies', () => {
 	test('cookie.serialize created correct cookie header string', async ({ page }) => {
 		const response = await page.goto('/cookies/serialize');
 		const cookies = await response.headerValue('set-cookie');
-		expect(
-			cookies.includes('before=before') &&
-				cookies.includes('after=after') &&
-				cookies.includes('endpoint=endpoint')
-		).toBe(true);
+
+		expect(cookies).toMatch('before=before');
+		expect(cookies).toMatch('after=after');
+		expect(cookies).toMatch('endpoint=endpoint');
 	});
 });
 
