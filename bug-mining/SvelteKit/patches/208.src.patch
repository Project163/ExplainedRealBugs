diff --git a/.changeset/khaki-schools-trade.md b/.changeset/khaki-schools-trade.md
new file mode 100644
index 000000000..9ba43de46
--- /dev/null
+++ b/.changeset/khaki-schools-trade.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': patch
+---
+
+[breaking] call beforeNavigate once with type unload on external navigation, rename type 'load' to 'enter' and type 'unload' to 'leave', add 'willUnload' property
diff --git a/packages/kit/src/runtime/client/client.js b/packages/kit/src/runtime/client/client.js
index bd23b87dc..b622af0c4 100644
--- a/packages/kit/src/runtime/client/client.js
+++ b/packages/kit/src/runtime/client/client.js
@@ -79,7 +79,7 @@ export function create_client({ target, base, trailing_slash }) {
 	/** @type {Array<((url: URL) => boolean)>} */
 	const invalidated = [];
 
-	/** @type {{id: string, promise: Promise<import('./types').NavigationResult | undefined>} | null} */
+	/** @type {{id: string, promise: Promise<import('./types').NavigationResult>} | null} */
 	let load_cache = null;
 
 	const callbacks = {
@@ -103,6 +103,9 @@ export function create_client({ target, base, trailing_slash }) {
 	let started = false;
 	let autoscroll = true;
 	let updating = false;
+	let navigating = false;
+	let hash_navigating = false;
+
 	let force_invalidation = false;
 
 	/** @type {import('svelte').SvelteComponent} */
@@ -132,8 +135,6 @@ export function create_client({ target, base, trailing_slash }) {
 		scrollTo(scroll.x, scroll.y);
 	}
 
-	let hash_navigating = false;
-
 	/** @type {import('types').Page} */
 	let page;
 
@@ -389,7 +390,8 @@ export function create_client({ target, base, trailing_slash }) {
 				route: { id: current.route?.id ?? null },
 				url: new URL(location.href)
 			}),
-			type: 'load'
+			willUnload: false,
+			type: 'enter'
 		};
 		callbacks.after_navigate.forEach((fn) => fn(navigation));
 
@@ -711,7 +713,7 @@ export function create_client({ target, base, trailing_slash }) {
 
 	/**
 	 * @param {import('./types').NavigationIntent} intent
-	 * @returns {Promise<import('./types').NavigationResult | undefined>}
+	 * @returns {Promise<import('./types').NavigationResult>}
 	 */
 	async function load_route({ id, invalidating, url, params, route }) {
 		if (load_cache?.id === id) {
@@ -1015,36 +1017,14 @@ export function create_client({ target, base, trailing_slash }) {
 	/**
 	 * @param {{
 	 *   url: URL;
-	 *   scroll: { x: number, y: number } | null;
-	 *   keepfocus: boolean;
-	 *   redirect_chain: string[];
-	 *   details: {
-	 *     replaceState: boolean;
-	 *     state: any;
-	 *   } | null;
 	 *   type: import('types').NavigationType;
+	 *   intent?: import('./types').NavigationIntent;
 	 *   delta?: number;
-	 *   nav_token?: {};
-	 *   accepted: () => void;
-	 *   blocked: () => void;
 	 * }} opts
 	 */
-	async function navigate({
-		url,
-		scroll,
-		keepfocus,
-		redirect_chain,
-		details,
-		type,
-		delta,
-		nav_token,
-		accepted,
-		blocked
-	}) {
+	function before_navigate({ url, type, intent, delta }) {
 		let should_block = false;
 
-		const intent = get_navigation_intent(url, false);
-
 		/** @type {import('types').Navigation} */
 		const navigation = {
 			from: add_url_properties('from', {
@@ -1057,6 +1037,7 @@ export function create_client({ target, base, trailing_slash }) {
 				route: { id: intent?.route?.id ?? null },
 				url
 			}),
+			willUnload: !intent,
 			type
 		};
 
@@ -1073,7 +1054,42 @@ export function create_client({ target, base, trailing_slash }) {
 
 		callbacks.before_navigate.forEach((fn) => fn(cancellable));
 
-		if (should_block) {
+		return should_block ? null : navigation;
+	}
+
+	/**
+	 * @param {{
+	 *   url: URL;
+	 *   scroll: { x: number, y: number } | null;
+	 *   keepfocus: boolean;
+	 *   redirect_chain: string[];
+	 *   details: {
+	 *     replaceState: boolean;
+	 *     state: any;
+	 *   } | null;
+	 *   type: import('types').NavigationType;
+	 *   delta?: number;
+	 *   nav_token?: {};
+	 *   accepted: () => void;
+	 *   blocked: () => void;
+	 * }} opts
+	 */
+	async function navigate({
+		url,
+		scroll,
+		keepfocus,
+		redirect_chain,
+		details,
+		type,
+		delta,
+		nav_token,
+		accepted,
+		blocked
+	}) {
+		const intent = get_navigation_intent(url, false);
+		const navigation = before_navigate({ url, type, delta, intent });
+
+		if (!navigation) {
 			blocked();
 			return;
 		}
@@ -1082,6 +1098,8 @@ export function create_client({ target, base, trailing_slash }) {
 
 		accepted();
 
+		navigating = true;
+
 		if (started) {
 			stores.navigating.set(navigation);
 		}
@@ -1097,6 +1115,7 @@ export function create_client({ target, base, trailing_slash }) {
 			},
 			nav_token,
 			() => {
+				navigating = false;
 				callbacks.after_navigate.forEach((fn) => fn(navigation));
 				stores.navigating.set(null);
 			}
@@ -1285,19 +1304,24 @@ export function create_client({ target, base, trailing_slash }) {
 			addEventListener('beforeunload', (e) => {
 				let should_block = false;
 
-				/** @type {import('types').Navigation & { cancel: () => void }} */
-				const navigation = {
-					from: add_url_properties('from', {
-						params: current.params,
-						route: { id: current.route?.id ?? null },
-						url: current.url
-					}),
-					to: null,
-					type: 'unload',
-					cancel: () => (should_block = true)
-				};
+				if (!navigating) {
+					// If we're navigating, beforeNavigate was already called. If we end up in here during navigation,
+					// it's due to an external or full-page-reload link, for which we don't want to call the hook again.
+					/** @type {import('types').Navigation & { cancel: () => void }} */
+					const navigation = {
+						from: add_url_properties('from', {
+							params: current.params,
+							route: { id: current.route?.id ?? null },
+							url: current.url
+						}),
+						to: null,
+						willUnload: true,
+						type: 'leave',
+						cancel: () => (should_block = true)
+					};
 
-				callbacks.before_navigate.forEach((fn) => fn(navigation));
+					callbacks.before_navigate.forEach((fn) => fn(navigation));
+				}
 
 				if (should_block) {
 					e.preventDefault();
@@ -1375,18 +1399,23 @@ export function create_client({ target, base, trailing_slash }) {
 				)
 					return;
 
-				// Ignore if tag has
-				// 1. 'download' attribute
-				// 2. 'rel' attribute includes external
-				const rel = (a.getAttribute('rel') || '').split(/\s+/);
+				if (a.hasAttribute('download')) return;
 
-				if (a.hasAttribute('download') || rel.includes('external') || options.reload) {
+				// Ignore the following but fire beforeNavigate
+				const rel = (a.getAttribute('rel') || '').split(/\s+/);
+				if (
+					rel.includes('external') ||
+					options.reload ||
+					(is_svg_a_element ? a.target.baseVal : a.target)
+				) {
+					const navigation = before_navigate({ url, type: 'link' });
+					if (!navigation) {
+						event.preventDefault();
+					}
+					navigating = true;
 					return;
 				}
 
-				// Ignore if <a> has a target
-				if (is_svg_a_element ? a.target.baseVal : a.target) return;
-
 				// Check if new url only differs by hash and use the browser default behavior in that case
 				// This will ensure the `hashchange` event is fired
 				// Removing the hash does a full page navigation in the browser, so make sure a hash is present
diff --git a/packages/kit/src/runtime/server/data/index.js b/packages/kit/src/runtime/server/data/index.js
index 2acb3b7ea..707adf859 100644
--- a/packages/kit/src/runtime/server/data/index.js
+++ b/packages/kit/src/runtime/server/data/index.js
@@ -1,4 +1,3 @@
-import * as devalue from 'devalue';
 import { HttpError, Redirect } from '../../control.js';
 import { normalize_error } from '../../../utils/error.js';
 import { once } from '../../../utils/functions.js';
diff --git a/packages/kit/src/runtime/server/page/index.js b/packages/kit/src/runtime/server/page/index.js
index b2923cca2..5ccdbc213 100644
--- a/packages/kit/src/runtime/server/page/index.js
+++ b/packages/kit/src/runtime/server/page/index.js
@@ -1,4 +1,3 @@
-import * as devalue from 'devalue';
 import { compact } from '../../../utils/array.js';
 import { normalize_error } from '../../../utils/error.js';
 import { add_data_suffix } from '../../../utils/url.js';
diff --git a/packages/kit/test/apps/basics/src/routes/before-navigate/prevent-navigation/+page.svelte b/packages/kit/test/apps/basics/src/routes/before-navigate/prevent-navigation/+page.svelte
index 4d64f38da..829056d1f 100644
--- a/packages/kit/test/apps/basics/src/routes/before-navigate/prevent-navigation/+page.svelte
+++ b/packages/kit/test/apps/basics/src/routes/before-navigate/prevent-navigation/+page.svelte
@@ -2,12 +2,17 @@
 	import { beforeNavigate } from '$app/navigation';
 
 	let triggered = false;
-	beforeNavigate(({ cancel }) => {
+	let unload = false;
+	let navigation_type;
+	beforeNavigate(({ cancel, type, willUnload }) => {
 		triggered = true;
+		unload = willUnload;
+		navigation_type = type;
 		cancel();
 	});
 </script>
 
 <h1>prevent navigation</h1>
 <a href="/before-navigate/a">a</a>
-<pre>{triggered}</pre>
+<a href="https://google.de">external</a>
+<pre>{triggered} {unload} {navigation_type}</pre>
diff --git a/packages/kit/test/apps/basics/test/client.test.js b/packages/kit/test/apps/basics/test/client.test.js
index 7240b6d23..9d82bfccf 100644
--- a/packages/kit/test/apps/basics/test/client.test.js
+++ b/packages/kit/test/apps/basics/test/client.test.js
@@ -15,14 +15,33 @@ test.describe('beforeNavigate', () => {
 		await page.waitForLoadState('networkidle');
 
 		expect(page.url()).toBe(baseURL + '/before-navigate/prevent-navigation');
-		expect(await page.innerHTML('pre')).toBe('true');
+		expect(await page.innerHTML('pre')).toBe('true false link');
+	});
+
+	test('prevents navigation to external', async ({ page, baseURL }) => {
+		await page.goto('/before-navigate/prevent-navigation');
+		await page.click('h1'); // The browsers block attempts to prevent navigation on a frame that's never had a user gesture.
+
+		page.on('dialog', (dialog) => dialog.dismiss());
+
+		page.click('a[href="https://google.de"]'); // do NOT await this, promise only resolves after successful navigation, which never happens
+		await page.waitForTimeout(500);
+		await expect(page.locator('pre')).toHaveText('true true link');
+		expect(page.url()).toBe(baseURL + '/before-navigate/prevent-navigation');
 	});
 
 	test('prevents navigation triggered by goto', async ({ page, app, baseURL }) => {
 		await page.goto('/before-navigate/prevent-navigation');
 		await app.goto('/before-navigate/a');
 		expect(page.url()).toBe(baseURL + '/before-navigate/prevent-navigation');
-		expect(await page.innerHTML('pre')).toBe('true');
+		expect(await page.innerHTML('pre')).toBe('true false goto');
+	});
+
+	test('prevents external navigation triggered by goto', async ({ page, app, baseURL }) => {
+		await page.goto('/before-navigate/prevent-navigation');
+		await app.goto('https://google.de');
+		expect(page.url()).toBe(baseURL + '/before-navigate/prevent-navigation');
+		expect(await page.innerHTML('pre')).toBe('true true goto');
 	});
 
 	test('prevents navigation triggered by back button', async ({ page, app, baseURL }) => {
@@ -31,7 +50,7 @@ test.describe('beforeNavigate', () => {
 		await page.click('h1'); // The browsers block attempts to prevent navigation on a frame that's never had a user gesture.
 
 		await page.goBack();
-		expect(await page.innerHTML('pre')).toBe('true');
+		expect(await page.innerHTML('pre')).toBe('true false popstate');
 		expect(page.url()).toBe(baseURL + '/before-navigate/prevent-navigation');
 	});
 
@@ -47,6 +66,7 @@ test.describe('beforeNavigate', () => {
 
 		await page.close({ runBeforeUnload: true });
 		expect(await type).toBe('beforeunload');
+		expect(await page.innerHTML('pre')).toBe('true true leave');
 	});
 });
 
diff --git a/packages/kit/types/ambient.d.ts b/packages/kit/types/ambient.d.ts
index c211eb0a8..bc96b872e 100644
--- a/packages/kit/types/ambient.d.ts
+++ b/packages/kit/types/ambient.d.ts
@@ -257,7 +257,7 @@ declare module '$app/navigation' {
 	 * A navigation interceptor that triggers before we navigate to a new URL, whether by clicking a link, calling `goto(...)`, or using the browser back/forward controls.
 	 * Calling `cancel()` will prevent the navigation from completing.
 	 *
-	 * When navigating to an external URL, `navigation.to` will be `null`.
+	 * When a navigation isn't client side, `navigation.to.routeId` will be `null`.
 	 *
 	 * `beforeNavigate` must be called during a component initialization. It remains active as long as the component is mounted.
 	 */
diff --git a/packages/kit/types/index.d.ts b/packages/kit/types/index.d.ts
index 3608b3030..a690057eb 100644
--- a/packages/kit/types/index.d.ts
+++ b/packages/kit/types/index.d.ts
@@ -394,12 +394,40 @@ export interface NavigationTarget {
 	url: URL;
 }
 
-export type NavigationType = 'load' | 'unload' | 'link' | 'goto' | 'popstate';
+/**
+ * - `enter`: The app has hydrated
+ * - `leave`: The user is leaving the app by closing the tab or using the back/forward buttons to go to a different document
+ * - `link`: Navigation was triggered by a link click
+ * - `goto`: Navigation was triggered by a `goto(...)` call or a redirect
+ * - `popstate`: Navigation was triggered by back/forward navigation
+ */
+export type NavigationType = 'enter' | 'leave' | 'link' | 'goto' | 'popstate';
 
 export interface Navigation {
+	/**
+	 * Where navigation was triggered from
+	 */
 	from: NavigationTarget | null;
+	/**
+	 * Where navigation is going to/has gone to
+	 */
 	to: NavigationTarget | null;
+	/**
+	 * The type of navigation:
+	 * - `enter`: The app has hydrated
+	 * - `leave`: The user is leaving the app by closing the tab or using the back/forward buttons to go to a different document
+	 * - `link`: Navigation was triggered by a link click
+	 * - `goto`: Navigation was triggered by a `goto(...)` call or a redirect
+	 * - `popstate`: Navigation was triggered by back/forward navigation
+	 */
 	type: NavigationType;
+	/**
+	 * Whether or not the navigation will result in the page being unloaded (i.e. not a client-side navigation)
+	 */
+	willUnload: boolean;
+	/**
+	 * In case of a history back/forward navigation, the number of steps to go back/forward
+	 */
 	delta?: number;
 }
 
