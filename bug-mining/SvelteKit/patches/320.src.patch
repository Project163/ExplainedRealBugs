diff --git a/.changeset/lemon-vans-call.md b/.changeset/lemon-vans-call.md
new file mode 100644
index 000000000..3f5f9d749
--- /dev/null
+++ b/.changeset/lemon-vans-call.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': patch
+---
+
+fix: focus management after navigation
diff --git a/packages/kit/src/runtime/client/client.js b/packages/kit/src/runtime/client/client.js
index 5d61d730c..c3fb0bbc2 100644
--- a/packages/kit/src/runtime/client/client.js
+++ b/packages/kit/src/runtime/client/client.js
@@ -326,13 +326,22 @@ export function create_client({ target, base }) {
 		// opts must be passed if we're navigating
 		if (opts) {
 			const { scroll, keepfocus } = opts;
+			const { activeElement } = document;
 
-			// reset focus first, so that manual focus management can override it
-			if (!keepfocus) reset_focus();
-
-			// need to render the DOM before we can scroll to the rendered elements
+			// need to render the DOM before we can scroll to the rendered elements and do focus management
 			await tick();
 
+			const changed_focus =
+				// reset focus only if any manual focus management didn't override it
+				document.activeElement !== activeElement &&
+				// also refocus when activeElement is body already because the
+				// focus event might not have been fired on it yet
+				document.activeElement !== document.body;
+
+			if (!keepfocus && !changed_focus) {
+				await reset_focus();
+			}
+
 			if (autoscroll) {
 				const deep_linked = url.hash && document.getElementById(url.hash.slice(1));
 				if (scroll) {
@@ -1718,16 +1727,19 @@ function reset_focus() {
 		root.tabIndex = -1;
 		root.focus({ preventScroll: true });
 
-		setTimeout(() => {
-			getSelection()?.removeAllRanges();
-		});
-
 		// restore `tabindex` as to prevent `root` from stealing input from elements
 		if (tabindex !== null) {
 			root.setAttribute('tabindex', tabindex);
 		} else {
 			root.removeAttribute('tabindex');
 		}
+
+		return new Promise((resolve) => {
+			setTimeout(() => {
+				// fixes https://github.com/sveltejs/kit/issues/8439
+				resolve(getSelection()?.removeAllRanges());
+			});
+		});
 	}
 }
 
diff --git a/packages/kit/test/apps/basics/src/routes/accessibility/autofocus/+layout.svelte b/packages/kit/test/apps/basics/src/routes/accessibility/autofocus/+layout.svelte
index 0ba5a8399..394596331 100644
--- a/packages/kit/test/apps/basics/src/routes/accessibility/autofocus/+layout.svelte
+++ b/packages/kit/test/apps/basics/src/routes/accessibility/autofocus/+layout.svelte
@@ -2,3 +2,5 @@
 
 <!-- svelte-ignore a11y-autofocus -->
 <input autofocus />
+
+<a href="/">Home</a>
diff --git a/packages/kit/test/apps/basics/test/cross-browser/client.test.js b/packages/kit/test/apps/basics/test/cross-browser/client.test.js
index babff5f30..37b2fe1dd 100644
--- a/packages/kit/test/apps/basics/test/cross-browser/client.test.js
+++ b/packages/kit/test/apps/basics/test/cross-browser/client.test.js
@@ -91,11 +91,24 @@ test.describe('a11y', () => {
 		await page.goto('/keepfocus');
 
 		await Promise.all([
-			page.locator('#input').fill('bar'),
+			page.type('#input', 'bar'),
 			page.waitForFunction(() => window.location.search === '?foo=bar')
 		]);
 		await expect(page.locator('#input')).toBeFocused();
 	});
+
+	test('autofocus from previous page is ignored', async ({ page, clicknav }) => {
+		page.addInitScript(`
+			window.active = null;
+			window.addEventListener('focusin', () => window.active = document.activeElement);
+		`);
+
+		await page.goto('/accessibility/autofocus/a');
+		await clicknav('[href="/"]');
+
+		expect(await page.evaluate(() => (window.active || {}).nodeName)).toBe('BODY');
+		expect(await page.evaluate(() => (document.activeElement || {}).nodeName)).toBe('BODY');
+	});
 });
 
 test.describe('beforeNavigate', () => {
