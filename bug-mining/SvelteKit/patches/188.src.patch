diff --git a/.changeset/clean-jars-float.md b/.changeset/clean-jars-float.md
new file mode 100644
index 000000000..051d798e9
--- /dev/null
+++ b/.changeset/clean-jars-float.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': patch
+---
+
+[breaking] throw error when routes conflict
diff --git a/.changeset/tender-schools-cover.md b/.changeset/tender-schools-cover.md
new file mode 100644
index 000000000..7ceaf6228
--- /dev/null
+++ b/.changeset/tender-schools-cover.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': patch
+---
+
+[feat] implement optional route params
diff --git a/documentation/docs/04-advanced-routing.md b/documentation/docs/04-advanced-routing.md
index 687f3cd7b..021bfcd06 100644
--- a/documentation/docs/04-advanced-routing.md
+++ b/documentation/docs/04-advanced-routing.md
@@ -63,6 +63,12 @@ export function load(event) {
 
 > If you don't handle 404 cases, they will appear in [`handleError`](/docs/hooks#shared-hooks-handleerror)
 
+### Optional parameters
+
+A route like `[lang]/home` contains a parameter named `lang` which is required. Sometimes it's beneficial to make these parameters optional, so that in this example both `home` and `en/home` point to the same page. You can do that by wrapping the parameter in another bracket pair: `[[lang]]/home`
+
+Note that an optional route parameter cannot follow a rest parameter (`[...rest]/[[optional]]`), since parameters are matched 'greedily' and the optional parameter would always be unused.
+
 ### Matching
 
 A route like `src/routes/archive/[page]` would match `/archive/3`, but it would also match `/archive/potato`. We don't want that. You can ensure that route parameters are well-formed by adding a _matcher_ — which takes the parameter string (`"3"` or `"potato"`) and returns `true` if it is valid — to your [`params`](/docs/configuration#files) directory...
@@ -92,7 +98,7 @@ It's possible for multiple routes to match a given path. For example each of the
 
 ```bash
 src/routes/[...catchall]/+page.svelte
-src/routes/[a]/+server.js
+src/routes/[[a]]/foo/+page.svelte
 src/routes/[b]/+page.svelte
 src/routes/foo-[c]/+page.svelte
 src/routes/foo-abc/+page.svelte
@@ -101,9 +107,8 @@ src/routes/foo-abc/+page.svelte
 SvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...
 
 - More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on)
-- `+server` files have higher priority than `+page` files
 - Parameters with [matchers](#matching) (`[name=type]`) are higher priority than those without (`[name]`)
-- Rest parameters have lowest priority
+- `[[optional]]` and `[...rest]` parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words `x/[[y]]/z` is treated equivalently to `x/z` for the purposes of sorting
 - Ties are resolved alphabetically
 
 ...resulting in this ordering, meaning that `/foo-abc` will invoke `src/routes/foo-abc/+page.svelte`, and `/foo-def` will invoke `src/routes/foo-[c]/+page.svelte` rather than less specific routes:
@@ -111,7 +116,7 @@ SvelteKit needs to know which route is being requested. To do so, it sorts them
 ```bash
 src/routes/foo-abc/+page.svelte
 src/routes/foo-[c]/+page.svelte
-src/routes/[a]/+server.js
+src/routes/[[a]]/foo/+page.svelte
 src/routes/[b]/+page.svelte
 src/routes/[...catchall]/+page.svelte
 ```
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/(foo)/(bar)/[...all]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/conflict.js
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/(foo)/(bar)/[...all]/+page.svelte
rename to packages/kit/src/core/sync/create_manifest_data/conflict.js
diff --git a/packages/kit/src/core/sync/create_manifest_data/index.js b/packages/kit/src/core/sync/create_manifest_data/index.js
index 852a02a86..ad30f046f 100644
--- a/packages/kit/src/core/sync/create_manifest_data/index.js
+++ b/packages/kit/src/core/sync/create_manifest_data/index.js
@@ -3,7 +3,8 @@ import path from 'path';
 import mime from 'mime';
 import { runtime_directory } from '../../utils.js';
 import { posixify } from '../../../utils/filesystem.js';
-import { parse_route_id, affects_path } from '../../../utils/routing.js';
+import { parse_route_id } from '../../../utils/routing.js';
+import { sort_routes } from './sort.js';
 
 /**
  * @param {{
@@ -82,11 +83,8 @@ function create_matchers(config, cwd) {
  * @param {string} fallback
  */
 function create_routes_and_nodes(cwd, config, fallback) {
-	/** @type {Map<string, import('types').RouteData>} */
-	const route_map = new Map();
-
-	/** @type {Map<string, import('./types').Part[][]>} */
-	const segment_map = new Map();
+	/** @type {import('types').RouteData[]} */
+	const routes = [];
 
 	const routes_base = posixify(path.relative(cwd, config.kit.files.routes));
 
@@ -111,32 +109,19 @@ function create_routes_and_nodes(cwd, config, fallback) {
 				throw new Error(`Invalid route ${id} — brackets are unbalanced`);
 			}
 
-			const { pattern, names, types } = parse_route_id(id);
+			if (/\[\.\.\.\w+\]\/\[\[/.test(id)) {
+				throw new Error(
+					`Invalid route ${id} — an [[optional]] route segment cannot follow a [...rest] route segment`
+				);
+			}
 
-			const segments = id.split('/');
+			if (/\[\[\.\.\./.test(id)) {
+				throw new Error(
+					`Invalid route ${id} — a rest route segment is always optional, remove the outer square brackets`
+				);
+			}
 
-			segment_map.set(
-				id,
-				segments
-					.filter((segment) => segment !== '' && affects_path(segment))
-					.map((segment) => {
-						/** @type {import('./types').Part[]} */
-						const parts = [];
-						segment.split(/\[(.+?)\]/).map((content, i) => {
-							const dynamic = !!(i % 2);
-
-							if (!content) return;
-
-							parts.push({
-								content,
-								dynamic,
-								rest: dynamic && content.startsWith('...'),
-								type: (dynamic && content.split('=')[1]) || null
-							});
-						});
-						return parts;
-					})
-			);
+			const { pattern, names, types } = parse_route_id(id);
 
 			/** @type {import('types').RouteData} */
 			const route = {
@@ -157,7 +142,7 @@ function create_routes_and_nodes(cwd, config, fallback) {
 
 			// important to do this before walking children, so that child
 			// routes appear later
-			route_map.set(id, route);
+			routes.push(route);
 
 			// if we don't do this, the route map becomes unwieldy to console.log
 			Object.defineProperty(route, 'parent', { enumerable: false });
@@ -224,8 +209,8 @@ function create_routes_and_nodes(cwd, config, fallback) {
 
 		walk(0, '', '', null);
 
-		const root = /** @type {import('types').RouteData} */ (route_map.get(''));
-		if (route_map.size === 1) {
+		if (routes.length === 1) {
+			const root = routes[0];
 			if (!root.leaf && !root.error && !root.layout && !root.endpoint) {
 				throw new Error(
 					// TODO adjust this error message for 1.0
@@ -237,7 +222,7 @@ function create_routes_and_nodes(cwd, config, fallback) {
 	} else {
 		// If there's no routes directory, we'll just create a single empty route. This ensures the root layout and
 		// error components are included in the manifest, which is needed for subsequent build/dev commands to work
-		route_map.set('', {
+		routes.push({
 			id: '',
 			segment: '',
 			pattern: /^$/,
@@ -252,7 +237,9 @@ function create_routes_and_nodes(cwd, config, fallback) {
 		});
 	}
 
-	const root = /** @type {import('types').RouteData} */ (route_map.get(''));
+	prevent_conflicts(routes);
+
+	const root = routes[0];
 
 	if (!root.layout?.component) {
 		if (!root.layout) root.layout = { depth: 0, child_pages: [] };
@@ -267,32 +254,19 @@ function create_routes_and_nodes(cwd, config, fallback) {
 	// we do layouts/errors first as they are more likely to be reused,
 	// and smaller indexes take fewer bytes. also, this guarantees that
 	// the default error/layout are 0/1
-	route_map.forEach((route) => {
+	for (const route of routes) {
 		if (route.layout) nodes.push(route.layout);
 		if (route.error) nodes.push(route.error);
-	});
-
-	/** @type {Map<string, string>} */
-	const conflicts = new Map();
-
-	route_map.forEach((route) => {
-		if (!route.leaf) return;
-
-		nodes.push(route.leaf);
-
-		const normalized = route.id.split('/').filter(affects_path).join('/');
-
-		if (conflicts.has(normalized)) {
-			throw new Error(`${conflicts.get(normalized)} and ${route.id} occupy the same route`);
-		}
+	}
 
-		conflicts.set(normalized, route.id);
-	});
+	for (const route of routes) {
+		if (route.leaf) nodes.push(route.leaf);
+	}
 
 	const indexes = new Map(nodes.map((node, i) => [node, i]));
 
-	route_map.forEach((route) => {
-		if (!route.leaf) return;
+	for (const route of routes) {
+		if (!route.leaf) continue;
 
 		route.page = {
 			layouts: [],
@@ -333,11 +307,12 @@ function create_routes_and_nodes(cwd, config, fallback) {
 		if (parent_id !== undefined) {
 			throw new Error(`${current_node.component} references missing segment "${parent_id}"`);
 		}
-	});
-
-	const routes = Array.from(route_map.values()).sort((a, b) => compare(a, b, segment_map));
+	}
 
-	return { nodes, routes };
+	return {
+		nodes,
+		routes: sort_routes(routes)
+	};
 }
 
 /**
@@ -400,59 +375,6 @@ function analyze(project_relative, file, component_extensions, module_extensions
 	throw new Error(`Files and directories prefixed with + are reserved (saw ${project_relative})`);
 }
 
-/**
- * @param {import('types').RouteData} a
- * @param {import('types').RouteData} b
- * @param {Map<string, import('./types').Part[][]>} segment_map
- */
-function compare(a, b, segment_map) {
-	const a_segments = /** @type {import('./types').Part[][]} */ (segment_map.get(a.id));
-	const b_segments = /** @type {import('./types').Part[][]} */ (segment_map.get(b.id));
-
-	const max_segments = Math.max(a_segments.length, b_segments.length);
-	for (let i = 0; i < max_segments; i += 1) {
-		const sa = a_segments[i];
-		const sb = b_segments[i];
-
-		// /x < /x/y, but /[...x]/y < /[...x]
-		if (!sa) return a.id.includes('[...') ? +1 : -1;
-		if (!sb) return b.id.includes('[...') ? -1 : +1;
-
-		const max_parts = Math.max(sa.length, sb.length);
-		for (let i = 0; i < max_parts; i += 1) {
-			const pa = sa[i];
-			const pb = sb[i];
-
-			// xy < x[y], but [x].json < [x]
-			if (pa === undefined) return pb.dynamic ? -1 : +1;
-			if (pb === undefined) return pa.dynamic ? +1 : -1;
-
-			// x < [x]
-			if (pa.dynamic !== pb.dynamic) {
-				return pa.dynamic ? +1 : -1;
-			}
-
-			if (pa.dynamic) {
-				// [x] < [...x]
-				if (pa.rest !== pb.rest) {
-					return pa.rest ? +1 : -1;
-				}
-
-				// [x=type] < [x]
-				if (!!pa.type !== !!pb.type) {
-					return pa.type ? -1 : +1;
-				}
-			}
-		}
-	}
-
-	if (!!a.endpoint !== !!b.endpoint) {
-		return a.endpoint ? -1 : +1;
-	}
-
-	return a < b ? -1 : 1;
-}
-
 /** @param {string} dir */
 function list_files(dir) {
 	/** @type {string[]} */
@@ -486,3 +408,63 @@ function count_occurrences(needle, haystack) {
 	}
 	return count;
 }
+
+/** @param {import('types').RouteData[]} routes */
+function prevent_conflicts(routes) {
+	/** @type {Map<string, string>} */
+	const lookup = new Map();
+
+	for (const route of routes) {
+		if (!route.leaf && !route.endpoint) continue;
+
+		const normalized = normalize_route_id(route.id);
+
+		// find all permutations created by optional parameters
+		const split = normalized.split(/<\?(.+?)\>/g);
+
+		let permutations = [/** @type {string} */ (split[0])];
+
+		// turn `x/[[optional]]/y` into `x/y` and `x/[required]/y`
+		for (let i = 1; i < split.length; i += 2) {
+			const matcher = split[i];
+			const next = split[i + 1];
+
+			permutations = [
+				...permutations.map((x) => x + next),
+				...permutations.map((x) => x + `<${matcher}>${next}`)
+			];
+		}
+
+		for (const permutation of permutations) {
+			// remove leading/trailing/duplicated slashes caused by prior
+			// manipulation of optional parameters and (groups)
+			const key = permutation
+				.replace(/\/{2,}/, '/')
+				.replace(/^\//, '')
+				.replace(/\/$/, '');
+
+			if (lookup.has(key)) {
+				throw new Error(
+					`The "${lookup.get(key)}" and "${route.id}" routes conflict with each other`
+				);
+			}
+
+			lookup.set(key, route.id);
+		}
+	}
+}
+
+/** @param {string} id */
+function normalize_route_id(id) {
+	return (
+		id
+			// remove groups
+			.replace(/(?<=^|\/)\(.+?\)(?=$|\/)/g, '')
+
+			// replace `[param]` with `<*>`, `[param=x]` with `<x>`, and `[[param]]` with `<?*>`
+			.replace(
+				/\[(?:(\[)|(\.\.\.))?.+?(=.+?)?\]\]?/g,
+				(_, optional, rest, matcher) => `<${optional ? '?' : ''}${rest ?? ''}${matcher ?? '*'}>`
+			)
+	);
+}
diff --git a/packages/kit/src/core/sync/create_manifest_data/index.spec.js b/packages/kit/src/core/sync/create_manifest_data/index.spec.js
index 031071a4d..3c5ca665c 100644
--- a/packages/kit/src/core/sync/create_manifest_data/index.spec.js
+++ b/packages/kit/src/core/sync/create_manifest_data/index.spec.js
@@ -5,6 +5,7 @@ import { test } from 'uvu';
 import * as assert from 'uvu/assert';
 import create_manifest_data from './index.js';
 import options from '../../config/options.js';
+import { sort_routes } from './sort.js';
 
 const cwd = fileURLToPath(new URL('./test', import.meta.url));
 
@@ -79,25 +80,21 @@ test('creates routes', () => {
 			pattern: '/^/$/',
 			page: { layouts: [0], errors: [1], leaf: 2 }
 		},
-
-		{
-			id: 'blog.json',
-			pattern: '/^/blog.json$/',
-			endpoint: { file: 'samples/basic/blog.json/+server.js' }
-		},
-
 		{
 			id: 'about',
 			pattern: '/^/about/?$/',
 			page: { layouts: [0], errors: [1], leaf: 3 }
 		},
-
+		{
+			id: 'blog.json',
+			pattern: '/^/blog.json$/',
+			endpoint: { file: 'samples/basic/blog.json/+server.js' }
+		},
 		{
 			id: 'blog',
 			pattern: '/^/blog/?$/',
 			page: { layouts: [0], errors: [1], leaf: 4 }
 		},
-
 		{
 			id: 'blog/[slug].json',
 			pattern: '/^/blog/([^/]+?).json$/',
@@ -105,7 +102,6 @@ test('creates routes', () => {
 				file: 'samples/basic/blog/[slug].json/+server.ts'
 			}
 		},
-
 		{
 			id: 'blog/[slug]',
 			pattern: '/^/blog/([^/]+?)/?$/',
@@ -215,36 +211,44 @@ test('encodes invalid characters', () => {
 });
 
 test('sorts routes correctly', () => {
-	const { routes } = create('samples/sorting');
-
-	assert.equal(
-		routes.map((p) => p.id),
-		[
-			'',
-			'(foo)',
-			'(foo)/(bar)',
-			'about',
-			'foo',
-			'post',
-			'post/bar',
-			'post/foo',
-			'post/f[yy].json',
-			'post/f[zz]',
-			'post/f[xx]',
-			'post/f[yy]',
-			'foo/[bar]',
-			'post/[id]',
-			'[endpoint]',
-			'[wildcard]',
-			'[...rest]/deep/[...deep_rest]/xyz',
-			'[...rest]/deep/[...deep_rest]',
-			'[...rest]/abc',
-			'[...rest]/deep',
-			'(foo)/(bar)/[...all]',
-			'[...anotherrest]',
-			'[...rest]'
-		]
+	const expected = [
+		'',
+		'a',
+		'b',
+		'b/[required]',
+		'c',
+		'c/bar',
+		'c/b[x].json',
+		'c/b[x]',
+		'c/foo',
+		'd/e',
+		'd/e[...rest]',
+		'e/f',
+		'e/[...rest]/f',
+		'f/static[...rest]',
+		'f/[...rest]static',
+		'g/[[optional]]/static',
+		'g/[required]',
+		'g/[...rest]/[required]',
+		'h/a/b',
+		'h/a/[required]/b',
+		'h/a/[...rest]/b',
+		'x/[...rest]',
+		'[...rest]/x',
+		'[...rest]/x/[...deep_rest]/y',
+		'[...rest]/x/[...deep_rest]',
+		'[required=matcher]',
+		'[required]',
+		'[...rest]'
+	];
+
+	const routes = /** @type {import('types').RouteData[]} */ (expected.map((id) => ({ id })));
+
+	const actual = sort_routes(routes.sort(() => (Math.random() > 0.5 ? 1 : -1))).map(
+		(route) => route.id
 	);
+
+	assert.equal(actual, expected);
 });
 
 test('sorts routes with rest correctly', () => {
@@ -272,15 +276,15 @@ test('sorts routes with rest correctly', () => {
 			id: 'a',
 			pattern: '/^/a/?$/'
 		},
-		{
-			id: 'b',
-			pattern: '/^/b/?$/'
-		},
 		{
 			id: 'a/[...rest]',
 			pattern: '/^/a(?:/(.*))?/?$/',
 			page: { layouts: [0], errors: [1], leaf: 2 }
 		},
+		{
+			id: 'b',
+			pattern: '/^/b/?$/'
+		},
 		{
 			id: 'b/[...rest]',
 			pattern: '/^/b(?:/(.*))?/?$/',
@@ -320,6 +324,76 @@ test('allows rest parameters inside segments', () => {
 	]);
 });
 
+test('optional parameters', () => {
+	const { nodes, routes } = create('samples/optional');
+
+	assert.equal(
+		nodes
+			.map(simplify_node)
+			// for some reason linux and windows have a different order, which is why
+			// we need sort the nodes using a sort function (doesn't work either without),
+			// resulting in the following expected node order
+			.sort((a, b) => a.component?.localeCompare(b.component ?? '') ?? 1),
+		[
+			default_error,
+			default_layout,
+			{
+				component: 'samples/optional/[[optional]]/+page.svelte'
+			},
+			{
+				component: 'samples/optional/nested/[[optional]]/sub/+page.svelte'
+			},
+			{
+				component: 'samples/optional/prefix[[suffix]]/+page.svelte'
+			}
+		]
+	);
+
+	assert.equal(routes.map(simplify_route), [
+		{
+			id: '',
+			pattern: '/^/$/'
+		},
+		{
+			id: '[[foo]]bar',
+			pattern: '/^/([^/]*)?bar/?$/',
+			endpoint: { file: 'samples/optional/[[foo]]bar/+server.js' }
+		},
+		{ id: 'nested', pattern: '/^/nested/?$/' },
+		{
+			id: 'nested/[[optional]]/sub',
+			pattern: '/^/nested(?:/([^/]+))?/sub/?$/',
+			page: {
+				layouts: [0],
+				errors: [1],
+				// see above, linux/windows difference -> find the index dynamically
+				leaf: nodes.findIndex((node) => node.component?.includes('nested/[[optional]]'))
+			}
+		},
+		{ id: 'nested/[[optional]]', pattern: '/^/nested(?:/([^/]+))?/?$/' },
+		{
+			id: 'prefix[[suffix]]',
+			pattern: '/^/prefix([^/]*)?/?$/',
+			page: {
+				layouts: [0],
+				errors: [1],
+				// see above, linux/windows difference -> find the index dynamically
+				leaf: nodes.findIndex((node) => node.component?.includes('prefix[[suffix]]'))
+			}
+		},
+		{
+			id: '[[optional]]',
+			pattern: '/^(?:/([^/]+))?/?$/',
+			page: {
+				layouts: [0],
+				errors: [1],
+				// see above, linux/windows difference -> find the index dynamically
+				leaf: nodes.findIndex((node) => node.component?.includes('optional/[[optional]]'))
+			}
+		}
+	]);
+});
+
 test('ignores files and directories with leading underscores', () => {
 	const { routes } = create('samples/hidden-underscore');
 
@@ -394,7 +468,11 @@ test('works with custom extensions', () => {
 			pattern: '/^/$/',
 			page: { layouts: [0], errors: [1], leaf: 2 }
 		},
-
+		{
+			id: 'about',
+			pattern: '/^/about/?$/',
+			page: { layouts: [0], errors: [1], leaf: 3 }
+		},
 		{
 			id: 'blog.json',
 			pattern: '/^/blog.json$/',
@@ -402,19 +480,11 @@ test('works with custom extensions', () => {
 				file: 'samples/custom-extension/blog.json/+server.js'
 			}
 		},
-
-		{
-			id: 'about',
-			pattern: '/^/about/?$/',
-			page: { layouts: [0], errors: [1], leaf: 3 }
-		},
-
 		{
 			id: 'blog',
 			pattern: '/^/blog/?$/',
 			page: { layouts: [0], errors: [1], leaf: 4 }
 		},
-
 		{
 			id: 'blog/[slug].json',
 			pattern: '/^/blog/([^/]+?).json$/',
@@ -422,7 +492,6 @@ test('works with custom extensions', () => {
 				file: 'samples/custom-extension/blog/[slug].json/+server.js'
 			}
 		},
-
 		{
 			id: 'blog/[slug]',
 			pattern: '/^/blog/([^/]+?)/?$/',
@@ -515,20 +584,15 @@ test('creates routes with named layouts', () => {
 	]);
 
 	assert.equal(routes.filter((route) => route.page).map(simplify_route), [
-		{
-			id: '(special)/a/a2',
-			pattern: '/^/a/a2/?$/',
-			page: { layouts: [0, 2], errors: [1, undefined], leaf: 9 }
-		},
 		{
 			id: 'a/a1',
 			pattern: '/^/a/a1/?$/',
 			page: { layouts: [0, 4], errors: [1, undefined], leaf: 10 }
 		},
 		{
-			id: 'b/d/(special)',
-			pattern: '/^/b/d/?$/',
-			page: { layouts: [0, 6], errors: [1, undefined], leaf: 12 }
+			id: '(special)/a/a2',
+			pattern: '/^/a/a2/?$/',
+			page: { layouts: [0, 2], errors: [1, undefined], leaf: 9 }
 		},
 		{
 			id: '(special)/(alsospecial)/b/c/c1',
@@ -540,6 +604,16 @@ test('creates routes with named layouts', () => {
 			pattern: '/^/b/c/c2/?$/',
 			page: { layouts: [0], errors: [1], leaf: 11 }
 		},
+		{
+			id: 'b/d/(special)',
+			pattern: '/^/b/d/?$/',
+			page: { layouts: [0, 6], errors: [1, undefined], leaf: 12 }
+		},
+		{
+			id: 'b/d/d1',
+			pattern: '/^/b/d/d1/?$/',
+			page: { layouts: [0], errors: [1], leaf: 15 }
+		},
 		{
 			id: 'b/d/(special)/(extraspecial)/d2',
 			pattern: '/^/b/d/d2/?$/',
@@ -549,11 +623,6 @@ test('creates routes with named layouts', () => {
 			id: 'b/d/(special)/(extraspecial)/d3',
 			pattern: '/^/b/d/d3/?$/',
 			page: { layouts: [0, 6], errors: [1, undefined], leaf: 14 }
-		},
-		{
-			id: 'b/d/d1',
-			pattern: '/^/b/d/d1/?$/',
-			page: { layouts: [0], errors: [1], leaf: 15 }
 		}
 	]);
 });
@@ -582,6 +651,11 @@ test('handles pages without .svelte file', () => {
 			id: 'error',
 			pattern: '/^/error/?$/'
 		},
+		{
+			id: 'error/[...path]',
+			pattern: '/^/error(?:/(.*))?/?$/',
+			page: { layouts: [0, undefined], errors: [1, 2], leaf: 5 }
+		},
 		{
 			id: 'layout',
 			pattern: '/^/layout/?$/'
@@ -595,11 +669,6 @@ test('handles pages without .svelte file', () => {
 			id: 'layout/redirect',
 			pattern: '/^/layout/redirect/?$/',
 			page: { layouts: [0, 3], errors: [1, undefined], leaf: 7 }
-		},
-		{
-			id: 'error/[...path]',
-			pattern: '/^/error(?:/(.*))?/?$/',
-			page: { layouts: [0, undefined], errors: [1, 2], leaf: 5 }
 		}
 	]);
 });
@@ -656,7 +725,7 @@ test('errors on duplicate matchers', () => {
 test('prevents route conflicts between groups', () => {
 	assert.throws(
 		() => create('samples/conflicting-groups'),
-		/\(x\)\/a and \(y\)\/a occupy the same route/
+		/The "\(x\)\/a" and "\(y\)\/a" routes conflict with each other/
 	);
 });
 
diff --git a/packages/kit/src/core/sync/create_manifest_data/sort.js b/packages/kit/src/core/sync/create_manifest_data/sort.js
new file mode 100644
index 000000000..a5c24fac4
--- /dev/null
+++ b/packages/kit/src/core/sync/create_manifest_data/sort.js
@@ -0,0 +1,163 @@
+import { affects_path } from '../../../utils/routing.js';
+
+/**
+ * @typedef {{
+ *   type: 'static' | 'required' | 'optional' | 'rest';
+ *   content: string;
+ *   matched: boolean;
+ * }} Part
+ */
+
+/**
+ * @typedef {Part[]} Segment
+ */
+
+const EMPTY = { type: 'static', content: '', matched: false };
+
+/** @param {import('types').RouteData[]} routes */
+export function sort_routes(routes) {
+	/** @type {Map<string, Part[]>} */
+	const segment_cache = new Map();
+
+	/** @param {string} segment */
+	function get_parts(segment) {
+		if (!segment_cache.has(segment)) {
+			segment_cache.set(segment, split(segment));
+		}
+
+		return segment_cache.get(segment);
+	}
+
+	/** @param {string} id */
+	function split(id) {
+		/** @type {Part[]} */
+		const parts = [];
+
+		let i = 0;
+		while (i <= id.length) {
+			const start = id.indexOf('[', i);
+			if (start === -1) {
+				parts.push({ type: 'static', content: id.slice(i), matched: false });
+				break;
+			}
+
+			parts.push({ type: 'static', content: id.slice(i, start), matched: false });
+
+			const type = id[start + 1] === '[' ? 'optional' : id[start + 1] === '.' ? 'rest' : 'required';
+			const delimiter = type === 'optional' ? ']]' : ']';
+			const end = id.indexOf(delimiter, start);
+
+			if (end === -1) {
+				throw new Error(`Invalid route ID ${id}`);
+			}
+
+			const content = id.slice(start, (i = end + delimiter.length));
+
+			parts.push({
+				type,
+				content,
+				matched: content.includes('=')
+			});
+		}
+
+		return parts;
+	}
+
+	return routes.sort((route_a, route_b) => {
+		const segments_a = split_route_id(route_a.id).map(get_parts);
+		const segments_b = split_route_id(route_b.id).map(get_parts);
+
+		for (let i = 0; i < Math.max(segments_a.length, segments_b.length); i += 1) {
+			const segment_a = segments_a[i] ?? [EMPTY];
+			const segment_b = segments_b[i] ?? [EMPTY];
+
+			for (let j = 0; j < Math.max(segment_a.length, segment_b.length); j += 1) {
+				const a = segment_a[j];
+				const b = segment_b[j];
+
+				// first part of each segment is always static
+				// (though it may be the empty string), then
+				// it alternates between dynamic and static
+				// (i.e. [foo][bar] is disallowed)
+				const dynamic = j % 2 === 1;
+
+				if (dynamic) {
+					if (!a) return -1;
+					if (!b) return +1;
+
+					// get the next static chunk, so we can handle [...rest] edge cases
+					const next_a = segment_a[j + 1].content || segments_a[i + 1]?.[0].content;
+					const next_b = segment_b[j + 1].content || segments_b[i + 1]?.[0].content;
+
+					// `[...rest]/x` outranks `[...rest]`
+					if (a.type === 'rest' && b.type === 'rest') {
+						if (next_a && next_b) continue;
+						if (next_a) return -1;
+						if (next_b) return +1;
+					}
+
+					// `[...rest]/x` outranks `[required]` or `[required]/[required]`
+					// but not `[required]/x`
+					if (a.type === 'rest') {
+						return next_a && !next_b ? -1 : +1;
+					}
+
+					if (b.type === 'rest') {
+						return next_b && !next_a ? +1 : -1;
+					}
+
+					// part with matcher outranks one without
+					if (a.matched !== b.matched) {
+						return a.matched ? -1 : +1;
+					}
+
+					if (a.type !== b.type) {
+						// `[...rest]` has already been accounted for, so here
+						// we're comparing between `[required]` and `[[optional]]`
+						if (a.type === 'required') return -1;
+						if (b.type === 'required') return +1;
+					}
+				} else if (a.content !== b.content) {
+					// shallower path outranks deeper path
+					if (a === EMPTY) return -1;
+					if (b === EMPTY) return +1;
+
+					return sort_static(a.content, b.content);
+				}
+			}
+		}
+
+		return route_a.id < route_b.id ? +1 : -1;
+	});
+}
+
+/** @param {string} id */
+function split_route_id(id) {
+	return (
+		id
+			// remove all [[optional]] parts unless they're at the very end
+			.replace(/\[\[[^\]]+\]\](?!$)/g, '')
+			.split('/')
+			.filter((segment) => segment !== '' && affects_path(segment))
+	);
+}
+
+/**
+ * Sort two strings lexicographically, except `foobar` outranks `foo`
+ * @param {string} a
+ * @param {string} b
+ */
+function sort_static(a, b) {
+	if (a === b) return 0;
+
+	for (let i = 0; true; i += 1) {
+		const char_a = a[i];
+		const char_b = b[i];
+
+		if (char_a !== char_b) {
+			if (char_a === undefined) return +1;
+			if (char_b === undefined) return -1;
+			return char_a < char_b ? -1 : +1;
+		}
+	}
+}
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/conflicting-params/[slug1]/+page.svelte
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/+page.svelte
rename to packages/kit/src/core/sync/create_manifest_data/test/samples/conflicting-params/[slug1]/+page.svelte
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...anotherrest]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/conflicting-params/[slug2]/+page.svelte
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...anotherrest]/+page.svelte
rename to packages/kit/src/core/sync/create_manifest_data/test/samples/conflicting-params/[slug2]/+page.svelte
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[endpoint]/+server.js b/packages/kit/src/core/sync/create_manifest_data/test/samples/optional/[[foo]]bar/+server.js
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[endpoint]/+server.js
rename to packages/kit/src/core/sync/create_manifest_data/test/samples/optional/[[foo]]bar/+server.js
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/optional/[[optional]]/+page.svelte
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/+page.svelte
rename to packages/kit/src/core/sync/create_manifest_data/test/samples/optional/[[optional]]/+page.svelte
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/abc/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/optional/nested/[[optional]]/sub/+page.svelte
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/abc/+page.svelte
rename to packages/kit/src/core/sync/create_manifest_data/test/samples/optional/nested/[[optional]]/sub/+page.svelte
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/deep/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/optional/prefix[[suffix]]/+page.svelte
similarity index 100%
rename from packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/deep/+page.svelte
rename to packages/kit/src/core/sync/create_manifest_data/test/samples/optional/prefix[[suffix]]/+page.svelte
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/deep/[...deep_rest]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/deep/[...deep_rest]/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/deep/[...deep_rest]/xyz/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[...rest]/deep/[...deep_rest]/xyz/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[wildcard]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/[wildcard]/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/_layout.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/_layout.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/about/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/about/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/foo/[bar]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/foo/[bar]/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/[id]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/[id]/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/_default.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/_default.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/bar/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/bar/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[xx]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[xx]/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[yy].json/+server.js b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[yy].json/+server.js
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[yy]/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[yy]/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[zz]/+server.ts b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/f[zz]/+server.ts
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/foo/+page.svelte b/packages/kit/src/core/sync/create_manifest_data/test/samples/sorting/post/foo/+page.svelte
deleted file mode 100644
index e69de29bb..000000000
diff --git a/packages/kit/src/core/sync/create_manifest_data/types.d.ts b/packages/kit/src/core/sync/create_manifest_data/types.d.ts
index e897cc9e6..317228845 100644
--- a/packages/kit/src/core/sync/create_manifest_data/types.d.ts
+++ b/packages/kit/src/core/sync/create_manifest_data/types.d.ts
@@ -1,8 +1,8 @@
 import { PageNode } from 'types';
 
 interface Part {
-	content: string;
 	dynamic: boolean;
+	optional: boolean;
 	rest: boolean;
 	type: string | null;
 }
diff --git a/packages/kit/src/utils/routing.js b/packages/kit/src/utils/routing.js
index 760702827..921c62d70 100644
--- a/packages/kit/src/utils/routing.js
+++ b/packages/kit/src/utils/routing.js
@@ -1,4 +1,4 @@
-const param_pattern = /^(\.\.\.)?(\w+)(?:=(\w+))?$/;
+const param_pattern = /^(\[)?(\.\.\.)?(\w+)(?:=(\w+))?(\])?$/;
 
 /** @param {string} id */
 export function parse_route_id(id) {
@@ -22,57 +22,70 @@ export function parse_route_id(id) {
 						.map((segment, i, segments) => {
 							const decoded_segment = decodeURIComponent(segment);
 							// special case — /[...rest]/ could contain zero segments
-							const match = /^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(decoded_segment);
-							if (match) {
-								names.push(match[1]);
-								types.push(match[2]);
+							const rest_match = /^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(decoded_segment);
+							if (rest_match) {
+								names.push(rest_match[1]);
+								types.push(rest_match[2]);
 								return '(?:/(.*))?';
 							}
+							// special case — /[[optional]]/ could contain zero segments
+							const optional_match = /^\[\[(\w+)(?:=(\w+))?\]\]$/.exec(decoded_segment);
+							if (optional_match) {
+								names.push(optional_match[1]);
+								types.push(optional_match[2]);
+								return '(?:/([^/]+))?';
+							}
 
 							const is_last = i === segments.length - 1;
 
-							return (
-								decoded_segment &&
-								'/' +
-									decoded_segment
-										.split(/\[(.+?)\]/)
-										.map((content, i) => {
-											if (i % 2) {
-												const match = param_pattern.exec(content);
-												if (!match) {
-													throw new Error(
-														`Invalid param: ${content}. Params and matcher names can only have underscores and alphanumeric characters.`
-													);
-												}
-
-												const [, rest, name, type] = match;
-												names.push(name);
-												types.push(type);
-												return rest ? '(.*?)' : '([^/]+?)';
-											}
-
-											if (is_last && content.includes('.')) add_trailing_slash = false;
-
-											return (
-												content // allow users to specify characters on the file system in an encoded manner
-													.normalize()
-													// We use [ and ] to denote parameters, so users must encode these on the file
-													// system to match against them. We don't decode all characters since others
-													// can already be epressed and so that '%' can be easily used directly in filenames
-													.replace(/%5[Bb]/g, '[')
-													.replace(/%5[Dd]/g, ']')
-													// '#', '/', and '?' can only appear in URL path segments in an encoded manner.
-													// They will not be touched by decodeURI so need to be encoded here, so
-													// that we can match against them.
-													// We skip '/' since you can't create a file with it on any OS
-													.replace(/#/g, '%23')
-													.replace(/\?/g, '%3F')
-													// escape characters that have special meaning in regex
-													.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
-											); // TODO handle encoding
-										})
-										.join('')
-							);
+							if (!decoded_segment) {
+								return;
+							}
+
+							const parts = decoded_segment.split(/\[(.+?)\](?!\])/);
+							const result = parts
+								.map((content, i) => {
+									if (i % 2) {
+										const match = param_pattern.exec(content);
+										if (!match) {
+											throw new Error(
+												`Invalid param: ${content}. Params and matcher names can only have underscores and alphanumeric characters.`
+											);
+										}
+
+										const [, optional, rest, name, type] = match;
+										// It's assumed that the following invalid route id cases are already checked
+										// - unbalanced brackets
+										// - optional param following rest param
+
+										names.push(name);
+										types.push(type);
+										return rest ? '(.*?)' : optional ? '([^/]*)?' : '([^/]+?)';
+									}
+
+									if (is_last && content.includes('.')) add_trailing_slash = false;
+
+									return (
+										content // allow users to specify characters on the file system in an encoded manner
+											.normalize()
+											// We use [ and ] to denote parameters, so users must encode these on the file
+											// system to match against them. We don't decode all characters since others
+											// can already be epressed and so that '%' can be easily used directly in filenames
+											.replace(/%5[Bb]/g, '[')
+											.replace(/%5[Dd]/g, ']')
+											// '#', '/', and '?' can only appear in URL path segments in an encoded manner.
+											// They will not be touched by decodeURI so need to be encoded here, so
+											// that we can match against them.
+											// We skip '/' since you can't create a file with it on any OS
+											.replace(/#/g, '%23')
+											.replace(/\?/g, '%3F')
+											// escape characters that have special meaning in regex
+											.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
+									); // TODO handle encoding
+								})
+								.join('');
+
+							return '/' + result;
 						})
 						.join('')}${add_trailing_slash ? '/?' : ''}$`
 			  );
@@ -101,7 +114,7 @@ export function exec(match, names, types, matchers) {
 	for (let i = 0; i < names.length; i += 1) {
 		const name = names[i];
 		const type = types[i];
-		const value = match[i + 1] || '';
+		let value = match[i + 1] || '';
 
 		if (type) {
 			const matcher = matchers[type];
diff --git a/packages/kit/src/utils/routing.spec.js b/packages/kit/src/utils/routing.spec.js
index 3c14ce927..1ee655312 100644
--- a/packages/kit/src/utils/routing.spec.js
+++ b/packages/kit/src/utils/routing.spec.js
@@ -1,6 +1,6 @@
 import { test } from 'uvu';
 import * as assert from 'uvu/assert';
-import { parse_route_id } from './routing.js';
+import { exec, parse_route_id } from './routing.js';
 
 const tests = {
 	'': {
@@ -28,6 +28,21 @@ const tests = {
 		names: ['slug'],
 		types: [undefined]
 	},
+	'blog/[[slug]]': {
+		pattern: /^\/blog(?:\/([^/]+))?\/?$/,
+		names: ['slug'],
+		types: [undefined]
+	},
+	'blog/[[slug=type]]/sub': {
+		pattern: /^\/blog(?:\/([^/]+))?\/sub\/?$/,
+		names: ['slug'],
+		types: ['type']
+	},
+	'blog/[[slug]].json': {
+		pattern: /^\/blog\/([^/]*)?\.json$/,
+		names: ['slug'],
+		types: [undefined]
+	},
 	'[...catchall]': {
 		pattern: /^(?:\/(.*))?\/?$/,
 		names: ['catchall'],
@@ -65,6 +80,74 @@ for (const [key, expected] of Object.entries(tests)) {
 	});
 }
 
+const exec_tests = [
+	{
+		route: 'blog/[[slug]]/sub[[param]]',
+		path: '/blog/sub',
+		expected: { slug: '', param: '' }
+	},
+	{
+		route: 'blog/[[slug]]/sub[[param]]',
+		path: '/blog/slug/sub',
+		expected: { slug: 'slug', param: '' }
+	},
+	{
+		route: 'blog/[[slug]]/sub[[param]]',
+		path: '/blog/slug/subparam',
+		expected: { slug: 'slug', param: 'param' }
+	},
+	{
+		route: 'blog/[[slug]]/sub[[param]]',
+		path: '/blog/subparam',
+		expected: { slug: '', param: 'param' }
+	},
+	{
+		route: '[[slug]]/[...rest]',
+		path: '/slug/rest/sub',
+		expected: { slug: 'slug', rest: 'rest/sub' }
+	},
+	{
+		route: '[[slug]]/[...rest]',
+		path: '/slug/rest',
+		expected: { slug: 'slug', rest: 'rest' }
+	},
+	{
+		route: '[[slug]]/[...rest]',
+		path: '/slug',
+		expected: { slug: 'slug', rest: '' }
+	},
+	{
+		route: '[[slug]]/[...rest]',
+		path: '/',
+		expected: { slug: '', rest: '' }
+	},
+	{
+		route: '[...rest]/path',
+		path: '/rest/path',
+		expected: { rest: 'rest' }
+	},
+	{
+		route: '[[slug1]]/[[slug2]]',
+		path: '/slug1/slug2',
+		expected: { slug1: 'slug1', slug2: 'slug2' }
+	},
+	{
+		route: '[[slug1]]/[[slug2]]',
+		path: '/slug1',
+		expected: { slug1: 'slug1', slug2: '' }
+	}
+];
+
+for (const { path, route, expected } of exec_tests) {
+	test(`exec extracts params correctly for ${path}`, () => {
+		const { pattern, names, types } = parse_route_id(route);
+		const match = pattern.exec(path);
+		if (!match) throw new Error(`Failed to match ${path}`);
+		const actual = exec(match, names, types, {});
+		assert.equal(actual, expected);
+	});
+}
+
 test('errors on bad param name', () => {
 	assert.throws(() => parse_route_id('abc/[b-c]'), /Invalid param: b-c/);
 	assert.throws(() => parse_route_id('abc/[bc=d-e]'), /Invalid param: bc=d-e/);
diff --git a/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[a]/+page.server.js b/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[a]/+page.server.js
index 266eee1cd..fd1bb2c6a 100644
--- a/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[a]/+page.server.js
+++ b/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[a]/+page.server.js
@@ -1,5 +1,5 @@
 import { redirect } from '@sveltejs/kit';
 
 export function load() {
-	throw redirect(302, '/shadowed/redirect/c');
+	throw redirect(302, '/shadowed/redirect/b');
 }
diff --git a/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[b]/+page.svelte b/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[b]/+page.svelte
deleted file mode 100644
index 2b853a040..000000000
--- a/packages/kit/test/apps/basics/src/routes/shadowed/redirect/[b]/+page.svelte
+++ /dev/null
@@ -1 +0,0 @@
-<h1>not here</h1>
diff --git a/packages/kit/test/apps/basics/src/routes/shadowed/redirect/c/+page.svelte b/packages/kit/test/apps/basics/src/routes/shadowed/redirect/b/+page.svelte
similarity index 100%
rename from packages/kit/test/apps/basics/src/routes/shadowed/redirect/c/+page.svelte
rename to packages/kit/test/apps/basics/src/routes/shadowed/redirect/b/+page.svelte
