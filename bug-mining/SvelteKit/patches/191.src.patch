diff --git a/.changeset/six-melons-drive.md b/.changeset/six-melons-drive.md
new file mode 100644
index 000000000..8b4e8f6b4
--- /dev/null
+++ b/.changeset/six-melons-drive.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': patch
+---
+
+[docs] rewrite load docs
diff --git a/documentation/docs/03-routing.md b/documentation/docs/03-routing.md
index ef44166d0..f237baa81 100644
--- a/documentation/docs/03-routing.md
+++ b/documentation/docs/03-routing.md
@@ -108,7 +108,7 @@ export async function load({ params }) {
 }
 ```
 
-During client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue).
+During client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue). See [`load`](/docs/load) for full details of the API.
 
 Like `+page.js`, `+page.server.js` can export [page options](/docs/page-options) — `prerender`, `ssr` and `csr`.
 
@@ -197,6 +197,8 @@ We can create a layout that only applies to pages below `/settings` (while inher
 <slot></slot>
 ```
 
+By default, each layout inherits the next layout above it. Sometimes that isn't what you want - in this case, [advanced layouts](/docs/advanced-routing#advanced-layouts) can help you.
+
 #### +layout.js
 
 Just like `+page.svelte` loading data from `+page.js`, your `+layout.svelte` component can get data from a [`load`](/docs/load) function in `+layout.js`.
diff --git a/documentation/docs/05-load.md b/documentation/docs/05-load.md
index 819bc9de5..ca04ed73b 100644
--- a/documentation/docs/05-load.md
+++ b/documentation/docs/05-load.md
@@ -2,253 +2,282 @@
 title: Loading data
 ---
 
-A [`+page.svelte`](/docs/routing#page-page-svelte) or [`+layout.svelte`](/docs/routing#layout-layout-svelte) gets its `data` from a `load` function.
+Before a [`+page.svelte`](/docs/routing#page-page-svelte) component (and its containing [`+layout.svelte`](/docs/routing#layout-layout-svelte) components) can be rendered, we often need to get some data. This is done by defining `load` functions.
 
-If the `load` function is defined in `+page.js` or `+layout.js` it will run both on the server and in the browser. If it's instead defined in `+page.server.js` or `+layout.server.js` it will only run on the server, in which case it can (for example) make database calls and access private [environment variables](/docs/modules#$env-static-private), but can only return data that can be serialized with [devalue](https://github.com/rich-harris/devalue). In both cases, the return value (if there is one) must be an object.
+### Page data
+
+A `+page.svelte` file can have a sibling `+page.js` (or `+page.ts`) that exports a `load` function, the return value of which is available to the page via the `data` prop:
 
 ```js
-/// file: src/routes/+page.js
+/// file: src/routes/blog/[slug]/+page.js
 /** @type {import('./$types').PageLoad} */
-export function load(event) {
+export function load({ params }) {
 	return {
-		some: 'data'
+		post: {
+			title: `Title for ${params.slug} goes here`,
+			content: `Content for ${params.slug} goes here`
+		}
 	};
 }
 ```
 
-### Input properties
+```svelte
+/// file: src/routes/blog/[slug]/+page.svelte
+<script>
+	/** @type {import('./$types').PageData} */
+	export let data;
+</script>
 
-The argument to a `load` function is a `LoadEvent` (or, for server-only `load` functions, a `ServerLoadEvent` which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`). All events have the following properties:
+<h1>{data.post.title}</h1>
+<div>{@html data.post.content}</div>
+```
 
-#### data
+Thanks to the generated `$types` module, we get full type safety.
 
-Very rarely, you might need both a `+page.js` and a `+page.server.js` (or the `+layout` equivalent). In these cases, the `data` for `+page.svelte` comes from `+page.js`, which in turn receives `data` from the server:
+A `load` function in a `+page.js` file runs both on the server and in the browser. If your `load` function should _always_ run on the server (because it uses private environment variables, for example, or accesses a database) then you can put it in a `+page.server.js` instead.
+
+A more realistic version of your blog post's `load` function, that only runs on the server and pulls data from a database, might look like this:
 
 ```js
-/// file: src/routes/my-route/+page.server.js
+/// file: src/routes/blog/[slug]/+page.server.js
+// @filename: ambient.d.ts
+declare module '$lib/server/database' {
+	export function getPost(slug: string): Promise<{ title: string, content: string }>
+}
+
+// @filename: index.js
+// ---cut---
+import * as db from '$lib/server/database';
+
 /** @type {import('./$types').PageServerLoad} */
-export function load() {
+export async function load({ params }) {
 	return {
-		a: 1
+		post: await db.getPost(params.slug)
 	};
 }
 ```
 
+Notice that the type changed from `PageLoad` to `PageServerLoad`, because server-only `load` functions can access additional arguments. To understand when to use `+page.js` and when to use `+page.server.js`, see [Shared vs server](/docs/load#shared-vs-server).
+
+### Layout data
+
+Your `+layout.svelte` files can also load data, via `+layout.js` or `+layout.server.js`.
+
 ```js
-/// file: src/routes/my-route/+page.js
-// @filename: $types.d.ts
-export type PageLoad = import('@sveltejs/kit').Load<{}, { a: number }>;
+/// file: src/routes/blog/[slug]/+layout.server.js
+// @filename: ambient.d.ts
+declare module '$lib/server/database' {
+	export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>>
+}
 
 // @filename: index.js
 // ---cut---
-/** @type {import('./$types').PageLoad} */
-export function load({ data }) {
+import * as db from '$lib/server/database';
+
+/** @type {import('./$types').LayoutServerLoad} */
+export async function load() {
 	return {
-		b: data.a * 2
+		posts: await db.getPostSummaries()
 	};
 }
 ```
 
 ```svelte
-/// file: src/routes/my-route/+page.svelte
+/// file: src/routes/blog/[slug]/+layout.svelte
 <script>
-	/** @type {import('./$types').PageData} */
+	/** @type {import('./$types').LayoutData} */
 	export let data;
-
-	console.log(data.a); // `undefined`, it wasn't passed through in +page.js
-	console.log(data.b); // `2`
 </script>
+
+<main>
+	<!-- +page.svelte is rendered here -->
+	<slot />
+</main>
+
+<aside>
+	<h2>More posts</h2>
+	<ul>
+		{#each data.posts as post}
+			<li>
+				<a href="/blog/{post.slug}">
+					{post.title}
+				</a>
+			</li>
+		{/each}
+	</ul>
+</aside>
 ```
 
-In other words `+page.server.js` passes `data` along to `+page.js`, which passes `data` along to `+page.svelte`.
+Data returned from layout `load` functions is available to child `+layout.svelte` components and the `+page.svelte` component as well as the layout that it 'belongs' to.
 
-#### params
+```diff
+/// file: src/routes/blog/[slug]/+page.svelte
+<script>
++	import { page } from '$app/stores';
 
-`params` is derived from `url.pathname` and the route filename.
+	/** @type {import('./$types').PageData} */
+	export let data;
 
-For a route filename example like `src/routes/a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:
++	// we can access `data.posts` because it's returned from
++	// the parent layout `load` function
++	$: index = data.posts.findIndex(post => post.slug === $page.params.slug);
++	$: next = data.posts[index - 1];
+</script>
 
-```json
-{
-	"b": "x",
-	"c": "y/z"
-}
+<h1>{data.post.title}</h1>
+<div>{@html data.post.content}</div>
+
++{#if next}
++	<p>Next post: <a href="/blog/{next.slug}">{next.title}</a></p>
++{/if}
 ```
 
-#### routeId
+> If multiple `load` functions return data with the same key, the last one 'wins'.
 
-The name of the current route directory, relative to `src/routes`:
+### $page.data
 
-```js
-/// file: src/routes/blog/[slug]/+page.js
-/** @type {import('./$types').PageLoad} */
-export function load({ routeId }) {
-	console.log(routeId); // 'blog/[slug]'
-}
-```
+The `+page.svelte` component, and each `+layout.svelte` component above it, has access to its own data plus all the data from its parents.
 
-#### url
+In some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a `title` property returned from a `load` function in `+page.js` or `+page.server.js`. This can be done with `$page.data`:
 
-An instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server.
+```svelte
+/// file: src/routes/+layout.svelte
+<script>
+	import { page } from '$app/stores';
+</script>
 
-> In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](/docs/adapters#supported-environments-node-js), for example, you may need to configure the adapter in order for the URL to be correct.
+<svelte:head>
+	<title>{$page.data.title}</title>
+</svelte:head>
+```
 
-### Input methods
+Type information for `$page.data` is provided by `App.PageData`.
 
-`LoadEvent` also has the following methods:
+### Shared vs server
 
-#### depends
+As we've seen, there are two types of `load` function:
 
-This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/modules#$app-navigation-invalidate) to cause `load` to rerun.
+* `+page.js` and `+layout.js` files export `load` functions that are _shared_ between server and browser
+* `+page.server.js` and `+layout.server.js` files export `load` functions that are _server-only_
 
-Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`.
+Conceptually, they're the same thing, but there are some important differences to be aware of.
 
-URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).
+#### Input
 
-Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).
+Both shared and server-only `load` functions have access to properties describing the request (`params`, `routeId` and `url`) and various functions (`depends`, `fetch` and `parent`). These are described in the following sections.
 
-The following example shows how to use `depends` to register a dependency on the URLs to a custom API client as well as a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.
+Server-only `load` functions are called with a `ServerLoadEvent`, which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`.
 
-```js
-/// file: src/routes/+page.js
-// @filename: ambient.d.ts
-declare module '$lib/api' {
-	interface Data{}
-	export const base: string;
-	export const client: {
-		get: (resource:string) => Promise<Data>
-	}
-}
+Shared `load` functions are called with a `LoadEvent`, which has a `data` property. If you have `load` functions in both `+page.js` and `+page.server.js` (or `+layout.js` and `+layout.server.js`), the return value of the server-only `load` function is the `data` property of the shared `load` function's argument.
 
-// @filename: index.js
-// ---cut---
-import * as api from '$lib/api';
+#### Output
 
-/** @type {import('./$types').PageLoad} */
-export async function load({ depends }) {
-	depends(
-		`${api.base}/foo`,
-		`${api.base}/bar`,
-		'my-stuff:foo'
-	);
+A shared `load` function can return an object containing any values, including things like custom classes and component constructors.
 
-	return {
-		foo: api.client.get('/foo'),
-		bar: api.client.get('/bar')
-	};
-}
-```
+A server-only `load` function must return data that can be serialized with [devalue](https://github.com/rich-harris/devalue) — anything that can be represented as JSON plus things like `BigInt`, `Date`, `Map`, `Set` and `RegExp`, or repeated/cyclical references — so that it can be transported over the network.
 
-```svelte
-/// file: src/routes/+page.svelte
-<script>
-	import { invalidate } from '$app/navigation';
+#### When to use which
 
-	/** @type {import('./$types').PageData} */
-	export let data;
+Server-only `load` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables.
 
-	const pageRefresh = async () => {
-		await invalidate('my-stuff:foo');
-	}
-</script>
+Shared `load` functions are useful when you need to `fetch` data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor.
 
-<p>{data.foo}<p>
-<p>{data.bar}</p>
-<button on:click={pageRefresh}>Refresh my stuff</button>
-```
+In rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server.
 
-#### fetch
+### Using URL data
 
-`fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:
+Often the `load` function depends on the URL in one way or another. For this, the `load` function provides you with `url`, `routeId` and `params`.
 
-- it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request
-- it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)
-- internal requests (e.g. for `+server.js` routes) go direct to the handler function when running on the server, without the overhead of an HTTP call
-- during server-side rendering, the response will be captured and inlined into the rendered HTML. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](/docs/hooks#server-hooks-handle)
-- during hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request
+#### url
 
-> Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.
+An instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server.
+
+> In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](/docs/adapters#supported-environments-node-js), for example, you may need to configure the adapter in order for the URL to be correct.
 
-#### parent
+#### routeId
 
-`await parent()` returns data from parent layout `load` functions. In `+page.server.js` or `+layout.server.js` it will return data from `load` functions in parent `+layout.server.js` files:
+The name of the current route directory, relative to `src/routes`:
 
 ```js
-/// file: src/routes/+layout.server.js
-/** @type {import('./$types').LayoutServerLoad} */
-export function load() {
-	return { a: 1 };
+/// file: src/routes/a/[b]/[...c]/+page.js
+/** @type {import('./$types').PageLoad} */
+export function load({ routeId }) {
+	console.log(routeId); // '/a/[b]/[...c]'
 }
 ```
 
-```js
-/// file: src/routes/foo/+layout.server.js
-// @filename: $types.d.ts
-export type LayoutServerLoad = import('@sveltejs/kit').Load<{}, null, { a: number }>;
+#### params
 
-// @filename: index.js
-// ---cut---
-/** @type {import('./$types').LayoutServerLoad} */
-export async function load({ parent }) {
-	const { a } = await parent();
-	console.log(a); // `1`
+`params` is derived from `url.pathname` and `routeId`.
+
+Given a `routeId` of `a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:
 
-	return { b: 2 };
+```json
+{
+	"b": "x",
+	"c": "y/z"
 }
 ```
 
-```js
-/// file: src/routes/foo/+page.server.js
-// @filename: $types.d.ts
-export type PageServerLoad = import('@sveltejs/kit').Load<{}, null, { a: number, b: number }>;
+### Making fetch requests
 
-// @filename: index.js
-// ---cut---
-/** @type {import('./$types').PageServerLoad} */
-export async function load({ parent }) {
-	const { a, b } = await parent();
-	console.log(a, b); // `1`, `2`
+To get data from an external API or a `+server.js` handler, you can use the provided `fetch` function, which behaves identically to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch) with a few additional features:
 
-	return { c: 3 };
+- it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request
+- it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)
+- internal requests (e.g. for `+server.js` routes) go direct to the handler function when running on the server, without the overhead of an HTTP call
+- during server-side rendering, the response will be captured and inlined into the rendered HTML. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](/docs/hooks#server-hooks-handle). Then, during hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you got a warning in your browser console when using the browser `fetch` instead of the `load` `fetch`, this is why.
+
+```js
+/// file: src/routes/items/[id]/+page.js
+/** @type {import('./$types').PageLoad} */
+export async function load({ fetch, params }) {
+	const res = await fetch(`/api/items/${params.id}`);
+	const item = await res.json();
+
+	return { item };
 }
 ```
 
-In `+page.js` or `+layout.js` it will return data from `load` functions in parent `+layout.js` files. Implicitly, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files.
+> Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.
 
-Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.
+### Cookies and headers
 
-```diff
-/// file: src/routes/foo/+page.server.js
-// @filename: $types.d.ts
-export type PageServerLoad = import('@sveltejs/kit').Load<{}, null, { a: number, b: number }>;
+A server-only `load` function can get and set [`cookies`](/docs/types#sveltejs-kit-cookies).
+
+```js
+/// file: src/routes/+layout.server.js
+// @filename: ambient.d.ts
+declare module '$lib/server/database' {
+	export function getUser(sessionid: string | undefined): Promise<{ name: string, avatar: string }>
+}
 
 // @filename: index.js
 // ---cut---
-/** @type {import('./$types').PageServerLoad} */
-export async function load({ parent, fetch }) {
--	const parentData = await parent();
-	const data = await fetch('./some-api');
-+	const parentData = await parent();
+import * as db from '$lib/server/database';
+
+/** @type {import('./$types').LayoutServerLoad} */
+export async function load({ cookies }) {
+	const sessionid = cookies.get('sessionid');
 
 	return {
-		...data
-		meta: { ...parentData.meta, ...data.meta }
+		user: await db.getUser(sessionid)
 	};
 }
 ```
 
-#### setHeaders
-
-If you need to set headers for the response, you can do so using the `setHeaders` method. This is useful if you want the page to be cached, for example:
+Both server-only and shared `load` functions have access to a `setHeaders` function that, when running on the server, can set headers for the response. (When running in the browser, `setHeaders` has no effect.) This is useful if you want the page to be cached, for example:
 
 ```js
 // @errors: 2322
-/// file: src/routes/blog/+page.js
+/// file: src/routes/products/+page.js
 /** @type {import('./$types').PageLoad} */
 export async function load({ fetch, setHeaders }) {
-	const url = `https://cms.example.com/articles.json`;
+	const url = `https://cms.example.com/products.json`;
 	const response = await fetch(url);
 
+	// cache the page for the same length of time
+	// as the underlying data
 	setHeaders({
 		age: response.headers.get('age'),
 		'cache-control': response.headers.get('cache-control')
@@ -258,31 +287,35 @@ export async function load({ fetch, setHeaders }) {
 }
 ```
 
-> `setHeaders` has no effect when a `load` function runs in the browser.
-
-Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.
+Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once. You cannot add a `set-cookie` header with `setHeaders` — use `cookies.set(name, value, options)` instead.
 
-You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](/docs/types#sveltejs-kit-cookies) API in a server-only `load` function instead.
+### Using parent data
 
-### Output
+Occasionally it's useful for a `load` function to access data from a parent `load` function, which can be done with `await parent()`:
 
-The returned `data`, if any, must be an object of values. For a server-only `load` function, these values must be serializable with [devalue](https://github.com/rich-harris/devalue). Top-level promises will be awaited, which makes it easy to return multiple promises without creating a waterfall:
+```js
+/// file: src/routes/+layout.js
+/** @type {import('./$types').LayoutLoad} */
+export function load() {
+	return { a: 1 };
+}
+```
 
 ```js
-// @filename: $types.d.ts
-export type PageLoad = import('@sveltejs/kit').Load<{}>;
+/// file: src/routes/abc/+layout.js
+/** @type {import('./$types').LayoutLoad} */
+export async function load({ parent }) {
+	const { a } = await parent();
+	return { b: a + 1 };
+}
+```
 
-// @filename: index.js
-// ---cut---
+```js
+/// file: src/routes/abc/+page.js
 /** @type {import('./$types').PageLoad} */
-export function load() {
-	return {
-		a: Promise.resolve('a'),
-		b: Promise.resolve('b'),
-		c: {
-			value: Promise.resolve('c')
-		}
-	};
+export async function load({ parent }) {
+	const { a, b } = await parent();
+	return { c: a + b };
 }
 ```
 
@@ -290,11 +323,33 @@ export function load() {
 <script>
 	/** @type {import('./$types').PageData} */
 	export let data;
-
-	console.log(data.a); // 'a'
-	console.log(data.b); // 'b'
-	console.log(data.c.value); // `Promise {...}`
 </script>
+
+<!-- renders `1 + 2 = 3` -->
+<p>{data.a} + {data.b} = {data.c}</p>
+```
+
+> Notice that the `load` function in `+page.js` receives the merged data from both layout `load` functions, not just the immediate parent.
+
+Inside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files.
+
+In `+page.js` or `+layout.js` it will return data from parent `+layout.js` files. However, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files that are not 'shadowed' by a `+layout.js` file
+
+Take care not to introduce waterfalls when using `await parent()`. Here, for example, `getData(params)` does not depend on the result of calling `parent()`, so we should call it first to avoid a delayed render.
+
+```diff
+/// file: +page.js
+/** @type {import('./$types').PageLoad} */
+export async function load({ params, parent }) {
+-	const parentData = await parent();
+	const data = await getData(params);
++	const parentData = await parent();
+
+	return {
+		...data
+		meta: { ...parentData.meta, ...data.meta }
+	};
+}
 ```
 
 ### Errors
@@ -306,7 +361,7 @@ If an error is thrown during `load`, the nearest [`+error.svelte`](/docs/routing
 // @filename: ambient.d.ts
 declare namespace App {
 	interface Locals {
-		user: {
+		user?: {
 			name: string;
 			isAdmin: boolean;
 		}
@@ -335,38 +390,163 @@ If an _unexpected_ error is thrown, SvelteKit will invoke [`handleError`](/docs/
 
 To redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the location to which they should be redirected alongside a `3xx` status code.
 
-```diff
-/// file: src/routes/admin/+layout.server.js
--import { error } from '@sveltejs/kit';
-+import { error, redirect } from '@sveltejs/kit';
+```js
+/// file: src/routes/user/+layout.server.js
+// @filename: ambient.d.ts
+declare namespace App {
+	interface Locals {
+		user?: {
+			name: string;
+		}
+	}
+}
+
+// @filename: index.js
+// ---cut---
+import { redirect } from '@sveltejs/kit';
 
 /** @type {import('./$types').LayoutServerLoad} */
 export function load({ locals }) {
 	if (!locals.user) {
--		throw error(401, 'not logged in');
-+		throw redirect(307, '/login');
+		throw redirect(307, '/login');
 	}
+}
+```
 
-	if (!locals.user.isAdmin) {
-		throw error(403, 'not an admin');
-	}
+### Promise unwrapping
+
+Top-level promises will be awaited, which makes it easy to return multiple promises without creating a waterfall:
+
+```js
+/// file: src/routes/+page.server.js
+/** @type {import('./$types').PageServerLoad} */
+export function load() {
+	return {
+		a: Promise.resolve('a'),
+		b: Promise.resolve('b'),
+		c: {
+			value: Promise.resolve('c')
+		}
+	};
 }
 ```
 
+```svelte
+<script>
+	/** @type {import('./$types').PageData} */
+	export let data;
+
+	console.log(data.a); // 'a'
+	console.log(data.b); // 'b'
+	console.log(data.c.value); // `Promise {...}`
+</script>
+```
+
+### Parallel loading
+
+When rendering (or navigating to) a page, SvelteKit runs all `load` functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server-only `load` functions are grouped into a single response. Once all `load` functions have returned, the page is rendered.
+
 ### Invalidation
 
-SvelteKit tracks the dependencies of each `load` function to avoid re-running it unnecessarily during navigation. For example, a `load` function in a root `+layout.js` doesn't need to re-run when you navigate from one page to another unless it references `url` or a member of `params` that changed since the last navigation.
+SvelteKit tracks the dependencies of each `load` function to avoid re-running it unnecessarily during navigation.
+
+For example, given a pair of `load` functions like these...
+
+```js
+/// file: src/routes/blog/[slug]/+page.server.js
+// @filename: ambient.d.ts
+declare module '$lib/server/database' {
+	export function getPost(slug: string): Promise<{ title: string, content: string }>
+}
+
+// @filename: index.js
+// ---cut---
+import * as db from '$lib/server/database';
+
+/** @type {import('./$types').PageServerLoad} */
+export async function load({ params }) {
+	return {
+		post: await db.getPost(params.slug)
+	};
+}
+```
+
+```js
+/// file: src/routes/blog/[slug]/+layout.server.js
+// @filename: ambient.d.ts
+declare module '$lib/server/database' {
+	export function getPostSummaries(): Promise<Array<{ title: string, slug: string }>>
+}
+
+// @filename: index.js
+// ---cut---
+import * as db from '$lib/server/database';
+
+/** @type {import('./$types').LayoutServerLoad} */
+export async function load() {
+	return {
+		posts: await db.getPostSummaries()
+	};
+}
+```
+
+...the one in `+page.server.js` will re-run if we navigate from `/blog/trying-the-raw-meat-diet` to `/blog/i-regret-my-choices` because `params.slug` has changed. The one in `+layout.server.js` will not, because the data is still valid. In other words, we won't call `db.getPostSummaries()` a second time.
+
+A `load` function that calls `await parent()` will also re-run if a parent `load` function is re-run.
+
+#### Manual invalidation
+
+You can also re-run `load` functions that apply to the current page using [`invalidate(url)`](/docs/modules#$app-navigation-invalidate), which re-runs all `load` functions that depend on `url`, and [`invalidateAll()`](/docs/modules#$app-navigation-invalidateall), which re-runs every `load` function.
+
+A `load` function depends on `url` if it calls `fetch(url)` or `depends(url)`. Note that `url` can be a custom identifier that starts with `[a-z]:`:
+
+```js
+/// file: src/routes/random-number/+page.js
+/** @type {import('./$types').PageLoad} */
+export async function load({ fetch, depends }) {
+	// load reruns when `invalidate('https://api.example.com/random-number')` is called...
+	const response = await fetch('https://api.example.com/random-number');
+
+	// ...or when `invalidate('app:random')` is called
+	depends('app:random');
+
+	return {
+		number: await response.json()
+	};
+}
+```
+
+```svelte
+/// file: src/routes/random-number/+page.svelte
+<script>
+	import { invalidateAll } from '$app/navigation';
+
+	/** @type {import('./$types').PageData} */
+	export let data;
+
+	function rerunLoadFunction() {
+		// any of these will cause the `load` function to re-run
+		invalidate('app:random');
+		invalidate('https://api.example.com/random-number');
+		invalidate(url => url.href.includes('random-number'));
+		invalidateAll();
+	}
+</script>
+
+<p>random number: {data.number}</p>
+<button on:click={rerunLoadFunction}>Update random number</button>
+```
 
-A `load` function will re-run in the following situations:
+To summarize, a `load` function will re-run in the following situations:
 
 - It references a property of `params` whose value has changed
 - It references a property of `url` (such as `url.pathname` or `url.search`) whose value has changed
 - It calls `await parent()` and a parent `load` function re-ran
-- It declared a dependency on a specific URL via [`fetch`](#input-methods-fetch) or [`depends`](#input-methods-depends), and that URL was marked invalid with [`invalidate(url)`](/docs/modules#$app-navigation-invalidate)
+- It declared a dependency on a specific URL via [`fetch`](#making-fetch-requests) or [`depends`](/docs/types#sveltejs-kit-loadevent), and that URL was marked invalid with [`invalidate(url)`](/docs/modules#$app-navigation-invalidate)
 - All active `load` functions were forcibly re-run with [`invalidateAll()`](/docs/modules#$app-navigation-invalidateall)
 
-If a `load` function is triggered to re-run, the page will not remount — instead, it will update with the new `data`. This means that components' internal state is preserved. If this isn't want you want, you can reset whatever you need to reset inside an [`afterNavigate`](/docs/modules#$app-navigation-afternavigate) callback, and/or wrap your component in a [`{#key ...}`](https://svelte.dev/docs#template-syntax-key) block.
+Note that re-running a `load` function will update the `data` prop inside the corresponding `+layout.svelte` or `+page.svelte`; it does _not_ cause the component to be recreated. As a result, internal state is preserved. If this isn't want you want, you can reset whatever you need to reset inside an [`afterNavigate`](/docs/modules#$app-navigation-afternavigate) callback, and/or wrap your component in a [`{#key ...}`](https://svelte.dev/docs#template-syntax-key) block.
 
 ### Shared state
 
-In many server environments, a single instance of your app will serve multiple users. For that reason, per-request state must not be stored in shared variables outside your `load` functions, but should instead be stored in `event.locals`. Similarly, per-user state must not be stored in global variables, but should instead make use of `$page.data` (which contains the combined data of all `load` functions) or use Svelte's [context feature](https://svelte.dev/docs#run-time-svelte-setcontext) to create scoped state.
+In many server environments, a single instance of your app will serve multiple users. For that reason, per-request or per-user state must not be stored in shared variables outside your `load` functions, but should instead be stored in `event.locals`.
\ No newline at end of file
diff --git a/documentation/docs/13-page-options.md b/documentation/docs/13-page-options.md
index 3ea49fe43..e20729e52 100644
--- a/documentation/docs/13-page-options.md
+++ b/documentation/docs/13-page-options.md
@@ -60,7 +60,7 @@ The basic rule is this: for a page to be prerenderable, any two users hitting it
 
 Note that you can still prerender pages that load data based on the page's parameters, such as a `src/routes/blog/[slug]/+page.svelte` route.
 
-Accessing [`url.searchParams`](/docs/load#input-properties-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in `onMount`).
+Accessing [`url.searchParams`](/docs/load#using-url-data-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in `onMount`).
 
 #### Route conflicts
 
@@ -83,7 +83,7 @@ Since these routes cannot be dynamically server-rendered, this will cause errors
 
 ### ssr
 
-Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it's hydrated. If you set `ssr` to `false`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document` for example), but in most situations it's not recommended ([see appendix](/docs/appendix#ssr)).
+Normally, SvelteKit renders your page on the server first and sends that HTML to the client where it's hydrated. If you set `ssr` to `false`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document` for example), but in most situations it's not recommended ([see appendix](/docs/appendix#ssr)). If you put this into your root `+layout.js`, you create an SPA (all pages are client-side rendered only).
 
 ```js
 /// file: +page.js
diff --git a/documentation/docs/80-migrating.md b/documentation/docs/80-migrating.md
index 7d8750494..18cef9023 100644
--- a/documentation/docs/80-migrating.md
+++ b/documentation/docs/80-migrating.md
@@ -97,7 +97,7 @@ As before, pages and layouts can export a function that allows data to be loaded
 
 This function has been renamed from `preload` to [`load`](/docs/load), it now lives in a `+page.js` (or `+layout.js`) next to its `+page.svelte` (or `+layout.svelte`), and its API has changed. Instead of two arguments — `page` and `session` — there is a single `event` argument.
 
-There is no more `this` object, and consequently no `this.fetch`, `this.error` or `this.redirect`. Instead, you can get [`fetch`](/docs/load#input-methods-fetch) from the input methods, and both [`error`](/docs/load#errors) and [`redirect`](/docs/load#redirects) are now thrown.
+There is no more `this` object, and consequently no `this.fetch`, `this.error` or `this.redirect`. Instead, you can get [`fetch`](/docs/load#making-fetch-requests) from the input methods, and both [`error`](/docs/load#errors) and [`redirect`](/docs/load#redirects) are now thrown.
 
 #### Stores
 
diff --git a/packages/kit/src/core/config/options.js b/packages/kit/src/core/config/options.js
index dbffb030d..6a39ae749 100644
--- a/packages/kit/src/core/config/options.js
+++ b/packages/kit/src/core/config/options.js
@@ -88,7 +88,7 @@ const options = object(
 			// TODO: remove this for the 1.0 release
 			amp: error(
 				(keypath) =>
-					`${keypath} has been removed. See https://kit.svelte.dev/docs/seo#amp for details on how to support AMP`
+					`${keypath} has been removed. See https://kit.svelte.dev/docs/seo#manual-setup-amp for details on how to support AMP`
 			),
 
 			appDir: validate('_app', (input, keypath) => {
@@ -321,7 +321,7 @@ const options = object(
 			// TODO remove this for 1.0
 			ssr: error(
 				(keypath) =>
-					`${keypath} has been removed — use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle`
+					`${keypath} has been removed — use the handle hook instead: https://kit.svelte.dev/docs/hooks#server-hooks-handle`
 			),
 
 			// TODO remove this for 1.0
diff --git a/packages/kit/src/runtime/client/fetcher.js b/packages/kit/src/runtime/client/fetcher.js
index 8ae2515bd..42a7b577e 100644
--- a/packages/kit/src/runtime/client/fetcher.js
+++ b/packages/kit/src/runtime/client/fetcher.js
@@ -29,7 +29,7 @@ if (import.meta.env.DEV) {
 		const heuristic = can_inspect_stack_trace ? stack.includes('load_node') : loading;
 		if (heuristic) {
 			console.warn(
-				`Loading ${url} using \`window.fetch\`. For best results, use the \`fetch\` that is passed to your \`load\` function: https://kit.svelte.dev/docs/load#input-fetch`
+				`Loading ${url} using \`window.fetch\`. For best results, use the \`fetch\` that is passed to your \`load\` function: https://kit.svelte.dev/docs/load#making-fetch-requests`
 			);
 		}
 
diff --git a/packages/kit/src/runtime/server/page/load_data.js b/packages/kit/src/runtime/server/page/load_data.js
index dfe50078e..73d25dbd0 100644
--- a/packages/kit/src/runtime/server/page/load_data.js
+++ b/packages/kit/src/runtime/server/page/load_data.js
@@ -184,7 +184,7 @@ export async function load_data({
 						const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
 						if (!included) {
 							throw new Error(
-								`Failed to get response header "${lower}" — it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#handle (at ${event.routeId})`
+								`Failed to get response header "${lower}" — it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.routeId})`
 							);
 						}
 					}
diff --git a/packages/kit/test/apps/basics/test/client.test.js b/packages/kit/test/apps/basics/test/client.test.js
index 1e34c648f..f0dae6abe 100644
--- a/packages/kit/test/apps/basics/test/client.test.js
+++ b/packages/kit/test/apps/basics/test/client.test.js
@@ -464,7 +464,7 @@ test.describe('Load', () => {
 			expect(await page.textContent('h1')).toBe('42');
 
 			expect(warnings).toContain(
-				`Loading http://localhost:${port}/load/window-fetch/data.json using \`window.fetch\`. For best results, use the \`fetch\` that is passed to your \`load\` function: https://kit.svelte.dev/docs/load#input-fetch`
+				`Loading http://localhost:${port}/load/window-fetch/data.json using \`window.fetch\`. For best results, use the \`fetch\` that is passed to your \`load\` function: https://kit.svelte.dev/docs/load#making-fetch-requests`
 			);
 
 			warnings.length = 0;
@@ -473,7 +473,7 @@ test.describe('Load', () => {
 			expect(await page.textContent('h1')).toBe('42');
 
 			expect(warnings).not.toContain(
-				`Loading http://localhost:${port}/load/window-fetch/data.json using \`window.fetch\`. For best results, use the \`fetch\` that is passed to your \`load\` function: https://kit.svelte.dev/docs/load#input-fetch`
+				`Loading http://localhost:${port}/load/window-fetch/data.json using \`window.fetch\`. For best results, use the \`fetch\` that is passed to your \`load\` function: https://kit.svelte.dev/docs/load#making-fetch-requests`
 			);
 		});
 	}
diff --git a/packages/kit/types/index.d.ts b/packages/kit/types/index.d.ts
index f36e2105b..ed88e2cac 100644
--- a/packages/kit/types/index.d.ts
+++ b/packages/kit/types/index.d.ts
@@ -271,18 +271,108 @@ export interface LoadEvent<
 	Data extends Record<string, unknown> | null = Record<string, any> | null,
 	ParentData extends Record<string, unknown> = Record<string, any>
 > extends NavigationEvent<Params> {
+	/**
+	 * `fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:
+	 *
+	 * - it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request
+	 * - it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)
+	 * - internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call
+	 * - during server-side rendering, the response will be captured and inlined into the rendered HTML. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](https://kit.svelte.dev/docs/hooks#server-hooks-handle)
+	 * - during hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request
+	 *
+	 * > Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.
+	 */
 	fetch: typeof fetch;
+	/**
+	 * Contains the data returned by the route's server `load` function (in `+layout.server.js` or `+page.server.js`), if any.
+	 */
 	data: Data;
+	/**
+	 * If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:
+	 *
+	 *	```js
+	 *	/// file: src/routes/blog/+page.js
+	 *	export async function load({ fetch, setHeaders }) {
+	 *		const url = `https://cms.example.com/articles.json`;
+	 *		const response = await fetch(url);
+	 *
+	 *		setHeaders({
+	 *			age: response.headers.get('age'),
+	 *			'cache-control': response.headers.get('cache-control')
+	 *		});
+	 *
+	 *		return response.json();
+	 *	}
+	 *	```
+	 *
+	 * Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.
+	 *
+	 * You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](https://kit.svelte.dev/docs/types#sveltejs-kit-cookies) API in a server-only `load` function instead.
+	 *
+	 * `setHeaders` has no effect when a `load` function runs in the browser.
+	 */
 	setHeaders: (headers: Record<string, string>) => void;
+	/**
+	 * `await parent()` returns data from parent `+layout.js` `load` functions.
+	 * Implicitly, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will return and forward data from parent `+layout.server.js` files.
+	 *
+	 * Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.
+	 */
 	parent: () => Promise<ParentData>;
+	/**
+	 * This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/modules#$app-navigation-invalidate) to cause `load` to rerun.
+	 *
+	 * Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`.
+	 *
+	 * URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).
+	 *
+	 * Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).
+	 *
+	 * The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.
+	 *
+	 * ```js
+	 * /// file: src/routes/+page.js
+	 * let count = 0;
+	 * export async function load({ depends }) {
+	 * 	depends('increase:count');
+	 *
+	 * 	return { count: count++ };
+	 * }
+	 * ```
+	 *
+	 * ```html
+	 * /// file: src/routes/+page.svelte
+	 * <script>
+	 * 	import { invalidate } from '$app/navigation';
+	 *
+	 * 	export let data;
+	 *
+	 * 	const increase = async () => {
+	 * 		await invalidate('increase:count');
+	 * 	}
+	 * </script>
+	 *
+	 * <p>{data.count}<p>
+	 * <button on:click={increase}>Increase Count</button>
+	 * ```
+	 */
 	depends: (...deps: string[]) => void;
 }
 
 export interface NavigationEvent<
 	Params extends Partial<Record<string, string>> = Partial<Record<string, string>>
 > {
+	/**
+	 * The parameters of the current page - e.g. for a route like `/blog/[slug]`, the `slug` parameter
+	 */
 	params: Params;
+	/**
+	 * The route ID of the current page - e.g. for `src/routes/blog/[slug]`, it would be `blog/[slug]`
+	 */
 	routeId: string | null;
+	/**
+	 * The URL of the current page
+	 */
 	url: URL;
 }
 
@@ -342,15 +432,70 @@ export interface ParamMatcher {
 export interface RequestEvent<
 	Params extends Partial<Record<string, string>> = Partial<Record<string, string>>
 > {
+	/**
+	 * Get or set cookies related to the current request
+	 */
 	cookies: Cookies;
+	/**
+	 * `fetch` is equivalent to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch), with a few additional features:
+	 *
+	 * - it can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request
+	 * - it can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context)
+	 * - internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call
+	 *
+	 * > Cookies will only be passed through if the target host is the same as the SvelteKit application or a more specific subdomain of it.
+	 */
 	fetch: typeof fetch;
+	/**
+	 * The client's IP address, set by the adapter.
+	 */
 	getClientAddress: () => string;
+	/**
+	 * Contains custom data that was added to the request within the [`handle hook`](https://kit.svelte.dev/docs/hooks#server-hooks-handle).
+	 */
 	locals: App.Locals;
+	/**
+	 * The parameters of the current page or endpoint - e.g. for a route like `/blog/[slug]`, the `slug` parameter
+	 */
 	params: Params;
+	/**
+	 * Additional data made available through the adapter.
+	 */
 	platform: Readonly<App.Platform>;
+	/**
+	 * The original request object
+	 */
 	request: Request;
+	/**
+	 * The route ID of the current page - e.g. for `src/routes/blog/[slug]`, it would be `blog/[slug]`
+	 */
 	routeId: string | null;
+	/**
+	 * If you need to set headers for the response, you can do so using the this method. This is useful if you want the page to be cached, for example:
+	 *
+	 *	```js
+	 *	/// file: src/routes/blog/+page.js
+	 *	export async function load({ fetch, setHeaders }) {
+	 *		const url = `https://cms.example.com/articles.json`;
+	 *		const response = await fetch(url);
+	 *
+	 *		setHeaders({
+	 *			age: response.headers.get('age'),
+	 *			'cache-control': response.headers.get('cache-control')
+	 *		});
+	 *
+	 *		return response.json();
+	 *	}
+	 *	```
+	 *
+	 * Setting the same header multiple times (even in separate `load` functions) is an error — you can only set a given header once.
+	 *
+	 * You cannot add a `set-cookie` header with `setHeaders` — use the [`cookies`](https://kit.svelte.dev/docs/types#sveltejs-kit-cookies) API instead.
+	 */
 	setHeaders: (headers: Record<string, string>) => void;
+	/**
+	 * The URL of the current page or endpoint
+	 */
 	url: URL;
 }
 
@@ -415,7 +560,49 @@ export interface ServerLoadEvent<
 	Params extends Partial<Record<string, string>> = Partial<Record<string, string>>,
 	ParentData extends Record<string, any> = Record<string, any>
 > extends RequestEvent<Params> {
+	/**
+	 * `await parent()` returns data from parent `+layout.server.js` `load` functions.
+	 *
+	 * Be careful not to introduce accidental waterfalls when using `await parent()`. If for example you only want to merge parent data into the returned output, call it _after_ fetching your other data.
+	 */
 	parent: () => Promise<ParentData>;
+	/**
+	 * This function declares that the `load` function has a _dependency_ on one or more URLs or custom identifiers, which can subsequently be used with [`invalidate()`](/docs/modules#$app-navigation-invalidate) to cause `load` to rerun.
+	 *
+	 * Most of the time you won't need this, as `fetch` calls `depends` on your behalf — it's only necessary if you're using a custom API client that bypasses `fetch`.
+	 *
+	 * URLs can be absolute or relative to the page being loaded, and must be [encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).
+	 *
+	 * Custom identifiers have to be prefixed with one or more lowercase letters followed by a colon to conform to the [URI specification](https://www.rfc-editor.org/rfc/rfc3986.html).
+	 *
+	 * The following example shows how to use `depends` to register a dependency on a custom identifier, which is `invalidate`d after a button click, making the `load` function rerun.
+	 *
+	 * ```js
+	 * /// file: src/routes/+page.js
+	 * let count = 0;
+	 * export async function load({ depends }) {
+	 * 	depends('increase:count');
+	 *
+	 * 	return { count: count++ };
+	 * }
+	 * ```
+	 *
+	 * ```html
+	 * /// file: src/routes/+page.svelte
+	 * <script>
+	 * 	import { invalidate } from '$app/navigation';
+	 *
+	 * 	export let data;
+	 *
+	 * 	const increase = async () => {
+	 * 		await invalidate('increase:count');
+	 * 	}
+	 * </script>
+	 *
+	 * <p>{data.count}<p>
+	 * <button on:click={increase}>Increase Count</button>
+	 * ```
+	 */
 	depends: (...deps: string[]) => void;
 }
 
diff --git a/scripts/check-doc-links.js b/scripts/check-doc-links.js
new file mode 100644
index 000000000..a6391c194
--- /dev/null
+++ b/scripts/check-doc-links.js
@@ -0,0 +1,127 @@
+import fs from 'fs';
+import path from 'path';
+import { fileURLToPath } from 'url';
+
+const __dirname = path.dirname(fileURLToPath(import.meta.url));
+
+const doc_filenames = fs.readdirSync(path.join(__dirname, '../documentation/docs'));
+const doc_urls = new Map();
+
+// 1. collect all doc links and hashes
+
+for (const doc of doc_filenames) {
+	doc_urls.set(doc_name_to_link(doc));
+
+	const content = fs.readFileSync(path.join(__dirname, `../documentation/docs/${doc}`), 'utf-8');
+
+	const headlines = content.matchAll(/### .+/g);
+	if (!headlines) continue;
+
+	let last_headline = '';
+
+	for (let headline of headlines) {
+		let hash = slugify(headline[0].slice(3).trim());
+		if (content.charAt(headline.index - 1) === '#') {
+			hash = last_headline + '-' + hash;
+		} else {
+			last_headline = hash;
+		}
+		doc_urls.set(doc_name_to_link(doc) + '#' + hash);
+	}
+}
+
+let bad = false;
+
+// 2. check docs for broken links
+
+for (const doc of doc_filenames) {
+	const content = fs.readFileSync(path.join(__dirname, `../documentation/docs/${doc}`), 'utf-8');
+
+	const links = content.match(/\]\(([^)]+)\)/g);
+	if (!links) continue;
+
+	for (const link of links) {
+		let url = link.slice(2, -1);
+
+		if (url.startsWith('http')) continue;
+		if (url.startsWith('/faq')) continue;
+		if (url.startsWith('/docs/')) url = url.slice(6);
+		if (url.startsWith('#')) url = doc_name_to_link(doc) + url;
+
+		const [path] = url.split('#');
+		if (path === 'modules' || path === 'types') continue; // autogenerated docs
+
+		if (!doc_urls.has(url)) {
+			bad = true;
+			console.error(`Bad link: ${url} in ${doc}`);
+		}
+	}
+}
+
+// 3. check SvelteKit docs for broken links
+
+for (const file of walk_kit_dir(path.join(__dirname, '../packages/kit'))) {
+	const content = fs.readFileSync(path.join(__dirname, '../packages/kit', file), 'utf-8');
+
+	const links = content.matchAll(/https:\/\/kit\.svelte\.dev\/docs\/([a-z$\-#]+)/g);
+	if (!links) continue;
+
+	for (const [, link] of links) {
+		const [path] = link.split('#');
+		if (path === 'modules' || path === 'types') continue; // autogenerated docs
+
+		if (!doc_urls.has(link)) {
+			bad = true;
+			console.error(`Bad link: ${link} in ${file}`);
+		}
+	}
+}
+
+if (bad) {
+	process.exit(1);
+}
+
+function walk_kit_dir(cwd) {
+	/** @type {string[]} */
+	const all_files = [];
+
+	/** @param {string} dir */
+	function walk_dir(dir) {
+		const files = fs.readdirSync(path.join(cwd, dir));
+
+		for (const file of files) {
+			if (
+				['node_modules', 'test', 'tests', 'docs', '.turbo', '.svelte-kit', 'CHANGELOG.md'].includes(
+					file
+				)
+			) {
+				continue;
+			}
+
+			const joined = path.join(dir, file);
+			const stats = fs.statSync(path.join(cwd, joined));
+			if (stats.isDirectory()) {
+				walk_dir(joined);
+			} else {
+				all_files.push(joined);
+			}
+		}
+	}
+
+	return walk_dir(''), all_files;
+}
+
+function doc_name_to_link(file) {
+	return file.replace(/\.md$/, '').replace(/^\d+-/, '');
+}
+
+function slugify(title) {
+	return title
+		.toLowerCase()
+		.replace(/&lt;/g, '')
+		.replace(/&gt;/g, '')
+		.replace(/[^a-z0-9-$]/g, '-')
+		.replace(/-{2,}/g, '-')
+		.replace(/^-/, '')
+		.replace(/-$/, '');
+}
diff --git a/sites/kit.svelte.dev/package.json b/sites/kit.svelte.dev/package.json
index 2d3076bea..8c4debeac 100644
--- a/sites/kit.svelte.dev/package.json
+++ b/sites/kit.svelte.dev/package.json
@@ -2,8 +2,8 @@
 	"name": "kit.svelte.dev",
 	"version": "0.0.1",
 	"scripts": {
-		"dev": "vite dev",
-		"build": "vite build",
+		"dev": "node ../../scripts/check-doc-links.js && vite dev",
+		"build": "node ../../scripts/check-doc-links.js && vite build",
 		"prebuild": "test \"$CI\" = true && npx pnpm install --store=node_modules/.pnpm-store || echo skipping pnpm install",
 		"preview": "vite preview",
 		"test": "uvu src \"(spec\\.js|test[\\\\/]index\\.js)\""
diff --git a/sites/kit.svelte.dev/src/lib/docs/server/index.js b/sites/kit.svelte.dev/src/lib/docs/server/index.js
index 1c79bc224..6e51731f4 100644
--- a/sites/kit.svelte.dev/src/lib/docs/server/index.js
+++ b/sites/kit.svelte.dev/src/lib/docs/server/index.js
@@ -78,7 +78,7 @@ export async function read_file(dir, file) {
 			let html = '';
 
 			source = source
-				.replace(/\/\/\/ (.+?): (.+)\n/gm, (match, key, value) => {
+				.replace(/^\/\/\/ (.+?): (.+)\n/gm, (match, key, value) => {
 					options[key] = value;
 					return '';
 				})
@@ -412,6 +412,8 @@ function parse({ body, file, slug, code, codespan }) {
 export function slugify(title) {
 	return title
 		.toLowerCase()
+		.replace(/&lt;/g, '')
+		.replace(/&gt;/g, '')
 		.replace(/[^a-z0-9-$]/g, '-')
 		.replace(/-{2,}/g, '-')
 		.replace(/^-/, '')
