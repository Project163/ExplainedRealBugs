diff --git a/.changeset/silly-experts-jump.md b/.changeset/silly-experts-jump.md
new file mode 100644
index 000000000..ea57ba527
--- /dev/null
+++ b/.changeset/silly-experts-jump.md
@@ -0,0 +1,5 @@
+---
+'@sveltejs/kit': minor
+---
+
+feat: allow generated tsconfig to be modified
diff --git a/packages/kit/src/core/config/index.spec.js b/packages/kit/src/core/config/index.spec.js
index b5c802fdf..17ef82b5b 100644
--- a/packages/kit/src/core/config/index.spec.js
+++ b/packages/kit/src/core/config/index.spec.js
@@ -94,6 +94,7 @@ const get_defaults = (prefix = '') => ({
 		serviceWorker: {
 			register: true
 		},
+		typescript: {},
 		paths: {
 			base: '',
 			assets: ''
diff --git a/packages/kit/src/core/config/options.js b/packages/kit/src/core/config/options.js
index 2aa87c8a2..212a75fdb 100644
--- a/packages/kit/src/core/config/options.js
+++ b/packages/kit/src/core/config/options.js
@@ -226,6 +226,10 @@ const options = object(
 				files: fun((filename) => !/\.DS_Store/.test(filename))
 			}),
 
+			typescript: object({
+				config: fun((config) => config)
+			}),
+
 			version: object({
 				name: string(Date.now().toString()),
 				pollInterval: number(0)
@@ -362,7 +366,7 @@ function list(options, fallback = options[0]) {
 }
 
 /**
- * @param {(filename: string) => boolean} fallback
+ * @param {(...args: any) => any} fallback
  * @returns {Validator}
  */
 function fun(fallback) {
diff --git a/packages/kit/src/core/sync/write_tsconfig.js b/packages/kit/src/core/sync/write_tsconfig.js
index 007fb0d19..a90e36083 100644
--- a/packages/kit/src/core/sync/write_tsconfig.js
+++ b/packages/kit/src/core/sync/write_tsconfig.js
@@ -34,7 +34,7 @@ function remove_trailing_slashstar(file) {
 }
 
 /**
- * Writes the tsconfig that the user's tsconfig inherits from.
+ * Generates the tsconfig that the user's tsconfig inherits from.
  * @param {import('types').ValidatedKitConfig} kit
  */
 export function write_tsconfig(kit, cwd = process.cwd()) {
@@ -72,6 +72,15 @@ export function write_tsconfig(kit, cwd = process.cwd()) {
 		}
 	}
 
+	write_if_changed(out, JSON.stringify(get_tsconfig(kit, include_base_url), null, '\t'));
+}
+
+/**
+ * Generates the tsconfig that the user's tsconfig inherits from.
+ * @param {import('types').ValidatedKitConfig} kit
+ * @param {boolean} include_base_url
+ */
+export function get_tsconfig(kit, include_base_url) {
 	/** @param {string} file */
 	const config_relative = (file) => posixify(path.relative(kit.outDir, file));
 
@@ -98,40 +107,35 @@ export function write_tsconfig(kit, cwd = process.cwd()) {
 		exclude.push(config_relative(`${kit.files.serviceWorker}.d.ts`));
 	}
 
-	write_if_changed(
-		out,
-		JSON.stringify(
-			{
-				compilerOptions: {
-					// generated options
-					baseUrl: include_base_url ? config_relative('.') : undefined,
-					paths: get_tsconfig_paths(kit, include_base_url),
-					rootDirs: [config_relative('.'), './types'],
-
-					// essential options
-					// svelte-preprocess cannot figure out whether you have a value or a type, so tell TypeScript
-					// to enforce using \`import type\` instead of \`import\` for Types.
-					importsNotUsedAsValues: 'error',
-					// Vite compiles modules one at a time
-					isolatedModules: true,
-					// TypeScript doesn't know about import usages in the template because it only sees the
-					// script of a Svelte file. Therefore preserve all value imports. Requires TS 4.5 or higher.
-					preserveValueImports: true,
-
-					// This is required for svelte-package to work as expected
-					// Can be overwritten
-					lib: ['esnext', 'DOM', 'DOM.Iterable'],
-					moduleResolution: 'node',
-					module: 'esnext',
-					target: 'esnext'
-				},
-				include,
-				exclude
-			},
-			null,
-			'\t'
-		)
-	);
+	const config = {
+		compilerOptions: {
+			// generated options
+			baseUrl: include_base_url ? config_relative('.') : undefined,
+			paths: get_tsconfig_paths(kit, include_base_url),
+			rootDirs: [config_relative('.'), './types'],
+
+			// essential options
+			// svelte-preprocess cannot figure out whether you have a value or a type, so tell TypeScript
+			// to enforce using \`import type\` instead of \`import\` for Types.
+			importsNotUsedAsValues: 'error',
+			// Vite compiles modules one at a time
+			isolatedModules: true,
+			// TypeScript doesn't know about import usages in the template because it only sees the
+			// script of a Svelte file. Therefore preserve all value imports. Requires TS 4.5 or higher.
+			preserveValueImports: true,
+
+			// This is required for svelte-package to work as expected
+			// Can be overwritten
+			lib: ['esnext', 'DOM', 'DOM.Iterable'],
+			moduleResolution: 'node',
+			module: 'esnext',
+			target: 'esnext'
+		},
+		include,
+		exclude
+	};
+
+	return kit.typescript.config(config) ?? config;
 }
 
 /** @param {string} cwd */
@@ -212,7 +216,7 @@ const value_regex = /^(.*?)((\/\*)|(\.\w+))?$/;
  * @param {import('types').ValidatedKitConfig} config
  * @param {boolean} include_base_url
  */
-export function get_tsconfig_paths(config, include_base_url) {
+function get_tsconfig_paths(config, include_base_url) {
 	/** @param {string} file */
 	const config_relative = (file) => posixify(path.relative(config.outDir, file));
 
diff --git a/packages/kit/src/core/sync/write_tsconfig.spec.js b/packages/kit/src/core/sync/write_tsconfig.spec.js
index 530c32da7..083d9a5bb 100644
--- a/packages/kit/src/core/sync/write_tsconfig.spec.js
+++ b/packages/kit/src/core/sync/write_tsconfig.spec.js
@@ -1,7 +1,7 @@
 import { test } from 'uvu';
 import * as assert from 'uvu/assert';
 import { validate_config } from '../config/index.js';
-import { get_tsconfig_paths } from './write_tsconfig.js';
+import { get_tsconfig } from './write_tsconfig.js';
 
 test('Creates tsconfig path aliases from kit.alias', () => {
 	const { kit } = validate_config({
@@ -15,11 +15,11 @@ test('Creates tsconfig path aliases from kit.alias', () => {
 		}
 	});
 
-	const paths = get_tsconfig_paths(kit, false);
+	const { compilerOptions } = get_tsconfig(kit, false);
 
 	// $lib isn't part of the outcome because there's a "path exists"
 	// check in the implementation
-	assert.equal(paths, {
+	assert.equal(compilerOptions.paths, {
 		simpleKey: ['../simple/value'],
 		'simpleKey/*': ['../simple/value/*'],
 		key: ['../value'],
@@ -40,11 +40,11 @@ test('Creates tsconfig path aliases from kit.alias with existing baseUrl', () =>
 		}
 	});
 
-	const paths = get_tsconfig_paths(kit, true);
+	const { compilerOptions } = get_tsconfig(kit, true);
 
 	// $lib isn't part of the outcome because there's a "path exists"
 	// check in the implementation
-	assert.equal(paths, {
+	assert.equal(compilerOptions.paths, {
 		simpleKey: ['simple/value'],
 		'simpleKey/*': ['simple/value/*'],
 		key: ['value'],
@@ -53,4 +53,37 @@ test('Creates tsconfig path aliases from kit.alias with existing baseUrl', () =>
 	});
 });
 
+test('Allows generated tsconfig to be mutated', () => {
+	const { kit } = validate_config({
+		kit: {
+			typescript: {
+				config: (config) => {
+					config.extends = 'some/other/tsconfig.json';
+				}
+			}
+		}
+	});
+
+	const config = get_tsconfig(kit, false);
+
+	assert.equal(config.extends, 'some/other/tsconfig.json');
+});
+
+test('Allows generated tsconfig to be replaced', () => {
+	const { kit } = validate_config({
+		kit: {
+			typescript: {
+				config: (config) => ({
+					...config,
+					extends: 'some/other/tsconfig.json'
+				})
+			}
+		}
+	});
+
+	const config = get_tsconfig(kit, false);
+
+	assert.equal(config.extends, 'some/other/tsconfig.json');
+});
+
 test.run();
diff --git a/packages/kit/types/index.d.ts b/packages/kit/types/index.d.ts
index d80c735c5..4d0f5823e 100644
--- a/packages/kit/types/index.d.ts
+++ b/packages/kit/types/index.d.ts
@@ -503,6 +503,14 @@ export interface KitConfig {
 		 */
 		files?(filepath: string): boolean;
 	};
+	typescript?: {
+		/**
+		 * A function that allows you to edit the generated `tsconfig.json`. You can mutate the config (recommended) or return a new one.
+		 * This is useful for — to example — extend a shared `tsconfig.json` in a monorepo root
+		 * @default (config) => config
+		 */
+		config?: (config: Record<string, any>) => Record<string, any> | void;
+	};
 	/**
 	 * Client-side navigation can be buggy if you deploy a new version of your app while people are using it. If the code for the new page is already loaded, it may have stale content; if it isn't, the app's route manifest may point to a JavaScript file that no longer exists. SvelteKit solves this problem by falling back to traditional full-page navigation if it detects that a new version has been deployed, using the `name` specified here (which defaults to a timestamp of the build).
 	 *
