diff --git a/hadoop-common-project/hadoop-common/CHANGES.txt b/hadoop-common-project/hadoop-common/CHANGES.txt
index ba67d083f45..efb2a756c14 100644
--- a/hadoop-common-project/hadoop-common/CHANGES.txt
+++ b/hadoop-common-project/hadoop-common/CHANGES.txt
@@ -292,6 +292,9 @@ Release 0.23.3 - UNRELEASED
     HADOOP-8202. RPC stopProxy() does not close the proxy correctly.
     (Hari Mankude via suresh)
 
+    HADOOP-8218. RPC.closeProxy shouldn't throw error when closing a mock
+    (todd)
+
   BREAKDOWN OF HADOOP-7454 SUBTASKS
 
     HADOOP-7455. HA: Introduce HA Service Protocol Interface. (suresh)
diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/HealthMonitor.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/HealthMonitor.java
index 545cc448363..753352945d4 100644
--- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/HealthMonitor.java
+++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/HealthMonitor.java
@@ -17,7 +17,6 @@
  */
 package org.apache.hadoop.ha;
 
-import java.io.Closeable;
 import java.io.IOException;
 import java.util.Collections;
 import java.util.LinkedList;
@@ -195,9 +194,7 @@ private void doHealthChecks() throws InterruptedException {
       } catch (Throwable t) {
         LOG.warn("Transport-level exception trying to monitor health of " +
             targetToMonitor + ": " + t.getLocalizedMessage());
-        if (proxy instanceof Closeable) {
-          RPC.stopProxy(proxy);
-        }
+        RPC.stopProxy(proxy);
         proxy = null;
         enterState(State.SERVICE_NOT_RESPONDING);
         Thread.sleep(sleepAfterDisconnectMillis);
diff --git a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/RPC.java b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/RPC.java
index 4dd1269780e..0c848bb40d9 100644
--- a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/RPC.java
+++ b/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/RPC.java
@@ -604,6 +604,9 @@ public static void stopProxy(Object proxy) {
       LOG.error("RPC.stopProxy called on non proxy.", e);
     }
     
+    // If you see this error on a mock object in a unit test you're
+    // developing, make sure to use MockitoUtil.mockProtocol() to
+    // create your mock.
     throw new HadoopIllegalArgumentException(
         "Cannot close proxy - is not Closeable or "
             + "does not provide closeable invocation handler "
diff --git a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/DummyHAService.java b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/DummyHAService.java
index 3f9be3cacc4..a8cd3d644f9 100644
--- a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/DummyHAService.java
+++ b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/DummyHAService.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.ha;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
@@ -56,50 +57,7 @@ class DummyHAService extends HAServiceTarget {
   }
   
   private HAServiceProtocol makeMock() {
-    return Mockito.spy(new HAServiceProtocol() {
-      @Override
-      public void monitorHealth() throws HealthCheckFailedException,
-          AccessControlException, IOException {
-        checkUnreachable();
-        if (!isHealthy) {
-          throw new HealthCheckFailedException("not healthy");
-        }
-      }
-
-      @Override
-      public void transitionToActive() throws ServiceFailedException,
-          AccessControlException, IOException {
-        checkUnreachable();
-        if (failToBecomeActive) {
-          throw new ServiceFailedException("injected failure");
-        }
-
-        state = HAServiceState.ACTIVE;
-      }
-
-      @Override
-      public void transitionToStandby() throws ServiceFailedException,
-          AccessControlException, IOException {
-        checkUnreachable();
-        state = HAServiceState.STANDBY;
-      }
-
-      @Override
-      public HAServiceStatus getServiceStatus() throws IOException {
-        checkUnreachable();
-        HAServiceStatus ret = new HAServiceStatus(state);
-        if (state == HAServiceState.STANDBY) {
-          ret.setReadyToBecomeActive();
-        }
-        return ret;
-      }
-
-      private void checkUnreachable() throws IOException {
-        if (actUnreachable) {
-          throw new IOException("Connection refused (fake)");
-        }
-      }
-    });
+    return Mockito.spy(new MockHAProtocolImpl());
   }
 
   @Override
@@ -130,4 +88,54 @@ public String toString() {
   public static HAServiceTarget getInstance(int serial) {
     return instances.get(serial - 1);
   }
+  
+  private class MockHAProtocolImpl implements
+      HAServiceProtocol, Closeable {
+    @Override
+    public void monitorHealth() throws HealthCheckFailedException,
+        AccessControlException, IOException {
+      checkUnreachable();
+      if (!isHealthy) {
+        throw new HealthCheckFailedException("not healthy");
+      }
+    }
+    
+    @Override
+    public void transitionToActive() throws ServiceFailedException,
+        AccessControlException, IOException {
+      checkUnreachable();
+      if (failToBecomeActive) {
+        throw new ServiceFailedException("injected failure");
+      }
+    
+      state = HAServiceState.ACTIVE;
+    }
+    
+    @Override
+    public void transitionToStandby() throws ServiceFailedException,
+        AccessControlException, IOException {
+      checkUnreachable();
+      state = HAServiceState.STANDBY;
+    }
+    
+    @Override
+    public HAServiceStatus getServiceStatus() throws IOException {
+      checkUnreachable();
+      HAServiceStatus ret = new HAServiceStatus(state);
+      if (state == HAServiceState.STANDBY) {
+        ret.setReadyToBecomeActive();
+      }
+      return ret;
+    }
+    
+    private void checkUnreachable() throws IOException {
+      if (actUnreachable) {
+        throw new IOException("Connection refused (fake)");
+      }
+    }
+    
+    @Override
+    public void close() throws IOException {
+    }
+  }
 }
diff --git a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/TestFailoverController.java b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/TestFailoverController.java
index 218bfec4ee9..292141dabe5 100644
--- a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/TestFailoverController.java
+++ b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ha/TestFailoverController.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.ha;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 
@@ -33,7 +34,6 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockito.internal.stubbing.answers.ThrowsException;
-import org.mockito.stubbing.Answer;
 
 import static org.junit.Assert.*;
 
@@ -228,7 +228,10 @@ public void testFailoverFromNonExistantServiceWithFencer() throws Exception {
     // Getting a proxy to a dead server will throw IOException on call,
     // not on creation of the proxy.
     HAServiceProtocol errorThrowingProxy = Mockito.mock(HAServiceProtocol.class,
-        new ThrowsException(new IOException("Could not connect to host")));
+        Mockito.withSettings()
+          .defaultAnswer(new ThrowsException(
+              new IOException("Could not connect to host")))
+          .extraInterfaces(Closeable.class));
     Mockito.doReturn(errorThrowingProxy).when(svc1).getProxy();
     DummyHAService svc2 = new DummyHAService(HAServiceState.STANDBY, svc2Addr);
     svc1.fencer = svc2.fencer = setupFencer(AlwaysSucceedFencer.class.getName());
diff --git a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ipc/TestRPC.java b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ipc/TestRPC.java
index 6a3b0f718f1..5b2c6d58848 100644
--- a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ipc/TestRPC.java
+++ b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/ipc/TestRPC.java
@@ -50,6 +50,7 @@
 import org.apache.hadoop.security.token.TokenIdentifier;
 import org.apache.hadoop.security.AccessControlException;
 import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.test.MockitoUtil;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -58,8 +59,6 @@
 
 import static org.apache.hadoop.test.MetricsAsserts.*;
 
-import static org.mockito.Mockito.*;
-
 /** Unit tests for RPC. */
 @SuppressWarnings("deprecation")
 public class TestRPC {
@@ -587,9 +586,17 @@ public void testNoPings() throws Exception {
    */
   @Test(expected=HadoopIllegalArgumentException.class)
   public void testStopNonRegisteredProxy() throws Exception {
-    RPC.stopProxy(mock(TestProtocol.class));
     RPC.stopProxy(null);
   }
+
+  /**
+   * Test that the mockProtocol helper returns mock proxies that can
+   * be stopped without error.
+   */
+  @Test
+  public void testStopMockObject() throws Exception {
+    RPC.stopProxy(MockitoUtil.mockProtocol(TestProtocol.class)); 
+  }
   
   @Test
   public void testStopProxy() throws IOException {
diff --git a/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/test/MockitoUtil.java b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/test/MockitoUtil.java
new file mode 100644
index 00000000000..82abcadf279
--- /dev/null
+++ b/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/test/MockitoUtil.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.test;
+
+import java.io.Closeable;
+
+import org.mockito.Mockito;
+
+public abstract class MockitoUtil {
+
+  /**
+   * Return a mock object for an IPC protocol. This special
+   * method is necessary, since the IPC proxies have to implement
+   * Closeable in addition to their protocol interface.
+   * @param clazz the protocol class
+   */
+  public static <T> T mockProtocol(Class<T> clazz) {
+    return Mockito.mock(clazz,
+        Mockito.withSettings().extraInterfaces(Closeable.class));
+  }
+}
