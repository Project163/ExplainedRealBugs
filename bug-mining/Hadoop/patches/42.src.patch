diff --git a/CHANGES.txt b/CHANGES.txt
index b2f7ff2e82e..0feb5dcc5a0 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1092,6 +1092,9 @@ Release 0.21.0 - Unreleased
     HADOOP-6285. Fix the result type of the getParameterMap method in the
     HttpServer.QuotingInputFilter. (omalley)
 
+    HADOOP-6286. Fix bugs in related to URI handling in glob methods in 
+    FileContext. (Boris Shkolnik via suresh)
+
 Release 0.20.1 - 2009-09-01
 
   INCOMPATIBLE CHANGES
diff --git a/src/java/org/apache/hadoop/fs/FileContext.java b/src/java/org/apache/hadoop/fs/FileContext.java
index 99cb9f40a64..8604c7d8bfc 100644
--- a/src/java/org/apache/hadoop/fs/FileContext.java
+++ b/src/java/org/apache/hadoop/fs/FileContext.java
@@ -869,7 +869,11 @@ private FileStatus[] getFileStatus(Path[] paths) throws IOException {
       }
       ArrayList<FileStatus> results = new ArrayList<FileStatus>(paths.length);
       for (int i = 0; i < paths.length; i++) {
-        results.add(FileContext.this.getFileStatus(paths[i]));
+        try {
+          results.add(FileContext.this.getFileStatus(paths[i]));
+        } catch (FileNotFoundException fnfe) {
+          // ignoring 
+        }
       }
       return results.toArray(new FileStatus[results.size()]);
     }
@@ -1016,17 +1020,25 @@ public FileStatus[] globStatus(Path pathPattern) throws IOException {
      * @return an array of FileStatus objects
      * @throws IOException if any I/O error occurs when fetching file status
      */
-    public FileStatus[] globStatus(Path pathPattern, PathFilter filter)
+    public FileStatus[] globStatus(final Path pathPattern, final PathFilter filter)
       throws IOException {
+      
       String filename = pathPattern.toUri().getPath();
+      
       List<String> filePatterns = GlobExpander.expand(filename);
       if (filePatterns.size() == 1) {
-        return globStatusInternal(pathPattern, filter);
+        Path p = fixRelativePart(pathPattern);
+        FileSystem fs = getFSofPath(p);
+        URI uri = fs.getUri();
+        return globStatusInternal(uri, p, filter);
       } else {
         List<FileStatus> results = new ArrayList<FileStatus>();
         for (String filePattern : filePatterns) {
-          FileStatus[] files = 
-                      globStatusInternal(new Path(filePattern), filter);
+          Path p = new Path(filePattern);
+          p = fixRelativePart(p);
+          FileSystem fs = getFSofPath(p);
+          URI uri = fs.getUri();
+          FileStatus[] files = globStatusInternal(uri, p, filter);
           for (FileStatus file : files) {
             results.add(file);
           }
@@ -1035,15 +1047,21 @@ public FileStatus[] globStatus(Path pathPattern, PathFilter filter)
       }
     }
 
-    private FileStatus[] globStatusInternal(Path pathPattern, PathFilter filter)
+    private FileStatus[] globStatusInternal(
+        final URI uri, final Path inPathPattern, final PathFilter filter)
       throws IOException {
       Path[] parents = new Path[1];
       int level = 0;
+      
+      // comes in as full path, but just in case
+      final Path pathPattern = fixRelativePart(inPathPattern);
+      
       String filename = pathPattern.toUri().getPath();
       
       // path has only zero component
       if ("".equals(filename) || Path.SEPARATOR.equals(filename)) {
-        return getFileStatus(new Path[]{pathPattern});
+        Path p = pathPattern.makeQualified(uri, null);
+        return getFileStatus(new Path[]{p});
       }
 
       // path has at least one component
@@ -1058,11 +1076,18 @@ private FileStatus[] globStatusInternal(Path pathPattern, PathFilter filter)
 
       // glob the paths that match the parent path, ie. [0, components.length-1]
       boolean[] hasGlob = new boolean[]{false};
-      Path[] parentPaths = globPathsLevel(parents, components, level, hasGlob);
+      Path[] relParentPaths = globPathsLevel(parents, components, level, hasGlob);
       FileStatus[] results;
-      if (parentPaths == null || parentPaths.length == 0) {
+      
+      if (relParentPaths == null || relParentPaths.length == 0) {
         results = null;
       } else {
+        // fix the pathes to be abs
+        Path[] parentPaths = new Path [relParentPaths.length]; 
+        for(int i=0; i<relParentPaths.length; i++) {
+          parentPaths[i] = relParentPaths[i].makeQualified(uri, null);
+        }
+        
         // Now work on the last component of the path
         GlobFilter fp = 
                     new GlobFilter(components[components.length - 1], filter);
@@ -1374,7 +1399,7 @@ private static boolean isSameFS(Path qualPath1, Path qualPath2) {
     return (srcUri.getAuthority().equals(dstUri.getAuthority()) && srcUri
         .getAuthority().equals(dstUri.getAuthority()));
   }
-  
+
   /**
    * Deletes all the paths in deleteOnExit on JVM shutdown
    */
