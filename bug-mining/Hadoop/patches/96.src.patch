diff --git a/CHANGES.txt b/CHANGES.txt
index 50b800ced13..bf071d24a12 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -224,6 +224,8 @@ Trunk (unreleased changes)
     HADOOP-6572. Makes sure that SASL encryption and push to responder
     queue for the RPC response happens atomically. (Kan Zhang via ddas)
 
+    HADOOP-6545. Changes the Key for the FileSystem cache to be UGI (ddas)
+
 Release 0.21.0 - Unreleased
 
   INCOMPATIBLE CHANGES
diff --git a/src/java/org/apache/hadoop/fs/FileSystem.java b/src/java/org/apache/hadoop/fs/FileSystem.java
index 5cf29aecd86..be1cdc88306 100644
--- a/src/java/org/apache/hadoop/fs/FileSystem.java
+++ b/src/java/org/apache/hadoop/fs/FileSystem.java
@@ -1854,7 +1854,7 @@ public synchronized void run() {
     static class Key {
       final String scheme;
       final String authority;
-      final String username;
+      final UserGroupInformation ugi;
       final long unique;   // an artificial way to make a key unique
 
       Key(URI uri, Configuration conf) throws IOException {
@@ -1866,13 +1866,12 @@ static class Key {
         authority = uri.getAuthority()==null?"":uri.getAuthority().toLowerCase();
         this.unique = unique;
         
-        UserGroupInformation ugi = UserGroupInformation.getCurrentUser();
-        username = ugi.getUserName();
+        this.ugi = UserGroupInformation.getCurrentUser();
       }
 
       /** {@inheritDoc} */
       public int hashCode() {
-        return (scheme + authority + username).hashCode() + (int)unique;
+        return (scheme + authority).hashCode() + ugi.hashCode() + (int)unique;
       }
 
       static boolean isEqual(Object a, Object b) {
@@ -1888,7 +1887,7 @@ public boolean equals(Object obj) {
           Key that = (Key)obj;
           return isEqual(this.scheme, that.scheme)
                  && isEqual(this.authority, that.authority)
-                 && isEqual(this.username, that.username)
+                 && isEqual(this.ugi, that.ugi)
                  && (this.unique == that.unique);
         }
         return false;        
@@ -1896,7 +1895,7 @@ && isEqual(this.username, that.username)
 
       /** {@inheritDoc} */
       public String toString() {
-        return username + "@" + scheme + "://" + authority;        
+        return "("+ugi.toString() + ")@" + scheme + "://" + authority;        
       }
     }
   }
diff --git a/src/test/core/org/apache/hadoop/fs/TestFileSystemCaching.java b/src/test/core/org/apache/hadoop/fs/TestFileSystemCaching.java
index 966ec6ae9a0..8caeeb134a8 100644
--- a/src/test/core/org/apache/hadoop/fs/TestFileSystemCaching.java
+++ b/src/test/core/org/apache/hadoop/fs/TestFileSystemCaching.java
@@ -24,7 +24,16 @@
 import java.net.URI;
 
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.security.UserGroupInformation;
+import org.apache.hadoop.security.token.Token;
+import org.apache.hadoop.security.token.TokenIdentifier;
 import org.junit.Test;
+import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import static org.mockito.Mockito.mock;
+
+
 
 public class TestFileSystemCaching {
 
@@ -46,5 +55,60 @@ public void testCacheDisabled() throws Exception {
     FileSystem fs2 = FileSystem.get(new URI("uncachedfile://a"), conf);
     assertNotSame(fs1, fs2);
   }
+  
+  @SuppressWarnings("unchecked")
+  @Test
+  public <T extends TokenIdentifier> void testCacheForUgi() throws Exception {
+    final Configuration conf = new Configuration();
+    conf.set("fs.cachedfile.impl", conf.get("fs.file.impl"));
+    UserGroupInformation ugiA = UserGroupInformation.createRemoteUser("foo");
+    UserGroupInformation ugiB = UserGroupInformation.createRemoteUser("bar");
+    FileSystem fsA = ugiA.doAs(new PrivilegedExceptionAction<FileSystem>() {
+      public FileSystem run() throws Exception {
+        return FileSystem.get(new URI("cachedfile://a"), conf);
+      }
+    });
+    FileSystem fsA1 = ugiA.doAs(new PrivilegedExceptionAction<FileSystem>() {
+      public FileSystem run() throws Exception {
+        return FileSystem.get(new URI("cachedfile://a"), conf);
+      }
+    });
+    //Since the UGIs are the same, we should have the same filesystem for both
+    assertSame(fsA, fsA1);
+    
+    FileSystem fsB = ugiB.doAs(new PrivilegedExceptionAction<FileSystem>() {
+      public FileSystem run() throws Exception {
+        return FileSystem.get(new URI("cachedfile://a"), conf);
+      }
+    });
+    //Since the UGIs are different, we should end up with different filesystems
+    //corresponding to the two UGIs
+    assertNotSame(fsA, fsB);
+    
+    Token<T> t1 = mock(Token.class);
+    ugiA = UserGroupInformation.createRemoteUser("foo");
+    ugiA.addToken(t1);
+    
+    fsA = ugiA.doAs(new PrivilegedExceptionAction<FileSystem>() {
+      public FileSystem run() throws Exception {
+        return FileSystem.get(new URI("cachedfile://a"), conf);
+      }
+    });
+    //Although the users in the UGI are same, ugiA has tokens in it, and
+    //we should end up with different filesystems corresponding to the two UGIs
+    assertNotSame(fsA, fsA1);
+    
+    ugiA = UserGroupInformation.createRemoteUser("foo");
+    ugiA.addToken(t1);
+    
+    fsA1 = ugiA.doAs(new PrivilegedExceptionAction<FileSystem>() {
+      public FileSystem run() throws Exception {
+        return FileSystem.get(new URI("cachedfile://a"), conf);
+      }
+    });
+    //Now the users in the UGI are the same, and they also have the same token.
+    //We should have the same filesystem for both
+    assertSame(fsA, fsA1);
+  }
 
 }
