diff --git a/lib/compiler.js b/lib/compiler.js
index 2bc68e7..263524f 100644
--- a/lib/compiler.js
+++ b/lib/compiler.js
@@ -5,6 +5,7 @@ var filters = require('./filters');
 var doctypes = require('./doctypes');
 var runtime = require('./runtime');
 var utils = require('./utils');
+var selfClosing = require('./self-closing');
 var parseJSExpression = require('character-parser').parseMax;
 var constantinople = require('constantinople');
 
@@ -14,7 +15,11 @@ function isConstant(src) {
 function toConstant(src) {
   return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined});
 }
-
+function errorAtNode(node, error) {
+  error.line = node.line;
+  error.filename = node.filename;
+  return error;
+}
 
 /**
  * Initialize `Compiler` with the given `node`.
@@ -434,13 +439,21 @@ Compiler.prototype = {
     if (pp && !tag.isInline())
       this.prettyIndent(0, true);
 
-    if (tag.selfClosing && !this.xml) {
+    if (tag.selfClosing || (!this.xml && selfClosing.indexOf(tag.name) !== -1)) {
       this.buffer('<');
       bufferName();
       this.visitAttributes(tag.attrs, tag.attributeBlocks);
       this.terse
         ? this.buffer('>')
         : this.buffer('/>');
+      // if it is non-empty throw an error
+      if (tag.block &&
+          !(tag.block.type === 'Block' && tag.block.nodes.length === 0) &&
+          tag.block.nodes.some(function (tag) {
+            return tag.type !== 'Text' || !/^\s*$/.test(tag.val)
+          })) {
+        throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'));
+      }
     } else {
       // Optimize attributes buffering
       this.buffer('<');
@@ -476,7 +489,11 @@ Compiler.prototype = {
       function(node){ return node.val; }
     ).join('\n');
     filter.attrs.filename = this.options.filename;
-    this.buffer(filters(filter.name, text, filter.attrs), true);
+    try {
+      this.buffer(filters(filter.name, text, filter.attrs), true);
+    } catch (err) {
+      throw errorAtNode(filter, err);
+    }
   },
 
   /**
diff --git a/lib/jade.js b/lib/jade.js
index 0646a29..00b1a9d 100644
--- a/lib/jade.js
+++ b/lib/jade.js
@@ -87,39 +87,49 @@ exports.cache = {};
  */
 
 function parse(str, options){
+  // Parse
+  var parser = new (options.parser || Parser)(str, options.filename, options);
+  var tokens;
   try {
     // Parse
-    var parser = new (options.parser || Parser)(str, options.filename, options);
-
-    // Compile
-    var compiler = new (options.compiler || Compiler)(parser.parse(), options)
-      , js = compiler.compile();
-
-    // Debug compiler
-    if (options.debug) {
-      console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
-    }
-
-    var globals = [];
-
-    globals.push('jade');
-    globals.push('jade_mixins');
-    globals.push('jade_interp');
-    globals.push('jade_debug');
-    globals.push('buf');
-
-    return ''
-      + 'var buf = [];\n'
-      + 'var jade_mixins = {};\n'
-      + 'var jade_interp;\n'
-      + (options.self
-        ? 'var self = locals || {};\n' + js
-        : addWith('locals || {}', '\n' + js, globals)) + ';'
-      + 'return buf.join("");';
+    tokens = parser.parse();
   } catch (err) {
     parser = parser.context();
     runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);
   }
+
+  // Compile
+  var compiler = new (options.compiler || Compiler)(tokens, options);
+  var js;
+  try {
+    js = compiler.compile();
+  } catch (err) {
+    if (err.line && (err.filename || !options.filename)) {
+      runtime.rethrow(err, err.filename, err.line, parser.input);
+    }
+  }
+
+  // Debug compiler
+  if (options.debug) {
+    console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '));
+  }
+
+  var globals = [];
+
+  globals.push('jade');
+  globals.push('jade_mixins');
+  globals.push('jade_interp');
+  globals.push('jade_debug');
+  globals.push('buf');
+
+  return ''
+    + 'var buf = [];\n'
+    + 'var jade_mixins = {};\n'
+    + 'var jade_interp;\n'
+    + (options.self
+      ? 'var self = locals || {};\n' + js
+      : addWith('locals || {}', '\n' + js, globals)) + ';'
+    + 'return buf.join("");';
 }
 
 /**
diff --git a/lib/lexer.js b/lib/lexer.js
index 87384be..f16565f 100644
--- a/lib/lexer.js
+++ b/lib/lexer.js
@@ -2,7 +2,6 @@
 
 var utils = require('./utils');
 var characterParser = require('character-parser');
-var selfClosing = require('./self-closing');
 
 
 /**
@@ -227,7 +226,7 @@ Lexer.prototype = {
       } else {
         tok = this.tok('tag', name);
       }
-      tok.selfClosing = !!captures[2] || selfClosing.indexOf(name) !== -1;
+      tok.selfClosing = !!captures[2];
       return tok;
     }
   },
diff --git a/lib/parser.js b/lib/parser.js
index 5277ca1..8f01e9f 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -765,12 +765,6 @@ Parser.prototype = {
       this.advance();
     }
 
-    if (tag.selfClosing
-        && ['newline', 'outdent', 'eos'].indexOf(this.peek().type) === -1
-        && (this.peek().type !== 'text' || !/^\s*$/.test(this.peek().val))) {
-      throw new Error(tag.name + ' is self closing and should not have content.');
-    }
-
     // (text | code | ':')?
     switch (this.peek().type) {
       case 'text':
diff --git a/test/cases/xml.html b/test/cases/xml.html
new file mode 100644
index 0000000..5fd9f1a
--- /dev/null
+++ b/test/cases/xml.html
@@ -0,0 +1,3 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<category term="some term"/>
+<link>http://google.com</link>
\ No newline at end of file
diff --git a/test/cases/xml.jade b/test/cases/xml.jade
new file mode 100644
index 0000000..2b21fa4
--- /dev/null
+++ b/test/cases/xml.jade
@@ -0,0 +1,3 @@
+doctype xml
+category(term='some term')/
+link http://google.com
\ No newline at end of file
