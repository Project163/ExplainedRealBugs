diff --git a/Readme.md b/Readme.md
index c2d126e..cbfce41 100644
--- a/Readme.md
+++ b/Readme.md
@@ -9,6 +9,7 @@
   - high performance parser
   - great readability
   - flexible indentation
+  - block-expansion
   - code is escaped by default for security
   - contextual error reporting at compile &amp; run time
   - executable for compiling jade templates via the command line
@@ -247,25 +248,26 @@ outputs:
 
 ### Nesting
 
-    ul
-      li one
-      li two
-      li three
-
-Messed up your whitespace? no worries, jade's error reporting should help you out.
-Jade instruments the compiled JavaScript to provide meaningful context for runtime exceptions.
+ Jade supports nesting to define the tags in a natural way:
 
     ul
-        li one
-      li two
+      li.first
+        a(href='#') foo
+      li
+        a(href='#') bar
+      li.last
+        a(href='#') baz
 
-    Error: /Users/tj/Projects/jade/examples/layout.jade:2
-	    1. 'ul'
-	    2. '    li one'
+### Block Expansion
 
-	Invalid indentation, got 2 expected 1.
+ Block expansion allows you to create terse single-line nested tags,
+ the following example is equivalent to the nesting example above.
+
+      ul
+        li.first: a(href='#') foo
+        li: a(href='#') bar
+        li.last: a(href='#') baz
 
-Note: Trailing outdents are generated on **EOS** (end-of-source) if not present.
 
 ### Attributes
 
diff --git a/lib/lexer.js b/lib/lexer.js
index bd90d79..1bed7ab 100644
--- a/lib/lexer.js
+++ b/lib/lexer.js
@@ -190,7 +190,20 @@ Lexer.prototype = {
    */
   
   get tag() {
-    return this.scan(/^(\w[-:\w]*)/, 'tag');
+    var captures;
+    if (captures = /^(\w[-:\w]*)/.exec(this.input)) {
+      this.consume(captures[0].length);
+      var tok, name = captures[1];
+      if (':' == name[name.length - 1]) {
+        name = name.slice(0, -1);
+        tok = this.tok('tag', name);
+        this.deferredTokens.push(this.tok(':'));
+        while (' ' == this.input[0]) this.input = this.input.substr(1);
+      } else {
+        tok = this.tok('tag', name);
+      }
+      return tok;
+    }
   },
   
   /**
@@ -411,6 +424,14 @@ Lexer.prototype = {
     }
   },
 
+  /**
+   * ':'
+   */
+
+  get colon() {
+    return this.scan(/^: */, ':');
+  },
+
   /**
    * Return the next token object, or those
    * previously stashed by lookahead.
@@ -446,6 +467,7 @@ Lexer.prototype = {
       || this.indent
       || this.comment
       || this.blockComment
+      || this.colon
       || this.text;
   }
 };
diff --git a/lib/parser.js b/lib/parser.js
index 7ce57f1..49288d2 100644
--- a/lib/parser.js
+++ b/lib/parser.js
@@ -327,7 +327,7 @@ Parser.prototype = {
   },
 
   /**
-   * tag (attrs | class | id)* (text | code)? newline* block?
+   * tag (attrs | class | id)* (text | code | ':')? newline* block?
    */
   
   parseTag: function(){
@@ -359,7 +359,7 @@ Parser.prototype = {
         }
       }
 
-    // (text | code)?
+    // (text | code | ':')?
     switch (this.peek.type) {
       case 'text':
         tag.text = this.parseText();
@@ -367,6 +367,11 @@ Parser.prototype = {
       case 'code':
         tag.code = this.parseCode();
         break;
+      case ':':
+        this.advance;
+        tag.block = new nodes.Block;
+        tag.block.push(this.parseTag());
+        break;
     }
 
     // newline*
diff --git a/test/jade.test.js b/test/jade.test.js
index 2dde818..b365b2b 100644
--- a/test/jade.test.js
+++ b/test/jade.test.js
@@ -86,6 +86,11 @@ module.exports = {
         assert.equal("<p>'foo'\n</p>", render("p\n  | 'foo'"));
         assert.equal('<a href="/foo"></a>', render("- var path = 'foo';\na(href='/' + path)"));
     },
+
+    'test block-expansion': function(assert){
+        assert.equal("<li><a>foo</a></li><li><a>bar</a></li><li><a>baz</a></li>", render("li: a foo\nli: a bar\nli: a baz"));
+        assert.equal("<li class=\"first\"><a>foo</a></li><li><a>bar</a></li><li><a>baz</a></li>", render("li.first: a foo\nli: a bar\nli: a baz"));
+    },
     
     'test tags': function(assert){
         var str = [
