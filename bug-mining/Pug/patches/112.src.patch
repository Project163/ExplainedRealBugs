diff --git a/lib/compiler.js b/lib/compiler.js
index 4253ec2..71b8d5d 100644
--- a/lib/compiler.js
+++ b/lib/compiler.js
@@ -137,8 +137,9 @@ Compiler.prototype = {
    */
 
   bufferExpression: function (src) {
+    var fn = Function('', 'return (' + src + ');');
     if (isConstant(src)) {
-      return this.buffer(toConstant(src), false)
+      return this.buffer(fn(), false)
     }
     if (this.lastBufferedIdx == this.buf.length) {
       if (this.lastBufferedType === 'text') this.lastBuffered += '"';
diff --git a/lib/lexer.js b/lib/lexer.js
index a4c02be..b85e773 100644
--- a/lib/lexer.js
+++ b/lib/lexer.js
@@ -5,7 +5,8 @@
  */
 
 var utils = require('./utils');
-var parseJSExpression = require('character-parser').parseMax;
+var characterParser = require('character-parser');
+
 
 /**
  * Initialize `Lexer` with the given `str`.
@@ -34,7 +35,16 @@ var Lexer = module.exports = function Lexer(str, options) {
 
 
 function assertExpression(exp) {
-  Function('', 'return (' + exp + ')')
+  //this verifies that a JavaScript expression is valid
+  Function('', 'return (' + exp + ')');
+}
+function assertNestingCorrect(exp) {
+  //this verifies that code is properly nested, but allows
+  //invalid JavaScript such as the contents of `attributes`
+  var res = characterParser(exp)
+  if (res.isNesting()) {
+    throw new Error('Nesting must match on expression `' + exp + '`')
+  }
 }
 /**
  * Lexer prototype.
@@ -124,7 +134,7 @@ Lexer.prototype = {
     var start = this.input[skip];
     if (start != '(' && start != '{' && start != '[') throw new Error('unrecognized start character');
     var end = ({'(': ')', '{': '}', '[': ']'})[start];
-    var range = parseJSExpression(this.input, {start: skip + 1});
+    var range = characterParser.parseMax(this.input, {start: skip + 1});
     if (this.input[range.end] !== end) throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]);
     return range;
   },
@@ -523,6 +533,8 @@ Lexer.prototype = {
         , c
         , p;
 
+      assertNestingCorrect(str)
+
       function state(){
         return states[states.length - 1];
       }
@@ -533,7 +545,7 @@ Lexer.prototype = {
           return attr.replace(/(\\)?#\{(.+)/g, function(_, escape, expr){
             if (escape) return _;
             try {
-              var range = parseJSExpression(expr);
+              var range = characterParser.parseMax(expr);
               if (expr[range.end] !== '}') return _.substr(0, 2) + recurse(_.substr(2));
               assertExpression(range.src)
               return quote + " + (" + range.src + ") + " + quote + recurse(expr.substr(range.end + 1));
diff --git a/package.json b/package.json
index 6c514c6..d106046 100644
--- a/package.json
+++ b/package.json
@@ -13,7 +13,7 @@
     "commander": "2.0.0",
     "mkdirp": "0.3.x",
     "transformers": "2.1.0",
-    "character-parser": "1.0.2",
+    "character-parser": "1.1.0",
     "monocle": "1.1.50",
     "with": "~1.1.0",
     "constantinople": "~1.0.1"
diff --git a/test/anti-cases/open-brace-in-attributes.jade b/test/anti-cases/open-brace-in-attributes.jade
new file mode 100644
index 0000000..7b5f21d
--- /dev/null
+++ b/test/anti-cases/open-brace-in-attributes.jade
@@ -0,0 +1 @@
+div(title=[)
\ No newline at end of file
