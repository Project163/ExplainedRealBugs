diff --git a/README.md b/README.md
index 44ac212..8cc793d 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 # solarpositioning
 ![CI](https://github.com/KlausBrunner/solarpositioning/workflows/Java%20CI%20with%20Maven/badge.svg)
 
-This is a Java library for finding topocentric solar coordinates, i.e. the sun’s position on the sky at a given date, latitude, and longitude (and other parameters). Calculations are based on well-known published algorithms: [SPA](http://dx.doi.org/10.1016/j.solener.2003.12.003) by Reda and Andreas and, alternatively, [Grena/ENEA](http://dx.doi.org/10.1016/j.solener.2012.01.024) by Grena or [PSA](http://dx.doi.org/10.1016/S0038-092X(00)00156-0) by Blanco-Muriel et al.
+This is a Java library for finding topocentric solar coordinates, i.e. the sun’s position on the sky at a given date, latitude, and longitude (and other parameters). Calculations are based on well-known published algorithms: [SPA](http://dx.doi.org/10.1016/j.solener.2003.12.003) by Reda and Andreas and, alternatively, [Grena/ENEA](http://dx.doi.org/10.1016/j.solener.2012.01.024) by Grena.
 
 ## Usage
 
@@ -11,54 +11,53 @@ This is a Java library for finding topocentric solar coordinates, i.e. the sun
 <dependency>
     <groupId>net.e175.klaus</groupId>
     <artifactId>solarpositioning</artifactId>
-    <version>0.0.10</version> <!-- or whatever latest release is -->
+    <version>0.1.0</version> <!-- or whatever latest release is -->
 </dependency>
 ```
 
-Occasional snapshots are deployed to https://oss.sonatype.org/content/repositories/snapshots
-
 ### Code
 
 ```java
 import net.e175.klaus.solarpositioning.*;
 
+import java.time.ZonedDateTime;
+
 public class App {
-  public static void main(String[] args) {
-    final GregorianCalendar dateTime = new GregorianCalendar();
-
-    AzimuthZenithAngle position = SPA.calculateSolarPosition(
-                                            dateTime,
-                                            48.21, // latitude (degrees)
-                                            16.37, // longitude (degrees)
-                                            190, // elevation (m)
-                                            DeltaT.estimate(dateTime), // delta T (s)
-                                            1010, // avg. air pressure (hPa)
-                                            11); // avg. air temperature (°C)
-    System.out.println("SPA: " + position);
-  }
+    public static void main(String[] args) {
+        final ZonedDateTime dateTime = new ZonedDateTime.now();
+
+        AzimuthZenithAngle position = SPA.calculateSolarPosition(
+                dateTime,
+                48.21, // latitude (degrees)
+                16.37, // longitude (degrees)
+                190, // elevation (m)
+                DeltaT.estimate(dateTime), // delta T (s)
+                1010, // avg. air pressure (hPa)
+                11); // avg. air temperature (°C)
+        System.out.println("SPA: " + position);
+    }
 }
 ```
 
+### Requirements
+
+Java SE 8. (0.0.10 was the last version to work on Java 6, if you are stuck in the dark ages.)
+
 ### Which algorithm should I use?
 
 * For many applications, Grena3 should work just fine. It's fast and pretty accurate for a time window from 2010 to 2110 CE.
 * If you're looking for maximum accuracy or need to calculate for historic dates, use SPA. It's widely considered the reference algorithm for solar positioning, being very accurate and usable in a very large time window. Its only downside is that it's relatively slow.
-* PSA is another fast and simple algorithm, but should not be used for new applications due to its limited time window. It is currently kept for backwards compatibility.
-
-### Is the code thread-safe?
-
-Yes. None of the classes hold any mutable shared state. As the calculation is obviously CPU-bound, explicit multithreading does make sense whenever a lot of positions need to be calculated.
 
 ### How do I get the time of sunrise or sunset?
 
-The SPA class now includes a method to calculate the times of sunrise, sun transit, and sunset in one fell swoop:
+The SPA class includes a method to calculate the times of sunrise, sun transit, and sunset in one fell swoop:
 
 ```java
-GregorianCalendar[] res = SPA.calculateSunriseTransitSet(
-                                    time, 
-                                    70.978056, // latitude  
-                                    25.974722, // longitude
-                                    68); // delta T
+SunriseTransitSet res = SPA.calculateSunriseTransitSet(
+                            dateTime, 
+                            70.978056, // latitude  
+                            25.974722, // longitude
+                            68); // delta T
 ```
 
 Notes:
@@ -66,7 +65,8 @@ Notes:
  * The times of sunrise and sunset may be null if the sun never sets or rises during the specified day (i.e. polar days and nights).
  * Calculation is based on the usual correction of 0.8333° on the zenith angle, i.e. sunrise and sunset are assumed to occur when the center of the solar disc is 50 arc-minutes below the 90° horizon.
  * For various reasons, sunrise and sunset times may differ from those given by other sources. If you feel there's something wrong with the results of this library, please make sure to compare with a reputable source such as the [NOAA calculator](http://www.esrl.noaa.gov/gmd/grad/solcalc/) and not one of the many quick-and-dirty algorithms found on the Web.   
- * As a general note on accuracy, Jean Meeus advises that "giving rising or setting times .. more accurately than to the nearest minute makes no sense" (_Astronomical Algorithms_). Errors increase the farther observer's position from the equator, i.e. values for polar regions are much less reliable.
+ * As a general note on accuracy, Jean Meeus advises that "giving rising or setting times .. more accurately than to the nearest minute makes no sense" (_Astronomical Algorithms_). Errors increase the farther the position from the equator, i.e. values for polar regions are much less reliable.    
+ * The goal of this implementation is to stay close to the reference implementation of SPA, using other sources for sanity checks only.
 
 ### What's with this "delta T" thing?
 
@@ -76,3 +76,6 @@ The DeltaT class provides an estimator based on polynomials fitting a number of
 
 ![deltat](resources/deltat.png)
 
+### Is the code thread-safe?
+
+Yes. None of the classes hold any mutable shared state. As the calculation is obviously CPU-bound, explicit multithreading does make sense whenever a lot of positions need to be calculated.
diff --git a/pom.xml b/pom.xml
index 755047a..258f2cc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,9 +1,10 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
 
     <groupId>net.e175.klaus</groupId>
     <artifactId>solarpositioning</artifactId>
-    <version>0.0.11-SNAPSHOT</version>
+    <version>0.1.0-SNAPSHOT</version>
     <packaging>jar</packaging>
 
     <name>solarpositioning</name>
@@ -14,8 +15,8 @@
     <url>https://github.com/KlausBrunner/solarpositioning</url>
     <licenses>
         <license>
-            <name>MIT License</name>
-            <url>http://www.opensource.org/licenses/mit-license.php</url>
+            <name>MIT</name>
+            <url>https://spdx.org/licenses/MIT.html</url>
         </license>
     </licenses>
 
@@ -44,31 +45,9 @@
                 <artifactId>maven-compiler-plugin</artifactId>
                 <version>3.10.1</version>
                 <configuration>
-                    <source>1.6</source>
-                    <target>1.6</target>
+                    <release>8</release> <!-- NOTE: this requires at least JDK version 9 compiler -->
                 </configuration>
             </plugin>
-            <plugin>
-                <groupId>org.codehaus.mojo</groupId>
-                <artifactId>animal-sniffer-maven-plugin</artifactId>
-                <version>1.22</version>
-                <configuration>
-                    <signature>
-                        <groupId>org.codehaus.mojo.signature</groupId>
-                        <artifactId>java16</artifactId>
-                        <version>1.0</version>
-                    </signature>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>ensure-class-library-version</id>
-                        <phase>test</phase>
-                        <goals>
-                            <goal>check</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-release-plugin</artifactId>
@@ -82,44 +61,9 @@
             </plugin>
         </plugins>
     </build>
-
-    <dependencies>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.13.2</version>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
-
     <profiles>
         <profile>
             <id>publish</id>
-            <!-- OSSRH repo publishing.
-            settings.xml template:
-
-            <settings>
-              <servers>
-                <server>
-                  <id>ossrh</id>
-                  <username>XXXXXXXXX</username>
-                  <password>XXXXXXXX</password>
-                </server>
-              </servers>
-
-              <profiles>
-                <profile>
-                  <id>ossrh</id>
-                  <activation>
-                    <activeByDefault>true</activeByDefault>
-                  </activation>
-                  <properties>
-                    <gpg.executable>gpg2</gpg.executable>
-                    </properties>
-                </profile>
-              </profiles>
-             </settings>
-            -->
             <distributionManagement>
                 <snapshotRepository>
                     <id>ossrh</id>
@@ -183,4 +127,13 @@
             </build>
         </profile>
     </profiles>
+
+    <dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.13.2</version>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
 </project>
diff --git a/src/main/java/net/e175/klaus/solarpositioning/AzimuthZenithAngle.java b/src/main/java/net/e175/klaus/solarpositioning/AzimuthZenithAngle.java
index 301b77c..c3fd673 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/AzimuthZenithAngle.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/AzimuthZenithAngle.java
@@ -1,9 +1,9 @@
 package net.e175.klaus.solarpositioning;
 
 /**
- * A simple wrapper class for keeping an azimuth/zenith angle pair of values.
+ * A simple data class for keeping an azimuth/zenith angle pair of values.
  */
-public class AzimuthZenithAngle {
+public final class AzimuthZenithAngle {
     private final double azimuth;
     private final double zenithAngle;
 
@@ -12,17 +12,19 @@ public class AzimuthZenithAngle {
         this.azimuth = azimuth;
     }
 
-    public final double getZenithAngle() {
+    public double getZenithAngle() {
         return zenithAngle;
     }
 
-    public final double getAzimuth() {
+    public double getAzimuth() {
         return azimuth;
     }
 
     @Override
     public String toString() {
-        return String.format("azimuth %.6f°, zenith angle %.6f°", azimuth, zenithAngle);
+        return "AzimuthZenithAngle{" +
+                String.format("azimuth=%.6f°", azimuth) +
+                String.format(", zenithAngle=%.6f°", zenithAngle) +
+                '}';
     }
-
 }
diff --git a/src/main/java/net/e175/klaus/solarpositioning/Grena3.java b/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
index 4ef9f8f..fd96022 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
@@ -1,17 +1,16 @@
 package net.e175.klaus.solarpositioning;
 
-import java.util.Calendar;
-import java.util.GregorianCalendar;
+import java.time.ZonedDateTime;
 
 import static java.lang.Math.*;
 
 /**
  * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
  * certain point of the Earth's surface.
- *
+ * <p>
  * This follows the no. 3 algorithm described in Grena, 'Five new algorithms for the computation of sun position
  * from 2010 to 2110', Solar Energy 86 (2012) pp. 1323-1337.
- *
+ * <p>
  * This is <i>not</i> a port of the C code, but a re-implementation based on the published procedure.
  *
  * @author Klaus Brunner
@@ -24,12 +23,12 @@ public final class Grena3 {
     /**
      * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
      * certain point of the Earth's surface.
-     *
+     * <p>
      * This follows the no. 3 algorithm described in Grena, 'Five new algorithms for the computation of sun position
      * from 2010 to 2110', Solar Energy 86 (2012) pp. 1323-1337.
-     *
+     * <p>
      * The algorithm is supposed to work for the years 2010 to 2110, with a maximum error of 0.01 degrees.
-     *
+     * <p>
      * This method does not perform refraction correction.
      *
      * @param date      Observer's local date and time.
@@ -42,7 +41,7 @@ public final class Grena3 {
      * @return Topocentric solar position (azimuth measured eastward from north)
      * @see AzimuthZenithAngle
      */
-    public static AzimuthZenithAngle calculateSolarPosition(final GregorianCalendar date, final double latitude,
+    public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
                                                             final double longitude, final double deltaT) {
         return calculateSolarPosition(date, latitude, longitude, deltaT, Double.MIN_VALUE, Double.MIN_VALUE);
     }
@@ -50,10 +49,10 @@ public final class Grena3 {
     /**
      * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
      * certain point of the Earth's surface.
-     *
+     * <p>
      * This follows the no. 3 algorithm described in Grena, 'Five new algorithms for the computation of sun position
      * from 2010 to 2110', Solar Energy 86 (2012) pp. 1323-1337.
-     *
+     * <p>
      * The algorithm is supposed to work for the years 2010 to 2110, with a maximum error of 0.01 degrees.
      *
      * @param date        Observer's local date and time.
@@ -69,7 +68,7 @@ public final class Grena3 {
      * @return Topocentric solar position (azimuth measured eastward from north)
      * @see AzimuthZenithAngle
      */
-    public static AzimuthZenithAngle calculateSolarPosition(final GregorianCalendar date, final double latitude,
+    public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
                                                             final double longitude, final double deltaT, final double pressure,
                                                             final double temperature) {
         final double t = calcT(date);
@@ -114,24 +113,24 @@ public final class Grena3 {
         // refraction correction (disabled for silly parameter values)
         final double deltaRe =
                 (temperature < -273 || temperature > 273 || pressure < 0 || pressure > 3000) ? 0.0 : (
-                ((eP > 0.0) ?
-                        (0.08422 * (pressure / 1000)) / ((273.0 + temperature) * tan(eP + 0.003138 / (eP + 0.08919)))
-                        : 0.0));
+                        ((eP > 0.0) ?
+                                (0.08422 * (pressure / 1000)) / ((273.0 + temperature) * tan(eP + 0.003138 / (eP + 0.08919)))
+                                : 0.0));
 
         final double z = PI / 2 - eP - deltaRe;
 
         return new AzimuthZenithAngle(toDegrees(gamma + PI) % 360.0, toDegrees(z));
     }
 
-    private static double calcT(GregorianCalendar date) {
-        GregorianCalendar utc = JulianDate.createUtcCalendar(date);
+    private static double calcT(ZonedDateTime date) {
+        ZonedDateTime utc = JulianDate.createUtcCalendar(date);
 
-        int m = utc.get(Calendar.MONTH) + 1;
-        int y = utc.get(Calendar.YEAR);
-        final int d = utc.get(Calendar.DAY_OF_MONTH);
-        final double h = utc.get(Calendar.HOUR_OF_DAY) +
-                utc.get(Calendar.MINUTE) / 60d +
-                utc.get(Calendar.SECOND) / (60d * 60);
+        int m = utc.getMonthValue();
+        int y = utc.getYear();
+        final int d = utc.getDayOfMonth();
+        final double h = utc.getHour() +
+                utc.getMinute() / 60d +
+                utc.getSecond() / (60d * 60);
 
         if (m <= 2) {
             m += 12;
diff --git a/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java b/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java
index de0057e..ac86a9e 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java
@@ -1,8 +1,7 @@
 package net.e175.klaus.solarpositioning;
 
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.TimeZone;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
 
 /**
  * Calculate Julian date for a given point in time. This follows the algorithm described in Reda, I.; Andreas, A.
@@ -20,8 +19,8 @@ public final class JulianDate {
      *
      * @param date date and time
      */
-    public JulianDate(final GregorianCalendar date) {
-        GregorianCalendar utcCalendar = createUtcCalendar(date);
+    public JulianDate(final ZonedDateTime date) {
+        ZonedDateTime utcCalendar = createUtcCalendar(date);
         this.julianDate = calcJulianDate(utcCalendar);
         this.deltaT = 0.0;
     }
@@ -38,37 +37,33 @@ public final class JulianDate {
     /**
      * Construct a Julian date, observing deltaT.
      *
-     * @param date date and time
+     * @param date   date and time
      * @param deltaT Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time),
      *               in seconds. See
      *               <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http://asa.usno.navy.mil/SecK/DeltaT.html</a>.
      *               For the year 2015, a reasonably accurate default would be 68.
      */
-    public JulianDate(final GregorianCalendar date, final double deltaT) {
-        GregorianCalendar calendar = createUtcCalendar(date);
+    public JulianDate(final ZonedDateTime date, final double deltaT) {
+        ZonedDateTime calendar = createUtcCalendar(date);
         this.julianDate = calcJulianDate(calendar);
         this.deltaT = deltaT;
     }
 
-    static GregorianCalendar createUtcCalendar(final GregorianCalendar fromCalendar) {
-        final GregorianCalendar utcCalendar = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
-        utcCalendar.setTimeInMillis(fromCalendar.getTimeInMillis());
-        utcCalendar.set(Calendar.ERA, fromCalendar.get(Calendar.ERA));
-        return utcCalendar;
+    static ZonedDateTime createUtcCalendar(final ZonedDateTime fromCalendar) {
+        return fromCalendar.withZoneSameInstant(ZoneOffset.UTC);
     }
 
-    private double calcJulianDate(GregorianCalendar calendar) {
-        int y = (calendar.get(Calendar.ERA) == GregorianCalendar.AD) ? calendar.get(Calendar.YEAR) : -calendar
-                .get(Calendar.YEAR);
-        int m = calendar.get(Calendar.MONTH) + 1;
+    private double calcJulianDate(ZonedDateTime calendar) {
+        int y = calendar.getYear();
+        int m = calendar.getMonthValue();
 
         if (m < 3) {
             y = y - 1;
             m = m + 12;
         }
 
-        final double d = calendar.get(Calendar.DAY_OF_MONTH)
-                + (calendar.get(Calendar.HOUR_OF_DAY) + (calendar.get(Calendar.MINUTE) + calendar.get(Calendar.SECOND) / 60.0) / 60.0)
+        final double d = calendar.getDayOfMonth()
+                + (calendar.getHour() + (calendar.getMinute() + calendar.getSecond() / 60.0) / 60.0)
                 / 24.0;
         final double jd = Math.floor(365.25 * (y + 4716.0)) + Math.floor(30.6001 * (m + 1)) + d - 1524.5;
         final double a = Math.floor(y / 100.0);
diff --git a/src/main/java/net/e175/klaus/solarpositioning/PSA.java b/src/main/java/net/e175/klaus/solarpositioning/PSA.java
deleted file mode 100644
index 78d83c3..0000000
--- a/src/main/java/net/e175/klaus/solarpositioning/PSA.java
+++ /dev/null
@@ -1,143 +0,0 @@
-package net.e175.klaus.solarpositioning;
-
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.TimeZone;
-
-/**
- * Compute sun position for a given date/time and longitude/latitude.
- *
- * This is a simple Java port of the "PSA" solar positioning algorithm, as documented in:
- *
- * Blanco-Muriel et al.: Computing the Solar Vector. Solar Energy Vol 70 No 5 pp 431-441.
- * http://dx.doi.org/10.1016/S0038-092X(00)00156-0
- *
- * According to the paper, "The algorithm allows .. the true solar vector to be determined with an accuracy of 0.5
- * minutes of arc for the period 1999–2015."
- *
- * @author Klaus A. Brunner
- * @deprecated PSA shouldn't be used after the year 2015.
- */
-public final class PSA {
-
-    private static final double D_EARTH_MEAN_RADIUS = 6371.01; // in km
-    private static final double D_ASTRONOMICAL_UNIT = 149597890; // in km
-
-    private static final double PI = Math.PI;
-    private static final double TWOPI = (2 * PI);
-    private static final double RAD = (PI / 180);
-
-    private PSA() {
-    }
-
-    /**
-     * Calculate sun position for a given time and location.
-     *
-     * @param date      Note that it's unclear how well the algorithm performs before the year 1990 or after the year 2015.
-     * @param latitude  in degrees (positive east of Greenwich)
-     * @param longitude in degrees (positive north of equator)
-     * @return Topocentric solar position (azimuth measured eastward from north)
-     */
-    public static AzimuthZenithAngle calculateSolarPosition(final GregorianCalendar date, final double latitude, final double longitude) {
-        final Calendar utcTime = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-        utcTime.setTimeInMillis(date.getTimeInMillis());
-
-        // Main variables
-        double dElapsedJulianDays;
-        double dDecimalHours;
-        double dEclipticLongitude;
-        double dEclipticObliquity;
-        double dRightAscension;
-        double dDeclination;
-
-        // Auxiliary variables
-        double dY;
-        double dX;
-
-        // Calculate difference in days between the current Julian Day
-        // and JD 2451545.0, which is noon 1 January 2000 Universal Time
-
-        {
-            long liAux1;
-            long liAux2;
-            double dJulianDate;
-            // Calculate time of the day in UT decimal hours
-            dDecimalHours = utcTime.get(Calendar.HOUR_OF_DAY)
-                    + (utcTime.get(Calendar.MINUTE) + utcTime.get(Calendar.SECOND) / 60.0) / 60.0;
-            // Calculate current Julian Day
-            liAux1 = (utcTime.get(Calendar.MONTH) + 1 - 14) / 12;
-            liAux2 = (1461 * (utcTime.get(Calendar.YEAR) + 4800 + liAux1)) / 4
-                    + (367 * (utcTime.get(Calendar.MONTH) + 1 - 2 - 12 * liAux1)) / 12
-                    - (3 * ((utcTime.get(Calendar.YEAR) + 4900 + liAux1) / 100)) / 4
-                    + utcTime.get(Calendar.DAY_OF_MONTH) - 32075;
-            dJulianDate = (liAux2) - 0.5 + dDecimalHours / 24.0;
-            // Calculate difference between current Julian Day and JD 2451545.0
-            dElapsedJulianDays = dJulianDate - 2451545.0;
-        }
-
-        // Calculate ecliptic coordinates (ecliptic longitude and obliquity of the
-        // ecliptic in radians but without limiting the angle to be less than 2*Pi
-        // (i.e., the result may be greater than 2*Pi)
-        {
-            double dMeanLongitude;
-            double dMeanAnomaly;
-            double dOmega;
-            dOmega = 2.1429 - 0.0010394594 * dElapsedJulianDays;
-            dMeanLongitude = 4.8950630 + 0.017202791698 * dElapsedJulianDays; // Radians
-            dMeanAnomaly = 6.2400600 + 0.0172019699 * dElapsedJulianDays;
-            dEclipticLongitude = dMeanLongitude + 0.03341607 * Math.sin(dMeanAnomaly) + 0.00034894
-                    * Math.sin(2 * dMeanAnomaly) - 0.0001134 - 0.0000203 * Math.sin(dOmega);
-            dEclipticObliquity = 0.4090928 - 6.2140e-9 * dElapsedJulianDays + 0.0000396 * Math.cos(dOmega);
-        }
-
-        // Calculate celestial coordinates ( right ascension and declination ) in radians
-        // but without limiting the angle to be less than 2*Pi (i.e., the result
-        // may be greater than 2*Pi)
-        {
-            double dSinEclipticLongitude;
-            dSinEclipticLongitude = Math.sin(dEclipticLongitude);
-            dY = Math.cos(dEclipticObliquity) * dSinEclipticLongitude;
-            dX = Math.cos(dEclipticLongitude);
-            dRightAscension = Math.atan2(dY, dX);
-            if (dRightAscension < 0.0) {
-                dRightAscension = dRightAscension + 2 * Math.PI;
-            }
-            dDeclination = Math.asin(Math.sin(dEclipticObliquity) * dSinEclipticLongitude);
-        }
-
-        // Calculate local coordinates ( azimuth and zenith angle ) in degrees
-        {
-            double dGreenwichMeanSiderealTime;
-            double dLocalMeanSiderealTime;
-            double dLatitudeInRadians;
-            double dHourAngle;
-            double dCosLatitude;
-            double dSinLatitude;
-            double dCosHourAngle;
-            double dParallax;
-            dGreenwichMeanSiderealTime = 6.6974243242 + 0.0657098283 * dElapsedJulianDays + dDecimalHours;
-            dLocalMeanSiderealTime = (dGreenwichMeanSiderealTime * 15 + longitude) * RAD;
-            dHourAngle = dLocalMeanSiderealTime - dRightAscension;
-            dLatitudeInRadians = latitude * RAD;
-            dCosLatitude = Math.cos(dLatitudeInRadians);
-            dSinLatitude = Math.sin(dLatitudeInRadians);
-            dCosHourAngle = Math.cos(dHourAngle);
-            double zenithAngle = (Math.acos(dCosLatitude * dCosHourAngle * Math.cos(dDeclination)
-                    + Math.sin(dDeclination) * dSinLatitude));
-            dY = -Math.sin(dHourAngle);
-            dX = Math.tan(dDeclination) * dCosLatitude - dSinLatitude * dCosHourAngle;
-            double azimuth = Math.atan2(dY, dX);
-            if (azimuth < 0.0) {
-                azimuth = azimuth + TWOPI;
-            }
-            azimuth = azimuth / RAD;
-            // Parallax Correction
-            dParallax = (D_EARTH_MEAN_RADIUS / D_ASTRONOMICAL_UNIT) * Math.sin(zenithAngle);
-            zenithAngle = (zenithAngle + dParallax) / RAD;
-
-            return new AzimuthZenithAngle(azimuth, zenithAngle);
-        }
-
-    }
-
-}
\ No newline at end of file
diff --git a/src/main/java/net/e175/klaus/solarpositioning/SPA.java b/src/main/java/net/e175/klaus/solarpositioning/SPA.java
index 2a7a07b..e03c84f 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/SPA.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/SPA.java
@@ -1,25 +1,24 @@
 package net.e175.klaus.solarpositioning;
 
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.TimeZone;
+import java.time.ZonedDateTime;
+import java.time.temporal.ChronoUnit;
 
 import static java.lang.Math.*;
 
 /**
  * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
  * certain point of the Earth's surface.
- *
+ * <p>
  * This follows the SPA algorithm described in Reda, I.; Andreas, A. (2003): Solar Position Algorithm for Solar
  * Radiation Applications. NREL Report No. TP-560-34302, Revised January 2008.
- *
+ * <p>
  * This is <i>not</i> a port of the C code, but a re-implementation based on the published procedure.
  *
  * @author Klaus Brunner
  */
 public final class SPA {
 
-    private static final double HPRIME_0 = -0.8333;
+    private static final double HPRIME_0 = -0.83337;
     private static final double SIN_HPRIME_0 = sin(toRadians(HPRIME_0));
     private static final int MS_PER_DAY = 24 * 60 * 60 * 1000;
 
@@ -29,7 +28,7 @@ public final class SPA {
     /**
      * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
      * certain point of the Earth's surface.
-     *
+     * <p>
      * This follows the SPA algorithm described in Reda, I.; Andreas, A. (2003): Solar Position Algorithm for Solar
      * Radiation Applications. NREL Report No. TP-560-34302, Revised January 2008. The algorithm is supposed to work for
      * the years -2000 to 6000, with uncertainties of +/-0.0003 degrees.
@@ -48,7 +47,7 @@ public final class SPA {
      * @return Topocentric solar position (azimuth measured eastward from north)
      * @see AzimuthZenithAngle
      */
-    public static AzimuthZenithAngle calculateSolarPosition(final GregorianCalendar date, final double latitude,
+    public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
                                                             final double longitude, final double elevation, final double deltaT, final double pressure,
                                                             final double temperature) {
 
@@ -76,7 +75,7 @@ public final class SPA {
         final double beta = toRadians(betaDegrees);
 
         // calculate nutation
-        final double xTerms[] = calculateNutationTerms(jce);
+        final double[] xTerms = calculateNutationTerms(jce);
         final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms);
         final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms);
         final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI);
@@ -129,11 +128,11 @@ public final class SPA {
     /**
      * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
      * certain point of the Earth's surface.
-     *
+     * <p>
      * This follows the SPA algorithm described in Reda, I.; Andreas, A. (2003): Solar Position Algorithm for Solar
      * Radiation Applications. NREL Report No. TP-560-34302, Revised January 2008. The algorithm is supposed to work for
      * the years -2000 to 6000, with uncertainties of +/-0.0003 degrees.
-     *
+     * <p>
      * This method does not perform refraction correction.
      *
      * @param date      Observer's local date and time.
@@ -147,7 +146,7 @@ public final class SPA {
      * @return Topocentric solar position (azimuth measured eastward from north)
      * @see AzimuthZenithAngle
      */
-    public static AzimuthZenithAngle calculateSolarPosition(final GregorianCalendar date, final double latitude,
+    public static AzimuthZenithAngle calculateSolarPosition(final ZonedDateTime date, final double latitude,
                                                             final double longitude, final double elevation, final double deltaT) {
         return calculateSolarPosition(date, latitude, longitude, elevation, deltaT, Double.MIN_VALUE, Double.MIN_VALUE);
     }
@@ -174,22 +173,19 @@ public final class SPA {
      *                  in seconds. See
      *                  <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http://asa.usno.navy.mil/SecK/DeltaT.html</a>.
      *                  For the year 2015, a reasonably accurate default would be 68.
-     * @return An array of 3 GregorianCalendar values corresponding to the time of sunrise, sun transit, and sunset,
-     * respectively. Note that the values for sunrise and sunset may be null: in this case, the sun stays above or
-     * below the horizon all day.
      */
-    public static GregorianCalendar[] calculateSunriseTransitSet(final GregorianCalendar day,
-                                                                 final double latitude,
-                                                                 final double longitude,
-                                                                 final double deltaT) {
-        final GregorianCalendar dayStart = startOfDayUT(day);
+    public static SunriseTransitSet calculateSunriseTransitSet(final ZonedDateTime day,
+                                                               final double latitude,
+                                                               final double longitude,
+                                                               final double deltaT) {
+        final ZonedDateTime dayStart = startOfDayUT(day);
         final JulianDate jd = new JulianDate(dayStart, 0);
 
         final double phi = toRadians(latitude);
 
         // A.2.1. Calculate the apparent sidereal time at Greenwich at 0 UT, nu (in degrees)
         final double jce = jd.getJulianEphemerisCentury();
-        final double xTerms[] = calculateNutationTerms(jce);
+        final double[] xTerms = calculateNutationTerms(jce);
         final double[] deltaPsiI = calculateDeltaPsiI(jce, xTerms);
         final double[] deltaEpsilonI = calculateDeltaEpsilonI(jce, xTerms);
         final double deltaPsi = calculateDeltaPsiEpsilon(deltaPsiI);
@@ -215,7 +211,8 @@ public final class SPA {
         final double acosArg = (SIN_HPRIME_0 - sin(phi) * sin(toRadians(alphaDeltas[1].delta)))
                 / (cos(phi) * cos(toRadians(alphaDeltas[1].delta)));
 
-        final boolean noSunriseOrSet = (acosArg < -1.0) || (acosArg > 1.0);
+        final SunriseTransitSet.Type type = acosArg < -1.0 ? SunriseTransitSet.Type.ALL_DAY :
+                (acosArg > 1.0 ? SunriseTransitSet.Type.ALL_NIGHT : SunriseTransitSet.Type.NORMAL);
 
         final double h0 = acos(acosArg);
 
@@ -294,28 +291,16 @@ public final class SPA {
                 (h[2] - HPRIME_0) /
                         (360.0 * cos(toRadians(alphaDeltaPrimes[2].delta)) * cos(phi) * sin(toRadians(hPrime[2])));
 
-        return new GregorianCalendar[]{
-                noSunriseOrSet ? null : addFractionOfDay(day, r),
+
+        return new SunriseTransitSet(type,
+                type == SunriseTransitSet.Type.NORMAL ? addFractionOfDay(day, r) : null,
                 addFractionOfDay(day, t),
-                noSunriseOrSet ? null : addFractionOfDay(day, s)
-        };
+                type == SunriseTransitSet.Type.NORMAL ? addFractionOfDay(day, s) : null);
     }
 
-    private static GregorianCalendar addFractionOfDay(GregorianCalendar day, final double fraction) {
-        GregorianCalendar dayStart = (GregorianCalendar) day.clone();
-        dayStart.set(Calendar.MINUTE, 0);
-        dayStart.set(Calendar.SECOND, 0);
-        dayStart.set(Calendar.MILLISECOND, 0);
-        dayStart.set(Calendar.HOUR_OF_DAY, 0);
-        final int offset = day.getTimeZone().getOffset(dayStart.getTimeInMillis());
-
-        dayStart.set(Calendar.HOUR_OF_DAY, 0);
-        final double offsetFraction = (double) offset / MS_PER_DAY;
-        final int addMs = (int) (MS_PER_DAY * limitTo(fraction + offsetFraction, 1.0));
-        assert addMs >= 0 && addMs <= MS_PER_DAY;
-        dayStart.setTimeInMillis(dayStart.getTimeInMillis() + addMs);
-
-        return dayStart;
+    private static ZonedDateTime addFractionOfDay(ZonedDateTime day, double fraction) {
+        final int millisPlus = (int) (MS_PER_DAY * fraction);
+        return day.truncatedTo(ChronoUnit.DAYS).plus(millisPlus, ChronoUnit.MILLIS);
     }
 
     /**
@@ -377,17 +362,8 @@ public final class SPA {
         return new AlphaDelta(alphaDegrees, deltaDegrees);
     }
 
-    private static GregorianCalendar startOfDayUT(GregorianCalendar day) {
-        final GregorianCalendar utcCalendar = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
-
-        utcCalendar.set(day.get(Calendar.YEAR), day.get(Calendar.MONTH), day.get(Calendar.DAY_OF_MONTH));
-        utcCalendar.set(Calendar.ERA, day.get(Calendar.ERA));
-        utcCalendar.set(Calendar.HOUR_OF_DAY, 0);
-        utcCalendar.set(Calendar.MINUTE, 0);
-        utcCalendar.set(Calendar.SECOND, 0);
-        utcCalendar.set(Calendar.MILLISECOND, 0);
-
-        return utcCalendar;
+    private static ZonedDateTime startOfDayUT(ZonedDateTime day) {
+        return day.truncatedTo(ChronoUnit.DAYS);
     }
 
     private static AzimuthZenithAngle calculateTopocentricSolarPosition(final double p, final double t, final double phi,
diff --git a/src/main/java/net/e175/klaus/solarpositioning/SunriseTransitSet.java b/src/main/java/net/e175/klaus/solarpositioning/SunriseTransitSet.java
new file mode 100644
index 0000000..d036877
--- /dev/null
+++ b/src/main/java/net/e175/klaus/solarpositioning/SunriseTransitSet.java
@@ -0,0 +1,56 @@
+package net.e175.klaus.solarpositioning;
+
+import java.time.ZonedDateTime;
+
+/**
+ * A simple wrapper class for keeping sunrise, sunset, and transit results.
+ */
+public final class SunriseTransitSet {
+    public enum Type {
+        /** This is a normal day, with a sunrise and a sunset. */
+        NORMAL,
+        /** The sun stays above the horizon all day. There is neither sunrise nor sunset. */
+        ALL_DAY,
+        /** The sun stays below the horizon all day. There is neither sunrise nor sunset. */
+        ALL_NIGHT}
+
+    private final Type type;
+    private final ZonedDateTime sunrise;
+    private final ZonedDateTime transit;
+    private final ZonedDateTime sunset;
+
+    public SunriseTransitSet(Type type, ZonedDateTime sunrise, ZonedDateTime transit, ZonedDateTime sunset) {
+        this.type = type;
+        this.sunrise = sunrise;
+        this.transit = transit;
+        this.sunset = sunset;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    /** Get time of sunrise. This may be null depending on the day's type. */
+    public ZonedDateTime getSunrise() {
+        return sunrise;
+    }
+
+    /** The sun's (upper) transit, or solar noon. This is never null, even for ALL_NIGHT days. */
+    public ZonedDateTime getTransit() {
+        return transit;
+    }
+
+    /** Get time of sunset. This may be null depending on the day's type. */
+    public ZonedDateTime getSunset() {
+        return sunset;
+    }
+    @Override
+    public String toString() {
+        return "SunriseTransitSet{" +
+                "type=" + type +
+                ", sunrise=" + sunrise +
+                ", transit=" + transit +
+                ", sunset=" + sunset +
+                '}';
+    }
+}
diff --git a/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java b/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java
index 454ab3e..aab6867 100644
--- a/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java
+++ b/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java
@@ -2,10 +2,8 @@ package net.e175.klaus.solarpositioning;
 
 import org.junit.Test;
 
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.SimpleTimeZone;
-import java.util.TimeZone;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
 
 import static java.lang.Math.PI;
 import static java.lang.Math.toDegrees;
@@ -17,8 +15,7 @@ public class Grena3Test {
 
     @Test
     public void cSampleComparison() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(+1 * 60 * 60 * 1000, "CET"));
-        time.set(2012, Calendar.JANUARY, 1, 12, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2012, 1, 1, 12, 0, 0, 0, ZoneOffset.ofHours(1));
 
         AzimuthZenithAngle result = Grena3.calculateSolarPosition(time,
                 toDegrees(0.73117), toDegrees(0.21787), 65, 1000, 20);
@@ -29,8 +26,7 @@ public class Grena3Test {
 
     @Test
     public void spaComparison() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
-        time.set(2015, Calendar.JUNE, 28, 17, 45, 12);
+        ZonedDateTime time = ZonedDateTime.of(2015, 6, 28, 17, 45, 12, 0, ZoneOffset.UTC);
 
         AzimuthZenithAngle result = Grena3.calculateSolarPosition(time,
                 52.509663, 13.376481, 68, 1000, 20);
@@ -41,8 +37,7 @@ public class Grena3Test {
 
     @Test
     public void testNearEquator1() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-4 * 60 * 60 * 1000, "AMT"));
-        time.set(2015, Calendar.JUNE, 12, 9, 34, 11);
+        ZonedDateTime time = ZonedDateTime.of(2015, 6, 12, 9, 34, 11, 0, ZoneOffset.ofHours(-4));
 
         AzimuthZenithAngle result = Grena3.calculateSolarPosition(time, -3.107, -60.025, 69, 1000, 20);
 
@@ -52,8 +47,7 @@ public class Grena3Test {
 
     @Test
     public void testSouthernSolstice() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-        time.set(2012, Calendar.DECEMBER, 22, 12, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2012, 12, 22, 12, 0, 0, 0, ZoneOffset.UTC);
 
         AzimuthZenithAngle result = Grena3.calculateSolarPosition(time, -41, 0, 0, 1000, 20);
 
@@ -68,8 +62,7 @@ public class Grena3Test {
 
     @Test
     public void testSillyRefractionParameters() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-7 * 60 * 60 * 1000, "LST"));
-        time.set(2003, Calendar.OCTOBER, 17, 12, 30, 30); // 17 October 2003, 12:30:30 LST-07:00
+        ZonedDateTime time = ZonedDateTime.of(2003, 10, 17, 12, 30, 30, 0, ZoneOffset.ofHours(-7));
 
         AzimuthZenithAngle result = Grena3.calculateSolarPosition(time, 39.742476, -105.1786, 67, -2, 1000);
         assertEquals(194.34024, result.getAzimuth(), TOLERANCE);
diff --git a/src/test/java/net/e175/klaus/solarpositioning/JulianDateTest.java b/src/test/java/net/e175/klaus/solarpositioning/JulianDateTest.java
index e23121d..a9fff3b 100644
--- a/src/test/java/net/e175/klaus/solarpositioning/JulianDateTest.java
+++ b/src/test/java/net/e175/klaus/solarpositioning/JulianDateTest.java
@@ -2,10 +2,9 @@ package net.e175.klaus.solarpositioning;
 
 import org.junit.Test;
 
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.SimpleTimeZone;
-import java.util.TimeZone;
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -16,19 +15,16 @@ public class JulianDateTest {
 
     @Test
     public void testConstructor() {
-        GregorianCalendar utcTime = createCalendar();
-        JulianDate julDate = new JulianDate(utcTime);
+        JulianDate julDate = new JulianDate(ZonedDateTime.now());
         assertNotNull(julDate);
     }
 
-    private GregorianCalendar createCalendar() {
-        return new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-    }
-
     @Test
     public void testWithTimeZone() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-7 * 60 * 60 * 1000, "LST"));
-        time.set(2003, Calendar.OCTOBER, 17, 12, 30, 30); // 17 October 2003, 12:30:30-07:00
+        // 17 October 2003, 12:30:30-07:00
+        ZoneId zone = ZoneOffset.ofHours(-7);
+        ZonedDateTime time = ZonedDateTime.of(2003, 10, 17, 12, 30, 30, 0, zone);
+
         JulianDate julDate = new JulianDate(time);
 
         assertEquals(2452930.312847222, julDate.getJulianDate(), TOLERANCE);
@@ -36,8 +32,8 @@ public class JulianDateTest {
 
     @Test
     public void testY2K() {
-        GregorianCalendar utcTime = createCalendar();
-        utcTime.set(2000, Calendar.JANUARY, 1, 12, 0, 0);
+        ZonedDateTime utcTime = ZonedDateTime.of(2000, 1, 1, 12, 0, 0, 0, ZoneOffset.UTC);
+
         JulianDate julDate = new JulianDate(utcTime);
 
         assertEquals(2451545.0, julDate.getJulianDate(), TOLERANCE);
@@ -45,8 +41,8 @@ public class JulianDateTest {
 
     @Test
     public void testPre1000() {
-        GregorianCalendar utcTime = createCalendar();
-        utcTime.set(837, Calendar.APRIL, 10, 7, 12, 0);
+        ZonedDateTime utcTime = ZonedDateTime.of(837, 4, 10, 7, 12, 0, 0, ZoneOffset.UTC);
+
         JulianDate julDate = new JulianDate(utcTime);
 
         assertEquals(2026871.8, julDate.getJulianDate(), TOLERANCE);
@@ -54,9 +50,8 @@ public class JulianDateTest {
 
     @Test
     public void testPre0() {
-        GregorianCalendar utcTime = createCalendar();
-        utcTime.set(123, Calendar.DECEMBER, 31, 0, 0, 0);
-        utcTime.set(Calendar.ERA, GregorianCalendar.BC);
+        ZonedDateTime utcTime = ZonedDateTime.of(-123, 12, 31, 0, 0, 0, 0, ZoneOffset.UTC);
+
         JulianDate julDate = new JulianDate(utcTime);
 
         assertEquals(1676496.5, julDate.getJulianDate(), TOLERANCE);
@@ -64,9 +59,8 @@ public class JulianDateTest {
 
     @Test
     public void testPre02() {
-        GregorianCalendar utcTime = createCalendar();
-        utcTime.set(122, Calendar.JANUARY, 1, 0, 0, 0);
-        utcTime.set(Calendar.ERA, GregorianCalendar.BC);
+        ZonedDateTime utcTime = ZonedDateTime.of(-122, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);
+
         JulianDate julDate = new JulianDate(utcTime);
 
         assertEquals(1676497.5, julDate.getJulianDate(), TOLERANCE);
@@ -74,9 +68,8 @@ public class JulianDateTest {
 
     @Test
     public void testJulian0() {
-        GregorianCalendar utcTime = createCalendar();
-        utcTime.set(4712, Calendar.JANUARY, 1, 12, 0, 0);
-        utcTime.set(Calendar.ERA, GregorianCalendar.BC);
+        ZonedDateTime utcTime = ZonedDateTime.of(-4712, 1, 1, 12, 0, 0, 0, ZoneOffset.UTC);
+
         JulianDate julDate = new JulianDate(utcTime);
 
         assertEquals(0.0, julDate.getJulianDate(), TOLERANCE);
diff --git a/src/test/java/net/e175/klaus/solarpositioning/PSATest.java b/src/test/java/net/e175/klaus/solarpositioning/PSATest.java
deleted file mode 100644
index 6ce0022..0000000
--- a/src/test/java/net/e175/klaus/solarpositioning/PSATest.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package net.e175.klaus.solarpositioning;
-
-import org.junit.Test;
-
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.SimpleTimeZone;
-
-import static org.junit.Assert.assertEquals;
-
-public class PSATest {
-    private static final double TOLERANCE = 0.1;
-
-    @Test
-    public void testSpaExample() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-7 * 60 * 60 * 1000, "LST"));
-        time.set(2003, Calendar.OCTOBER, 17, 12, 30, 30); // 17 October 2003, 12:30:30 LST-07:00
-
-        AzimuthZenithAngle result = PSA.calculateSolarPosition(time, 39.742476, -105.1786);
-
-        assertEquals(194.34024, result.getAzimuth(), TOLERANCE); // reference values from SPA
-        assertEquals(50.11162, result.getZenithAngle(), TOLERANCE);
-    }
-}
diff --git a/src/test/java/net/e175/klaus/solarpositioning/SPAPerformanceGuesstimate.java b/src/test/java/net/e175/klaus/solarpositioning/SPAPerformanceGuesstimate.java
deleted file mode 100644
index e785022..0000000
--- a/src/test/java/net/e175/klaus/solarpositioning/SPAPerformanceGuesstimate.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package net.e175.klaus.solarpositioning;
-
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-
-/**
- * As the name says, this is merely a guesstimate to get a rough idea of SPA's performance. Like all
- * microbenchmarks on the JVM, its results will be distorted by garbage collection, JIT compilation,
- * and other JVM optimisations.
- */
-public class SPAPerformanceGuesstimate {
-
-    public static void main(final String[] args) {
-        final long numIterations = 1000000;
-        final GregorianCalendar cal = new GregorianCalendar();
-
-        System.out.printf("calculating %d positions...%n", numIterations);
-
-        final long startTimeNanos = System.nanoTime();
-        for (int i = 0; i < numIterations; i++) {
-            AzimuthZenithAngle result = SPA.calculateSolarPosition(cal, 39.742476, -105.1786, 1830.14, 67, 820, 11);
-            cal.add(Calendar.SECOND, (int) result.getZenithAngle());
-        }
-        final double elapsedTimeSeconds = (System.nanoTime() - startTimeNanos) / 1e9;
-
-        System.out.printf("elapsed time: %.3f s%n", elapsedTimeSeconds);
-        System.out.printf("throughput: %.1f positions / s%n", numIterations / elapsedTimeSeconds);
-        System.out.printf("mean time per position: %.3f µs", elapsedTimeSeconds * 1e6 / numIterations);
-    }
-}
diff --git a/src/test/java/net/e175/klaus/solarpositioning/SPATest.java b/src/test/java/net/e175/klaus/solarpositioning/SPATest.java
index 774c49f..52fb05d 100644
--- a/src/test/java/net/e175/klaus/solarpositioning/SPATest.java
+++ b/src/test/java/net/e175/klaus/solarpositioning/SPATest.java
@@ -2,26 +2,22 @@ package net.e175.klaus.solarpositioning;
 
 import org.junit.Test;
 
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.SimpleTimeZone;
-import java.util.TimeZone;
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.*;
 
 public class SPATest {
 
     private static final double TOLERANCE = 0.0001;
-    private static final String DATE_FORMAT = "yyyy-MM-dd'T'HH:mm:ssZ";
+
+    private static final DateTimeFormatter DF = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssxxx");
 
     @Test
     public void testSpaExample() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-7 * 60 * 60 * 1000, "LST"));
-        time.set(2003, Calendar.OCTOBER, 17, 12, 30, 30); // 17 October 2003, 12:30:30 LST-07:00
+        ZonedDateTime time = ZonedDateTime.of(2003, 10, 17, 12, 30, 30, 0, ZoneOffset.ofHours(-7));
 
         AzimuthZenithAngle result = SPA.calculateSolarPosition(time, 39.742476, -105.1786, 1830.14, 67, 820, 11);
 
@@ -31,8 +27,7 @@ public class SPATest {
 
     @Test
     public void testNearEquator1() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-4 * 60 * 60 * 1000, "AMT"));
-        time.set(2015, Calendar.JUNE, 12, 9, 34, 11);
+        ZonedDateTime time = ZonedDateTime.of(2015, 6, 12, 9, 34, 11, 0, ZoneOffset.ofHours(-4));
 
         AzimuthZenithAngle result = SPA.calculateSolarPosition(time, -3.107, -60.025, 100, 69, 1000, 20);
 
@@ -42,8 +37,7 @@ public class SPATest {
 
     @Test
     public void testSouthernSolstice() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-        time.set(2012, Calendar.DECEMBER, 22, 12, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2012, 12, 22, 12, 0, 0, 0, ZoneOffset.UTC);
 
         AzimuthZenithAngle result = SPA.calculateSolarPosition(time, -41, 0, 100, 0, 1000, 20);
 
@@ -58,8 +52,7 @@ public class SPATest {
 
     @Test
     public void testSillyRefractionParameters() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-7 * 60 * 60 * 1000, "LST"));
-        time.set(2003, Calendar.OCTOBER, 17, 12, 30, 30); // 17 October 2003, 12:30:30 LST-07:00
+        ZonedDateTime time = ZonedDateTime.of(2003, 10, 17, 12, 30, 30, 0, ZoneOffset.ofHours(-7));
 
         AzimuthZenithAngle result = SPA.calculateSolarPosition(time, 39.742476, -105.1786, 1830.14, 67, -2, 1000);
         assertEquals(194.34024, result.getAzimuth(), TOLERANCE);
@@ -72,132 +65,140 @@ public class SPATest {
 
     @Test
     public void testSpaExampleSunriseTransitSet() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(-7 * 60 * 60 * 1000, "LST"));
-        time.set(2003, Calendar.OCTOBER, 17, 12, 30, 30); // 17 October 2003, 12:30:30 LST-07:00
-
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, 39.742476, -105.1786, 67);
+        ZonedDateTime time = ZonedDateTime.of(2003, 10, 17, 12, 30, 30, 0, ZoneOffset.ofHours(-7));
 
-        DateFormat df = getDateFormat(time);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, 39.742476, -105.1786, 67);
 
-        assertEquals("2003-10-17T06:12:43-0700", df.format(res[0].getTime()));
-        assertEquals("2003-10-17T11:46:04-0700", df.format(res[1].getTime()));
-        assertEquals("2003-10-17T17:20:19-0700", df.format(res[2].getTime()));
-    }
-
-    private DateFormat getDateFormat(GregorianCalendar time) {
-        DateFormat df = new SimpleDateFormat(DATE_FORMAT);
-        df.setTimeZone(time.getTimeZone());
-        return df;
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2003-10-17T06:12:43-07:00", DF.format(res.getSunrise()));
+        assertEquals("2003-10-17T11:46:04-07:00", DF.format(res.getTransit()));
+        assertEquals("2003-10-17T17:18:51-07:00", DF.format(res.getSunset())); // SPA paper: 17:20:19, NOAA calc: 17:19
     }
 
     @Test
     public void testOtherSpaExampleSunriseTransitSet() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
-        time.set(2004, Calendar.DECEMBER, 4, 12, 30, 30);
-
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, -35.0, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2004, 12, 4, 12, 30, 30, 0, ZoneOffset.UTC);
 
-        DateFormat df = getDateFormat(time);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, -35.0, 0, 0);
 
-        assertEquals("2004-12-04T04:38:56+0000", df.format(res[0].getTime()));
-        assertEquals("2004-12-04T19:02:02+0000", df.format(res[2].getTime())); // SPA paper has 19:02:02.5
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2004-12-04T04:38:56+00:00", DF.format(res.getSunrise()));
+        assertEquals("2004-12-04T19:02:02+00:00", DF.format(res.getSunset())); // SPA paper has 19:02:02.5
     }
 
     @Test
     public void testNoSunset() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(2 * 60 * 60 * 1000, "CEST"));
-        time.set(2015, Calendar.JUNE, 17, 12, 30, 30);
+        ZonedDateTime time = ZonedDateTime.of(2015, 6, 17, 12, 30, 30, 0, ZoneOffset.ofHours(2));
 
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, 70.978056, 25.974722, 68);
+        // location is Honningsvåg, Norway (near North Cape)
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, 70.978056, 25.974722, 0);
 
-        DateFormat df = getDateFormat(time);
-
-        assertNull(res[0]);
-        assertEquals("2015-06-17T12:16:55+0200", df.format(res[1].getTime())); // NOAA calc says 12:16:50
-        assertNull(res[2]);
+        assertEquals(SunriseTransitSet.Type.ALL_DAY, res.getType());
+        assertNull(res.getSunrise());
+        assertEquals("2015-06-17T12:16:55+02:00", DF.format(res.getTransit())); // NOAA calc says 12:16:50
+        assertNull(res.getSunset());
     }
 
     @Test
     public void testNZSunriseTransitSet() {
-        GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(12 * 60 * 60 * 1000, "NZST"));
-        time.set(2015, Calendar.JUNE, 17, 12, 30, 30);
-
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, -36.8406, 174.74, 0);
-
-        DateFormat df = getDateFormat(time);
-
-        assertEquals("2015-06-17T07:32:46+1200", df.format(res[0].getTime()));
-        assertEquals("2015-06-17T17:11:03+1200", df.format(res[2].getTime()));
-    }
+        ZonedDateTime time = ZonedDateTime.of(2015, 6, 17, 12, 30, 30, 0, ZoneOffset.ofHours(12));
 
-    @Test
-    public void testResoluteSunriseTransitSet() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
-        time.set(2016, Calendar.NOVEMBER, 1, 0, 0, 0);
-
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, 74.6973, -94.8297, 0);
-
-        DateFormat df = getDateFormat(time);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, -36.8406, 174.74, 0);
 
-        assertNotNull(res[0]);
-        assertEquals("2016-11-01T16:20:30+0000", df.format(res[0].getTime()));
-        assertEquals("2016-11-01T19:43:37+0000", df.format(res[2].getTime()));
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2015-06-17T07:32:26+12:00", DF.format(res.getSunrise())); // NOAA: 7:32 (no seconds given)
+        assertEquals("2015-06-17T12:21:46+12:00", DF.format(res.getTransit())); // NOAA: 12:21:41
+        assertEquals("2015-06-17T17:11:03+12:00", DF.format(res.getSunset())); // NOAA: 17:11 (no seconds given)
     }
 
     @Test
     public void testDSToffDayBerlin() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("Europe/Berlin"));
-        time.set(2015, Calendar.OCTOBER, 25, 12, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2015, 10, 25, 12, 0, 0, 0,
+                ZoneId.of("Europe/Berlin"));
 
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, 52.33, 13.3, 68);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, 52.33, 13.3, 68);
 
-        DateFormat df = getDateFormat(time);
-
-        assertEquals("2015-10-25T06:49:02+0100", df.format(res[0].getTime())); // NOAA: same (no seconds given)
-        assertEquals("2015-10-25T11:50:55+0100", df.format(res[1].getTime())); // NOAA: 11:50:53
-        assertEquals("2015-10-25T16:51:59+0100", df.format(res[2].getTime())); // NOAA: 16:52 (no seconds given)
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2015-10-25T06:49:02+01:00", DF.format(res.getSunrise())); // NOAA: same (no seconds given)
+        assertEquals("2015-10-25T11:50:55+01:00", DF.format(res.getTransit())); // NOAA: 11:50:53
+        assertEquals("2015-10-25T16:51:59+01:00", DF.format(res.getSunset())); // NOAA: 16:52 (no seconds given)
     }
 
     @Test
     public void testDSTonDayBerlin() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("Europe/Berlin"));
-        time.set(2016, Calendar.MARCH, 27, 12, 0, 0);
-
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, 52.33, 13.3, 68);
+        ZonedDateTime time = ZonedDateTime.of(2016, 3, 27, 12, 0, 0, 0,
+                ZoneId.of("Europe/Berlin"));
 
-        DateFormat df = getDateFormat(time);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, 52.33, 13.3, 68);
 
-        assertEquals("2016-03-27T06:52:19+0200", df.format(res[0].getTime())); // NOAA: 06:52 (no seconds given)
-        assertEquals("2016-03-27T13:12:02+0200", df.format(res[1].getTime())); // NOAA: 13:12:01
-        assertEquals("2016-03-27T19:32:49+0200", df.format(res[2].getTime())); // NOAA: 19:33 (no seconds given)
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2016-03-27T06:52:19+02:00", DF.format(res.getSunrise())); // NOAA: 06:52 (no seconds given)
+        assertEquals("2016-03-27T13:12:02+02:00", DF.format(res.getTransit())); // NOAA: 13:12:01
+        assertEquals("2016-03-27T19:32:49+02:00", DF.format(res.getSunset())); // NOAA: 19:33 (no seconds given)
     }
 
     @Test
     public void testDSToffDayAuckland() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("Pacific/Auckland"));
-        time.set(2016, Calendar.APRIL, 3, 12, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2016, 4, 3, 12, 0, 0, 0,
+                ZoneId.of("Pacific/Auckland"));
 
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, -36.84, 174.74, 68);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, -36.84, 174.74, 68);
 
-        DateFormat df = getDateFormat(time);
-
-        assertEquals("2016-04-03T06:37:01+1200", df.format(res[0].getTime())); // NOAA: 06:36 (no seconds given)
-        assertEquals("2016-04-03T12:24:19+1200", df.format(res[1].getTime())); // NOAA: same
-        assertEquals("2016-04-03T18:11:55+1200", df.format(res[2].getTime())); // NOAA: 18:12 (no seconds given)
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2016-04-03T06:36:09+12:00", DF.format(res.getSunrise())); // NOAA: 06:36 (no seconds given)
+        assertEquals("2016-04-03T12:24:19+12:00", DF.format(res.getTransit())); // NOAA: same
+        assertEquals("2016-04-03T18:11:55+12:00", DF.format(res.getSunset())); // NOAA: 18:12 (no seconds given)
     }
 
     @Test
     public void testDSTonDayAuckland() {
-        GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("Pacific/Auckland"));
-        time.set(2015, Calendar.SEPTEMBER, 27, 12, 0, 0);
+        ZonedDateTime time = ZonedDateTime.of(2015, 9, 27, 12, 0, 0, 0,
+                ZoneId.of("Pacific/Auckland"));
 
-        GregorianCalendar[] res = SPA.calculateSunriseTransitSet(time, -36.84, 174.74, 68);
+        SunriseTransitSet res = SPA.calculateSunriseTransitSet(time, -36.84, 174.74, 68);
 
-        DateFormat df = getDateFormat(time);
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2015-09-27T07:04:14+13:00", DF.format(res.getSunrise())); // NOAA: 07:04 (no seconds given)
+        assertEquals("2015-09-27T13:12:17+13:00", DF.format(res.getTransit())); // NOAA: 13:12:19
+        assertEquals("2015-09-27T19:20:56+13:00", DF.format(res.getSunset())); // NOAA: 19:21 (no seconds given)
+    }
 
-        assertEquals("2015-09-27T07:02:43+1300", df.format(res[0].getTime())); // NOAA: 07:04 (no seconds given)
-        assertEquals("2015-09-27T13:12:17+1300", df.format(res[1].getTime())); // NOAA: 13:12:19
-        assertEquals("2015-09-27T19:20:56+1300", df.format(res[2].getTime())); // NOAA: 19:21 (no seconds given)
+    private SunriseTransitSet lybRun(int year, int month, int day) {
+        ZonedDateTime time = ZonedDateTime.of(year, month, day, 0, 0, 0, 0,
+                ZoneOffset.UTC);
+        return SPA.calculateSunriseTransitSet(time, 78.2222, 15.6316, 0);
+    }
+
+    @Test
+    public void testLongyearbyen() {
+        SunriseTransitSet res;
+
+        res = lybRun(2015, 1, 20);
+        // USNO for comparison: https://aa.usno.navy.mil/calculated/rstt/oneday?date=2015-01-20&lat=78.2222&lon=15.6316&label=Longyearbyen&tz=0.00&tz_sign=-1&tz_label=false&dst=false&submit=Get+Data
+        assertEquals(SunriseTransitSet.Type.ALL_NIGHT, res.getType());
+        assertNull(res.getSunrise());
+        assertNull(res.getSunset());
+
+        res = lybRun(2015, 2, 20);
+        // https://aa.usno.navy.mil/calculated/rstt/oneday?date=2015-02-20&lat=78.2222&lon=15.6316&label=Longyearbyen&tz=0.00&tz_sign=-1&tz_label=false&dst=false&submit=Get+Data
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2015-02-20T09:07:12+00:00", DF.format(res.getSunrise())); // USNO: 09:07, timeanddate.com: no sunrise
+        assertEquals("2015-02-20T11:11:12+00:00", DF.format(res.getTransit())); // USNO: 11:11
+        assertEquals("2015-02-20T13:17:33+00:00", DF.format(res.getSunset())); // USNO: 13:17, timeanddate.com: no sunset
+
+        res = lybRun(2015, 3, 20);
+        // https://aa.usno.navy.mil/calculated/rstt/oneday?date=2015-03-20&lat=78.2222&lon=15.6316&label=Longyearbyen&tz=0.00&tz_sign=-1&tz_label=false&dst=false&submit=Get+Data
+        assertEquals(SunriseTransitSet.Type.NORMAL, res.getType());
+        assertEquals("2015-03-20T04:54:24+00:00", DF.format(res.getSunrise())); // USNO: 04:54
+        assertEquals("2015-03-20T11:05:01+00:00", DF.format(res.getTransit())); // USNO: 11:05
+        assertEquals("2015-03-20T17:19:32+00:00", DF.format(res.getSunset())); // USNO: 17:20
+
+        res = lybRun(2015, 6, 20);
+        // https://aa.usno.navy.mil/calculated/rstt/oneday?date=2015-06-20&lat=78.2222&lon=15.6316&label=Longyearbyen&tz=0.00&tz_sign=-1&tz_label=false&dst=false&submit=Get+Data
+        assertEquals(SunriseTransitSet.Type.ALL_DAY, res.getType());
+        assertNull(res.getSunrise());
+        assertEquals("2015-06-20T10:58:57+00:00", DF.format(res.getTransit())); // USNO: 10:59
+        assertNull(res.getSunset());
     }
 
 }
