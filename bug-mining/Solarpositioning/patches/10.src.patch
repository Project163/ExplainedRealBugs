diff --git a/README.md b/README.md
index 5b79235..8d30aee 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # solarpositioning
 
-This is a Java library for finding topocentric solar coordinates, i.e. the sun’s position on the sky at a given date, latitude, and longitude (and other parameters). Calculations are based on well-known published algorithms: [SPA](http://dx.doi.org/10.1016/j.solener.2003.12.003) by Reda and Andreas and, alternatively, <a href="http://dx.doi.org/10.1016/S0038-092X(00)00156-0">PSA</a> by Blanco-Muriel et al.
+This is a Java library for finding topocentric solar coordinates, i.e. the sun’s position on the sky at a given date, latitude, and longitude (and other parameters). Calculations are based on well-known published algorithms: [SPA](http://dx.doi.org/10.1016/j.solener.2003.12.003) by Reda and Andreas and, alternatively, [Grena/ENEA](http://dx.doi.org/10.1016/j.solener.2012.01.024) by Grena or [PSA](http://dx.doi.org/10.1016/S0038-092X(00)00156-0") by Blanco-Muriel et al.
 
 ## Usage
 
@@ -42,11 +42,11 @@ public class App {
 
 ### Which algorithm should I use?
 
-When in doubt, use SPA. It's widely considered the reference algorithm for solar positioning, being very accurate and usable in a very large time window. Its only downside is that it's relatively slow.
+For many applications, Grena3 should work just fine. It's fast and pretty accurate for a time window from 2010 to 2110 CE.
 
-If speed is critical (e.g. you need to calculate lots of positions), consider using PSA. Note however that it's highly optimised for its specified time window (1999-2015), and will be drastically less accurate outside of it.
+If you're looking for maximum accuracy or need to calculate for historic dates, consider SPA. It's widely considered the reference algorithm for solar positioning, being very accurate and usable in a very large time window. Its only downside is that it's relatively slow.
 
-A fast, yet still accurate alternative would be one of the [Grena/ENEA](http://dx.doi.org/10.1016/j.solener.2012.01.024) algorithms, but that's not implemented yet.
+PSA is another fast and simple algorithm, but should not be used for new applications due to its limited time window. It is currently kept for backwards compatibility.
 
 ### Is the code thread-safe?
 
@@ -64,7 +64,7 @@ Note that the times of sunrise and sunset may be NULL if the sun never sets or r
 
 ### What's with this "delta T" thing?
 
-See [Wikipedia](https://en.wikipedia.org/wiki/ΔT) for an explanation. For many simple applications, this value could be negligible as it's just about a minute as of this writing. However, if you're looking for maximum accuracy, you should either use a current observed value (published e.g. by the US Naval Observatory) or at least a solid estimate.
+See [Wikipedia](https://en.wikipedia.org/wiki/ΔT) for an explanation. For many simple applications, this value could be negligible as it's just about a minute as of this writing. However, if you're looking for maximum accuracy, you should either use a current observed value (available from e.g. the US Naval Observatory) or at least a solid estimate.
 
 The DeltaT class provides an estimator based on polynomials fitting a number of observed (or extrapolated) historical values, published by [Espenak and Meeus](http://eclipse.gsfc.nasa.gov/SEcat5/deltatpoly.html). Here's a plot of its output compared with some published ΔT data:
 
diff --git a/src/main/java/net/e175/klaus/solarpositioning/Grena3.java b/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
new file mode 100644
index 0000000..a62bf49
--- /dev/null
+++ b/src/main/java/net/e175/klaus/solarpositioning/Grena3.java
@@ -0,0 +1,119 @@
+package net.e175.klaus.solarpositioning;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+import static java.lang.Math.*;
+
+/**
+ * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
+ * certain point of the Earth's surface.*
+ * <p/>
+ * This follows the no. 3 algorithm described in Grena, 'Five new algorithms for the computation of sun position
+ * from 2010 to 2110', Solar Energy 86 (2012) pp. 1323-1337.
+ * <p/>
+ * This is <i>not</i> a port of the C code, but a re-implementation based on the published procedure.
+ *
+ * @author Klaus Brunner
+ */
+public final class Grena3 {
+
+	private Grena3() {
+	}
+
+	/**
+	 * Calculate topocentric solar position, i.e. the location of the sun on the sky for a certain point in time on a
+	 * certain point of the Earth's surface.
+	 * <p/>
+	 * This follows the no. 3 algorithm described in Grena, 'Five new algorithms for the computation of sun position
+	 * from 2010 to 2110', Solar Energy 86 (2012) pp. 1323-1337.
+	 * <p/>
+	 * The algorithm is supposed to work for the years 2010 to 2110, with a maximum error of 0.01 degrees.
+	 *
+	 * @param date        Observer's local date and time.
+	 * @param latitude    Observer's latitude, in degrees (negative south of equator).
+	 * @param longitude   Observer's longitude, in degrees (negative west of Greenwich).
+	 * @param deltaT      Difference between earth rotation time and terrestrial time (or Universal Time and Terrestrial Time),
+	 *                    in seconds. See
+	 *                    <a href ="http://asa.usno.navy.mil/SecK/DeltaT.html">http://asa.usno.navy.mil/SecK/DeltaT.html</a>.
+	 *                    For the year 2015, a reasonably accurate default would be 68.
+	 * @param pressure    Annual average local pressure, in millibars (or hectopascals). Used for refraction
+	 *                    correction of zenith angle. If unsure, 1000 is a reasonable default.
+	 * @param temperature Annual average local temperature, in degrees Celsius. Used for refraction correction of zenith angle.
+	 * @return Topocentric solar position (azimuth measured eastward from north)
+	 * @see AzimuthZenithAngle
+	 */
+	public static AzimuthZenithAngle calculateSolarPosition(final GregorianCalendar date, final double latitude,
+															final double longitude, final double deltaT, final double pressure,
+															final double temperature) {
+		final double t = calcT(date);
+		final double tE = t + 1.1574e-5 * deltaT;
+		final double omegaAtE = 0.0172019715 * tE;
+
+		final double lambda = -1.388803 + 1.720279216e-2 * tE + 3.3366e-2 * sin(omegaAtE - 0.06172)
+				+ 3.53e-4 * sin(2.0 * omegaAtE - 0.1163);
+
+		final double epsilon = 4.089567e-1 - 6.19e-9 * tE;
+
+		final double sLambda = sin(lambda);
+		final double cLambda = cos(lambda);
+		final double sEpsilon = sin(epsilon);
+		final double cEpsilon = sqrt(1 - sEpsilon * sEpsilon);
+
+		double alpha = atan2(sLambda * cEpsilon, cLambda);
+		if (alpha < 0) {
+			alpha += 2 * PI;
+		}
+
+		final double delta = asin(sLambda * sEpsilon);
+
+		double H = 1.7528311 + 6.300388099 * t + toRadians(longitude) - alpha;
+		H = ((H + PI) % (2 * PI)) - PI;
+		if (H < -PI) {
+			H += 2 * PI;
+		}
+
+		// end of "short procedure"
+
+		final double sPhi = sin(toRadians(latitude));
+		final double cPhi = sqrt((1 - sPhi * sPhi));
+		final double sDelta = sin(delta);
+		final double cDelta = sqrt(1 - sDelta * sDelta);
+		final double sH = sin(H);
+		final double cH = cos(H);
+
+		final double sEpsilon0 = sPhi * sDelta + cPhi * cDelta * cH;
+		final double eP = asin(sEpsilon0) - 4.26e-5 * sqrt(1.0 - sEpsilon0 * sEpsilon0);
+		final double gamma = atan2(sH, cH * sPhi - sDelta * cPhi / cDelta);
+
+		// refraction correction
+		final double deltaRe =
+				(eP > 0.0) ?
+						(0.08422 * (pressure / 1000)) / ((273.0 + temperature) * tan(eP + 0.003138 / (eP + 0.08919)))
+						: 0.0;
+
+		final double z = PI / 2 - eP - deltaRe;
+
+		return new AzimuthZenithAngle(toDegrees(gamma + PI) % 360.0, toDegrees(z));
+	}
+
+	private static double calcT(GregorianCalendar date) {
+		GregorianCalendar utc = JulianDate.createUtcCalendar(date);
+
+		int m = utc.get(Calendar.MONTH) + 1;
+		int y = utc.get(Calendar.YEAR);
+		final int d = utc.get(Calendar.DAY_OF_MONTH);
+		final double h = utc.get(Calendar.HOUR_OF_DAY) +
+				utc.get(Calendar.MINUTE) / 60d +
+				utc.get(Calendar.SECOND) / (60d * 60);
+
+		if (m <= 2) {
+			m += 12;
+			y -= 1;
+		}
+
+		return (int) (365.25 * (y - 2000)) + (int) (30.6001 * (m + 1))
+				- (int) (0.01 * y) + d + 0.0416667 * h - 21958;
+	}
+
+}
diff --git a/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java b/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java
index d3ed45d..af339b6 100644
--- a/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java
+++ b/src/main/java/net/e175/klaus/solarpositioning/JulianDate.java
@@ -53,7 +53,7 @@ public final class JulianDate {
 		this.deltaT = deltaT;
 	}
 
-	private GregorianCalendar createUtcCalendar(final GregorianCalendar fromCalendar) {
+	static GregorianCalendar createUtcCalendar(final GregorianCalendar fromCalendar) {
 		final GregorianCalendar utcCalendar = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
 		utcCalendar.setTimeInMillis(fromCalendar.getTimeInMillis());
 		utcCalendar.set(Calendar.ERA, fromCalendar.get(Calendar.ERA));
diff --git a/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java b/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java
new file mode 100644
index 0000000..64adf6d
--- /dev/null
+++ b/src/test/java/net/e175/klaus/solarpositioning/Grena3Test.java
@@ -0,0 +1,44 @@
+package net.e175.klaus.solarpositioning;
+
+import org.junit.Test;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
+
+import static java.lang.Math.PI;
+import static java.lang.Math.toDegrees;
+import static org.junit.Assert.assertEquals;
+
+public class Grena3Test {
+
+	private static final double TOLERANCE = 0.01; // advertised max error vis-a-vis SPA
+
+	@Test
+	public void cSampleComparison() {
+		GregorianCalendar time = new GregorianCalendar(new SimpleTimeZone(+1 * 60 * 60 * 1000, "CET"));
+		time.set(2012, Calendar.JANUARY, 1, 12, 0, 0);
+
+		AzimuthZenithAngle result = Grena3.calculateSolarPosition(time,
+				toDegrees(0.73117), toDegrees(0.21787), 65, 1000, 20);
+
+		assertEquals(toDegrees(1.1338), result.getZenithAngle(), TOLERANCE/10);
+		assertEquals(toDegrees(-0.059186 + PI) % 360.0, result.getAzimuth(), TOLERANCE/10);
+	}
+
+	@Test
+	public void spaComparison() {
+		GregorianCalendar time = new GregorianCalendar(TimeZone.getTimeZone("UTC"));
+		time.set(2015, Calendar.JUNE, 28, 17, 45, 12);
+
+		AzimuthZenithAngle result = Grena3.calculateSolarPosition(time,
+				52.509663, 13.376481, 68, 1000, 20);
+
+		assertEquals(291.232854, result.getAzimuth(), TOLERANCE);
+		assertEquals(76.799924, result.getZenithAngle(), TOLERANCE);
+	}
+
+	// TODO: more tests needed (other hemispheres, polar circle, etc.)
+
+}
