diff --git a/lib/hs/README b/lib/hs/README
index e58c8c93f..c5b35ebde 100644
--- a/lib/hs/README
+++ b/lib/hs/README
@@ -20,46 +20,53 @@ KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.
 
-Running
+Compile
 =======
 
-You need -fglasgow-exts. Use Cabal to compile and install. If you're trying to
-manually compile or load via ghci, and you're using ghc 6.10 (or really if your
-default base package has major version number 4), you must specify a version of
-the base package with major version number 3. Furthermore if you have the syb
-package installed you need to hide that package to avoid import conflicts.
-Here's an example of what I'm talking about:
+Use Cabal to compile and install; ./configure uses Cabal underneath, and that
+path is not yet well tested. Thrift's library and generated code should compile
+with pretty much any GHC extensions or warnings you enable (or disable).
+Please report this not being the case as a bug on
+https://issues.apache.org/jira/secure/CreateIssue!default.jspa
 
-  ghci -fglasgow-exts -package base-3.0.3.0 -hide-package syb -isrc Thrift.hs
+Chances you'll need to muck a bit with Cabal flags to install Thrift:
 
-To determine which versions of the base package you have installed use the
-following command:
+CABAL_CONFIGURE_FLAGS="--user" ./configure
 
-  ghc-pkg list base
+Base Types
+==========
 
-All of this is taken care of for you if you use Cabal.
+The mapping from Thrift types to Haskell's is:
 
+ * double -> Double
+ * i8 -> Data.Word.Word8
+ * i16 -> Data.Int.Int16
+ * i32 -> Data.Int.Int32
+ * i64 -> Data.Int.Int64
+ * string -> String
+ * binary -> Data.ByteString.Lazy
+ * bool -> Boolean
 
 Enums
 =====
 
-become haskell data types. Use fromEnum to get out the int value.
+Become Haskell 'data' types. Use fromEnum to get out the int value.
 
 Structs
 =======
 
-become records. Field labels are ugly, of the form f_STRUCTNAME_FIELDNAME. All
+Become records. Field labels are ugly, of the form f_STRUCTNAME_FIELDNAME. All
 fields are Maybe types.
 
 Exceptions
 ==========
 
-identical to structs. Throw them with throwDyn. Catch them with catchDyn.
+Identical to structs. Throw them with throwDyn. Catch them with catchDyn.
 
 Client
 ======
 
-just a bunch of functions. You may have to import a bunch of client files to
+Just a bunch of functions. You may have to import a bunch of client files to
 deal with inheritance.
 
 Interface
