diff --git a/compiler/cpp/src/generate/t_cpp_generator.cc b/compiler/cpp/src/generate/t_cpp_generator.cc
index 27d663328..db19c90c1 100755
--- a/compiler/cpp/src/generate/t_cpp_generator.cc
+++ b/compiler/cpp/src/generate/t_cpp_generator.cc
@@ -815,13 +815,14 @@ void t_cpp_generator::generate_struct_definition(ofstream& out,
       if ((*m_iter)->get_req() == t_field::T_REQUIRED) {
         continue;
       }
+      string isSet = ((*m_iter)->get_value() != NULL) ? "true" : "false";
       if (first) {
         first = false;
         out <<
-          ": " << (*m_iter)->get_name() << "(false)";
+          ": " << (*m_iter)->get_name() << "(" << isSet << ")";
       } else {
         out <<
-          ", " << (*m_iter)->get_name() << "(false)";
+          ", " << (*m_iter)->get_name() << "(" << isSet << ")";
       }
     }
     out << " {}" << endl;
diff --git a/lib/cpp/test/OptionalRequiredTest.cpp b/lib/cpp/test/OptionalRequiredTest.cpp
index 747260359..5d58f0985 100644
--- a/lib/cpp/test/OptionalRequiredTest.cpp
+++ b/lib/cpp/test/OptionalRequiredTest.cpp
@@ -242,5 +242,21 @@ int main() {
     assert(t1 != t2);
   }
 
+  {
+    OptionalDefault t1, t2;
+    cout << ThriftDebugString(t1) << endl;
+    assert(t1.__isset.opt_int == true);
+    assert(t1.__isset.opt_str == true);
+    assert(t1.opt_int == t2.opt_int);
+    assert(t1.opt_str == t2.opt_str);
+
+    write_to_read(t1, t2);
+    cout << ThriftDebugString(t2) << endl;
+    assert(t2.__isset.opt_int == true);
+    assert(t2.__isset.opt_str == true);
+    assert(t1.opt_int == t2.opt_int);
+    assert(t1.opt_str == t2.opt_str);
+  }
+
   return 0;
 }
diff --git a/test/OptionalRequiredTest.thrift b/test/OptionalRequiredTest.thrift
index 8108a7f7b..dcdd0f2cc 100644
--- a/test/OptionalRequiredTest.thrift
+++ b/test/OptionalRequiredTest.thrift
@@ -49,6 +49,11 @@ struct Tricky3 {
   1: required i16 im_required;
 }
 
+struct OptionalDefault {
+  1: optional i16 opt_int = 1234;
+  2: optional string opt_str = "default";
+}
+
 struct Complex {
   1:          i16 cp_default;
   2: required i16 cp_required;
