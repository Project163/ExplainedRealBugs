diff --git a/compiler/cpp/src/generate/t_generator.h b/compiler/cpp/src/generate/t_generator.h
index 8c156f921..458922ff7 100644
--- a/compiler/cpp/src/generate/t_generator.h
+++ b/compiler/cpp/src/generate/t_generator.h
@@ -237,10 +237,7 @@ class t_generator {
    * Get the true type behind a series of typedefs.
    */
   static t_type* get_true_type(t_type* type) {
-    while (type->is_typedef()) {
-      type = ((t_typedef*)type)->get_type();
-    }
-    return type;
+    return type->get_true_type();
   }
 
  protected:
diff --git a/compiler/cpp/src/parse/parse.cc b/compiler/cpp/src/parse/parse.cc
index 2570c37b5..a6556525e 100644
--- a/compiler/cpp/src/parse/parse.cc
+++ b/compiler/cpp/src/parse/parse.cc
@@ -1,4 +1,5 @@
 #include "t_type.h"
+#include "t_typedef.h"
 
 #include "md5.h"
 
@@ -9,3 +10,11 @@ void t_type::generate_fingerprint() {
   md5_append(&ctx, (md5_byte_t*)(material.data()), (int)material.size());
   md5_finish(&ctx, (md5_byte_t*)fingerprint_);
 }
+
+t_type* t_type::get_true_type() {
+  t_type* type = this;
+  while (type->is_typedef()) {
+    type = ((t_typedef*)type)->get_type();
+  }
+  return type;
+}
diff --git a/compiler/cpp/src/parse/t_scope.h b/compiler/cpp/src/parse/t_scope.h
index 01894aa88..4617bf8d7 100644
--- a/compiler/cpp/src/parse/t_scope.h
+++ b/compiler/cpp/src/parse/t_scope.h
@@ -115,8 +115,11 @@ class t_scope {
           throw "No enum value or constant found named \"" + const_val->get_identifier() + "\"!";
         }
 
-        if (constant->get_type()->is_base_type()) {
-          switch (((t_base_type*)constant->get_type())->get_base()) {
+        // Resolve typedefs to the underlying type
+        t_type* const_type = constant->get_type()->get_true_type();
+
+        if (const_type->is_base_type()) {
+          switch (((t_base_type*)const_type)->get_base()) {
             case t_base_type::TYPE_I16:
             case t_base_type::TYPE_I32:
             case t_base_type::TYPE_I64:
@@ -133,7 +136,7 @@ class t_scope {
             case t_base_type::TYPE_VOID:
               throw "Constants cannot be of type VOID";
           }
-        } else if (constant->get_type()->is_map()) {
+        } else if (const_type->is_map()) {
           const std::map<t_const_value*, t_const_value*>& map = constant->get_value()->get_map();
           std::map<t_const_value*, t_const_value*>::const_iterator v_iter;
 
@@ -141,7 +144,7 @@ class t_scope {
           for (v_iter = map.begin(); v_iter != map.end(); ++v_iter) {
             const_val->add_map(v_iter->first, v_iter->second);
           }
-        } else if (constant->get_type()->is_list()) {
+        } else if (const_type->is_list()) {
           const std::vector<t_const_value*>& val = constant->get_value()->get_list();
           std::vector<t_const_value*>::const_iterator v_iter;
 
diff --git a/compiler/cpp/src/parse/t_type.h b/compiler/cpp/src/parse/t_type.h
index 0941a2644..f02427956 100644
--- a/compiler/cpp/src/parse/t_type.h
+++ b/compiler/cpp/src/parse/t_type.h
@@ -66,6 +66,7 @@ class t_type : public t_doc {
     return program_;
   }
 
+  t_type* get_true_type();
 
   // Return a string that uniquely identifies this type
   // from any other thrift type in the world, as far as
