diff --git a/compiler/cpp/src/generate/t_go_generator.cc b/compiler/cpp/src/generate/t_go_generator.cc
index 6e887a7d1..c581ffa8a 100644
--- a/compiler/cpp/src/generate/t_go_generator.cc
+++ b/compiler/cpp/src/generate/t_go_generator.cc
@@ -334,6 +334,8 @@ static bool type_need_reference(t_type* type) {
 	if( type->is_map()
 	 || type->is_set()
 	 || type->is_list()
+	 || type->is_struct()
+	 || type->is_xception()
 	 || (type->is_string() && ((t_base_type*)type)->is_binary() )) {
 		return false;
 	}
@@ -347,7 +349,7 @@ bool t_go_generator::is_pointer_field(t_field* tfield, bool in_container_value)
 	}
 	t_type* type = tfield->get_type()->get_true_type();
 	//Structs in containers are pointers
-	if (in_container_value && type->is_struct()) {
+	if (type->is_struct() || type->is_xception()) {
 		return true;
 	}
 	if (!(tfield->get_req() == t_field::T_OPTIONAL)) {
@@ -2532,7 +2534,7 @@ void t_go_generator::generate_process_function(t_service* tservice,
 
         for (xf_iter = x_fields.begin(); xf_iter != x_fields.end(); ++xf_iter) {
             f_service_ <<
-                        indent() << "  case *" << type_to_go_type(((*xf_iter)->get_type())) << ":" << endl <<
+                        indent() << "  case " << type_to_go_type(((*xf_iter)->get_type())) << ":" << endl <<
                         indent() << "result." << publicize(variable_name_to_go_name((*xf_iter)->get_name())) << " = v" << endl;
         }
         
@@ -3441,10 +3443,7 @@ string t_go_generator::type_to_go_type_with_opt(t_type* type, bool optional_fiel
     } else if (type->is_enum()) {
         return maybe_pointer + publicize(type_name(type));
     } else if (type->is_struct() || type->is_xception()) {
-    	if (is_container_value) {
-    		maybe_pointer = "*";
-    	}
-        return maybe_pointer + publicize(type_name(type));
+        return "*" + publicize(type_name(type));
     } else if (type->is_map()) {
         t_map* t = (t_map*)type;
         string keyType = type_to_go_key_type(t->get_key_type());
diff --git a/lib/go/test/ServicesTest.thrift b/lib/go/test/ServicesTest.thrift
index 1b8be3648..c79f472a3 100644
--- a/lib/go/test/ServicesTest.thrift
+++ b/lib/go/test/ServicesTest.thrift
@@ -106,4 +106,6 @@ service a_serv {
 	struct_a struct_a_func_1ex_1int_1s(1: i64 i, 2: string s) throws(1: moderate_disaster err1)
 	struct_a struct_a_func_2ex_1int_1s(1: i64 i, 2: string s) throws(1: moderate_disaster err1, 2:total_disaster err2)
 
+	struct_a struct_a_func_1struct_a(1: struct_a st)
+
 }
diff --git a/lib/go/test/tests/struct_args_rets_test.go b/lib/go/test/tests/struct_args_rets_test.go
new file mode 100644
index 000000000..c96586560
--- /dev/null
+++ b/lib/go/test/tests/struct_args_rets_test.go
@@ -0,0 +1,36 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+package tests
+
+import (
+	st "ServicesTest"
+)
+
+//this function is never called, it will fail to compile if check is failed
+func staticCheckStructArgsResults() {
+	//Check that struct args and results are passed by reference
+	var sa *st.StructA = &st.StructA{}
+	var iface st.AServ
+	var err error
+
+	sa, err = iface.StructAFunc_1structA(sa)
+	_ = err
+	_ = sa
+}
