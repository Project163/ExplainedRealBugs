diff --git a/lib/rs/src/protocol/binary.rs b/lib/rs/src/protocol/binary.rs
index f3c9ea20c..54613a532 100644
--- a/lib/rs/src/protocol/binary.rs
+++ b/lib/rs/src/protocol/binary.rs
@@ -55,17 +55,18 @@ const BINARY_PROTOCOL_VERSION_1: u32 = 0x80010000;
 /// let recvd_bool = i_prot.read_bool().unwrap();
 /// let recvd_string = i_prot.read_string().unwrap();
 /// ```
-pub struct TBinaryInputProtocol {
+pub struct TBinaryInputProtocol<'a> {
     strict: bool,
-    transport: Rc<RefCell<Box<TTransport>>>,
+    transport: Rc<RefCell<Box<TTransport + 'a>>>,
 }
 
-impl TBinaryInputProtocol {
+impl<'a> TBinaryInputProtocol<'a> {
     /// Create a `TBinaryInputProtocol` that reads bytes from `transport`.
     ///
     /// Set `strict` to `true` if all incoming messages contain the protocol
     /// version number in the protocol header.
-    pub fn new(transport: Rc<RefCell<Box<TTransport>>>, strict: bool) -> TBinaryInputProtocol {
+    pub fn new(transport: Rc<RefCell<Box<TTransport + 'a>>>,
+               strict: bool) -> TBinaryInputProtocol<'a> {
         TBinaryInputProtocol {
             strict: strict,
             transport: transport,
@@ -73,7 +74,7 @@ impl TBinaryInputProtocol {
     }
 }
 
-impl TInputProtocol for TBinaryInputProtocol {
+impl<'a> TInputProtocol for TBinaryInputProtocol<'a> {
     #[cfg_attr(feature = "cargo-clippy", allow(collapsible_if))]
     fn read_message_begin(&mut self) -> ::Result<TMessageIdentifier> {
         let mut first_bytes = vec![0; 4];
@@ -239,8 +240,8 @@ impl TBinaryInputProtocolFactory {
 }
 
 impl TInputProtocolFactory for TBinaryInputProtocolFactory {
-    fn create(&mut self, transport: Rc<RefCell<Box<TTransport>>>) -> Box<TInputProtocol> {
-        Box::new(TBinaryInputProtocol::new(transport, true)) as Box<TInputProtocol>
+    fn create<'a>(&mut self, transport: Rc<RefCell<Box<TTransport + 'a>>>) -> Box<TInputProtocol + 'a> {
+        Box::new(TBinaryInputProtocol::new(transport, true)) as Box<TInputProtocol + 'a>
     }
 }
 
@@ -269,17 +270,18 @@ impl TInputProtocolFactory for TBinaryInputProtocolFactory {
 /// o_prot.write_bool(true).unwrap();
 /// o_prot.write_string("test_string").unwrap();
 /// ```
-pub struct TBinaryOutputProtocol {
+pub struct TBinaryOutputProtocol<'a> {
     strict: bool,
-    transport: Rc<RefCell<Box<TTransport>>>,
+    transport: Rc<RefCell<Box<TTransport + 'a>>>,
 }
 
-impl TBinaryOutputProtocol {
+impl<'a> TBinaryOutputProtocol<'a> {
     /// Create a `TBinaryOutputProtocol` that writes bytes to `transport`.
     ///
     /// Set `strict` to `true` if all outgoing messages should contain the
     /// protocol version number in the protocol header.
-    pub fn new(transport: Rc<RefCell<Box<TTransport>>>, strict: bool) -> TBinaryOutputProtocol {
+    pub fn new(transport: Rc<RefCell<Box<TTransport + 'a>>>,
+               strict: bool) -> TBinaryOutputProtocol<'a> {
         TBinaryOutputProtocol {
             strict: strict,
             transport: transport,
@@ -291,7 +293,7 @@ impl TBinaryOutputProtocol {
     }
 }
 
-impl TOutputProtocol for TBinaryOutputProtocol {
+impl<'a> TOutputProtocol for TBinaryOutputProtocol<'a> {
     fn write_message_begin(&mut self, identifier: &TMessageIdentifier) -> ::Result<()> {
         if self.strict {
             let message_type: u8 = identifier.message_type.into();
@@ -794,10 +796,11 @@ mod tests {
         assert_eq!(&received_bytes, &bytes);
     }
 
-    fn test_objects
+    fn test_objects<'a>
         ()
-        -> (Rc<RefCell<Box<TBufferTransport>>>, TBinaryInputProtocol, TBinaryOutputProtocol)
+        -> (Rc<RefCell<Box<TBufferTransport>>>, TBinaryInputProtocol<'a>, TBinaryOutputProtocol<'a>)
     {
+
         let mem = Rc::new(RefCell::new(Box::new(TBufferTransport::with_capacity(40, 40))));
 
         let inner: Box<TTransport> = Box::new(TPassThruTransport { inner: mem.clone() });
diff --git a/lib/rs/src/protocol/compact.rs b/lib/rs/src/protocol/compact.rs
index 96fa8efa0..353514d30 100644
--- a/lib/rs/src/protocol/compact.rs
+++ b/lib/rs/src/protocol/compact.rs
@@ -53,7 +53,7 @@ const COMPACT_VERSION_MASK: u8 = 0x1F;
 /// let recvd_bool = i_prot.read_bool().unwrap();
 /// let recvd_string = i_prot.read_string().unwrap();
 /// ```
-pub struct TCompactInputProtocol {
+pub struct TCompactInputProtocol<'a> {
     // Identifier of the last field deserialized for a struct.
     last_read_field_id: i16,
     // Stack of the last read field ids (a new entry is added each time a nested struct is read).
@@ -63,12 +63,12 @@ pub struct TCompactInputProtocol {
     // and reading the field only occurs after the field id is read.
     pending_read_bool_value: Option<bool>,
     // Underlying transport used for byte-level operations.
-    transport: Rc<RefCell<Box<TTransport>>>,
+    transport: Rc<RefCell<Box<TTransport + 'a>>>,
 }
 
-impl TCompactInputProtocol {
+impl<'a> TCompactInputProtocol<'a> {
     /// Create a `TCompactInputProtocol` that reads bytes from `transport`.
-    pub fn new(transport: Rc<RefCell<Box<TTransport>>>) -> TCompactInputProtocol {
+    pub fn new(transport: Rc<RefCell<Box<TTransport + 'a>>>) -> TCompactInputProtocol<'a> {
         TCompactInputProtocol {
             last_read_field_id: 0,
             read_field_id_stack: Vec::new(),
@@ -94,7 +94,7 @@ impl TCompactInputProtocol {
     }
 }
 
-impl TInputProtocol for TCompactInputProtocol {
+impl<'a> TInputProtocol for TCompactInputProtocol<'a> {
     fn read_message_begin(&mut self) -> ::Result<TMessageIdentifier> {
         let compact_id = self.read_byte()?;
         if compact_id != COMPACT_PROTOCOL_ID {
@@ -294,8 +294,8 @@ impl TCompactInputProtocolFactory {
 }
 
 impl TInputProtocolFactory for TCompactInputProtocolFactory {
-    fn create(&mut self, transport: Rc<RefCell<Box<TTransport>>>) -> Box<TInputProtocol> {
-        Box::new(TCompactInputProtocol::new(transport)) as Box<TInputProtocol>
+    fn create<'a>(&mut self, transport: Rc<RefCell<Box<TTransport + 'a>>>) -> Box<TInputProtocol + 'a> {
+        Box::new(TCompactInputProtocol::new(transport)) as Box<TInputProtocol + 'a>
     }
 }
 
@@ -320,7 +320,7 @@ impl TInputProtocolFactory for TCompactInputProtocolFactory {
 /// o_prot.write_bool(true).unwrap();
 /// o_prot.write_string("test_string").unwrap();
 /// ```
-pub struct TCompactOutputProtocol {
+pub struct TCompactOutputProtocol<'a> {
     // Identifier of the last field serialized for a struct.
     last_write_field_id: i16,
     // Stack of the last written field ids (a new entry is added each time a nested struct is written).
@@ -329,12 +329,12 @@ pub struct TCompactOutputProtocol {
     // Saved because boolean fields and their value are encoded in a single byte
     pending_write_bool_field_identifier: Option<TFieldIdentifier>,
     // Underlying transport used for byte-level operations.
-    transport: Rc<RefCell<Box<TTransport>>>,
+    transport: Rc<RefCell<Box<TTransport + 'a>>>,
 }
 
-impl TCompactOutputProtocol {
+impl<'a> TCompactOutputProtocol<'a> {
     /// Create a `TCompactOutputProtocol` that writes bytes to `transport`.
-    pub fn new(transport: Rc<RefCell<Box<TTransport>>>) -> TCompactOutputProtocol {
+    pub fn new(transport: Rc<RefCell<Box<TTransport + 'a>>>) -> TCompactOutputProtocol<'a> {
         TCompactOutputProtocol {
             last_write_field_id: 0,
             write_field_id_stack: Vec::new(),
@@ -379,7 +379,7 @@ impl TCompactOutputProtocol {
     }
 }
 
-impl TOutputProtocol for TCompactOutputProtocol {
+impl<'a> TOutputProtocol for TCompactOutputProtocol<'a> {
     fn write_message_begin(&mut self, identifier: &TMessageIdentifier) -> ::Result<()> {
         self.write_byte(COMPACT_PROTOCOL_ID)?;
         self.write_byte((u8::from(identifier.message_type) << 5) | COMPACT_VERSION)?;
@@ -2062,9 +2062,9 @@ mod tests {
         assert!(i_prot.read_map_end().is_ok()); // will blow up if we try to read from empty buffer
     }
 
-    fn test_objects
+    fn test_objects<'a>
         ()
-        -> (Rc<RefCell<Box<TBufferTransport>>>, TCompactInputProtocol, TCompactOutputProtocol)
+        -> (Rc<RefCell<Box<TBufferTransport>>>, TCompactInputProtocol<'a>, TCompactOutputProtocol<'a>)
     {
         let mem = Rc::new(RefCell::new(Box::new(TBufferTransport::with_capacity(80, 80))));
 
diff --git a/lib/rs/src/protocol/multiplexed.rs b/lib/rs/src/protocol/multiplexed.rs
index 15fe6086d..a30aca80a 100644
--- a/lib/rs/src/protocol/multiplexed.rs
+++ b/lib/rs/src/protocol/multiplexed.rs
@@ -53,17 +53,17 @@ use super::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifie
 /// let ident = TMessageIdentifier::new("svc_call", TMessageType::Call, 1);
 /// o_prot.write_message_begin(&ident).unwrap();
 /// ```
-pub struct TMultiplexedOutputProtocol {
+pub struct TMultiplexedOutputProtocol<'a> {
     service_name: String,
-    inner: Box<TOutputProtocol>,
+    inner: Box<TOutputProtocol + 'a>,
 }
 
-impl TMultiplexedOutputProtocol {
+impl<'a> TMultiplexedOutputProtocol<'a> {
     /// Create a `TMultiplexedOutputProtocol` that identifies outgoing messages
     /// as originating from a service named `service_name` and sends them over
     /// the `wrapped` `TOutputProtocol`. Outgoing messages are encoded and sent
     /// by `wrapped`, not by this instance.
-    pub fn new(service_name: &str, wrapped: Box<TOutputProtocol>) -> TMultiplexedOutputProtocol {
+    pub fn new(service_name: &str, wrapped: Box<TOutputProtocol + 'a>) -> TMultiplexedOutputProtocol<'a> {
         TMultiplexedOutputProtocol {
             service_name: service_name.to_owned(),
             inner: wrapped,
@@ -72,7 +72,7 @@ impl TMultiplexedOutputProtocol {
 }
 
 // FIXME: avoid passthrough methods
-impl TOutputProtocol for TMultiplexedOutputProtocol {
+impl<'a> TOutputProtocol for TMultiplexedOutputProtocol<'a> {
     fn write_message_begin(&mut self, identifier: &TMessageIdentifier) -> ::Result<()> {
         match identifier.message_type { // FIXME: is there a better way to override identifier here?
             TMessageType::Call | TMessageType::OneWay => {
@@ -205,7 +205,7 @@ mod tests {
         assert_eq!(&trans.borrow().write_buffer_to_vec(), &expected);
     }
 
-    fn test_objects() -> (Rc<RefCell<Box<TBufferTransport>>>, TMultiplexedOutputProtocol) {
+    fn test_objects<'a>() -> (Rc<RefCell<Box<TBufferTransport>>>, TMultiplexedOutputProtocol<'a>) {
         let mem = Rc::new(RefCell::new(Box::new(TBufferTransport::with_capacity(40, 40))));
 
         let inner: Box<TTransport> = Box::new(TPassThruTransport { inner: mem.clone() });
