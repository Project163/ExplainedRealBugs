diff --git a/lib/rb/ext/binaryprotocolaccelerated.c b/lib/rb/ext/binaryprotocolaccelerated.c
index 31e969e47..6e295ed2f 100644
--- a/lib/rb/ext/binaryprotocolaccelerated.c
+++ b/lib/rb/ext/binaryprotocolaccelerated.c
@@ -259,10 +259,9 @@ static void write_double(VALUE buf, double dub) {
   write_i64(buf, transfer.t);
 }
 
-static void write_string(VALUE buf, char* str) {
-  int32_t len = strlen(str);
+static void write_string(VALUE buf, char* str, size_t len) {
   write_i32(buf, len);
-  rb_str_buf_cat2(buf, str);
+  rb_str_buf_cat(buf, str, len);
 }
 
 // Some functions macro'd out because they're nops for the binary protocol
@@ -473,7 +472,7 @@ static void binary_encoding(VALUE buf, VALUE obj, int type) {
       break;
 
     case T_STR:
-      write_string(buf, StringValuePtr(obj));
+      write_string(buf, StringValuePtr(obj), RSTRING(obj)->len);
       break;
           
     case T_STRCT: {
diff --git a/lib/rb/spec/binaryprotocolaccelerated_spec.rb b/lib/rb/spec/binaryprotocolaccelerated_spec.rb
index c816369a3..86101f81d 100644
--- a/lib/rb/spec/binaryprotocolaccelerated_spec.rb
+++ b/lib/rb/spec/binaryprotocolaccelerated_spec.rb
@@ -70,6 +70,16 @@ class ThriftBinaryProtocolAcceleratedSpec < Spec::ExampleGroup
 \000\005words\f\000\003\v\000\001\000\000\000\rhello, world!\000\000")
       @prot.decode_binary(SpecNamespace::Foo.new, trans).should == SpecNamespace::Foo.new
     end
+
+    it "should encode a string with null bytes in it" do
+      foo = SpecNamespace::Hello.new(:greeting => "Hello\000World!")
+      @prot.encode_binary(foo).should == "\v\000\001\000\000\000\fHello\000World!\000"
+    end
+
+    it "should decode a string with null bytes in it" do
+      trans = Thrift::MemoryBuffer.new("\v\000\001\000\000\000\fHello\000World!\000")
+      @prot.decode_binary(SpecNamespace::Hello.new, trans).should == SpecNamespace::Hello.new(:greeting => "Hello\000World!")
+    end
   end
 
   describe BinaryProtocolAcceleratedFactory do
