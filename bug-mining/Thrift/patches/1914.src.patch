diff --git a/compiler/cpp/src/thrift/generate/t_rb_generator.cc b/compiler/cpp/src/thrift/generate/t_rb_generator.cc
index 3f2b78e6a..13ea2490e 100644
--- a/compiler/cpp/src/thrift/generate/t_rb_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_rb_generator.cc
@@ -113,6 +113,7 @@ public:
   void generate_enum(t_enum* tenum);
   void generate_const(t_const* tconst);
   void generate_struct(t_struct* tstruct);
+  void generate_forward_declaration(t_struct* tstruct);
   void generate_union(t_struct* tunion);
   void generate_xception(t_struct* txception);
   void generate_service(t_service* tservice);
@@ -123,6 +124,7 @@ public:
    * Struct generation code
    */
 
+  void generate_rb_struct_declaration(t_rb_ofstream& out, t_struct* tstruct, bool is_exception);
   void generate_rb_struct(t_rb_ofstream& out, t_struct* tstruct, bool is_exception);
   void generate_rb_struct_required_validator(t_rb_ofstream& out, t_struct* tstruct);
   void generate_rb_union(t_rb_ofstream& out, t_struct* tstruct, bool is_exception);
@@ -529,6 +531,29 @@ void t_rb_generator::generate_struct(t_struct* tstruct) {
   }
 }
 
+
+/**
+ * Generates the "forward declarations" for ruby structs.
+ * These are simply a declaration of each class with proper inheritance.
+ * The rest of the struct is still generated in generate_struct as has
+ * always been the case. These declarations allow thrift to generate valid
+ * ruby in cases where thrift structs rely on recursive definitions.
+ */
+void t_rb_generator::generate_forward_declaration(t_struct* tstruct) {
+  generate_rb_struct_declaration(f_types_, tstruct, tstruct->is_xception());
+}
+
+void t_rb_generator::generate_rb_struct_declaration(t_rb_ofstream& out, t_struct* tstruct, bool is_exception) {
+  out.indent() << "class " << type_name(tstruct);
+  if (tstruct->is_union()) {
+    out << " < ::Thrift::Union";
+  }
+  if (is_exception) {
+    out << " < ::Thrift::Exception";
+  }
+  out << "; end" << endl << endl;
+}
+
 /**
  * Generates a struct definition for a thrift exception. Basically the same
  * as a struct but extends the Exception class.
diff --git a/test/rb/Makefile.am b/test/rb/Makefile.am
index 4bd470481..cfdc1496e 100644
--- a/test/rb/Makefile.am
+++ b/test/rb/Makefile.am
@@ -20,6 +20,7 @@
 stubs: $(THRIFT) ../ThriftTest.thrift ../SmallTest.thrift
 	$(THRIFT) --gen rb ../ThriftTest.thrift
 	$(THRIFT) --gen rb ../SmallTest.thrift
+	$(THRIFT) --gen rb ../Recursive.thrift
 
 precross: stubs
 
diff --git a/test/rb/generation/test_recursive.rb b/test/rb/generation/test_recursive.rb
new file mode 100644
index 000000000..e912f72f5
--- /dev/null
+++ b/test/rb/generation/test_recursive.rb
@@ -0,0 +1,41 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+require File.join(File.dirname(__FILE__), '../test_helper')
+require 'recursive_types'
+
+class TestRecursiveGeneration < Test::Unit::TestCase
+  CHILD_ITEM = "child item"
+  PARENT_ITEM = "parent item"
+
+  def test_can_create_recursive_tree
+
+    child_tree = RecTree.new
+    child_tree.item = CHILD_ITEM
+
+    parent_tree = RecTree.new
+    parent_tree.item = PARENT_ITEM
+    parent_tree.children = [child_tree]
+
+    assert_equal(PARENT_ITEM, parent_tree.item)
+    assert_equal(1, parent_tree.children.length)
+    assert_equal(CHILD_ITEM, parent_tree.children.first.item)
+    assert_nil(parent_tree.children.first.children)
+  end
+end
