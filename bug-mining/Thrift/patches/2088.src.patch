diff --git a/lib/hs/src/Thrift/Transport/Framed.hs b/lib/hs/src/Thrift/Transport/Framed.hs
index 42fc43f39..ad553aed8 100644
--- a/lib/hs/src/Thrift/Transport/Framed.hs
+++ b/lib/hs/src/Thrift/Transport/Framed.hs
@@ -87,11 +87,11 @@ instance Transport t => Transport (FramedTransport t) where
 readFrame :: Transport t => FramedTransport t -> IO Int
 readFrame trans = do
   -- Read and decode the frame size.
-  szBs <- tRead (wrappedTrans trans) 4
+  szBs <- tReadAll (wrappedTrans trans) 4
   let sz = fromIntegral (B.decode szBs :: Int32)
 
   -- Read the frame and stuff it into the read buffer.
-  bs <- tRead (wrappedTrans trans) sz
+  bs <- tReadAll (wrappedTrans trans) sz
   fillBuf (readBuffer trans) bs
 
   -- Return the frame size so that the caller knows whether to expect
diff --git a/lib/hs/src/Thrift/Transport/Handle.hs b/lib/hs/src/Thrift/Transport/Handle.hs
index ff6295b67..528a02793 100644
--- a/lib/hs/src/Thrift/Transport/Handle.hs
+++ b/lib/hs/src/Thrift/Transport/Handle.hs
@@ -28,6 +28,7 @@ module Thrift.Transport.Handle
     ) where
 
 import Control.Exception ( catch, throw )
+import Control.Monad ( when )
 import Data.ByteString.Internal (c2w)
 import Data.Functor
 
@@ -50,7 +51,13 @@ instance Transport Handle where
           hLookAhead h
           LBS.hGetNonBlocking h n
     tReadAll _ 0 = return mempty
-    tReadAll h n = LBS.hGet h n `Control.Exception.catch` throwTransportExn
+    tReadAll h n = do
+      result <- LBS.hGet h n `Control.Exception.catch` throwTransportExn
+      let rlen = fromIntegral $ LBS.length result
+      when (rlen == 0) (throw $ TransportExn "Cannot read. Remote side has closed." TE_UNKNOWN)
+      if n <= rlen
+        then return result
+        else (result `mappend`) <$> tReadAll h (n - rlen)
     tPeek h = (Just . c2w <$> hLookAhead h) `Control.Exception.catch` handleEOF Nothing
     tWrite = LBS.hPut
     tFlush = hFlush
