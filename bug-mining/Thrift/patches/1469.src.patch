diff --git a/compiler/cpp/src/generate/t_py_generator.cc b/compiler/cpp/src/generate/t_py_generator.cc
index 00be6e792..a90bfca04 100644
--- a/compiler/cpp/src/generate/t_py_generator.cc
+++ b/compiler/cpp/src/generate/t_py_generator.cc
@@ -2555,6 +2555,9 @@ string t_py_generator::type_to_spec_args(t_type* ttype) {
 
   if (ttype->is_base_type() && reinterpret_cast<t_base_type*>(ttype)->is_binary()) {
     return  "'BINARY'";
+  } else if (gen_utf8strings_ && ttype->is_base_type()
+             && reinterpret_cast<t_base_type*>(ttype)->is_string()) {
+    return "'UTF8'";
   } else if (ttype->is_base_type() || ttype->is_enum()) {
     return  "None";
   } else if (ttype->is_struct() || ttype->is_xception()) {
diff --git a/lib/py/src/protocol/fastbinary.c b/lib/py/src/protocol/fastbinary.c
index 091a6170b..714fb1364 100644
--- a/lib/py/src/protocol/fastbinary.c
+++ b/lib/py/src/protocol/fastbinary.c
@@ -226,6 +226,10 @@ parse_pyint(PyObject* o, int32_t* ret, int32_t min, int32_t max) {
   return true;
 }
 
+static bool
+is_utf8(PyObject* typeargs) {
+  return PyString_Check(typeargs) && !strcmp(PyString_AS_STRING(typeargs), "UTF8");
+}
 
 /* --- FUNCTIONS TO PARSE STRUCT SPECIFICATOINS --- */
 
@@ -430,7 +434,10 @@ output_val(PyObject* output, PyObject* value, TType type, PyObject* typeargs) {
   }
 
   case T_STRING: {
-    Py_ssize_t len = PyString_Size(value);
+    Py_ssize_t len = 0;
+    if (is_utf8(typeargs) && PyUnicode_Check(value))
+      value = PyUnicode_AsUTF8String(value);
+    len = PyString_Size(value);
 
     if (!check_ssize_t_32(len)) {
       return false;
@@ -1053,7 +1060,10 @@ decode_val(DecodeBuffer* input, TType type, PyObject* typeargs) {
       return NULL;
     }
 
-    return PyString_FromStringAndSize(buf, len);
+    if (is_utf8(typeargs))
+      return PyUnicode_DecodeUTF8(buf, len, 0);
+    else
+      return PyString_FromStringAndSize(buf, len);
   }
 
   case T_LIST:
