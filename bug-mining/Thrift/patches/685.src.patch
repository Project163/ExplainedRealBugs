diff --git a/compiler/cpp/src/generate/t_py_generator.cc b/compiler/cpp/src/generate/t_py_generator.cc
index 8f79c377e..60856703f 100644
--- a/compiler/cpp/src/generate/t_py_generator.cc
+++ b/compiler/cpp/src/generate/t_py_generator.cc
@@ -95,7 +95,7 @@ class t_py_generator : public t_generator {
     gen_utf8strings_ = (iter != parsed_options.end());
 
     copy_options_ = option_string;
-    
+
     if (gen_twisted_){
       out_dir_base_ = "gen-py.twisted";
     } else {
@@ -260,17 +260,17 @@ class t_py_generator : public t_generator {
    * True if we should generate dynamic style classes.
    */
   bool gen_dynamic_;
- 
+
   bool gen_dynbase_;
   std::string gen_dynbaseclass_;
   std::string gen_dynbaseclass_exc_;
- 
+
   std::string import_dynbase_;
 
   bool gen_slots_;
 
   std::string copy_options_;
- 
+
   /**
    * True if we should generate Twisted-friendly RPC services.
    */
@@ -447,7 +447,7 @@ void t_py_generator::generate_enum(t_enum* tenum) {
   f_types_ <<
     "class " << tenum->get_name() <<
     (gen_newstyle_ ? "(object)" : "") <<
-    (gen_dynamic_ ? "(" + gen_dynbaseclass_ + ")" : "") <<  
+    (gen_dynamic_ ? "(" + gen_dynbaseclass_ + ")" : "") <<
     ":" << endl;
   indent_up();
   generate_python_docstring(f_types_, tenum);
@@ -805,7 +805,7 @@ void t_py_generator::generate_py_struct_definition(ofstream& out,
       indent() << "    for key in self.__slots__]" << endl <<
       indent() << "  return '%s(%s)' % (self.__class__.__name__, ', '.join(L))" << endl <<
       endl;
-    
+
     // Equality method that compares each attribute by value and type, walking __slots__
     out <<
       indent() << "def __eq__(self, other):" << endl <<
@@ -818,7 +818,7 @@ void t_py_generator::generate_py_struct_definition(ofstream& out,
       indent() << "      return False" << endl <<
       indent() << "  return True" << endl <<
       endl;
-    
+
     out <<
       indent() << "def __ne__(self, other):" << endl <<
       indent() << "  return not (self == other)" << endl <<
@@ -1412,7 +1412,7 @@ void t_py_generator::generate_service_client(t_service* tservice) {
  */
 void t_py_generator::generate_service_remote(t_service* tservice) {
   vector<t_function*> functions = tservice->get_functions();
-  //Get all function from parents  
+  //Get all function from parents
   t_service* parent = tservice->get_extends();
   while(parent != NULL) {
     vector<t_function*> p_functions = parent->get_functions();
@@ -2382,11 +2382,15 @@ string t_py_generator::render_field_default_value(t_field* tfield) {
  * @return String of rendered function definition
  */
 string t_py_generator::function_signature(t_function* tfunction,
-                                           string prefix) {
-  // TODO(mcslee): Nitpicky, no ',' if argument_list is empty
-  return
-    prefix + tfunction->get_name() +
-    "(self, " + argument_list(tfunction->get_arglist()) + ")";
+                                          string prefix) {
+  string argument_list_result = argument_list(tfunction->get_arglist());
+  if (!argument_list_result.empty()) {
+    argument_list_result = "self, " + argument_list_result;
+  } else {
+    argument_list_result = "self";
+  }
+
+  return prefix + tfunction->get_name() + "(" + argument_list_result + ")";
 }
 
 /**
@@ -2396,14 +2400,16 @@ string t_py_generator::function_signature(t_function* tfunction,
  * @return String of rendered function definition
  */
 string t_py_generator::function_signature_if(t_function* tfunction,
-                                           string prefix) {
-  // TODO(mcslee): Nitpicky, no ',' if argument_list is empty
-  string signature = prefix + tfunction->get_name() + "(";
+                                             string prefix) {
+  string argument_list_result = argument_list(tfunction->get_arglist());
   if (!gen_twisted_) {
-    signature += "self, ";
+    if (!argument_list_result.empty()) {
+      argument_list_result = "self, " + argument_list_result;
+    } else {
+      argument_list_result = "self";
+    }
   }
-  signature += argument_list(tfunction->get_arglist()) + ")";
-  return signature;
+  return prefix + tfunction->get_name() + "(" + argument_list_result + ")";
 }
 
 
@@ -2524,4 +2530,3 @@ THRIFT_REGISTER_GENERATOR(py, "Python",
 "    dynexc=CLS       Derive generated exceptions from CLS instead of TExceptionBase.\n" \
 "    dynimport='from foo.bar import CLS'\n" \
 "                     Add an import line to generated code to find the dynbase class.\n")
-
