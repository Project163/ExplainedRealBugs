diff --git a/compiler/cpp/src/thrift/generate/t_netstd_generator.cc b/compiler/cpp/src/thrift/generate/t_netstd_generator.cc
index e9c579c9f..fb8d65c52 100644
--- a/compiler/cpp/src/thrift/generate/t_netstd_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_netstd_generator.cc
@@ -1956,6 +1956,10 @@ void t_netstd_generator::generate_service_helpers(ostream& out, t_service* tserv
     vector<t_function*> functions = tservice->get_functions();
     vector<t_function*>::iterator f_iter;
 
+    out << indent() << "public class InternalStructs" << endl;
+    out << indent() << "{" << endl;
+    indent_up();
+
     for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter)
     {
         t_struct* ts = (*f_iter)->get_arglist();
@@ -1963,6 +1967,9 @@ void t_netstd_generator::generate_service_helpers(ostream& out, t_service* tserv
         generate_netstd_struct_definition(out, ts, false, true);
         generate_function_helpers(out, *f_iter);
     }
+
+    indent_down();
+    out << indent() << "}" << endl << endl;
 }
 
 void t_netstd_generator::generate_service_client(ostream& out, t_service* tservice)
@@ -2013,7 +2020,7 @@ void t_netstd_generator::generate_service_client(ostream& out, t_service* tservi
             << "\", TMessageType." << ((*functions_iterator)->is_oneway() ? "Oneway" : "Call") 
             << ", SeqId), cancellationToken);" << endl
             << indent() << endl
-            << indent() << "var args = new " << argsname << "() {" << endl;
+            << indent() << "var args = new InternalStructs." << argsname << "() {" << endl;
         indent_up();
 
         t_struct* arg_struct = (*functions_iterator)->get_arglist();
@@ -2057,7 +2064,7 @@ void t_netstd_generator::generate_service_client(ostream& out, t_service* tservi
 
             out << indent() << "}" << endl
                 << endl
-                << indent() << "var result = new " << resultname << "();" << endl
+                << indent() << "var result = new InternalStructs." << resultname << "();" << endl
                 << indent() << "await result.ReadAsync(InputProtocol, cancellationToken);" << endl
                 << indent() << "await InputProtocol.ReadMessageEndAsync(cancellationToken);" << endl;
 
@@ -2269,13 +2276,13 @@ void t_netstd_generator::generate_process_function_async(ostream& out, t_service
     string argsname = tfunction->get_name() + "Args";
     string resultname = tfunction->get_name() + "Result";
 
-    out << indent() << "var args = new " << argsname << "();" << endl
+    out << indent() << "var args = new InternalStructs." << argsname << "();" << endl
         << indent() << "await args.ReadAsync(iprot, cancellationToken);" << endl
         << indent() << "await iprot.ReadMessageEndAsync(cancellationToken);" << endl;
 
     if (!tfunction->is_oneway())
     {
-        out << indent() << "var result = new " << resultname << "();" << endl;
+        out << indent() << "var result = new InternalStructs." << resultname << "();" << endl;
     }
 
     out << indent() << "try" << endl
@@ -3007,6 +3014,7 @@ void t_netstd_generator::prepare_member_name_mapping(void* scope, const vector<t
 
     // prevent name conflicts with struct (CS0542 error)
     used_member_names.insert(structname);
+    used_member_names.insert("Isset");
 
     // prevent name conflicts with known methods (THRIFT-2942)
     used_member_names.insert("Read");
@@ -3103,12 +3111,12 @@ string t_netstd_generator::type_name(t_type* ttype)
     string the_name = check_and_correct_struct_name(normalize_name(ttype->get_name()));
 
     t_program* program = ttype->get_program();
-    if (program != nullptr && program != program_)
+    if (program != nullptr)// && program != program_)
     {
-        string ns = program->get_namespace("netstd");
+        string ns =  program->get_namespace("netstd");
         if (!ns.empty())
         {
-            return ns + "." + the_name;
+            return "global::" + ns + "." + the_name;
         }
     }
 
@@ -3417,11 +3425,11 @@ string t_netstd_generator::get_enum_class_name(t_type* type)
 {
     string package = "";
     t_program* program = type->get_program();
-    if (program != nullptr && program != program_)
+    if (program != nullptr) // && program != program_)
     {
         package = program->get_namespace("netstd") + ".";
     }
-    return package + type->get_name();
+    return "global::" + package + type->get_name();
 }
 
 THRIFT_REGISTER_GENERATOR(
diff --git a/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Impl/Thrift5253/MyService.cs b/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Impl/Thrift5253/MyService.cs
new file mode 100644
index 000000000..342dd4ad0
--- /dev/null
+++ b/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Impl/Thrift5253/MyService.cs
@@ -0,0 +1,59 @@
+// Licensed to the Apache Software Foundation(ASF) under one
+// or more contributor license agreements.See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License. You may obtain a copy of the License at
+// 
+//     http://www.apache.org/licenses/LICENSE-2.0
+// 
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied. See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+using Thrift5253;
+
+namespace Thrift.PublicInterfaces.Compile.Tests.Impl.Thrift5253
+{
+    class MyServiceImpl : MyService.IAsync
+    {
+        public Task<AsyncProcessor> AsyncProcessorAsync(AsyncProcessor input, CancellationToken cancellationToken = default)
+        {
+            return Task.FromResult(new AsyncProcessor() { Foo = input.Foo });
+        }
+
+        public Task<BrokenResult> BrokenAsync(BrokenArgs input, CancellationToken cancellationToken = default)
+        {
+            return Task.FromResult(new BrokenResult() { Foo = input.Foo });
+        }
+
+        public Task<Client> ClientAsync(Client input, CancellationToken cancellationToken = default)
+        {
+            return Task.FromResult(new Client() { Foo = input.Foo });
+        }
+
+        public Task<IAsync> IAsyncAsync(IAsync input, CancellationToken cancellationToken = default)
+        {
+            return Task.FromResult(new IAsync() { Foo = input.Foo });
+        }
+
+        public Task<InternalStructs> InternalStructsAsync(InternalStructs input, CancellationToken cancellationToken = default)
+        {
+            return Task.FromResult(new InternalStructs() { Foo = input.Foo });
+        }
+
+        public Task<WorksRslt> WorksAsync(WorksArrrgs input, CancellationToken cancellationToken = default)
+        {
+            return Task.FromResult(new WorksRslt() { Foo = input.Foo });
+        }
+    }
+}
diff --git a/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift.PublicInterfaces.Compile.Tests.csproj b/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift.PublicInterfaces.Compile.Tests.csproj
index 1938ddc94..95c85afc0 100644
--- a/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift.PublicInterfaces.Compile.Tests.csproj
+++ b/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift.PublicInterfaces.Compile.Tests.csproj
@@ -52,6 +52,9 @@
     <Exec Condition="Exists('$(PathToThrift)')" Command="$(PathToThrift) -gen netstd:wcf,union,serial -r ./../../../../contrib/fb303/if/fb303.thrift" />
     <Exec Condition="Exists('thrift')" Command="thrift -gen netstd:wcf,union,serial -r ./../../../../contrib/fb303/if/fb303.thrift" />
     <Exec Condition="Exists('$(ProjectDir)/../../../../compiler/cpp/thrift')" Command="$(ProjectDir)/../../../../compiler/cpp/thrift -gen netstd:wcf,union,serial -r ./../../../../contrib/fb303/if/fb303.thrift" />
+    <Exec Condition="Exists('$(PathToThrift)')" Command="$(PathToThrift) -gen netstd:wcf,union,serial -r ./Thrift5253.thrift" />
+    <Exec Condition="Exists('thrift')" Command="thrift -gen netstd:wcf,union,serial -r ./Thrift5253.thrift" />
+    <Exec Condition="Exists('$(ProjectDir)/../../../../compiler/cpp/thrift')" Command="$(ProjectDir)/../../../../compiler/cpp/thrift -gen netstd:wcf,union,serial -r ./Thrift5253.thrift" />
   </Target>
 
 </Project>
diff --git a/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift5253.thrift b/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift5253.thrift
new file mode 100644
index 000000000..bf77302de
--- /dev/null
+++ b/lib/netstd/Tests/Thrift.PublicInterfaces.Compile.Tests/Thrift5253.thrift
@@ -0,0 +1,45 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+// Testcase for THRIFT-5253 using Result in result name generates wrong IAsync interface
+
+namespace * Thrift5253
+
+
+// this works
+struct WorksArrrgs { 1: i32 foo }
+struct WorksRslt   { 1: i32 foo }
+
+// this does not
+struct BrokenResult{ 1: i32 foo }
+struct BrokenArgs  { 1: i32 foo }
+
+struct InternalStructs { 1: optional i32 foo }
+struct AsyncProcessor  { 1: optional i32 foo }
+struct Client          { 1: optional i32 foo }
+struct IAsync          { 1: optional i32 foo }
+
+
+service MyService{
+    BrokenResult Broken( 1 : BrokenArgs  foo)
+    WorksRslt     Works( 1 : WorksArrrgs foo)
+
+	InternalStructs InternalStructs( 1: InternalStructs foo)
+	AsyncProcessor  AsyncProcessor ( 1: AsyncProcessor  foo)
+	Client          Client         ( 1: Client  foo)
+	IAsync          IAsync         ( 1: IAsync  foo)
+}
+
