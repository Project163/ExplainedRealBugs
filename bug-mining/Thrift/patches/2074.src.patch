diff --git a/lib/d/src/thrift/async/libevent.d b/lib/d/src/thrift/async/libevent.d
index 812e4a765..04e0e71ba 100644
--- a/lib/d/src/thrift/async/libevent.d
+++ b/lib/d/src/thrift/async/libevent.d
@@ -62,7 +62,7 @@ class TLibeventAsyncManager : TAsyncSocketManager {
     controlReceiveSocket_.blocking = false;
 
     // Register an event for receiving control messages.
-    controlReceiveEvent_ = event_new(eventBase_, controlReceiveSocket_.handle,
+    controlReceiveEvent_ = event_new(eventBase_, cast(evutil_socket_t)controlReceiveSocket_.handle,
       EV_READ | EV_PERSIST | EV_ET, assumeNothrow(&controlMsgReceiveCallback),
       cast(void*)this);
     event_add(controlReceiveEvent_, null);
@@ -188,7 +188,7 @@ private:
   void addOneshotListenerImpl(Socket socket, TAsyncEventType eventType,
      const(timeval)* timeout, TSocketEventListener listener
   ) {
-    registerOneshotEvent(socket.handle, libeventEventType(eventType),
+    registerOneshotEvent(cast(evutil_socket_t)socket.handle, libeventEventType(eventType),
       assumeNothrow(&socketCallback), timeout, listener);
   }
 
diff --git a/lib/d/src/thrift/async/socket.d b/lib/d/src/thrift/async/socket.d
index a08f51db0..352a8224e 100644
--- a/lib/d/src/thrift/async/socket.d
+++ b/lib/d/src/thrift/async/socket.d
@@ -18,7 +18,6 @@
  */
 module thrift.async.socket;
 
-import core.stdc.errno: ECONNRESET;
 import core.thread : Fiber;
 import core.time : dur, Duration;
 import std.array : empty;
@@ -33,11 +32,15 @@ import thrift.internal.endian;
 import thrift.internal.socket;
 
 version (Windows) {
-  import std.c.windows.winsock : connect;
+  import core.sys.windows.winsock2 : connect;
 } else version (Posix) {
   import core.sys.posix.sys.socket : connect;
 } else static assert(0, "Don't know connect on this platform.");
 
+version (Win32) {
+  import core.stdc.config : __c_long;
+}
+
 /**
  * Non-blocking socket implementation of the TTransport interface.
  *
@@ -148,7 +151,11 @@ class TAsyncSocket : TSocketBase, TAsyncTransport {
           return;
         }
 
-        int errorCode = void;
+        version (Win32) {
+          __c_long errorCode = void;
+        } else {
+          int errorCode = void;
+        }
         socket_.getOption(SocketOptionLevel.SOCKET, cast(SocketOption)SO_ERROR,
           errorCode);
 
@@ -344,8 +351,8 @@ private {
     enum SO_ERROR = 0x1007;
   } else version (FreeBSD) {
     enum SO_ERROR = 0x1007;
-  } else version (Win32) {
-    import std.c.windows.winsock : SO_ERROR;
+  } else version (Windows) {
+    import core.sys.windows.winsock2 : SO_ERROR;
   } else static assert(false, "Don't know SO_ERROR on this platform.");
 
   // This hack forces a delegate literal to be scoped, even if it is passed to
diff --git a/lib/d/src/thrift/codegen/async_client_pool.d b/lib/d/src/thrift/codegen/async_client_pool.d
index 26cb975a3..b51cd16a9 100644
--- a/lib/d/src/thrift/codegen/async_client_pool.d
+++ b/lib/d/src/thrift/codegen/async_client_pool.d
@@ -95,7 +95,7 @@ interface TAsyncClientPoolBase(Interface) if (isService!Interface) :
 }
 
 immutable bool delegate(Exception) defaultRpcFaultFilter;
-static this() {
+shared static this() {
   defaultRpcFaultFilter = (Exception e) {
     import thrift.protocol.base;
     import thrift.transport.base;
diff --git a/lib/d/src/thrift/internal/socket.d b/lib/d/src/thrift/internal/socket.d
index 6ca0a970e..757fafab3 100644
--- a/lib/d/src/thrift/internal/socket.d
+++ b/lib/d/src/thrift/internal/socket.d
@@ -34,8 +34,8 @@ version (FreeBSD) {
   enum connresetOnPeerShutdown = false;
 }
 
-version (Win32) {
-  import std.c.windows.winsock : WSAGetLastError, WSAEINTR, WSAEWOULDBLOCK;
+version (Windows) {
+  import core.sys.windows.winsock2 : WSAGetLastError, WSAEINTR, WSAEWOULDBLOCK;
   import std.windows.syserror : sysErrorString;
 
   // These are unfortunately not defined in std.c.windows.winsock, see
@@ -60,7 +60,7 @@ version (Win32) {
  * isSocetCloseErrno(errno): returns true if errno indicates that the socket
  *   is logically in closed state now.
  */
-version (Win32) {
+version (Windows) {
   alias WSAGetLastError getSocketErrno;
   enum CONNECT_INPROGRESS_ERRNO = WSAEWOULDBLOCK;
   enum INTERRUPTED_ERRNO = WSAEINTR;
@@ -88,7 +88,7 @@ version (Win32) {
 }
 
 string socketErrnoString(uint errno) {
-  version (Win32) {
+  version (Windows) {
     return sysErrorString(errno);
   } else {
     return to!string(strerror(errno));
diff --git a/lib/d/src/thrift/server/nonblocking.d b/lib/d/src/thrift/server/nonblocking.d
index 5860c0c42..f0afc1f92 100644
--- a/lib/d/src/thrift/server/nonblocking.d
+++ b/lib/d/src/thrift/server/nonblocking.d
@@ -623,7 +623,7 @@ private {
             to!string(event_get_version()), to!string(event_base_get_method(eventBase_)));
 
           // Register the event for the listening socket.
-          listenEvent_ = event_new(eventBase_, listenSocket_.handle,
+          listenEvent_ = event_new(eventBase_, cast(evutil_socket_t)listenSocket_.handle,
             EV_READ | EV_PERSIST | EV_ET,
             assumeNothrow(&TNonblockingServer.acceptConnectionsCallback),
             cast(void*)server_);
@@ -638,7 +638,7 @@ private {
         completionReceiveSocket_ = pair[1];
 
         // Register an event for the task completion notification socket.
-        completionEvent_ = event_new(eventBase_, completionReceiveSocket_.handle,
+        completionEvent_ = event_new(eventBase_, cast(evutil_socket_t)completionReceiveSocket_.handle,
           EV_READ | EV_PERSIST | EV_ET, assumeNothrow(&completedCallback),
           cast(void*)this);
 
@@ -1212,10 +1212,10 @@ private {
 
       if (!event_) {
         // If the event was not already allocated, do it now.
-        event_ = event_new(loop_.eventBase_, socket_.socketHandle,
+        event_ = event_new(loop_.eventBase_, cast(evutil_socket_t)socket_.socketHandle,
           eventFlags_, assumeNothrow(&workSocketCallback), cast(void*)this);
       } else {
-        event_assign(event_, loop_.eventBase_, socket_.socketHandle,
+        event_assign(event_, loop_.eventBase_, cast(evutil_socket_t)socket_.socketHandle,
           eventFlags_, assumeNothrow(&workSocketCallback), cast(void*)this);
       }
 
diff --git a/lib/d/src/thrift/transport/socket.d b/lib/d/src/thrift/transport/socket.d
index fcb38da36..b257fe955 100644
--- a/lib/d/src/thrift/transport/socket.d
+++ b/lib/d/src/thrift/transport/socket.d
@@ -18,7 +18,6 @@
  */
 module thrift.transport.socket;
 
-import core.stdc.errno: ECONNRESET;
 import core.thread : Thread;
 import core.time : dur, Duration;
 import std.array : empty;
@@ -29,6 +28,13 @@ import thrift.base;
 import thrift.transport.base;
 import thrift.internal.socket;
 
+version (Windows) {
+  import core.sys.windows.winsock2 : WSAECONNRESET;
+  enum ECONNRESET = WSAECONNRESET;
+} else version (Posix) {
+  import core.stdc.errno : ECONNRESET;
+} else static assert(0, "Don't know ECONNRESET on this platform.");
+
 /**
  * Common parts of a socket TTransport implementation, regardless of how the
  * actual I/O is performed (sync/async).
diff --git a/lib/d/src/thrift/transport/ssl.d b/lib/d/src/thrift/transport/ssl.d
index f8ce40eb7..5bdacbf1f 100644
--- a/lib/d/src/thrift/transport/ssl.d
+++ b/lib/d/src/thrift/transport/ssl.d
@@ -213,7 +213,7 @@ private:
     if (ssl_ !is null) return;
     ssl_ = context_.createSSL();
 
-    SSL_set_fd(ssl_, socketHandle);
+    SSL_set_fd(ssl_, cast(int)socketHandle);
     int rc;
     if (serverSide_) {
       rc = SSL_accept(ssl_);
