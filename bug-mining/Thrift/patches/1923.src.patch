diff --git a/CHANGES b/CHANGES
index 7025683fd..9533ad08f 100644
--- a/CHANGES
+++ b/CHANGES
@@ -5,6 +5,7 @@ Breaking Changes since 0.11.0 [for 0.12.0]:
     * [THRIFT-4448] - Support for golang 1.6 and earlier has been dropped.
     * [THRIFT-4474] - PHP now uses the PSR-4 loader by default instead of class maps.
     * [THRIFT-4532] - method signatures changed in the compiler's t_oop_generator.
+    * [THRIFT-4648] - The C (GLib) compiler's handling of namespaces has been improved.
 
 
 Thrift 0.11.0
diff --git a/compiler/cpp/src/thrift/generate/t_c_glib_generator.cc b/compiler/cpp/src/thrift/generate/t_c_glib_generator.cc
index b1e80421d..be3bad161 100644
--- a/compiler/cpp/src/thrift/generate/t_c_glib_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_c_glib_generator.cc
@@ -250,11 +250,21 @@ void t_c_glib_generator::init_generator() {
 
   /* include other thrift includes */
   const vector<t_program*>& includes = program_->get_includes();
-  for (size_t i = 0; i < includes.size(); ++i) {
-    f_types_ << "/* other thrift includes */" << endl << "#include \"" << this->nspace_lc
-             << initial_caps_to_underscores(includes[i]->get_name()) << "_types.h\"" << endl;
+  if (!includes.empty()) {
+    f_types_ << "/* other thrift includes */" << endl;
+
+    for (vector<t_program*>::const_iterator iter = includes.begin();
+         iter != includes.end();
+         ++iter) {
+      const std::string& include_nspace = (*iter)->get_namespace("c_glib");
+      std::string include_nspace_prefix =
+        include_nspace.empty() ? "" : initial_caps_to_underscores(include_nspace) + "_";
+
+      f_types_ << "#include \"" << include_nspace_prefix
+               << initial_caps_to_underscores((*iter)->get_name()) << "_types.h\"" << endl;
+    }
+    f_types_ << endl;
   }
-  f_types_ << endl;
 
   /* include custom headers */
   const vector<string>& c_includes = program_->get_c_includes();
@@ -602,7 +612,8 @@ string t_c_glib_generator::type_name(t_type* ttype, bool in_typedef, bool is_con
   }
 
   // check for a namespace
-  string pname = this->nspace + ttype->get_name();
+  t_program* tprogram = ttype->get_program();
+  string pname = (tprogram ? tprogram->get_namespace("c_glib") : "") + ttype->get_name();
 
   if (is_complex_type(ttype)) {
     pname += " *";
@@ -1831,8 +1842,10 @@ void t_c_glib_generator::generate_service_handler(t_service* tservice) {
   string service_name_lc = to_lower_case(initial_caps_to_underscores(service_name_));
   string service_name_uc = to_upper_case(service_name_lc);
 
-  string class_name = this->nspace + service_name_ + "Handler";
-  string class_name_lc = to_lower_case(initial_caps_to_underscores(class_name));
+  string service_handler_name = service_name_ + "Handler";
+
+  string class_name = this->nspace + service_handler_name;
+  string class_name_lc = this->nspace_lc + initial_caps_to_underscores(service_handler_name);
   string class_name_uc = to_upper_case(class_name_lc);
 
   string parent_class_name;
@@ -2051,8 +2064,10 @@ void t_c_glib_generator::generate_service_processor(t_service* tservice) {
   string service_name_lc = to_lower_case(initial_caps_to_underscores(service_name_));
   string service_name_uc = to_upper_case(service_name_lc);
 
-  string class_name = this->nspace + service_name_ + "Processor";
-  string class_name_lc = to_lower_case(initial_caps_to_underscores(class_name));
+  string service_processor_name = service_name_ + "Processor";
+
+  string class_name = this->nspace + service_processor_name;
+  string class_name_lc = this->nspace_lc + initial_caps_to_underscores(service_processor_name);
   string class_name_uc = to_upper_case(class_name_lc);
 
   string parent_class_name;
@@ -2784,7 +2799,7 @@ void t_c_glib_generator::generate_object(t_struct* tstruct) {
   string name_uc = to_upper_case(name_u);
 
   string class_name = this->nspace + name;
-  string class_name_lc = to_lower_case(initial_caps_to_underscores(class_name));
+  string class_name_lc = this->nspace_lc + initial_caps_to_underscores(name);
   string class_name_uc = to_upper_case(class_name_lc);
 
   string function_name;
@@ -3124,7 +3139,8 @@ void t_c_glib_generator::generate_object(t_struct* tstruct) {
                         << "THRIFT_UNUSED_VAR (object);" << endl;
 
   for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
-    t_type* t = get_true_type((*m_iter)->get_type());
+    t_type* member_type = (*m_iter)->get_type();
+    t_type* t = get_true_type(member_type);
     if (t->is_base_type()) {
       string dval = " = ";
       if (t->is_enum()) {
@@ -3139,10 +3155,14 @@ void t_c_glib_generator::generate_object(t_struct* tstruct) {
       indent(f_types_impl_) << "object->" << (*m_iter)->get_name() << dval << ";" << endl;
     } else if (t->is_struct()) {
       string name = (*m_iter)->get_name();
-      string type_name_uc
-          = to_upper_case(initial_caps_to_underscores((*m_iter)->get_type()->get_name()));
-      indent(f_types_impl_) << "object->" << name << " = g_object_new (" << this->nspace_uc
-                            << "TYPE_" << type_name_uc << ", NULL);" << endl;
+      t_program* type_program = member_type->get_program();
+      string type_nspace = type_program ? type_program->get_namespace("c_glib") : "";
+      string type_nspace_prefix =
+        type_nspace.empty() ? "" : initial_caps_to_underscores(type_nspace) + "_";
+      string type_name_uc = to_upper_case(initial_caps_to_underscores(member_type->get_name()));
+      indent(f_types_impl_) << "object->" << name << " = g_object_new ("
+                            << to_upper_case(type_nspace_prefix) << "TYPE_" << type_name_uc
+                            << ", NULL);" << endl;
     } else if (t->is_xception()) {
       string name = (*m_iter)->get_name();
       indent(f_types_impl_) << "object->" << name << " = NULL;" << endl;
@@ -3424,7 +3444,12 @@ void t_c_glib_generator::generate_object(t_struct* tstruct) {
                       << "G_PARAM_READWRITE));" << endl;
         indent_down();
       } else if (member_type->is_struct() || member_type->is_xception()) {
-        string param_type = this->nspace_uc + "TYPE_"
+        t_program* type_program = member_type->get_program();
+        string type_nspace = type_program ? type_program->get_namespace("c_glib") : "";
+        string type_nspace_prefix =
+          type_nspace.empty() ? "" : initial_caps_to_underscores(type_nspace) + "_";
+
+        string param_type = to_upper_case(type_nspace_prefix) + "TYPE_"
                             + to_upper_case(initial_caps_to_underscores(member_type->get_name()));
 
         args_indent += string(20, ' ');
diff --git a/lib/c_glib/README.md b/lib/c_glib/README.md
index fd70d089c..dd84f3d35 100644
--- a/lib/c_glib/README.md
+++ b/lib/c_glib/README.md
@@ -32,3 +32,18 @@ Dependencies
 GLib
 http://www.gtk.org/
 
+Breaking Changes
+================
+
+0.12.0
+------
+
+The compiler's handling of namespaces when generating the name of types,
+functions and header files has been improved. This means code written to use
+classes generated by previous versions of the compiler may need to be updated to
+reflect the proper convention for class names, which is
+
+- A lowercase, [snake-case](https://en.wikipedia.org/wiki/Snake_case)
+  representation of the class' namespace, followed by
+- An underscore and
+- A lowercase, snake-case representation of the class' name.
