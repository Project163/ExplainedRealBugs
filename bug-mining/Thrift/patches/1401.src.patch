diff --git a/lib/rb/ext/struct.c b/lib/rb/ext/struct.c
index f500d0336..e3aa855ed 100644
--- a/lib/rb/ext/struct.c
+++ b/lib/rb/ext/struct.c
@@ -290,7 +290,7 @@ static void write_container(int ttype, VALUE field_info, VALUE value, VALUE prot
 
     if (TYPE(value) == T_ARRAY) {
       items = value;
-    } else {        
+    } else {
       if (rb_cSet == CLASS_OF(value)) {
         items = rb_funcall(value, entries_method_id, 0);
       } else {
@@ -670,6 +670,10 @@ static VALUE rb_thrift_union_write(VALUE self, VALUE protocol) {
 
   VALUE field_info = rb_hash_aref(struct_fields, field_id);
 
+  if(NIL_P(field_info)) {
+    rb_raise(rb_eRuntimeError, "set_field is not valid for this union!");
+  }
+
   VALUE ttype_value = rb_hash_aref(field_info, type_sym);
   int ttype = FIX2INT(ttype_value);
 
diff --git a/lib/rb/spec/union_spec.rb b/lib/rb/spec/union_spec.rb
index a4270906d..6ad31940c 100644
--- a/lib/rb/spec/union_spec.rb
+++ b/lib/rb/spec/union_spec.rb
@@ -48,6 +48,13 @@ describe 'Union' do
       lambda { union.some_characters }.should raise_error(RuntimeError, "some_characters is not union's set field.")
     end
 
+    it "should raise for wrong set field when hash initialized and type checking is off" do
+      Thrift.type_checking = false
+      union = SpecNamespace::My_union.new({incorrect_field: :incorrect})
+      example = lambda { Thrift::Serializer.new.serialize(union) }
+      example.should raise_error(RuntimeError, "set_field is not valid for this union!")
+    end
+
     it "should not be equal to nil" do
       union = SpecNamespace::My_union.new
       union.should_not == nil
