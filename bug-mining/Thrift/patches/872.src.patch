diff --git a/lib/d/src/thrift/codegen/base.d b/lib/d/src/thrift/codegen/base.d
index 95e09ff65..a9150d75e 100644
--- a/lib/d/src/thrift/codegen/base.d
+++ b/lib/d/src/thrift/codegen/base.d
@@ -358,7 +358,7 @@ template BaseService(T) if (isDerivedService!T) {
 mixin template TStructHelpers(alias fieldMetaData = cast(TFieldMeta[])null) if (
   is(typeof(fieldMetaData) : TFieldMeta[])
 ) {
-  import std.algorithm : canFind;
+  import std.algorithm : any;
   import thrift.codegen.base;
   import thrift.internal.codegen : isNullable, MemberType, mergeFieldMeta,
     FieldNames;
@@ -459,7 +459,7 @@ mixin template TStructHelpers(alias fieldMetaData = cast(TFieldMeta[])null) if (
     return true;
   }
 
-  static if (canFind!`!a.defaultValue.empty`(mergeFieldMeta!(This, fieldMetaData))) {
+  static if (any!`!a.defaultValue.empty`(mergeFieldMeta!(This, fieldMetaData))) {
     static if (is(This _ == class)) {
       this() {
         mixin(thriftFieldInitCode!(mergeFieldMeta!(This, fieldMetaData))("this"));
@@ -500,10 +500,10 @@ string thriftFieldInitCode(alias fieldMeta)(string thisName) {
   return code;
 }
 
-version (unittest) {
+unittest {
   // Cannot make this nested in the unittest block due to a »no size yet for
   // forward reference« error.
-  struct Foo {
+  static struct Foo {
     string a;
     int b;
     int c;
@@ -514,8 +514,7 @@ version (unittest) {
       TFieldMeta("c", 3, TReq.REQUIRED, "4")
     ]);
   }
-}
-unittest {
+
   auto f = Foo();
 
   f.set!"b"(12345);
diff --git a/lib/d/src/thrift/internal/codegen.d b/lib/d/src/thrift/internal/codegen.d
index aae65bb98..85f9d1891 100644
--- a/lib/d/src/thrift/internal/codegen.d
+++ b/lib/d/src/thrift/internal/codegen.d
@@ -19,6 +19,7 @@
 
 module thrift.internal.codegen;
 
+import std.algorithm : canFind;
 import std.traits : InterfacesTuple, isSomeFunction, isSomeString;
 import std.typetuple : staticIndexOf, staticMap, NoDuplicates, TypeTuple;
 import thrift.codegen.base;
@@ -178,6 +179,7 @@ template isValueMember(T, string name) {
 template FieldNames(T, alias fieldMetaData = cast(TFieldMeta[])null) {
   alias StaticFilter!(
     All!(
+      doesNotReadMembers,
       PApply!(isValueMember, T),
       PApply!(notIgnored, T, PApplySkip, fieldMetaData)
     ),
@@ -185,6 +187,17 @@ template FieldNames(T, alias fieldMetaData = cast(TFieldMeta[])null) {
   ) FieldNames;
 }
 
+/*
+ * true if the passed member name is not a method generated by the
+ * TStructHelpers template that in its implementations queries the struct
+ * members.
+ *
+ * Kludge used internally to break a cycle caused a DMD forward reference
+ * regression, see THRIFT-2130.
+ */
+enum doesNotReadMembers(string name) = !["opEquals", "thriftOpEqualsImpl",
+  "toString", "thriftToStringImpl"].canFind(name);
+
 template derivedMembers(T) {
   alias TypeTuple!(__traits(derivedMembers, T)) derivedMembers;
 }
diff --git a/lib/d/src/thrift/util/hashset.d b/lib/d/src/thrift/util/hashset.d
index 5ef97f988..3fa466e39 100644
--- a/lib/d/src/thrift/util/hashset.d
+++ b/lib/d/src/thrift/util/hashset.d
@@ -23,6 +23,8 @@ import std.conv : to;
 import std.traits : isImplicitlyConvertible, ParameterTypeTuple;
 import std.range : ElementType, isInputRange;
 
+struct Void {}
+
 /**
  * A quickly hacked together hash set implementation backed by built-in
  * associative arrays to have something to compile Thrift's set<> to until
@@ -41,7 +43,7 @@ final class HashSet(E) {
 
   ///
   void insert(Stuff)(Stuff stuff) if (isImplicitlyConvertible!(Stuff, E)) {
-    aa_[*(cast(immutable(E)*)&stuff)] = [];
+    aa_[*(cast(immutable(E)*)&stuff)] = Void.init;
   }
 
   ///
@@ -49,7 +51,7 @@ final class HashSet(E) {
     isInputRange!Stuff && isImplicitlyConvertible!(ElementType!Stuff, E)
   ) {
     foreach (e; stuff) {
-      aa_[*(cast(immutable(E)*)&e)] = [];
+      aa_[*(cast(immutable(E)*)&e)] = Void.init;
     }
   }
 
@@ -115,7 +117,6 @@ final class HashSet(E) {
   }
 
 private:
-  alias void[0] Void;
   Void[immutable(E)] aa_;
 }
 
