<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 08:24:39 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[THRIFT-3768] TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec</title>
                <link>https://issues.apache.org/jira/browse/THRIFT-3768</link>
                <project id="12310800" key="THRIFT">Thrift</project>
                    <description>&lt;p&gt;Here&apos;s a sequence that shows the race:&lt;/p&gt;

&lt;p&gt;Thread-1 (Users of TThreadedServer): Calls TThreadedServer::stop(), which calls interruptChildren and initiates the tearing down of client connections.&lt;/p&gt;

&lt;p&gt;Thread-2: In TServerFramework::serve(), broke out of accept, and now blocks in TThreadedServer::serve() waiting to drain all the clients.&lt;/p&gt;

&lt;p&gt;Thread-3 (The connected client thread created by TThreadedServer): In disposeConnectedClient, running because the server is shutting down and the shared_ptr specified this function to be the cleanup function for the client. This thread just returned from onClientDisconnected and now context switches.&lt;/p&gt;

&lt;p&gt;Thread-2: TThreadedServer::serve() is notified that all of the clients have disconnected and completes.&lt;/p&gt;

&lt;p&gt;Thread-1: Joins on Thread-2 and destroys the server object because it is done.&lt;/p&gt;

&lt;p&gt;Thread-3: Finally gets a chance to run, but now encounters undefined behavior because it is still executing a member function of an object that has been destroyed.&lt;/p&gt;

&lt;p&gt;You can force this race in action if you put sleep(1) before onClientDisconnected() in disposeConnectedClient&lt;/p&gt;</description>
                <environment></environment>
        <key id="12955010">THRIFT-3768</key>
            <summary>TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jking3">James E. King III</assignee>
                                    <reporter username="tewang">Ted Wang</reporter>
                        <labels>
                    </labels>
                <created>Thu, 31 Mar 2016 16:35:49 +0000</created>
                <updated>Fri, 12 Aug 2016 01:29:57 +0000</updated>
                            <resolved>Fri, 8 Jul 2016 20:12:49 +0000</resolved>
                                    <version>0.9.3</version>
                                    <fixVersion>0.10.0</fixVersion>
                                    <component>C++ - Library</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="15220177" author="tewang" created="Thu, 31 Mar 2016 16:42:56 +0000"  >&lt;p&gt;I would be happy to provide a patch to fix this race, but I am not sure how to go about fixing this. It seems that we should not be calling into a member function of the server as the cleanup method for TConnectedClient:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/thrift/blob/master/lib/cpp/src/thrift/server/TServerFramework.cpp#L164&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/blob/master/lib/cpp/src/thrift/server/TServerFramework.cpp#L164&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A couple of naive solution comes into mind, but I think they break existing servers or users:&lt;br/&gt;
1. Ensure that servers can only be held in a shared_ptr (not on the stack), and then we can extend the lifetime of the server to cleanup TConnectedClient (use a separate static function and std::shared_from_this). This breaks users.&lt;br/&gt;
2. Use a separate object to handle the callback so that onClientDisconnected isn&apos;t calling into a server&apos;s member function, but this breaks existing servers.&lt;/p&gt;</comment>
                            <comment id="15220595" author="ben.craig" created="Thu, 31 Mar 2016 20:12:45 +0000"  >&lt;p&gt;Not sure how this will get reflected in code, but I would argue that the correct solution is for serve() to not return until it has joined the threads owned by the server.  Connected clients notifying the server of death via callback is fine, but that&apos;s sort-of orthogonal to waiting for all owned threads to be done, particularly for the TThreadPoolServer.&lt;/p&gt;

&lt;p&gt;TThreadedServer::onClientConnected looks like it is leaking the thread, and relying on the &quot;detached by default&quot; policy to eventually clean up the thread.  I think that TThreadedServer should keep a vector of these threads around so that it can join on them as appropriate at the end of the serve() call.&lt;/p&gt;</comment>
                            <comment id="15220607" author="tewang" created="Thu, 31 Mar 2016 20:23:41 +0000"  >&lt;p&gt;I had considered that as well, which I think would make TThreadedServer act sort of like an unbounded TThreadPoolServer. However, I am not sure when threads would be removed from an internal vector that TThreadedServer is keeping around. It cannot be in onClientDisconnected (at least not for the thread that initiated this, for obvious reasons), and leaving it around to grow unbounded doesn&apos;t seem like a good idea.&lt;/p&gt;

&lt;p&gt;So maybe we need a &quot;live client&quot; list and a &quot;pending removal&quot; list? Maybe join with a timeout of 0 on the pending removal list during onClientConnected or onClientDisconnected?&lt;/p&gt;</comment>
                            <comment id="15220756" author="ben.craig" created="Thu, 31 Mar 2016 22:16:45 +0000"  >&lt;p&gt;You probably will need two vectors.  You can service the vectors (including the associated joins) in between accept calls.  That does suggest that the code will have a strange split between the server leaf classes and the server framework though.&lt;/p&gt;</comment>
                            <comment id="15220935" author="jking3" created="Fri, 1 Apr 2016 00:46:15 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tewang&quot; class=&quot;user-hover&quot; rel=&quot;tewang&quot;&gt;tewang&lt;/a&gt; Thanks for your detailed description of the issue and steps to reproduce it!  I did the refactoring on the server side in 0.9.3 with input from others, and would like to take a look at this one as well.&lt;/p&gt;</comment>
                            <comment id="15224357" author="tewang" created="Mon, 4 Apr 2016 15:44:47 +0000"  >&lt;p&gt;What do you think about &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ben.craig&quot; class=&quot;user-hover&quot; rel=&quot;ben.craig&quot;&gt;ben.craig&lt;/a&gt;&apos;s suggestion for using two vectors to keep track of the state of the created threads? I think the biggest contentious area would be when to service the vectors and how to expose a mechanism from the TServerFramework class for TThreadedServer to use.&lt;/p&gt;</comment>
                            <comment id="15224493" author="jking3" created="Mon, 4 Apr 2016 16:49:14 +0000"  >&lt;p&gt;Yuck.. TThreadedServer doesn&apos;t actually follow the interface requirements of TServerFramework.  The onClientConnected() method is documented to require the implementation to manage the lifetime of the client object.  TThreadedServer fires off a thread to run the client but does not guarantee the lifetime.  As a result we delete the client immediately in the middle of TServerFramework::serve() because it is the last reference to it. I guess there are not many (if any) implementations using TThreadedServer out there because this is a pretty serious defect in that implementation.&lt;/p&gt;

&lt;p&gt;I was going to first see about adding an assertion to verify that the implementation actually bumped the reference count on the smart pointer for safety.  I tried it, but it isn&apos;t valid because TSimpleServer meets the contract but doesn&apos;t store the client.&lt;/p&gt;

&lt;p&gt;I&apos;ll have to change TThreadedServer so that it passes the client into a routine that runs the client and maintains the lifetime of the client.  I&apos;d like to get rid of TThreadedServer however... perhaps we can deprecate it in 0.10.0?  Using a TThreadPoolServer is a better choice.&lt;/p&gt;</comment>
                            <comment id="15224760" author="jking3" created="Mon, 4 Apr 2016 18:34:10 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ben.craig&quot; class=&quot;user-hover&quot; rel=&quot;ben.craig&quot;&gt;ben.craig&lt;/a&gt; Ideally we would remove TThreadedServer and have implementations transition to TThreadPoolServer which provides the same functionality.  Given how fundamentally broken the TThreadedServer is provided in thrift-0.9.3 and the lack of feedback on the subject, I&apos;m implementing TThreadedServer as a subclass of TThreadPoolServer.&lt;/p&gt;</comment>
                            <comment id="15224861" author="tewang" created="Mon, 4 Apr 2016 19:21:27 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; The onClientConnected() method is documented to require the implementation to manage the lifetime of the client object&lt;/p&gt;

&lt;p&gt;I don&apos;t think the server leaf classes are responsible for managing the lifetime of the client object because &lt;br/&gt;
onClientDisconnected says that &quot;The implementation must not delete the pointer&quot;, and I take it to mean that TServerFramework is responsible for its lifetime. I take the documentation in onClientConnected to mean that the leaf classes must take care not to use the client after onClientDisconnected returns.&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt; I&apos;d like to get rid of TThreadedServer however... perhaps we can deprecate it in 0.10.0? Using a TThreadPoolServer is a better choice.&lt;/p&gt;

&lt;p&gt;I&apos;ll just say that TThreadedServer and TThreadPoolServer are very similar in that one is bounded and another is unbounded. TThreadedServer has a simpler implementation, but that simplification seems to be flaky in shutdown cases.&lt;/p&gt;

&lt;p&gt;By the way, in one of your earlier edits, I think you are running into this problem:&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3753&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/THRIFT-3753&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15225179" author="githubbot" created="Mon, 4 Apr 2016 22:22:29 +0000"  >&lt;p&gt;GitHub user jeking3 opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt; fix TThreadedServer refactoring issues with client lifetime guarantees&lt;/p&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/jeking3/thrift&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jeking3/thrift&lt;/a&gt; defect/&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #977&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 3f44af8a474591eb0879983efc35534e17a0b533&lt;br/&gt;
Author: Jim King &amp;lt;jim.king@simplivity.com&amp;gt;&lt;br/&gt;
Date:   2016-04-04T22:12:49Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt; fix TThreadedServer refactoring issues with client lifetime guarantees&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15225199" author="jking3" created="Mon, 4 Apr 2016 22:34:02 +0000"  >&lt;p&gt;The behavior of TThreadedServer is a little different now than before.  Previously it would scale threads up and down to meet demand.  I made it a subclass of TThreadPoolServer and it will scale up the number of threads to meet demand, up to the limit of concurrent connections imposed by the TServerFramework.  What it will not do however is reap those threads.  The ThreadManager::removeWorker() is not reliable as written and it was not possible to use it to reduce the thread count of the thread manager used by the thread pool when a client disconnects.  I will be opening a separate defect for that.&lt;/p&gt;</comment>
                            <comment id="15225415" author="githubbot" created="Tue, 5 Apr 2016 00:50:50 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977#discussion_r58472724&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977#discussion_r58472724&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -20,19 +20,26 @@&lt;br/&gt;
     #ifndef &lt;em&gt;THRIFT_SERVER_TTHREADEDSERVER_H&lt;/em&gt;&lt;br/&gt;
     #define &lt;em&gt;THRIFT_SERVER_TTHREADEDSERVER_H&lt;/em&gt; 1&lt;/p&gt;

&lt;p&gt;    -#include &amp;lt;thrift/concurrency/Monitor.h&amp;gt;&lt;br/&gt;
     #include &amp;lt;thrift/concurrency/PlatformThreadFactory.h&amp;gt;&lt;br/&gt;
     #include &amp;lt;thrift/concurrency/Thread.h&amp;gt;&lt;br/&gt;
    -#include &amp;lt;thrift/server/TServerFramework.h&amp;gt;&lt;br/&gt;
    +#include &amp;lt;thrift/server/TThreadPoolServer.h&amp;gt;&lt;/p&gt;

&lt;p&gt;     namespace apache {&lt;br/&gt;
     namespace thrift {&lt;br/&gt;
     namespace server {&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Manage clients using a thread pool.&lt;br/&gt;
    + * Manage clients using threads.  Once the refactoring for &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3083&quot; title=&quot;C++ Consolidate server processing loops in TSimpleServer, TThreadedServer, TThreadPoolServer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3083&quot;&gt;&lt;del&gt;THRIFT-3083&lt;/del&gt;&lt;/a&gt; took place it became&lt;br/&gt;
    + * obvious that the differences between the two threaded server types was becoming insignificant.&lt;br/&gt;
    + * Therefore to satisfy &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3096&quot; title=&quot;Consolidate TSimpleServer, TThreadedServer, TThreadPoolServer into one&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3096&quot;&gt;&lt;del&gt;THRIFT-3096&lt;/del&gt;&lt;/a&gt; and fix &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;, TThreadedServer is simply a wrapper&lt;br/&gt;
    + * around TThreadedPoolServer now.  If backwards compatibility was not a concern, it would have&lt;br/&gt;
    + * been removed.&lt;br/&gt;
    + *&lt;br/&gt;
    + * The default thread pool size is
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Unfinished comment.&lt;/p&gt;</comment>
                            <comment id="15225421" author="githubbot" created="Tue, 5 Apr 2016 00:55:05 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977#discussion_r58473050&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977#discussion_r58473050&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -20,19 +20,26 @@&lt;br/&gt;
     #ifndef &lt;em&gt;THRIFT_SERVER_TTHREADEDSERVER_H&lt;/em&gt;&lt;br/&gt;
     #define &lt;em&gt;THRIFT_SERVER_TTHREADEDSERVER_H&lt;/em&gt; 1&lt;/p&gt;

&lt;p&gt;    -#include &amp;lt;thrift/concurrency/Monitor.h&amp;gt;&lt;br/&gt;
     #include &amp;lt;thrift/concurrency/PlatformThreadFactory.h&amp;gt;&lt;br/&gt;
     #include &amp;lt;thrift/concurrency/Thread.h&amp;gt;&lt;br/&gt;
    -#include &amp;lt;thrift/server/TServerFramework.h&amp;gt;&lt;br/&gt;
    +#include &amp;lt;thrift/server/TThreadPoolServer.h&amp;gt;&lt;/p&gt;

&lt;p&gt;     namespace apache {&lt;br/&gt;
     namespace thrift {&lt;br/&gt;
     namespace server {&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Manage clients using a thread pool.&lt;br/&gt;
    + * Manage clients using threads.  Once the refactoring for &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3083&quot; title=&quot;C++ Consolidate server processing loops in TSimpleServer, TThreadedServer, TThreadPoolServer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3083&quot;&gt;&lt;del&gt;THRIFT-3083&lt;/del&gt;&lt;/a&gt; took place it became&lt;br/&gt;
    + * obvious that the differences between the two threaded server types was becoming insignificant.&lt;br/&gt;
    + * Therefore to satisfy &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3096&quot; title=&quot;Consolidate TSimpleServer, TThreadedServer, TThreadPoolServer into one&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3096&quot;&gt;&lt;del&gt;THRIFT-3096&lt;/del&gt;&lt;/a&gt; and fix &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;, TThreadedServer is simply a wrapper&lt;br/&gt;
    + * around TThreadedPoolServer now.  If backwards compatibility was not a concern, it would have&lt;br/&gt;
    + * been removed.&lt;br/&gt;
    + *&lt;br/&gt;
    + * The default thread pool size is&lt;br/&gt;
      */&lt;br/&gt;
    -class TThreadedServer : public TServerFramework {&lt;br/&gt;
    +&lt;br/&gt;
    +/* [&lt;span class=&quot;error&quot;&gt;&amp;#91;deprecated&amp;#93;&lt;/span&gt;] */&lt;br/&gt;
    +class TThreadedServer : public TThreadPoolServer {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I&apos;d suggest using composition and the thread manager internally rather than inheriting from TThreadPoolServer seeing that TThreadPoolServer exposes other methods that would defeat the original purpose of the TThreadedServer.&lt;/p&gt;</comment>
                            <comment id="15225426" author="githubbot" created="Tue, 5 Apr 2016 00:57:16 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977#discussion_r58473198&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977#discussion_r58473198&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -77,44 +83,29 @@ TThreadedServer::TThreadedServer(const shared_ptr&amp;lt;TProcessor&amp;gt;&amp;amp; processor,&lt;br/&gt;
                                      const shared_ptr&amp;lt;TProtocolFactory&amp;gt;&amp;amp; inputProtocolFactory,&lt;br/&gt;
                                      const shared_ptr&amp;lt;TProtocolFactory&amp;gt;&amp;amp; outputProtocolFactory,&lt;br/&gt;
                                      const shared_ptr&amp;lt;ThreadFactory&amp;gt;&amp;amp; threadFactory)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;: TServerFramework(processor,&lt;/li&gt;
	&lt;li&gt;serverTransport,&lt;/li&gt;
	&lt;li&gt;inputTransportFactory,&lt;/li&gt;
	&lt;li&gt;outputTransportFactory,&lt;/li&gt;
	&lt;li&gt;inputProtocolFactory,&lt;/li&gt;
	&lt;li&gt;outputProtocolFactory),&lt;/li&gt;
	&lt;li&gt;threadFactory_(threadFactory) {&lt;br/&gt;
    +  : TThreadPoolServer(processor,&lt;br/&gt;
    +                      serverTransport,&lt;br/&gt;
    +                      inputTransportFactory,&lt;br/&gt;
    +                      outputTransportFactory,&lt;br/&gt;
    +                      inputProtocolFactory,&lt;br/&gt;
    +                      outputProtocolFactory,&lt;br/&gt;
    +                      apache::thrift::concurrency::ThreadManager::newSimpleThreadManager(0, 0)) 
{
    +    threadManager_-&amp;gt;threadFactory(threadFactory);
    +    threadManager_-&amp;gt;start();
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;    -void TThreadedServer::serve() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TServerFramework::serve();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) {&lt;br/&gt;
    +  if (!threadManager_-&amp;gt;idleWorkerCount())
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I would personally like to see how the threads would be reaped before we go down this path, but that&apos;s mostly because I am unfamiliar with the thread manager. I&apos;ll defer to you and the maintainers on whether to do this without the accompanying thread manager change.&lt;/p&gt;</comment>
                            <comment id="15225570" author="githubbot" created="Tue, 5 Apr 2016 03:03:22 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977#discussion_r58481087&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977#discussion_r58481087&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -77,44 +83,29 @@ TThreadedServer::TThreadedServer(const shared_ptr&amp;lt;TProcessor&amp;gt;&amp;amp; processor,&lt;br/&gt;
                                      const shared_ptr&amp;lt;TProtocolFactory&amp;gt;&amp;amp; inputProtocolFactory,&lt;br/&gt;
                                      const shared_ptr&amp;lt;TProtocolFactory&amp;gt;&amp;amp; outputProtocolFactory,&lt;br/&gt;
                                      const shared_ptr&amp;lt;ThreadFactory&amp;gt;&amp;amp; threadFactory)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;: TServerFramework(processor,&lt;/li&gt;
	&lt;li&gt;serverTransport,&lt;/li&gt;
	&lt;li&gt;inputTransportFactory,&lt;/li&gt;
	&lt;li&gt;outputTransportFactory,&lt;/li&gt;
	&lt;li&gt;inputProtocolFactory,&lt;/li&gt;
	&lt;li&gt;outputProtocolFactory),&lt;/li&gt;
	&lt;li&gt;threadFactory_(threadFactory) {&lt;br/&gt;
    +  : TThreadPoolServer(processor,&lt;br/&gt;
    +                      serverTransport,&lt;br/&gt;
    +                      inputTransportFactory,&lt;br/&gt;
    +                      outputTransportFactory,&lt;br/&gt;
    +                      inputProtocolFactory,&lt;br/&gt;
    +                      outputProtocolFactory,&lt;br/&gt;
    +                      apache::thrift::concurrency::ThreadManager::newSimpleThreadManager(0, 0)) 
{
    +    threadManager_-&amp;gt;threadFactory(threadFactory);
    +    threadManager_-&amp;gt;start();
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;    -void TThreadedServer::serve() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TServerFramework::serve();&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) {&lt;br/&gt;
    +  if (!threadManager_-&amp;gt;idleWorkerCount())
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As submitted the number of threads will grow to the maximum number of concurrent connections and will not shrink.  Additional work is needed to allow ThreadManager::removeWorker() to do the right thing when many threads arrive at it at the same time.  In gdb I found that workerCount_ was 10 but workerMaxCount_ was 0; the stop behavior for ThreadManager calls removeWorker(workerCount_) and gets an exception, which eventually causes a core.  This is why, for this submission, I left it as stated.  &lt;/p&gt;</comment>
                            <comment id="15226689" author="ben.craig" created="Tue, 5 Apr 2016 17:15:45 +0000"  >&lt;p&gt;ThreadManager is a mess.  When the C++11 revolution comes, it will be the first against the wall.&lt;/p&gt;

&lt;p&gt;Making TThreadedServer turn into a TThreadPoolServer is a significant change in behavior that can impact correctness and security.  TThreadedServer was able to reap threads before the ServerFramework refactor.  TThreadedServer needs to be able to reap threads after the refactor too.&lt;/p&gt;</comment>
                            <comment id="15227413" author="jking3" created="Wed, 6 Apr 2016 00:12:57 +0000"  >&lt;p&gt;Fair enough.  It&apos;s completely broken in 0.9.3 as far as I can tell since it deletes the TConnectedClient immediately, I wanted to put something out there for discussion.&lt;/p&gt;

&lt;p&gt;The worker thread doesn&apos;t contain a reference to the client itself so it can&apos;t maintain the lifetime of itself, but...&lt;br/&gt;
That&apos;s a pretty interesting concept.  If I could feed the smart pointer into the thread routine by value it would take care of the original issue without the change I made.  &lt;br/&gt;
I&apos;ll take a look.&lt;/p&gt;</comment>
                            <comment id="15228201" author="jking3" created="Wed, 6 Apr 2016 12:58:46 +0000"  >&lt;p&gt;I have a much, much simpler fix for this that I am going to push.  Declining the previous.&lt;/p&gt;</comment>
                            <comment id="15228203" author="githubbot" created="Wed, 6 Apr 2016 12:59:22 +0000"  >&lt;p&gt;Github user jeking3 commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977#issuecomment-206358845&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977#issuecomment-206358845&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Declining this pull request - I have a far simpler one to submit.&lt;/p&gt;</comment>
                            <comment id="15228205" author="githubbot" created="Wed, 6 Apr 2016 12:59:23 +0000"  >&lt;p&gt;Github user jeking3 closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15228369" author="githubbot" created="Wed, 6 Apr 2016 14:40:04 +0000"  >&lt;p&gt;GitHub user jeking3 opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: ensure TThreadedServer guarantees the lifetime of the client&lt;/p&gt;

&lt;p&gt;    TThreadedServer now guarantees the lifetime of the TConnectedClient.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/jeking3/thrift&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jeking3/thrift&lt;/a&gt; defect/&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;-alternate&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #980&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 7132ec16086daf2b2808e3a91f78ecfbca6a5dab&lt;br/&gt;
Author: Jim King &amp;lt;jim.king@simplivity.com&amp;gt;&lt;br/&gt;
Date:   2016-04-05T16:17:51Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: ensure TThreadedServer guarantees the lifetime of the client&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15228370" author="jking3" created="Wed, 6 Apr 2016 14:40:56 +0000"  >&lt;p&gt;I decided to wrap the client object and put it into a map to solve this.  It isolates the fix to the TThreadedServer instead of coupling it to the TThreadPoolServer.&lt;/p&gt;</comment>
                            <comment id="15229593" author="githubbot" created="Thu, 7 Apr 2016 03:16:38 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r58814042&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r58814042&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -92,29 +97,42 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     void TThreadedServer::serve() {&lt;br/&gt;
       TServerFramework::serve();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +  // Ensure post-condition of no active clients&lt;br/&gt;
    +  Synchronized s(clientMonitor_);&lt;br/&gt;
    +  while (!clientMap_.empty()) 
{
    +    clientMonitor_.wait();
       }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) &lt;/p&gt;
{
    -  threadFactory_-&amp;gt;newThread(pClient)-&amp;gt;start();
    +  Synchronized sync(clientMonitor_);
    +  clientMap_.insert(ClientMap::value_type(pClient.get(), boost::make_shared&amp;lt;TConnectedClientTracker&amp;gt;(pClient)));
    +
    +  // We do not track the threads themselves
    +  ClientMap::const_iterator it = clientMap_.find(pClient.get());
    +  threadFactory_-&amp;gt;newThread(it-&amp;gt;second)-&amp;gt;start();
     }

&lt;p&gt;     void TThreadedServer::onClientDisconnected(TConnectedClient* pClient) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;THRIFT_UNUSED_VARIABLE(pClient);&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;if (getConcurrentClientCount() == 0) {&lt;/li&gt;
	&lt;li&gt;clientsMonitor_.notify();&lt;br/&gt;
    +  Synchronized sync(clientMonitor_);&lt;br/&gt;
    +  clientMap_.erase(pClient);&lt;br/&gt;
    +  if (clientMap_.empty()) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This doesn&apos;t fix the issue because as soon as you notify clientMonitor_, TThreadedServer::serve() will exit and clients are free to release TThreadedServer, but the thread that initiated onClientDisconnected is still in the middle of disposeConnectedClient, which it should not be executing any more because the object is already destroyed.&lt;/p&gt;

&lt;p&gt;    Try adding one second sleep after the delete in disposeConnectedClient and run the tests. I see the same segfault in TServerIntegrationTest. I am not sure we can get away with not joining the threads.&lt;/p&gt;</comment>
                            <comment id="15230063" author="githubbot" created="Thu, 7 Apr 2016 10:35:47 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r58851243&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r58851243&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -92,29 +97,42 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     void TThreadedServer::serve() {&lt;br/&gt;
       TServerFramework::serve();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +  // Ensure post-condition of no active clients&lt;br/&gt;
    +  Synchronized s(clientMonitor_);&lt;br/&gt;
    +  while (!clientMap_.empty()) 
{
    +    clientMonitor_.wait();
       }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) &lt;/p&gt;
{
    -  threadFactory_-&amp;gt;newThread(pClient)-&amp;gt;start();
    +  Synchronized sync(clientMonitor_);
    +  clientMap_.insert(ClientMap::value_type(pClient.get(), boost::make_shared&amp;lt;TConnectedClientTracker&amp;gt;(pClient)));
    +
    +  // We do not track the threads themselves
    +  ClientMap::const_iterator it = clientMap_.find(pClient.get());
    +  threadFactory_-&amp;gt;newThread(it-&amp;gt;second)-&amp;gt;start();
     }

&lt;p&gt;     void TThreadedServer::onClientDisconnected(TConnectedClient* pClient) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;THRIFT_UNUSED_VARIABLE(pClient);&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;if (getConcurrentClientCount() == 0) {&lt;/li&gt;
	&lt;li&gt;clientsMonitor_.notify();&lt;br/&gt;
    +  Synchronized sync(clientMonitor_);&lt;br/&gt;
    +  clientMap_.erase(pClient);&lt;br/&gt;
    +  if (clientMap_.empty()) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Understood.  I&apos;m working on that now.&lt;/p&gt;</comment>
                            <comment id="15230503" author="jking3" created="Thu, 7 Apr 2016 16:29:35 +0000"  >&lt;p&gt;To summarize, because there&apos;s a lot of information here:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;TThreadedServer does not follow the interface contract of TServerFramework - it does not guarantee the lifetime of the TConnectedClient.&lt;/li&gt;
	&lt;li&gt;TServerFramework may return from serve() before TThreadedServer&apos;s threads are done processing.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I am working on a fix for this.&lt;/p&gt;</comment>
                            <comment id="15231101" author="jking3" created="Thu, 7 Apr 2016 21:24:55 +0000"  >&lt;p&gt;I am looking back at the original pull request for the thread pool server based implementation, and taking into consideration the pull request commeent regarding composition vs. inheritance I have done that, and fixing up ThreadManager so removeWorker works when:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Multiple concurrent callers to removeWorker - currently broken.&lt;/li&gt;
	&lt;li&gt;Calling removeWorker while the thread manager is stopping - currently broken.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="15232274" author="jking3" created="Fri, 8 Apr 2016 14:45:47 +0000"  >&lt;p&gt;After spending some quality time with ThreadManager I&apos;m going to avoid it.  I don&apos;t know how well tested it is, and has some interesting behaviors.&lt;br/&gt;
I went back to the second solution that I submitted which didn&apos;t actually join the threads and added that logic as well as a new stress test for TServerIntegrationTest.&lt;br/&gt;
All of this requires the ability to join the threads.&lt;br/&gt;
I go into PosixThreadFactory and see the default is to use detached threads, and join is a no-op (it produces a log message however)!&lt;br/&gt;
This one sure is fun. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15232312" author="tewang" created="Fri, 8 Apr 2016 15:11:57 +0000"  >&lt;p&gt;This one is pretty complicated. Thanks for taking the time to go through this, James.&lt;/p&gt;</comment>
                            <comment id="15232318" author="jking3" created="Fri, 8 Apr 2016 15:17:00 +0000"  >&lt;p&gt;I just pushed an update to the last pull request that fixes the join issue and adds more testing.&lt;/p&gt;</comment>
                            <comment id="15233147" author="hudson" created="Fri, 8 Apr 2016 23:33:42 +0000"  >&lt;p&gt;FAILURE: Integrated in Thrift-precommit #402 (See &lt;a href=&quot;https://builds.apache.org/job/Thrift-precommit/402/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/Thrift-precommit/402/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: ensure TThreadedServer guarantees the lifetime of the (jim.king: &lt;a href=&quot;https://github.com/apache/thrift/commit/7132ec16086daf2b2808e3a91f78ecfbca6a5dab&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/commit/7132ec16086daf2b2808e3a91f78ecfbca6a5dab&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TServerFramework.cpp&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.h&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TServerFramework.h&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.cpp&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: properly join TThreadedServer threads, added a stress test (jim.king: &lt;a href=&quot;https://github.com/apache/thrift/commit/8627e5d391489aafbd8892d9d57296b0358e2015&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/commit/8627e5d391489aafbd8892d9d57296b0358e2015&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.cpp&lt;/li&gt;
	&lt;li&gt;lib/cpp/test/TServerIntegrationTest.cpp&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.h&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/concurrency/Thread.h&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: small maintainability change (jim.king: &lt;a href=&quot;https://github.com/apache/thrift/commit/e258a1ad1434edd04426caf0fb05b528d2b1503e&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/commit/e258a1ad1434edd04426caf0fb05b528d2b1503e&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.cpp&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15233249" author="githubbot" created="Sat, 9 Apr 2016 01:08:07 +0000"  >&lt;p&gt;Github user jeking3 commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-207675424&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-207675424&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I did not touch &quot;go&quot; or &quot;py&quot; implementations and that was the reason for the failure in #2467.2.  #2467.1 failed in three tests including go-cpp/json however given other go tests are failing it looks like the issue is likely in &quot;go&quot;.&lt;/p&gt;</comment>
                            <comment id="15234116" author="hudson" created="Sun, 10 Apr 2016 13:18:16 +0000"  >&lt;p&gt;FAILURE: Integrated in Thrift-precommit #403 (See &lt;a href=&quot;https://builds.apache.org/job/Thrift-precommit/403/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/Thrift-precommit/403/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: ensure TThreadedServer guarantees the lifetime of the (jim.king: &lt;a href=&quot;https://github.com/apache/thrift/commit/acfa3ea233d4218a39255f434a9bc82ea49353af&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/commit/acfa3ea233d4218a39255f434a9bc82ea49353af&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.cpp&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TServerFramework.h&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TServerFramework.cpp&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.h&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: properly join TThreadedServer threads, added a stress test (jim.king: &lt;a href=&quot;https://github.com/apache/thrift/commit/a3a1bf86eec1b3f25e16934700154f46526576ae&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/commit/a3a1bf86eec1b3f25e16934700154f46526576ae&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.h&lt;/li&gt;
	&lt;li&gt;lib/cpp/test/TServerIntegrationTest.cpp&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/concurrency/Thread.h&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.cpp&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;: small maintainability change (jim.king: &lt;a href=&quot;https://github.com/apache/thrift/commit/9410809bb8df7c9742e37c93c0cb4785e2d2de1c&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/commit/9410809bb8df7c9742e37c93c0cb4785e2d2de1c&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;lib/cpp/src/thrift/server/TThreadedServer.cpp&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15234188" author="githubbot" created="Sun, 10 Apr 2016 16:43:02 +0000"  >&lt;p&gt;Github user jeking3 commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-208013575&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-208013575&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I ran the test that failed in the apache build in a loop and finally ended up in a deadlock situation, so I am looking at that.&lt;/p&gt;</comment>
                            <comment id="15235785" author="githubbot" created="Mon, 11 Apr 2016 19:24:59 +0000"  >&lt;p&gt;Github user jeking3 commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-208513794&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-208513794&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I&apos;m starting to believe that the TThreadServerPool implementation may have the same issue.  The cores I have been able to produce through repeated testing are showing a pthread running when nothing else is, and it usually cores because it is trying to lock a mutex that has been destroyed.  I&apos;m looking into this.&lt;/p&gt;</comment>
                            <comment id="15236327" author="githubbot" created="Tue, 12 Apr 2016 00:34:04 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59304879&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59304879&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -83,12 +88,56 @@ class TThreadedServer : public TServerFramework {&lt;br/&gt;
       virtual void serve();&lt;/p&gt;

&lt;p&gt;     protected:&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Drain recently connected clients by joining their threads - this is done lazily because&lt;br/&gt;
    +   * we cannot do it inside the thread context that is disconnecting.&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void drainDeadClients();&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientConnected&lt;br/&gt;
    +   */&lt;br/&gt;
       virtual void onClientConnected(const boost::shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) /* override */;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;virtual void onClientDisconnected(TConnectedClient* pClient) /* override */;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientDisconnected&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void onClientDisconnected(TConnectedClient &lt;b&gt;pClient) /&lt;/b&gt; override */;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       boost::shared_ptr&amp;lt;apache::thrift::concurrency::ThreadFactory&amp;gt; threadFactory_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;apache::thrift::concurrency::Monitor clientsMonitor_;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * A helper wrapper used to wrap the client in something we can use to maintain&lt;br/&gt;
    +   * the lifetime of the connected client within a detached thread.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It&apos;s not a detached thread anymore, but why is this needed? I think ClientMap be a map from TConnectedClient* to shared_ptr&amp;lt;apache:thrift::concurrency::Thread&amp;gt; because Thread itself holds on to the TConnectedClient and maintains its lifetime since it needs to run it.&lt;/p&gt;</comment>
                            <comment id="15236329" author="githubbot" created="Tue, 12 Apr 2016 00:34:11 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59304884&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59304884&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,71 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is a functional change that is subtle and may break existing users of TThreadedServer. I don&apos;t have a better solution at the moment, but I do want to call this out to see if others have a better solution.&lt;/p&gt;</comment>
                            <comment id="15236340" author="githubbot" created="Tue, 12 Apr 2016 00:39:27 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59305327&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59305327&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,71 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
       TServerFramework::serve();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +  // Ensure post-condition of no active clients&lt;br/&gt;
    +  Synchronized s(clientMonitor_);&lt;br/&gt;
    +  while (!activeClientMap_.empty()) 
{
    +    clientMonitor_.wait();
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  drainDeadClients();&lt;br/&gt;
    +}&lt;br/&gt;
    +&lt;br/&gt;
    +void TThreadedServer::drainDeadClients() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +  // we&amp;#39;re in a monitor here    +  while (!deadClientMap_.empty()) {
    +    ClientMap::iterator it = deadClientMap_.begin();
    +    it-&amp;gt;second-&amp;gt;join();
    +    deadClientMap_.erase(it);
       }     }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;threadFactory_&lt;del&gt;&amp;gt;newThread(pClient)&lt;/del&gt;&amp;gt;start();&lt;br/&gt;
    +  Synchronized sync(clientMonitor_);&lt;br/&gt;
    +  drainDeadClients();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    What do you think about draining in onClientDisconnected instead of onClientConnected (note to take care of draining before adding the thread that initiated onClientDisconnected to the list of dead clients)? I think it might be better to make onClientConnected as fast as possible because the serve thread is the caller?&lt;/p&gt;</comment>
                            <comment id="15236354" author="githubbot" created="Tue, 12 Apr 2016 00:49:13 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59306037&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59306037&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -83,12 +88,56 @@ class TThreadedServer : public TServerFramework {&lt;br/&gt;
       virtual void serve();&lt;/p&gt;

&lt;p&gt;     protected:&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Drain recently connected clients by joining their threads - this is done lazily because&lt;br/&gt;
    +   * we cannot do it inside the thread context that is disconnecting.&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void drainDeadClients();&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientConnected&lt;br/&gt;
    +   */&lt;br/&gt;
       virtual void onClientConnected(const boost::shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) /* override */;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;virtual void onClientDisconnected(TConnectedClient* pClient) /* override */;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientDisconnected&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void onClientDisconnected(TConnectedClient &lt;b&gt;pClient) /&lt;/b&gt; override */;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       boost::shared_ptr&amp;lt;apache::thrift::concurrency::ThreadFactory&amp;gt; threadFactory_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;apache::thrift::concurrency::Monitor clientsMonitor_;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * A helper wrapper used to wrap the client in something we can use to maintain&lt;br/&gt;
    +   * the lifetime of the connected client within a detached thread.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You are correct, we can just store the thread instead of this.&lt;/p&gt;</comment>
                            <comment id="15236356" author="githubbot" created="Tue, 12 Apr 2016 00:49:58 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59306085&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59306085&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,71 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
       TServerFramework::serve();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +  // Ensure post-condition of no active clients&lt;br/&gt;
    +  Synchronized s(clientMonitor_);&lt;br/&gt;
    +  while (!activeClientMap_.empty()) 
{
    +    clientMonitor_.wait();
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  drainDeadClients();&lt;br/&gt;
    +}&lt;br/&gt;
    +&lt;br/&gt;
    +void TThreadedServer::drainDeadClients() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +  // we&amp;#39;re in a monitor here    +  while (!deadClientMap_.empty()) {
    +    ClientMap::iterator it = deadClientMap_.begin();
    +    it-&amp;gt;second-&amp;gt;join();
    +    deadClientMap_.erase(it);
       }     }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;threadFactory_&lt;del&gt;&amp;gt;newThread(pClient)&lt;/del&gt;&amp;gt;start();&lt;br/&gt;
    +  Synchronized sync(clientMonitor_);&lt;br/&gt;
    +  drainDeadClients();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Sure we could do it that way.&lt;/p&gt;</comment>
                            <comment id="15237320" author="githubbot" created="Tue, 12 Apr 2016 14:54:13 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59390310&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59390310&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,71 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I could require it to be detached in the constructor and throw an invalid argument if it is not, I suppose, rather than mutating the thread factory in serve.&lt;/p&gt;</comment>
                            <comment id="15237323" author="githubbot" created="Tue, 12 Apr 2016 14:55:53 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59390673&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59390673&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -83,12 +88,56 @@ class TThreadedServer : public TServerFramework {&lt;br/&gt;
       virtual void serve();&lt;/p&gt;

&lt;p&gt;     protected:&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Drain recently connected clients by joining their threads - this is done lazily because&lt;br/&gt;
    +   * we cannot do it inside the thread context that is disconnecting.&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void drainDeadClients();&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientConnected&lt;br/&gt;
    +   */&lt;br/&gt;
       virtual void onClientConnected(const boost::shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) /* override */;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;virtual void onClientDisconnected(TConnectedClient* pClient) /* override */;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientDisconnected&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void onClientDisconnected(TConnectedClient &lt;b&gt;pClient) /&lt;/b&gt; override */;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       boost::shared_ptr&amp;lt;apache::thrift::concurrency::ThreadFactory&amp;gt; threadFactory_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;apache::thrift::concurrency::Monitor clientsMonitor_;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * A helper wrapper used to wrap the client in something we can use to maintain&lt;br/&gt;
    +   * the lifetime of the connected client within a detached thread.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I made this change and it will only work if I modify each of the thread implementations to release the smart_ptr to runnable in the thread class after the thread runs.  I assume this is acceptable; once the runnable runs we don&apos;t need the thread smart_ptr holding on to it any more; TServerFramework requires the TConnectedClient (the runnable) to be destroyed when the client disconnects to function properly.&lt;/p&gt;</comment>
                            <comment id="15237526" author="githubbot" created="Tue, 12 Apr 2016 16:50:27 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59410629&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59410629&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -83,12 +88,56 @@ class TThreadedServer : public TServerFramework {&lt;br/&gt;
       virtual void serve();&lt;/p&gt;

&lt;p&gt;     protected:&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Drain recently connected clients by joining their threads - this is done lazily because&lt;br/&gt;
    +   * we cannot do it inside the thread context that is disconnecting.&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void drainDeadClients();&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientConnected&lt;br/&gt;
    +   */&lt;br/&gt;
       virtual void onClientConnected(const boost::shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) /* override */;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;virtual void onClientDisconnected(TConnectedClient* pClient) /* override */;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * Implementation of TServerFramework::onClientDisconnected&lt;br/&gt;
    +   */&lt;br/&gt;
    +  virtual void onClientDisconnected(TConnectedClient &lt;b&gt;pClient) /&lt;/b&gt; override */;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       boost::shared_ptr&amp;lt;apache::thrift::concurrency::ThreadFactory&amp;gt; threadFactory_;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;apache::thrift::concurrency::Monitor clientsMonitor_;&lt;br/&gt;
    +&lt;br/&gt;
    +  /**&lt;br/&gt;
    +   * A helper wrapper used to wrap the client in something we can use to maintain&lt;br/&gt;
    +   * the lifetime of the connected client within a detached thread.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This busted StressTest and StressTestNonBlocking because they are coded to assume that the thread shared pointer will hold on to the runnable after the thread is gone.  The TConnectedClientTracker is therefore necessary to avoid breaking existing clients that might depend on this behavior of Thread, so I am not going to simplify to a map of TConnectedClient* to shared_ptr&amp;lt;Thread&amp;gt;.&lt;/p&gt;</comment>
                            <comment id="15237678" author="githubbot" created="Tue, 12 Apr 2016 18:17:24 +0000"  >&lt;p&gt;Github user jeking3 commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-209039437&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-209039437&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @jfarrell Could you look into why the Jenkins build for apache thinks that a c_glib file needs to be merged manually and/or has an open pull request on the apache build system?&lt;/p&gt;</comment>
                            <comment id="15244992" author="githubbot" created="Mon, 18 Apr 2016 00:04:07 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59995963&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59995963&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    What if an addWorker call was made in between this and when goalCount was set? &lt;/p&gt;</comment>
                            <comment id="15244995" author="githubbot" created="Mon, 18 Apr 2016 00:09:57 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59996087&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59996087&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,71 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I am &lt;b&gt;slightly&lt;/b&gt; concerned about user reusing the thrift factory in other part of the code, so changing this can change the function of their other code. I&apos;m not too sure what the maintainers usually do when there are some minor functional changes.&lt;/p&gt;</comment>
                            <comment id="15245001" author="githubbot" created="Mon, 18 Apr 2016 00:15:41 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59996185&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59996185&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,69 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
       TServerFramework::serve();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +  // Ensure post-condition of no active clients&lt;br/&gt;
    +  Synchronized s(clientMonitor_);&lt;br/&gt;
    +  while (!activeClientMap_.empty()) 
{
    +    clientMonitor_.wait();
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  drainDeadClients();&lt;br/&gt;
    +}&lt;br/&gt;
    +&lt;br/&gt;
    +void TThreadedServer::drainDeadClients() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +  // we&amp;#39;re in a monitor here    +  while (!deadClientMap_.empty()) {
    +    ClientMap::iterator it = deadClientMap_.begin();
    +    it-&amp;gt;second-&amp;gt;join();
    +    deadClientMap_.erase(it);
       }     }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;threadFactory_&lt;del&gt;&amp;gt;newThread(pClient)&lt;/del&gt;&amp;gt;start();&lt;br/&gt;
    +  Synchronized sync(clientMonitor_);&lt;br/&gt;
    +  activeClientMap_.insert(ClientMap::value_type(pClient.get(), boost::make_shared&amp;lt;TConnectedClientRunner&amp;gt;(pClient)));&lt;br/&gt;
    +  ClientMap::iterator it = activeClientMap_.find(pClient.get());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You can be slightly more efficient if you use the pair&amp;lt;iterator,bool&amp;gt; returned by insert.&lt;/p&gt;</comment>
                            <comment id="15245002" author="githubbot" created="Mon, 18 Apr 2016 00:18:48 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r59996235&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r59996235&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/test/TServerIntegrationTest.cpp &amp;#8212;&lt;br/&gt;
    @@ -152,7 +155,10 @@ class TServerIntegrationTestFixture {&lt;br/&gt;
                                       new TServerSocket(&quot;localhost&quot;, 0)),&lt;br/&gt;
                                   boost::shared_ptr&amp;lt;TTransportFactory&amp;gt;(new TTransportFactory),&lt;br/&gt;
                                   boost::shared_ptr&amp;lt;TProtocolFactory&amp;gt;(new TBinaryProtocolFactory))),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;pEventHandler(boost::shared_ptr&amp;lt;TServerReadyEventHandler&amp;gt;(new TServerReadyEventHandler)) {&lt;br/&gt;
    +      pEventHandler(boost::shared_ptr&amp;lt;TServerReadyEventHandler&amp;gt;(new TServerReadyEventHandler)),&lt;br/&gt;
    +	  bStressDone(false),
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Looks like the tabs are not aligned correctly in this document.&lt;/p&gt;</comment>
                            <comment id="15245004" author="githubbot" created="Mon, 18 Apr 2016 00:19:29 +0000"  >&lt;p&gt;Github user tpcwang commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-211137935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-211137935&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I think this change looks good for the most part, maybe we can get one of the maintainers to look at it?&lt;/p&gt;</comment>
                            <comment id="15247728" author="githubbot" created="Tue, 19 Apr 2016 13:14:12 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r60227644&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r60227644&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,69 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
       TServerFramework::serve();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Drain all clients - no more will arrive&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;Synchronized s(clientsMonitor_);&lt;/li&gt;
	&lt;li&gt;while (getConcurrentClientCount() &amp;gt; 0) 
{
    -      clientsMonitor_.wait();
    -    }&lt;/li&gt;
	&lt;li&gt;} catch (TException&amp;amp; tx) {&lt;/li&gt;
	&lt;li&gt;string errStr = string(&quot;TThreadedServer: Exception joining workers: &quot;) + tx.what();&lt;/li&gt;
	&lt;li&gt;GlobalOutput(errStr.c_str());&lt;br/&gt;
    +  // Ensure post-condition of no active clients&lt;br/&gt;
    +  Synchronized s(clientMonitor_);&lt;br/&gt;
    +  while (!activeClientMap_.empty()) 
{
    +    clientMonitor_.wait();
    +  }
&lt;p&gt;    +&lt;br/&gt;
    +  drainDeadClients();&lt;br/&gt;
    +}&lt;br/&gt;
    +&lt;br/&gt;
    +void TThreadedServer::drainDeadClients() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +  // we&amp;#39;re in a monitor here    +  while (!deadClientMap_.empty()) {
    +    ClientMap::iterator it = deadClientMap_.begin();
    +    it-&amp;gt;second-&amp;gt;join();
    +    deadClientMap_.erase(it);
       }     }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     void TThreadedServer::onClientConnected(const shared_ptr&amp;lt;TConnectedClient&amp;gt;&amp;amp; pClient) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;threadFactory_&lt;del&gt;&amp;gt;newThread(pClient)&lt;/del&gt;&amp;gt;start();&lt;br/&gt;
    +  Synchronized sync(clientMonitor_);&lt;br/&gt;
    +  activeClientMap_.insert(ClientMap::value_type(pClient.get(), boost::make_shared&amp;lt;TConnectedClientRunner&amp;gt;(pClient)));&lt;br/&gt;
    +  ClientMap::iterator it = activeClientMap_.find(pClient.get());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I implemented this suggestion.&lt;/p&gt;</comment>
                            <comment id="15251965" author="githubbot" created="Thu, 21 Apr 2016 14:31:44 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r60590542&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r60590542&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    This routine blocks until there are fewer actual workers than the number of workers when it was called less the value passed in.  On a busy system where workers are being added this means it might be in here for a while.  I did not change this behavior; simply I ensured that the effects of multiple threads calling removeWorker() at the same time don&apos;t clobber each-other&apos;s desired goal of how many to remove.&lt;/p&gt;

&lt;p&gt;    It would be better to have two calls; one to trim the maximum number of workers but it doesn&apos;t block; another being a barrier you can use to get to that number.  Callers may want to trim without blocking, for example.&lt;/p&gt;</comment>
                            <comment id="15251969" author="githubbot" created="Thu, 21 Apr 2016 14:34:41 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r60591056&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r60591056&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.cpp &amp;#8212;&lt;br/&gt;
    @@ -90,31 +95,71 @@ TThreadedServer::~TThreadedServer() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     void TThreadedServer::serve() {&lt;br/&gt;
    +  threadFactory_-&amp;gt;setDetached(false);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I don&apos;t see an easy way around this.  The threaded server must be able to join.  The caller could pass a non-detached ThreadManager into the ctor and then setDetached(true) before or while serve() is running - there are a variety of things we cannot control.  The default behavior is to use a detached ThreadManager, so if I changed this to a check with an invalid_argument or logic_error exception, there would have been more work to do in the default simple thread manager static factory and related calls.&lt;/p&gt;

&lt;p&gt;    On line 38 of the header this behavior is documented, at least.&lt;/p&gt;</comment>
                            <comment id="15252151" author="githubbot" created="Thu, 21 Apr 2016 16:23:54 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r60612338&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r60612338&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I&apos;m not sure I understand what the problem is. Why would calling removeWorker() at the same time clobber each other&apos;s desire goal? They have a shared goal of reducing workerMaxCount_ and both will eventually get there, right?&lt;/p&gt;

&lt;p&gt;    However, I think the new implementation does have problems with addWorker and removeWorker. Say I start with 1 worker:&lt;br/&gt;
    (1) Thread1 calls removeWorker(1) - goalCount is 0, workerCount_ is 1&lt;br/&gt;
    (2) Thread2 calls addWorker(2) - goalCount is 0, workerCount_ is 3&lt;br/&gt;
    (3) Thread3 worker is reaped - goalCount is 0, workerCount_ is 2 &amp;lt;- this will stay at 2 forever&lt;/p&gt;

&lt;p&gt;    In any case, we may want to discuss this in a separate change if there is a problem with the current implementation since this pull request no longer uses the thread manager.&lt;/p&gt;</comment>
                            <comment id="15252171" author="githubbot" created="Thu, 21 Apr 2016 16:35:12 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r60614134&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r60614134&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    ThreadManager should probably be tossed out; removeWorker is inherently dangerous for a variety of reasons just like this.  In particular I can see a scenario where multiple workers simultaneously try to reduce the worker count by the same amount and fail badly because they both thought there were 5 workers and they both asked to removeWorker(3).  The API would be much better as specifying what the new limit should be and the reduction of intention vs setting a barrier until you get there should be separate operations.  It seems pretty fragile as-is and I think the whole thing needs a rethink.&lt;/p&gt;</comment>
                            <comment id="15252175" author="githubbot" created="Thu, 21 Apr 2016 16:38:40 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r60614631&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r60614631&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    In that particular scenario, the second removeWorker should fail since we should be synchronizing correctly when it checks if (value &amp;gt; workerMaxCount_), but I agree that ThreadManager probably needs some TLC.&lt;/p&gt;</comment>
                            <comment id="15262575" author="githubbot" created="Thu, 28 Apr 2016 17:26:15 +0000"  >&lt;p&gt;Github user jeking3 commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-215502049&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-215502049&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Looking for an advocate who would consider merging this fix despite the busted Apache Jenkins environment result.&lt;/p&gt;</comment>
                            <comment id="15263540" author="githubbot" created="Fri, 29 Apr 2016 04:53:20 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r61534321&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r61534321&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I would be happy to give my vote for this to be merged in, if you can address my concern on the change in this file. I still don&apos;t think this new implementation correctly handles concurrent addWorker/removeWorker calls. I also think the existing implementation actually handles concurrent removeWorker calls correctly, so it is not clear to me why this change is necessary. Sorry if I miss anything obvious.&lt;/p&gt;</comment>
                            <comment id="15263870" author="githubbot" created="Fri, 29 Apr 2016 10:22:52 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r61558381&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r61558381&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Old line 424 was accessing ``workerMaxCount_`` outside of a lock so its behavior was unpredictable when multiple threads called ``removeWorker()`` simultaneously.  Saving the value ti ``goalCount`` removes this unpredictability and therefore is an improvement.  Also see &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3233&quot; title=&quot;Fix C++ ThreadManager::Impl::removeWorker worker join&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3233&quot;&gt;&lt;del&gt;THRIFT-3233&lt;/del&gt;&lt;/a&gt; for another fix submitted by someone else.&lt;/p&gt;</comment>
                            <comment id="15264083" author="githubbot" created="Fri, 29 Apr 2016 13:58:49 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r61581424&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r61581424&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It is not accessing `workerMaxCount_` outside of a lock. See line 424 where it uses the `Synchronized` object which grabs the mutex that the monitor owns. &lt;/p&gt;</comment>
                            <comment id="15264143" author="githubbot" created="Fri, 29 Apr 2016 14:48:12 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r61589086&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r61589086&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Old line 399 modifies it under the monitor ``monitor_`` and then old line 424 acquired it under a different monitor ``workerMonitor_``.  One cannot use different monitors to control access to the same variable and expect any synchronization.  This is why I squirrel away the new value into goalCount and use it later on.&lt;/p&gt;</comment>
                            <comment id="15264254" author="githubbot" created="Fri, 29 Apr 2016 16:05:06 +0000"  >&lt;p&gt;Github user tpcwang commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r61601611&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r61601611&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I had missed that it is using different monitors and thus different mutexes. Thanks for clarifying.&lt;/p&gt;

&lt;p&gt;    I would still argue that this new implementation is worse than the existing implementation. With the existing implementation, concurrent *&lt;b&gt;writes&lt;/b&gt;* to `workerMaxCount_` and `workerCount_` is synchronized, but the reading of those values is not synchronized. Reading an aligned integer is most likely atomic on most architectures, so this might not even be that unsafe &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. Getting either the old value or the new value will not invalidate what it is trying to do.&lt;/p&gt;

&lt;p&gt;    On the other hand, the new implementation has a problem with concurrent removeWorker and addWorker as far as I can tell. A removeWorker can be stuck forever if a addWorker call comes in after the removeWorker sets the local `goalCount` because it will never hit that goal with new workers that are produced by addWorker.&lt;/p&gt;

&lt;p&gt;    Hopefully I didn&apos;t miss another detail. Thanks for working with me to address these concerns.&lt;/p&gt;</comment>
                            <comment id="15264351" author="githubbot" created="Fri, 29 Apr 2016 17:10:47 +0000"  >&lt;p&gt;Github user jeking3 commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#discussion_r61612686&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#discussion_r61612686&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/concurrency/ThreadManager.cpp &amp;#8212;&lt;br/&gt;
    @@ -421,7 +416,7 @@ void ThreadManager::Impl::removeWorker(size_t value) {&lt;br/&gt;
       {&lt;br/&gt;
         Synchronized s(workerMonitor_);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;while (workerCount_ != workerMaxCount_) {&lt;br/&gt;
    +    while (workerCount_ &amp;gt; goalCount) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I reverted all changes to this file.&lt;/p&gt;</comment>
                            <comment id="15264546" author="githubbot" created="Fri, 29 Apr 2016 18:59:48 +0000"  >&lt;p&gt;Github user tpcwang commented on the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980#issuecomment-215848959&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980#issuecomment-215848959&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    LGTM. Thanks for fixing this issue.&lt;/p&gt;</comment>
                            <comment id="15310863" author="jking3" created="Wed, 1 Jun 2016 18:43:59 +0000"  >&lt;p&gt;Would like to get this into 0.10.0.&lt;/p&gt;</comment>
                            <comment id="15329390" author="jking3" created="Tue, 14 Jun 2016 12:16:40 +0000"  >&lt;p&gt;The latest build passed fully.  Please merge this in so it gets into 0.10.0.&lt;/p&gt;</comment>
                            <comment id="15334577" author="githubbot" created="Thu, 16 Jun 2016 20:05:04 +0000"  >&lt;p&gt;Github user Jens-G commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/977#discussion_r67414520&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/977#discussion_r67414520&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: lib/cpp/src/thrift/server/TThreadedServer.h &amp;#8212;&lt;br/&gt;
    @@ -20,19 +20,26 @@&lt;br/&gt;
     #ifndef &lt;em&gt;THRIFT_SERVER_TTHREADEDSERVER_H&lt;/em&gt;&lt;br/&gt;
     #define &lt;em&gt;THRIFT_SERVER_TTHREADEDSERVER_H&lt;/em&gt; 1&lt;/p&gt;

&lt;p&gt;    -#include &amp;lt;thrift/concurrency/Monitor.h&amp;gt;&lt;br/&gt;
     #include &amp;lt;thrift/concurrency/PlatformThreadFactory.h&amp;gt;&lt;br/&gt;
     #include &amp;lt;thrift/concurrency/Thread.h&amp;gt;&lt;br/&gt;
    -#include &amp;lt;thrift/server/TServerFramework.h&amp;gt;&lt;br/&gt;
    +#include &amp;lt;thrift/server/TThreadPoolServer.h&amp;gt;&lt;/p&gt;

&lt;p&gt;     namespace apache {&lt;br/&gt;
     namespace thrift {&lt;br/&gt;
     namespace server {&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Manage clients using a thread pool.&lt;br/&gt;
    + * Manage clients using threads.  Once the refactoring for &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3083&quot; title=&quot;C++ Consolidate server processing loops in TSimpleServer, TThreadedServer, TThreadPoolServer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3083&quot;&gt;&lt;del&gt;THRIFT-3083&lt;/del&gt;&lt;/a&gt; took place it became&lt;br/&gt;
    + * obvious that the differences between the two threaded server types was becoming insignificant.&lt;br/&gt;
    + * Therefore to satisfy &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3096&quot; title=&quot;Consolidate TSimpleServer, TThreadedServer, TThreadPoolServer into one&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3096&quot;&gt;&lt;del&gt;THRIFT-3096&lt;/del&gt;&lt;/a&gt; and fix &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-3768&quot; title=&quot;TThreadedServer may crash if it is destroyed immediately after it returns from serve(); TThreadedServer disconnects clients when they connec&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-3768&quot;&gt;&lt;del&gt;THRIFT-3768&lt;/del&gt;&lt;/a&gt;, TThreadedServer is simply a wrapper&lt;br/&gt;
    + * around TThreadedPoolServer now.  If backwards compatibility was not a concern, it would have&lt;br/&gt;
    + * been removed.&lt;br/&gt;
    + *&lt;br/&gt;
    + * The default thread pool size is
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Still the case.&lt;/p&gt;</comment>
                            <comment id="15334582" author="jensg" created="Thu, 16 Jun 2016 20:07:18 +0000"  >&lt;p&gt;Committed. That comment may be fixed later.&lt;/p&gt;</comment>
                            <comment id="15362990" author="jking3" created="Tue, 5 Jul 2016 18:45:21 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jensg&quot; class=&quot;user-hover&quot; rel=&quot;jensg&quot;&gt;jensg&lt;/a&gt; The wrong pull request got merged.  Pull request 977 was declined in favor of pull request 980.   Please revert pull request 977 and apply pull request 980.&lt;/p&gt;</comment>
                            <comment id="15368332" author="jensg" created="Fri, 8 Jul 2016 20:05:48 +0000"  >&lt;p&gt;Sure. May I rebase it for you?&lt;/p&gt;</comment>
                            <comment id="15368344" author="githubbot" created="Fri, 8 Jul 2016 20:12:09 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/980&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15368346" author="jensg" created="Fri, 8 Jul 2016 20:12:49 +0000"  >&lt;p&gt;LGTM, rebased &amp;amp; committed.&lt;/p&gt;</comment>
                            <comment id="15368455" author="jking3" created="Fri, 8 Jul 2016 20:54:44 +0000"  >&lt;p&gt;Glad there weren&apos;t any issues rebasing / removing 977.&lt;br/&gt;
I&apos;ll take one of my other pull requests that got stuck building, rebase, and push to see that the issue is gone.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12820683">THRIFT-3096</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 19 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2vgtj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>