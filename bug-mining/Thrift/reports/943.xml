<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 08:12:55 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[THRIFT-2451] Do not use pointers for optional fields with defaults. Do not write such fields if its value set to default. Also, do not use pointers for any optional fields mapped to go map or slice. generate Get accessors</title>
                <link>https://issues.apache.org/jira/browse/THRIFT-2451</link>
                <project id="12310800" key="THRIFT">Thrift</project>
                    <description>&lt;p&gt;Currently, for optional fields in struct&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;struct pkt {
 1: optional string s = &lt;span class=&quot;code-quote&quot;&gt;&quot;DEFAULT&quot;&lt;/span&gt;,
 2: optional i64 i = 42,
 3: optional bool b = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;go compiler generates the following:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;type Pkt struct {
        S *string `thrift:&lt;span class=&quot;code-quote&quot;&gt;&quot;s,1&quot;&lt;/span&gt;`
        I *int64  `thrift:&lt;span class=&quot;code-quote&quot;&gt;&quot;i,2&quot;&lt;/span&gt;`
        B *bool   `thrift:&lt;span class=&quot;code-quote&quot;&gt;&quot;b,3&quot;&lt;/span&gt;`
}

func NewPkt() *Pkt {
        rval := &amp;amp;Pkt{
                S: &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;(string),

                I: &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;(int64),

                B: &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;(bool),
        }
        *(rval.S) = &lt;span class=&quot;code-quote&quot;&gt;&quot;DEFAULT&quot;&lt;/span&gt;
        *(rval.I) = 42
        *(rval.B) = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; rval
}

func (p *Pkt) IsSetS() bool {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; p.S != nil
}

func (p *Pkt) IsSetI() bool {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; p.I != nil
}

func (p *Pkt) IsSetB() bool {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; p.B != nil
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;which is wrong in multiple ways:&lt;br/&gt;
1. Freshly initialized fields returns IsSetField() true&lt;br/&gt;
    &lt;a href=&quot;http://play.golang.org/p/T2pIX80ZJp&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://play.golang.org/p/T2pIX80ZJp&lt;/a&gt;&lt;br/&gt;
    This results in &lt;br/&gt;
      a. wrong semantics: freshly created struct has optional fields set&lt;br/&gt;
      b. excessive payload produced on serialization (writing field value instead of skipping it)&lt;br/&gt;
2. Additional load on garbage collector&lt;br/&gt;
3. accessing field value is complicated and error prone. even without default value:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;     &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; pkt.IsSetB() &amp;amp;&amp;amp; *pkt.B {
        &lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; something &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; b==&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
&lt;/span&gt;     }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;     would work for false default for field b. However, if I change default value to true, I need to change all occurrences in the code like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;     &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; !pkt.IsSetB() || *pkt.B {
        &lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; something &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; b==&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
&lt;/span&gt;     }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;How to fix that?&lt;br/&gt;
there are two ways:&lt;br/&gt;
1. get back to generating inlines instead of pointers for optional fields with default value and compare with &quot;magic value&quot; of default in IsSet*(). could be tricky since not all types are comparable &lt;a href=&quot;http://golang.org/ref/spec#Comparison_operators&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://golang.org/ref/spec#Comparison_operators&lt;/a&gt; . notably, slices and maps are not.&lt;br/&gt;
2. approach, used in protobuf: Do not initialize optional fields, generate Get*() accessors like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; Pkt_B_Default = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
 func (p *Pkt) GetB() bool {
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; p.B == nil {
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; Pkt_B_Default
  }
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; *p.B
 }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Just to make API uniform, we can also generate accessors for required fields:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; func (p *Pkt) GetB() bool {
  &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; p.B
 }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;m inclining to implement second approach, but I would like to collect opinions before I dig into the code.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12706805">THRIFT-2451</key>
            <summary>Do not use pointers for optional fields with defaults. Do not write such fields if its value set to default. Also, do not use pointers for any optional fields mapped to go map or slice. generate Get accessors</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jensg">Jens Geyer</assignee>
                                    <reporter username="apesternikov">Aleksey Pesternikov</reporter>
                        <labels>
                    </labels>
                <created>Sat, 5 Apr 2014 21:29:10 +0000</created>
                <updated>Mon, 26 May 2014 22:42:40 +0000</updated>
                            <resolved>Thu, 1 May 2014 22:27:13 +0000</resolved>
                                                    <fixVersion>0.9.2</fixVersion>
                                    <component>Go - Compiler</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="13961990" author="bensigelman" created="Mon, 7 Apr 2014 16:35:41 +0000"  >&lt;p&gt;A few responses.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It&apos;s not clear to me that an optional field with a default value shouldn&apos;t be considered &quot;Set&quot;... is that in the spec, or is that your interpretation? (I come from the world of protobufs... in those cases, a field with a default value was essentially always set IIRC).&lt;/li&gt;
	&lt;li&gt;It&apos;s dangerous not to write default values over the wire. Otherwise, if the default value changes, the wire protocol essentially breaks.&lt;/li&gt;
	&lt;li&gt;Point taken about the GC, though it would be great if you could quantify this with some sort of realistic workload.&lt;/li&gt;
	&lt;li&gt;Field value accesses were far more broken before IMO &amp;#8211; still error-prone, for sure, but at least not &quot;error-guaranteed&quot; if you depended on the magic &quot;empty&quot; values for various types.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;FWIW, I can see the argument for adding Get*() accessors... though if we go that route, it might make sense to hide the entire implementation behind a generated interface. (I.e., Set/Get would be the only way to access the underlying structures)&lt;/p&gt;

&lt;p&gt;My only cautionary note about this is that, if we include a bitfield of some sort to indicate whether fields have been set or not, we basically need to make all of the struct fields un-exported... I wouldn&apos;t want to force callers to take responsibility for setting &quot;set&quot; bits along with field values.&lt;/p&gt;

&lt;p&gt;Obviously this is just my two cents!&lt;/p&gt;</comment>
                            <comment id="13962192" author="jensg" created="Mon, 7 Apr 2014 19:57:29 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apesternikov&quot; class=&quot;user-hover&quot; rel=&quot;apesternikov&quot;&gt;apesternikov&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bensigelman&quot; class=&quot;user-hover&quot; rel=&quot;bensigelman&quot;&gt;bensigelman&lt;/a&gt;, &lt;/p&gt;

&lt;p&gt;there is a lengthy debate about the semantics of &lt;tt&gt;required&lt;/tt&gt;, &lt;tt&gt;optional&lt;/tt&gt; and default specifiers vis-&#225;-vis setting field defaults over there in &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt;. I dont want to repeat the stuff here, but the ideal result would have the Go implementation conform to what has been finally agreed upon over there. &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I wouldn&apos;t want to force callers to take responsibility for setting &quot;set&quot; bits along with field values.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Absolutely. I&apos;m 100% behind that, especially as it would a) not conform with the other languages and b) make things overly complicated. &lt;/p&gt;

&lt;p&gt;BTW, Ben, your opinion is more than welcome.&lt;/p&gt;
</comment>
                            <comment id="13962357" author="apesternikov" created="Mon, 7 Apr 2014 22:56:21 +0000"  >&lt;p&gt;Per discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt;, the current implementation always serialize value even if it is equals to default, and &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt; is actually changing it. I did not realize it is currently not implemented this way.&lt;br/&gt;
Another thing: optional with default specified is currently indistinguishable from required on encoding side, &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt; is changing it to use &amp;lt;del&amp;gt;magic&amp;lt;/del&amp;gt; default values as an indicator of &quot;optional&quot;&lt;br/&gt;
That means we can safely generate inlines (no pointers) for fields with defaults.&lt;br/&gt;
Also, we don&apos;t need pointers to slices and maps since they can be distinguished by nil:&lt;br/&gt;
&lt;a href=&quot;http://play.golang.org/p/gWtUqwz6XS&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://play.golang.org/p/gWtUqwz6XS&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13962365" author="apesternikov" created="Mon, 7 Apr 2014 23:05:45 +0000"  >&lt;p&gt;After my attempt to use it, I really dislike the idea of fields mapped to pointers, even wrapped in Get*/Set*. This make code ugly so I found myself converting serialized structures into plain (pogo?&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &quot;internal represenation&quot; and back.&lt;/p&gt;</comment>
                            <comment id="13962366" author="bensigelman" created="Mon, 7 Apr 2014 23:07:54 +0000"  >&lt;p&gt;I added the pointers to slices/maps partly for consistency, and partly because a nil slice is actually a bit different than a pointer to a nil slice.&lt;/p&gt;

&lt;p&gt;This is well-defined go code:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://play.golang.org/p/IhzZ4Mzokp&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://play.golang.org/p/IhzZ4Mzokp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;... so a nil slice is (IMO) sufficiently confusable with an empty slice.&lt;/p&gt;

&lt;p&gt;Of course this is not the case for Golang maps.&lt;/p&gt;

&lt;p&gt;Anyway, here&apos;s what I actually care about:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;support for optional fields&lt;/li&gt;
	&lt;li&gt;no special treatment of special values for various field types; esp 0 and &quot;&quot;, which are really very common and often &lt;b&gt;valid&lt;/b&gt; values for numeric/string types&lt;/li&gt;
	&lt;li&gt;no requirement for the user of the struct to maintain a bitfield&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I don&apos;t actually like my patch very much, to be honest. I think it shows off some problems with both the Thrift spec and Golang &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  The only alternative I could imagine was Getter/Setter interfaces and totally opaque implementations. That would work well for the common case of numeric and string types, but it runs into trouble when we get into the more esoteric set/map stuff. Or that&apos;s why I stayed away from it.&lt;/p&gt;

&lt;p&gt;But anyway! I don&apos;t mean to be a stick in the mud. I don&apos;t like the proliferation of pointers much more than you do, but for optional fields, I think they&apos;re our best bet given the combined requirements of Thrift and Golang. If you want to do the heavy lifting to make an interface-driven approach, then my hat goes off to you &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13962373" author="apesternikov" created="Mon, 7 Apr 2014 23:16:56 +0000"  >&lt;p&gt;to get in line with &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt;, this bug title should be:&lt;br/&gt;
&quot;Do not use pointers for optional fields with defaults. Do not write such fields if its value set to default. Also, do not use pointers for any optional fields mapped to go map or slice&quot;&lt;br/&gt;
Any objections?&lt;/p&gt;</comment>
                            <comment id="13962376" author="bensigelman" created="Mon, 7 Apr 2014 23:23:49 +0000"  >&lt;p&gt;I&apos;m not on the thrift team and will thus stay out of the main debate about 2429, but let me state for the record:&lt;/p&gt;

&lt;p&gt;Building big distributed systems eventually means dealing with widely differing software versions that must communicate with each other in a production environment. Thus, it seems unwise to have the wire protocols depend on default values which may change at the whim of a programmer who doesn&apos;t realize the full implications of a removed (or added) default.&lt;/p&gt;

&lt;p&gt;That said, I would say that there&apos;s an argument &lt;b&gt;for consistency&lt;/b&gt; to keep pointers for all optional fields, whether or not there are defaults available. But I don&apos;t feel strongly about that.&lt;/p&gt;

&lt;p&gt;In that other thread I illustrated why I think there&apos;s an argument for using pointers to slices. I don&apos;t feel strongly about it, though.&lt;/p&gt;

&lt;p&gt;And in none of this am I in a decision-making position &amp;#8211; I&apos;m just providing my perspective... Jens and/or other maintainers should get the final word!&lt;/p&gt;</comment>
                            <comment id="13962377" author="apesternikov" created="Mon, 7 Apr 2014 23:24:34 +0000"  >&lt;p&gt;Ben,&lt;/p&gt;

&lt;p&gt;I understand that nil slice is acting exactly like empty slice, this is exactly the most beautiful part. It is just an empty slice, but you can distinguish between nil and empty slice.&lt;/p&gt;

&lt;p&gt;I do NOT like an interface-driven approach (if Get*/Set* is what you mean). In fact, I would rather go with specifying defaults for all optional fields and always use simple struct fields for mapping. &lt;/p&gt;</comment>
                            <comment id="13962386" author="bensigelman" created="Mon, 7 Apr 2014 23:33:15 +0000"  >&lt;p&gt;You and I have divergent opinions about the desirability for ambiguity in programming interfaces &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  An empty list and an absent list are distinguishable in the thrift wire protocol, so my assumption was that they should be distinguishable in the generated code. Using `nil` to represent both in Golang makes that impossible... A far more benign and less problematic version of the issue that prompted my fix in the first place!&lt;/p&gt;

&lt;p&gt;But this is not a big deal &amp;#8211; just wanted to make sure my perspective was recorded...&lt;/p&gt;</comment>
                            <comment id="13962394" author="apesternikov" created="Mon, 7 Apr 2014 23:41:37 +0000"  >&lt;p&gt;&amp;gt;Using `nil` to represent both in Golang makes that impossible...&lt;br/&gt;
It is perfectly possible, as demonstrated, without making the mapping inconvenient.&lt;/p&gt;</comment>
                            <comment id="13962399" author="bensigelman" created="Mon, 7 Apr 2014 23:48:23 +0000"  >&lt;p&gt;My point was that some people use a nil slice to represent an empty slice; `append` accepts both. Minor point.&lt;/p&gt;</comment>
                            <comment id="13962446" author="apesternikov" created="Tue, 8 Apr 2014 00:34:59 +0000"  >&lt;p&gt;&amp;gt;I come from the world of protobufs... in those cases, a field with a default value was essentially always set IIRC&lt;br/&gt;
Not really, at least not for go. This proto definition&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;message m {
	optional int64 i = 1 [&lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; = 42];
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;With this code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; (
	&lt;span class=&quot;code-quote&quot;&gt;&quot;code.google.com/p/goprotobuf/proto&quot;&lt;/span&gt;
	&lt;span class=&quot;code-quote&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;code-quote&quot;&gt;&quot;t&quot;&lt;/span&gt;
)

func main() {
	m := &amp;amp;t.M{}
	buf, _ := proto.Marshal(m)
	fmt.Printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;%#v\n&quot;&lt;/span&gt;, buf)
	m.I = proto.Int64(1)
	buf, _ = proto.Marshal(m)
	fmt.Printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;%#v\n&quot;&lt;/span&gt;, buf)
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;shows&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;[]&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;{}
[]&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;{0x8, 0x1}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13964923" author="apesternikov" created="Thu, 10 Apr 2014 03:03:14 +0000"  >&lt;p&gt;Please review the attached implementation. In the mean time I will try to come up with benchmarks using cassandra interface.&lt;/p&gt;</comment>
                            <comment id="13965605" author="apesternikov" created="Thu, 10 Apr 2014 17:51:07 +0000"  >&lt;p&gt;benchmark for the change is here &lt;a href=&quot;https://github.com/apesternikov/thrifttest&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apesternikov/thrifttest&lt;/a&gt;. Turned out cassandra interface has no optional fields with defaults, so difference of the code generated with this change is next to none. In this benchmark, I have used a part of my real log record.&lt;br/&gt;
&lt;a href=&quot;https://github.com/apesternikov/thrifttest&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apesternikov/thrifttest&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13965668" author="bensigelman" created="Thu, 10 Apr 2014 18:34:44 +0000"  >&lt;p&gt;I really do appreciate the effort you&apos;re going through on this change, but I&apos;ll admit that I still think it&apos;s a net regression. I think it&apos;s unintuitive that the addition of a default to an optional field would change the generated Go type of the related field.&lt;/p&gt;

&lt;p&gt;The test you wrote is a microbenchmark... i.e., of course it&apos;s faster. The big question (IMO) is whether it would actually show up in the profile of a real production workload; of course I&apos;m not demanding that you write such a test (super painful to do, of course), but this is not how thrift is used in the wild:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;https://github.com/apesternikov/thrifttest/blob/master/runme_test.go&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apesternikov/thrifttest/blob/master/runme_test.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I dunno. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jensg&quot; class=&quot;user-hover&quot; rel=&quot;jensg&quot;&gt;jensg&lt;/a&gt;, I leave this to you. In my view, we should use the same generated Golang interface for optional fields, regardless of whether they have a default or not. If we&apos;re worried about the allocation overhead of the current codebase, I&apos;d prefer that we move to generate interfaces with totally opaque/unexported non-pointer-field+bool pairs. (The bool would represent whether the field is set, of course) That&apos;s a lot of work, though, and I don&apos;t have time for it myself...&lt;/p&gt;</comment>
                            <comment id="13965771" author="apesternikov" created="Thu, 10 Apr 2014 19:52:18 +0000"  >&lt;p&gt;&amp;gt;The test you wrote is a microbenchmark... i.e., of course it&apos;s faster. The big question (IMO) is whether it would actually show up in the &amp;gt;profile of a real production workload; of course I&apos;m not demanding that you write such a test (super painful to do, of course), but this is &amp;gt;not how thrift is used in the wild:&lt;br/&gt;
Production workloads are different. Thats why YMMV, disclamer etc etc are in the readme. All benchmarks in a world are more or less artificial. This one is a part of my real use case, when log records are processed by M/R-like workers and the structure is being created over and over again, just to be decoded from the stream, checked for some condition and mostly discarded. It is also a part of every thrift call, but impact is not that big of course.&lt;br/&gt;
Also, IMHO non-pointers are much more intuitive and easy to use. As I already said, I would love to implement a (non-default) mapping mode when all optional fields use zero value as IsSet indicator. It is very natural for golang. And no, it is not broken as long as it is non-default and documented so people understand what they are doing.&lt;br/&gt;
As a middle ground, I can return pointers for all optional fields as default mapping, and implement this one, as well as proposed as nondefault. For the record: I totally oppose hiding real struct fields behind getters/setters, since it makes code so clunky.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jensg&quot; class=&quot;user-hover&quot; rel=&quot;jensg&quot;&gt;jensg&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="13965818" author="jensg" created="Thu, 10 Apr 2014 20:42:56 +0000"  >&lt;p&gt;I saw your posts, answer follows. &lt;/p&gt;</comment>
                            <comment id="13967171" author="jensg" created="Fri, 11 Apr 2014 22:18:00 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Please review the attached implementation. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d like to, but it don&apos;t let me.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;error: lib/go/test/OptionalFieldsTest.thrift: No such file or directory
error: lib/go/test/tests/optional_fields_test.go: No such file or directory
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13967263" author="apesternikov" created="Fri, 11 Apr 2014 23:59:28 +0000"  >&lt;p&gt;Oops the patch was broken, sorry for that.&lt;br/&gt;
regenerated...&lt;/p&gt;</comment>
                            <comment id="13970115" author="jensg" created="Tue, 15 Apr 2014 22:09:11 +0000"  >&lt;p&gt;The longer I look at the generated code (either case), the more things I find that need to be reviewed.&lt;/p&gt;

&lt;p&gt;1. As Aleksey has demonstrated, and my tests confirm this, a nil slice and an empty slice can be distinguished without the pointer mechanics. So that part is fine with me, and I think we should do it this way.&lt;/p&gt;

&lt;p&gt;2. &quot;&lt;em&gt;I think it&apos;s unintuitive that the addition of a default to an optional field would change the generated Go type of the related field&lt;/em&gt;&quot; - I agree here as well as on the statement, that a default changes the &lt;tt&gt;IsSet()&lt;/tt&gt; logic back to comparing with magic values. But that&apos;s exactly what&apos;s specified in &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt;, so it can&apos;t be completely wrong (assumed that &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2429&quot; title=&quot;Provide option to not write default values, rely on receiver default construction instead&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2429&quot;&gt;THRIFT-2429&lt;/a&gt; defines what we have/want/should consider as the &quot;truth&quot; here). I&apos;m not completely sure about this point, but looking at the overall &lt;a href=&quot;http://thrift.apache.org/about&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;project values&lt;/a&gt; again, the performance gain can&apos;t be ignored, and shouldn&apos;t. Bottom line: After thinking about it, I tend slightly more to the opinion, that we probably should do this as well. &lt;/p&gt;

&lt;p&gt;3. I&apos;m a little puzzled about the additional &lt;tt&gt;GetXxx()&lt;/tt&gt; and &lt;tt&gt;IsSetXxx()&lt;/tt&gt; methods that are now generated, but not (or not consequently) used in the generated code itself. Instead, we have places where a direct &lt;tt&gt;nil&lt;/tt&gt; check is performed, sometimes followed by the call to &lt;tt&gt;IsSetXxx)()&lt;/tt&gt;, which checks the same pointer against &lt;tt&gt;nil&lt;/tt&gt; again (BTW, this is also true with the old code, look at DetailsWanted below).&lt;/p&gt;

&lt;p&gt;4. I&apos;m somewhat more puzzled about the fact, that those &lt;tt&gt;GetXxx()&lt;/tt&gt; and &lt;tt&gt;IsSetXxx()&lt;/tt&gt; methods are generated for &lt;tt&gt;required&lt;/tt&gt; fields as well, always returning &lt;tt&gt;true&lt;/tt&gt;. What do we need these for? First, a &lt;tt&gt;required&lt;/tt&gt; field is always set, by definition. There is no such thing as an unset &lt;tt&gt;required&lt;/tt&gt; field - that&apos;s exactly why these methods always return &lt;tt&gt;true&lt;/tt&gt;. &lt;/p&gt;

&lt;p&gt;5. Next, the &lt;tt&gt;IsSetXxx()&lt;/tt&gt;  methods for &lt;tt&gt;required&lt;/tt&gt; return &lt;tt&gt;true&lt;/tt&gt;, even when the (pointer) field is &lt;tt&gt;nil&lt;/tt&gt;, which it surprisingly can be, because a pointer-field is generated here as well:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; Details {
  Everything = 0
  StateOnly = 1
  StateAndOptions = 2
  SomethingElse = 3
}

typedef list&amp;lt; Details&amp;gt;  DetailsWanted

struct BaseRequest {
  1 : optional string RequestID
}

struct GetMyDetails {
  1 : required BaseRequest base_
  2 : required string ObjectID
  3 : optional DetailsWanted DetailsWanted
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;gives me&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;type GetMyDetails struct {
	Base_         *BaseRequest  `thrift:&lt;span class=&quot;code-quote&quot;&gt;&quot;base_,1,required&quot;&lt;/span&gt;`      &lt;span class=&quot;code-comment&quot;&gt;// why pointer? 
&lt;/span&gt;	ObjectID      string        `thrift:&lt;span class=&quot;code-quote&quot;&gt;&quot;ObjectID,2,required&quot;&lt;/span&gt;`
	DetailsWanted DetailsWanted `thrift:&lt;span class=&quot;code-quote&quot;&gt;&quot;DetailsWanted,3&quot;&lt;/span&gt;`
}

func (p *GetMyDetails) GetBase_() *BaseRequest {
	&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; p.Base_   &lt;span class=&quot;code-comment&quot;&gt;// may be nil?
&lt;/span&gt;}

func (p *GetMyDetails) IsSetBase_() bool {
	&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;      &lt;span class=&quot;code-comment&quot;&gt;// even in the nil &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;?
&lt;/span&gt;}

func (p *GetMyDetails) IsSetDetailsWanted() bool {
	&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; p.DetailsWanted != nil  
}

func (p *GetMyDetails) writeField3(oprot thrift.TProtocol) (err error) {
	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; p.DetailsWanted != nil {       &lt;span class=&quot;code-comment&quot;&gt;// nil test #1
&lt;/span&gt;		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; p.IsSetDetailsWanted() {   &lt;span class=&quot;code-comment&quot;&gt;// nil test #2
&lt;/span&gt;		  ...
		}
	}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I commented all the relevant places in the code above. I&apos;m fully aware that some points go beyond the initial scope of this ticket, but they belong into that area as well, and that&apos;s why I mention them here.&lt;/p&gt;

&lt;p&gt;Comments?&lt;/p&gt;</comment>
                            <comment id="13970327" author="apesternikov" created="Wed, 16 Apr 2014 01:46:43 +0000"  >&lt;p&gt;GetXxx() is basically a convenience method returning the value or default value to use by client code. It is idiomatic to use zero value (which is a variety of default) as &quot;not present&quot;, right? we all are doing &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; func f() (string, error)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;, not &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;func f() (*string, error)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;. I started using new pointers API and found myself writing something like this all the time:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; s string
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; thriftstruct.field != nil {
  s = *thriftstruct.field
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So that was the motivation for GetXxx(), also inspired by the way PB is dealing with it.&lt;br/&gt;
I added IsSet* for required field just for consistency, but it is probably overkill.&lt;br/&gt;
I assume double checking for nil is a bug related to enums, I will check. I certainly need to find all places where we do != nil.&lt;br/&gt;
nil pointers for required fields are not surprising at all, for example any required struct field is a pointer, and I have a mixed feeling about it. I would rather prefer to have it inlined, but it means we may start copying struct values somewhere we don&apos;t want, so I have no strong opinion on that.&lt;br/&gt;
To conclude: I will remove IsSet* for required fields and fix null double checking.&lt;/p&gt;

</comment>
                            <comment id="13970631" author="jensg" created="Wed, 16 Apr 2014 10:02:22 +0000"  >&lt;blockquote&gt;
&lt;p&gt;nil pointers for required fields are not surprising at all, for example any required struct field is a pointer, and I have a mixed feeling about it. I would rather prefer to have it inlined, but it means we may start copying struct values somewhere we don&apos;t want, &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Are you aware, that this very same argument could be applied to the non-pointer optional fields with defaults? If we do the one but ignore the other, it starts looking arbitrary and inconsistent. That&apos;s what I for sure don&apos;t want. If we have two cases (pointer vs. non-pointer), we should at least be able to explain it in a logical fashion. &lt;/p&gt;

&lt;p&gt;But speaking about that, I found another issue with non-pointer-fields (both optional or required): Having them would require us to add special handling for the new &lt;tt&gt;cpp.ref&lt;/tt&gt; annotation for those cases, where you &lt;b&gt;want&lt;/b&gt; it to be a pointer. The benefit of the annotation would be that it would be only applied in exactly such cases, manually by editing the IDL, not affecting the performance of the non-pointerized fields. And yes, there are (and will be) use cases for this.&lt;/p&gt;

&lt;p&gt;In my opinion, we should do it all or nothing: &lt;b&gt;Either we want to sacrifice the (more consistent) &quot;all-pointers&quot; style to performance wherever possible, or we don&apos;t.&lt;/b&gt; I&apos;m strongly against producing an &lt;a href=&quot;http://www.dict.cc/deutsch-englisch/Mischmasch.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Mischmasch&lt;/a&gt;-solution here It is already complex enough. there is really no need to make it more complicated as it already is.&lt;/p&gt;</comment>
                            <comment id="13971413" author="apesternikov" created="Wed, 16 Apr 2014 13:49:04 +0000"  >&lt;p&gt;Absolutely agree, I&apos;ll take a look at cpp.ref and inline structs as well.&lt;br/&gt;
well probably go.ref or golang.ref instead of cpp.ref?&lt;/p&gt;</comment>
                            <comment id="13971767" author="jensg" created="Wed, 16 Apr 2014 18:18:53 +0000"  >&lt;p&gt;Quite the opposite. Because &lt;tt&gt;cpp.ref&lt;/tt&gt; would serve exactly the same purpose, it would be better to remove the &quot;cpp&quot; part, IMHO =&amp;gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2471&quot; title=&quot;Make cpp.ref annotation language agnostic&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2471&quot;&gt;&lt;del&gt;THRIFT-2471&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13973622" author="githubbot" created="Fri, 18 Apr 2014 00:25:54 +0000"  >&lt;p&gt;GitHub user apesternikov opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/101&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/101&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Go inlines&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2451&quot; title=&quot;Do not use pointers for optional fields with defaults. Do not write such fields if its value set to default. Also, do not use pointers for any optional fields mapped to go map or slice. generate Get accessors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2451&quot;&gt;&lt;del&gt;THRIFT-2451&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/apesternikov/thrift&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apesternikov/thrift&lt;/a&gt; go_inlines&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/101.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/101.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #101&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit e6e5dcf3a07cd931183991ff031179b425e2740b&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-16T14:06:52Z&lt;/p&gt;

&lt;p&gt;    initial change&lt;/p&gt;

&lt;p&gt;commit f65730e951a4310160a9f7e3e4eeb7e55abd2c55&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-16T14:16:03Z&lt;/p&gt;

&lt;p&gt;    no IsSet for required&lt;/p&gt;

&lt;p&gt;commit 9865f700eb9354d6053994da989a907766c42d1d&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-17T19:32:13Z&lt;/p&gt;

&lt;p&gt;    inlined required structs&lt;/p&gt;

&lt;p&gt;commit ca52300c07cefcf553f1ebf35569953c933b2367&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-17T19:44:24Z&lt;/p&gt;

&lt;p&gt;    do not use heap for args struct&lt;/p&gt;

&lt;p&gt;commit 012ca3e512d2bc8822de8a715b4f3d3cae5c0c42&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-17T19:52:41Z&lt;/p&gt;

&lt;p&gt;    do not use heap for result struct&lt;/p&gt;

&lt;p&gt;commit 2fc4afc53ff7db43e08eadeaa30e34bc1fd9c889&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-17T21:32:43Z&lt;/p&gt;

&lt;p&gt;    do not set result field on error&lt;/p&gt;

&lt;p&gt;commit 6e5da0062b139f02dcafe3148cdf02f97c23442a&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-mbp.att.net&amp;gt;&lt;br/&gt;
Date:   2014-04-17T21:57:57Z&lt;/p&gt;

&lt;p&gt;    Jens&apos; thrift source as test case&lt;/p&gt;

&lt;p&gt;commit 7317957ed708831e280f182f081043fbe9d38a0c&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-macbook-pro.local&amp;gt;&lt;br/&gt;
Date:   2014-04-17T23:43:08Z&lt;/p&gt;

&lt;p&gt;    support for cpp.ref&lt;/p&gt;

&lt;p&gt;commit 1c4f3efc7b54fd335db633f86faf8c426ae9c87d&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-macbook-pro.local&amp;gt;&lt;br/&gt;
Date:   2014-04-18T00:13:24Z&lt;/p&gt;

&lt;p&gt;    package flag&lt;/p&gt;

&lt;p&gt;commit c9d7e54f5c5d29c776f42fb861bc9e82da4e542f&lt;br/&gt;
Author: Aleksey Pesternikov &amp;lt;ap@alekseys-macbook-pro.local&amp;gt;&lt;br/&gt;
Date:   2014-04-18T00:21:18Z&lt;/p&gt;

&lt;p&gt;    Merge branch &apos;master&apos; into go_inlines&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="13987089" author="jensg" created="Thu, 1 May 2014 22:27:13 +0000"  >&lt;p&gt;Committed. The only thing that catched my interest was the global static package flag. Why is it global, and have you really tested that with includes? &lt;/p&gt;</comment>
                            <comment id="13987090" author="githubbot" created="Thu, 1 May 2014 22:28:27 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/thrift/pull/101&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/thrift/pull/101&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13988104" author="hudson" created="Fri, 2 May 2014 19:09:27 +0000"  >&lt;p&gt;SUCCESS: Integrated in Thrift #1145 (See &lt;a href=&quot;https://builds.apache.org/job/Thrift/1145/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/Thrift/1145/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/THRIFT-2451&quot; title=&quot;Do not use pointers for optional fields with defaults. Do not write such fields if its value set to default. Also, do not use pointers for any optional fields mapped to go map or slice. generate Get accessors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;THRIFT-2451&quot;&gt;&lt;del&gt;THRIFT-2451&lt;/del&gt;&lt;/a&gt;: Do not use pointers for optional fields with defaults. Do not write such fields if its value set to default. Also, do not use pointers for any optional fields mapped to go map or slice. generate Get accessors (jensg: rev 731975a645e47c931fbbc42ac51c12b0873a50c2)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;lib/go/test/tests/optional_fields_test.go&lt;/li&gt;
	&lt;li&gt;compiler/cpp/src/generate/t_go_generator.cc&lt;/li&gt;
	&lt;li&gt;lib/go/test/RefAnnotationFieldsTest.thrift&lt;/li&gt;
	&lt;li&gt;lib/go/test/ServicesTest.thrift&lt;/li&gt;
	&lt;li&gt;lib/go/test/tests/protocol_mock.go&lt;/li&gt;
	&lt;li&gt;lib/go/thrift/pointerize.go&lt;/li&gt;
	&lt;li&gt;lib/go/test/Makefile.am&lt;/li&gt;
	&lt;li&gt;lib/go/test/OptionalFieldsTest.thrift&lt;/li&gt;
	&lt;li&gt;lib/go/test/TypedefFieldTest.thrift&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12704253">THRIFT-2429</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12639891" name="thrift-2451-v2.patch" size="41176" author="apesternikov" created="Fri, 11 Apr 2014 23:59:28 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>385128</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 29 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310041" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Patch Info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10042"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1ucj3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>385395</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>