<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 07:57:59 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[THRIFT-845] async client does not respect timeout</title>
                <link>https://issues.apache.org/jira/browse/THRIFT-845</link>
                <project id="12310800" key="THRIFT">Thrift</project>
                    <description>&lt;p&gt;there effectively is no timeout on calls via the async client, so the consumer may never be called back with either a success or error.  this is not an awesome contract, and it also leaves the potential for the client itself to leak.  ning is working on a patch for this based on the below discussion:&lt;/p&gt;

&lt;p&gt;implementing the timeout inside TAsyncClientManager seems pretty easy, we would just loop through Selector.keys() there and make sure none of them have been waiting for longer than the SO_TIMEOUT we set on its TNonblockingSocket, if one is, we just do methodCall.onError on it to make sure the caller is notified.&lt;/p&gt;

&lt;p&gt;We also need to change Selector.select() to Selector.select(long timeout), with a small value so that the selector thread wakes up with sufficient granularity to timeout calls.&lt;/p&gt;

&lt;p&gt;I think we can just track the timeout of the pending operation within TAsyncMethodCall itself and loop over Selector.keys() to check them.  But since we just made the change to leave the keys for all open connections registered with the selector until they are closed, this could be somewhat costly.&lt;/p&gt;

&lt;p&gt;For reference, here&apos;s how jetty does this (&lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.eclipse.jetty/jetty-io/8.0.0.M0/org/eclipse/jetty/io/nio/SelectorManager.java#SelectorManager&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://grepcode.com/file/repo1.maven.org/maven2/org.eclipse.jetty/jetty-io/8.0.0.M0/org/eclipse/jetty/io/nio/SelectorManager.java#SelectorManager&lt;/a&gt;) which i do &lt;em&gt;not&lt;/em&gt; encourage you to read, but i am confident from reading it that it&apos;s doing just what i said:  tracking the list of outstanding read/write operations and their timeouts themselves, looping through them within the selector thread, and closing their sockets if their so-called &quot;idle timeout&quot; has expired.&lt;/p&gt;

&lt;p&gt;Also, there are a couple java selector bugs jetty links to that we should be aware of, the only one applicable to us has been fixed in jdk 1.6 update 18 (the latest is 21).  &lt;/p&gt;</description>
                <environment></environment>
        <key id="12471233">THRIFT-845</key>
            <summary>async client does not respect timeout</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ning">Ning Liang</assignee>
                                    <reporter username="ericcj">Eric Jensen</reporter>
                        <labels>
                    </labels>
                <created>Tue, 10 Aug 2010 20:58:04 +0000</created>
                <updated>Mon, 23 Aug 2010 19:30:09 +0000</updated>
                            <resolved>Thu, 19 Aug 2010 21:44:23 +0000</resolved>
                                    <version>0.4</version>
                    <version>0.5</version>
                                    <fixVersion>0.5</fixVersion>
                                    <component>Java - Library</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                    <workratio workratioPercent="0"/>
                                    <progress percentage="0">
                                    <originalProgress>
                                                    <row percentage="100" backgroundColor="#89afd7"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="0" backgroundColor="#51a825"/>
                                                    <row percentage="100" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="0">
                                    <originalProgress>
                                                    <row percentage="100" backgroundColor="#89afd7"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="0" backgroundColor="#51a825"/>
                                                    <row percentage="100" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                    <timeoriginalestimate seconds="86400">24h</timeoriginalestimate>
                            <timeestimate seconds="86400">24h</timeestimate>
                                        <comments>
                            <comment id="12899092" author="ning" created="Mon, 16 Aug 2010 21:12:52 +0000"  >&lt;p&gt;Attached is a patch that implements a first draft of timeouts. Summary:&lt;/p&gt;

&lt;p&gt;1) Allow setting timeout on calling client, through either constructor or a setter&lt;br/&gt;
2) On a method call, note the start time if the calling client timeout is &amp;gt; 0&lt;br/&gt;
3) On each method transition, update the time stamp&lt;br/&gt;
4) Scan through all method calls with timeouts in selector thread, calling onError with a TimeoutException for those that have exceeded idle limit.&lt;/p&gt;

&lt;p&gt;Added a test case in TestAsyncClientManager&lt;/p&gt;</comment>
                            <comment id="12899211" author="ericcj@gmail.com" created="Tue, 17 Aug 2010 00:41:38 +0000"  >&lt;p&gt;Woop woop!  Thanks for doing this.  Did you look at that jetty selector loop?  It has me scared.  Hopefully we dont need all that crap if we upgrade the jvm...maybe thrift async should have release notes to that effect?&lt;/p&gt;

&lt;p&gt;eric&lt;/p&gt;


</comment>
                            <comment id="12899483" author="bryanduxbury" created="Tue, 17 Aug 2010 17:31:06 +0000"  >&lt;p&gt;Some thoughts:&lt;br/&gt;
-Could we move the tracking of last action into TAsyncMethodCall? I&apos;m wary of putting hashmap accesses into such a sensitive loop.&lt;br/&gt;
-I&apos;d prefer if you stored long milliseconds since epoch instead of Date objects. We don&apos;t need the Date abstraction.&lt;br/&gt;
-The catch blocks in startPendingMethodCalls seem very redundant. I think it would make more sense to just reduce it to a single catch (Throwable t) block. Also, you should log the exception before you call the onError, since there&apos;s the possibility that onError could fail for some reason.&lt;/p&gt;

&lt;p&gt;Otherwise, this is a great patch, and the tests pass for me. With the slight revisions above, I&apos;ll be happy to commit this.&lt;/p&gt;</comment>
                            <comment id="12899604" author="ning" created="Tue, 17 Aug 2010 21:42:24 +0000"  >&lt;p&gt;-Could we move the tracking of last action into TAsyncMethodCall? I&apos;m wary of putting hashmap accesses into such a sensitive loop.&lt;/p&gt;

&lt;p&gt;  Done. Although I&apos;m keeping a hash set of TAsyncMethodCall to loop over for timing out.&lt;/p&gt;

&lt;p&gt;-I&apos;d prefer if you stored long milliseconds since epoch instead of Date objects. We don&apos;t need the Date abstraction.&lt;/p&gt;

&lt;p&gt;  Done.&lt;/p&gt;

&lt;p&gt;-The catch blocks in startPendingMethodCalls seem very redundant. I think it would make more sense to just reduce it to a single catch (Throwable t) block. Also, you should log the exception before you call the onError, since there&apos;s the possibility that onError could fail for some reason.&lt;/p&gt;

&lt;p&gt;  Done. Good catch.&lt;/p&gt;</comment>
                            <comment id="12899610" author="ning" created="Tue, 17 Aug 2010 21:46:22 +0000"  >&lt;p&gt;Also, yes, we should definitely note the minimum java version for fixing the broken Selector.select() issue (&lt;a href=&quot;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6525190&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6525190&lt;/a&gt;)&lt;/p&gt;</comment>
                            <comment id="12899719" author="ning" created="Wed, 18 Aug 2010 03:26:19 +0000"  >&lt;p&gt;I realized I made an oversight - we need to be very careful about how we manage the timeout watch set to avoid a buildup of set members.&lt;/p&gt;</comment>
                            <comment id="12899929" author="bryanduxbury" created="Wed, 18 Aug 2010 17:49:53 +0000"  >&lt;p&gt;Don&apos;t use new Date().getTime(). Use System.currentTimeMillis() instead. &lt;/p&gt;

&lt;p&gt;In timeoutIdleMethods, you shouldn&apos;t be calling remove() within the loop. This will cause a ConcurrentModificationException if there is more than one item in the set.&lt;/p&gt;

&lt;p&gt;In transitionMethods, you don&apos;t need to check if a given method call is in the watch set before trying to remove it - the remove operation will just return false if the item wasn&apos;t present in the first place.&lt;/p&gt;</comment>
                            <comment id="12900118" author="ning" created="Thu, 19 Aug 2010 00:13:59 +0000"  >&lt;p&gt;Don&apos;t use new Date().getTime(). Use System.currentTimeMillis() instead.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Done&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In timeoutIdleMethods, you shouldn&apos;t be calling remove() within the loop. This will cause a ConcurrentModificationException if there is more than one item in the set.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Only the select thread modifies the timeoutWatchSet - methods are entered when they are popped off the pending queue, not when they&apos;re pushed on.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In transitionMethods, you don&apos;t need to check if a given method call is in the watch set before trying to remove it - the remove operation will just return false if the item wasn&apos;t present in the first place.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Done&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Also fixed a bug with how we do timeout checks.&lt;/p&gt;</comment>
                            <comment id="12900124" author="bryanduxbury" created="Thu, 19 Aug 2010 00:38:11 +0000"  >&lt;blockquote&gt;&lt;p&gt;Only the select thread modifies the timeoutWatchSet - methods are entered when they are popped off the pending queue, not when they&apos;re pushed on.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Having threads involved is only one way to get a ConcurrentModification exception. Try this code out:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.HashSet;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;QuickTest {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
    HashSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; set = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt;();
    set.add(&lt;span class=&quot;code-quote&quot;&gt;&quot;blah&quot;&lt;/span&gt;);
    set.add(&lt;span class=&quot;code-quote&quot;&gt;&quot;blah2&quot;&lt;/span&gt;);

    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s : set) {
      set.remove(&lt;span class=&quot;code-quote&quot;&gt;&quot;blah2&quot;&lt;/span&gt;);
    }
  }
}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you try to remove any value from the set that is actually in the set, whether it is the current element being iterated or not, causes a CME. Trying to remove an element not in the set will not throw any exception. And if the item you are removing is the &lt;b&gt;only&lt;/b&gt; item in the set, then you also won&apos;t get an exception.&lt;/p&gt;</comment>
                            <comment id="12900199" author="ning" created="Thu, 19 Aug 2010 07:30:18 +0000"  >&lt;p&gt;How about:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;// Timeout any existing method calls
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void timeoutIdleMethods() {
  Iterator&amp;lt;TAsyncMethodCall&amp;gt; iterator = timeoutWatchSet.iterator();
  &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (iterator.hasNext()) {
    TAsyncMethodCall methodCall = iterator.next();
    &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; clientTimeout = methodCall.getClient().getTimeout();
    &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; timeElapsed = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis() - methodCall.getLastTransitionTime();
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (timeElapsed &amp;gt; clientTimeout) {
      iterator.remove();
      &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; message = &lt;span class=&quot;code-quote&quot;&gt;&quot;Operation &quot;&lt;/span&gt; + methodCall.getClass() + &lt;span class=&quot;code-quote&quot;&gt;&quot; timed out after &quot;&lt;/span&gt; + timeElapsed + &lt;span class=&quot;code-quote&quot;&gt;&quot; milliseconds.&quot;&lt;/span&gt;;
      methodCall.onError(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TimeoutException(message));
    }
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12900307" author="bryanduxbury" created="Thu, 19 Aug 2010 15:17:54 +0000"  >&lt;p&gt;That looks right. Is that in the latest rev of the patch?&lt;/p&gt;</comment>
                            <comment id="12900387" author="ning" created="Thu, 19 Aug 2010 18:19:24 +0000"  >&lt;p&gt;Yes, great catch, btw.&lt;/p&gt;</comment>
                            <comment id="12900477" author="bryanduxbury" created="Thu, 19 Aug 2010 21:44:23 +0000"  >&lt;p&gt;Great, I just committed the latest version (with minor whitespace edits). Thanks for the ambitious patch, Ning!&lt;/p&gt;</comment>
                            <comment id="12901111" author="ericcj" created="Sat, 21 Aug 2010 23:16:40 +0000"  >&lt;p&gt;this is awesome for us...thanks so much for implementing it.  something about the way the timeout, selector keys, client state, and method state are spread across several classes makes it scary to me...there&apos;s probably a way to refactor into something more centralized that would be easier to reason about.  could we make at least one of these things stateless?  &lt;/p&gt;

&lt;p&gt;for example, when we time something out we call methodCall.onError, which closes the transport, which i think prevents it from showing up in selectedKeys() again, but if it did we would throw our IllegalStateException because we set the error state but didn&apos;t cancel the key (since we didn&apos;t have access to it from the timeout loop).  &lt;/p&gt;

&lt;p&gt;also, a few small things, probably not worth re-opening, but worth fixing in another patch:&lt;/p&gt;

&lt;p&gt;1.  Timeouts per-transition aren&apos;t really what I want as a consumer of this api.  It looks like there are about five states, which as a consumer I need to know since the effective timeout on the whole call is then 5x the one I set.  I&apos;d rather be guaranteed I will be called back one way or another within the timeout i set, counting time i spend in the selector&apos;s queue, etc.  Seems like that would be easy to implement.  &lt;/p&gt;

&lt;p&gt;2.  You should not be allowed to set a timeout lower than TAsyncClientManager.SELECT_TIME, and the value there should be much lower, maybe 5ms?  Because its per-transition as above, the true minimum timeout for an entire call is 1s if each of its states took 200ms.  We&apos;ve actually run clients with lower than 200ms timeouts.  &lt;/p&gt;

&lt;p&gt;3.  TAsyncMethodCall.onError does not do anything to remove itself from TAsyncClientManager.timeoutWatchSet, so unless it shows up in selectedKeys() it will stay there until its timeout.  Not a big deal, but could make that set prohibitively large if there are many errors within a timeout interval.  &lt;/p&gt;

&lt;p&gt;4.  We call TAsyncMethodCall.transition before adding it to timeoutWatchSet, so lastTransitionTime is initialized before it is inspected.  But, this is a somewhat dangerous pattern to allow an uninitialized primitive to ever be accessible.  You should probably initialize it to the current time or a sentinel on instantiation.&lt;/p&gt;

&lt;p&gt;5.  it might be safer for lastTransitionTime = System.currentTimeMillis() to be at the top of transition(SelectionKey key) so you can guarantee the timestamp is updated even for errant transitions...don&apos;t think it matter&apos;s functionally in the current code, but it could in refactorings.  you don&apos;t want to inadvertently obscure an error with a timeout.  &lt;/p&gt;

&lt;p&gt;6.  TNonblockingServerSocket is the only non-test, non-tutorial thrift source file that uses System.err.println instead of LOGGER.warn&lt;/p&gt;

&lt;p&gt;7.  You might want to catch Exception instead of Throwable?  I don&apos;t think you intend or want to catch things like OutOfMemoryError, etc.  The docs say &quot;An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch&quot;&lt;/p&gt;

&lt;p&gt;8.  TAsyncClientManager.call should really throw an exception if its SelectThread is not running (because its run method did not catch an unexpected Throwable) instead of inserting it into a queue that will grow unbounded and cause an OOM.  You probably want a catch and throw block in run that cleans up by calling onError on all pending calls and sets its done flag.  You probably also want to do this on ClosedSelectorException instead of just catching and logging it in an infinite loop. It&apos;s odd that you catch it on selectedKeys() but not select().  &lt;/p&gt;

&lt;p&gt;9.  timeoutIdleMethods would be a bit faster if it only called currentTimeMillis() once instead of per-check&lt;/p&gt;

&lt;p&gt;10.  Probably an unnecessary optimization, but instead of relying on Object.hashCode for removing timed out methods, you could identify them by their start timestamp from currentTimeMillis() + a few bits of a static atomic sequence counter, put them in a TreeSet, and shortcut the iteration for timed out methods when you hit the first one that&apos;s not too old.  &lt;/p&gt;</comment>
                            <comment id="12901112" author="ericcj" created="Sat, 21 Aug 2010 23:25:14 +0000"  >&lt;p&gt;also, reading through the jetty selector, i noticed they do:&lt;/p&gt;


&lt;p&gt;651                        if (!key.isValid())&lt;br/&gt;
652                        {&lt;br/&gt;
653                            key.cancel();&lt;/p&gt;

&lt;p&gt;in their selector loop.  we do:&lt;/p&gt;

&lt;p&gt;          if (!key.isValid()) &lt;/p&gt;
{
            continue;
          }

&lt;p&gt;we should probably log at info level or something here...i fear we could be seeing the same invalid keys over and over again and burning more and more cpu skipping them over time.  maybe we should be logging the size of Selector.keys(), pendingCalls, and timeoutWatchSet at debug level periodically so we have visibility into leakage errors.&lt;/p&gt;</comment>
                            <comment id="12901551" author="ning" created="Mon, 23 Aug 2010 19:27:40 +0000"  >&lt;p&gt;Hey Eric,&lt;/p&gt;

&lt;p&gt;You bring up some good points. We have indirect communication between the client manager and client going through the method call object, which we can refactor into direct communication. I&apos;d like to keep the state machine separate from the async client manager, though - the client manager only coordinates transitioning the method call on ready. Responses inline for the other comments:&lt;/p&gt;

&lt;p&gt;1. Timeouts per-transition aren&apos;t really what I want as a consumer of this api. It looks like there are about five states, which as a consumer I need to know since the effective timeout on the whole call is then 5x the one I set. I&apos;d rather be guaranteed I will be called back one way or another within the timeout i set, counting time i spend in the selector&apos;s queue, etc. Seems like that would be easy to implement.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The naming is misleading - we can have idle socket timeout or an overall method call timeout (more like a deadline). I coded for the former case, so we can modify to the latter or rename. Modifying is trivial - we just need to track the method call start time, as opposed to the last action time. The effective deadline is arbitrarily long, since we&apos;re updating the last action timestamp on each socket read/write, which doesn&apos;t necessarily correspond to a transition between method states.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2. You should not be allowed to set a timeout lower than TAsyncClientManager.SELECT_TIME, and the value there should be much lower, maybe 5ms? Because its per-transition as above, the true minimum timeout for an entire call is 1s if each of its states took 200ms. We&apos;ve actually run clients with lower than 200ms timeouts.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Agreed, though we won&apos;t be able to get to 5ms resolution. The reason is because the JVM makes no guarantees on actual sleep time. Maybe a better solution would be to use Selector.selectNow(), which returns immediately with all ready keys, making our timeout granularity as small as possible.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3. TAsyncMethodCall.onError does not do anything to remove itself from TAsyncClientManager.timeoutWatchSet, so unless it shows up in selectedKeys() it will stay there until its timeout. Not a big deal, but could make that set prohibitively large if there are many errors within a timeout interval.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TAsyncClientManager removes the method after a transition if the method&apos;s client.hasError(). Again, somewhat confusing since it&apos;s relying on the method calling the client&apos;s onError.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;4. We call TAsyncMethodCall.transition before adding it to timeoutWatchSet, so lastTransitionTime is initialized before it is inspected. But, this is a somewhat dangerous pattern to allow an uninitialized primitive to ever be accessible. You should probably initialize it to the current time or a sentinel on instantiation.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Current time is good - if we end up using the deadline definition of timeout, we don&apos;t even have to update the value.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;5. it might be safer for lastTransitionTime = System.currentTimeMillis() to be at the top of transition(SelectionKey key) so you can guarantee the timestamp is updated even for errant transitions...don&apos;t think it matter&apos;s functionally in the current code, but it could in refactorings. you don&apos;t want to inadvertently obscure an error with a timeout.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Good point. I wanted the timestamp to reflect the last socket activity - putting at the beginning of transition could make it inaccurate on long socket reads/writes. Maybe we can use the finally block?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;6. TNonblockingServerSocket is the only non-test, non-tutorial thrift source file that uses System.err.println instead of LOGGER.warn&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;We can easily fix.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;7. You might want to catch Exception instead of Throwable? I don&apos;t think you intend or want to catch things like OutOfMemoryError, etc. The docs say &quot;An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch&quot;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Also easily fixed, though I want to make sure we didn&apos;t do this for a reason earlier. Bryan, why Throwable vs Exception?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;8. TAsyncClientManager.call should really throw an exception if its SelectThread is not running (because its run method did not catch an unexpected Throwable) instead of inserting it into a queue that will grow unbounded and cause an OOM. You probably want a catch and throw block in run that cleans up by calling onError on all pending calls and sets its done flag. You probably also want to do this on ClosedSelectorException instead of just catching and logging it in an infinite loop. It&apos;s odd that you catch it on selectedKeys() but not select().&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;That catch got folded into the catch(Throwable)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;9. timeoutIdleMethods would be a bit faster if it only called currentTimeMillis() once instead of per-check&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Good point. I was going for accuracy but even for large timeout watch sets the iteration time should be negligible.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;10. Probably an unnecessary optimization, but instead of relying on Object.hashCode for removing timed out methods, you could identify them by their start timestamp from currentTimeMillis() + a few bits of a static atomic sequence counter, put them in a TreeSet, and shortcut the iteration for timed out methods when you hit the first one that&apos;s not too old. &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Definitely, this was the original plan. We&apos;ll get it in on next iteration.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12901552" author="ning" created="Mon, 23 Aug 2010 19:30:09 +0000"  >&lt;p&gt;Also, we do a remove() call on the iterator while looping through methods, which should remove the key from the selector&apos;s key set.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12452497" name="async_timeout.diff" size="14223" author="ning" created="Thu, 19 Aug 2010 07:30:18 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>186993</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            15 years, 14 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i16e1r:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>245408</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>