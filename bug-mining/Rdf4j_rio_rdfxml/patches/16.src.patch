diff --git a/core/rio/rdfxml/pom.xml b/core/rio/rdfxml/pom.xml
deleted file mode 100644
index b5218b56a6..0000000000
--- a/core/rio/rdfxml/pom.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-	<modelVersion>4.0.0</modelVersion>
-	
-	<parent>
-		<groupId>org.eclipse.rdf4j</groupId>
-		<artifactId>rdf4j-rio</artifactId>
-		<version>2.3-SNAPSHOT</version>
-	</parent>
-
-	<artifactId>rdf4j-rio-rdfxml</artifactId>
-
-	<name>RDF4J: Rio - RDF/XML</name>
-	<description>Rio parser and writer implementation for the RDF/XML file format.</description>
-
-	<dependencies>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-model</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-rio-api</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-rio-datatypes</artifactId>
-			<version>${project.version}</version>
-			<scope>runtime</scope>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-rio-languages</artifactId>
-			<version>${project.version}</version>
-			<scope>runtime</scope>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-util</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>commons-io</groupId>
-			<artifactId>commons-io</artifactId>
-		</dependency>
-
-		<dependency>
-			<groupId>junit</groupId>
-			<artifactId>junit</artifactId>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.hamcrest</groupId>
-			<artifactId>hamcrest-library</artifactId>
-			<scope>test</scope>
-		</dependency>
-	</dependencies>
-</project>
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/Att.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/Att.java
deleted file mode 100644
index 88d76e041f..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/Att.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-/**
- * An XML attribute.
- */
-class Att {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	private String namespace;
-
-	private String localName;
-
-	private String qName;
-
-	private String value;
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	public Att(String namespace, String localName, String qName, String value) {
-		this.namespace = namespace;
-		this.localName = localName;
-		this.qName = qName;
-		this.value = value;
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	public String getNamespace() {
-		return namespace;
-	}
-
-	public String getLocalName() {
-		return localName;
-	}
-
-	public String getURI() {
-		return namespace + localName;
-	}
-
-	public String getQName() {
-		return qName;
-	}
-
-	public String getValue() {
-		return value;
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/Atts.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/Atts.java
deleted file mode 100644
index d7b9bca5bf..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/Atts.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * A collection of XML attributes.
- */
-class Atts {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	/**
-	 * List containing Att objects.
-	 */
-	private List<Att> attributes;
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new <tt>Atts</tt> object.
-	 */
-	public Atts() {
-		this(4);
-	}
-
-	/**
-	 * Creates a new <tt>Atts</tt> object.
-	 * 
-	 * @param size
-	 *        The initial size of the array for storing attributes.
-	 */
-	public Atts(int size) {
-		attributes = new ArrayList<Att>(size);
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	/**
-	 * Adds an attribute.
-	 */
-	public void addAtt(Att att) {
-		attributes.add(att);
-	}
-
-	/**
-	 * Get an iterator on the attributes.
-	 * 
-	 * @return an Iterator over Att objects.
-	 */
-	public Iterator<Att> iterator() {
-		return attributes.iterator();
-	}
-
-	/**
-	 * Gets the attribute with the specified QName.
-	 * 
-	 * @param qName
-	 *        The QName of an attribute.
-	 * @return The attribute with the specified QName, or <tt>null</tt> if no such attribute could be found.
-	 */
-	public Att getAtt(String qName) {
-		for (int i = 0; i < attributes.size(); i++) {
-			Att att = attributes.get(i);
-
-			if (att.getQName().equals(qName)) {
-				return att;
-			}
-		}
-
-		return null;
-	}
-
-	/**
-	 * Gets the attribute with the specified namespace and local name.
-	 * 
-	 * @param namespace
-	 *        The namespace of an attribute.
-	 * @param localName
-	 *        The local name of an attribute.
-	 * @return The attribute with the specified namespace and local name, or <tt>null</tt> if no such
-	 *         attribute could be found.
-	 */
-	public Att getAtt(String namespace, String localName) {
-		for (int i = 0; i < attributes.size(); i++) {
-			Att att = attributes.get(i);
-
-			if (att.getLocalName().equals(localName) && att.getNamespace().equals(namespace)) {
-				return att;
-			}
-		}
-
-		return null;
-	}
-
-	/**
-	 * Removes the attribute with the specified QName and returns it.
-	 * 
-	 * @param qName
-	 *        The QName of an attribute.
-	 * @return The removed attribute, or <tt>null</tt> if no attribute with the specified QName could be
-	 *         found.
-	 */
-	public Att removeAtt(String qName) {
-		for (int i = 0; i < attributes.size(); i++) {
-			Att att = attributes.get(i);
-
-			if (att.getQName().equals(qName)) {
-				attributes.remove(i);
-				return att;
-			}
-		}
-
-		return null;
-	}
-
-	/**
-	 * Removes the attribute with the specified namespace and local name and returns it.
-	 * 
-	 * @param namespace
-	 *        The namespace of an attribute.
-	 * @param localName
-	 *        The local name of an attribute.
-	 * @return The removed attribute, or <tt>null</tt> if no attribute with the specified namespace and local
-	 *         name could be found.
-	 */
-	public Att removeAtt(String namespace, String localName) {
-		for (int i = 0; i < attributes.size(); i++) {
-			Att att = attributes.get(i);
-
-			if (att.getLocalName().equals(localName) && att.getNamespace().equals(namespace)) {
-				attributes.remove(i);
-				return att;
-			}
-		}
-
-		return null;
-	}
-
-	/**
-	 * Returns the number of attributes contained in this object.
-	 */
-	public int size() {
-		return attributes.size();
-	}
-
-	/**
-	 * Produces a String-representation of this object.
-	 */
-	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append("Atts[");
-		for (int i = 0; i < attributes.size(); i++) {
-			Att att = attributes.get(i);
-			sb.append(att.getQName());
-			sb.append("=");
-			sb.append(att.getValue());
-			sb.append("; ");
-		}
-		sb.append("]");
-		return sb.toString();
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParser.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParser.java
deleted file mode 100644
index 39becb56d2..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParser.java
+++ /dev/null
@@ -1,1434 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.Stack;
-
-import javax.xml.transform.sax.SAXResult;
-
-import org.apache.commons.io.input.BOMInputStream;
-import org.eclipse.rdf4j.common.net.ParsedURI;
-import org.eclipse.rdf4j.common.xml.XMLReaderFactory;
-import org.eclipse.rdf4j.common.xml.XMLUtil;
-import org.eclipse.rdf4j.model.BNode;
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Literal;
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.Value;
-import org.eclipse.rdf4j.model.ValueFactory;
-import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.RDFParseException;
-import org.eclipse.rdf4j.rio.RioSetting;
-import org.eclipse.rdf4j.rio.helpers.AbstractRDFParser;
-import org.eclipse.rdf4j.rio.helpers.XMLParserSettings;
-import org.xml.sax.ErrorHandler;
-import org.xml.sax.InputSource;
-import org.xml.sax.Locator;
-import org.xml.sax.SAXException;
-import org.xml.sax.SAXNotRecognizedException;
-import org.xml.sax.SAXNotSupportedException;
-import org.xml.sax.SAXParseException;
-import org.xml.sax.XMLReader;
-
-/**
- * A parser for XML-serialized RDF. This parser operates directly on the SAX events generated by a SAX-enabled
- * XML parser. The XML parser should be compliant with SAX2. You should specify which SAX parser should be
- * used by setting the <code>org.xml.sax.driver</code> property. This parser is not thread-safe, therefore
- * it's public methods are synchronized.
- * <p>
- * To parse a document using this parser:
- * <ul>
- * <li>Create an instance of RDFXMLParser, optionally supplying it with your own ValueFactory.
- * <li>Set the RDFHandler.
- * <li>Optionally, set the ParseErrorListener and/or ParseLocationListener.
- * <li>Optionally, specify whether the parser should verify the data it parses and whether it should stop
- * immediately when it finds an error in the data (both default to <tt>true</tt>).
- * <li>Call the parse method.
- * </ul>
- * Example code:
- * 
- * <pre>
- * // Use the SAX2-compliant Xerces parser:
- * System.setProperty(&quot;org.xml.sax.driver&quot;, &quot;org.apache.xerces.parsers.SAXParser&quot;);
- * 
- * RDFParser parser = new RDFXMLParser();
- * parser.setRDFHandler(myRDFHandler);
- * parser.setParseErrorListener(myParseErrorListener);
- * parser.setVerifyData(true);
- * parser.stopAtFirstError(false);
- * 
- * // Parse the data from inputStream, resolving any
- * // relative URIs against http://foo/bar:
- * parser.parse(inputStream, &quot;http://foo/bar&quot;);
- * </pre>
- * 
- * @see org.eclipse.rdf4j.model.ValueFactory
- * @see org.eclipse.rdf4j.rio.RDFHandler
- * @see org.eclipse.rdf4j.rio.ParseErrorListener
- * @see org.eclipse.rdf4j.rio.ParseLocationListener
- * @author Arjohn Kampman
- */
-public class RDFXMLParser extends AbstractRDFParser implements ErrorHandler {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	/**
-	 * A filter filtering calls to SAX methods specifically for this parser.
-	 */
-	private SAXFilter saxFilter;
-
-	/**
-	 * The base URI of the document. This variable is set when <tt>parse(inputStream, baseURI)</tt> is called
-	 * and will not be changed during parsing.
-	 */
-	private String documentURI;
-
-	/**
-	 * The language of literal values as can be specified using xml:lang attributes. This variable is
-	 * set/modified by the SAXFilter during parsing such that it always represents the language of the context
-	 * in which elements are reported.
-	 */
-	private String xmlLang;
-
-	/**
-	 * A stack of node- and property elements.
-	 */
-	private Stack<Object> elementStack = new Stack<Object>();
-
-	/**
-	 * A set containing URIs that have been generated as a result of rdf:ID attributes. These URIs should be
-	 * unique within a single document.
-	 */
-	private Set<IRI> usedIDs = new HashSet<IRI>();
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new RDFXMLParser that will use a {@link SimpleValueFactory} to create RDF model objects.
-	 */
-	public RDFXMLParser() {
-		this(SimpleValueFactory.getInstance());
-	}
-
-	/**
-	 * Creates a new RDFXMLParser that will use the supplied <tt>ValueFactory</tt> to create RDF model
-	 * objects.
-	 * 
-	 * @param valueFactory
-	 *        A ValueFactory.
-	 */
-	public RDFXMLParser(ValueFactory valueFactory) {
-		super(valueFactory);
-
-		// SAXFilter does some filtering and verifying of SAX events
-		saxFilter = new SAXFilter(this);
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	@Override
-	public final RDFFormat getRDFFormat() {
-		return RDFFormat.RDFXML;
-	}
-
-	/**
-	 * Sets the parser in a mode to parse stand-alone RDF documents. In stand-alone RDF documents, the
-	 * enclosing <tt>rdf:RDF</tt> root element is optional if this root element contains just one element
-	 * (e.g. <tt>rdf:Description</tt>.
-	 */
-	public void setParseStandAloneDocuments(boolean standAloneDocs) {
-		getParserConfig().set(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS, standAloneDocs);
-	}
-
-	/**
-	 * Returns whether the parser is currently in a mode to parse stand-alone RDF documents.
-	 * 
-	 * @see #setParseStandAloneDocuments
-	 */
-	public boolean getParseStandAloneDocuments() {
-		return getParserConfig().get(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS);
-	}
-
-	/**
-	 * Parses the data from the supplied InputStream, using the supplied baseURI to resolve any relative URI
-	 * references.
-	 * 
-	 * @param in
-	 *        The InputStream from which to read the data, must not be <tt>null</tt>.
-	 * @param baseURI
-	 *        The URI associated with the data in the InputStream, must not be <tt>null</tt>.
-	 * @throws IOException
-	 *         If an I/O error occurred while data was read from the InputStream.
-	 * @throws RDFParseException
-	 *         If the parser has found an unrecoverable parse error.
-	 * @throws RDFHandlerException
-	 *         If the configured statement handler encountered an unrecoverable error.
-	 * @throws IllegalArgumentException
-	 *         If the supplied input stream or base URI is <tt>null</tt>.
-	 */
-	@Override
-	public synchronized void parse(InputStream in, String baseURI)
-		throws IOException, RDFParseException, RDFHandlerException
-	{
-		if (in == null) {
-			throw new IllegalArgumentException("Input stream cannot be 'null'");
-		}
-		if (baseURI == null) {
-			throw new IllegalArgumentException("Base URI cannot be 'null'");
-		}
-
-		InputSource inputSource = new InputSource(new BOMInputStream(in, false));
-		inputSource.setSystemId(baseURI);
-
-		parse(inputSource);
-	}
-
-	/**
-	 * Parses the data from the supplied Reader, using the supplied baseURI to resolve any relative URI
-	 * references.
-	 * 
-	 * @param reader
-	 *        The Reader from which to read the data, must not be <tt>null</tt>.
-	 * @param baseURI
-	 *        The URI associated with the data in the InputStream, must not be <tt>null</tt>.
-	 * @throws IOException
-	 *         If an I/O error occurred while data was read from the InputStream.
-	 * @throws RDFParseException
-	 *         If the parser has found an unrecoverable parse error.
-	 * @throws RDFHandlerException
-	 *         If the configured statement handler has encountered an unrecoverable error.
-	 * @throws IllegalArgumentException
-	 *         If the supplied reader or base URI is <tt>null</tt>.
-	 */
-	@Override
-	public synchronized void parse(Reader reader, String baseURI)
-		throws IOException, RDFParseException, RDFHandlerException
-	{
-		if (reader == null) {
-			throw new IllegalArgumentException("Reader cannot be 'null'");
-		}
-		if (baseURI == null) {
-			throw new IllegalArgumentException("Base URI cannot be 'null'");
-		}
-
-		InputSource inputSource = new InputSource(reader);
-		inputSource.setSystemId(baseURI);
-
-		parse(inputSource);
-	}
-
-	private void parse(InputSource inputSource)
-		throws IOException, RDFParseException, RDFHandlerException
-	{
-		clear();
-		
-		try {
-			documentURI = inputSource.getSystemId();
-
-			saxFilter.setParseStandAloneDocuments(
-					getParserConfig().get(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS));
-
-			// saxFilter.clear();
-			saxFilter.setDocumentURI(documentURI);
-
-			XMLReader xmlReader;
-
-			if (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {
-				xmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);
-			}
-			else {
-				xmlReader = XMLReaderFactory.createXMLReader();
-			}
-
-			xmlReader.setContentHandler(saxFilter);
-			xmlReader.setErrorHandler(this);
-
-			// Set all compulsory feature settings, using the defaults if they are
-			// not explicitly set
-			for (RioSetting<Boolean> aSetting : getCompulsoryXmlFeatureSettings()) {
-				try {
-					xmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));
-				}
-				catch (SAXNotRecognizedException e) {
-					reportWarning(String.format("%s is not a recognized SAX feature.", aSetting.getKey()));
-				}
-				catch (SAXNotSupportedException e) {
-					reportWarning(String.format("%s is not a supported SAX feature.", aSetting.getKey()));
-				}
-			}
-
-			// Set all compulsory property settings, using the defaults if they are
-			// not explicitly set
-			for (RioSetting<?> aSetting : getCompulsoryXmlPropertySettings()) {
-				try {
-					xmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));
-				}
-				catch (SAXNotRecognizedException e) {
-					reportWarning(String.format("%s is not a recognized SAX property.", aSetting.getKey()));
-				}
-				catch (SAXNotSupportedException e) {
-					reportWarning(String.format("%s is not a supported SAX property.", aSetting.getKey()));
-				}
-			}
-
-			// Check for any optional feature settings that are explicitly set in
-			// the parser config
-			for (RioSetting<Boolean> aSetting : getOptionalXmlFeatureSettings()) {
-				try {
-					if (getParserConfig().isSet(aSetting)) {
-						xmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));
-					}
-				}
-				catch (SAXNotRecognizedException e) {
-					reportWarning(String.format("%s is not a recognized SAX feature.", aSetting.getKey()));
-				}
-				catch (SAXNotSupportedException e) {
-					reportWarning(String.format("%s is not a supported SAX feature.", aSetting.getKey()));
-				}
-			}
-
-			// Check for any optional property settings that are explicitly set in
-			// the parser config
-			for (RioSetting<?> aSetting : getOptionalXmlPropertySettings()) {
-				try {
-					if (getParserConfig().isSet(aSetting)) {
-						xmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));
-					}
-				}
-				catch (SAXNotRecognizedException e) {
-					reportWarning(String.format("%s is not a recognized SAX property.", aSetting.getKey()));
-				}
-				catch (SAXNotSupportedException e) {
-					reportWarning(String.format("%s is not a supported SAX property.", aSetting.getKey()));
-				}
-			}
-
-			xmlReader.parse(inputSource);
-		}
-		catch (SAXParseException e) {
-			Exception wrappedExc = e.getException();
-
-			if (wrappedExc == null) {
-				reportFatalError(e, e.getLineNumber(), e.getColumnNumber());
-			}
-			else {
-				reportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());
-			}
-		}
-		catch (SAXException e) {
-			Exception wrappedExc = e.getException();
-
-			if (wrappedExc == null) {
-				reportFatalError(e);
-			}
-			else if (wrappedExc instanceof RDFParseException) {
-				throw (RDFParseException)wrappedExc;
-			}
-			else if (wrappedExc instanceof RDFHandlerException) {
-				throw (RDFHandlerException)wrappedExc;
-			}
-			else {
-				reportFatalError(wrappedExc);
-			}
-		}
-		finally {
-			// Clean up
-			saxFilter.clear();
-			xmlLang = null;
-			elementStack.clear();
-			usedIDs.clear();
-			clear();
-		}
-	}
-
-	/**
-	 * Returns a collection of settings that will always be set as XML parser properties using
-	 * {@link XMLReader#setProperty(String, Object)}
-	 * <p>
-	 * Subclasses can override this to specify more supported settings.
-	 * 
-	 * @return A collection of {@link RioSetting}s that indicate which properties will always be setup using
-	 *         {@link XMLReader#setProperty(String, Object)}.
-	 */
-	public Collection<RioSetting<?>> getCompulsoryXmlPropertySettings() {
-		return Collections.<RioSetting<?>> emptyList();
-	}
-
-	/**
-	 * Returns a collection of settings that will always be set as XML parser features using
-	 * {@link XMLReader#setFeature(String, boolean)}.
-	 * <p>
-	 * Subclasses can override this to specify more supported settings.
-	 * 
-	 * @return A collection of {@link RioSetting}s that indicate which boolean settings will always be setup
-	 *         using {@link XMLReader#setFeature(String, boolean)}.
-	 */
-	public Collection<RioSetting<Boolean>> getCompulsoryXmlFeatureSettings() {
-		Set<RioSetting<Boolean>> results = new HashSet<RioSetting<Boolean>>();
-		results.add(XMLParserSettings.SECURE_PROCESSING);
-		return results;
-	}
-
-	/**
-	 * Returns a collection of settings that will be used, if set in {@link #getParserConfig()}, as XML parser
-	 * properties using {@link XMLReader#setProperty(String, Object)}
-	 * <p>
-	 * Subclasses can override this to specify more supported settings.
-	 * 
-	 * @return A collection of {@link RioSetting}s that indicate which properties can be setup using
-	 *         {@link XMLReader#setProperty(String, Object)}.
-	 */
-	public Collection<RioSetting<?>> getOptionalXmlPropertySettings() {
-		return Collections.<RioSetting<?>> emptyList();
-	}
-
-	/**
-	 * Returns a collection of settings that will be used, if set in {@link #getParserConfig()}, as XML parser
-	 * features using {@link XMLReader#setFeature(String, boolean)}.
-	 * <p>
-	 * Subclasses can override this to specify more supported settings.
-	 * 
-	 * @return A collection of {@link RioSetting}s that indicate which boolean settings can be setup using
-	 *         {@link XMLReader#setFeature(String, boolean)}.
-	 */
-	public Collection<RioSetting<Boolean>> getOptionalXmlFeatureSettings() {
-		Set<RioSetting<Boolean>> results = new HashSet<RioSetting<Boolean>>();
-		results.add(XMLParserSettings.LOAD_EXTERNAL_DTD);
-		return results;
-	}
-
-	@Override
-	public Collection<RioSetting<?>> getSupportedSettings() {
-		// Override to add RDF/XML specific supported settings
-		Set<RioSetting<?>> results = new HashSet<RioSetting<?>>(super.getSupportedSettings());
-
-		results.addAll(getCompulsoryXmlPropertySettings());
-		results.addAll(getCompulsoryXmlFeatureSettings());
-		results.addAll(getOptionalXmlPropertySettings());
-		results.addAll(getOptionalXmlFeatureSettings());
-
-		results.add(XMLParserSettings.CUSTOM_XML_READER);
-		results.add(XMLParserSettings.FAIL_ON_DUPLICATE_RDF_ID);
-		results.add(XMLParserSettings.FAIL_ON_INVALID_NCNAME);
-		results.add(XMLParserSettings.FAIL_ON_INVALID_QNAME);
-		results.add(XMLParserSettings.FAIL_ON_MISMATCHED_TAGS);
-		results.add(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-		results.add(XMLParserSettings.FAIL_ON_SAX_NON_FATAL_ERRORS);
-		results.add(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS);
-
-		return results;
-	}
-
-	public SAXResult getSAXResult(String baseURI) {
-		if (baseURI == null) {
-			throw new IllegalArgumentException("Base URI cannot be 'null'");
-		}
-		documentURI = baseURI;
-		saxFilter.setDocumentURI(baseURI);
-
-		return new SAXResult(saxFilter);
-	}
-
-	void startDocument()
-		throws RDFParseException, RDFHandlerException
-	{
-		if (rdfHandler != null) {
-			rdfHandler.startRDF();
-		}
-	}
-
-	void endDocument()
-		throws RDFParseException, RDFHandlerException
-	{
-		if (rdfHandler != null) {
-			rdfHandler.endRDF();
-		}
-	}
-
-	/*-----------------------------*
-	 * Methods called by SAXFilter *
-	 *-----------------------------*/
-
-	@Override
-	protected void setBaseURI(ParsedURI baseURI) {
-		// Note: we need to override this method to allow SAXFilter to access it
-		super.setBaseURI(baseURI);
-	}
-
-	@Override
-	protected void setBaseURI(String baseURI) {
-		// Note: we need to override this method to allow SAXFilter to access it
-		super.setBaseURI(baseURI);
-	}
-
-	void setXMLLang(String xmlLang) {
-		if ("".equals(xmlLang)) {
-			this.xmlLang = null;
-		}
-		else {
-			this.xmlLang = xmlLang;
-		}
-	}
-
-	void startElement(String namespaceURI, String localName, String qName, Atts atts)
-		throws RDFParseException, RDFHandlerException
-	{
-		if (topIsProperty()) {
-			// this element represents the subject and/or object of a statement
-			processNodeElt(namespaceURI, localName, qName, atts, false);
-		}
-		else {
-			// this element represents a property
-			processPropertyElt(namespaceURI, localName, qName, atts, false);
-		}
-	}
-
-	void endElement(String namespaceURI, String localName, String qName)
-		throws RDFParseException, RDFHandlerException
-	{
-		Object topElement = peekStack(0);
-
-		if (topElement instanceof NodeElement) {
-			// Check if top node is 'volatile', meaning that it doesn't have a
-			// start- and end element associated with it.
-			if (((NodeElement)topElement).isVolatile()) {
-				elementStack.pop();
-			}
-		}
-		else {
-			// topElement instanceof PropertyElement
-			PropertyElement predicate = (PropertyElement)topElement;
-
-			if (predicate.parseCollection()) {
-				Resource lastListResource = predicate.getLastListResource();
-
-				if (lastListResource == null) {
-					// no last list resource, list must have been empty.
-					NodeElement subject = (NodeElement)peekStack(1);
-
-					reportStatement(subject.getResource(), predicate.getURI(), RDF.NIL);
-
-					handleReification(RDF.NIL);
-				}
-				else {
-					// Generate the final tail of the list.
-					reportStatement(lastListResource, RDF.REST, RDF.NIL);
-				}
-			}
-
-		}
-
-		elementStack.pop();
-	}
-
-	void emptyElement(String namespaceURI, String localName, String qName, Atts atts)
-		throws RDFParseException, RDFHandlerException
-	{
-		if (topIsProperty()) {
-			// this element represents the subject and/or object of a statement
-			processNodeElt(namespaceURI, localName, qName, atts, true);
-		}
-		else {
-			// this element represents a property
-			processPropertyElt(namespaceURI, localName, qName, atts, true);
-		}
-	}
-
-	void text(String text)
-		throws RDFParseException, RDFHandlerException
-	{
-		if (!topIsProperty()) {
-			reportError("unexpected literal", XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-			return;
-		}
-
-		PropertyElement propEl = (PropertyElement)peekStack(0);
-		IRI datatype = propEl.getDatatype();
-
-		Literal lit = createLiteral(text, xmlLang, datatype);
-
-		NodeElement subject = (NodeElement)peekStack(1);
-		PropertyElement predicate = (PropertyElement)peekStack(0);
-
-		reportStatement(subject.getResource(), predicate.getURI(), lit);
-
-		handleReification(lit);
-	}
-
-	/*------------------------*
-	 * RDF processing methods *
-	 *------------------------*/
-
-	/* Process a node element (can be both subject and object) */
-	private void processNodeElt(String namespaceURI, String localName, String qName, Atts atts,
-			boolean isEmptyElt)
-		throws RDFParseException, RDFHandlerException
-	{
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-			// Check the element name
-			checkNodeEltName(namespaceURI, localName, qName);
-		}
-
-		Resource nodeResource = getNodeResource(atts);
-		NodeElement nodeElement = new NodeElement(nodeResource);
-
-		if (!elementStack.isEmpty()) {
-			// node can be object of a statement, or part of an rdf:List
-			NodeElement subject = (NodeElement)peekStack(1);
-			PropertyElement predicate = (PropertyElement)peekStack(0);
-
-			if (predicate.parseCollection()) {
-				Resource lastListRes = predicate.getLastListResource();
-				BNode newListRes = createBNode();
-
-				if (lastListRes == null) {
-					// first element in the list
-					reportStatement(subject.getResource(), predicate.getURI(), newListRes);
-
-					handleReification(newListRes);
-				}
-				else {
-					// not the first element in the list
-					reportStatement(lastListRes, RDF.REST, newListRes);
-				}
-
-				reportStatement(newListRes, RDF.FIRST, nodeResource);
-
-				predicate.setLastListResource(newListRes);
-			}
-			else {
-				reportStatement(subject.getResource(), predicate.getURI(), nodeResource);
-
-				handleReification(nodeResource);
-			}
-		}
-
-		if (!localName.equals("Description") || !namespaceURI.equals(RDF.NAMESPACE)) {
-			// element name is uri's type
-			IRI className = null;
-			if ("".equals(namespaceURI)) {
-				// No namespace, use base URI
-				className = buildResourceFromLocalName(localName);
-			}
-			else {
-				className = createURI(namespaceURI + localName);
-			}
-			reportStatement(nodeResource, RDF.TYPE, className);
-		}
-
-		Att type = atts.removeAtt(RDF.NAMESPACE, "type");
-		if (type != null) {
-			// rdf:type attribute, value is a URI-reference
-			IRI className = resolveURI(type.getValue());
-
-			reportStatement(nodeResource, RDF.TYPE, className);
-		}
-
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-			checkRDFAtts(atts);
-		}
-
-		processSubjectAtts(nodeElement, atts);
-
-		if (!isEmptyElt) {
-			elementStack.push(nodeElement);
-		}
-	}
-
-	/**
-	 * Retrieves the resource of a node element (subject or object) using relevant attributes (rdf:ID,
-	 * rdf:about and rdf:nodeID) from its attributes list.
-	 * 
-	 * @return a resource or a bNode.
-	 */
-	private Resource getNodeResource(Atts atts)
-		throws RDFParseException
-	{
-		Att id = atts.removeAtt(RDF.NAMESPACE, "ID");
-		Att about = atts.removeAtt(RDF.NAMESPACE, "about");
-		Att nodeID = atts.removeAtt(RDF.NAMESPACE, "nodeID");
-
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-			int definedAttsCount = 0;
-
-			if (id != null) {
-				definedAttsCount++;
-			}
-			if (about != null) {
-				definedAttsCount++;
-			}
-			if (nodeID != null) {
-				definedAttsCount++;
-			}
-
-			if (definedAttsCount > 1) {
-				reportError("Only one of the attributes rdf:ID, rdf:about or rdf:nodeID can be used here",
-						XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-			}
-		}
-
-		Resource result = null;
-
-		if (id != null) {
-			result = buildURIFromID(id.getValue());
-		}
-		else if (about != null) {
-			result = resolveURI(about.getValue());
-		}
-		else if (nodeID != null) {
-			result = createBNode(nodeID.getValue());
-		}
-		else {
-			// No resource specified, generate a bNode
-			result = createBNode();
-		}
-
-		return result;
-	}
-
-	/** processes subject attributes. */
-	private void processSubjectAtts(NodeElement nodeElt, Atts atts)
-		throws RDFParseException, RDFHandlerException
-	{
-		Resource subject = nodeElt.getResource();
-
-		Iterator<Att> iter = atts.iterator();
-
-		while (iter.hasNext()) {
-			Att att = iter.next();
-
-			IRI predicate = createURI(att.getURI());
-			Literal lit = createLiteral(att.getValue(), xmlLang, null);
-
-			reportStatement(subject, predicate, lit);
-		}
-	}
-
-	private void processPropertyElt(String namespaceURI, String localName, String qName, Atts atts,
-			boolean isEmptyElt)
-		throws RDFParseException, RDFHandlerException
-	{
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-			checkPropertyEltName(namespaceURI, localName, qName,
-					XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-		}
-
-		// Get the URI of the property
-		IRI propURI = null;
-		if (namespaceURI.equals("")) {
-			// no namespace URI
-			reportError("unqualified property element <" + qName + "> not allowed",
-					XMLParserSettings.FAIL_ON_INVALID_QNAME);
-			// Use base URI as namespace:
-			propURI = buildResourceFromLocalName(localName);
-		}
-		else {
-			propURI = createURI(namespaceURI + localName);
-		}
-
-		// List expansion rule
-		if (propURI.equals(RDF.LI)) {
-			NodeElement subject = (NodeElement)peekStack(0);
-			propURI = createURI(RDF.NAMESPACE + "_" + subject.getNextLiCounter());
-		}
-
-		// Push the property on the stack.
-		PropertyElement predicate = new PropertyElement(propURI);
-		elementStack.push(predicate);
-
-		// Check if property has a reification ID
-		Att id = atts.removeAtt(RDF.NAMESPACE, "ID");
-		if (id != null) {
-			IRI reifURI = buildURIFromID(id.getValue());
-			predicate.setReificationURI(reifURI);
-		}
-
-		// Check for presence of rdf:parseType attribute
-		Att parseType = atts.removeAtt(RDF.NAMESPACE, "parseType");
-
-		if (parseType != null) {
-			if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-				checkNoMoreAtts(atts);
-			}
-
-			String parseTypeValue = parseType.getValue();
-
-			if (parseTypeValue.equals("Resource")) {
-				BNode objectResource = createBNode();
-				NodeElement subject = (NodeElement)peekStack(1);
-
-				reportStatement(subject.getResource(), propURI, objectResource);
-
-				if (isEmptyElt) {
-					handleReification(objectResource);
-				}
-				else {
-					NodeElement object = new NodeElement(objectResource);
-					object.setIsVolatile(true);
-					elementStack.push(object);
-				}
-			}
-			else if (parseTypeValue.equals("Collection")) {
-				if (isEmptyElt) {
-					NodeElement subject = (NodeElement)peekStack(1);
-					reportStatement(subject.getResource(), propURI, RDF.NIL);
-					handleReification(RDF.NIL);
-				}
-				else {
-					predicate.setParseCollection(true);
-				}
-			}
-			else {
-				// other parseType
-				if (!parseTypeValue.equals("Literal")) {
-					reportWarning("unknown parseType: " + parseType.getValue());
-				}
-
-				if (isEmptyElt) {
-					NodeElement subject = (NodeElement)peekStack(1);
-
-					Literal lit = createLiteral("", null, RDF.XMLLITERAL);
-
-					reportStatement(subject.getResource(), propURI, lit);
-
-					handleReification(lit);
-				}
-				else {
-					// The next string is an rdf:XMLLiteral
-					predicate.setDatatype(RDF.XMLLITERAL);
-
-					saxFilter.setParseLiteralMode();
-				}
-			}
-		}
-		// parseType == null
-		else if (isEmptyElt) {
-			// empty element without an rdf:parseType attribute
-
-			// Note: we handle rdf:datatype attributes here to allow datatyped
-			// empty strings in documents. The current spec does have a
-			// production rule that matches this, which is likely to be an
-			// omission on its part.
-			Att datatype = atts.getAtt(RDF.NAMESPACE, "datatype");
-
-			if (atts.size() == 0 || atts.size() == 1 && datatype != null) {
-				// element had no attributes, or only the optional
-				// rdf:ID and/or rdf:datatype attributes.
-				NodeElement subject = (NodeElement)peekStack(1);
-
-				IRI dtURI = null;
-				if (datatype != null) {
-					dtURI = createURI(datatype.getValue());
-				}
-
-				Literal lit = createLiteral("", xmlLang, dtURI);
-
-				reportStatement(subject.getResource(), propURI, lit);
-				handleReification(lit);
-			}
-			else {
-				// Create resource for the statement's object.
-				Resource resourceRes = getPropertyResource(atts);
-
-				// All special rdf attributes have been checked/removed.
-				if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-					checkRDFAtts(atts);
-				}
-
-				NodeElement resourceElt = new NodeElement(resourceRes);
-				NodeElement subject = (NodeElement)peekStack(1);
-
-				reportStatement(subject.getResource(), propURI, resourceRes);
-				handleReification(resourceRes);
-
-				Att type = atts.removeAtt(RDF.NAMESPACE, "type");
-				if (type != null) {
-					// rdf:type attribute, value is a URI-reference
-					IRI className = resolveURI(type.getValue());
-
-					reportStatement(resourceRes, RDF.TYPE, className);
-				}
-
-				processSubjectAtts(resourceElt, atts);
-			}
-		}
-		else {
-			// Not an empty element, sub elements will follow.
-
-			// Check for rdf:datatype attribute
-			Att datatype = atts.removeAtt(RDF.NAMESPACE, "datatype");
-			if (datatype != null) {
-				IRI dtURI = resolveURI(datatype.getValue());
-				predicate.setDatatype(dtURI);
-			}
-
-			// No more attributes are expected.
-			if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-				checkNoMoreAtts(atts);
-			}
-		}
-
-		if (isEmptyElt) {
-			// Empty element has been pushed on the stack
-			// at the start of this method, remove it.
-			elementStack.pop();
-		}
-	}
-
-	/**
-	 * Retrieves the object resource of a property element using relevant attributes (rdf:resource and
-	 * rdf:nodeID) from its attributes list.
-	 * 
-	 * @return a resource or a bNode.
-	 */
-	private Resource getPropertyResource(Atts atts)
-		throws RDFParseException
-	{
-		Att resource = atts.removeAtt(RDF.NAMESPACE, "resource");
-		Att nodeID = atts.removeAtt(RDF.NAMESPACE, "nodeID");
-
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES)) {
-			int definedAttsCount = 0;
-
-			if (resource != null) {
-				definedAttsCount++;
-			}
-			if (nodeID != null) {
-				definedAttsCount++;
-			}
-
-			if (definedAttsCount > 1) {
-				reportError("Only one of the attributes rdf:resource or rdf:nodeID can be used here",
-						XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-			}
-		}
-
-		Resource result = null;
-
-		if (resource != null) {
-			result = resolveURI(resource.getValue());
-		}
-		else if (nodeID != null) {
-			result = createBNode(nodeID.getValue());
-		}
-		else {
-			// No resource specified, generate a bNode
-			result = createBNode();
-		}
-
-		return result;
-	}
-
-	/*
-	 * Processes any rdf:ID attributes that generate reified statements. This method assumes that a
-	 * PropertyElement (which can have an rdf:ID attribute) is on top of the stack, and a NodeElement is below
-	 * that.
-	 */
-	private void handleReification(Value value)
-		throws RDFParseException, RDFHandlerException
-	{
-		PropertyElement predicate = (PropertyElement)peekStack(0);
-
-		if (predicate.isReified()) {
-			NodeElement subject = (NodeElement)peekStack(1);
-			IRI reifRes = predicate.getReificationURI();
-			reifyStatement(reifRes, subject.getResource(), predicate.getURI(), value);
-		}
-	}
-
-	private void reifyStatement(Resource reifNode, Resource subj, IRI pred, Value obj)
-		throws RDFParseException, RDFHandlerException
-	{
-		reportStatement(reifNode, RDF.TYPE, RDF.STATEMENT);
-		reportStatement(reifNode, RDF.SUBJECT, subj);
-		reportStatement(reifNode, RDF.PREDICATE, pred);
-		reportStatement(reifNode, RDF.OBJECT, obj);
-	}
-
-	/**
-	 * Builds a Resource from a non-qualified localname.
-	 */
-	private IRI buildResourceFromLocalName(String localName)
-		throws RDFParseException
-	{
-		return resolveURI("#" + localName);
-	}
-
-	/**
-	 * Builds a Resource from the value of an rdf:ID attribute.
-	 */
-	private IRI buildURIFromID(String id)
-		throws RDFParseException
-	{
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_INVALID_NCNAME)) {
-			// Check if 'id' is a legal NCName
-			if (!XMLUtil.isNCName(id)) {
-				reportError("Not an XML Name: " + id, XMLParserSettings.FAIL_ON_INVALID_NCNAME);
-			}
-		}
-
-		IRI uri = resolveURI("#" + id);
-
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_DUPLICATE_RDF_ID)) {
-			// ID (URI) should be unique in the current document
-			if (!usedIDs.add(uri)) {
-				// URI was not added because the set already contained an equal
-				// strings
-				reportError("ID '" + id + "' has already been defined",
-						XMLParserSettings.FAIL_ON_DUPLICATE_RDF_ID);
-			}
-		}
-
-		return uri;
-	}
-
-	@Override
-	protected BNode createBNode(String nodeID)
-		throws RDFParseException
-	{
-		if (getParserConfig().get(XMLParserSettings.FAIL_ON_INVALID_NCNAME)) {
-			// Check if 'nodeID' is a legal NCName
-			if (!XMLUtil.isNCName(nodeID)) {
-				reportError("Not an XML Name: " + nodeID, XMLParserSettings.FAIL_ON_INVALID_NCNAME);
-			}
-		}
-
-		return super.createBNode(nodeID);
-	}
-
-	private Object peekStack(int distFromTop) {
-		return elementStack.get(elementStack.size() - 1 - distFromTop);
-	}
-
-	private boolean topIsProperty() {
-		return elementStack.isEmpty() || peekStack(0) instanceof PropertyElement;
-	}
-
-	/**
-	 * Checks whether the node element name is from the RDF namespace and, if so, if it is allowed to be used
-	 * in a node element. If the name is equal to one of the disallowed names (RDF, ID, about, parseType,
-	 * resource, nodeID, datatype and li), an error is generated. If the name is not defined in the RDF
-	 * namespace, but it claims that it is from this namespace, a warning is generated.
-	 */
-	private void checkNodeEltName(String namespaceURI, String localName, String qName)
-		throws RDFParseException
-	{
-		if (RDF.NAMESPACE.equals(namespaceURI)) {
-
-			if (localName.equals("Description") || localName.equals("Seq") || localName.equals("Bag")
-					|| localName.equals("Alt") || localName.equals("Statement")
-					|| localName.equals("Property") || localName.equals("List") || localName.equals("subject")
-					|| localName.equals("predicate") || localName.equals("object") || localName.equals("type")
-					|| localName.equals("value") || localName.equals("first") || localName.equals("rest")
-					|| localName.equals("nil") || localName.startsWith("_"))
-			{
-				// These are OK
-			}
-			else if (localName.equals("li") || localName.equals("RDF") || localName.equals("ID")
-					|| localName.equals("about") || localName.equals("parseType")
-					|| localName.equals("resource") || localName.equals("nodeID")
-					|| localName.equals("datatype"))
-			{
-				reportError("<" + qName + "> not allowed as node element",
-						XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-			}
-			else if (localName.equals("bagID") || localName.equals("aboutEach")
-					|| localName.equals("aboutEachPrefix"))
-			{
-				reportError(qName + " is no longer a valid RDF name",
-						XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-			}
-			else {
-				reportWarning("unknown rdf element <" + qName + ">");
-			}
-		}
-	}
-
-	/**
-	 * Checks whether the property element name is from the RDF namespace and, if so, if it is allowed to be
-	 * used in a property element. If the name is equal to one of the disallowed names (RDF, ID, about,
-	 * parseType, resource and li), an error is generated. If the name is not defined in the RDF namespace,
-	 * but it claims that it is from this namespace, a warning is generated.
-	 * 
-	 * @param setting
-	 */
-	private void checkPropertyEltName(String namespaceURI, String localName, String qName,
-			RioSetting<Boolean> setting)
-		throws RDFParseException
-	{
-		if (RDF.NAMESPACE.equals(namespaceURI)) {
-
-			if (localName.equals("li") || localName.equals("Seq") || localName.equals("Bag")
-					|| localName.equals("Alt") || localName.equals("Statement")
-					|| localName.equals("Property") || localName.equals("List") || localName.equals("subject")
-					|| localName.equals("predicate") || localName.equals("object") || localName.equals("type")
-					|| localName.equals("value") || localName.equals("first") || localName.equals("rest")
-					|| localName.equals("nil") || localName.startsWith("_"))
-			{
-				// These are OK
-			}
-			else if (localName.equals("Description") || localName.equals("RDF") || localName.equals("ID")
-					|| localName.equals("about") || localName.equals("parseType")
-					|| localName.equals("resource") || localName.equals("nodeID")
-					|| localName.equals("datatype"))
-			{
-				reportError("<" + qName + "> not allowed as property element", setting);
-			}
-			else if (localName.equals("bagID") || localName.equals("aboutEach")
-					|| localName.equals("aboutEachPrefix"))
-			{
-				reportError(qName + " is no longer a valid RDF name", setting);
-			}
-			else {
-				reportWarning("unknown rdf element <" + qName + ">");
-			}
-		}
-	}
-
-	/**
-	 * Checks whether 'atts' contains attributes from the RDF namespace that are not allowed as attributes. If
-	 * such an attribute is found, an error is generated and the attribute is removed from 'atts'. If the
-	 * attribute is not defined in the RDF namespace, but it claims that it is from this namespace, a warning
-	 * is generated.
-	 */
-	private void checkRDFAtts(Atts atts)
-		throws RDFParseException
-	{
-		Iterator<Att> iter = atts.iterator();
-
-		while (iter.hasNext()) {
-			Att att = iter.next();
-
-			if (RDF.NAMESPACE.equals(att.getNamespace())) {
-				String localName = att.getLocalName();
-
-				if (localName.equals("Seq") || localName.equals("Bag") || localName.equals("Alt")
-						|| localName.equals("Statement") || localName.equals("Property")
-						|| localName.equals("List") || localName.equals("subject")
-						|| localName.equals("predicate") || localName.equals("object")
-						|| localName.equals("type") || localName.equals("value") || localName.equals("first")
-						|| localName.equals("rest") || localName.equals("nil") || localName.startsWith("_"))
-				{
-					// These are OK
-				}
-				else if (localName.equals("Description") || localName.equals("li") || localName.equals("RDF")
-						|| localName.equals("ID") || localName.equals("about")
-						|| localName.equals("parseType") || localName.equals("resource")
-						|| localName.equals("nodeID") || localName.equals("datatype"))
-				{
-					reportError("'" + att.getQName() + "' not allowed as attribute name",
-							XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-					iter.remove();
-				}
-				else if (localName.equals("bagID") || localName.equals("aboutEach")
-						|| localName.equals("aboutEachPrefix"))
-				{
-					reportError(att.getQName() + " is no longer a valid RDF name",
-							XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-				}
-				else {
-					reportWarning("unknown rdf attribute '" + att.getQName() + "'");
-				}
-			}
-		}
-	}
-
-	/**
-	 * Checks whether 'atts' is empty. If this is not the case, a warning is generated for each attribute that
-	 * is still present.
-	 */
-	private void checkNoMoreAtts(Atts atts)
-		throws RDFParseException
-	{
-		if (atts.size() > 0) {
-			Iterator<Att> iter = atts.iterator();
-
-			while (iter.hasNext()) {
-				Att att = iter.next();
-
-				reportError("unexpected attribute '" + att.getQName() + "'",
-						XMLParserSettings.FAIL_ON_NON_STANDARD_ATTRIBUTES);
-				iter.remove();
-			}
-		}
-	}
-
-	/**
-	 * Reports a stament to the configured RDFHandlerException.
-	 * 
-	 * @param subject
-	 *        The statement's subject.
-	 * @param predicate
-	 *        The statement's predicate.
-	 * @param object
-	 *        The statement's object.
-	 * @throws RDFHandlerException
-	 *         If the configured RDFHandlerException throws an RDFHandlerException.
-	 */
-	private void reportStatement(Resource subject, IRI predicate, Value object)
-		throws RDFParseException, RDFHandlerException
-	{
-		Statement st = createStatement(subject, predicate, object);
-		if (rdfHandler != null) {
-			rdfHandler.handleStatement(st);
-		}
-	}
-
-	@Override
-	protected Literal createLiteral(String label, String lang, IRI datatype)
-		throws RDFParseException
-	{
-		Locator locator = saxFilter.getLocator();
-		if (locator != null) {
-			return createLiteral(label, lang, datatype, locator.getLineNumber(), locator.getColumnNumber());
-		}
-		else {
-			return createLiteral(label, lang, datatype, -1, -1);
-		}
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportWarning(String)}, adding line- and column number information
-	 * to the error.
-	 */
-	@Override
-	protected void reportWarning(String msg) {
-		Locator locator = saxFilter.getLocator();
-		if (locator != null) {
-			reportWarning(msg, locator.getLineNumber(), locator.getColumnNumber());
-		}
-		else {
-			reportWarning(msg, -1, -1);
-		}
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportError(String, RioSetting)}, adding line- and column number
-	 * information to the error.
-	 */
-	@Override
-	protected void reportError(String msg, RioSetting<Boolean> setting)
-		throws RDFParseException
-	{
-		Locator locator = saxFilter.getLocator();
-		if (locator != null) {
-			reportError(msg, locator.getLineNumber(), locator.getColumnNumber(), setting);
-		}
-		else {
-			reportError(msg, -1, -1, setting);
-		}
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportError(String, RioSetting)}, adding line- and column number
-	 * information to the error.
-	 */
-	@Override
-	protected void reportError(Exception e, RioSetting<Boolean> setting)
-		throws RDFParseException
-	{
-		Locator locator = saxFilter.getLocator();
-		if (locator != null) {
-			reportError(e, locator.getLineNumber(), locator.getColumnNumber(), setting);
-		}
-		else {
-			reportError(e, -1, -1, setting);
-		}
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportFatalError(String)}, adding line- and column number
-	 * information to the error.
-	 */
-	@Override
-	protected void reportFatalError(String msg)
-		throws RDFParseException
-	{
-		Locator locator = saxFilter.getLocator();
-		if (locator != null) {
-			reportFatalError(msg, locator.getLineNumber(), locator.getColumnNumber());
-		}
-		else {
-			reportFatalError(msg, -1, -1);
-		}
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportFatalError(Exception)}, adding line- and column number
-	 * information to the error.
-	 */
-	@Override
-	protected void reportFatalError(Exception e)
-		throws RDFParseException
-	{
-		Locator locator = saxFilter.getLocator();
-		if (locator != null) {
-			reportFatalError(e, locator.getLineNumber(), locator.getColumnNumber());
-		}
-		else {
-			reportFatalError(e, -1, -1);
-		}
-	}
-
-	/*-----------------------------------------------*
-	 * Inner classes NodeElement and PropertyElement *
-	 *-----------------------------------------------*/
-
-	static class NodeElement {
-
-		private Resource resource;
-
-		private boolean isVolatile = false;;
-
-		private int liCounter = 1;
-
-		public NodeElement(Resource resource) {
-			this.resource = resource;
-		}
-
-		public Resource getResource() {
-			return resource;
-		}
-
-		public void setIsVolatile(boolean isVolatile) {
-			this.isVolatile = isVolatile;
-		}
-
-		public boolean isVolatile() {
-			return isVolatile;
-		}
-
-		public int getNextLiCounter() {
-			return liCounter++;
-		}
-	}
-
-	static class PropertyElement {
-
-		/** The property URI. */
-		private IRI uri;
-
-		/** An optional reification identifier. */
-		private IRI reificationURI;
-
-		/** An optional datatype. */
-		private IRI datatype;
-
-		/**
-		 * Flag indicating whether this PropertyElement has an attribute <tt>rdf:parseType="Collection"</tt>.
-		 */
-		private boolean parseCollection = false;
-
-		/**
-		 * The resource that was used to append the last part of an rdf:List.
-		 */
-		private Resource lastListResource;
-
-		public PropertyElement(IRI uri) {
-			this.uri = uri;
-		}
-
-		public IRI getURI() {
-			return uri;
-		}
-
-		public boolean isReified() {
-			return reificationURI != null;
-		}
-
-		public void setReificationURI(IRI reifURI) {
-			this.reificationURI = reifURI;
-		}
-
-		public IRI getReificationURI() {
-			return reificationURI;
-		}
-
-		public void setDatatype(IRI datatype) {
-			this.datatype = datatype;
-		}
-
-		public IRI getDatatype() {
-			return datatype;
-		}
-
-		public boolean parseCollection() {
-			return parseCollection;
-		}
-
-		public void setParseCollection(boolean parseCollection) {
-			this.parseCollection = parseCollection;
-		}
-
-		public Resource getLastListResource() {
-			return lastListResource;
-		}
-
-		public void setLastListResource(Resource resource) {
-			lastListResource = resource;
-		}
-	}
-
-	/**
-	 * Implementation of SAX ErrorHandler.warning
-	 */
-	@Override
-	public void warning(SAXParseException exception)
-		throws SAXException
-	{
-		this.reportWarning(exception.getMessage());
-	}
-
-	/**
-	 * Implementation of SAX ErrorHandler.error
-	 */
-	@Override
-	public void error(SAXParseException exception)
-		throws SAXException
-	{
-		try {
-			this.reportError(exception, XMLParserSettings.FAIL_ON_SAX_NON_FATAL_ERRORS);
-		}
-		catch (RDFParseException rdfpe) {
-			throw new SAXException(rdfpe);
-		}
-	}
-
-	/**
-	 * Implementation of SAX ErrorHandler.fatalError
-	 */
-	@Override
-	public void fatalError(SAXParseException exception)
-		throws SAXException
-	{
-		try {
-			this.reportFatalError(exception);
-		}
-		catch (RDFParseException rdfpe) {
-			throw new SAXException(rdfpe);
-		}
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParserFactory.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParserFactory.java
deleted file mode 100644
index 91ff5d4b36..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParserFactory.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFParser;
-import org.eclipse.rdf4j.rio.RDFParserFactory;
-
-/**
- * An {@link RDFParserFactory} for RDF/XML parsers.
- * 
- * @author Arjohn Kampman
- */
-public class RDFXMLParserFactory implements RDFParserFactory {
-
-	/**
-	 * Returns the RDF format for this factory.
-	 */
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.RDFXML;
-	}
-
-	/**
-	 * Returns a new instance of RDFXMLParser.
-	 */
-	public RDFParser getParser() {
-		return new RDFXMLParser();
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriter.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriter.java
deleted file mode 100644
index b9e0bcc277..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriter.java
+++ /dev/null
@@ -1,560 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.nio.charset.Charset;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.common.xml.XMLUtil;
-import org.eclipse.rdf4j.model.BNode;
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Literal;
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.Value;
-import org.eclipse.rdf4j.model.util.Literals;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.RDFWriter;
-import org.eclipse.rdf4j.rio.helpers.AbstractRDFWriter;
-import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
-import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
-import org.eclipse.rdf4j.rio.helpers.XMLWriterSettings;
-
-/**
- * An implementation of the RDFWriter interface that writes RDF documents in XML-serialized RDF format.
- */
-public class RDFXMLWriter extends AbstractRDFWriter implements RDFWriter {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	protected ParsedIRI baseIRI;
-
-	protected Writer writer;
-
-	protected String defaultNamespace;
-
-	protected boolean writingStarted;
-
-	protected boolean headerWritten;
-
-	protected Resource lastWrittenSubject;
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new RDFXMLWriter that will write to the supplied OutputStream.
-	 * 
-	 * @param out
-	 *        The OutputStream to write the RDF/XML document to.
-	 */
-	public RDFXMLWriter(OutputStream out) {
-		this(out, null);
-	}
-
-	/**
-	 * Creates a new RDFXMLWriter that will write to the supplied OutputStream.
-	 *
-	 * @param out
-	 *        The OutputStream to write the RDF/XML document to.
-	 */
-	public RDFXMLWriter(OutputStream out, ParsedIRI baseIRI) {
-		this(new OutputStreamWriter(out, Charset.forName("UTF-8")), baseIRI);
-	}
-
-	/**
-	 * Creates a new RDFXMLWriter that will write to the supplied Writer.
-	 * 
-	 * @param writer
-	 *        The Writer to write the RDF/XML document to.
-	 */
-	public RDFXMLWriter(Writer writer) {
-		this(writer, null);
-	}
-
-	/**
-	 * Creates a new RDFXMLWriter that will write to the supplied Writer.
-	 *
-	 * @param writer
-	 *        The Writer to write the RDF/XML document to.
-	 */
-	public RDFXMLWriter(Writer writer, ParsedIRI baseIRI) {
-		this.baseIRI = baseIRI;
-		this.writer = writer;
-		namespaceTable = new LinkedHashMap<String, String>();
-		writingStarted = false;
-		headerWritten = false;
-		lastWrittenSubject = null;
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.RDFXML;
-	}
-
-	@Override
-	public void startRDF()
-		throws RDFHandlerException
-	{
-		if (writingStarted) {
-			throw new RDFHandlerException("Document writing has already started");
-		}
-		writingStarted = true;
-	}
-
-	protected void writeHeader()
-		throws IOException
-	{
-		try {
-			// This export format needs the RDF namespace to be defined, add a
-			// prefix for it if there isn't one yet.
-			setNamespace(RDF.PREFIX, RDF.NAMESPACE);
-
-			if (getWriterConfig().get(XMLWriterSettings.INCLUDE_XML_PI)) {
-				writer.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
-			}
-
-			if (getWriterConfig().get(XMLWriterSettings.INCLUDE_ROOT_RDF_TAG)) {
-				writeStartOfStartTag(RDF.NAMESPACE, "RDF");
-
-				if (defaultNamespace != null) {
-					writeNewLine();
-					writeIndent();
-					writer.write("xmlns=\"");
-					writer.write(XMLUtil.escapeDoubleQuotedAttValue(defaultNamespace));
-					writer.write("\"");
-				}
-
-				for (Map.Entry<String, String> entry : namespaceTable.entrySet()) {
-					String name = entry.getKey();
-					String prefix = entry.getValue();
-
-					writeNewLine();
-					writeIndent();
-					writer.write("xmlns:");
-					writer.write(prefix);
-					writer.write("=\"");
-					writer.write(XMLUtil.escapeDoubleQuotedAttValue(name));
-					writer.write("\"");
-				}
-
-				if (baseIRI != null && getWriterConfig().get(BasicWriterSettings.BASE_DIRECTIVE)) {
-					writeNewLine();
-					writeIndent();
-					writer.write("xml:base=\"");
-					writer.write(baseIRI.toString());
-					writer.write("\"");
-				}
-
-				writeEndOfStartTag();
-			}
-
-			writeNewLine();
-		}
-		finally {
-			headerWritten = true;
-		}
-	}
-
-	public void endRDF()
-		throws RDFHandlerException
-	{
-		if (!writingStarted) {
-			throw new RDFHandlerException("Document writing has not yet started");
-		}
-
-		try {
-			if (!headerWritten) {
-				writeHeader();
-			}
-
-			flushPendingStatements();
-
-			writeNewLine();
-
-			if (getWriterConfig().get(XMLWriterSettings.INCLUDE_ROOT_RDF_TAG)) {
-				writeEndTag(RDF.NAMESPACE, "RDF");
-			}
-
-			writer.flush();
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-		finally {
-			writingStarted = false;
-			headerWritten = false;
-		}
-	}
-
-	public void handleNamespace(String prefix, String name) {
-		setNamespace(prefix, name);
-	}
-
-	protected void setNamespace(String prefix, String name) {
-		if (headerWritten) {
-			// Header containing namespace declarations has already been written
-			return;
-		}
-
-		if (prefix.length() == 0) {
-			defaultNamespace = name;
-			return;
-		}
-
-		if (namespaceTable.containsKey(name)) {
-			// Namespace is already mapped to a prefix
-			return;
-		}
-
-		// Try to give the namespace the specified prefix
-		boolean isLegalPrefix = XMLUtil.isNCName(prefix);
-
-		if (!isLegalPrefix || namespaceTable.containsValue(prefix)) {
-			// Specified prefix is not legal or the prefix is already in use,
-			// generate a legal unique prefix
-			if (!isLegalPrefix) {
-				prefix = "ns";
-			}
-			int number = 1;
-			while (namespaceTable.containsValue(prefix + number)) {
-				number++;
-			}
-			prefix += number;
-		}
-
-		namespaceTable.put(name, prefix);
-	}
-
-	public void handleStatement(Statement st)
-		throws RDFHandlerException
-	{
-		if (!writingStarted) {
-			throw new RDFHandlerException("Document writing has not yet been started");
-		}
-
-		Resource subj = st.getSubject();
-		IRI pred = st.getPredicate();
-		Value obj = st.getObject();
-
-		// Verify that an XML namespace-qualified name can be created for the
-		// predicate
-		String predString = pred.toString();
-		int predSplitIdx = XMLUtil.findURISplitIndex(predString);
-		if (predSplitIdx == -1) {
-			throw new RDFHandlerException(
-					"Unable to create XML namespace-qualified name for predicate: " + predString);
-		}
-
-		String predNamespace = predString.substring(0, predSplitIdx);
-		String predLocalName = predString.substring(predSplitIdx);
-
-		try {
-			if (!headerWritten) {
-				writeHeader();
-			}
-
-			// SUBJECT
-			if (!subj.equals(lastWrittenSubject)) {
-				flushPendingStatements();
-
-				// Write new subject:
-				writeNewLine();
-				writeStartOfStartTag(RDF.NAMESPACE, "Description");
-				if (subj instanceof BNode) {
-					BNode bNode = (BNode)subj;
-					writeAttribute(RDF.NAMESPACE, "nodeID", getValidNodeId(bNode));
-				}
-				else if (baseIRI != null) {
-					writeAttribute(RDF.NAMESPACE, "about", baseIRI.relativize(subj.stringValue()));
-				}
-				else {
-					IRI uri = (IRI)subj;
-					writeAttribute(RDF.NAMESPACE, "about", uri.toString());
-				}
-				writeEndOfStartTag();
-				writeNewLine();
-
-				lastWrittenSubject = subj;
-			}
-
-			// PREDICATE
-			writeIndent();
-			writeStartOfStartTag(predNamespace, predLocalName);
-
-			// OBJECT
-			if (obj instanceof Resource) {
-				Resource objRes = (Resource)obj;
-
-				if (objRes instanceof BNode) {
-					BNode bNode = (BNode)objRes;
-					writeAttribute(RDF.NAMESPACE, "nodeID", getValidNodeId(bNode));
-				}
-				else if (baseIRI != null) {
-					writeAttribute(RDF.NAMESPACE, "resource", baseIRI.relativize(objRes.stringValue()));
-				}
-				else {
-					IRI uri = (IRI)objRes;
-					writeAttribute(RDF.NAMESPACE, "resource", uri.toString());
-				}
-
-				writeEndOfEmptyTag();
-			}
-			else if (obj instanceof Literal) {
-				Literal objLit = (Literal)obj;
-				// datatype attribute
-				boolean isXMLLiteral = false;
-
-				// language attribute
-				if (Literals.isLanguageLiteral(objLit)) {
-					writeAttribute("xml:lang", objLit.getLanguage().get());
-				}
-				else {
-					IRI datatype = objLit.getDatatype();
-					// Check if datatype is rdf:XMLLiteral
-					isXMLLiteral = datatype.equals(RDF.XMLLITERAL);
-
-					if (isXMLLiteral) {
-						writeAttribute(RDF.NAMESPACE, "parseType", "Literal");
-					}
-					else if (!datatype.equals(XMLSchema.STRING)) {
-						writeAttribute(RDF.NAMESPACE, "datatype", datatype.toString());
-					}
-				}
-
-				writeEndOfStartTag();
-
-				// label
-				if (isXMLLiteral) {
-					// Write XML literal as plain XML
-					writer.write(objLit.getLabel());
-				}
-				else {
-					writeCharacterData(objLit.getLabel());
-				}
-
-				writeEndTag(predNamespace, predLocalName);
-			}
-
-			writeNewLine();
-
-			// Don't write </rdf:Description> yet, maybe the next statement
-			// has the same subject.
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	public void handleComment(String comment)
-		throws RDFHandlerException
-	{
-		try {
-			if (!headerWritten) {
-				writeHeader();
-			}
-
-			flushPendingStatements();
-
-			writer.write("<!-- ");
-			writer.write(comment);
-			writer.write(" -->");
-			writeNewLine();
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	protected void flushPendingStatements()
-		throws IOException, RDFHandlerException
-	{
-		if (lastWrittenSubject != null) {
-			// The last statement still has to be closed:
-			writeEndTag(RDF.NAMESPACE, "Description");
-			writeNewLine();
-
-			lastWrittenSubject = null;
-		}
-	}
-
-	protected void writeStartOfStartTag(String namespace, String localName)
-		throws IOException
-	{
-		if (namespace.equals(defaultNamespace)) {
-			writer.write("<");
-			writer.write(localName);
-		}
-		else {
-			String prefix = namespaceTable.get(namespace);
-
-			// If the prefix was not defined, or the root rdf:RDF tag was not
-			// written, then use xmlns=...
-			if (prefix == null || !getWriterConfig().get(XMLWriterSettings.INCLUDE_ROOT_RDF_TAG)) {
-				writer.write("<");
-				writer.write(localName);
-				writer.write(" xmlns=\"");
-				writer.write(XMLUtil.escapeDoubleQuotedAttValue(namespace));
-				writer.write("\"");
-			}
-			else {
-				writer.write("<");
-				writer.write(prefix);
-				writer.write(":");
-				writer.write(localName);
-			}
-		}
-	}
-
-	protected void writeAttribute(String attName, String value)
-		throws IOException
-	{
-		writer.write(" ");
-		writer.write(attName);
-		writer.write("=\"");
-		writer.write(XMLUtil.escapeDoubleQuotedAttValue(value));
-		writer.write("\"");
-	}
-
-	protected void writeAttribute(String namespace, String attName, String value)
-		throws IOException, RDFHandlerException
-	{
-		// Note: attribute cannot use the default namespace
-		String prefix = namespaceTable.get(namespace);
-
-		if (prefix == null) {
-			throw new RDFHandlerException(
-					"No prefix has been declared for the namespace used in this attribute: " + namespace);
-		}
-
-		writer.write(" ");
-		writer.write(prefix);
-		writer.write(":");
-		writer.write(attName);
-		writer.write("=\"");
-		writer.write(XMLUtil.escapeDoubleQuotedAttValue(value));
-		writer.write("\"");
-	}
-
-	protected void writeEndOfStartTag()
-		throws IOException
-	{
-		writer.write(">");
-	}
-
-	protected void writeEndOfEmptyTag()
-		throws IOException
-	{
-		writer.write("/>");
-	}
-
-	protected void writeEndTag(String namespace, String localName)
-		throws IOException
-	{
-		if (namespace.equals(defaultNamespace)) {
-			writer.write("</");
-			writer.write(localName);
-			writer.write(">");
-		}
-		else {
-			writer.write("</");
-			String prefix = namespaceTable.get(namespace);
-			if (prefix != null) {
-				writer.write(prefix);
-				writer.write(":");
-			}
-			writer.write(localName);
-			writer.write(">");
-		}
-	}
-
-	protected void writeCharacterData(String chars)
-		throws IOException
-	{
-		writer.write(XMLUtil.escapeCharacterData(chars));
-	}
-
-	protected void writeIndent()
-		throws IOException
-	{
-		writer.write("\t");
-	}
-
-	protected void writeNewLine()
-		throws IOException
-	{
-		writer.write("\n");
-	}
-
-	/**
-	 * Create a syntactically valid node id from the supplied blank node id. This is necessary because RDF/XML
-	 * syntax enforces the blank node id is a valid NCName.
-	 * 
-	 * @param bNode
-	 *        a blank node identifier
-	 * @return the blank node identifier converted to a form that is a valid NCName.
-	 * @see <a href="http://www.w3.org/TR/REC-rdf-syntax/#rdf-id">section 7.2.34 of the RDF/XML Syntax
-	 *      specification</a>
-	 */
-	protected String getValidNodeId(BNode bNode)
-		throws IOException
-	{
-		String validNodeId = bNode.getID();
-		if (!XMLUtil.isNCName(validNodeId)) {
-			StringBuilder builder = new StringBuilder();
-			if (validNodeId.isEmpty()) {
-				if (this.getWriterConfig().get(BasicParserSettings.PRESERVE_BNODE_IDS)) {
-					throw new IOException(
-							"Cannot consistently write blank nodes with empty internal identifiers");
-				}
-				builder.append("genid-hash-");
-				builder.append(Integer.toHexString(System.identityHashCode(bNode)));
-			}
-			else {
-				if (!XMLUtil.isNCNameStartChar(validNodeId.charAt(0))) {
-					// prepend legal start char
-					builder.append("genid-start-");
-					builder.append(Integer.toHexString(validNodeId.charAt(0)));
-				}
-				else {
-					builder.append(validNodeId.charAt(0));
-				}
-
-				for (int i = 1; i < validNodeId.length(); i++) {
-					// do char-by-char scan and replace illegal chars where
-					// necessary.
-					if (XMLUtil.isNCNameChar(validNodeId.charAt(i))) {
-						builder.append(validNodeId.charAt(i));
-					}
-					else {
-						// replace incompatible char with encoded hex value that will
-						// always be alphanumeric.
-						builder.append(Integer.toHexString(validNodeId.charAt(i)));
-					}
-				}
-			}
-			validNodeId = builder.toString();
-		}
-		return validNodeId;
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriterFactory.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriterFactory.java
deleted file mode 100644
index f9cdb3adb5..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriterFactory.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import java.io.OutputStream;
-import java.io.Writer;
-import java.net.URISyntaxException;
-
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFWriter;
-import org.eclipse.rdf4j.rio.RDFWriterFactory;
-
-/**
- * An {@link RDFWriterFactory} for RDF/XML writers.
- * 
- * @author Arjohn Kampman
- */
-public class RDFXMLWriterFactory implements RDFWriterFactory {
-
-	/**
-	 * Returns {@link RDFFormat#RDFXML}.
-	 */
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.RDFXML;
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLWriter}.
-	 */
-	public RDFWriter getWriter(OutputStream out) {
-		return new RDFXMLWriter(out);
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLWriter}.
-	 *
-	 * @throws URISyntaxException
-	 */
-	public RDFWriter getWriter(OutputStream out, String baseURI)
-		throws URISyntaxException
-	{
-		return new RDFXMLWriter(out, new ParsedIRI(baseURI));
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLWriter}.
-	 */
-	public RDFWriter getWriter(Writer writer) {
-		return new RDFXMLWriter(writer);
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLWriter}.
-	 *
-	 * @throws URISyntaxException
-	 */
-	public RDFWriter getWriter(Writer writer, String baseURI)
-		throws URISyntaxException
-	{
-		return new RDFXMLWriter(writer, new ParsedIRI(baseURI));
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/SAXFilter.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/SAXFilter.java
deleted file mode 100644
index b37ddd24da..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/SAXFilter.java
+++ /dev/null
@@ -1,729 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Stack;
-
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.common.xml.XMLUtil;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.rio.ParseLocationListener;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.RDFParseException;
-import org.eclipse.rdf4j.rio.helpers.XMLParserSettings;
-import org.xml.sax.Attributes;
-import org.xml.sax.ContentHandler;
-import org.xml.sax.Locator;
-import org.xml.sax.SAXException;
-
-/**
- * A filter on SAX events to make life easier on the RDF parser itself. This filter does things like combining
- * a call to startElement() that is directly followed by a call to endElement() to a single call to
- * emptyElement().
- */
-class SAXFilter implements ContentHandler {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	/**
-	 * The RDF parser to supply the filtered SAX events to.
-	 */
-	private RDFXMLParser rdfParser;
-
-	/**
-	 * A Locator indicating a position in the text that is currently being parsed by the SAX parser.
-	 */
-	private Locator locator;
-
-	/**
-	 * Stack of ElementInfo objects.
-	 */
-	private Stack<ElementInfo> elInfoStack = new Stack<ElementInfo>();
-
-	/**
-	 * StringBuilder used to collect text during parsing.
-	 */
-	private StringBuilder charBuf = new StringBuilder(512);
-
-	/**
-	 * The document's URI.
-	 */
-	private ParsedIRI documentURI;
-
-	/**
-	 * Flag indicating whether the parser parses stand-alone RDF documents. In stand-alone documents, the
-	 * rdf:RDF element is optional if it contains just one element.
-	 */
-	private boolean parseStandAloneDocuments = true;
-
-	/**
-	 * Variable used to defer reporting of start tags. Reporting start tags is deferred to be able to combine
-	 * a start tag and an immediately following end tag to a single call to emptyElement().
-	 */
-	private ElementInfo deferredElement = null;
-
-	/**
-	 * New namespace mappings that have been reported for the next start tag by the SAX parser, but that are
-	 * not yet assigned to an ElementInfo object.
-	 */
-	private Map<String, String> newNamespaceMappings = new LinkedHashMap<String, String>();
-
-	/**
-	 * Flag indicating whether we're currently parsing RDF elements.
-	 */
-	private boolean inRDFContext;
-
-	/**
-	 * The number of elements on the stack that are in the RDF context.
-	 */
-	private int rdfContextStackHeight;
-
-	/**
-	 * Flag indicating whether we're currently parsing an XML literal.
-	 */
-	private boolean parseLiteralMode = false;
-
-	/**
-	 * The number of elements on the stack that are part of an XML literal.
-	 */
-	private int xmlLiteralStackHeight;
-
-	/**
-	 * The prefixes that are defined in the XML literal itself (this in contrast to the namespaces from the
-	 * XML literal's context).
-	 */
-	private List<String> xmlLiteralPrefixes = new ArrayList<String>();
-
-	/**
-	 * The prefixes that were used in an XML literal, but that were not defined in it (but rather in the XML
-	 * literal's context).
-	 */
-	private List<String> unknownPrefixesInXMLLiteral = new ArrayList<String>();
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	public SAXFilter(RDFXMLParser rdfParser) {
-		this.rdfParser = rdfParser;
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	public Locator getLocator() {
-		return locator;
-	}
-
-	public void clear() {
-		locator = null;
-		elInfoStack.clear();
-		charBuf.setLength(0);
-		documentURI = null;
-		deferredElement = null;
-
-		newNamespaceMappings.clear();
-
-		inRDFContext = false;
-		rdfContextStackHeight = 0;
-
-		parseLiteralMode = false;
-		xmlLiteralStackHeight = 0;
-
-		xmlLiteralPrefixes.clear();
-		unknownPrefixesInXMLLiteral.clear();
-	}
-
-	public void setDocumentURI(String documentURI) {
-		this.documentURI = createBaseURI(documentURI);
-	}
-
-	public void setParseStandAloneDocuments(boolean standAloneDocs) {
-		parseStandAloneDocuments = standAloneDocs;
-	}
-
-	public boolean getParseStandAloneDocuments() {
-		return parseStandAloneDocuments;
-	}
-
-	/*---------------------------------------*
-	 * Methods from interface ContentHandler *
-	 *---------------------------------------*/
-
-	@Override
-	public void setDocumentLocator(Locator loc) {
-		locator = loc;
-
-		ParseLocationListener pll = rdfParser.getParseLocationListener();
-		if (pll != null && loc != null) {
-			pll.parseLocationUpdate(loc.getLineNumber(), loc.getColumnNumber());
-		}
-	}
-
-	@Override
-	public void startDocument()
-		throws SAXException
-	{
-		try {
-			rdfParser.startDocument();
-		}
-		catch (RDFParseException e) {
-			throw new SAXException(e);
-		}
-		catch (RDFHandlerException e) {
-			throw new SAXException(e);
-		}
-	}
-
-	@Override
-	public void endDocument()
-		throws SAXException
-	{
-		try {
-			rdfParser.endDocument();
-		}
-		catch (RDFParseException e) {
-			throw new SAXException(e);
-		}
-		catch (RDFHandlerException e) {
-			throw new SAXException(e);
-		}
-	}
-
-	@Override
-	public void startPrefixMapping(String prefix, String uri)
-		throws SAXException
-	{
-		try {
-			if (deferredElement != null) {
-				// This new prefix mapping must come from a new start tag
-				reportDeferredStartElement();
-			}
-
-			newNamespaceMappings.put(prefix, uri);
-
-			if (parseLiteralMode) {
-				// This namespace is introduced inside an XML literal
-				xmlLiteralPrefixes.add(prefix);
-			}
-
-			if (rdfParser.getRDFHandler() != null) {
-				rdfParser.getRDFHandler().handleNamespace(prefix, uri);
-			}
-		}
-		catch (RDFParseException e) {
-			throw new SAXException(e);
-		}
-		catch (RDFHandlerException e) {
-			throw new SAXException(e);
-		}
-	}
-
-	@Override
-	public void endPrefixMapping(String prefix) {
-		if (parseLiteralMode) {
-			xmlLiteralPrefixes.remove(prefix);
-		}
-	}
-
-	@Override
-	public void startElement(String namespaceURI, String localName, String qName, Attributes attributes)
-		throws SAXException
-	{
-		try {
-			if (deferredElement != null) {
-				// The next call could set parseLiteralMode to true!
-				reportDeferredStartElement();
-			}
-
-			if (parseLiteralMode) {
-				appendStartTag(qName, attributes);
-				xmlLiteralStackHeight++;
-			}
-			else {
-				ElementInfo parent = peekStack();
-				ElementInfo elInfo = new ElementInfo(parent, qName, namespaceURI, localName);
-
-				elInfo.setNamespaceMappings(newNamespaceMappings);
-				newNamespaceMappings.clear();
-
-				if (!inRDFContext && parseStandAloneDocuments
-						&& (!localName.equals("RDF") || !namespaceURI.equals(RDF.NAMESPACE)))
-				{
-					// Stand-alone document that does not start with an rdf:RDF root
-					// element. Assume this root element is omitted.
-					inRDFContext = true;
-				}
-
-				if (!inRDFContext) {
-					// Check for presence of xml:base and xlm:lang attributes.
-					for (int i = 0; i < attributes.getLength(); i++) {
-						String attQName = attributes.getQName(i);
-
-						if ("xml:base".equals(attQName)) {
-							elInfo.setBaseURI(attributes.getValue(i));
-						}
-						else if ("xml:lang".equals(attQName)) {
-							elInfo.xmlLang = attributes.getValue(i);
-						}
-					}
-
-					elInfoStack.push(elInfo);
-
-					// Check if we are entering RDF context now.
-					if (localName.equals("RDF") && namespaceURI.equals(RDF.NAMESPACE)) {
-						inRDFContext = true;
-						rdfContextStackHeight = 0;
-					}
-				}
-				else {
-					// We're parsing RDF elements.
-					checkAndCopyAttributes(attributes, elInfo);
-
-					// Don't report the new element to the RDF parser just yet.
-					deferredElement = elInfo;
-				}
-
-				charBuf.setLength(0);
-			}
-		}
-		catch (RDFParseException e) {
-			throw new SAXException(e);
-		}
-		catch (RDFHandlerException e) {
-			throw new SAXException(e);
-		}
-	}
-
-	private void reportDeferredStartElement()
-		throws RDFParseException, RDFHandlerException
-	{
-
-		// Only useful for debugging.
-		// if (deferredElement == null) {
-		// throw new RuntimeException("no deferred start element available");
-		// }
-
-		elInfoStack.push(deferredElement);
-		rdfContextStackHeight++;
-
-		rdfParser.setBaseURI(deferredElement.baseURI.toString());
-		rdfParser.setXMLLang(deferredElement.xmlLang);
-
-		rdfParser.startElement(deferredElement.namespaceURI, deferredElement.localName, deferredElement.qName,
-				deferredElement.atts);
-
-		deferredElement = null;
-	}
-
-	@Override
-	public void endElement(String namespaceURI, String localName, String qName)
-		throws SAXException
-	{
-		try {
-			// FIXME: in parseLiteralMode we should also check if start- and
-			// end-tags match but these start tags are not tracked yet.
-
-			if (rdfParser.getParserConfig().get(XMLParserSettings.FAIL_ON_MISMATCHED_TAGS)
-					&& !parseLiteralMode)
-			{
-				// Verify that the end tag matches the start tag.
-				ElementInfo elInfo;
-
-				if (deferredElement != null) {
-					elInfo = deferredElement;
-				}
-				else {
-					elInfo = peekStack();
-				}
-
-				if (!qName.equals(elInfo.qName)) {
-					rdfParser.reportError("expected end tag </'" + elInfo.qName + ">, found </" + qName + ">",
-							XMLParserSettings.FAIL_ON_MISMATCHED_TAGS);
-				}
-			}
-
-			if (!inRDFContext) {
-				elInfoStack.pop();
-				charBuf.setLength(0);
-				return;
-			}
-
-			if (deferredElement == null && rdfContextStackHeight == 0) {
-				// This end tag removes the element that signaled the start
-				// of the RDF context (i.e. <rdf:RDF>) from the stack.
-				inRDFContext = false;
-
-				elInfoStack.pop();
-				charBuf.setLength(0);
-				return;
-			}
-
-			// We're still in RDF context.
-
-			if (parseLiteralMode && xmlLiteralStackHeight > 0) {
-				appendEndTag(qName);
-				xmlLiteralStackHeight--;
-				return;
-			}
-
-			// Check for any deferred start elements
-			if (deferredElement != null) {
-				// Start element still deferred, this is an empty element
-				rdfParser.setBaseURI(deferredElement.baseURI.toString());
-				rdfParser.setXMLLang(deferredElement.xmlLang);
-
-				rdfParser.emptyElement(deferredElement.namespaceURI, deferredElement.localName,
-						deferredElement.qName, deferredElement.atts);
-
-				deferredElement = null;
-			}
-			else {
-				if (parseLiteralMode) {
-					// Insert any used namespace prefixes from the XML literal's
-					// context that are not defined in the XML literal itself.
-					insertUsedContextPrefixes();
-
-					rdfParser.text(charBuf.toString());
-
-					parseLiteralMode = false;
-				}
-				else {
-					String s = charBuf.toString();
-
-					// ignore whitespace-only nodes
-					if (s.trim().length() > 0) {
-						rdfParser.text(s);
-					}
-				}
-
-				charBuf.setLength(0);
-
-				// Handle the end tag
-				elInfoStack.pop();
-				rdfContextStackHeight--;
-
-				rdfParser.endElement(namespaceURI, localName, qName);
-			}
-		}
-		catch (RDFParseException e) {
-			throw new SAXException(e);
-		}
-		catch (RDFHandlerException e) {
-			throw new SAXException(e);
-		}
-	}
-
-	@Override
-	public void characters(char[] ch, int start, int length)
-		throws SAXException
-	{
-		try {
-			if (inRDFContext) {
-				// verify if we need to switch to XMLLiteral processing mode immediately.
-				if (deferredElement != null && !parseLiteralMode) {
-					Att parseType = deferredElement.atts.getAtt(RDF.NAMESPACE, "parseType");
-					if (parseType != null && parseType.getValue().equals("Literal")) {
-						setParseLiteralMode();
-					}
-				}
-
-				if (parseLiteralMode) {
-					if (deferredElement != null) {
-						reportDeferredStartElement();
-					}
-
-					// Characters like '<', '>', and '&' must be escaped to
-					// prevent breaking the XML text.
-					String s = new String(ch, start, length);
-					s = XMLUtil.escapeCharacterData(s);
-					charBuf.append(s);
-				}
-				else {
-					charBuf.append(ch, start, length);
-
-					// if the element is not empty we need to process it as such. Otherwise,
-					// we keep the start element deferred for now.
-					if (deferredElement != null && charBuf.toString().trim().length() > 0) {
-						reportDeferredStartElement();
-					}
-				}
-			}
-		}
-		catch (RDFParseException e) {
-			throw new SAXException(e);
-		}
-		catch (RDFHandlerException e) {
-			throw new SAXException(e);
-		}
-	}
-
-	@Override
-	public void ignorableWhitespace(char[] ch, int start, int length) {
-		if (parseLiteralMode) {
-			charBuf.append(ch, start, length);
-		}
-	}
-
-	@Override
-	public void processingInstruction(String target, String data) {
-		// ignore
-	}
-
-	@Override
-	public void skippedEntity(String name) {
-		// ignore
-	}
-
-	private void checkAndCopyAttributes(Attributes attributes, ElementInfo elInfo)
-		throws SAXException, RDFParseException
-	{
-		Atts atts = new Atts(attributes.getLength());
-
-		int attCount = attributes.getLength();
-		for (int i = 0; i < attCount; i++) {
-			String qName = attributes.getQName(i);
-			String value = attributes.getValue(i);
-
-			// attributes starting with "xml" should be ignored, except for the
-			// ones that are handled by this parser (xml:lang and xml:base).
-			if (qName.startsWith("xml")) {
-				if (qName.equals("xml:lang")) {
-					elInfo.xmlLang = value;
-				}
-				else if (qName.equals("xml:base")) {
-					elInfo.setBaseURI(value);
-				}
-			}
-			else {
-				String namespace = attributes.getURI(i);
-				String localName = attributes.getLocalName(i);
-
-				// A limited set of unqualified attributes must be supported by
-				// parsers, as is specified in section 6.1.4 of the spec
-				if ("".equals(namespace)) {
-					if (localName.equals("ID") || localName.equals("about") || localName.equals("resource")
-							|| localName.equals("parseType") || localName.equals("type"))
-					{
-						rdfParser.reportWarning(
-								"use of unqualified attribute " + localName + " has been deprecated");
-						namespace = RDF.NAMESPACE;
-					}
-				}
-
-				if ("".equals(namespace)) {
-					rdfParser.reportError("unqualified attribute '" + qName + "' not allowed",
-							XMLParserSettings.FAIL_ON_INVALID_QNAME);
-				}
-
-				Att att = new Att(namespace, localName, qName, value);
-				atts.addAtt(att);
-			}
-		}
-
-		elInfo.atts = atts;
-	}
-
-	public void setParseLiteralMode() {
-		parseLiteralMode = true;
-		xmlLiteralStackHeight = 0;
-
-		// All currently known namespace prefixes are
-		// new for this XML literal.
-		xmlLiteralPrefixes.clear();
-		unknownPrefixesInXMLLiteral.clear();
-	}
-
-	private ParsedIRI createBaseURI(String uriString) {
-		return ParsedIRI.create(uriString).normalize();
-	}
-
-	/*---------------------------------*
-	 * Methods related to XML literals *
-	 *---------------------------------*/
-
-	/**
-	 * Appends a start tag to charBuf. This method is used during the parsing of an XML Literal.
-	 */
-	private void appendStartTag(String qName, Attributes attributes) {
-		// Write start of start tag
-		charBuf.append("<" + qName);
-
-		// Write any new namespace prefix definitions
-		for (Map.Entry<String, String> entry : newNamespaceMappings.entrySet()) {
-			String prefix = entry.getKey();
-			String namespace = entry.getValue();
-			appendNamespaceDecl(charBuf, prefix, namespace);
-		}
-
-		// Write attributes
-		int attCount = attributes.getLength();
-		for (int i = 0; i < attCount; i++) {
-			appendAttribute(charBuf, attributes.getQName(i), attributes.getValue(i));
-		}
-
-		// Write end of start tag
-		charBuf.append(">");
-
-		// Check for any used prefixes that are not
-		// defined in the XML literal itself
-		int colonIdx = qName.indexOf(':');
-		String prefix = (colonIdx > 0) ? qName.substring(0, colonIdx) : "";
-
-		if (!xmlLiteralPrefixes.contains(prefix) && !unknownPrefixesInXMLLiteral.contains(prefix)) {
-			unknownPrefixesInXMLLiteral.add(prefix);
-		}
-	}
-
-	/**
-	 * Appends an end tag to charBuf. This method is used during the parsing of an XML Literal.
-	 */
-	private void appendEndTag(String qName) {
-		charBuf.append("</" + qName + ">");
-	}
-
-	/**
-	 * Inserts prefix mappings from an XML Literal's context for all prefixes that are used in the XML Literal
-	 * and that are not defined in the XML Literal itself.
-	 */
-	private void insertUsedContextPrefixes() {
-		int unknownPrefixesCount = unknownPrefixesInXMLLiteral.size();
-
-		if (unknownPrefixesCount > 0) {
-			// Create a String with all needed context prefixes
-			StringBuilder contextPrefixes = new StringBuilder(1024);
-			ElementInfo topElement = peekStack();
-
-			for (int i = 0; i < unknownPrefixesCount; i++) {
-				String prefix = unknownPrefixesInXMLLiteral.get(i);
-				String namespace = topElement.getNamespace(prefix);
-				if (namespace != null) {
-					appendNamespaceDecl(contextPrefixes, prefix, namespace);
-				}
-			}
-
-			// Insert this String before the first '>' character
-			int endOfFirstStartTag = charBuf.indexOf(">");
-			charBuf.insert(endOfFirstStartTag, contextPrefixes.toString());
-		}
-
-		unknownPrefixesInXMLLiteral.clear();
-	}
-
-	private void appendNamespaceDecl(StringBuilder sb, String prefix, String namespace) {
-		String attName = "xmlns";
-
-		if (!"".equals(prefix)) {
-			attName += ":" + prefix;
-		}
-
-		appendAttribute(sb, attName, namespace);
-	}
-
-	private void appendAttribute(StringBuilder sb, String name, String value) {
-		sb.append(" ");
-		sb.append(name);
-		sb.append("=\"");
-		sb.append(XMLUtil.escapeDoubleQuotedAttValue(value));
-		sb.append("\"");
-	}
-
-	/*------------------------------------------*
-	 * Methods related to the ElementInfo stack *
-	 *------------------------------------------*/
-
-	private ElementInfo peekStack() {
-		ElementInfo result = null;
-
-		if (!elInfoStack.empty()) {
-			result = elInfoStack.peek();
-		}
-
-		return result;
-	}
-
-	/*----------------------------*
-	 * Internal class ElementInfo *
-	 *----------------------------*/
-
-	private class ElementInfo {
-
-		public String qName;
-
-		public String namespaceURI;
-
-		public String localName;
-
-		public Atts atts;
-
-		public ElementInfo parent;
-
-		private Map<String, String> namespaceMap;
-
-		public ParsedIRI baseURI;
-
-		public String xmlLang;
-
-		public ElementInfo(String qName, String namespaceURI, String localName) {
-			this(null, qName, namespaceURI, localName);
-		}
-
-		public ElementInfo(ElementInfo parent, String qName, String namespaceURI, String localName) {
-			this.parent = parent;
-			this.qName = qName;
-			this.namespaceURI = namespaceURI;
-			this.localName = localName;
-
-			if (parent != null) {
-				// Inherit baseURI and xmlLang from parent
-				this.baseURI = parent.baseURI;
-				this.xmlLang = parent.xmlLang;
-			}
-			else {
-				this.baseURI = documentURI;
-				this.xmlLang = "";
-			}
-		}
-
-		public void setBaseURI(String uriString) {
-			// Resolve the specified base URI against the inherited base URI
-			baseURI = baseURI.resolve(createBaseURI(uriString));
-		}
-
-		public void setNamespaceMappings(Map<String, String> namespaceMappings) {
-			if (namespaceMappings.isEmpty()) {
-				namespaceMap = null;
-			}
-			else {
-				namespaceMap = new HashMap<String, String>(namespaceMappings);
-			}
-		}
-
-		public String getNamespace(String prefix) {
-			String result = null;
-
-			if (namespaceMap != null) {
-				result = namespaceMap.get(prefix);
-			}
-
-			if (result == null && parent != null) {
-				result = parent.getNamespace(prefix);
-			}
-
-			return result;
-		}
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/package.html b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/package.html
deleted file mode 100644
index d01faaf561..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/package.html
+++ /dev/null
@@ -1,8 +0,0 @@
-<html>
-<head></head>
-<body>
-Parser and writer for XML-serialized RDF. These parsers and writers adhere to the
-<a href="http://www.w3.org/TR/rdf-syntax-grammar/">revised RDF/XML
-syntax specification of 10 February 2004</a>.
-</body>
-</html>
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/util/RDFXMLPrettyWriter.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/util/RDFXMLPrettyWriter.java
deleted file mode 100644
index 3b41b1aa2a..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/util/RDFXMLPrettyWriter.java
+++ /dev/null
@@ -1,594 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml.util;
-
-import java.io.Closeable;
-import java.io.Flushable;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.Writer;
-import java.util.Stack;
-
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.model.BNode;
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Literal;
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.Value;
-import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
-import org.eclipse.rdf4j.model.util.Literals;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.model.vocabulary.RDFS;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.rdfxml.RDFXMLWriter;
-
-/**
- * An extension of RDFXMLWriter that outputs a more concise form of RDF/XML. The resulting output is
- * semantically equivalent to the output of an RDFXMLWriter (it produces the same set of statements), but it
- * is usually easier to read for humans.
- * <p>
- * This is a quasi-streaming RDFWriter. Statements are cached as long as the striped syntax is followed (i.e.
- * the subject of the next statement is the object of the previous statement) and written to the output when
- * the stripe is broken.
- * <p>
- * The abbreviations used are
- * <a href="http://www.w3.org/TR/rdf-syntax-grammar/#section-Syntax-typed-nodes" >typed node elements</a>,
- * <a href= "http://www.w3.org/TR/rdf-syntax-grammar/#section-Syntax-empty-property-elements" >empty property
- * elements</a> and
- * <a href= "http://www.w3.org/TR/rdf-syntax-grammar/#section-Syntax-node-property-elements" >striped
- * syntax</a>. Note that these abbreviations require that statements are written in the appropriate order.
- * <p>
- * Striped syntax means that when the object of a statement is the subject of the next statement we can nest
- * the descriptions in each other.
- * <p>
- * Example:
- * 
- * <pre>
- * &lt;rdf:Seq&gt;
- *    &lt;rdf:li&gt;
- *       &lt;foaf:Person&gt;
- *          &lt;foaf:knows&gt;
- *             &lt;foaf:Person&gt;
- *               &lt;foaf:mbox rdf:resource=&quot;...&quot;/&gt;
- *             &lt;/foaf:Person&gt;
- *          &lt;/foaf:knows&gt;
- *       &lt;/foaf:Person&gt;
- *    &lt;/rdf:li&gt;
- * &lt;/rdf:Seq&gt;
- * </pre>
- * 
- * Typed node elements means that we write out type information in the short form of
- * 
- * <pre>
- * &lt;foaf:Person rdf:about=&quot;...&quot;&gt;
- *     ...
- *  &lt;/foaf:Person&gt;
- * </pre>
- * 
- * instead of
- * 
- * <pre>
- * &lt;rdf:Description rdf:about=&quot;...&quot;&gt;
- *    &lt;rdf:type rdf:resource=&quot;http://xmlns.com/foaf/0.1/Person&quot;/&gt;
- *     ...
- *  &lt;/rdf:Description&gt;
- * </pre>
- * 
- * Empty property elements are of the form
- * 
- * <pre>
- * &lt;foaf:Person&gt;
- *    &lt;foaf:homepage rdf:resource=&quot;http://www.cs.vu.nl/&tilde;marta&quot;/&gt;
- * &lt;/foaf:Person&gt;
- * </pre>
- * 
- * instead of
- * 
- * <pre>
- * &lt;foaf:Person&gt;
- *    &lt;foaf:homepage&gt;
- *       &lt;rdf:Description rdf:about=&quot;http://www.cs.vu.nl/&tilde;marta&quot;/&gt;
- *    &lt;foaf:homepage&gt;
- * &lt;/foaf:Person&gt;
- * </pre>
- * 
- * @author Peter Mika (pmika@cs.vu.nl)
- */
-public class RDFXMLPrettyWriter extends RDFXMLWriter implements Closeable, Flushable {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	/*
-	 * We implement striped syntax by using two stacks, one for predicates and one for subjects/objects.
-	 */
-
-	/**
-	 * Stack for remembering the nodes (subjects/objects) of statements at each level.
-	 */
-	private final Stack<Node> nodeStack = new Stack<Node>();
-
-	/**
-	 * Stack for remembering the predicate of statements at each level.
-	 */
-	private final Stack<IRI> predicateStack = new Stack<IRI>();
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new RDFXMLPrintWriter that will write to the supplied OutputStream.
-	 * 
-	 * @param out
-	 *        The OutputStream to write the RDF/XML document to.
-	 */
-	public RDFXMLPrettyWriter(OutputStream out) {
-		super(out);
-	}
-
-	/**
-	 * Creates a new RDFXMLPrintWriter that will write to the supplied OutputStream.
-	 *
-	 * @param out
-	 *        The OutputStream to write the RDF/XML document to.
-	 */
-	public RDFXMLPrettyWriter(OutputStream out, ParsedIRI baseIRI) {
-		super(out, baseIRI);
-	}
-
-	/**
-	 * Creates a new RDFXMLPrintWriter that will write to the supplied Writer.
-	 * 
-	 * @param out
-	 *        The Writer to write the RDF/XML document to.
-	 */
-	public RDFXMLPrettyWriter(Writer out) {
-		super(out);
-	}
-
-	/**
-	 * Creates a new RDFXMLPrintWriter that will write to the supplied Writer.
-	 *
-	 * @param out
-	 *        The Writer to write the RDF/XML document to.
-	 */
-	public RDFXMLPrettyWriter(Writer writer, ParsedIRI baseIRI) {
-		super(writer, baseIRI);
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	@Override
-	protected void writeHeader()
-		throws IOException
-	{
-		// This export format needs the RDF Schema namespace to be defined:
-		setNamespace(RDFS.PREFIX, RDFS.NAMESPACE);
-
-		super.writeHeader();
-	}
-
-	@Override
-	public void flush()
-		throws IOException
-	{
-		if (writingStarted) {
-			if (!headerWritten) {
-				writeHeader();
-			}
-
-			try {
-				flushPendingStatements();
-			}
-			catch (RDFHandlerException e) {
-				if (e.getCause() != null && e.getCause() instanceof IOException) {
-					throw (IOException)e.getCause();
-				}
-				else {
-					throw new IOException(e);
-				}
-			}
-
-			writer.flush();
-		}
-	}
-
-	@Override
-	public void close()
-		throws IOException
-	{
-		try {
-			if (writingStarted) {
-				endRDF();
-			}
-		}
-		catch (RDFHandlerException e) {
-			if (e.getCause() != null && e.getCause() instanceof IOException) {
-				throw (IOException)e.getCause();
-			}
-			else {
-				throw new IOException(e);
-			}
-		}
-		finally {
-			nodeStack.clear();
-			predicateStack.clear();
-			writer.close();
-		}
-	}
-
-	@Override
-	protected void flushPendingStatements()
-		throws IOException, RDFHandlerException
-	{
-		if (!nodeStack.isEmpty()) {
-			popStacks(null);
-		}
-	}
-
-	/**
-	 * Write out the stacks until we find subject. If subject == null, write out the entire stack
-	 * 
-	 * @param newSubject
-	 */
-	private void popStacks(Resource newSubject)
-		throws IOException, RDFHandlerException
-	{
-		// Write start tags for the part of the stacks that are not yet
-		// written
-		for (int i = 0; i < nodeStack.size() - 1; i++) {
-			Node node = nodeStack.get(i);
-
-			if (!node.isWritten()) {
-				if (i > 0) {
-					writeIndents(i * 2 - 1);
-
-					IRI predicate = predicateStack.get(i - 1);
-
-					writeStartTag(predicate.getNamespace(), predicate.getLocalName());
-					writeNewLine();
-				}
-
-				writeIndents(i * 2);
-				writeNodeStartTag(node);
-				node.setIsWritten(true);
-			}
-		}
-
-		// Write tags for the top subject
-		Node topNode = nodeStack.pop();
-
-		if (predicateStack.isEmpty()) {
-			// write out an empty subject
-			writeIndents(nodeStack.size() * 2);
-			writeNodeEmptyTag(topNode);
-			writeNewLine();
-		}
-		else {
-			IRI topPredicate = predicateStack.pop();
-
-			if (!topNode.hasType()) {
-				// we can use an abbreviated predicate
-				writeIndents(nodeStack.size() * 2 - 1);
-				writeAbbreviatedPredicate(topPredicate, topNode.getValue());
-			}
-			else {
-				// we cannot use an abbreviated predicate because the type needs to
-				// written out as well
-
-				writeIndents(nodeStack.size() * 2 - 1);
-				writeStartTag(topPredicate.getNamespace(), topPredicate.getLocalName());
-				writeNewLine();
-
-				// write out an empty subject
-				writeIndents(nodeStack.size() * 2);
-				writeNodeEmptyTag(topNode);
-				writeNewLine();
-
-				writeIndents(nodeStack.size() * 2 - 1);
-				writeEndTag(topPredicate.getNamespace(), topPredicate.getLocalName());
-				writeNewLine();
-			}
-		}
-
-		// Write out the end tags until we find the subject
-		while (!nodeStack.isEmpty()) {
-			Node nextElement = nodeStack.peek();
-
-			if (nextElement.getValue().equals(newSubject)) {
-				break;
-			}
-			else {
-				nodeStack.pop();
-
-				// We have already written out the subject/object,
-				// but we still need to close the tag
-				writeIndents(predicateStack.size() + nodeStack.size());
-
-				writeNodeEndTag(nextElement);
-
-				if (predicateStack.size() > 0) {
-					IRI nextPredicate = predicateStack.pop();
-
-					writeIndents(predicateStack.size() + nodeStack.size());
-
-					writeEndTag(nextPredicate.getNamespace(), nextPredicate.getLocalName());
-
-					writeNewLine();
-				}
-			}
-		}
-	}
-
-	@Override
-	public void handleStatement(Statement st)
-		throws RDFHandlerException
-	{
-		if (!writingStarted) {
-			throw new RDFHandlerException("Document writing has not yet been started");
-		}
-
-		Resource subj = st.getSubject();
-		IRI pred = st.getPredicate();
-		Value obj = st.getObject();
-
-		try {
-			if (!headerWritten) {
-				writeHeader();
-			}
-
-			if (!nodeStack.isEmpty() && !subj.equals(nodeStack.peek().getValue())) {
-				// Different subject than we had before, empty the stack
-				// until we find it
-				popStacks(subj);
-			}
-
-			// Stack is either empty or contains the same subject at top
-
-			if (nodeStack.isEmpty()) {
-				// Push subject
-				nodeStack.push(new Node(subj));
-			}
-
-			// Stack now contains at least one element
-			Node topSubject = nodeStack.peek();
-
-			// Check if current statement is a type statement and use a typed node
-			// element is possible
-			// FIXME: verify that an XML namespace-qualified name can be created
-			// for the type URI
-			if (pred.equals(RDF.TYPE) && obj instanceof IRI && !topSubject.hasType()
-					&& !topSubject.isWritten())
-			{
-				// Use typed node element
-				topSubject.setType((IRI)obj);
-			}
-			else {
-				if (!nodeStack.isEmpty() && pred.equals(nodeStack.peek().nextLi())) {
-					pred = RDF.LI;
-					nodeStack.peek().incrementNextLi();
-				}
-
-				// Push predicate and object
-				predicateStack.push(pred);
-				nodeStack.push(new Node(obj));
-			}
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	/**
-	 * Write out the opening tag of the subject or object of a statement up to (but not including) the end of
-	 * the tag. Used both in writeStartSubject and writeEmptySubject.
-	 */
-	private void writeNodeStartOfStartTag(Node node)
-		throws IOException, RDFHandlerException
-	{
-		Value value = node.getValue();
-
-		if (node.hasType()) {
-			// We can use abbreviated syntax
-			writeStartOfStartTag(node.getType().getNamespace(), node.getType().getLocalName());
-		}
-		else {
-			// We cannot use abbreviated syntax
-			writeStartOfStartTag(RDF.NAMESPACE, "Description");
-		}
-
-		if (value instanceof IRI) {
-			IRI uri = (IRI)value;
-			writeAttribute(RDF.NAMESPACE, "about", uri.toString());
-		}
-		else {
-			BNode bNode = (BNode)value;
-			writeAttribute(RDF.NAMESPACE, "nodeID", getValidNodeId(bNode));
-		}
-	}
-
-	/**
-	 * Write out the opening tag of the subject or object of a statement.
-	 */
-	private void writeNodeStartTag(Node node)
-		throws IOException, RDFHandlerException
-	{
-		writeNodeStartOfStartTag(node);
-		writeEndOfStartTag();
-		writeNewLine();
-	}
-
-	/**
-	 * Write out the closing tag for the subject or object of a statement.
-	 */
-	private void writeNodeEndTag(Node node)
-		throws IOException
-	{
-		if (node.getType() != null) {
-			writeEndTag(node.getType().getNamespace(), node.getType().getLocalName());
-		}
-		else {
-			writeEndTag(RDF.NAMESPACE, "Description");
-		}
-		writeNewLine();
-	}
-
-	/**
-	 * Write out an empty tag for the subject or object of a statement.
-	 */
-	private void writeNodeEmptyTag(Node node)
-		throws IOException, RDFHandlerException
-	{
-		writeNodeStartOfStartTag(node);
-		writeEndOfEmptyTag();
-	}
-
-	/**
-	 * Write out an empty property element.
-	 */
-	private void writeAbbreviatedPredicate(IRI pred, Value obj)
-		throws IOException, RDFHandlerException
-	{
-		writeStartOfStartTag(pred.getNamespace(), pred.getLocalName());
-
-		if (obj instanceof Resource) {
-			Resource objRes = (Resource)obj;
-
-			if (objRes instanceof IRI) {
-				IRI uri = (IRI)objRes;
-				writeAttribute(RDF.NAMESPACE, "resource", uri.toString());
-			}
-			else {
-				BNode bNode = (BNode)objRes;
-				writeAttribute(RDF.NAMESPACE, "nodeID", getValidNodeId(bNode));
-			}
-
-			writeEndOfEmptyTag();
-		}
-		else if (obj instanceof Literal) {
-			Literal objLit = (Literal)obj;
-			// datatype attribute
-			IRI datatype = objLit.getDatatype();
-			// Check if datatype is rdf:XMLLiteral
-			boolean isXmlLiteral = datatype.equals(RDF.XMLLITERAL);
-
-			// language attribute
-			if (Literals.isLanguageLiteral(objLit)) {
-				writeAttribute("xml:lang", objLit.getLanguage().get());
-			}
-			else {
-				if (isXmlLiteral) {
-					writeAttribute(RDF.NAMESPACE, "parseType", "Literal");
-				}
-				else {
-					writeAttribute(RDF.NAMESPACE, "datatype", datatype.toString());
-				}
-			}
-
-			writeEndOfStartTag();
-
-			// label
-			if (isXmlLiteral) {
-				// Write XML literal as plain XML
-				writer.write(objLit.getLabel());
-			}
-			else {
-				writeCharacterData(objLit.getLabel());
-			}
-
-			writeEndTag(pred.getNamespace(), pred.getLocalName());
-		}
-
-		writeNewLine();
-	}
-
-	protected void writeStartTag(String namespace, String localName)
-		throws IOException
-	{
-		writeStartOfStartTag(namespace, localName);
-		writeEndOfStartTag();
-	}
-
-	/**
-	 * Writes <tt>n</tt> indents.
-	 */
-	protected void writeIndents(int n)
-		throws IOException
-	{
-		for (int i = 0; i < n; i++) {
-			writeIndent();
-		}
-	}
-
-	/*------------------*
-	 * Inner class Node *
-	 *------------------*/
-
-	private static class Node {
-
-		private int nextLiIndex = 1;
-
-		private Resource nextLi;
-
-		private Value value;
-
-		// type == null means that we use <rdf:Description>
-		private IRI type = null;
-
-		private boolean isWritten = false;
-
-		/**
-		 * Creates a new Node for the supplied Value.
-		 */
-		public Node(Value value) {
-			this.value = value;
-		}
-
-		Resource nextLi() {
-			if (nextLi == null) {
-				nextLi = SimpleValueFactory.getInstance().createIRI(RDF.NAMESPACE + "_" + nextLiIndex);
-			}
-
-			return nextLi;
-		}
-
-		public void incrementNextLi() {
-			nextLiIndex++;
-			nextLi = null;
-		}
-
-		public Value getValue() {
-			return value;
-		}
-
-		public void setType(IRI type) {
-			this.type = type;
-		}
-
-		public IRI getType() {
-			return type;
-		}
-
-		public boolean hasType() {
-			return type != null;
-		}
-
-		public void setIsWritten(boolean isWritten) {
-			this.isWritten = isWritten;
-		}
-
-		public boolean isWritten() {
-			return isWritten;
-		}
-	}
-}
diff --git a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/util/RDFXMLPrettyWriterFactory.java b/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/util/RDFXMLPrettyWriterFactory.java
deleted file mode 100644
index 278fe3002a..0000000000
--- a/core/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/util/RDFXMLPrettyWriterFactory.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml.util;
-
-import java.io.OutputStream;
-import java.io.Writer;
-import java.net.URISyntaxException;
-
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFWriter;
-import org.eclipse.rdf4j.rio.RDFWriterFactory;
-
-/**
- * An {@link RDFWriterFactory} for RDF/XML writers.
- * 
- * @author Arjohn Kampman
- */
-public class RDFXMLPrettyWriterFactory implements RDFWriterFactory {
-
-	/**
-	 * Returns {@link RDFFormat#RDFXML}.
-	 */
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.RDFXML;
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLPrettyWriter}.
-	 */
-	public RDFWriter getWriter(OutputStream out) {
-		return new RDFXMLPrettyWriter(out);
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLPrettyWriter}.
-	 *
-	 * @throws URISyntaxException
-	 */
-	public RDFWriter getWriter(OutputStream out, String baseURI)
-		throws URISyntaxException
-	{
-		return new RDFXMLPrettyWriter(out, new ParsedIRI(baseURI));
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLPrettyWriter}.
-	 */
-	public RDFWriter getWriter(Writer writer) {
-		return new RDFXMLPrettyWriter(writer);
-	}
-
-	/**
-	 * Returns a new instance of {@link RDFXMLPrettyWriter}.
-	 *
-	 * @throws URISyntaxException
-	 */
-	public RDFWriter getWriter(Writer writer, String baseURI)
-		throws URISyntaxException
-	{
-		return new RDFXMLPrettyWriter(writer, new ParsedIRI(baseURI));
-	}
-}
diff --git a/core/rio/rdfxml/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFParserFactory b/core/rio/rdfxml/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFParserFactory
deleted file mode 100644
index 4dba932e9e..0000000000
--- a/core/rio/rdfxml/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFParserFactory
+++ /dev/null
@@ -1 +0,0 @@
-org.eclipse.rdf4j.rio.rdfxml.RDFXMLParserFactory
diff --git a/core/rio/rdfxml/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFWriterFactory b/core/rio/rdfxml/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFWriterFactory
deleted file mode 100644
index d9db0bc2ba..0000000000
--- a/core/rio/rdfxml/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFWriterFactory
+++ /dev/null
@@ -1 +0,0 @@
-org.eclipse.rdf4j.rio.rdfxml.RDFXMLWriterFactory
diff --git a/core/rio/rdfxml/src/test/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParserTest.java b/core/rio/rdfxml/src/test/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParserTest.java
deleted file mode 100644
index a14ecbc6ab..0000000000
--- a/core/rio/rdfxml/src/test/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParserTest.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.rdfxml;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.io.PrintStream;
-import java.net.URL;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Locale;
-
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.ValueFactory;
-import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
-import org.eclipse.rdf4j.model.vocabulary.DC;
-import org.eclipse.rdf4j.model.vocabulary.RDFS;
-import org.eclipse.rdf4j.rio.RDFParseException;
-import org.eclipse.rdf4j.rio.RDFParser;
-import org.eclipse.rdf4j.rio.helpers.ParseErrorCollector;
-import org.eclipse.rdf4j.rio.helpers.StatementCollector;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.Matchers;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-public class RDFXMLParserTest {
-
-	private ValueFactory vf;
-
-	private RDFParser parser;
-
-	private StatementCollector sc;
-
-	private ParseErrorCollector el;
-
-	private Locale platformLocale;
-
-	@Before
-	public void setUp()
-		throws Exception
-	{
-		platformLocale = Locale.getDefault();
-		
-		Locale.setDefault(Locale.ENGLISH);
-		vf = SimpleValueFactory.getInstance();
-		parser = new RDFXMLParser();
-		sc = new StatementCollector();
-		parser.setRDFHandler(sc);
-		el = new ParseErrorCollector();
-		parser.setParseErrorListener(el);
-	}
-
-	@After
-	public void tearDown()
-		throws Exception
-	{
-		Locale.setDefault(platformLocale);
-	}
-
-	@Test
-	public void rdfXmlLoadedFromInsideAJarResolvesRelativeUris()
-		throws Exception
-	{
-		URL zipfileUrl = this.getClass().getResource(
-				"/org/eclipse/rdf4j/rio/rdfxml/sample-with-rdfxml-data.zip");
-
-		assertNotNull("The sample-data.zip file must be present for this test", zipfileUrl);
-
-		String url = "jar:" + zipfileUrl + "!/index.rdf";
-
-		try (final InputStream in = new URL(url).openStream();) {
-			parser.parse(in, url);
-		}
-
-		Collection<Statement> stmts = sc.getStatements();
-
-		assertThat(stmts, Matchers.<Statement> iterableWithSize(3));
-
-		Iterator<Statement> iter = stmts.iterator();
-
-		Statement stmt1 = iter.next();
-		Statement stmt2 = iter.next();
-
-		assertEquals(vf.createIRI("http://www.example.com/#"), stmt1.getSubject());
-		assertEquals(vf.createIRI("http://www.example.com/ns/#document-about"), stmt1.getPredicate());
-		assertTrue(stmt1.getObject() instanceof IRI);
-
-		IRI res = (IRI)stmt1.getObject();
-
-		String resourceUrl = res.stringValue();
-
-		assertThat(resourceUrl, CoreMatchers.startsWith("jar:" + zipfileUrl + "!"));
-
-		URL javaUrl = new URL(resourceUrl);
-		assertEquals("jar", javaUrl.getProtocol());
-
-		try (InputStream uc = javaUrl.openStream();) {
-			assertEquals("The resource stream should be empty", -1, uc.read());
-		}
-
-		assertEquals(res, stmt2.getSubject());
-		assertEquals(DC.TITLE, stmt2.getPredicate());
-		assertEquals(vf.createLiteral("Empty File"), stmt2.getObject());
-	}
-
-	@Test
-	public void testRDFXMLWhitespace()
-		throws Exception
-	{
-		try (final InputStream in = this.getClass().getResourceAsStream(
-				"/org/eclipse/rdf4j/rio/rdfxml/rdfxml-whitespace-literal.rdf");)
-		{
-			parser.parse(in, "");
-		}
-		Statement stmt1 = sc.getStatements().iterator().next();
-		assertEquals(1, sc.getStatements().size());
-		assertEquals(RDFS.LABEL, stmt1.getPredicate());
-		assertEquals(vf.createLiteral("  Literal with whitespace  "), stmt1.getObject());
-	}
-
-	@Test
-	public void testFatalErrorPrologContent()
-		throws Exception
-	{
-		// Temporarily override System.err to verify that nothing is being
-		// printed to it for this test
-		PrintStream oldErr = System.err;
-		ByteArrayOutputStream tempErr = new ByteArrayOutputStream();
-		System.setErr(new PrintStream(tempErr));
-		PrintStream oldOut = System.out;
-		ByteArrayOutputStream tempOut = new ByteArrayOutputStream();
-		System.setOut(new PrintStream(tempOut));
-		try (final InputStream in = this.getClass().getResourceAsStream(
-				"/org/eclipse/rdf4j/rio/rdfxml/not-an-rdfxml-file.rdf");)
-		{
-			parser.parse(in, "");
-		}
-		catch (RDFParseException e) {
-			assertEquals("Content is not allowed in prolog. [line 1, column 1]", e.getMessage());
-		}
-		finally {
-			// Reset System Error output to ensure that we don't interfere with
-			// other tests
-			System.setErr(oldErr);
-			// Reset System Out output to ensure that we don't interfere with
-			// other tests
-			System.setOut(oldOut);
-		}
-		// Verify nothing was printed to System.err during test
-		assertEquals(0, tempErr.size());
-		// Verify nothing was printed to System.out during test
-		assertEquals(0, tempOut.size());
-		assertEquals(0, el.getWarnings().size());
-		assertEquals(0, el.getErrors().size());
-		assertEquals(1, el.getFatalErrors().size());
-		assertEquals("[Rio fatal] Content is not allowed in prolog. (1, 1)", el.getFatalErrors().get(0));
-	}
-}
diff --git a/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/not-an-rdfxml-file.rdf b/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/not-an-rdfxml-file.rdf
deleted file mode 100644
index 24f3f58659..0000000000
--- a/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/not-an-rdfxml-file.rdf
+++ /dev/null
@@ -1 +0,0 @@
-# rdf:RDF should not make this an RDF file, and it should fail to parse as one even with <rdf:RDF> or </rdf:RDF> in this comment
diff --git a/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/rdfxml-whitespace-literal.rdf b/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/rdfxml-whitespace-literal.rdf
deleted file mode 100644
index cdad7b10f9..0000000000
--- a/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/rdfxml-whitespace-literal.rdf
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version='1.0' encoding='utf-8'?>
-
-<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>
-
- <rdf:Description rdf:about='urn:test:empty-literal'>
-  <label xmlns='http://www.w3.org/2000/01/rdf-schema#'>  Literal with whitespace  </label>
- </rdf:Description>
-</rdf:RDF>
diff --git a/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/sample-with-rdfxml-data.zip b/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/sample-with-rdfxml-data.zip
deleted file mode 100644
index 727df4d704..0000000000
Binary files a/core/rio/rdfxml/src/test/resources/org/eclipse/rdf4j/rio/rdfxml/sample-with-rdfxml-data.zip and /dev/null differ
