diff --git a/README.md b/README.md
index 61c9001..f64e0b0 100644
--- a/README.md
+++ b/README.md
@@ -257,7 +257,8 @@ During the conversion process, all these formats will be parsed and then added i
 
 ### Run Modes
 
-As shown above, run modes in the path lead the tool to create a dedicated _Apache Sling Feature_ model file containing all interested OSGi configurations/bundles.
+As shown above, run modes in the path lead the tool to create a dedicated _Apache Sling Feature_ model file containing all interested OSGi configurations/bundles. Run modes are determined according to the RunModePolicy which by default for backwards compatiblity reasons is DIRECT_ONLY.
+For DIRECT_ONLY only the direct path leading up to the artifact, while PREPEND_INHERITED makes sure that run modes are inherited downwards and deduplicated (only new ones added)
 
 ### Known limitations
 
@@ -543,6 +544,13 @@ Apache Sling Content Package to Sling Feature converter
       --remove-install-hooks
                             Removes both internal and external hooks from processed
                               packages
+      --run-mode-policy=<runModePolicy>
+                            Determines how to determine the final run mode of an
+                              artifact. DIRECT_ONLY uses only the run modes of the
+                              containing path while PREPEND_INHERITED inherits the
+                              run modes affecting the parent package. Valid values:
+                              DIRECT_ONLY, PREPEND_INHERITED.
+                              Default: DIRECT_ONLY
       --seed-feature=<seedFeature>
                             A url pointing to a feature that can be assumed to be
                               around when the conversion result will be used
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverter.java b/src/main/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverter.java
index 7bf91f7..4500382 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverter.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverter.java
@@ -117,6 +117,19 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
 
     private IndexManager indexManager = new DefaultIndexManager();
 
+    private RunModePolicy runModePolicy = RunModePolicy.DIRECT_ONLY;
+
+    public enum RunModePolicy {
+        /**
+         * Only path within containing package is considered for run mode evaluation 
+         */
+        DIRECT_ONLY,
+        /**
+         * For nesting of multiple levels, run mode constraints are inherited down and prepended 
+         */
+        PREPEND_INHERITED
+    }
+    
     public enum PackagePolicy {
         /**
          * References the content package in the feature model and deploys via the {@link ContentPackage2FeatureModelConverter#artifactsDeployer}
@@ -158,10 +171,15 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
     }
 
     public ContentPackage2FeatureModelConverter(boolean strictValidation, @NotNull SlingInitialContentPolicy slingInitialContentPolicy, boolean disablePackageTypeRecalculation) throws IOException {
+        this(strictValidation, slingInitialContentPolicy, disablePackageTypeRecalculation, RunModePolicy.DIRECT_ONLY);
+    }
+    
+    public ContentPackage2FeatureModelConverter(boolean strictValidation, @NotNull SlingInitialContentPolicy slingInitialContentPolicy, boolean disablePackageTypeRecalculation, @NotNull RunModePolicy runModePolicy) throws IOException {
         super(strictValidation);
         this.disablePackageTypeRecalculation = disablePackageTypeRecalculation;
         this.recollectorVaultPackageScanner = new RecollectorVaultPackageScanner(this, this.packageManager, strictValidation, subContentPackages, slingInitialContentPolicy);
         this.tmpDirectory = Files.createTempDirectory("cp2fm-converter").toFile();
+        this.runModePolicy = runModePolicy;
     }
 
     public @NotNull ContentPackage2FeatureModelConverter setEntryHandlersManager(@Nullable EntryHandlersManager handlersManager) {
@@ -242,7 +260,16 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
         this.removeInstallHooks = removeInstallHook;
         return this;
     }
+    
+    public @NotNull ContentPackage2FeatureModelConverter setRunModePolicy(@NotNull RunModePolicy runModePolicy) {
+        this.runModePolicy = runModePolicy;
+        return this;
+    }
 
+    public RunModePolicy getRunModePolicy() {
+        return this.runModePolicy;
+    }
+    
     public @Nullable IndexManager getIndexManager() {
         return indexManager;
     }
@@ -287,7 +314,7 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
 
             // analyze sub-content packages in order to filter out
             // possible outdated conflicting packages
-            recollectorVaultPackageScanner.traverse(pack);
+            recollectorVaultPackageScanner.traverse(pack, null);
 
             logger.info("content-package '{}' successfully read!", contentPackage);
 
@@ -322,7 +349,7 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
 
                 logger.info("Converting content-package '{}'...", vaultPackage.getId());
 
-                traverse(vaultPackage);
+                traverse(vaultPackage, null);
 
                 // retrieve the resulting zip-content-package and deploy it to the local mvn bundles dir.
                 try (VaultPackage result = processContentPackageArchive(getMainPackageAssembler(), null)) {
@@ -405,7 +432,7 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
         assemblers.add(clonedPackage);
 
         // scan the detected package, first
-        traverse(vaultPackage);
+        traverse(vaultPackage, runMode);
         
         //set dependency to parent package if the parent package is an application package & subpackage is embedded
         if (isEmbeddedPackage && !isContainerPackage) {
@@ -503,7 +530,7 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
         return subContentPackages.containsValue(path);
     }
 
-    private void process(@NotNull String entryPath, @NotNull Archive archive, @Nullable Entry entry) throws IOException, ConverterException {
+    private void process(@NotNull String entryPath, @NotNull Archive archive, @Nullable Entry entry, String runMode) throws IOException, ConverterException {
         if (resourceFilter != null && resourceFilter.isFilteredOut(entryPath)) {
             throw new ConverterException("Path '"
                     + entryPath
@@ -523,7 +550,7 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
                 throw new IllegalArgumentException("Archive '" + archive.getMetaInf().getPackageProperties().getId() + "' does not contain entry with path '" + entryPath + "'");
             }
         }
-        entryHandler.handle(entryPath, archive, entry, this);
+        entryHandler.handle(entryPath, archive, entry, this, runMode);
         if (!getMainPackageAssembler().recordEntryPath(entryPath)) {
             logger.warn("Duplicate entry path {}", entryPath);
         }
@@ -535,9 +562,9 @@ public class ContentPackage2FeatureModelConverter extends BaseVaultPackageScanne
     }
 
     @Override
-    protected void onFile(@NotNull String entryPath, @NotNull Archive archive, @NotNull Entry entry) throws IOException, ConverterException {
+    protected void onFile(@NotNull String entryPath, @NotNull Archive archive, @NotNull Entry entry, String runMode) throws IOException, ConverterException {
         try {
-            process(entryPath, archive, entry);
+            process(entryPath, archive, entry, runMode);
         } catch (ConverterException ex) {
             throw new ConverterException("ConverterException occured on path " + entryPath + " with message: " + ex.getMessage(), ex);
         } catch (IOException ex) {
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/cli/ContentPackage2FeatureModelConverterLauncher.java b/src/main/java/org/apache/sling/feature/cpconverter/cli/ContentPackage2FeatureModelConverterLauncher.java
index 64304fb..b9ae738 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/cli/ContentPackage2FeatureModelConverterLauncher.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/cli/ContentPackage2FeatureModelConverterLauncher.java
@@ -30,6 +30,7 @@ import java.util.TimeZone;
 import org.apache.sling.feature.Feature;
 import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter;
 import org.apache.sling.feature.cpconverter.ConverterException;
+import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter.RunModePolicy;
 import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter.SlingInitialContentPolicy;
 import org.apache.sling.feature.cpconverter.accesscontrol.AclManager;
 import org.apache.sling.feature.cpconverter.accesscontrol.DefaultAclManager;
@@ -145,6 +146,9 @@ public final class ContentPackage2FeatureModelConverterLauncher implements Runna
 
     @Option(names = { "--sling-initial-content-policy" }, description = "Determines what to do with Sling-Initial-Content found in embedded bundles. Valid values: ${COMPLETION-CANDIDATES}.", required = false, showDefaultValue = Visibility.ALWAYS)
     private SlingInitialContentPolicy slingInitialContentPolicy = SlingInitialContentPolicy.KEEP;
+    
+    @Option(names = { "--run-mode-policy" }, description = "Determines how to determine the final run mode of an artifact. DIRECT_ONLY uses only the run modes of the containing path while PREPEND_INHERITED inherits the run modes affecting the parent package. Valid values: ${COMPLETION-CANDIDATES}.", required = false, showDefaultValue = Visibility.ALWAYS)
+    private RunModePolicy runModePolicy = RunModePolicy.DIRECT_ONLY;
 
     @Override
     public void run() {
@@ -214,7 +218,7 @@ public final class ContentPackage2FeatureModelConverterLauncher implements Runna
                     }
                 }
 
-                try (ContentPackage2FeatureModelConverter converter = new ContentPackage2FeatureModelConverter(strictValidation, slingInitialContentPolicy,disablePackageTypeRecalculation)) {
+                try (ContentPackage2FeatureModelConverter converter = new ContentPackage2FeatureModelConverter(strictValidation, slingInitialContentPolicy, disablePackageTypeRecalculation, runModePolicy)) {
                     BundleSlingInitialContentExtractor bundleSlingInitialContentExtractor = new BundleSlingInitialContentExtractor();
                     converter.setFeaturesManager(featuresManager)
                              .setBundlesDeployer(new LocalMavenRepositoryArtifactsDeployer(artifactsOutputDirectory))
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractConfigurationEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractConfigurationEntryHandler.java
index bcc1c64..4222219 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractConfigurationEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractConfigurationEntryHandler.java
@@ -21,7 +21,6 @@ import java.io.InputStream;
 import java.util.Dictionary;
 import java.util.Objects;
 import java.util.regex.Matcher;
-
 import org.apache.jackrabbit.vault.fs.io.Archive;
 import org.apache.jackrabbit.vault.fs.io.Archive.Entry;
 import org.apache.sling.feature.Configuration;
@@ -45,11 +44,12 @@ abstract class AbstractConfigurationEntryHandler extends AbstractRegexEntryHandl
     }
 
     @Override
-    public final void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter) throws IOException, ConverterException {
+    public final void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode) throws IOException, ConverterException {
 
         Matcher matcher = getPattern().matcher(path);
         
-        String runMode;
+        String targetRunMode;
+        
         // we are pretty sure it matches, here
         if (matcher.matches()) {
             if (matcher.group("dir") != null) {
@@ -74,12 +74,14 @@ abstract class AbstractConfigurationEntryHandler extends AbstractRegexEntryHandl
                     throw new ConverterException("OSGi configuration are only considered if placed below a folder called 'config', but the configuration at '"+ path + "' is placed outside!");
                 }
                 
-                // there is a specified RunMode
-                runMode = matcher.group("runmode");
-    
+                // determine run mode string for current path
+                String runModeMatch = matcher.group("runmode");
+                targetRunMode = extractTargetRunMode(path, converter, runMode,
+                    runModeMatch);
+                
                 FeaturesManager featuresManager = Objects.requireNonNull(converter.getFeaturesManager());
                 final Configuration cfg = new Configuration(id);
-                featuresManager.addConfiguration(runMode, cfg, path, configurationProperties);
+                featuresManager.addConfiguration(targetRunMode, cfg, path, configurationProperties);
             }
         } else {
             throw new IllegalStateException("Something went terribly wrong: pattern '"
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractContentPackageHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractContentPackageHandler.java
index 5779c2c..3f0f7af 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractContentPackageHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractContentPackageHandler.java
@@ -23,7 +23,6 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-
 import org.apache.commons.io.IOUtils;
 import org.apache.jackrabbit.vault.fs.io.Archive;
 import org.apache.jackrabbit.vault.fs.io.Archive.Entry;
@@ -44,7 +43,7 @@ public abstract class AbstractContentPackageHandler extends AbstractRegexEntryHa
     }
 
     @Override
-    public final void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter)
+    public final void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode)
             throws IOException, ConverterException {
         logger.info("Processing sub-content package '{}'...", entry.getName());
 
@@ -74,7 +73,7 @@ public abstract class AbstractContentPackageHandler extends AbstractRegexEntryHa
         }
 
         Matcher matcher = getPattern().matcher(path);
-        String runMode = null;
+
         // we are pretty sure it matches, here
         if (!matcher.matches()) {
             throw new IllegalStateException("Something went terribly wrong: pattern '"
@@ -84,15 +83,16 @@ public abstract class AbstractContentPackageHandler extends AbstractRegexEntryHa
                                             + "' but it does not, currently");
         }
 
-        runMode = matcher.group(1);
-        if (runMode != null) {
-            // there is a specified RunMode
-            logger.debug("Runmode {} was extracted from path {}", runMode, path);
-        }
 
+        String targetRunMode;
+        // determine run mode string for current path
+        String runModeMatch = matcher.group(1);
+        targetRunMode = extractTargetRunMode(path, converter, runMode,
+            runModeMatch);
+        
         boolean isEmbeddedPackage = EMBEDDED_PACKAGE_PATTERN.matcher(path).matches();
         try (VaultPackage vaultPackage = converter.open(temporaryContentPackage)) {
-            processSubPackage(path, runMode, vaultPackage, converter, isEmbeddedPackage);
+            processSubPackage(path, targetRunMode, vaultPackage, converter, isEmbeddedPackage);
         }
 
         logger.info("Sub-content package '{}' processing is over", entry.getName());
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractPolicyEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractPolicyEntryHandler.java
index 952cf1b..bf156be 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractPolicyEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractPolicyEntryHandler.java
@@ -48,7 +48,7 @@ abstract class AbstractPolicyEntryHandler extends AbstractRegexEntryHandler {
     }
 
     @Override
-    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Archive.Entry entry, @NotNull ContentPackage2FeatureModelConverter converter)
+    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Archive.Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode)
             throws IOException {
         String resourcePath;
         Matcher matcher = getPattern().matcher(path);
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractRegexEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractRegexEntryHandler.java
index f1bea34..8df8290 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractRegexEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractRegexEntryHandler.java
@@ -16,8 +16,17 @@
  */
 package org.apache.sling.feature.cpconverter.handlers;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter;
+import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter.RunModePolicy;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -45,4 +54,40 @@ abstract class AbstractRegexEntryHandler implements EntryHandler {
         return pattern;
     }
 
+    protected String extractTargetRunMode(String path, ContentPackage2FeatureModelConverter converter,
+            String runMode, String runModeMatch) {
+                String targetRunmode;
+                if  (RunModePolicy.PREPEND_INHERITED.equals(converter.getRunModePolicy())) {
+                    final List<String> runModes = new ArrayList<>();
+                    final List<String> inheritedRunModes = runMode == null ? Collections.emptyList() : Arrays.asList(StringUtils.split(runMode, '.'));
+            
+                    runModes.addAll(inheritedRunModes);
+                    // append found run modes without duplicates (legacy behavior direct_only established by appending to empty List)
+                    if (StringUtils.isNotEmpty(runModeMatch)) {
+                        // there is a specified RunMode
+                        logger.debug("Runmode {} was extracted from path {}", runModeMatch, path);
+                        List<String> newRunModes = Arrays.asList(StringUtils.split(runModeMatch, '.'));
+            
+                        // add only new RunModes that are not already present
+                        List<String> newRunModesList = newRunModes.stream()
+                                                                  .filter(mode -> !runModes.contains(mode))
+                                                                  .collect(Collectors.toList());
+            
+                        // identify diverging list of run modes between parent & direct definition as diverging criteria between run mode policies
+                        if(!runModes.isEmpty() && !CollectionUtils.isEqualCollection(newRunModes, inheritedRunModes)) {
+                            logger.info("Found diverging run modes list {} diverging from defined run modes on the parent {}", newRunModes, inheritedRunModes);
+                            logger.info("Effective run modes: {}", runModes);
+                        }
+            
+                        runModes.addAll(newRunModesList);
+                    }
+                    targetRunmode = String.join(".", runModes);
+            
+                } else {
+                    //legacy behavior - direct_only - just use the directly defined run modes
+                    targetRunmode = runModeMatch;
+                }
+                return targetRunmode;
+            }
+
 }
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractUserEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractUserEntryHandler.java
index 902851a..c892f27 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractUserEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/AbstractUserEntryHandler.java
@@ -42,7 +42,7 @@ abstract class AbstractUserEntryHandler extends AbstractRegexEntryHandler {
     }
 
     @Override
-    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter)
+    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode)
             throws IOException, ConverterException {
         Matcher matcher = getPattern().matcher(path);
         if (matcher.matches()) {
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandler.java
index 3e25e77..a1d01ab 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandler.java
@@ -86,11 +86,12 @@ public class BundleEntryHandler extends AbstractRegexEntryHandler {
     public void handle(@NotNull String path,
            @NotNull Archive archive, 
            @NotNull Entry entry, 
-           @NotNull ContentPackage2FeatureModelConverter converter) throws IOException, ConverterException {
+           @NotNull ContentPackage2FeatureModelConverter converter,
+           String runMode) throws IOException, ConverterException {
         logger.info("Processing bundle {}...", entry.getName());
 
         Matcher matcher = getPattern().matcher(path);
-        String runMode = null;
+        
         Integer startLevel = null;
         // we are pretty sure it matches, here
         if (!matcher.matches()) {
@@ -105,12 +106,11 @@ public class BundleEntryHandler extends AbstractRegexEntryHandler {
             throw new ConverterException("OSGi bundles are only considered if placed below a folder called 'install', but the bundle at '"+ path + "' is placed outside!");
         }
 
-        
-        runMode = matcher.group("runmode");
-        if (runMode != null) {
-            // there is a specified RunMode
-            logger.debug("Runmode {} was extracted from path {}", runMode, path);
-        }
+        // determine run mode string for current path
+        String runModeMatch = matcher.group("runmode");
+
+        String targetRunMode = extractTargetRunMode(path, converter, runMode,
+            runModeMatch);
 
         final String value = matcher.group("startlevel");
         if (value != null) {
@@ -138,7 +138,7 @@ public class BundleEntryHandler extends AbstractRegexEntryHandler {
                 InputStream input = Objects.requireNonNull(archive.openInputStream(entry))) {
                 IOUtils.copy(input, output);
             }
-            processBundleInputStream(path, tmpBundleJar, bundleName, runMode, startLevel, converter);
+            processBundleInputStream(path, tmpBundleJar, bundleName, targetRunMode, startLevel, converter);
         } finally {
             Files.delete(tmpBundleJar);
         }
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/DefaultHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/DefaultHandler.java
index 5ffff3e..090d6ed 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/DefaultHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/DefaultHandler.java
@@ -46,7 +46,7 @@ public class DefaultHandler implements EntryHandler {
     }
 
     @Override
-    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Archive.Entry entry, @NotNull ContentPackage2FeatureModelConverter converter)
+    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Archive.Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode)
             throws IOException {
         if (removeInstallHooks && path.startsWith(INSTALL_HOOK_ROOT)) {
             log.info("Skipping install hook {} from original package", path);
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/EntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/EntryHandler.java
index a1fe28f..8d36aaa 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/EntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/EntryHandler.java
@@ -28,8 +28,13 @@ public interface EntryHandler {
 
     boolean matches(@NotNull String path);
 
-    void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter) 
-    throws IOException, ConverterException;
+    default void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter) 
+            throws IOException, ConverterException {
+        handle(path, archive, entry, converter, null);
+    }
+
+    void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode) 
+            throws IOException, ConverterException;
 
     default EntryHandler withConfig(@NotNull String config) {
         return this;
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandler.java
index cb7c9c0..2da38f2 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandler.java
@@ -99,7 +99,7 @@ public class IndexDefinitionsEntryHandler extends AbstractRegexEntryHandler {
 
     @Override
     public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry,
-            @NotNull ContentPackage2FeatureModelConverter converter) throws IOException, ConverterException {
+            @NotNull ContentPackage2FeatureModelConverter converter, String runMode) throws IOException, ConverterException {
 
         IndexManager indexManager = converter.getIndexManager();
         if ( indexManager == null ) {
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/NodeTypesEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/NodeTypesEntryHandler.java
index 41713fb..45259b8 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/NodeTypesEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/NodeTypesEntryHandler.java
@@ -54,7 +54,7 @@ public class NodeTypesEntryHandler extends AbstractRegexEntryHandler {
     }
 
     @Override
-    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter)
+    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode)
             throws IOException, ConverterException {
         try (Reader cndStatements = new InputStreamReader(Objects.requireNonNull(archive.openInputStream(entry)))) {
             converter.getAclManager().addNodetypeRegistration(IOUtils.toString(cndStatements));
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/PrivilegesHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/PrivilegesHandler.java
index 2440475..037754e 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/PrivilegesHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/PrivilegesHandler.java
@@ -29,7 +29,7 @@ public class PrivilegesHandler extends AbstractRegexEntryHandler {
     }
 
     @Override
-    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter) {
+    public void handle(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, @NotNull ContentPackage2FeatureModelConverter converter, String runMode) {
         PrivilegeDefinitions privileges = archive.getMetaInf().getPrivileges();
         if (privileges != null) {
             converter.getAclManager().addPrivilegeDefinitions(privileges);
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/handlers/VersionResolverContentPackageEntryHandler.java b/src/main/java/org/apache/sling/feature/cpconverter/handlers/VersionResolverContentPackageEntryHandler.java
index 23ab9de..4da98ab 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/handlers/VersionResolverContentPackageEntryHandler.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/handlers/VersionResolverContentPackageEntryHandler.java
@@ -71,7 +71,7 @@ public final class VersionResolverContentPackageEntryHandler extends AbstractCon
             subContentPackages.put(currentId, path);
 
             // iteratively traverse the sub(-sub)*content-packages
-            scanner.traverse(contentPackage);
+            scanner.traverse(contentPackage, runMode);
         }
     }
 
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java b/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java
index 337523e..0233cac 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java
@@ -58,11 +58,11 @@ public abstract class BaseVaultPackageScanner {
         return packageManager.open(vaultPackage, strictValidation);
     }
 
-    public final void traverse(@NotNull File vaultPackageFile, boolean closeOnTraversed) throws IOException, ConverterException {
+    public final void traverse(@NotNull File vaultPackageFile, boolean closeOnTraversed, String runMode) throws IOException, ConverterException {
         VaultPackage vaultPackage = null;
         try {
             vaultPackage = open(vaultPackageFile);
-            traverse(vaultPackage);
+            traverse(vaultPackage, runMode);
         } finally {
             if (closeOnTraversed) {
                 if (vaultPackage != null) {
@@ -72,7 +72,7 @@ public abstract class BaseVaultPackageScanner {
         }
     }
 
-    public final void traverse(@NotNull VaultPackage vaultPackage) throws IOException, ConverterException {
+    public final void traverse(@NotNull VaultPackage vaultPackage, String runMode) throws IOException, ConverterException {
         requireNonNull(vaultPackage, "Impossible to process a null vault package");
 
         PackageProperties properties = vaultPackage.getProperties();
@@ -88,20 +88,20 @@ public abstract class BaseVaultPackageScanner {
             archive.open(strictValidation);
 
             Entry root = archive.getRoot();
-            traverse(null, archive, root);
+            traverse(null, archive, root, runMode);
         } finally {
             archive.close();
         }
     }
 
-    private void traverse(@Nullable String path, @NotNull Archive archive, @NotNull Entry entry) throws IOException, ConverterException {
+    private void traverse(@Nullable String path, @NotNull Archive archive, @NotNull Entry entry, String runMode) throws IOException, ConverterException {
         String entryPath = newPath(path, entry.getName());
 
         if (entry.isDirectory()) {
             onDirectory(entryPath, archive, entry);
 
             for (Entry child : entry.getChildren()) {
-                traverse(entryPath, archive, child);
+                traverse(entryPath, archive, child, runMode);
             }
 
             return;
@@ -109,7 +109,7 @@ public abstract class BaseVaultPackageScanner {
 
         logger.debug("Processing entry {}...", entryPath);
 
-        onFile(entryPath, archive, entry);
+        onFile(entryPath, archive, entry, runMode);
 
         logger.debug("Entry {} successfully processed.", entryPath);
     }
@@ -126,7 +126,7 @@ public abstract class BaseVaultPackageScanner {
         // do nothing by default
     }
 
-    protected void onFile(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry) throws IOException, ConverterException {
+    protected void onFile(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, String runMode) throws IOException, ConverterException {
         // do nothing by default
     }
 
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/RecollectorVaultPackageScanner.java b/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/RecollectorVaultPackageScanner.java
index fddd6ef..4838ede 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/RecollectorVaultPackageScanner.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/RecollectorVaultPackageScanner.java
@@ -55,10 +55,10 @@ public final class RecollectorVaultPackageScanner extends BaseVaultPackageScanne
     }
 
     @Override
-    protected void onFile(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry) throws IOException, ConverterException {
+    protected void onFile(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, String runMode) throws IOException, ConverterException {
         for (EntryHandler handler : handlers) {
             if (handler.matches(path)) {
-                handler.handle(path, archive, entry, converter);
+                handler.handle(path, archive, entry, converter, runMode);
             }
         }
     }
diff --git a/src/test/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverterTest.java b/src/test/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverterTest.java
index 234ce30..55f753b 100644
--- a/src/test/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverterTest.java
+++ b/src/test/java/org/apache/sling/feature/cpconverter/ContentPackage2FeatureModelConverterTest.java
@@ -52,6 +52,7 @@ import org.apache.jackrabbit.vault.packaging.VaultPackage;
 import org.apache.jackrabbit.vault.packaging.impl.PackageManagerImpl;
 import org.apache.sling.feature.ArtifactId;
 import org.apache.sling.feature.Artifacts;
+import org.apache.sling.feature.Bundles;
 import org.apache.sling.feature.Configuration;
 import org.apache.sling.feature.Configurations;
 import org.apache.sling.feature.Extension;
@@ -59,6 +60,7 @@ import org.apache.sling.feature.ExtensionType;
 import org.apache.sling.feature.Feature;
 import org.apache.sling.feature.cpconverter.accesscontrol.AclManager;
 import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter.PackagePolicy;
+import org.apache.sling.feature.cpconverter.ContentPackage2FeatureModelConverter.RunModePolicy;
 import org.apache.sling.feature.cpconverter.accesscontrol.DefaultAclManager;
 import org.apache.sling.feature.cpconverter.artifacts.LocalMavenRepositoryArtifactsDeployer;
 import org.apache.sling.feature.cpconverter.artifacts.SimpleFolderArtifactsDeployer;
@@ -569,6 +571,125 @@ public class ContentPackage2FeatureModelConverterTest extends AbstractConverterT
             deleteDirTree(outputDirectory);
         }
     }
+    
+    
+    @Test
+    public void verifyRunModesInheritedWithInheritanceOn() throws Exception {
+        URL packageUrl = getClass().getResource("runmodenesting-0.0.1.zip");
+        File packageFile = FileUtils.toFile(packageUrl);
+
+        File outputDirectory = new File(System.getProperty("java.io.tmpdir"), getClass().getName() + '_' + System.currentTimeMillis());
+
+        try {
+            converter.setFeaturesManager(new DefaultFeaturesManager(true, 5, outputDirectory, null, null, new HashMap<>(), new DefaultAclManager()))
+                    .setBundlesDeployer(new LocalMavenRepositoryArtifactsDeployer(outputDirectory))
+                    .setEmitter(DefaultPackagesEventsEmitter.open(outputDirectory))
+                    .setRunModePolicy(RunModePolicy.PREPEND_INHERITED)
+                    .convert(packageFile);
+            
+            File runModeMapperFile = new File(outputDirectory, "runmode.mapping");
+            assertTrue(runModeMapperFile.exists());
+            assertTrue(runModeMapperFile.isFile());
+            Properties runModes = new Properties();
+            try (FileInputStream input = new FileInputStream(runModeMapperFile)) {
+                runModes.load(input);
+            }
+            assertFalse(runModes.isEmpty());
+            assertTrue(runModes.containsKey("(default)"));
+            assertEquals("runmodetest_parentcontainer-author.json", runModes.getProperty("author"));
+            
+            // general
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer.json"), "asd.sample:embedded.test.app:zip:cp2fm-converted:0.0.0", false);
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer.json"), "my_packages:test_a:zip:cp2fm-converted:1.0", false);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer.json"), "io.wcm:io.wcm.handler.media:1.11.6", false);
+            
+            // author
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "asd.sample:embedded.test.app:zip:cp2fm-converted:0.0.0", true);
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "my_packages:test_a:zip:cp2fm-converted:1.0", true);
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "my_packages:test_b:zip:cp2fm-converted:1.0", true);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "io.wcm:io.wcm.handler.media:1.11.6", true);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "io.wcm:io.wcm.handler.link:1.7.02", true);
+            
+            // publish
+            assertFalse(new File(outputDirectory, "runmodetest_parentcontainer-publish.json").exists());
+            
+            // author.publish (for cp converter those are not mutually exclusive)
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.publish.json"), "my_packages:test_c:zip:cp2fm-converted:1.0", true);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.publish.json"), "com.composum.nodes:composum-nodes-config:2.5.3", true);
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.publish.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~c", true);
+
+            
+            //author.dev
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.dev.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~d", true);
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.dev.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~f", true);
+
+            //author.prod
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.prod.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~e", true);
+            
+            // dev
+            assertFalse(new File(outputDirectory, "runmodetest_parentcontainer-dev.json").exists());
+            
+        } finally {
+            deleteDirTree(outputDirectory);
+        }
+    }
+
+    
+    @Test
+    public void verifyRunModesInheritedWithInheritanceOff() throws Exception {
+        URL packageUrl = getClass().getResource("runmodenesting-0.0.1.zip");
+        File packageFile = FileUtils.toFile(packageUrl);
+
+        File outputDirectory = new File(System.getProperty("java.io.tmpdir"), getClass().getName() + '_' + System.currentTimeMillis());
+
+        try {
+            converter.setFeaturesManager(new DefaultFeaturesManager(true, 5, outputDirectory, null, null, new HashMap<>(), new DefaultAclManager()))
+                    .setBundlesDeployer(new LocalMavenRepositoryArtifactsDeployer(outputDirectory))
+                    .setEmitter(DefaultPackagesEventsEmitter.open(outputDirectory))
+                    .setRunModePolicy(RunModePolicy.DIRECT_ONLY)
+                    .convert(packageFile);
+            
+            File runModeMapperFile = new File(outputDirectory, "runmode.mapping");
+            assertTrue(runModeMapperFile.exists());
+            assertTrue(runModeMapperFile.isFile());
+            Properties runModes = new Properties();
+            try (FileInputStream input = new FileInputStream(runModeMapperFile)) {
+                runModes.load(input);
+            }
+            assertFalse(runModes.isEmpty());
+            assertTrue(runModes.containsKey("(default)"));
+            assertEquals("runmodetest_parentcontainer-author.json", runModes.getProperty("author"));
+            
+            // general
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer.json"), "asd.sample:embedded.test.app:zip:cp2fm-converted:0.0.0", false);
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer.json"), "my_packages:test_a:zip:cp2fm-converted:1.0", true);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer.json"), "io.wcm:io.wcm.handler.media:1.11.6", true);
+            
+            // author
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "asd.sample:embedded.test.app:zip:cp2fm-converted:0.0.0", true);
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "my_packages:test_a:zip:cp2fm-converted:1.0", false);
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "my_packages:test_b:zip:cp2fm-converted:1.0", true);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.json"), "io.wcm:io.wcm.handler.link:1.7.02", true);
+            // publish
+            assertContentPackage(new File(outputDirectory, "runmodetest_parentcontainer-publish.json"), "my_packages:test_c:zip:cp2fm-converted:1.0", true);
+            assertBundleEntry(new File(outputDirectory, "runmodetest_parentcontainer-publish.json"), "com.composum.nodes:composum-nodes-config:2.5.3", true);
+            
+            // author.publish (for cp converter those are not mutually exclusive)
+            assertFalse(new File(outputDirectory, "runmodetest_parentcontainer-author.publish.json").exists());
+            
+           //author.dev
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.dev.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~d", true);
+            
+            //author.prod
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-author.prod.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~e", true);
+        
+            //dev
+            assertConfigEntry(new File(outputDirectory, "runmodetest_parentcontainer-dev.json"), "org.apache.jackrabbit.oak.spi.security.authentication.external.impl.DefaultSyncHandler~f", true);
+        } finally {
+            deleteDirTree(outputDirectory);
+        }
+    }
+
 
 
     @Test(expected = ConverterException.class)
@@ -688,6 +809,52 @@ public class ContentPackage2FeatureModelConverterTest extends AbstractConverterT
             assertTrue(exports == null || exports.isEmpty());
         }
     }
+    
+    private static void assertContentPackage(File featureFile, String packageCoordinates, boolean isPresent) throws IOException {
+        try (Reader reader = new FileReader(featureFile)) {
+            Feature feature = FeatureJSONReader.read(reader, featureFile.getAbsolutePath());
+
+            Extension contentPackages = feature.getExtensions().getByName("content-packages");
+            assertEquals(ExtensionType.ARTIFACTS, contentPackages.getType());
+            Artifacts artifacts = contentPackages.getArtifacts();
+            ArtifactId aId = ArtifactId.fromMvnId(packageCoordinates);
+            if (isPresent) {
+                assertTrue("Missing package from featurefile", artifacts.containsExact(aId));
+            } else {
+                assertFalse("Package not expected in featurefile", artifacts.containsExact(aId));
+            }
+            
+        }
+    }
+    
+    private static void assertConfigEntry(File featureFile, String pid, boolean isPresent) throws IOException {
+        try (Reader reader = new FileReader(featureFile)) {
+            Feature feature = FeatureJSONReader.read(reader, featureFile.getAbsolutePath());
+
+            Configurations configs  = feature.getConfigurations();
+            if (isPresent) {
+                assertTrue("Missing Configuration from featurefile", configs.getConfiguration(pid) != null);
+            } else {
+                assertFalse("Configuration not expected in featurefile", configs.getConfiguration(pid) == null);
+            }
+            
+        }
+    }
+    
+    private static void assertBundleEntry(File featureFile, String bundleCoordinates, boolean isPresent) throws IOException {
+        try (Reader reader = new FileReader(featureFile)) {
+            Feature feature = FeatureJSONReader.read(reader, featureFile.getAbsolutePath());
+
+            Bundles bundles = feature.getBundles();
+            ArtifactId aId = ArtifactId.fromMvnId(bundleCoordinates);
+            if (isPresent) {
+                assertTrue("Missing Bundle from featurefile", bundles.containsExact(aId));
+            } else {
+                assertFalse("Bundle not expected in featurefile", bundles.containsExact(aId));
+            }
+            
+        }
+    }
 
     @Test
     public void overrideFeatureId() throws Exception {
diff --git a/src/test/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandlerTest.java b/src/test/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandlerTest.java
index f9a5e99..15ca995 100644
--- a/src/test/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandlerTest.java
+++ b/src/test/java/org/apache/sling/feature/cpconverter/handlers/BundleEntryHandlerTest.java
@@ -131,7 +131,7 @@ public final class BundleEntryHandlerTest {
 
     @Parameters
     public static Collection<Object[]> data() {
-        final BundleEntryHandler bundleEntryHandler = new BundleEntryHandler();
+        final AbstractRegexEntryHandler bundleEntryHandler = new BundleEntryHandler();
 
         return Arrays.asList(new Object[][] {
                 { "/jcr_root/apps/asd/install/test-framework-no-pom.jar", bundleEntryHandler, 20 },
diff --git a/src/test/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandlerTest.java b/src/test/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandlerTest.java
index 48d6c18..e724dd4 100644
--- a/src/test/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandlerTest.java
+++ b/src/test/java/org/apache/sling/feature/cpconverter/handlers/IndexDefinitionsEntryHandlerTest.java
@@ -276,12 +276,12 @@ public class IndexDefinitionsEntryHandlerTest {
 
                 new BaseVaultPackageScanner(true) {
                     @Override
-                    protected void onFile(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry)
+                    protected void onFile(@NotNull String path, @NotNull Archive archive, @NotNull Entry entry, String runMode)
                             throws IOException, ConverterException {
                         if ( handler.matches(path) )
                             handler.handle(path, archive, entry, converter);
                     }
-                }.traverse(new ZipVaultPackage(archive, true));
+                }.traverse(new ZipVaultPackage(archive, true), null);
             }
 
         }
diff --git a/src/test/java/org/apache/sling/feature/cpconverter/vltpkg/NodeTypesDetectionTest.java b/src/test/java/org/apache/sling/feature/cpconverter/vltpkg/NodeTypesDetectionTest.java
index 6d36490..1b82984 100644
--- a/src/test/java/org/apache/sling/feature/cpconverter/vltpkg/NodeTypesDetectionTest.java
+++ b/src/test/java/org/apache/sling/feature/cpconverter/vltpkg/NodeTypesDetectionTest.java
@@ -52,7 +52,7 @@ public class NodeTypesDetectionTest {
                 detectedCndFiles.add(cndPattern.pattern());
             }
 
-        }.traverse(packageFile, true);
+        }.traverse(packageFile, true, null);
 
         assertFalse(detectedCndFiles.isEmpty());
         assertEquals(1, detectedCndFiles.size());
diff --git a/src/test/resources/org/apache/sling/feature/cpconverter/runmodenesting-0.0.1.zip b/src/test/resources/org/apache/sling/feature/cpconverter/runmodenesting-0.0.1.zip
new file mode 100644
index 0000000..ae01bf2
Binary files /dev/null and b/src/test/resources/org/apache/sling/feature/cpconverter/runmodenesting-0.0.1.zip differ
