diff --git a/src/main/java/org/apache/sling/feature/cpconverter/index/IndexDefinitions.java b/src/main/java/org/apache/sling/feature/cpconverter/index/IndexDefinitions.java
index e3c1821..3716ecc 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/index/IndexDefinitions.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/index/IndexDefinitions.java
@@ -28,6 +28,7 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Collectors;
 
+import org.apache.commons.collections.CollectionUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.jackrabbit.spi.Name;
 import org.apache.jackrabbit.vault.util.DocViewNode2;
@@ -56,6 +57,12 @@ public class IndexDefinitions {
     public void addNode(@NotNull String parentPath, @NotNull DocViewNode2 node) {
         List<DocViewNode2> currentChildren = children.computeIfAbsent(parentPath, k -> new ArrayList<>());
         DocViewNode2 existing = null;
+
+        if ( CollectionUtils.isEmpty(node.getProperties())
+                && ( binaries.get(parentPath + "/" + node.getName().getLocalName()) == null
+                || node.getName().getLocalName().contains(".xml"))){
+            return;
+        }
         for ( DocViewNode2 currentChild : currentChildren ) {
 
             // prevent duplicates
diff --git a/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java b/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java
index 0233cac..6e15d74 100644
--- a/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java
+++ b/src/main/java/org/apache/sling/feature/cpconverter/vltpkg/BaseVaultPackageScanner.java
@@ -100,8 +100,17 @@ public abstract class BaseVaultPackageScanner {
         if (entry.isDirectory()) {
             onDirectory(entryPath, archive, entry);
 
+            //traverse all subdirectory first like stopwords/charfilter
             for (Entry child : entry.getChildren()) {
-                traverse(entryPath, archive, child, runMode);
+                if(child.isDirectory()) {
+                    traverse(entryPath, archive, child, runMode);
+                }
+            }
+            //traverse all files after that so that binaries all already has entries for stopwords/charfilter txt files.
+            for (Entry child : entry.getChildren()) {
+                if(!child.isDirectory()) {
+                    traverse(entryPath, archive, child, runMode);
+                }
             }
 
             return;
diff --git a/src/test/java/org/apache/sling/feature/cpconverter/index/IndexDefinitionsJsonWriterTest.java b/src/test/java/org/apache/sling/feature/cpconverter/index/IndexDefinitionsJsonWriterTest.java
index 2a6c231..26e7566 100644
--- a/src/test/java/org/apache/sling/feature/cpconverter/index/IndexDefinitionsJsonWriterTest.java
+++ b/src/test/java/org/apache/sling/feature/cpconverter/index/IndexDefinitionsJsonWriterTest.java
@@ -194,6 +194,38 @@ public class IndexDefinitionsJsonWriterTest {
             .hasFieldOrPropertyWithValue("string", ":blobId:" + Base64.encode(configXmlFileContents));
     }
 
+    @Test
+    public void propertyIndexDefinitionWithEmptyNodes() throws IOException {
+
+        Collection<DocViewProperty2> fooProps = new ArrayList<>();
+        fooProps.add(new DocViewProperty2(nameFactory.create("{}type"), "property"));
+        fooProps.add(new DocViewProperty2(nameFactory.create("{}comment"), "foo:bar"));
+        fooProps.add(new DocViewProperty2(nameFactory.create(NamespaceRegistry.NAMESPACE_JCR, "primaryType"), OAK_PREFIX+":QueryIndexDefinition"));
+        fooProps.add(new DocViewProperty2(nameFactory.create("{}reindex"), Boolean.FALSE.toString(), PropertyType.BOOLEAN));
+        fooProps.add(new DocViewProperty2(nameFactory.create("{}reindexCount"), "1", PropertyType.LONG));
+
+        definitions.addNode("/oak:index", new DocViewNode2(nameFactory.create("{}foo"), fooProps));
+
+        Collection<DocViewProperty2> barProps = new ArrayList<>();
+        barProps.add(new DocViewProperty2(nameFactory.create("{}type"), "property"));
+        barProps.add(new DocViewProperty2(nameFactory.create(NamespaceRegistry.NAMESPACE_JCR, "primaryType"), OAK_PREFIX+":QueryIndexDefinition"));
+        barProps.add(new DocViewProperty2(nameFactory.create("{}reindex"), Boolean.TRUE.toString(), PropertyType.BOOLEAN));
+        barProps.add(new DocViewProperty2(nameFactory.create("{}reindexCount"), "25", PropertyType.LONG));
+
+        definitions.addNode("/oak:index", new DocViewNode2(nameFactory.create("{}bar"), barProps));
+
+        //creating oak index with empty node properties.
+        Collection<DocViewProperty2> maiProps = new ArrayList<>();
+        definitions.addNode("/oak:index", new DocViewNode2(nameFactory.create("{}mai"),maiProps));
+
+        JsonObject root = generateAndParse(definitions);
+        // should be two instead of three
+        assertThat(root).as("indexDefinitions")
+                .hasSize(2)
+                .hasEntrySatisfying("/oak:index/foo", Conditions.isJsonObject())
+                .hasEntrySatisfying("/oak:index/bar", Conditions.isJsonObject())
+                .doesNotContainKey("/oak:index/mai");
+    }
 
     private JsonObject generateAndParse(IndexDefinitions definitions) throws IOException {
 
