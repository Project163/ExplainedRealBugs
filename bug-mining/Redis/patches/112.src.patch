diff --git a/src/t_stream.c b/src/t_stream.c
index 577954451..d721780a6 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -2980,6 +2980,10 @@ NULL
             s = o->ptr;
             signalModifiedKey(c,c->db,c->argv[2]);
         }
+        
+        if (entries_read != SCG_INVALID_ENTRIES_READ && (uint64_t)entries_read > s->entries_added) {
+            entries_read = s->entries_added;
+        }
 
         streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id,entries_read);
         if (cg) {
@@ -2997,6 +3001,11 @@ NULL
         } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
             return;
         }
+
+        if (entries_read != SCG_INVALID_ENTRIES_READ && (uint64_t)entries_read > s->entries_added) {
+            entries_read = s->entries_added;
+        }
+        
         streamUpdateCGroupLastId(s, cg, &id);
         cg->entries_read = entries_read;
         addReply(c,shared.ok);
diff --git a/tests/unit/type/stream-cgroups.tcl b/tests/unit/type/stream-cgroups.tcl
index 2fbe794bf..05c56074e 100644
--- a/tests/unit/type/stream-cgroups.tcl
+++ b/tests/unit/type/stream-cgroups.tcl
@@ -1630,5 +1630,33 @@ start_server {
             assert_equal {0 {} {} {}} [r XPENDING mystream group1]
             assert_equal {0 {} {} {}} [r XPENDING mystream group2]
         }
+
+        test "XGROUP CREATE with ENTRIESREAD larger than stream entries should cap the value" {
+            r DEL mystream
+            r xadd mystream * field value
+            r xgroup create mystream mygroup $ entriesread 9999
+
+            set reply [r XINFO STREAM mystream FULL]
+            set group [lindex [dict get $reply groups] 0]
+
+            # Lag must be 0 and entries-read must be 1.
+            assert_equal [dict get $group lag] 0
+            assert_equal [dict get $group entries-read] 1
+        }
+
+        test "XGROUP SETID with ENTRIESREAD larger than stream entries should cap the value" {
+            r DEL mystream
+            r xadd mystream * field value
+            r xgroup create mystream mygroup $
+
+            r xgroup setid mystream mygroup $ entriesread 9999
+
+            set reply [r XINFO STREAM mystream FULL]
+            set group [lindex [dict get $reply groups] 0]
+
+            # Lag must be 0 and entries-read must be 1.
+            assert_equal [dict get $group lag] 0
+            assert_equal [dict get $group entries-read] 1
+        }
     }
 }
