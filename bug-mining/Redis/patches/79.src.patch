diff --git a/src/cluster.c b/src/cluster.c
index 94c0d131d..c788194f1 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -848,7 +848,7 @@ void setClusterNodeToInboundClusterLink(clusterNode *node, clusterLink *link) {
          * one inbound link from the same node at the same time. Our cleanup logic assumes
          * a one to one relationship between nodes and inbound links, so we need to kill
          * one of the links. The existing link is more likely the outdated one, but it's
-         * possible the the other node may need to open another link. */
+         * possible the other node may need to open another link. */
         serverLog(LL_DEBUG, "Replacing inbound link fd %d from node %.40s with fd %d",
                 node->inbound_link->conn->fd, node->name, link->conn->fd);
         freeClusterLink(node->inbound_link);
@@ -5216,7 +5216,7 @@ void clusterReplyShards(client *c) {
             continue;
         }
         shard_count++;
-        /* n->slot_info_pairs is set to NULL when the the node owns no slots. */
+        /* n->slot_info_pairs is set to NULL when the node owns no slots. */
         addShardReplyForClusterShards(c, n, n->slot_info_pairs, n->slot_info_pairs_count);
         clusterFreeNodesSlotsInfo(n);
     }
@@ -6652,7 +6652,7 @@ void readwriteCommand(client *c) {
 /* Return the pointer to the cluster node that is able to serve the command.
  * For the function to succeed the command should only target either:
  *
- * 1) A single key (even multiple times like LPOPRPUSH mylist mylist).
+ * 1) A single key (even multiple times like RPOPLPUSH mylist mylist).
  * 2) Multiple keys in the same hash slot, while the slot is stable (no
  *    resharding in progress).
  *
diff --git a/src/commands.c b/src/commands.c
index 8722a9712..569b47a43 100644
--- a/src/commands.c
+++ b/src/commands.c
@@ -640,7 +640,7 @@ struct redisCommand CLUSTER_Subcommands[] = {
 {"failover","Forces a replica to perform a manual failover of its master.","O(1)","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_FAILOVER_History,CLUSTER_FAILOVER_tips,clusterCommand,-2,CMD_NO_ASYNC_LOADING|CMD_ADMIN|CMD_STALE,0,.args=CLUSTER_FAILOVER_Args},
 {"flushslots","Delete a node's own slots information","O(1)","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_FLUSHSLOTS_History,CLUSTER_FLUSHSLOTS_tips,clusterCommand,2,CMD_NO_ASYNC_LOADING|CMD_ADMIN|CMD_STALE,0},
 {"forget","Remove a node from the nodes table","O(1)","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_FORGET_History,CLUSTER_FORGET_tips,clusterCommand,3,CMD_NO_ASYNC_LOADING|CMD_ADMIN|CMD_STALE,0,.args=CLUSTER_FORGET_Args},
-{"getkeysinslot","Return local key names in the specified hash slot","O(log(N)) where N is the number of requested keys","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_GETKEYSINSLOT_History,CLUSTER_GETKEYSINSLOT_tips,clusterCommand,4,CMD_STALE,0,.args=CLUSTER_GETKEYSINSLOT_Args},
+{"getkeysinslot","Return local key names in the specified hash slot","O(N) where N is the number of requested keys","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_GETKEYSINSLOT_History,CLUSTER_GETKEYSINSLOT_tips,clusterCommand,4,CMD_STALE,0,.args=CLUSTER_GETKEYSINSLOT_Args},
 {"help","Show helpful text about the different subcommands","O(1)","5.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_HELP_History,CLUSTER_HELP_tips,clusterCommand,2,CMD_LOADING|CMD_STALE,0},
 {"info","Provides info about Redis Cluster node state","O(1)","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_INFO_History,CLUSTER_INFO_tips,clusterCommand,2,CMD_STALE,0},
 {"keyslot","Returns the hash slot of the specified key","O(N) where N is the number of bytes in the key","3.0.0",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_CLUSTER,CLUSTER_KEYSLOT_History,CLUSTER_KEYSLOT_tips,clusterCommand,3,CMD_STALE,0,.args=CLUSTER_KEYSLOT_Args},
diff --git a/src/commands/cluster-getkeysinslot.json b/src/commands/cluster-getkeysinslot.json
index 97c3a3b8e..06c1b03c8 100644
--- a/src/commands/cluster-getkeysinslot.json
+++ b/src/commands/cluster-getkeysinslot.json
@@ -1,7 +1,7 @@
 {
     "GETKEYSINSLOT": {
         "summary": "Return local key names in the specified hash slot",
-        "complexity": "O(log(N)) where N is the number of requested keys",
+        "complexity": "O(N) where N is the number of requested keys",
         "group": "cluster",
         "since": "3.0.0",
         "arity": 4,
diff --git a/src/rax.c b/src/rax.c
index bef13a440..287f9855d 100644
--- a/src/rax.c
+++ b/src/rax.c
@@ -352,7 +352,7 @@ raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode **
      * we don't need to do anything if there was already some padding to use. In
      * that case the final destination of the pointers will be the same, however
      * in our example there was no pre-existing padding, so we added one byte
-     * plus there bytes of padding. After the next memmove() things will look
+     * plus three bytes of padding. After the next memmove() things will look
      * like that:
      *
      * [HDR*][abde][....][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
diff --git a/src/replication.c b/src/replication.c
index 4e1160752..f60fcfd00 100644
--- a/src/replication.c
+++ b/src/replication.c
@@ -1581,7 +1581,7 @@ void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
              * the slave online. */
             if (type == RDB_CHILD_TYPE_SOCKET) {
                 serverLog(LL_NOTICE,
-                    "Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from slave to enable streaming",
+                    "Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from replica to enable streaming",
                         replicationGetSlaveName(slave));
                 /* Note: we wait for a REPLCONF ACK message from the replica in
                  * order to really put it online (install the write handler
diff --git a/src/server.h b/src/server.h
index 62385bbfd..92acaa9a0 100644
--- a/src/server.h
+++ b/src/server.h
@@ -2729,7 +2729,6 @@ int loadAppendOnlyFiles(aofManifest *am);
 void stopAppendOnly(void);
 int startAppendOnly(void);
 void backgroundRewriteDoneHandler(int exitcode, int bysignal);
-ssize_t aofReadDiffFromParent(void);
 void killAppendOnlyChild(void);
 void restartAOFAfterSYNC();
 void aofLoadManifestFromDisk(void);
diff --git a/src/tracking.c b/src/tracking.c
index c4b534a62..1b04c0626 100644
--- a/src/tracking.c
+++ b/src/tracking.c
@@ -412,7 +412,7 @@ void trackingInvalidateKey(client *c, robj *keyobj, int bcast) {
     raxRemove(TrackingTable,(unsigned char*)key,keylen,NULL);
 }
 
-void trackingHandlePendingKeyInvalidations() {
+void trackingHandlePendingKeyInvalidations(void) {
     if (!listLength(server.tracking_pending_keys)) return;
 
     listNode *ln;
