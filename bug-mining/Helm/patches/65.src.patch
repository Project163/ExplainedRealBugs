diff --git a/pkg/lint/rules/template.go b/pkg/lint/rules/template.go
index 3da5b63fa..9a3a2a1ba 100644
--- a/pkg/lint/rules/template.go
+++ b/pkg/lint/rules/template.go
@@ -19,6 +19,7 @@ package rules
 import (
 	"fmt"
 	"os"
+	"path"
 	"path/filepath"
 	"regexp"
 	"strings"
@@ -47,10 +48,10 @@ var validName = regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-
 
 // Templates lints the templates in the Linter.
 func Templates(linter *support.Linter, values map[string]interface{}, namespace string, strict bool) {
-	path := "templates/"
-	templatesPath := filepath.Join(linter.ChartDir, path)
+	fpath := "templates/"
+	templatesPath := filepath.Join(linter.ChartDir, fpath)
 
-	templatesDirExist := linter.RunLinterRule(support.WarningSev, path, validateTemplatesDir(templatesPath))
+	templatesDirExist := linter.RunLinterRule(support.WarningSev, fpath, validateTemplatesDir(templatesPath))
 
 	// Templates directory is optional for now
 	if !templatesDirExist {
@@ -60,7 +61,7 @@ func Templates(linter *support.Linter, values map[string]interface{}, namespace
 	// Load chart and parse templates
 	chart, err := loader.Load(linter.ChartDir)
 
-	chartLoaded := linter.RunLinterRule(support.ErrorSev, path, err)
+	chartLoaded := linter.RunLinterRule(support.ErrorSev, fpath, err)
 
 	if !chartLoaded {
 		return
@@ -77,14 +78,14 @@ func Templates(linter *support.Linter, values map[string]interface{}, namespace
 	}
 	valuesToRender, err := chartutil.ToRenderValues(chart, cvals, options, nil)
 	if err != nil {
-		linter.RunLinterRule(support.ErrorSev, path, err)
+		linter.RunLinterRule(support.ErrorSev, fpath, err)
 		return
 	}
 	var e engine.Engine
 	e.LintMode = true
 	renderedContentMap, err := e.Render(chart, valuesToRender)
 
-	renderOk := linter.RunLinterRule(support.ErrorSev, path, err)
+	renderOk := linter.RunLinterRule(support.ErrorSev, fpath, err)
 
 	if !renderOk {
 		return
@@ -99,13 +100,13 @@ func Templates(linter *support.Linter, values map[string]interface{}, namespace
 	*/
 	for _, template := range chart.Templates {
 		fileName, data := template.Name, template.Data
-		path = fileName
+		fpath = fileName
 
-		linter.RunLinterRule(support.ErrorSev, path, validateAllowedExtension(fileName))
+		linter.RunLinterRule(support.ErrorSev, fpath, validateAllowedExtension(fileName))
 		// These are v3 specific checks to make sure and warn people if their
 		// chart is not compatible with v3
-		linter.RunLinterRule(support.WarningSev, path, validateNoCRDHooks(data))
-		linter.RunLinterRule(support.ErrorSev, path, validateNoReleaseTime(data))
+		linter.RunLinterRule(support.WarningSev, fpath, validateNoCRDHooks(data))
+		linter.RunLinterRule(support.ErrorSev, fpath, validateNoReleaseTime(data))
 
 		// We only apply the following lint rules to yaml files
 		if filepath.Ext(fileName) != ".yaml" || filepath.Ext(fileName) == ".yml" {
@@ -114,12 +115,12 @@ func Templates(linter *support.Linter, values map[string]interface{}, namespace
 
 		// NOTE: disabled for now, Refs https://github.com/helm/helm/issues/1463
 		// Check that all the templates have a matching value
-		//linter.RunLinterRule(support.WarningSev, path, validateNoMissingValues(templatesPath, valuesToRender, preExecutedTemplate))
+		//linter.RunLinterRule(support.WarningSev, fpath, validateNoMissingValues(templatesPath, valuesToRender, preExecutedTemplate))
 
 		// NOTE: disabled for now, Refs https://github.com/helm/helm/issues/1037
-		// linter.RunLinterRule(support.WarningSev, path, validateQuotes(string(preExecutedTemplate)))
+		// linter.RunLinterRule(support.WarningSev, fpath, validateQuotes(string(preExecutedTemplate)))
 
-		renderedContent := renderedContentMap[filepath.Join(chart.Name(), fileName)]
+		renderedContent := renderedContentMap[path.Join(chart.Name(), fileName)]
 		if strings.TrimSpace(renderedContent) != "" {
 			var yamlStruct K8sYamlStruct
 			// Even though K8sYamlStruct only defines a few fields, an error in any other
@@ -128,10 +129,10 @@ func Templates(linter *support.Linter, values map[string]interface{}, namespace
 
 			// If YAML linting fails, we sill progress. So we don't capture the returned state
 			// on this linter run.
-			linter.RunLinterRule(support.ErrorSev, path, validateYamlContent(err))
-			linter.RunLinterRule(support.ErrorSev, path, validateMetadataName(&yamlStruct))
-			linter.RunLinterRule(support.ErrorSev, path, validateNoDeprecations(&yamlStruct))
-			linter.RunLinterRule(support.ErrorSev, path, validateMatchSelector(&yamlStruct, renderedContent))
+			linter.RunLinterRule(support.ErrorSev, fpath, validateYamlContent(err))
+			linter.RunLinterRule(support.ErrorSev, fpath, validateMetadataName(&yamlStruct))
+			linter.RunLinterRule(support.ErrorSev, fpath, validateNoDeprecations(&yamlStruct))
+			linter.RunLinterRule(support.ErrorSev, fpath, validateMatchSelector(&yamlStruct, renderedContent))
 		}
 	}
 }
