diff --git a/pkg/chart/loader/archive_test.go b/pkg/chart/loader/archive_test.go
index 7d8c8b51e..41b0af1aa 100644
--- a/pkg/chart/loader/archive_test.go
+++ b/pkg/chart/loader/archive_test.go
@@ -43,46 +43,26 @@ func TestLoadArchiveFiles(t *testing.T) {
 			generate: func(w *tar.Writer) {
 				// simulate the presence of a `pax_global_header` file like you would get when
 				// processing a GitHub release archive.
-				_ = w.WriteHeader(&tar.Header{
+				err := w.WriteHeader(&tar.Header{
 					Typeflag: tar.TypeXGlobalHeader,
 					Name:     "pax_global_header",
 				})
-
-				// we need to have at least one file, otherwise we'll get the "no files in chart archive" error
-				_ = w.WriteHeader(&tar.Header{
-					Typeflag: tar.TypeReg,
-					Name:     "dir/empty",
-				})
-			},
-			check: func(t *testing.T, files []*BufferedFile, err error) {
 				if err != nil {
-					t.Fatalf(`got unwanted error [%#v] for tar file with pax_global_header content`, err)
+					t.Fatal(err)
 				}
 
-				if len(files) != 1 {
-					t.Fatalf(`expected to get one file but got [%v]`, files)
-				}
-			},
-		},
-		{
-			name: "should ignore files with TypeXHeader type",
-			generate: func(w *tar.Writer) {
-				// simulate the presence of a `pax_header` file like you might get when
-				// processing a GitHub release archive.
-				_ = w.WriteHeader(&tar.Header{
-					Typeflag: tar.TypeXHeader,
-					Name:     "pax_header",
-				})
-
 				// we need to have at least one file, otherwise we'll get the "no files in chart archive" error
-				_ = w.WriteHeader(&tar.Header{
+				err = w.WriteHeader(&tar.Header{
 					Typeflag: tar.TypeReg,
 					Name:     "dir/empty",
 				})
+				if err != nil {
+					t.Fatal(err)
+				}
 			},
 			check: func(t *testing.T, files []*BufferedFile, err error) {
 				if err != nil {
-					t.Fatalf(`got unwanted error [%#v] for tar file with pax_header content`, err)
+					t.Fatalf(`got unwanted error [%#v] for tar file with pax_global_header content`, err)
 				}
 
 				if len(files) != 1 {
diff --git a/pkg/plugin/installer/http_installer.go b/pkg/plugin/installer/http_installer.go
index 629bbec39..c07cad80a 100644
--- a/pkg/plugin/installer/http_installer.go
+++ b/pkg/plugin/installer/http_installer.go
@@ -188,6 +188,9 @@ func (g *TarGzExtractor) Extract(buffer *bytes.Buffer, targetDir string) error {
 				return err
 			}
 			outFile.Close()
+		// We don't want to process these extension header files.
+		case tar.TypeXGlobalHeader, tar.TypeXHeader:
+			continue
 		default:
 			return errors.Errorf("unknown type: %b in %s", header.Typeflag, header.Name)
 		}
diff --git a/pkg/plugin/installer/http_installer_test.go b/pkg/plugin/installer/http_installer_test.go
index b496a1b01..99470ace6 100644
--- a/pkg/plugin/installer/http_installer_test.go
+++ b/pkg/plugin/installer/http_installer_test.go
@@ -222,6 +222,19 @@ func TestExtract(t *testing.T) {
 			t.Fatal(err)
 		}
 	}
+
+	// Add pax global headers. This should be ignored.
+	// Note the PAX header that isn't global cannot be written using WriteHeader.
+	// Details are in the internal Go function for the tar packaged named
+	// allowedFormats. For a TypeXHeader it will return a message stating
+	// "cannot manually encode TypeXHeader, TypeGNULongName, or TypeGNULongLink headers"
+	if err := tw.WriteHeader(&tar.Header{
+		Name:     "pax_global_header",
+		Typeflag: tar.TypeXGlobalHeader,
+	}); err != nil {
+		t.Fatal(err)
+	}
+
 	if err := tw.Close(); err != nil {
 		t.Fatal(err)
 	}
