{"url":"https://api.github.com/repos/rwf2/Rocket/issues/465","repository_url":"https://api.github.com/repos/rwf2/Rocket","labels_url":"https://api.github.com/repos/rwf2/Rocket/issues/465/labels{/name}","comments_url":"https://api.github.com/repos/rwf2/Rocket/issues/465/comments","events_url":"https://api.github.com/repos/rwf2/Rocket/issues/465/events","html_url":"https://github.com/rwf2/Rocket/issues/465","id":267241552,"node_id":"MDU6SXNzdWUyNjcyNDE1NTI=","number":465,"title":"Return 405 Method Not Allowed for unsupported HTTP methods instead of just 500ing","user":{"login":"YetAnotherMinion","id":8005290,"node_id":"MDQ6VXNlcjgwMDUyOTA=","avatar_url":"https://avatars.githubusercontent.com/u/8005290?v=4","gravatar_id":"","url":"https://api.github.com/users/YetAnotherMinion","html_url":"https://github.com/YetAnotherMinion","followers_url":"https://api.github.com/users/YetAnotherMinion/followers","following_url":"https://api.github.com/users/YetAnotherMinion/following{/other_user}","gists_url":"https://api.github.com/users/YetAnotherMinion/gists{/gist_id}","starred_url":"https://api.github.com/users/YetAnotherMinion/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/YetAnotherMinion/subscriptions","organizations_url":"https://api.github.com/users/YetAnotherMinion/orgs","repos_url":"https://api.github.com/users/YetAnotherMinion/repos","events_url":"https://api.github.com/users/YetAnotherMinion/events{/privacy}","received_events_url":"https://api.github.com/users/YetAnotherMinion/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":343542068,"node_id":"MDU6TGFiZWwzNDM1NDIwNjg=","url":"https://api.github.com/repos/rwf2/Rocket/labels/enhancement","name":"enhancement","color":"5319E7","default":true,"description":"A minor feature request"},{"id":343542070,"node_id":"MDU6TGFiZWwzNDM1NDIwNzA=","url":"https://api.github.com/repos/rwf2/Rocket/labels/help%20wanted","name":"help wanted","color":"008672","default":true,"description":"Contributions to this issue are needed"},{"id":442152232,"node_id":"MDU6TGFiZWw0NDIxNTIyMzI=","url":"https://api.github.com/repos/rwf2/Rocket/labels/request","name":"request","color":"5319E7","default":false,"description":"Request for new functionality"},{"id":442158672,"node_id":"MDU6TGFiZWw0NDIxNTg2NzI=","url":"https://api.github.com/repos/rwf2/Rocket/labels/accepted","name":"accepted","color":"0E8A16","default":false,"description":"An accepted request or suggestion"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":1,"created_at":"2017-10-20T17:05:23Z","updated_at":"2017-12-28T07:11:10Z","closed_at":"2017-12-28T07:11:10Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"  1. Why you believe this feature is necessary.\r\nMakes it easier to build security alerts.\r\n\r\n  2. A convincing use-case for this feature.\r\nHelps distinguish attack traffic from run of the mill bugs in the rocket handlers. Having Rocket report incoming bad methods with 405 makes it easy to separate security alerts from developer alerts (500 code from logic errors, missing template files, missing db connection, ..etc). \r\n\r\n\r\n  3. Why this feature can't or shouldn't exist outside of Rocket.\r\nRocket is already parsing the method, so why do the work again in another system? One could read the code of Rocket and generate a whitelist of methods in the config language of their upstream proxy, but then they have to keep that config up to date with Rocket source code changes. This kind of silent dependency imposes an extra cost on organizations using Rocket. The extra work that would be independently required for every organization is why this should not exist outside of Rocket.\r\n\r\n\r\nThe below diff shows the general idea of distinguishing between request construction failures. Note: it fails to set the Allow header which is required by the spec, not sure the best way of generating that header value (should the registered routes be inspected at runtime to see which methods are allowed? ).\r\n```diff\r\ndiff --git a/lib/src/request/request.rs b/lib/src/request/request.rs\r\nindex f0492de..d3e78e5 100644\r\n--- a/lib/src/request/request.rs\r\n+++ b/lib/src/request/request.rs\r\n@@ -568,17 +568,17 @@ impl<'r> Request<'r> {\r\n                            h_headers: hyper::header::Headers,\r\n                            h_uri: hyper::RequestUri,\r\n                            h_addr: SocketAddr,\r\n-                           ) -> Result<Request<'r>, String> {\r\n+                           ) -> Result<Request<'r>, (Error, String)> {\r\n         // Get a copy of the URI for later use.\r\n         let uri = match h_uri {\r\n             hyper::RequestUri::AbsolutePath(s) => s,\r\n-            _ => return Err(format!(\"Bad URI: {}\", h_uri)),\r\n+            _ => return Err((Error::Internal, format!(\"Bad URI: {}\", h_uri))),\r\n         };\r\n \r\n         // Ensure that the method is known. TODO: Allow made-up methods?\r\n         let method = match Method::from_hyp(&h_method) {\r\n             Some(method) => method,\r\n-            None => return Err(format!(\"Invalid method: {}\", h_method))\r\n+            None => return Err((Error::BadMethod, format!(\"Invalid method: {}\", h_method)))\r\n         };\r\n \r\n         // Construct the request object.\r\ndiff --git a/lib/src/rocket.rs b/lib/src/rocket.rs\r\nindex 52f276a..bdb6f96 100644\r\n--- a/lib/src/rocket.rs\r\n+++ b/lib/src/rocket.rs\r\n@@ -55,10 +55,13 @@ impl hyper::Handler for Rocket {\r\n         let req_res = Request::from_hyp(self, h_method, h_headers, h_uri, h_addr);\r\n         let mut req = match req_res {\r\n             Ok(req) => req,\r\n-            Err(e) => {\r\n-                error!(\"Bad incoming request: {}\", e);\r\n+            Err((reason, log_message)) => {\r\n+                error!(\"Bad incoming request: {}\", log_message);\r\n                 let dummy = Request::new(self, Method::Get, Uri::new(\"<unknown>\"));\r\n-                let r = self.handle_error(Status::InternalServerError, &dummy);\r\n+                let r = match reason {\r\n+                    Error::BadMethod => self.handle_error(Status::MethodNotAllowed, &dummy),\r\n+                    _ => self.handle_error(Status::InternalServerError, &dummy),\r\n+                };\r\n                 return self.issue_response(r, res);\r\n             }\r\n         };\r\n```\r\n\r\n","closed_by":{"login":"SergioBenitez","id":1480321,"node_id":"MDQ6VXNlcjE0ODAzMjE=","avatar_url":"https://avatars.githubusercontent.com/u/1480321?v=4","gravatar_id":"","url":"https://api.github.com/users/SergioBenitez","html_url":"https://github.com/SergioBenitez","followers_url":"https://api.github.com/users/SergioBenitez/followers","following_url":"https://api.github.com/users/SergioBenitez/following{/other_user}","gists_url":"https://api.github.com/users/SergioBenitez/gists{/gist_id}","starred_url":"https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SergioBenitez/subscriptions","organizations_url":"https://api.github.com/users/SergioBenitez/orgs","repos_url":"https://api.github.com/users/SergioBenitez/repos","events_url":"https://api.github.com/users/SergioBenitez/events{/privacy}","received_events_url":"https://api.github.com/users/SergioBenitez/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rwf2/Rocket/issues/465/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rwf2/Rocket/issues/465/timeline","performed_via_github_app":null,"state_reason":"completed"}