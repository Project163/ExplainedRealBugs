{"url":"https://api.github.com/repos/rwf2/Rocket/issues/775","repository_url":"https://api.github.com/repos/rwf2/Rocket","labels_url":"https://api.github.com/repos/rwf2/Rocket/issues/775/labels{/name}","comments_url":"https://api.github.com/repos/rwf2/Rocket/issues/775/comments","events_url":"https://api.github.com/repos/rwf2/Rocket/issues/775/events","html_url":"https://github.com/rwf2/Rocket/issues/775","id":360845281,"node_id":"MDU6SXNzdWUzNjA4NDUyODE=","number":775,"title":"Ability to chain Data Guards.","user":{"login":"Carreau","id":335567,"node_id":"MDQ6VXNlcjMzNTU2Nw==","avatar_url":"https://avatars.githubusercontent.com/u/335567?v=4","gravatar_id":"","url":"https://api.github.com/users/Carreau","html_url":"https://github.com/Carreau","followers_url":"https://api.github.com/users/Carreau/followers","following_url":"https://api.github.com/users/Carreau/following{/other_user}","gists_url":"https://api.github.com/users/Carreau/gists{/gist_id}","starred_url":"https://api.github.com/users/Carreau/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Carreau/subscriptions","organizations_url":"https://api.github.com/users/Carreau/orgs","repos_url":"https://api.github.com/users/Carreau/repos","events_url":"https://api.github.com/users/Carreau/events{/privacy}","received_events_url":"https://api.github.com/users/Carreau/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":442152232,"node_id":"MDU6TGFiZWw0NDIxNTIyMzI=","url":"https://api.github.com/repos/rwf2/Rocket/labels/request","name":"request","color":"5319E7","default":false,"description":"Request for new functionality"},{"id":442158672,"node_id":"MDU6TGFiZWw0NDIxNTg2NzI=","url":"https://api.github.com/repos/rwf2/Rocket/labels/accepted","name":"accepted","color":"0E8A16","default":false,"description":"An accepted request or suggestion"}],"state":"closed","locked":false,"assignee":{"login":"SergioBenitez","id":1480321,"node_id":"MDQ6VXNlcjE0ODAzMjE=","avatar_url":"https://avatars.githubusercontent.com/u/1480321?v=4","gravatar_id":"","url":"https://api.github.com/users/SergioBenitez","html_url":"https://github.com/SergioBenitez","followers_url":"https://api.github.com/users/SergioBenitez/followers","following_url":"https://api.github.com/users/SergioBenitez/following{/other_user}","gists_url":"https://api.github.com/users/SergioBenitez/gists{/gist_id}","starred_url":"https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SergioBenitez/subscriptions","organizations_url":"https://api.github.com/users/SergioBenitez/orgs","repos_url":"https://api.github.com/users/SergioBenitez/repos","events_url":"https://api.github.com/users/SergioBenitez/events{/privacy}","received_events_url":"https://api.github.com/users/SergioBenitez/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"SergioBenitez","id":1480321,"node_id":"MDQ6VXNlcjE0ODAzMjE=","avatar_url":"https://avatars.githubusercontent.com/u/1480321?v=4","gravatar_id":"","url":"https://api.github.com/users/SergioBenitez","html_url":"https://github.com/SergioBenitez","followers_url":"https://api.github.com/users/SergioBenitez/followers","following_url":"https://api.github.com/users/SergioBenitez/following{/other_user}","gists_url":"https://api.github.com/users/SergioBenitez/gists{/gist_id}","starred_url":"https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SergioBenitez/subscriptions","organizations_url":"https://api.github.com/users/SergioBenitez/orgs","repos_url":"https://api.github.com/users/SergioBenitez/repos","events_url":"https://api.github.com/users/SergioBenitez/events{/privacy}","received_events_url":"https://api.github.com/users/SergioBenitez/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":{"url":"https://api.github.com/repos/rwf2/Rocket/milestones/6","html_url":"https://github.com/rwf2/Rocket/milestone/6","labels_url":"https://api.github.com/repos/rwf2/Rocket/milestones/6/labels","id":2224310,"node_id":"MDk6TWlsZXN0b25lMjIyNDMxMA==","number":6,"title":"0.6.0","description":"","creator":{"login":"SergioBenitez","id":1480321,"node_id":"MDQ6VXNlcjE0ODAzMjE=","avatar_url":"https://avatars.githubusercontent.com/u/1480321?v=4","gravatar_id":"","url":"https://api.github.com/users/SergioBenitez","html_url":"https://github.com/SergioBenitez","followers_url":"https://api.github.com/users/SergioBenitez/followers","following_url":"https://api.github.com/users/SergioBenitez/following{/other_user}","gists_url":"https://api.github.com/users/SergioBenitez/gists{/gist_id}","starred_url":"https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SergioBenitez/subscriptions","organizations_url":"https://api.github.com/users/SergioBenitez/orgs","repos_url":"https://api.github.com/users/SergioBenitez/repos","events_url":"https://api.github.com/users/SergioBenitez/events{/privacy}","received_events_url":"https://api.github.com/users/SergioBenitez/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":11,"closed_issues":18,"state":"open","created_at":"2017-01-03T03:17:51Z","updated_at":"2024-08-24T10:40:35Z","due_on":null,"closed_at":null},"comments":16,"created_at":"2018-09-17T12:27:40Z","updated_at":"2023-12-28T13:05:54Z","closed_at":"2023-12-28T04:09:11Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"This is a followup from IRC\r\n\r\n## Feature Requests\r\n\r\nIt would be nice to have a way to chain data guard. \r\n\r\n> 1. Why you believe this feature is necessary.\r\n> 2. A convincing use-case for this feature.\r\n\r\nUse-case : Request that are signed with a hash of the body, typically GitHub webhook. We need to way to verify the hash is correct and still likely dispatch to custom dataGuards.\r\n\r\n\r\nTake the following approximate example:\r\n\r\n```rust\r\n\r\n#[post(\"/\", data = \"<payload>\")]\r\nfn webhook_post(payload: SignedPayload<Json<Value>>) -> ... {\r\n\t...\r\n}\r\n\r\nimpl<T:FromData> FromData for SignedPayload<T> {\r\n    type Error = ();\r\n\r\n    fn from_data(request: &Request, data: Data) -> data::Outcome<Self, ()> {\r\n        let mut body = String::new();\r\n        if let Err(_) = data.open().read_to_string(&mut body) {\r\n            let mut hmac = Hmac::new(digest, secret.as_bytes());\r\n            hmac.input(body.as_bytes());\r\n            if hmac.result() != requests.headers.get_one('signature'){\r\n\t\t\t\treturn Outcome::Failure((Status::InternalServerError, ()));\r\n\t\t\t}\r\n        }\r\n\r\n        // ... need a way to chain to T::from_data, but data has been consumed.\r\n\t\tmatch T::from_data(request, data) {\r\n                Outcome::Success(val) => Outcome::Success(SignedPayload(val)),\r\n                ...\r\n        }\r\n}\r\n```\r\n\r\nThat would allow clean composition of Data Guards.\r\n\r\n  3. Why this feature can't or shouldn't exist outside of Rocket.\r\n\r\nData is private, AFAICT there is no way to recreate/reuse one.\r\nYou can see that [some project](https://github.com/aergonaut/railgun/) are basically implementing [this kind of DataGuard](https://github.com/aergonaut/railgun/blob/master/src/railgun/request.rs) but [defer deserializing into the handler themselves](https://github.com/aergonaut/railgun/blob/master/src/railgun/handlers/webhooks.rs#L12-L19) which seem (to me), like this goes again the Rocket way of doing things.\r\n\r\n## General Comments\r\n\r\nIt was discussed on IRC, but it was late here is an excerpt of the conversation:\r\n\r\n\r\n<details>\r\ncarreau\r\n\r\n> Hi all, I do have a small question about data-guards in rocket (i'm relatively new to rust), It may be a question of vocabulary but I don't seem to be able to find an answer.  Is it possible to chain Data Guards ? More specifically I want to write a data-guard that check that hash(secret+data.body) == value-in-header but to do so need to consume Data. I can't recreate it (necessary things are private), and would like to not re-implement the all the existing From Data. Or maybe I am trying o do things the wrong way. Thanks.\r\n\r\nSergio\r\n\r\n> What do you want to do with the data?\r\n> Yes, you can chain guards. \r\n\r\ncarreau\r\n\r\n> Typically:\r\n> #[post(\"/gh\", data = \"<payload>\")]\r\n> fn webhook_post(payload: SignedPayload<Json<Value>>) -> Whatever\r\n> But I want Json<Value> to be variable\r\n\r\nSergio\r\n\r\n> Yeah. \r\n> Hmm. Not sure if this can be done efficiently at the moment. \r\n> Assuming you can compute the hash in a streaming fashion, which should be the case, I'd implement a new data guard that wraps another data guard that somehow streams the data through the hash and into the other guard.\r\n...\r\n> This is interesting. I think the current API forces you to read the data into memory. \r\n> We should fix that. \r\n> \r\nSo, this might not actually be possible. Even if you read everything into memory, you wouldn't be able to call the other FromData since the original Data is gone.\r\n\r\ncarreau \r\n\r\n> I guess a peek_all() that return the full buffer would be sufficient (inefficient for sure... but sufficient).\r\n\r\nSergio \r\n\r\n> We need some kind of way to provide a chain of readers to Data itself. \r\n> No, we won't add that.\r\n> It makes DOS trivial. \r\n> Far too error prone.\r\n> We need something like a .map method on Data that returns another Data but also makes mapping an error.\r\n> Can you open an issue on GitHub with your usecase? I'm off to bed now but will think of a design that works for tomorrow.\r\n> But also makes mapping fallible*\r\n\r\n</details>\r\n\r\nApologies for any vocabulary that might be off I'm still relatively new to rust. Feel free to edit to make clearer.\r\n\r\nThanks.","closed_by":{"login":"SergioBenitez","id":1480321,"node_id":"MDQ6VXNlcjE0ODAzMjE=","avatar_url":"https://avatars.githubusercontent.com/u/1480321?v=4","gravatar_id":"","url":"https://api.github.com/users/SergioBenitez","html_url":"https://github.com/SergioBenitez","followers_url":"https://api.github.com/users/SergioBenitez/followers","following_url":"https://api.github.com/users/SergioBenitez/following{/other_user}","gists_url":"https://api.github.com/users/SergioBenitez/gists{/gist_id}","starred_url":"https://api.github.com/users/SergioBenitez/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SergioBenitez/subscriptions","organizations_url":"https://api.github.com/users/SergioBenitez/orgs","repos_url":"https://api.github.com/users/SergioBenitez/repos","events_url":"https://api.github.com/users/SergioBenitez/events{/privacy}","received_events_url":"https://api.github.com/users/SergioBenitez/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rwf2/Rocket/issues/775/reactions","total_count":18,"+1":14,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":4,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rwf2/Rocket/issues/775/timeline","performed_via_github_app":null,"state_reason":"completed"}