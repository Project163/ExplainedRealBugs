diff --git a/codegen/src/decorators/derive_form.rs b/codegen/src/decorators/derive_form.rs
index 30278b9a..13bc34f7 100644
--- a/codegen/src/decorators/derive_form.rs
+++ b/codegen/src/decorators/derive_form.rs
@@ -79,13 +79,18 @@ pub fn from_form_derive(ecx: &mut ExtCtxt, span: Span, meta_item: &MetaItem,
         generics: trait_generics,
         methods: vec![
             MethodDef {
-                name: "from_form_string",
+                name: "from_form_items",
                 generics: ty::LifetimeBounds::empty(),
                 explicit_self: None,
                 args: vec![
                     ty::Ptr(
-                        Box::new(ty::Literal(ty::Path::new_local("str"))),
-                        ty::Borrowed(lifetime_var, Mutability::Immutable)
+                        Box::new(ty::Literal(ty::Path {
+                            path: vec!["rocket", "request", "FormItems"],
+                            lifetime: lifetime_var,
+                            params: vec![],
+                            global: true
+                        })),
+                        ty::Borrowed(None, Mutability::Mutable)
                     )
                 ],
                 ret_ty: ty::Ty::Literal(
@@ -188,7 +193,7 @@ fn from_form_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substruct
     // The actual match statement. Iterate through all of the fields in the form
     // and use the $arms generated above.
     stmts.push(quote_stmt!(cx,
-        for (k, v) in ::rocket::request::FormItems($arg) {
+        for (k, v) in $arg {
             match k {
                 $arms
                 field if field == "_method" => {
diff --git a/codegen/src/decorators/route.rs b/codegen/src/decorators/route.rs
index 29b438f5..aa837121 100644
--- a/codegen/src/decorators/route.rs
+++ b/codegen/src/decorators/route.rs
@@ -56,8 +56,11 @@ impl RouteGenerateExt for RouteParams {
         ecx.span_err(fn_span, "...but isn't in the function signature.");
     }
 
-    fn gen_form(&self, ecx: &ExtCtxt, param: Option<&Spanned<Ident>>,
-                form_string: P<Expr>) -> Option<Stmt> {
+    fn gen_form(&self,
+                ecx: &ExtCtxt,
+                param: Option<&Spanned<Ident>>,
+                form_string: P<Expr>)
+                -> Option<Stmt> {
         let arg = param.and_then(|p| self.annotated_fn.find_input(&p.node.name));
         if param.is_none() {
             return None;
@@ -70,11 +73,20 @@ impl RouteGenerateExt for RouteParams {
         let name = arg.ident().expect("form param identifier").prepend(PARAM_PREFIX);
         let ty = strip_ty_lifetimes(arg.ty.clone());
         Some(quote_stmt!(ecx,
-            let $name: $ty =
-                match ::rocket::request::FromForm::from_form_string($form_string) {
+            let $name: $ty = {
+                let mut items = ::rocket::request::FormItems::from($form_string);
+                let obj = match ::rocket::request::FromForm::from_form_items(items.by_ref()) {
                     Ok(v) => v,
                     Err(_) => return ::rocket::Outcome::Forward(_data)
                 };
+
+                if !items.exhausted() {
+                    println!("    => The query string {:?} is malformed.", $form_string);
+                    return ::rocket::Outcome::Failure(::rocket::http::Status::BadRequest);
+                }
+
+                obj
+             }
         ).expect("form statement"))
     }
 
diff --git a/codegen/tests/run-pass/derive_form.rs b/codegen/tests/run-pass/derive_form.rs
index aa79156e..993be36d 100644
--- a/codegen/tests/run-pass/derive_form.rs
+++ b/codegen/tests/run-pass/derive_form.rs
@@ -3,7 +3,7 @@
 
 extern crate rocket;
 
-use rocket::request::{FromForm, FromFormValue};
+use rocket::request::{FromForm, FromFormValue, FormItems};
 
 #[derive(Debug, PartialEq, FromForm)]
 struct TodoTask {
@@ -64,21 +64,31 @@ struct UnpresentCheckboxTwo<'r> {
     something: &'r str
 }
 
+fn parse<'f, T: FromForm<'f>>(string: &'f str) -> Option<T> {
+    let mut items = FormItems::from(string);
+    let result = T::from_form_items(items.by_ref());
+    if !items.exhausted() {
+        panic!("Invalid form input.");
+    }
+
+    result.ok()
+}
+
 fn main() {
     // Same number of arguments: simple case.
-    let task = TodoTask::from_form_string("description=Hello&completed=on");
-    assert_eq!(task, Ok(TodoTask {
+    let task: Option<TodoTask> = parse("description=Hello&completed=on");
+    assert_eq!(task, Some(TodoTask {
         description: "Hello".to_string(),
         completed: true
     }));
 
     // Argument in string but not in form.
-    let task = TodoTask::from_form_string("other=a&description=Hello&completed=on");
-    assert!(task.is_err());
+    let task: Option<TodoTask> = parse("other=a&description=Hello&completed=on");
+    assert!(task.is_none());
 
     // Ensure _method isn't required.
-    let task = TodoTask::from_form_string("_method=patch&description=Hello&completed=off");
-    assert_eq!(task, Ok(TodoTask {
+    let task: Option<TodoTask> = parse("_method=patch&description=Hello&completed=off");
+    assert_eq!(task, Some(TodoTask {
         description: "Hello".to_string(),
         completed: false
     }));
@@ -88,8 +98,8 @@ fn main() {
         "checkbox=off", "textarea=", "select=a", "radio=c",
     ].join("&");
 
-    let input = FormInput::from_form_string(&form_string);
-    assert_eq!(input, Ok(FormInput {
+    let input: Option<FormInput> = parse(&form_string);
+    assert_eq!(input, Some(FormInput {
         checkbox: false,
         number: 10,
         radio: FormOption::C,
@@ -99,34 +109,34 @@ fn main() {
     }));
 
     // Argument not in string with default in form.
-    let default = DefaultInput::from_form_string("");
-    assert_eq!(default, Ok(DefaultInput {
+    let default: Option<DefaultInput> = parse("");
+    assert_eq!(default, Some(DefaultInput {
         arg: None
     }));
 
     // Ensure _method can be captured if desired.
-    let manual = ManualMethod::from_form_string("_method=put&done=true");
-    assert_eq!(manual, Ok(ManualMethod {
+    let manual: Option<ManualMethod> = parse("_method=put&done=true");
+    assert_eq!(manual, Some(ManualMethod {
         _method: Some("put"),
         done: true
     }));
 
     // And ignored when not present.
-    let manual = ManualMethod::from_form_string("done=true");
-    assert_eq!(manual, Ok(ManualMethod {
+    let manual: Option<ManualMethod> = parse("done=true");
+    assert_eq!(manual, Some(ManualMethod {
         _method: None,
         done: true
     }));
 
     // Check that a `bool` value that isn't in the form is marked as `false`.
-    let manual = UnpresentCheckbox::from_form_string("");
-    assert_eq!(manual, Ok(UnpresentCheckbox {
+    let manual: Option<UnpresentCheckbox> = parse("");
+    assert_eq!(manual, Some(UnpresentCheckbox {
         checkbox: false
     }));
 
     // Check that a `bool` value that isn't in the form is marked as `false`.
-    let manual = UnpresentCheckboxTwo::from_form_string("something=hello");
-    assert_eq!(manual, Ok(UnpresentCheckboxTwo {
+    let manual: Option<UnpresentCheckboxTwo> = parse("something=hello");
+    assert_eq!(manual, Some(UnpresentCheckboxTwo {
         checkbox: false,
         something: "hello"
     }));
diff --git a/codegen/tests/run-pass/empty_form.rs b/codegen/tests/run-pass/empty_form.rs
index 5a42c049..3594e9eb 100644
--- a/codegen/tests/run-pass/empty_form.rs
+++ b/codegen/tests/run-pass/empty_form.rs
@@ -3,13 +3,13 @@
 
 extern crate rocket;
 
-use rocket::request::FromForm;
+use rocket::request::{FromForm, FormItems};
 
 #[derive(PartialEq, Debug, FromForm)]
 struct Form {  }
 
 fn main() {
     // Same number of arguments: simple case.
-    let task = Form::from_form_string("");
+    let task = Form::from_form_items(&mut FormItems::from(""));
     assert_eq!(task, Ok(Form { }));
 }
diff --git a/lib/Cargo.toml b/lib/Cargo.toml
index 5f1fc42e..67128820 100644
--- a/lib/Cargo.toml
+++ b/lib/Cargo.toml
@@ -24,6 +24,7 @@ toml = { version = "^0.2", default-features = false }
 num_cpus = "1"
 state = "^0.2"
 time = "^0.1"
+memchr = "1"
 
 [dependencies.cookie]
 version = "^0.6"
diff --git a/lib/src/lib.rs b/lib/src/lib.rs
index 8d22dd78..5f4003b8 100644
--- a/lib/src/lib.rs
+++ b/lib/src/lib.rs
@@ -99,6 +99,7 @@ extern crate num_cpus;
 extern crate state;
 extern crate cookie;
 extern crate time;
+extern crate memchr;
 
 #[cfg(test)] #[macro_use] extern crate lazy_static;
 
diff --git a/lib/src/request/form/form_items.rs b/lib/src/request/form/form_items.rs
index 11799543..aeb753b2 100644
--- a/lib/src/request/form/form_items.rs
+++ b/lib/src/request/form/form_items.rs
@@ -1,3 +1,5 @@
+use memchr::memchr2;
+
 /// Iterator over the key/value pairs of a given HTTP form string. You'll likely
 /// want to use this if you're implementing [FromForm](trait.FromForm.html)
 /// manually, for whatever reason, by iterating over the items in `form_string`.
@@ -9,7 +11,7 @@
 /// use rocket::request::{FormItems, FromFormValue};
 ///
 /// let form_string = "greeting=Hello%2C+Mark%21&username=jake%2Fother";
-/// for (key, value) in FormItems(form_string) {
+/// for (key, value) in FormItems::from(form_string) {
 ///     let decoded_value = String::from_form_value(value);
 ///     match key {
 ///         "greeting" => assert_eq!(decoded_value, Ok("Hello, Mark!".into())),
@@ -28,7 +30,7 @@
 ///
 /// // prints "greeting = hello" then "username = jake"
 /// let form_string = "greeting=hello&username=jake";
-/// for (key, value) in FormItems(form_string) {
+/// for (key, value) in FormItems::from(form_string) {
 ///     println!("{} = {}", key, value);
 /// }
 /// ```
@@ -39,55 +41,104 @@
 /// use rocket::request::FormItems;
 ///
 /// let form_string = "greeting=hello&username=jake";
-/// let mut items = FormItems(form_string);
+/// let mut items = FormItems::from(form_string);
 /// assert_eq!(items.next(), Some(("greeting", "hello")));
 /// assert_eq!(items.next(), Some(("username", "jake")));
 /// assert_eq!(items.next(), None);
+/// assert!(items.completed());
 /// ```
-pub struct FormItems<'f>(pub &'f str);
+pub struct FormItems<'f> {
+    string: &'f str,
+    next_index: usize
+}
+
+impl<'f> FormItems<'f> {
+    #[inline]
+    pub fn completed(&self) -> bool {
+        self.next_index >= self.string.len()
+    }
+
+    pub fn exhausted(&mut self) -> bool {
+        while let Some(_) = self.next() {  }
+        self.completed()
+    }
+
+    #[inline]
+    #[doc(hidden)]
+    pub fn mark_complete(&mut self) {
+        self.next_index = self.string.len()
+    }
+
+    #[inline]
+    pub fn inner_str(&self) -> &'f str {
+        self.string
+    }
+}
+
+impl<'f> From<&'f str> for FormItems<'f> {
+    fn from(string: &'f str) -> FormItems<'f> {
+        FormItems {
+            string: string,
+            next_index: 0
+        }
+    }
+}
 
 impl<'f> Iterator for FormItems<'f> {
     type Item = (&'f str, &'f str);
 
     fn next(&mut self) -> Option<Self::Item> {
-        let string = self.0;
-        let (key, rest) = match string.find('=') {
-            Some(index) => (&string[..index], &string[(index + 1)..]),
+        let s = &self.string[self.next_index..];
+        let (key, rest) = match memchr2(b'=', b'&', s.as_bytes()) {
+            Some(i) if s.as_bytes()[i] == b'=' => (&s[..i], &s[(i + 1)..]),
+            Some(_) => return None,
             None => return None,
         };
 
-        let (value, remainder) = match rest.find('&') {
-            Some(index) => (&rest[..index], &rest[(index + 1)..]),
-            None => (rest, ""),
+        if key.is_empty() {
+            return None;
+        }
+
+        let (value, consumed) = match rest.find('&') {
+            Some(index) => (&rest[..index], index + 1),
+            None => (rest, rest.len()),
         };
 
-        self.0 = remainder;
+        self.next_index += key.len() + 1 + consumed;
         Some((key, value))
     }
 }
 
+
 #[cfg(test)]
 mod test {
     use super::FormItems;
 
     macro_rules! check_form {
-        ($string:expr, $expected: expr) => ({
-            let results: Vec<(&str, &str)> = FormItems($string).collect();
-            assert_eq!($expected.len(), results.len());
-
-            for i in 0..results.len() {
-                let (expected_key, actual_key) = ($expected[i].0, results[i].0);
-                let (expected_val, actual_val) = ($expected[i].1, results[i].1);
-
-                assert!(expected_key == actual_key,
-                    "key [{}] mismatch: expected {}, got {}",
-                        i, expected_key, actual_key);
-
-                assert!(expected_val == actual_val,
-                    "val [{}] mismatch: expected {}, got {}",
-                        i, expected_val, actual_val);
+        (@opt $string:expr, $expected:expr) => ({
+            let mut items = FormItems::from($string);
+            let results: Vec<_> = items.by_ref().collect();
+            if let Some(expected) = $expected {
+                assert_eq!(expected.len(), results.len());
+
+                for i in 0..results.len() {
+                    let (expected_key, actual_key) = (expected[i].0, results[i].0);
+                    let (expected_val, actual_val) = (expected[i].1, results[i].1);
+
+                    assert!(expected_key == actual_key,
+                            "key [{}] mismatch: expected {}, got {}",
+                            i, expected_key, actual_key);
+
+                    assert!(expected_val == actual_val,
+                            "val [{}] mismatch: expected {}, got {}",
+                            i, expected_val, actual_val);
+                }
+            } else {
+                assert!(!items.exhausted());
             }
-        })
+        });
+        (@bad $string:expr) => (check_form!(@opt $string, None : Option<&[(&str, &str)]>));
+        ($string:expr, $expected:expr) => (check_form!(@opt $string, Some($expected)));
     }
 
     #[test]
@@ -101,12 +152,18 @@ mod test {
         check_form!("user=&password=pass",
                     &[("user", ""), ("password", "pass")]);
 
-        check_form!("=&=", &[("", ""), ("", "")]);
-
         check_form!("a=b", &[("a", "b")]);
 
-        check_form!("a=b&a", &[("a", "b")]);
-
+        check_form!("user=", &[("user", "")]);
+        check_form!("user=&", &[("user", "")]);
         check_form!("a=b&a=", &[("a", "b"), ("a", "")]);
+
+        check_form!(@bad "user=&password");
+        check_form!(@bad "a=b&a");
+        check_form!(@bad "=");
+        check_form!(@bad "&");
+        check_form!(@bad "=&");
+        check_form!(@bad "&=&");
+        check_form!(@bad "=&=");
     }
 }
diff --git a/lib/src/request/form/from_form.rs b/lib/src/request/form/from_form.rs
index 11185b90..2a309a11 100644
--- a/lib/src/request/form/from_form.rs
+++ b/lib/src/request/form/from_form.rs
@@ -1,4 +1,4 @@
-use error::Error;
+use request::FormItems;
 
 /// Trait to create an instance of some type from an HTTP form. The
 /// [Form](struct.Form.html) type requires that its generic parameter implements
@@ -53,14 +53,15 @@ pub trait FromForm<'f>: Sized {
     /// Parses an instance of `Self` from a raw HTTP form string
     /// (`application/x-www-form-urlencoded data`) or returns an `Error` if one
     /// cannot be parsed.
-    fn from_form_string(form_string: &'f str) -> Result<Self, Self::Error>;
+    fn from_form_items(form_items: &mut FormItems<'f>) -> Result<Self, Self::Error>;
 }
 
 /// This implementation should only be used during debugging!
 impl<'f> FromForm<'f> for &'f str {
-    type Error = Error;
-    fn from_form_string(s: &'f str) -> Result<Self, Error> {
-        Ok(s)
+    type Error = ();
+
+    fn from_form_items(items: &mut FormItems<'f>) -> Result<Self, Self::Error> {
+        items.mark_complete();
+        Ok(items.inner_str())
     }
 }
-
diff --git a/lib/src/request/form/mod.rs b/lib/src/request/form/mod.rs
index 66486fb8..a3e35f73 100644
--- a/lib/src/request/form/mod.rs
+++ b/lib/src/request/form/mod.rs
@@ -155,6 +155,22 @@ pub struct Form<'f, T: FromForm<'f> + 'f> {
     _phantom: PhantomData<&'f T>,
 }
 
+enum FormResult<T, E> {
+    Ok(T),
+    Err(String, E),
+    Invalid(String)
+}
+
+#[cfg(test)]
+impl<T, E> FormResult<T, E> {
+    fn unwrap(self) -> T {
+        match self {
+            FormResult::Ok(val) => val,
+            _ => panic!("Unwrapping non-Ok FormResult.")
+        }
+    }
+}
+
 impl<'f, T: FromForm<'f> + 'f> Form<'f, T> {
     /// Immutably borrow the parsed type.
     pub fn get(&'f self) -> &'f T {
@@ -192,18 +208,24 @@ impl<'f, T: FromForm<'f> + 'f> Form<'f, T> {
     // caller via `get()` and contrain everything to that lifetime. This is, in
     // reality a little coarser than necessary, but the user can simply move the
     // call to right after the creation of a Form object to get the same effect.
-    fn new(form_string: String) -> Result<Self, (String, T::Error)> {
+    fn new(form_string: String) -> FormResult<Self, T::Error> {
         let long_lived_string: &'f str = unsafe {
             ::std::mem::transmute(form_string.as_str())
         };
 
-        match T::from_form_string(long_lived_string) {
-            Ok(obj) => Ok(Form {
+        let mut items = FormItems::from(long_lived_string);
+        let result = T::from_form_items(items.by_ref());
+        if !items.exhausted() {
+            return FormResult::Invalid(form_string);
+        }
+
+        match result {
+            Ok(obj) => FormResult::Ok(Form {
                 form_string: form_string,
                 object: obj,
                 _phantom: PhantomData
             }),
-            Err(e) => Err((form_string, e))
+            Err(e) => FormResult::Err(form_string, e)
         }
     }
 }
@@ -240,17 +262,21 @@ impl<'f, T: FromForm<'f>> FromData for Form<'f, T> where T::Error: Debug {
         }
 
         let mut form_string = String::with_capacity(4096);
-        let mut stream = data.open().take(32768);
+        let mut stream = data.open().take(32768); // TODO: Make this configurable?
         if let Err(e) = stream.read_to_string(&mut form_string) {
             error_!("IO Error: {:?}", e);
             Failure((Status::InternalServerError, None))
         } else {
             match Form::new(form_string) {
-                Ok(form) => Success(form),
-                Err((form_string, e)) => {
-                    error_!("Failed to parse value from form: {:?}", e);
+                FormResult::Ok(form) => Success(form),
+                FormResult::Invalid(form_string) => {
+                    error_!("The request's form string was malformed.");
                     Failure((Status::BadRequest, Some(form_string)))
                 }
+                FormResult::Err(form_string, e) => {
+                    error_!("Failed to parse value from form: {:?}", e);
+                    Failure((Status::UnprocessableEntity, Some(form_string)))
+                }
             }
         }
     }
@@ -259,7 +285,7 @@ impl<'f, T: FromForm<'f>> FromData for Form<'f, T> where T::Error: Debug {
 #[cfg(test)]
 mod test {
     use super::Form;
-    use ::request::FromForm;
+    use ::request::{FromForm, FormItems};
 
     struct Simple<'s> {
         value: &'s str
@@ -270,18 +296,18 @@ mod test {
     }
 
     impl<'s> FromForm<'s> for Simple<'s> {
-        type Error = &'s str;
+        type Error = ();
 
-        fn from_form_string(fs: &'s str) -> Result<Simple<'s>, &'s str> {
-            Ok(Simple { value: fs })
+        fn from_form_items(items: &mut FormItems<'s>) -> Result<Simple<'s>, ()> {
+            Ok(Simple { value: items.inner_str() })
         }
     }
 
     impl<'s> FromForm<'s> for Other {
-        type Error = &'s str;
+        type Error = ();
 
-        fn from_form_string(fs: &'s str) -> Result<Other, &'s str> {
-            Ok(Other { value: fs.to_string() })
+        fn from_form_items(items: &mut FormItems<'s>) -> Result<Other, ()> {
+            Ok(Other { value: items.inner_str().to_string() })
         }
     }
 
diff --git a/lib/src/rocket.rs b/lib/src/rocket.rs
index 70a44d17..52c16c30 100644
--- a/lib/src/rocket.rs
+++ b/lib/src/rocket.rs
@@ -167,7 +167,7 @@ impl Rocket {
                 from_utf8_unchecked(&data.peek()[..min(data_len, max_len)])
             };
 
-            let mut form_items = FormItems(form);
+            let mut form_items = FormItems::from(form);
             if let Some(("_method", value)) = form_items.next() {
                 if let Ok(method) = value.parse() {
                     req.set_method(method);
