diff --git a/core/codegen/src/attribute/entry/launch.rs b/core/codegen/src/attribute/entry/launch.rs
index 90f5d612..12289219 100644
--- a/core/codegen/src/attribute/entry/launch.rs
+++ b/core/codegen/src/attribute/entry/launch.rs
@@ -1,9 +1,10 @@
-use super::EntryAttr;
-
 use devise::{Spanned, Result};
 use devise::ext::SpanDiagnosticExt;
 use proc_macro2::{TokenStream, Span};
 
+use super::EntryAttr;
+use crate::exports::mixed;
+
 /// `#[rocket::launch]`: generates a `main` function that calls the attributed
 /// function to generate a `Rocket` instance. Then calls `.launch()` on the
 /// returned instance inside of an `rocket::async_main`.
@@ -78,7 +79,7 @@ impl EntryAttr for Launch {
         };
 
         let block = &f.block;
-        let rocket = quote_spanned!(ty.span() => {
+        let rocket = quote_spanned!(mixed(ty.span()) => {
             let ___rocket: #ty = #block;
             let ___rocket: ::rocket::Rocket<::rocket::Build> = ___rocket;
             ___rocket
diff --git a/core/codegen/src/derive/from_form.rs b/core/codegen/src/derive/from_form.rs
index 19c4cc02..bf55d3bb 100644
--- a/core/codegen/src/derive/from_form.rs
+++ b/core/codegen/src/derive/from_form.rs
@@ -120,12 +120,13 @@ pub fn derive_from_form(input: proc_macro::TokenStream) -> TokenStream {
                 let (ctxt_ty, gen) = context_type(input)?;
                 let (impl_gen, _, where_clause)  = gen.split_for_impl();
                 let output = mapper::input_default(mapper, input)?;
-                Ok(quote_spanned! { input.span() =>
+                Ok(quote_spanned! { mixed(input.span()) =>
                     /// Rocket generated FormForm context.
                     #[doc(hidden)]
                     #[allow(unknown_lints)]
                     #[allow(renamed_and_removed_lints)]
-                    #[allow(private_in_public, private_bounds)]
+                    #[allow(private_in_public)]
+                    #[allow(private_bounds)]
                     #vis struct #ctxt_ty #impl_gen #where_clause {
                         __opts: #_form::Options,
                         __errors: #_form::Errors<'r>,
@@ -150,6 +151,7 @@ pub fn derive_from_form(input: proc_macro::TokenStream) -> TokenStream {
             #[allow(unused_imports)]
             use #_http::uncased::AsUncased;
         })
+        .outer_mapper(quote!(#[allow(clippy::all, clippy::pedantic, clippy::nursery)]))
         .outer_mapper(quote!(#[allow(renamed_and_removed_lints)]))
         .outer_mapper(quote!(#[allow(private_in_public)]))
         .outer_mapper(quote!(#[rocket::async_trait]))
@@ -205,8 +207,8 @@ pub fn derive_from_form(input: proc_macro::TokenStream) -> TokenStream {
             // Without the `let _fut`, we get a wild lifetime error. It don't
             // make no sense, Rust async/await: it don't make no sense.
             .try_fields_map(|_, f| fields_map(f, |ty, ctxt| quote_spanned!(ty.span() => {
-                let _fut = <#ty as #_form::FromForm<'r>>::push_data(#ctxt, __f.shift());
-                _fut.await;
+                let __fut = <#ty as #_form::FromForm<'r>>::push_data(#ctxt, __f.shift());
+                __fut.await;
             })))
         )
         .inner_mapper(MapperBuild::new()
@@ -261,7 +263,6 @@ pub fn derive_from_form(input: proc_macro::TokenStream) -> TokenStream {
                         <#ty as #_form::FromForm<'r>>::default(__opts)
                     }));
 
-                let _err = _Err;
                 Ok(quote_spanned! { ty.span() => {
                     let __opts = __c.__opts;
                     let __name = #name_buf_opt;
@@ -271,8 +272,8 @@ pub fn derive_from_form(input: proc_macro::TokenStream) -> TokenStream {
                             <#ty as #_form::FromForm<'r>>::finalize
                         )
                         .map_err(|__e| match __name {
-                            Some(__name) => __e.with_name(__name),
-                            None => __e,
+                            #_Some(__name) => __e.with_name(__name),
+                            #_None => __e,
                         })
                         .map_err(|__e| __e.is_empty()
                             .then(|| #_form::ErrorKind::Unknown.into())
