diff --git a/contrib/db_pools/lib/Cargo.toml b/contrib/db_pools/lib/Cargo.toml
index 836cc89e..6c20349d 100644
--- a/contrib/db_pools/lib/Cargo.toml
+++ b/contrib/db_pools/lib/Cargo.toml
@@ -59,7 +59,7 @@ features = ["tokio-runtime"]
 optional = true
 
 [dependencies.sqlx]
-version = "0.5"
+version = "0.6"
 default-features = false
 features = ["runtime-tokio-rustls"]
 optional = true
diff --git a/contrib/db_pools/lib/src/pool.rs b/contrib/db_pools/lib/src/pool.rs
index 60270fe5..9f313eaa 100644
--- a/contrib/db_pools/lib/src/pool.rs
+++ b/contrib/db_pools/lib/src/pool.rs
@@ -246,7 +246,7 @@ mod sqlx {
 
             sqlx::pool::PoolOptions::new()
                 .max_connections(config.max_connections as u32)
-                .connect_timeout(Duration::from_secs(config.connect_timeout))
+                .acquire_timeout(Duration::from_secs(config.connect_timeout))
                 .idle_timeout(config.idle_timeout.map(Duration::from_secs))
                 .min_connections(config.min_connections.unwrap_or_default())
                 .connect_with(opts)
diff --git a/contrib/sync_db_pools/lib/Cargo.toml b/contrib/sync_db_pools/lib/Cargo.toml
index adc9d11d..5c9238f9 100644
--- a/contrib/sync_db_pools/lib/Cargo.toml
+++ b/contrib/sync_db_pools/lib/Cargo.toml
@@ -23,13 +23,13 @@ r2d2 = "0.8"
 tokio = { version = "1.6.1", features = ["rt", "rt-multi-thread"] }
 serde = { version = "1.0", features = ["derive"] }
 
-diesel = { version = "1.0", default-features = false, optional = true }
+diesel = { version = "2.0.0", default-features = false, optional = true }
 
 postgres = { version = "0.19", optional = true }
 r2d2_postgres = { version = "0.18", optional = true }
 
-rusqlite = { version = "0.25", optional = true }
-r2d2_sqlite = { version = "0.18", optional = true }
+rusqlite = { version = "0.27.0", optional = true }
+r2d2_sqlite = { version = "0.20.0", optional = true }
 
 memcache = { version = "0.15", optional = true }
 r2d2-memcache = { version = "0.6", optional = true }
diff --git a/examples/databases/Cargo.toml b/examples/databases/Cargo.toml
index 67810761..927f64d3 100644
--- a/examples/databases/Cargo.toml
+++ b/examples/databases/Cargo.toml
@@ -7,11 +7,11 @@ publish = false
 
 [dependencies]
 rocket = { path = "../../core/lib", features = ["json"] }
-diesel = { version = "1.3", features = ["sqlite", "r2d2"] }
-diesel_migrations = "1.3"
+diesel = { version = "2.0.0", features = ["sqlite", "r2d2"] }
+diesel_migrations = "2.0.0"
 
 [dependencies.sqlx]
-version = "0.5.1"
+version = "0.6.0"
 default-features = false
 features = ["macros", "offline", "migrate"]
 
diff --git a/examples/databases/src/diesel_sqlite.rs b/examples/databases/src/diesel_sqlite.rs
index bcf23ae8..c64d8edf 100644
--- a/examples/databases/src/diesel_sqlite.rs
+++ b/examples/databases/src/diesel_sqlite.rs
@@ -14,7 +14,7 @@ type Result<T, E = Debug<diesel::result::Error>> = std::result::Result<T, E>;
 
 #[derive(Debug, Clone, Deserialize, Serialize, Queryable, Insertable)]
 #[serde(crate = "rocket::serde")]
-#[table_name="posts"]
+#[diesel(table_name = posts)]
 struct Post {
     #[serde(skip_deserializing)]
     id: Option<i32>,
@@ -84,13 +84,14 @@ async fn destroy(db: Db) -> Result<()> {
 }
 
 async fn run_migrations(rocket: Rocket<Build>) -> Rocket<Build> {
-    // This macro from `diesel_migrations` defines an `embedded_migrations`
-    // module containing a function named `run` that runs the migrations in the
-    // specified directory, initializing the database.
-    embed_migrations!("db/diesel/migrations");
+    use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
 
-    let conn = Db::get_one(&rocket).await.expect("database connection");
-    conn.run(|c| embedded_migrations::run(c)).await.expect("diesel migrations");
+    const MIGRATIONS: EmbeddedMigrations = embed_migrations!("db/diesel/migrations");
+
+    Db::get_one(&rocket).await
+        .expect("database connection")
+        .run(|conn| { conn.run_pending_migrations(MIGRATIONS).expect("diesel migrations"); })
+        .await;
 
     rocket
 }
diff --git a/examples/databases/src/main.rs b/examples/databases/src/main.rs
index 32ff22e2..8748f22d 100644
--- a/examples/databases/src/main.rs
+++ b/examples/databases/src/main.rs
@@ -1,7 +1,5 @@
 #[macro_use] extern crate rocket;
 #[macro_use] extern crate rocket_sync_db_pools;
-#[macro_use] extern crate diesel_migrations;
-#[macro_use] extern crate diesel;
 
 #[cfg(test)] mod tests;
 
diff --git a/examples/todo/Cargo.toml b/examples/todo/Cargo.toml
index 854570a9..3aac1874 100644
--- a/examples/todo/Cargo.toml
+++ b/examples/todo/Cargo.toml
@@ -7,8 +7,8 @@ publish = false
 
 [dependencies]
 rocket = { path = "../../core/lib" }
-diesel = { version = "1.3", features = ["sqlite", "r2d2"] }
-diesel_migrations = "1.3"
+diesel = { version = "2.0.0", features = ["sqlite", "r2d2"] }
+diesel_migrations = "2.0.0"
 
 [dev-dependencies]
 parking_lot = "0.12"
diff --git a/examples/todo/src/main.rs b/examples/todo/src/main.rs
index fb36aacc..96763545 100644
--- a/examples/todo/src/main.rs
+++ b/examples/todo/src/main.rs
@@ -1,7 +1,6 @@
 #[macro_use] extern crate rocket;
-#[macro_use] extern crate diesel;
-#[macro_use] extern crate diesel_migrations;
 #[macro_use] extern crate rocket_sync_db_pools;
+#[macro_use] extern crate diesel;
 
 #[cfg(test)]
 mod tests;
@@ -93,13 +92,14 @@ async fn index(flash: Option<FlashMessage<'_>>, conn: DbConn) -> Template {
 }
 
 async fn run_migrations(rocket: Rocket<Build>) -> Rocket<Build> {
-    // This macro from `diesel_migrations` defines an `embedded_migrations`
-    // module containing a function named `run`. This allows the example to be
-    // run and tested without any outside setup of the database.
-    embed_migrations!();
+    use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
+
+    const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");
 
-    let conn = DbConn::get_one(&rocket).await.expect("database connection");
-    conn.run(|c| embedded_migrations::run(c)).await.expect("can run migrations");
+    DbConn::get_one(&rocket).await
+        .expect("database connection")
+        .run(|conn| { conn.run_pending_migrations(MIGRATIONS).expect("diesel migrations"); })
+        .await;
 
     rocket
 }
diff --git a/examples/todo/src/task.rs b/examples/todo/src/task.rs
index ce4067c1..eb93ffe7 100644
--- a/examples/todo/src/task.rs
+++ b/examples/todo/src/task.rs
@@ -12,14 +12,14 @@ mod schema {
 }
 
 use self::schema::tasks;
-use self::schema::tasks::dsl::{tasks as all_tasks, completed as task_completed};
 
 use crate::DbConn;
 
 #[derive(Serialize, Queryable, Insertable, Debug, Clone)]
 #[serde(crate = "rocket::serde")]
-#[table_name="tasks"]
+#[diesel(table_name = tasks)]
 pub struct Task {
+    #[serde(skip_deserializing)]
     pub id: Option<i32>,
     pub description: String,
     pub completed: bool
@@ -33,7 +33,7 @@ pub struct Todo {
 impl Task {
     pub async fn all(conn: &DbConn) -> QueryResult<Vec<Task>> {
         conn.run(|c| {
-            all_tasks.order(tasks::id.desc()).load::<Task>(c)
+            tasks::table.order(tasks::id.desc()).load::<Task>(c)
         }).await
     }
 
@@ -48,21 +48,24 @@ impl Task {
     /// Returns the number of affected rows: 1.
     pub async fn toggle_with_id(id: i32, conn: &DbConn) -> QueryResult<usize> {
         conn.run(move |c| {
-            let task = all_tasks.find(id).get_result::<Task>(c)?;
+            let task = tasks::table.filter(tasks::id.eq(id)).get_result::<Task>(c)?;
             let new_status = !task.completed;
-            let updated_task = diesel::update(all_tasks.find(id));
-            updated_task.set(task_completed.eq(new_status)).execute(c)
+            let updated_task = diesel::update(tasks::table.filter(tasks::id.eq(id)));
+            updated_task.set(tasks::completed.eq(new_status)).execute(c)
         }).await
     }
 
     /// Returns the number of affected rows: 1.
     pub async fn delete_with_id(id: i32, conn: &DbConn) -> QueryResult<usize> {
-        conn.run(move |c| diesel::delete(all_tasks.find(id)).execute(c)).await
+        conn.run(move |c| diesel::delete(tasks::table)
+            .filter(tasks::id.eq(id))
+            .execute(c))
+            .await
     }
 
     /// Returns the number of affected rows.
     #[cfg(test)]
     pub async fn delete_all(conn: &DbConn) -> QueryResult<usize> {
-        conn.run(|c| diesel::delete(all_tasks).execute(c)).await
+        conn.run(|c| diesel::delete(tasks::table).execute(c)).await
     }
 }
