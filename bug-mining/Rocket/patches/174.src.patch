diff --git a/core/lib/src/request/request.rs b/core/lib/src/request/request.rs
index f0ce039c..24ce226f 100644
--- a/core/lib/src/request/request.rs
+++ b/core/lib/src/request/request.rs
@@ -831,34 +831,26 @@ impl<'r> Request<'r> {
     /// Convert from Hyper types into a Rocket Request.
     pub(crate) fn from_hyp(
         rocket: &'r Rocket<Orbit>,
-        h_method: hyper::Method,
-        h_headers: hyper::HeaderMap<hyper::HeaderValue>,
-        h_uri: &'r hyper::Uri,
-        h_addr: SocketAddr,
+        hyper: &'r hyper::RequestParts,
+        addr: SocketAddr
     ) -> Result<Request<'r>, Error<'r>> {
-        // Get a copy of the URI (only supports path-and-query) for later use.
-        let uri = match (h_uri.scheme(), h_uri.authority(), h_uri.path_and_query()) {
-            (None, None, Some(path_query)) => path_query,
-            _ => return Err(Error::InvalidUri(h_uri)),
-        };
-
         // Ensure that the method is known. TODO: Allow made-up methods?
-        let method = match Method::from_hyp(&h_method) {
-            Some(method) => method,
-            None => return Err(Error::BadMethod(h_method))
-        };
+        let method = Method::from_hyp(&hyper.method)
+            .ok_or_else(|| Error::BadMethod(&hyper.method))?;
 
         // In debug, make sure we agree with Hyper. Otherwise, cross our fingers
         // and trust that it only gives us valid URIs like it's supposed to.
+        // TODO: Keep around not just the path/query, but the rest, if there?
+        let uri = hyper.uri.path_and_query().ok_or_else(|| Error::InvalidUri(&hyper.uri))?;
         debug_assert!(Origin::parse(uri.as_str()).is_ok());
         let uri = Origin::new(uri.path(), uri.query().map(Cow::Borrowed));
 
         // Construct the request object.
         let mut request = Request::new(rocket, method, uri);
-        request.set_remote(h_addr);
+        request.set_remote(addr);
 
         // Set the request cookies, if they exist.
-        for header in h_headers.get_all("Cookie") {
+        for header in hyper.headers.get_all("Cookie") {
             let raw_str = match std::str::from_utf8(header.as_bytes()) {
                 Ok(string) => string,
                 Err(_) => continue
@@ -871,13 +863,19 @@ impl<'r> Request<'r> {
             }
         }
 
-        // Set the rest of the headers.
-        // This is rather unfortunate and slow.
-        for (name, value) in h_headers.iter() {
-            // FIXME: This is not totally correct since values needn't be UTF8.
-            let value_str = String::from_utf8_lossy(value.as_bytes()).into_owned();
-            let header = Header::new(name.to_string(), value_str);
-            request.add_header(header);
+        // Set the rest of the headers. This is rather unfortunate and slow.
+        for (name, value) in hyper.headers.iter() {
+            // FIXME: This is rather unfortunate. Header values needn't be UTF8.
+            let value = match std::str::from_utf8(value.as_bytes()) {
+                Ok(value) => value,
+                Err(_) => {
+                    warn!("Header '{}' contains invalid UTF-8", name);
+                    warn_!("Rocket only supports UTF-8 header values. Dropping header.");
+                    continue;
+                }
+            };
+
+            request.add_header(Header::new(name.as_str(), value));
         }
 
         Ok(request)
@@ -888,7 +886,7 @@ impl<'r> Request<'r> {
 pub(crate) enum Error<'r> {
     InvalidUri(&'r hyper::Uri),
     UriParse(crate::http::uri::Error<'r>),
-    BadMethod(hyper::Method),
+    BadMethod(&'r hyper::Method),
 }
 
 impl fmt::Display for Error<'_> {
diff --git a/core/lib/src/request/tests.rs b/core/lib/src/request/tests.rs
index 41627a8c..2bab068e 100644
--- a/core/lib/src/request/tests.rs
+++ b/core/lib/src/request/tests.rs
@@ -1,4 +1,4 @@
-use std::net::{IpAddr, Ipv4Addr, SocketAddr};
+use std::net::{Ipv4Addr, SocketAddrV4};
 use std::collections::HashMap;
 
 use crate::Request;
@@ -7,23 +7,21 @@ use crate::http::hyper;
 
 macro_rules! assert_headers {
     ($($key:expr => [$($value:expr),+]),+) => ({
-        // Set up the parameters to the hyper request object.
-        let h_method = hyper::Method::GET;
-        let h_uri = "/test".parse().unwrap();
-        let h_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8000);
-        let mut h_headers = hyper::HeaderMap::new();
-
-        // Add all of the passed in headers to the request.
-        $($(h_headers.append($key, hyper::HeaderValue::from_str($value).unwrap());)+)+
+        // Create a new Hyper request. Add all of the passed in headers.
+        let mut req = hyper::Request::get("/test").body(()).unwrap();
+        $($(req.headers_mut().append($key, hyper::HeaderValue::from_str($value).unwrap());)+)+
 
         // Build up what we expect the headers to actually be.
         let mut expected = HashMap::new();
         $(expected.entry($key).or_insert(vec![]).append(&mut vec![$($value),+]);)+
 
-        // Dispatch the request and check that the headers are what we expect.
+        // Create a valid `Rocket` and convert the hyper req to a Rocket one.
         let client = Client::debug_with(vec![]).unwrap();
-        let r = client.rocket();
-        let req = Request::from_hyp(r, h_method, h_headers, &h_uri, h_addr).unwrap();
+        let addr = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 8000).into();
+        let hyper = req.into_parts().0;
+        let req = Request::from_hyp(client.rocket(), &hyper, addr).unwrap();
+
+        // Dispatch the request and check that the headers match.
         let actual_headers = req.headers();
         for (key, values) in expected.iter() {
             let actual: Vec<_> = actual_headers.get(key).collect();
diff --git a/core/lib/src/server.rs b/core/lib/src/server.rs
index ebed03ac..a3b7446a 100644
--- a/core/lib/src/server.rs
+++ b/core/lib/src/server.rs
@@ -63,7 +63,7 @@ async fn handle<Fut, T, F>(name: Option<&str>, run: F) -> Option<T>
 // `HyperResponse` type, this function does the actual response processing.
 async fn hyper_service_fn(
     rocket: Arc<Rocket<Orbit>>,
-    h_addr: std::net::SocketAddr,
+    addr: std::net::SocketAddr,
     hyp_req: hyper::Request<hyper::Body>,
 ) -> Result<hyper::Response<hyper::Body>, io::Error> {
     // This future must return a hyper::Response, but the response body might
@@ -72,15 +72,9 @@ async fn hyper_service_fn(
     let (tx, rx) = oneshot::channel();
 
     tokio::spawn(async move {
-        // Get all of the information from Hyper.
+        // Convert a Hyper request into a Rocket request.
         let (h_parts, h_body) = hyp_req.into_parts();
-
-        // Convert the Hyper request into a Rocket request.
-        let req_res = Request::from_hyp(
-            &rocket, h_parts.method, h_parts.headers, &h_parts.uri, h_addr
-        );
-
-        let mut req = match req_res {
+        let mut req = match Request::from_hyp(&rocket, &h_parts, addr) {
             Ok(req) => req,
             Err(e) => {
                 error!("Bad incoming request: {}", e);
