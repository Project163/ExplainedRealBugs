diff --git a/core/codegen/src/bang/uri.rs b/core/codegen/src/bang/uri.rs
index e6bce960..05c7bb9c 100644
--- a/core/codegen/src/bang/uri.rs
+++ b/core/codegen/src/bang/uri.rs
@@ -209,7 +209,7 @@ fn build_origin(internal: &InternalUriParams) -> Origin<'static> {
 
     let path = format!("{}/{}", mount_point, internal.route_uri.path());
     let query = internal.route_uri.query();
-    Origin::new(path, query).to_normalized().into_owned()
+    Origin::new(path, query).into_normalized().into_owned()
 }
 
 pub fn _uri_internal_macro(input: TokenStream) -> Result<TokenStream> {
diff --git a/core/codegen/src/bang/uri_parsing.rs b/core/codegen/src/bang/uri_parsing.rs
index 63ba28ad..62b551e9 100644
--- a/core/codegen/src/bang/uri_parsing.rs
+++ b/core/codegen/src/bang/uri_parsing.rs
@@ -192,7 +192,7 @@ impl Parse for InternalUriParams {
         // Validation should always succeed since this macro can only be called
         // if the route attribute succeeded, implying a valid route URI.
         let route_uri = Origin::parse_route(&route_uri_str.value())
-            .map(|o| o.to_normalized().into_owned())
+            .map(|o| o.into_normalized().into_owned())
             .map_err(|_| input.error("internal error: invalid route URI"))?;
 
         let content;
diff --git a/core/codegen/src/http_codegen.rs b/core/codegen/src/http_codegen.rs
index f65c8ca7..889c63ae 100644
--- a/core/codegen/src/http_codegen.rs
+++ b/core/codegen/src/http_codegen.rs
@@ -181,7 +181,7 @@ impl FromMeta for Origin {
             })?;
 
         if !uri.is_normalized() {
-            let normalized = uri.to_normalized();
+            let normalized = uri.clone().into_normalized();
             return Err(string.span().error("paths cannot contain empty segments")
                 .note(format!("expected '{}', found '{}'", normalized, uri)));
         }
diff --git a/core/http/src/uri/origin.rs b/core/http/src/uri/origin.rs
index f63d2d2f..4f54a275 100644
--- a/core/http/src/uri/origin.rs
+++ b/core/http/src/uri/origin.rs
@@ -63,8 +63,8 @@ use state::Storage;
 /// # }
 /// ```
 ///
-/// The [`Origin::to_normalized()`](crate::uri::Origin::to_normalized()) method can be
-/// used to normalize any `Origin`:
+/// The [`Origin::into_normalized()`](crate::uri::Origin::into_normalized())
+/// method can be used to normalize any `Origin`:
 ///
 /// ```rust
 /// # extern crate rocket;
@@ -80,7 +80,7 @@ use state::Storage;
 /// # for i in 0..(invalid.len() / 2) {
 /// #     let abnormal = Origin::parse(invalid[i]).unwrap();
 /// #     let expected = Origin::parse(invalid[i + (invalid.len() / 2)]).unwrap();
-/// #     assert_eq!(abnormal.to_normalized(), expected);
+/// #     assert_eq!(abnormal.into_normalized(), expected);
 /// # }
 /// ```
 #[derive(Clone, Debug)]
@@ -170,8 +170,8 @@ impl<'a> Origin<'a> {
     }
 
     // Parses an `Origin` that may contain `<` or `>` characters which are
-    // invalid according to the RFC but used by Rocket's routing URIs Don't use
-    // this outside of Rocket!
+    // invalid according to the RFC but used by Rocket's routing URIs.
+    // Don't use this outside of Rocket!
     #[doc(hidden)]
     pub fn parse_route(string: &'a str) -> Result<Origin<'a>, Error<'a>> {
         crate::parse::uri::route_origin_from_str(string)
@@ -179,8 +179,9 @@ impl<'a> Origin<'a> {
 
     /// Parses the string `string` into an `Origin`. Parsing will never
     /// allocate. This method should be used instead of
-    /// [`Origin::parse()`](crate::uri::Origin::parse()) when the source URI is already
-    /// a `String`. Returns an `Error` if `string` is not a valid origin URI.
+    /// [`Origin::parse()`](crate::uri::Origin::parse()) when the source URI is
+    /// already a `String`. Returns an `Error` if `string` is not a valid origin
+    /// URI.
     ///
     /// # Example
     ///
@@ -266,13 +267,13 @@ impl<'a> Origin<'a> {
     /// let abnormal = Origin::parse("/a/b/c//d").unwrap();
     /// assert!(!abnormal.is_normalized());
     ///
-    /// let normalized = abnormal.to_normalized();
+    /// let normalized = abnormal.into_normalized();
     /// assert!(normalized.is_normalized());
     /// assert_eq!(normalized, Origin::parse("/a/b/c/d").unwrap());
     /// ```
-    pub fn to_normalized(&self) -> Origin<'_> {
+    pub fn into_normalized(mut self) -> Self {
         if self.is_normalized() {
-            Origin::new(self.path(), self.query())
+            self
         } else {
             let mut new_path = String::with_capacity(self.path().len());
             for segment in self.segments() {
@@ -284,7 +285,9 @@ impl<'a> Origin<'a> {
                 new_path.push('/');
             }
 
-            Origin::new(new_path, self.query())
+            // Note: normalization preserves segmments!
+            self.path = Indexed::from(Cow::Owned(new_path));
+            self
         }
     }
 
@@ -624,7 +627,7 @@ mod tests {
     fn normalized() {
         let uri_to_string = |s| Origin::parse(s)
             .unwrap()
-            .to_normalized()
+            .into_normalized()
             .to_string();
 
         assert_eq!(uri_to_string("/"), "/".to_string());
diff --git a/core/lib/src/handler.rs b/core/lib/src/handler.rs
index 37172b5a..9f20904e 100644
--- a/core/lib/src/handler.rs
+++ b/core/lib/src/handler.rs
@@ -191,6 +191,12 @@ pub type ErrorHandler = for<'r> fn(&'r Request<'_>) -> CatcherFuture<'r>;
 /// Type type of `Future` returned by an error handler.
 pub type CatcherFuture<'r> = BoxFuture<'r, response::Result<'r>>;
 
+// A handler to use when one is needed temporarily. Don't use outside of Rocket!
+#[doc(hidden)]
+pub fn dummy<'r>(r: &'r Request<'_>, _: Data) -> HandlerFuture<'r> {
+    Outcome::from(r, ()).pin()
+}
+
 impl<'r, 'o: 'r> Outcome<'o> {
     /// Return the `Outcome` of response to `req` from `responder`.
     ///
diff --git a/core/lib/src/rocket.rs b/core/lib/src/rocket.rs
index c79ce238..3a862211 100644
--- a/core/lib/src/rocket.rs
+++ b/core/lib/src/rocket.rs
@@ -73,12 +73,14 @@ impl Rocket {
               Paint::blue(&base),
               Paint::magenta(":"));
 
-        for mut route in routes {
-            let path = route.uri.clone();
-            if let Err(e) = route.set_uri(base.clone(), path) {
-                error_!("{}", e);
-                panic!("Invalid route URI.");
-            }
+        for route in routes {
+            let old_route = route.clone();
+            let route = route.map_base(|old| format!("{}{}", base, old))
+                .unwrap_or_else(|e| {
+                    error_!("Route `{}` has a malformed URI.", old_route);
+                    error_!("{}", e);
+                    panic!("Invalid route URI.");
+                });
 
             info_!("{}", route);
             self.router.add(route);
@@ -720,12 +722,12 @@ impl Rocket {
     pub fn mount<R: Into<Vec<Route>>>(mut self, base: &str, routes: R) -> Self {
         let base_uri = Origin::parse_owned(base.to_string())
             .unwrap_or_else(|e| {
-                error_!("Invalid origin URI '{}' used as mount point.", base);
+                error!("Invalid mount point URI: {}.", Paint::white(base));
                 panic!("Error: {}", e);
             });
 
         if base_uri.query().is_some() {
-            error_!("Mount point '{}' contains query string.", base);
+            error!("Mount point '{}' contains query string.", base);
             panic!("Invalid mount point.");
         }
 
diff --git a/core/lib/src/router/collider.rs b/core/lib/src/router/collider.rs
index f3b1aa68..1b64c96f 100644
--- a/core/lib/src/router/collider.rs
+++ b/core/lib/src/router/collider.rs
@@ -156,28 +156,28 @@ mod tests {
     use crate::rocket::Rocket;
     use crate::config::Config;
     use crate::request::Request;
-    use crate::router::{dummy_handler, route::Route};
-    use crate::http::{Method, MediaType, ContentType, Accept};
+    use crate::router::route::Route;
+    use crate::http::{Method, Method::*, MediaType, ContentType, Accept};
     use crate::http::uri::Origin;
-    use crate::http::Method::*;
+    use crate::handler::dummy;
 
     type SimpleRoute = (Method, &'static str);
 
     fn m_collide(a: SimpleRoute, b: SimpleRoute) -> bool {
-        let route_a = Route::new(a.0, a.1, dummy_handler);
-        route_a.collides_with(&Route::new(b.0, b.1, dummy_handler))
+        let route_a = Route::new(a.0, a.1, dummy);
+        route_a.collides_with(&Route::new(b.0, b.1, dummy))
     }
 
     fn unranked_collide(a: &'static str, b: &'static str) -> bool {
-        let route_a = Route::ranked(0, Get, a, dummy_handler);
-        let route_b = Route::ranked(0, Get, b, dummy_handler);
+        let route_a = Route::ranked(0, Get, a, dummy);
+        let route_b = Route::ranked(0, Get, b, dummy);
         eprintln!("Checking {} against {}.", route_a, route_b);
         route_a.collides_with(&route_b)
     }
 
     fn s_s_collide(a: &'static str, b: &'static str) -> bool {
-        let a = Route::new(Get, a, dummy_handler);
-        let b = Route::new(Get, b, dummy_handler);
+        let a = Route::new(Get, a, dummy);
+        let b = Route::new(Get, b, dummy);
         paths_collide(&a, &b)
     }
 
@@ -343,12 +343,12 @@ mod tests {
     fn r_mt_mt_collide<S1, S2>(m: Method, mt1: S1, mt2: S2) -> bool
         where S1: Into<Option<&'static str>>, S2: Into<Option<&'static str>>
     {
-        let mut route_a = Route::new(m, "/", dummy_handler);
+        let mut route_a = Route::new(m, "/", dummy);
         if let Some(mt_str) = mt1.into() {
             route_a.format = Some(mt_str.parse::<MediaType>().unwrap());
         }
 
-        let mut route_b = Route::new(m, "/", dummy_handler);
+        let mut route_b = Route::new(m, "/", dummy);
         if let Some(mt_str) = mt2.into() {
             route_b.format = Some(mt_str.parse::<MediaType>().unwrap());
         }
@@ -411,7 +411,7 @@ mod tests {
             }
         }
 
-        let mut route = Route::new(m, "/", dummy_handler);
+        let mut route = Route::new(m, "/", dummy);
         if let Some(mt_str) = mt2.into() {
             route.format = Some(mt_str.parse::<MediaType>().unwrap());
         }
@@ -470,7 +470,7 @@ mod tests {
     fn req_route_path_match(a: &'static str, b: &'static str) -> bool {
         let rocket = Rocket::custom(Config::development());
         let req = Request::new(&rocket, Get, Origin::parse(a).expect("valid URI"));
-        let route = Route::ranked(0, Get, b.to_string(), dummy_handler);
+        let route = Route::ranked(0, Get, b.to_string(), dummy);
         route.matches(&req)
     }
 
diff --git a/core/lib/src/router/mod.rs b/core/lib/src/router/mod.rs
index 0a9ed1cd..0849cdf2 100644
--- a/core/lib/src/router/mod.rs
+++ b/core/lib/src/router/mod.rs
@@ -1,25 +1,17 @@
 mod collider;
 mod route;
 
-use std::collections::hash_map::HashMap;
-
-use futures::future::BoxFuture;
-
-pub use self::route::Route;
+use std::collections::HashMap;
 
 use crate::request::Request;
 use crate::http::Method;
+use crate::handler::dummy;
+
+pub use self::route::Route;
 
 // type Selector = (Method, usize);
 type Selector = Method;
 
-// A handler to use when one is needed temporarily.
-pub(crate) fn dummy_handler<'r>(
-    r: &'r Request<'_>, _: crate::Data
-) -> BoxFuture<'r, crate::handler::Outcome<'r>> {
-    crate::outcome::Outcome::from(r, ()).pin()
-}
-
 #[derive(Default)]
 pub struct Router {
     routes: HashMap<Selector, Vec<Route>>,
@@ -60,9 +52,9 @@ impl Router {
                 for a_route in left.iter_mut() {
                     for b_route in right.iter_mut() {
                         if a_route.collides_with(b_route) {
-                            let dummy_a = Route::new(Method::Get, "/", dummy_handler);
+                            let dummy_a = Route::new(Method::Get, "/", dummy);
                             let a = std::mem::replace(a_route, dummy_a);
-                            let dummy_b = Route::new(Method::Get, "/", dummy_handler);
+                            let dummy_b = Route::new(Method::Get, "/", dummy);
                             let b = std::mem::replace(b_route, dummy_b);
                             collisions.push((a, b));
                         }
@@ -102,19 +94,19 @@ impl Router {
 
 #[cfg(test)]
 mod test {
-    use super::{Router, Route, dummy_handler};
+    use super::{Router, Route};
 
     use crate::rocket::Rocket;
     use crate::config::Config;
-    use crate::http::Method;
-    use crate::http::Method::*;
+    use crate::http::{Method, Method::*};
     use crate::http::uri::Origin;
     use crate::request::Request;
+    use crate::handler::dummy;
 
     fn router_with_routes(routes: &[&'static str]) -> Router {
         let mut router = Router::new();
         for route in routes {
-            let route = Route::new(Get, route.to_string(), dummy_handler);
+            let route = Route::new(Get, route.to_string(), dummy);
             router.add(route);
         }
 
@@ -124,7 +116,7 @@ mod test {
     fn router_with_ranked_routes(routes: &[(isize, &'static str)]) -> Router {
         let mut router = Router::new();
         for &(rank, route) in routes {
-            let route = Route::ranked(rank, Get, route.to_string(), dummy_handler);
+            let route = Route::ranked(rank, Get, route.to_string(), dummy);
             router.add(route);
         }
 
@@ -134,7 +126,7 @@ mod test {
     fn router_with_unranked_routes(routes: &[&'static str]) -> Router {
         let mut router = Router::new();
         for route in routes {
-            let route = Route::ranked(0, Get, route.to_string(), dummy_handler);
+            let route = Route::ranked(0, Get, route.to_string(), dummy);
             router.add(route);
         }
 
@@ -266,9 +258,9 @@ mod test {
         assert!(route(&router, Get, "/jdlk/asdij").is_some());
 
         let mut router = Router::new();
-        router.add(Route::new(Put, "/hello".to_string(), dummy_handler));
-        router.add(Route::new(Post, "/hello".to_string(), dummy_handler));
-        router.add(Route::new(Delete, "/hello".to_string(), dummy_handler));
+        router.add(Route::new(Put, "/hello".to_string(), dummy));
+        router.add(Route::new(Post, "/hello".to_string(), dummy));
+        router.add(Route::new(Delete, "/hello".to_string(), dummy));
         assert!(route(&router, Put, "/hello").is_some());
         assert!(route(&router, Post, "/hello").is_some());
         assert!(route(&router, Delete, "/hello").is_some());
diff --git a/core/lib/src/router/route.rs b/core/lib/src/router/route.rs
index 05c6bb86..d43c4655 100644
--- a/core/lib/src/router/route.rs
+++ b/core/lib/src/router/route.rs
@@ -22,15 +22,17 @@ pub struct Route {
     pub handler: Box<dyn Handler>,
     /// The base mount point of this `Route`.
     pub base: Origin<'static>,
-    /// The uri (in Rocket's route format) that should be matched against. This
-    /// URI already includes the base mount point.
+    /// The path of this `Route` in Rocket's route format.
+    pub(crate) path: Origin<'static>,
+    /// The complete URI (in Rocket's route format) that should be matched
+    /// against. This is `base` + `path`.
     pub uri: Origin<'static>,
     /// The rank of this route. Lower ranks have higher priorities.
     pub rank: isize,
     /// The media type this route matches against, if any.
     pub format: Option<MediaType>,
     /// Cached metadata that aids in routing later.
-    pub(crate) metadata: Metadata
+    pub(crate) metadata: Metadata,
 }
 
 #[derive(Debug, Default, Clone)]
@@ -108,10 +110,7 @@ impl Route {
     /// use rocket::Route;
     /// use rocket::http::Method;
     /// # use rocket::{Request, Data};
-    /// # use rocket::handler::{Outcome, HandlerFuture};
-    /// # fn handler<'r>(request: &'r Request, _data: Data) -> HandlerFuture<'r> {
-    /// #     Outcome::from(request, "Hello, world!").pin()
-    /// # }
+    /// # use rocket::handler::{dummy as handler, Outcome, HandlerFuture};
     ///
     /// // this is rank -6 (static path, ~static query)
     /// let route = Route::new(Method::Get, "/foo?bar=baz&<zoo>", handler);
@@ -158,10 +157,7 @@ impl Route {
     /// use rocket::Route;
     /// use rocket::http::Method;
     /// # use rocket::{Request, Data};
-    /// # use rocket::handler::{Outcome, HandlerFuture};
-    /// # fn handler<'r>(request: &'r Request, _data: Data) -> HandlerFuture<'r> {
-    /// #     Outcome::from(request, "Hello, world!").pin()
-    /// # }
+    /// # use rocket::handler::{dummy as handler, Outcome, HandlerFuture};
     ///
     /// // this is a rank 1 route matching requests to `GET /`
     /// let index = Route::ranked(1, Method::Get, "/", handler);
@@ -174,18 +170,20 @@ impl Route {
         where S: AsRef<str>, H: Handler + 'static
     {
         let path = path.as_ref();
-        let uri = Origin::parse_route(path)
+        let route_path = Origin::parse_route(path)
             .unwrap_or_else(|e| panic(path, e))
-            .to_normalized()
+            .into_normalized()
             .into_owned();
 
         let mut route = Route {
+            path: route_path.clone(),
+            uri: route_path,
             name: None,
             format: None,
             base: Origin::dummy(),
             handler: Box::new(handler),
             metadata: Metadata::default(),
-            method, rank, uri
+            method, rank,
         };
 
         route.update_metadata().unwrap_or_else(|e| panic(path, e));
@@ -207,12 +205,7 @@ impl Route {
     /// ```rust
     /// use rocket::Route;
     /// use rocket::http::Method;
-    /// # use rocket::{Request, Data};
-    /// # use rocket::handler::{Outcome, HandlerFuture};
-    /// #
-    /// # fn handler<'r>(request: &'r Request, _data: Data) -> HandlerFuture<'r> {
-    /// #     Outcome::from(request, "Hello, world!").pin()
-    /// # }
+    /// # use rocket::handler::dummy as handler;
     ///
     /// let mut index = Route::new(Method::Get, "/", handler);
     /// assert_eq!(index.base(), "/");
@@ -223,66 +216,74 @@ impl Route {
         self.base.path()
     }
 
-    /// Sets the base mount point of the route to `base` and sets the path to
-    /// `path`. The `path` should _not_ contains the `base` mount point. If
-    /// `base` contains a query, it is ignored. Note that `self.uri` will
-    /// include the new `base` after this method is called.
+    /// Retrieves this route's path.
+    ///
+    /// # Example
     ///
-    /// # Errors
+    /// ```rust
+    /// use rocket::Route;
+    /// use rocket::http::Method;
+    /// # use rocket::handler::dummy as handler;
     ///
-    /// Returns an error if any of the following occur:
+    /// let index = Route::new(Method::Get, "/foo/bar?a=1", handler);
+    /// let index = index.map_base(|base| format!("{}{}", "/boo", base)).unwrap();
+    /// assert_eq!(index.uri.path(), "/boo/foo/bar");
+    /// assert_eq!(index.uri.query(), Some("a=1"));
+    /// assert_eq!(index.base(), "/boo");
+    /// assert_eq!(index.path().path(), "/foo/bar");
+    /// assert_eq!(index.path().query(), Some("a=1"));
+    /// ```
+    #[inline]
+    pub fn path(&self) -> &Origin<'_> {
+        &self.path
+    }
+
+    /// Maps the `base` of this route using `mapper`, returning a new `Route`
+    /// with the returned base.
     ///
-    ///   * The base mount point contains dynamic parameters.
-    ///   * The base mount point or path contain encoded characters.
-    ///   * The path is not a valid Rocket route URI.
+    /// `mapper` is called with the current base. The returned `String` is used
+    /// as the new base if it is a valid URI. If the returned base URI contains
+    /// a query, it is ignored. Returns an if the base produced by `mapper` is
+    /// not a valid origin URI.
     ///
     /// # Example
     ///
     /// ```rust
     /// use rocket::Route;
     /// use rocket::http::{Method, uri::Origin};
-    /// # use rocket::{Request, Data};
-    /// # use rocket::handler::{Outcome, HandlerFuture};
-    /// #
-    /// # fn handler<'r>(request: &'r Request, _data: Data) -> HandlerFuture<'r> {
-    /// #     Outcome::from(request, "Hello, world!").pin()
-    /// # }
+    /// # use rocket::handler::{dummy as handler, Outcome, HandlerFuture};
     ///
-    /// let mut index = Route::new(Method::Get, "/", handler);
+    /// let index = Route::new(Method::Get, "/foo/bar", handler);
     /// assert_eq!(index.base(), "/");
-    /// assert_eq!(index.base.path(), "/");
+    /// assert_eq!(index.path().path(), "/foo/bar");
+    /// assert_eq!(index.uri.path(), "/foo/bar");
     ///
-    /// let new_base = Origin::parse("/greeting").unwrap();
-    /// let new_uri = Origin::parse("/hi").unwrap();
-    /// index.set_uri(new_base, new_uri);
-    /// assert_eq!(index.base(), "/greeting");
-    /// assert_eq!(index.uri.path(), "/greeting/hi");
+    /// let index = index.map_base(|base| format!("{}{}", "/boo", base)).unwrap();
+    /// assert_eq!(index.base(), "/boo");
+    /// assert_eq!(index.path().path(), "/foo/bar");
+    /// assert_eq!(index.uri.path(), "/boo/foo/bar");
     /// ```
-    pub fn set_uri<'a>(
-        &mut self,
-        mut base: Origin<'a>,
-        path: Origin<'a>
-    ) -> Result<(), RouteUriError> {
-        base.clear_query();
-        for segment in <RouteSegment<'_, Path>>::parse(&base) {
-            if segment?.kind != Kind::Static {
-                return Err(RouteUriError::DynamicBase);
-            }
-        }
+    pub fn map_base<'a, F>(mut self, mapper: F) -> Result<Self, RouteUriError>
+        where F: FnOnce(Origin<'static>) -> String
+    {
+        self.base = Origin::parse_owned(mapper(self.base))?.into_normalized();
+        self.base.clear_query();
 
-        let complete_uri = format!("{}/{}", base, path);
-        let uri = Origin::parse_route(&complete_uri)?;
-        self.base = base.to_normalized().into_owned();
-        self.uri = uri.to_normalized().into_owned();
+        let new_uri = format!("{}{}", self.base, self.path);
+        self.uri = Origin::parse_route(&new_uri)?.into_owned().into_normalized();
         self.update_metadata()?;
-
-        Ok(())
+        Ok(self)
     }
 }
 
 impl fmt::Display for Route {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        write!(f, "{} {}", Paint::green(&self.method), Paint::blue(&self.uri))?;
+        write!(f, "{} ", Paint::green(&self.method))?;
+        if self.base.path() != "/" {
+            write!(f, "{}", Paint::blue(&self.base).underline())?;
+        }
+
+        write!(f, "{}", Paint::blue(&self.path))?;
 
         if self.rank > 1 {
             write!(f, " [{}]", Paint::default(&self.rank).bold())?;
diff --git a/core/lib/tests/mapped-base-issue-1262.rs b/core/lib/tests/mapped-base-issue-1262.rs
new file mode 100644
index 00000000..a78e7bbb
--- /dev/null
+++ b/core/lib/tests/mapped-base-issue-1262.rs
@@ -0,0 +1,58 @@
+#[macro_use] extern crate rocket;
+use rocket::Route;
+
+pub fn prepend(prefix: &str, route: Route) -> Route {
+    route.map_base(|base| format!("{}{}", prefix, base)).unwrap()
+}
+
+pub fn extend_routes(prefix: &str, routes: Vec<Route>) -> Vec<Route> {
+    routes.into_iter()
+        .map(|route| prepend(prefix, route))
+        .collect()
+}
+
+mod a {
+    #[get("/b/<id>")]
+    fn b(id: u8) -> String { id.to_string() }
+
+    pub fn routes() -> Vec<rocket::Route> {
+        super::extend_routes("/a", routes![b])
+    }
+}
+
+fn rocket() -> rocket::Rocket {
+    rocket::ignite().mount("/", a::routes()).mount("/foo", a::routes())
+}
+
+mod mapped_base_tests {
+    use rocket::local::blocking::Client;
+    use rocket::http::Status;
+
+    #[test]
+    fn only_prefix() {
+        let client = Client::new(super::rocket()).unwrap();
+
+        let response = client.get("/a/b/3").dispatch();
+        assert_eq!(response.into_string().unwrap(), "3");
+
+        let response = client.get("/a/b/239").dispatch();
+        assert_eq!(response.into_string().unwrap(), "239");
+
+        let response = client.get("/b/239").dispatch();
+        assert_eq!(response.status(), Status::NotFound);
+    }
+
+    #[test]
+    fn prefix_and_base() {
+        let client = Client::new(super::rocket()).unwrap();
+
+        let response = client.get("/foo/a/b/23").dispatch();
+        assert_eq!(response.into_string().unwrap(), "23");
+
+        let response = client.get("/foo/a/b/99").dispatch();
+        assert_eq!(response.into_string().unwrap(), "99");
+
+        let response = client.get("/foo/b/239").dispatch();
+        assert_eq!(response.status(), Status::NotFound);
+    }
+}
