diff --git a/glow/src/backend.rs b/glow/src/backend.rs
index 92bb993e..390ffbe5 100644
--- a/glow/src/backend.rs
+++ b/glow/src/backend.rs
@@ -208,7 +208,7 @@ impl backend::Text for Backend {
     }
 }
 
-#[cfg(feature = "image")]
+#[cfg(feature = "image_rs")]
 impl backend::Image for Backend {
     fn dimensions(&self, _handle: &iced_native::image::Handle) -> (u32, u32) {
         (50, 50)
diff --git a/src/widget.rs b/src/widget.rs
index edd35d2d..e220a15e 100644
--- a/src/widget.rs
+++ b/src/widget.rs
@@ -34,7 +34,7 @@ mod platform {
     )]
     pub use crate::renderer::widget::qr_code;
 
-    #[cfg_attr(docsrs, doc(cfg(feature = "image")))]
+    #[cfg_attr(docsrs, doc(cfg(feature = "image_rs")))]
     pub mod image {
         //! Display images in your user interface.
         pub use crate::runtime::image::viewer;
diff --git a/wgpu/Cargo.toml b/wgpu/Cargo.toml
index bdd9e65a..aa39f068 100644
--- a/wgpu/Cargo.toml
+++ b/wgpu/Cargo.toml
@@ -9,6 +9,18 @@ repository = "https://github.com/hecrj/iced"
 
 [features]
 svg = ["resvg", "usvg"]
+image = ["png", "jpeg", "jpeg_rayon", "gif", "webp", "bmp"]
+png = ["image_rs/png"]
+jpeg = ["image_rs/jpeg"]
+jpeg_rayon = ["image_rs/jpeg_rayon"]
+gif = ["image_rs/gif"]
+webp = ["image_rs/webp"]
+pnm = ["image_rs/pnm"]
+ico = ["image_rs/ico"]
+bmp = ["image_rs/bmp"]
+hdr = ["image_rs/hdr"]
+dds = ["image_rs/dds"]
+farbfeld = ["image_rs/farbfeld"]
 canvas = ["iced_graphics/canvas"]
 qr_code = ["iced_graphics/qr_code"]
 default_system_font = ["iced_graphics/font-source"]
@@ -35,8 +47,10 @@ version = "0.1"
 path = "../graphics"
 features = ["font-fallback", "font-icons"]
 
-[dependencies.image]
+[dependencies.image_rs]
 version = "0.23"
+package = "image"
+default-features = false
 optional = true
 
 [dependencies.resvg]
diff --git a/wgpu/src/backend.rs b/wgpu/src/backend.rs
index fccb5ac7..534c6cb7 100644
--- a/wgpu/src/backend.rs
+++ b/wgpu/src/backend.rs
@@ -9,7 +9,7 @@ use iced_graphics::{Primitive, Viewport};
 use iced_native::mouse;
 use iced_native::{Font, HorizontalAlignment, Size, VerticalAlignment};
 
-#[cfg(any(feature = "image", feature = "svg"))]
+#[cfg(any(feature = "image_rs", feature = "svg"))]
 use crate::image;
 
 /// A [`wgpu`] graphics backend for [`iced`].
@@ -22,7 +22,7 @@ pub struct Backend {
     text_pipeline: text::Pipeline,
     triangle_pipeline: triangle::Pipeline,
 
-    #[cfg(any(feature = "image", feature = "svg"))]
+    #[cfg(any(feature = "image_rs", feature = "svg"))]
     image_pipeline: image::Pipeline,
 
     default_text_size: u16,
@@ -40,7 +40,7 @@ impl Backend {
             settings.antialiasing,
         );
 
-        #[cfg(any(feature = "image", feature = "svg"))]
+        #[cfg(any(feature = "image_rs", feature = "svg"))]
         let image_pipeline = image::Pipeline::new(device, settings.format);
 
         Self {
@@ -48,7 +48,7 @@ impl Backend {
             text_pipeline,
             triangle_pipeline,
 
-            #[cfg(any(feature = "image", feature = "svg"))]
+            #[cfg(any(feature = "image_rs", feature = "svg"))]
             image_pipeline,
 
             default_text_size: settings.default_text_size,
@@ -92,7 +92,7 @@ impl Backend {
             );
         }
 
-        #[cfg(any(feature = "image", feature = "svg"))]
+        #[cfg(any(feature = "image_rs", feature = "svg"))]
         self.image_pipeline.trim_cache();
 
         *mouse_interaction
@@ -142,7 +142,7 @@ impl Backend {
             );
         }
 
-        #[cfg(any(feature = "image", feature = "svg"))]
+        #[cfg(any(feature = "image_rs", feature = "svg"))]
         {
             if !layer.images.is_empty() {
                 let scaled = transformation
@@ -270,7 +270,7 @@ impl backend::Text for Backend {
     }
 }
 
-#[cfg(feature = "image")]
+#[cfg(feature = "image_rs")]
 impl backend::Image for Backend {
     fn dimensions(&self, handle: &iced_native::image::Handle) -> (u32, u32) {
         self.image_pipeline.dimensions(handle)
diff --git a/wgpu/src/image.rs b/wgpu/src/image.rs
index 70bfe586..5511565e 100644
--- a/wgpu/src/image.rs
+++ b/wgpu/src/image.rs
@@ -1,6 +1,6 @@
 mod atlas;
 
-#[cfg(feature = "image")]
+#[cfg(feature = "image_rs")]
 mod raster;
 
 #[cfg(feature = "svg")]
@@ -16,7 +16,7 @@ use std::mem;
 
 use bytemuck::{Pod, Zeroable};
 
-#[cfg(feature = "image")]
+#[cfg(feature = "image_rs")]
 use iced_native::image;
 
 #[cfg(feature = "svg")]
@@ -24,7 +24,7 @@ use iced_native::svg;
 
 #[derive(Debug)]
 pub struct Pipeline {
-    #[cfg(feature = "image")]
+    #[cfg(feature = "image_rs")]
     raster_cache: RefCell<raster::Cache>,
     #[cfg(feature = "svg")]
     vector_cache: RefCell<vector::Cache>,
@@ -259,7 +259,7 @@ impl Pipeline {
         });
 
         Pipeline {
-            #[cfg(feature = "image")]
+            #[cfg(feature = "image_rs")]
             raster_cache: RefCell::new(raster::Cache::new()),
 
             #[cfg(feature = "svg")]
@@ -278,7 +278,7 @@ impl Pipeline {
         }
     }
 
-    #[cfg(feature = "image")]
+    #[cfg(feature = "image_rs")]
     pub fn dimensions(&self, handle: &image::Handle) -> (u32, u32) {
         let mut cache = self.raster_cache.borrow_mut();
         let memory = cache.load(&handle);
@@ -307,7 +307,7 @@ impl Pipeline {
     ) {
         let instances: &mut Vec<Instance> = &mut Vec::new();
 
-        #[cfg(feature = "image")]
+        #[cfg(feature = "image_rs")]
         let mut raster_cache = self.raster_cache.borrow_mut();
 
         #[cfg(feature = "svg")]
@@ -315,7 +315,7 @@ impl Pipeline {
 
         for image in images {
             match &image {
-                #[cfg(feature = "image")]
+                #[cfg(feature = "image_rs")]
                 layer::Image::Raster { handle, bounds } => {
                     if let Some(atlas_entry) = raster_cache.upload(
                         handle,
@@ -331,7 +331,7 @@ impl Pipeline {
                         );
                     }
                 }
-                #[cfg(not(feature = "image"))]
+                #[cfg(not(feature = "image_rs"))]
                 layer::Image::Raster { .. } => {}
 
                 #[cfg(feature = "svg")]
@@ -464,7 +464,7 @@ impl Pipeline {
     }
 
     pub fn trim_cache(&mut self) {
-        #[cfg(feature = "image")]
+        #[cfg(feature = "image_rs")]
         self.raster_cache.borrow_mut().trim(&mut self.texture_atlas);
 
         #[cfg(feature = "svg")]
diff --git a/wgpu/src/image/atlas/entry.rs b/wgpu/src/image/atlas/entry.rs
index 0310fc54..9b3f16df 100644
--- a/wgpu/src/image/atlas/entry.rs
+++ b/wgpu/src/image/atlas/entry.rs
@@ -10,7 +10,7 @@ pub enum Entry {
 }
 
 impl Entry {
-    #[cfg(feature = "image")]
+    #[cfg(feature = "image_rs")]
     pub fn size(&self) -> (u32, u32) {
         match self {
             Entry::Contiguous(allocation) => allocation.size(),
diff --git a/wgpu/src/image/raster.rs b/wgpu/src/image/raster.rs
index 25607dab..d5c62545 100644
--- a/wgpu/src/image/raster.rs
+++ b/wgpu/src/image/raster.rs
@@ -4,7 +4,7 @@ use std::collections::{HashMap, HashSet};
 
 #[derive(Debug)]
 pub enum Memory {
-    Host(::image::ImageBuffer<::image::Bgra<u8>, Vec<u8>>),
+    Host(::image_rs::ImageBuffer<::image_rs::Bgra<u8>, Vec<u8>>),
     Device(atlas::Entry),
     NotFound,
     Invalid,
@@ -42,14 +42,14 @@ impl Cache {
 
         let memory = match handle.data() {
             image::Data::Path(path) => {
-                if let Ok(image) = ::image::open(path) {
+                if let Ok(image) = ::image_rs::open(path) {
                     Memory::Host(image.to_bgra8())
                 } else {
                     Memory::NotFound
                 }
             }
             image::Data::Bytes(bytes) => {
-                if let Ok(image) = ::image::load_from_memory(&bytes) {
+                if let Ok(image) = ::image_rs::load_from_memory(&bytes) {
                     Memory::Host(image.to_bgra8())
                 } else {
                     Memory::Invalid
@@ -60,7 +60,7 @@ impl Cache {
                 height,
                 pixels,
             } => {
-                if let Some(image) = ::image::ImageBuffer::from_vec(
+                if let Some(image) = ::image_rs::ImageBuffer::from_vec(
                     *width,
                     *height,
                     pixels.to_vec(),
diff --git a/wgpu/src/lib.rs b/wgpu/src/lib.rs
index a4c2ac0e..e868a655 100644
--- a/wgpu/src/lib.rs
+++ b/wgpu/src/lib.rs
@@ -49,7 +49,7 @@ pub use widget::*;
 
 pub(crate) use iced_graphics::Transformation;
 
-#[cfg(any(feature = "image", feature = "svg"))]
+#[cfg(any(feature = "image_rs", feature = "svg"))]
 mod image;
 
 /// A [`wgpu`] graphics renderer for [`iced`].
