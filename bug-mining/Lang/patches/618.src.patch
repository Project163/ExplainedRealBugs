diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 1bbdf7f5e..eaaef7d13 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -63,6 +63,7 @@ The <action> type attribute can be add,update,fix,remove.
     <action issue="LANG-1682" type="fix" dev="ggregory" due-to="Capt. Cutlass">Javadoc and test: Use Strings.CI.startsWithAny method instead #1299.</action>
     <action                   type="fix" dev="ggregory" due-to="Gary Gregory">Fix NullPointerException in FastDateParser.TimeZoneStrategy.setCalendar(FastDateParser, Calendar, String) on Java 23.</action>
     <action issue="LANG-1757" type="fix" dev="ggregory" due-to="Gary Gregory">Fix NullPointerException in MethodUtils.getMatchingAccessibleMethod((Class, String, Class...)).</action>
+    <action issue="LANG-1698" type="fix" dev="ggregory" due-to="Jan Arne Sparka, Gary Gregory">Fix StackOverflowError in TypeUtils.typeVariableToString(TypeVariable), TypeUtils.toString(Type) on Java 17 and up.</action>
     <!-- ADD -->
     <action                   type="add" dev="ggregory" due-to="Gary Gregory">Add Strings and refactor StringUtils.</action>
     <action issue="LANG-1747" type="add" dev="ggregory" due-to="Oliver B. Fischer, Gary Gregory">Add StopWatch.run([Failable]Runnable) and get([Failable]Supplier).</action>
diff --git a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
index 09d9391ca..e2dafb272 100644
--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
@@ -291,7 +291,7 @@ public String toString() {
     // @formatter:off
     private static final AppendableJoiner<Type> AMP_JOINER = AppendableJoiner.<Type>builder()
             .setDelimiter(" & ")
-            .setElementAppender((a, e) -> a.append(TypeUtils.toString(e)))
+            .setElementAppender((a, e) -> a.append(toString(e)))
             .get();
     // @formatter:on
 
@@ -301,7 +301,7 @@ public String toString() {
     // @formatter:off
     private static final AppendableJoiner<TypeVariable<Class<?>>> CTJ_JOINER = AppendableJoiner.<TypeVariable<Class<?>>>builder()
         .setDelimiter(", ")
-        .setElementAppender((a, e) -> a.append(TypeUtils.anyToString(e)))
+        .setElementAppender((a, e) -> a.append(anyToString(e)))
         .get();
     // @formatter:on
 
@@ -313,7 +313,7 @@ public String toString() {
             .setPrefix("<")
             .setSuffix(">")
             .setDelimiter(", ")
-            .setElementAppender((a, e) -> a.append(TypeUtils.anyToString(e)))
+            .setElementAppender((a, e) -> a.append(anyToString(e)))
             .get();
     // @formatter:on
 
@@ -359,7 +359,6 @@ private static <T> String classToString(final Class<T> cls) {
             buf.append(cls.getName());
         }
         if (cls.getTypeParameters().length > 0) {
-            // AppendableJoiner.joinSB(buf, null, null, ", ", TypeUtils::anyToString, cls.getTypeParameters());
             CTJ_JOINER.join(buf, (TypeVariable[]) cls.getTypeParameters());
         }
         return buf.toString();
@@ -1535,7 +1534,7 @@ private static String parameterizedTypeToString(final ParameterizedType paramete
         if (recursiveTypeIndexes.length > 0) {
             appendRecursiveTypes(builder, recursiveTypeIndexes, parameterizedType.getActualTypeArguments());
         } else {
-            GT_JOINER.join(builder, parameterizedType.getActualTypeArguments());
+            GT_JOINER.join(builder, (Object[]) parameterizedType.getActualTypeArguments());
         }
         return builder.toString();
     }
@@ -1700,8 +1699,22 @@ private static String typeVariableToString(final TypeVariable<?> typeVariable) {
         final StringBuilder builder = new StringBuilder(typeVariable.getName());
         final Type[] bounds = typeVariable.getBounds();
         if (bounds.length > 0 && !(bounds.length == 1 && Object.class.equals(bounds[0]))) {
-            builder.append(" extends ");
-            AMP_JOINER.join(builder, typeVariable.getBounds());
+            // https://issues.apache.org/jira/projects/LANG/issues/LANG-1698
+            // There must be a better way to avoid a stack overflow on Java 17 and up.
+            // Bounds are different in Java 17 and up where instead of Object you can get an interface like Comparable.
+            final Type bound = bounds[0];
+            boolean append = true;
+            if (bound instanceof ParameterizedType) {
+                final Type rawType = ((ParameterizedType) bound).getRawType();
+                if (rawType instanceof Class && ((Class<?>) rawType).isInterface()) {
+                    // Avoid recursion and stack overflow on Java 17 and up.
+                    append = false;
+                }
+            }
+            if (append) {
+                builder.append(" extends ");
+                AMP_JOINER.join(builder, bounds);
+            }
         }
         return builder.toString();
     }
diff --git a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java
index bc04744d2..86aa0a71c 100644
--- a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java
@@ -19,10 +19,10 @@
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assumptions.assumeTrue;
 
 import java.awt.Insets;
 import java.io.Serializable;
@@ -45,16 +45,17 @@
 import java.util.Map;
 import java.util.Properties;
 import java.util.TreeSet;
+import java.util.stream.Stream;
 
 import org.apache.commons.lang3.AbstractLangTest;
-import org.apache.commons.lang3.JavaVersion;
-import org.apache.commons.lang3.SystemUtils;
 import org.apache.commons.lang3.reflect.testbed.Foo;
 import org.apache.commons.lang3.reflect.testbed.GenericParent;
 import org.apache.commons.lang3.reflect.testbed.GenericTypeHolder;
 import org.apache.commons.lang3.reflect.testbed.StringParameterizedChild;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Test fixture for https://issues.apache.org/jira/browse/LANG-1524
@@ -243,6 +244,17 @@ public static <T extends Comparable<? extends T>> T stub3() {
         return null;
     }
 
+    static Stream<Type> testTypeToString() {
+        // @formatter:off
+        return Stream.of(Comparator.class, Comparable.class, ArrayList.class, HashMap.class)
+                .flatMap(cls -> Stream.of(cls.getDeclaredMethods()))
+                .flatMap(m ->
+                    Stream.concat(Stream.of(m.getGenericExceptionTypes()),
+                    Stream.concat(Stream.of(m.getGenericParameterTypes()),
+                    Stream.concat(Stream.of(m.getGenericReturnType()), Stream.of(m.getTypeParameters())))));
+        // @formatter:on
+    }
+
     public The<String, String> da;
 
     public That<String, String> dat;
@@ -301,6 +313,8 @@ public void test_LANG_1524() {
     }
 
     /**
+     * Tests https://issues.apache.org/jira/projects/LANG/issues/LANG-1698
+     *
      * <pre>{@code
      * java.lang.StackOverflowError
     at org.apache.commons.lang3.reflect.TypeUtils.typeVariableToString(TypeUtils.java:1785)
@@ -321,8 +335,6 @@ public void test_LANG_1524() {
      */
     @Test
     public void test_LANG_1698() {
-        // SO on Java 17
-        assumeTrue(SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_16));
         final ParameterizedType comparing = (ParameterizedType) Arrays.stream(Comparator.class.getDeclaredMethods())
                 .filter(k -> k.getName().equals("comparing")).findFirst()
                 .orElse(Comparator.class.getDeclaredMethods()[0]).getGenericParameterTypes()[0];
@@ -1024,6 +1036,13 @@ public void testTypesSatisfyVariables() throws NoSuchMethodException {
         assertThrows(NullPointerException.class, () -> TypeUtils.typesSatisfyVariables(null));
     }
 
+    @ParameterizedTest
+    @MethodSource
+    public void testTypeToString(Type type) {
+        // No stack overflow
+        assertNotNull(TypeUtils.toString(type));
+    }
+
     @Test
     public void testUnboundedWildcardType() {
         final WildcardType unbounded = TypeUtils.wildcardType().withLowerBounds((Type) null).withUpperBounds().build();
