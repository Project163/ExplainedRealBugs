diff --git a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
index e4742ad36..55ee7d136 100644
--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
@@ -25,6 +25,7 @@
 import java.util.Locale;
 import java.util.Map;
 
+import org.apache.commons.lang3.ObjectUtils;
 import org.apache.commons.lang3.Validate;
 
 /**
@@ -69,6 +70,7 @@
  */
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
+    private static final int HASH_SEED = 31;
 
     private static final String DUMMY_PATTERN = "";
     private static final String ESCAPED_QUOTE = "''";
@@ -253,6 +255,49 @@ public void setFormatsByArgumentIndex(Format[] newFormats) {
         throw new UnsupportedOperationException();
     }
 
+    /**
+     * Check if this extended message format is equal to another object.
+     *
+     * @param obj the object to compare to
+     * @return true if this object equals the other, otherwise false
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!super.equals(obj)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
+          return false;
+        }
+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(registry, rhs.registry)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Return the hashcode.
+     *
+     * @return the hashcode
+     */
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
+        return result;
+    }
+
     /**
      * Get a custom format from a format description.
      * 
diff --git a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java
index 845a2bd09..e2bde90b4 100644
--- a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java
+++ b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java
@@ -264,6 +264,48 @@ public void testBuiltInNumberFormat() {
         checkBuiltInFormat("5: {0,number,00000.000}",  args, availableLocales);
     }
 
+    /**
+     * Test equals() and hashcode.
+     */
+    public void testEqualsHashcode() {
+        Map<String, ? extends FormatFactory> registry = Collections.singletonMap("testfmt", new LowerCaseFormatFactory());
+        Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap("testfmt", new UpperCaseFormatFactory());
+
+        String pattern = "Pattern: {0,testfmt}";
+        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry);
+
+        ExtendedMessageFormat other = null;
+
+        // Same object
+        assertTrue("same, equals()",   emf.equals(emf));
+        assertTrue("same, hashcode()", emf.hashCode() == emf.hashCode());
+
+        // Equal Object
+        other = new ExtendedMessageFormat(pattern, Locale.US, registry);
+        assertTrue("equal, equals()",   emf.equals(other));
+        assertTrue("equal, hashcode()", emf.hashCode() == other.hashCode());
+
+        // Different Class
+        other = new OtherExtendedMessageFormat(pattern, Locale.US, registry);
+        assertFalse("class, equals()",  emf.equals(other));
+        assertTrue("class, hashcode()", emf.hashCode() == other.hashCode()); // same hashcode
+        
+        // Different pattern
+        other = new ExtendedMessageFormat("X" + pattern, Locale.US, registry);
+        assertFalse("pattern, equals()",   emf.equals(other));
+        assertFalse("pattern, hashcode()", emf.hashCode() == other.hashCode());
+
+        // Different registry
+        other = new ExtendedMessageFormat(pattern, Locale.US, otherRegitry);
+        assertFalse("registry, equals()",   emf.equals(other));
+        assertFalse("registry, hashcode()", emf.hashCode() == other.hashCode());
+
+        // Different Locale
+        other = new ExtendedMessageFormat(pattern, Locale.FRANCE, registry);
+        assertFalse("locale, equals()",  emf.equals(other));
+        assertTrue("locale, hashcode()", emf.hashCode() == other.hashCode()); // same hashcode
+    }
+
     /**
      * Test a built in format for the specified Locales, plus <code>null</code> Locale.
      * @param pattern MessageFormat pattern
@@ -394,4 +436,16 @@ public Format getFormat(String name, String arguments, Locale locale) {
                             .getDateInstance(DateFormat.DEFAULT, locale);
         }
     }
+
+    /**
+     * Alternative ExtendedMessageFormat impl.
+     */
+    private static class OtherExtendedMessageFormat extends ExtendedMessageFormat {
+        public OtherExtendedMessageFormat(String pattern, Locale locale,
+                Map<String, ? extends FormatFactory> registry) {
+            super(pattern, locale, registry);
+        }
+        
+    }
+
 }
