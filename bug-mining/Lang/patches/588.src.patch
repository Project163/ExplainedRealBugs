diff --git a/src/main/java/org/apache/commons/lang3/ClassPathUtils.java b/src/main/java/org/apache/commons/lang3/ClassPathUtils.java
index df0efa255..71c3fed92 100644
--- a/src/main/java/org/apache/commons/lang3/ClassPathUtils.java
+++ b/src/main/java/org/apache/commons/lang3/ClassPathUtils.java
@@ -35,6 +35,7 @@ public class ClassPathUtils {
      *
      * @param path the source path.
      * @return a package name.
+     * @throws NullPointerException if {@code path} is null.
      * @since 3.13.0
      */
     public static String packageToPath(final String path) {
@@ -46,6 +47,7 @@ public static String packageToPath(final String path) {
      *
      * @param path the source path.
      * @return a package name.
+     * @throws NullPointerException if {@code path} is null.
      * @since 3.13.0
      */
     public static String pathToPackage(final String path) {
diff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java
index 798542034..39782f1e2 100644
--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java
+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java
@@ -62,6 +62,7 @@ private static ThreadLocalRandom random() {
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String random(final int count) {
         return random(count, false, false);
@@ -80,6 +81,7 @@ public static String random(final int count) {
      * @param numbers  if {@code true}, generated string may include
      *  numeric characters
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String random(final int count, final boolean letters, final boolean numbers) {
         return random(count, 0, 0, letters, numbers);
@@ -119,6 +121,7 @@ public static String random(final int count, final char... chars) {
      * @param numbers  if {@code true}, generated string may include
      *  numeric characters
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {
         return random(count, start, end, letters, numbers, null, random());
@@ -145,6 +148,7 @@ public static String random(final int count, final int start, final int end, fin
      * @return the random string
      * @throws ArrayIndexOutOfBoundsException if there are not
      *  {@code (end - start) + 1} characters in the set array.
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {
         return random(count, start, end, letters, numbers, chars, random());
@@ -291,6 +295,7 @@ public static String random(final int count, final String chars) {
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String randomAlphabetic(final int count) {
         return random(count, true, false);
@@ -320,6 +325,7 @@ public static String randomAlphabetic(final int minLengthInclusive, final int ma
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String randomAlphanumeric(final int count) {
         return random(count, true, true);
@@ -350,6 +356,7 @@ public static String randomAlphanumeric(final int minLengthInclusive, final int
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String randomAscii(final int count) {
         return random(count, 32, 127, false, false);
@@ -380,6 +387,7 @@ public static String randomAscii(final int minLengthInclusive, final int maxLeng
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      * @since 3.5
      */
     public static String randomGraph(final int count) {
@@ -410,6 +418,7 @@ public static String randomGraph(final int minLengthInclusive, final int maxLeng
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      */
     public static String randomNumeric(final int count) {
         return random(count, false, true);
@@ -439,6 +448,7 @@ public static String randomNumeric(final int minLengthInclusive, final int maxLe
      *
      * @param count  the length of random string to create
      * @return the random string
+     * @throws IllegalArgumentException if {@code count} &lt; 0.
      * @since 3.5
      */
     public static String randomPrint(final int count) {
diff --git a/src/main/java/org/apache/commons/lang3/builder/DiffBuilder.java b/src/main/java/org/apache/commons/lang3/builder/DiffBuilder.java
index 9b34038e1..e4d20a990 100644
--- a/src/main/java/org/apache/commons/lang3/builder/DiffBuilder.java
+++ b/src/main/java/org/apache/commons/lang3/builder/DiffBuilder.java
@@ -94,7 +94,7 @@ public class DiffBuilder<T> implements Builder<DiffResult<T>> {
      *            without creating a field {@link Diff} if the trivially equal
      *            test is enabled and returns true.  The result of this test
      *            is never changed throughout the life of this {@link DiffBuilder}.
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if {@code lhs} or {@code rhs} is {@code null}
      * @since 3.4
      */
@@ -134,7 +134,7 @@ public DiffBuilder(final T lhs, final T rhs,
      * @param style
      *            the style will use when outputting the objects, {@code null}
      *            uses the default
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if {@code lhs} or {@code rhs} is {@code null}
      */
     public DiffBuilder(final T lhs, final T rhs,
@@ -153,7 +153,7 @@ public DiffBuilder(final T lhs, final T rhs,
      * @param rhs
      *            the right-hand {@code boolean}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final boolean lhs,
@@ -191,7 +191,7 @@ public Boolean getRight() {
      * @param rhs
      *            the right-hand {@code boolean[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final boolean[] lhs,
@@ -228,7 +228,7 @@ public Boolean[] getRight() {
      * @param rhs
      *            the right-hand {@code byte}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final byte lhs,
@@ -265,7 +265,7 @@ public Byte getRight() {
      * @param rhs
      *            the right-hand {@code byte[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final byte[] lhs,
@@ -303,7 +303,7 @@ public Byte[] getRight() {
      * @param rhs
      *            the right-hand {@code char}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final char lhs,
@@ -341,7 +341,7 @@ public Character getRight() {
      * @param rhs
      *            the right-hand {@code char[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final char[] lhs,
@@ -379,7 +379,7 @@ public Character[] getRight() {
      * @param rhs
      *            the right-hand {@code double}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final double lhs,
@@ -417,7 +417,7 @@ public Double getRight() {
      * @param rhs
      *            the right-hand {@code double[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final double[] lhs,
@@ -455,7 +455,7 @@ public Double[] getRight() {
      * @param rhs
      *            the right-hand {@code float}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final float lhs,
@@ -493,7 +493,7 @@ public Float getRight() {
      * @param rhs
      *            the right-hand {@code float[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final float[] lhs,
@@ -531,7 +531,7 @@ public Float[] getRight() {
      * @param rhs
      *            the right-hand {@code int}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final int lhs,
@@ -569,7 +569,7 @@ public Integer getRight() {
      * @param rhs
      *            the right-hand {@code int[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final int[] lhs,
@@ -607,7 +607,7 @@ public Integer[] getRight() {
      * @param rhs
      *            the right-hand {@code long}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final long lhs,
@@ -645,7 +645,7 @@ public Long getRight() {
      * @param rhs
      *            the right-hand {@code long[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final long[] lhs,
@@ -683,7 +683,7 @@ public Long[] getRight() {
      * @param rhs
      *            the right-hand {@code short}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final short lhs,
@@ -721,7 +721,7 @@ public Short getRight() {
      * @param rhs
      *            the right-hand {@code short[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final short[] lhs,
@@ -759,7 +759,7 @@ public Short[] getRight() {
      * @param rhs
      *            the right-hand {@link Object}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final Object lhs,
@@ -841,7 +841,7 @@ public Object getRight() {
      * @param rhs
      *            the right-hand {@code Object[]}
      * @return this
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if field name is {@code null}
      */
     public DiffBuilder<T> append(final String fieldName, final Object[] lhs,
@@ -900,7 +900,7 @@ public Object[] getRight() {
      * @param diffResult
      *            the {@link DiffResult} to append
      * @return this
-     * @throws NullPointerException if field name is {@code null}
+     * @throws NullPointerException if field name is {@code null} or diffResult is {@code null}
      * @since 3.5
      */
     public DiffBuilder<T> append(final String fieldName, final DiffResult<T> diffResult) {
diff --git a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
index f564db95a..8297fa6a6 100644
--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
@@ -237,7 +237,7 @@ private static void reflectionAppend(final Object object, final Class<?> clazz,
      * @param object
      *            the Object to create a {@code hashCode} for
      * @return int hash code
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the Object is {@code null}
      * @throws IllegalArgumentException
      *             if the number is zero or even
@@ -281,7 +281,7 @@ public static int reflectionHashCode(final int initialNonZeroOddNumber, final in
      * @param testTransients
      *            whether to include transient fields
      * @return int hash code
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the Object is {@code null}
      * @throws IllegalArgumentException
      *             if the number is zero or even
@@ -333,7 +333,7 @@ public static int reflectionHashCode(final int initialNonZeroOddNumber, final in
      * @param excludeFields
      *            array of field names to exclude from use in calculation of hash code
      * @return int hash code
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the Object is {@code null}
      * @throws IllegalArgumentException
      *             if the number is zero or even
@@ -382,7 +382,7 @@ public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, fina
      * @param testTransients
      *            whether to include transient fields
      * @return int hash code
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the object is {@code null}
      *
      * @see HashCodeExclude
@@ -420,7 +420,7 @@ public static int reflectionHashCode(final Object object, final boolean testTran
      * @param excludeFields
      *            Collection of String field names to exclude from use in calculation of hash code
      * @return int hash code
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the object is {@code null}
      *
      * @see HashCodeExclude
@@ -457,7 +457,7 @@ public static int reflectionHashCode(final Object object, final Collection<Strin
      * @param excludeFields
      *            array of field names to exclude from use in calculation of hash code
      * @return int hash code
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the object is {@code null}
      *
      * @see HashCodeExclude
diff --git a/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java b/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java
index 231d3fc7a..afc32e25d 100644
--- a/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java
+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java
@@ -129,7 +129,7 @@ public static ToStringStyle getDefaultStyle() {
      * that the latest value set is the value returned from {@link #getDefaultStyle}.</p>
      *
      * @param style  the default {@link ToStringStyle}
-     * @throws IllegalArgumentException if the style is {@code null}
+     * @throws NullPointerException if the style is {@code null}
      */
     public static void setDefaultStyle(final ToStringStyle style) {
         defaultStyle = Objects.requireNonNull(style, "style");
diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java
index fe1ae846b..c362a162f 100644
--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java
+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java
@@ -684,7 +684,7 @@ private static int subAndCheck(final int x, final int y) {
      *
      * @param fraction  the fraction to add, must not be {@code null}
      * @return a {@link Fraction} instance with the resulting values
-     * @throws IllegalArgumentException if the fraction is {@code null}
+     * @throws NullPointerException if the fraction is {@code null}
      * @throws ArithmeticException if the resulting numerator or denominator exceeds
      *  {@code Integer.MAX_VALUE}
      */
@@ -698,7 +698,7 @@ public Fraction add(final Fraction fraction) {
      *
      * @param fraction  the fraction to subtract, must not be {@code null}
      * @return a {@link Fraction} instance with the resulting values
-     * @throws IllegalArgumentException if the fraction is {@code null}
+     * @throws NullPointerException if the fraction is {@code null}
      * @throws ArithmeticException if the resulting numerator or denominator
      *   cannot be represented in an {@code int}.
      */
diff --git a/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java
index a2566512a..d863c250c 100644
--- a/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java
+++ b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java
@@ -60,8 +60,10 @@ public FieldUtils() {
      * @param fieldName
      *            the field name to obtain
      * @return the Field object
+     * @throws NullPointerException
+     *             if the class is {@code null}
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty
+     *             if the field name is {@code null}, blank, or empty
      */
     public static Field getField(final Class<?> cls, final String fieldName) {
         return MemberUtils.setAccessibleWorkaround(getField(cls, fieldName, false));
@@ -143,8 +145,10 @@ public static Field getField(final Class<?> cls, final String fieldName, final b
      * @param fieldName
      *            the field name to obtain
      * @return the Field object
+     * @throws NullPointerException
+     *             if the class is {@code null}
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty
+     *             if the field name is {@code null}, blank, or empty
      */
     public static Field getDeclaredField(final Class<?> cls, final String fieldName) {
         return getDeclaredField(cls, fieldName, false);
@@ -163,8 +167,10 @@ public static Field getDeclaredField(final Class<?> cls, final String fieldName)
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
      * @return the Field object
+     * @throws NullPointerException
+     *             if the class is {@code null}
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty
+     *             if the field name is {@code null}, blank, or empty
      */
     public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {
         Objects.requireNonNull(cls, "cls");
@@ -191,7 +197,7 @@ public static Field getDeclaredField(final Class<?> cls, final String fieldName,
      * @param cls
      *            the {@link Class} to query
      * @return an array of Fields (possibly empty).
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the class is {@code null}
      * @since 3.2
      */
@@ -205,7 +211,7 @@ public static Field[] getAllFields(final Class<?> cls) {
      * @param cls
      *            the {@link Class} to query
      * @return a list of Fields (possibly empty).
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the class is {@code null}
      * @since 3.2
      */
@@ -228,7 +234,7 @@ public static List<Field> getAllFieldsList(final Class<?> cls) {
      * @param annotationCls
      *            the {@link Annotation} that must be present on a field to be matched
      * @return an array of Fields (possibly empty).
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *            if the class or annotation are {@code null}
      * @since 3.4
      */
@@ -243,7 +249,7 @@ public static Field[] getFieldsWithAnnotation(final Class<?> cls, final Class<?
      * @param annotationCls
      *            the {@link Annotation} that must be present on a field to be matched
      * @return a list of Fields (possibly empty).
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *            if the class or annotation are {@code null}
      * @since 3.4
      */
@@ -258,8 +264,10 @@ public static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final
      * @param field
      *            to read
      * @return the field value
+     * @throws NullPointerException
+     *             if the field is {@code null}
      * @throws IllegalArgumentException
-     *             if the field is {@code null}, or not {@code static}
+     *             if the field is not {@code static}
      * @throws IllegalAccessException
      *             if the field is not accessible
      */
@@ -276,8 +284,10 @@ public static Object readStaticField(final Field field) throws IllegalAccessExce
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method.
      * @return the field value
+     * @throws NullPointerException
+     *             if the field is {@code null}
      * @throws IllegalArgumentException
-     *             if the field is {@code null} or not {@code static}
+     *             if the field is not {@code static}
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
@@ -295,9 +305,10 @@ public static Object readStaticField(final Field field, final boolean forceAcces
      * @param fieldName
      *            the field name to obtain
      * @return the value of the field
+     * @throws NullPointerException
+     *             if the class is {@code null}, or the field could not be found
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty, is not {@code static}, or could
-     *             not be found
+     *             if the field name is {@code null}, blank or empty, or is not {@code static}
      * @throws IllegalAccessException
      *             if the field is not accessible
      */
@@ -317,9 +328,10 @@ public static Object readStaticField(final Class<?> cls, final String fieldName)
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
      * @return the Field object
+     * @throws NullPointerException
+     *             if the class is {@code null}, or the field could not be found
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty, is not {@code static}, or could
-     *             not be found
+     *             if the field name is {@code null}, blank or empty, or is not {@code static}
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
@@ -339,9 +351,10 @@ public static Object readStaticField(final Class<?> cls, final String fieldName,
      * @param fieldName
      *            the field name to obtain
      * @return the value of the field
+     * @throws NullPointerException
+     *             if the class is {@code null}, or the field could not be found
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty, is not {@code static}, or could
-     *             not be found
+     *             if the field name is {@code null}, blank, empty, or is not {@code static}
      * @throws IllegalAccessException
      *             if the field is not accessible
      */
@@ -361,9 +374,10 @@ public static Object readDeclaredStaticField(final Class<?> cls, final String fi
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
      * @return the Field object
+     * @throws NullPointerException
+     *             if the class is {@code null}, or the field could not be found
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty, is not {@code static}, or could
-     *             not be found
+     *             if the field name is blank or empty, is not {@code static}
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
@@ -382,7 +396,7 @@ public static Object readDeclaredStaticField(final Class<?> cls, final String fi
      * @param target
      *            the object to call on, may be {@code null} for {@code static} fields
      * @return the field value
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the field is {@code null}
      * @throws IllegalAccessException
      *             if the field is not accessible
@@ -402,7 +416,7 @@ public static Object readField(final Field field, final Object target) throws Il
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method.
      * @return the field value
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the field is {@code null}
      * @throws IllegalAccessException
      *             if the field is not made accessible
@@ -425,8 +439,10 @@ public static Object readField(final Field field, final Object target, final boo
      * @param fieldName
      *            the field name to obtain
      * @return the value of the field
+     * @throws NullPointerException
+     *             if the target is {@code null}
      * @throws IllegalArgumentException
-     *             if the class is {@code null}, or the field name is blank or empty or could not be found
+     *             if the field name is {@code null}, blank, empty, or could not be found
      * @throws IllegalAccessException
      *             if the named field is not {@code public}
      */
@@ -446,8 +462,10 @@ public static Object readField(final Object target, final String fieldName) thro
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
      * @return the field value
+     * @throws NullPointerException
+     *             if {@code target} is {@code null}
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, or the field name is blank or empty or could not be found
+     *             if the field name is {@code null}, blank, empty, or could not be found
      * @throws IllegalAccessException
      *             if the named field is not made accessible
      */
@@ -468,8 +486,10 @@ public static Object readField(final Object target, final String fieldName, fina
      * @param fieldName
      *            the field name to obtain
      * @return the value of the field
+     * @throws NullPointerException
+     *             if {@code target} is @{code null}
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, or the field name is blank or empty or could not be found
+     *             if {@code fieldName} is {@code null}, blank or empty, or could not be found
      * @throws IllegalAccessException
      *             if the named field is not {@code public}
      */
@@ -489,8 +509,10 @@ public static Object readDeclaredField(final Object target, final String fieldNa
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match public fields.
      * @return the Field object
+     * @throws NullPointerException
+     *             if {@code target} is @{code null}
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, or the field name is blank or empty or could not be found
+     *             if {@code fieldName} is {@code null}, blank or empty, or could not be found
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
@@ -510,8 +532,10 @@ public static Object readDeclaredField(final Object target, final String fieldNa
      *            to write
      * @param value
      *            to set
+     * @throws NullPointerException
+     *              if the field is {@code null}
      * @throws IllegalArgumentException
-     *             if the field is {@code null} or not {@code static}, or {@code value} is not assignable
+     *              if the field is not {@code static}, or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not {@code public} or is {@code final}
      */
@@ -530,8 +554,10 @@ public static void writeStaticField(final Field field, final Object value) throw
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
+     * @throws NullPointerException
+     *              if the field is {@code null}
      * @throws IllegalArgumentException
-     *             if the field is {@code null} or not {@code static}, or {@code value} is not assignable
+     *              if the field is not {@code static}, or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible or is {@code final}
      */
@@ -551,8 +577,10 @@ public static void writeStaticField(final Field field, final Object value, final
      *            to write
      * @param value
      *            to set
+     * @throws NullPointerException
+     *             if {@code target} is @{code null}
      * @throws IllegalArgumentException
-     *             if {@code cls} is {@code null}, the field name is blank or empty, the field cannot be located or is
+     *             if {@code fieldName} is {@code null}, blank or empty, the field cannot be located or is
      *             not {@code static}, or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not {@code public} or is {@code final}
@@ -574,9 +602,10 @@ public static void writeStaticField(final Class<?> cls, final String fieldName,
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
+     * @throws NullPointerException
+     *             if {@code cls} is {@code null} or the field cannot be located
      * @throws IllegalArgumentException
-     *             if {@code cls} is {@code null}, the field name is blank or empty, the field cannot be located or is
-     *             not {@code static}, or {@code value} is not assignable
+     *             if {@code fieldName} is {@code null}, blank or empty, the field not {@code static}, or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible or is {@code final}
      */
@@ -597,9 +626,10 @@ public static void writeStaticField(final Class<?> cls, final String fieldName,
      *            to write
      * @param value
      *            to set
+     * @throws NullPointerException
+     *             if {@code cls} is {@code null} or the field cannot be located
      * @throws IllegalArgumentException
-     *             if {@code cls} is {@code null}, the field name is blank or empty, the field cannot be located or is
-     *             not {@code static}, or {@code value} is not assignable
+     *             if the field name is @{code null}, blank, empty, not {@code static}, or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not {@code public} or is {@code final}
      */
@@ -619,9 +649,10 @@ public static void writeDeclaredStaticField(final Class<?> cls, final String fie
      * @param forceAccess
      *            whether to break scope restrictions using the {@code AccessibleObject#setAccessible(boolean)} method.
      *            {@code false} will only match {@code public} fields.
+     * @throws NullPointerException
+     *             if {@code cls} is {@code null} or the field cannot be located
      * @throws IllegalArgumentException
-     *             if {@code cls} is {@code null}, the field name is blank or empty, the field cannot be located or is
-     *             not {@code static}, or {@code value} is not assignable
+     *             if the field name is @{code null}, blank, empty, not {@code static}, or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible or is {@code final}
      */
@@ -642,9 +673,12 @@ public static void writeDeclaredStaticField(final Class<?> cls, final String fie
      *            the object to call on, may be {@code null} for {@code static} fields
      * @param value
      *            to set
+     * @throws NullPointerException
+     *             if the field is {@code null}
+     * @throws IllegalArgumentException
+     *             if {@code value} is not assignable
      * @throws IllegalAccessException
-     *             if the field or target is {@code null}, the field is not accessible or is {@code final}, or
-     *             {@code value} is not assignable
+     *             if the field is not accessible or is {@code final}
      */
     public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException {
         writeField(field, target, value, false);
@@ -663,8 +697,10 @@ public static void writeField(final Field field, final Object target, final Obje
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
+     * @throws NullPointerException
+     *             if the field is {@code null}
      * @throws IllegalArgumentException
-     *             if the field is {@code null} or {@code value} is not assignable
+     *             if {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible or is {@code final}
      */
@@ -684,7 +720,7 @@ public static void writeField(final Field field, final Object target, final Obje
      *
      * @param field
      *            to remove the final modifier
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the field is {@code null}
      * @since 3.2
      */
@@ -701,7 +737,7 @@ public static void removeFinalModifier(final Field field) {
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *             if the field is {@code null}
      * @deprecated As of Java 12, we can no longer drop the {@code final} modifier, thus
      *             rendering this method obsolete. The JDK discussion about this change can be found
@@ -748,9 +784,11 @@ public static void removeFinalModifier(final Field field, final boolean forceAcc
      *            the field name to obtain
      * @param value
      *            to set
+     * @throws NullPointerException
+     *             if {@code target} is @{code null}
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, {@code fieldName} is blank or empty or could not be found, or
-     *             {@code value} is not assignable
+     *             if {@code fieldName} is {@code null}, blank, empty, or could not be found,
+     *             or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not accessible
      */
@@ -771,9 +809,11 @@ public static void writeField(final Object target, final String fieldName, final
      *            whether to break scope restrictions using the
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
+     * @throws NullPointerException
+     *             if {@code target} is @{code null}
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, {@code fieldName} is blank or empty or could not be found, or
-     *             {@code value} is not assignable
+     *             if {@code fieldName} is {@code null}, blank, empty, or could not be found,
+     *             or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
@@ -796,9 +836,11 @@ public static void writeField(final Object target, final String fieldName, final
      *            the field name to obtain
      * @param value
      *            to set
+     * @throws NullPointerException
+     *             if {@code target} is @{code null}
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, {@code fieldName} is blank or empty or could not be found, or
-     *             {@code value} is not assignable
+     *             if {@code fieldName} is {@code null}, blank or empty, or could not be found,
+     *             or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
@@ -820,8 +862,8 @@ public static void writeDeclaredField(final Object target, final String fieldNam
      *            {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} method. {@code false} will only
      *            match {@code public} fields.
      * @throws IllegalArgumentException
-     *             if {@code target} is {@code null}, {@code fieldName} is blank or empty or could not be found, or
-     *             {@code value} is not assignable
+     *             if {@code fieldName} is {@code null}, blank or empty, or could not be found,
+     *             or {@code value} is not assignable
      * @throws IllegalAccessException
      *             if the field is not made accessible
      */
diff --git a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java
index 35d9cfc2e..3cf99834b 100644
--- a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java
+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java
@@ -142,6 +142,7 @@ public static Object invokeMethod(final Object object, final boolean forceAccess
      * @throws NoSuchMethodException if there is no such accessible method
      * @throws InvocationTargetException wraps an exception thrown by the method invoked
      * @throws IllegalAccessException if the requested method is not accessible via reflection
+     * @throws NullPointerException if the object or method name are {@code null}
      */
     public static Object invokeMethod(final Object object, final String methodName,
             Object... args) throws NoSuchMethodException,
@@ -170,7 +171,7 @@ public static Object invokeMethod(final Object object, final String methodName,
      * @throws NoSuchMethodException if there is no such accessible method
      * @throws InvocationTargetException wraps an exception thrown by the method invoked
      * @throws IllegalAccessException if the requested method is not accessible via reflection
-     *
+     * @throws NullPointerException if the object or method name are {@code null}
      * @since 3.5
      */
     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName,
@@ -197,6 +198,7 @@ public static Object invokeMethod(final Object object, final boolean forceAccess
      * @throws NoSuchMethodException if there is no such accessible method
      * @throws InvocationTargetException wraps an exception thrown by the method invoked
      * @throws IllegalAccessException if the requested method is not accessible via reflection
+     * @throws NullPointerException if the object or method name are {@code null}
      * @since 3.5
      */
     public static Object invokeMethod(final Object object, final boolean forceAccess, final String methodName, Object[] args, Class<?>[] parameterTypes)
@@ -294,6 +296,7 @@ public static Object invokeExactMethod(final Object object, final String methodN
      *  method invoked
      * @throws IllegalAccessException if the requested method is not accessible
      *  via reflection
+     * @throws NullPointerException if the object or method name are {@code null}
      */
     public static Object invokeExactMethod(final Object object, final String methodName,
             Object... args) throws NoSuchMethodException,
@@ -320,6 +323,7 @@ public static Object invokeExactMethod(final Object object, final String methodN
      *  method invoked
      * @throws IllegalAccessException if the requested method is not accessible
      *  via reflection
+     * @throws NullPointerException if the object or method name are {@code null}
      */
     public static Object invokeExactMethod(final Object object, final String methodName, Object[] args, Class<?>[] parameterTypes)
         throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
@@ -711,6 +715,7 @@ public static Method getMatchingAccessibleMethod(final Class<?> cls,
      * @param methodName The method that we wish to call
      * @param parameterTypes Argument class types
      * @throws IllegalStateException if there is no unique result
+     * @throws NullPointerException if the class is {@code null}
      * @return The method
      *
      * @since 3.5
@@ -861,7 +866,7 @@ public static Method[] getMethodsWithAnnotation(final Class<?> cls, final Class<
      * @param annotationCls
      *            the {@link Annotation} that must be present on a method to be matched
      * @return a list of Methods (possibly empty).
-     * @throws IllegalArgumentException
+     * @throws NullPointerException
      *            if the class or annotation are {@code null}
      * @since 3.4
      */
diff --git a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
index 83beab013..09e65b749 100644
--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
@@ -415,6 +415,7 @@ private static boolean containsVariableTypeSameParametrizedTypeBound(final TypeV
      * @return a {@link Map} of the type assignments that could be determined
      * for the type variables in each type in the inheritance hierarchy from
      * {@code type} to {@code toClass} inclusive.
+     * @throws NullPointerException if either {@code cls} or {@code superParameterizedType} is {@code null}
      */
     public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls,
             final ParameterizedType superParameterizedType) {
@@ -670,6 +671,7 @@ && isAssignable(genericInterface, (Type) midClass)) {
      *
      * @param typeVariable the subject type variable, not {@code null}
      * @return a non-empty array containing the bounds of the type variable.
+     * @throws NullPointerException if {@code typeVariable} is {@code null}
      */
     public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) {
         Objects.requireNonNull(typeVariable, "typeVariable");
@@ -686,6 +688,7 @@ public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) {
      * @param wildcardType the subject wildcard type, not {@code null}
      * @return a non-empty array containing the lower bounds of the wildcard
      * type.
+     * @throws NullPointerException if {@code wildcardType} is {@code null}
      */
     public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {
         Objects.requireNonNull(wildcardType, "wildcardType");
@@ -703,6 +706,7 @@ public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {
      * @param wildcardType the subject wildcard type, not {@code null}
      * @return a non-empty array containing the upper bounds of the wildcard
      * type.
+     * @throws NullPointerException if {@code wildcardType} is {@code null}
      */
     public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {
         Objects.requireNonNull(wildcardType, "wildcardType");
@@ -1509,6 +1513,7 @@ private static <T> void mapTypeVariablesToArguments(final Class<T> cls,
      * {@link WildcardType} or {@link TypeVariable}, not {@code null}.
      * @return an array containing the values from {@code bounds} minus the
      * redundant types.
+     * @throws NullPointerException if {@code bounds} is {@code null}
      */
     public static Type[] normalizeUpperBounds(final Type[] bounds) {
         Objects.requireNonNull(bounds, "bounds");
@@ -1680,6 +1685,7 @@ private static Type substituteTypeVariables(final Type type, final Map<TypeVaria
      *
      * @param typeVariable the type variable to create a String representation for, not {@code null}
      * @return String
+     * @throws NullPointerException if {@code typeVariable} is {@code null}
      * @since 3.2
      */
     public static String toLongString(final TypeVariable<?> typeVariable) {
@@ -1713,6 +1719,7 @@ private static <T> String toString(final T object) {
      *
      * @param type the type to create a String representation for, not {@code null}
      * @return String
+     * @throws NullPointerException if {@code type} is {@code null}
      * @since 3.2
      */
     public static String toString(final Type type) {
@@ -1747,6 +1754,7 @@ public static String toString(final Type type) {
      * type variables, not {@code null}.
      * @return whether or not the types can be assigned to their respective type
      * variables.
+     * @throws NullPointerException if {@code typeVariableMap} is {@code null}
      */
     public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVariableMap) {
         Objects.requireNonNull(typeVariableMap, "typeVariableMap");
diff --git a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java
index 0d051e5c5..81ac519e0 100644
--- a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java
@@ -180,6 +180,11 @@ public void testExceptions() {
                 () -> RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random()));
         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(8, 32, 48, false, true));
         assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.random(8, 32, 65, true, false));
+        assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.randomAlphabetic(-1));
+        assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.randomAscii(-1));
+        assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.randomGraph(-1));
+        assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.randomNumeric(-1));
+        assertThrows(IllegalArgumentException.class, () -> RandomStringUtils.randomPrint(-1));
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/lang3/builder/DiffBuilderTest.java b/src/test/java/org/apache/commons/lang3/builder/DiffBuilderTest.java
index 705fee26f..003d2abad 100644
--- a/src/test/java/org/apache/commons/lang3/builder/DiffBuilderTest.java
+++ b/src/test/java/org/apache/commons/lang3/builder/DiffBuilderTest.java
@@ -317,6 +317,16 @@ public void testNullRhs() {
         assertThrows(NullPointerException.class, () -> new DiffBuilder<>(this, null, ToStringStyle.DEFAULT_STYLE));
     }
 
+    @Test
+    public void testNullLhs_4args() {
+        assertThrows(NullPointerException.class, () -> new DiffBuilder<>(null, this, ToStringStyle.DEFAULT_STYLE, true));
+    }
+
+    @Test
+    public void testNullRhs_4args() {
+        assertThrows(NullPointerException.class, () -> new DiffBuilder<>(this, null, ToStringStyle.DEFAULT_STYLE, true));
+    }
+
     @Test
     public void testObject() {
         final TypeTestClass class1 = new TypeTestClass();
diff --git a/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java b/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java
index b68a994f3..d7eb8cb23 100644
--- a/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java
@@ -107,22 +107,22 @@ public void testGetField() {
     }
 
     @Test
-    public void testGetFieldIllegalArgumentException1() {
+    public void testGetFieldNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getField(null, "none"));
     }
 
     @Test
-    public void testGetFieldIllegalArgumentException2() {
+    public void testGetFieldIllegalArgumentException1() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getField(PublicChild.class, null));
     }
 
     @Test
-    public void testGetFieldIllegalArgumentException3() {
+    public void testGetFieldIllegalArgumentException2() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getField(PublicChild.class, ""));
     }
 
     @Test
-    public void testGetFieldIllegalArgumentException4() {
+    public void testGetFieldIllegalArgumentException3() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getField(PublicChild.class, " "));
     }
 
@@ -146,22 +146,22 @@ public void testGetFieldForceAccess() {
     }
 
     @Test
-    public void testGetFieldForceAccessIllegalArgumentException1() {
+    public void testGetFieldForceAccessNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getField(null, "none", true));
     }
 
     @Test
-    public void testGetFieldForceAccessIllegalArgumentException2() {
+    public void testGetFieldForceAccessIllegalArgumentException1() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getField(PublicChild.class, null, true));
     }
 
     @Test
-    public void testGetFieldForceAccessIllegalArgumentException3() {
+    public void testGetFieldForceAccessIllegalArgumentException2() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getField(PublicChild.class, "", true));
     }
 
     @Test
-    public void testGetFieldForceAccessIllegalArgumentException4() {
+    public void testGetFieldForceAccessIllegalArgumentException3() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getField(PublicChild.class, " ", true));
     }
 
@@ -183,6 +183,11 @@ public void testGetAllFields() {
         assertEquals(expected, allFields.length, Arrays.toString(allFields));
     }
 
+    @Test
+    public void testGetAllFieldsNullPointerException() {
+        assertThrows(NullPointerException.class, () -> FieldUtils.getAllFields(null));
+    }
+
     private Field[] sort(final Field[] fields) {
         // Field does not implement Comparable, so we use a KISS solution here.
         return ArraySorter.sort(fields, ObjectToStringComparator.INSTANCE);
@@ -209,6 +214,11 @@ public void testGetAllFieldsList() {
 
     }
 
+    @Test
+    public void testGetAllFieldListsNullPointerException() {
+        assertThrows(NullPointerException.class, () -> FieldUtils.getAllFieldsList(null));
+    }
+
     @Test
     public void testGetFieldsWithAnnotation() throws NoSuchFieldException {
         assertArrayEquals(new Field[0], FieldUtils.getFieldsWithAnnotation(Object.class, Annotated.class));
@@ -220,17 +230,17 @@ public void testGetFieldsWithAnnotation() throws NoSuchFieldException {
     }
 
     @Test
-    public void testGetFieldsWithAnnotationIllegalArgumentException1() {
+    public void testGetFieldsWithAnnotationNullPointerException1() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getFieldsWithAnnotation(FieldUtilsTest.class, null));
     }
 
     @Test
-    public void testGetFieldsWithAnnotationIllegalArgumentException2() {
+    public void testGetFieldsWithAnnotationNullPointerException2() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getFieldsWithAnnotation(null, Annotated.class));
     }
 
     @Test
-    public void testGetFieldsWithAnnotationIllegalArgumentException3() {
+    public void testGetFieldsWithAnnotationNullPointerException3() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getFieldsWithAnnotation(null, null));
     }
 
@@ -248,17 +258,17 @@ public void testGetFieldsListWithAnnotation() throws NoSuchFieldException {
     }
 
     @Test
-    public void testGetFieldsListWithAnnotationIllegalArgumentException1() {
+    public void testGetFieldsListWithAnnotationNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getFieldsListWithAnnotation(FieldUtilsTest.class, null));
     }
 
     @Test
-    public void testGetFieldsListWithAnnotationIllegalArgumentException2() {
+    public void testGetFieldsListWithAnnotationNullPointerException2() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getFieldsListWithAnnotation(null, Annotated.class));
     }
 
     @Test
-    public void testGetFieldsListWithAnnotationIllegalArgumentException3() {
+    public void testGetFieldsListWithAnnotationNullPointerException3() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getFieldsListWithAnnotation(null, null));
     }
 
@@ -282,22 +292,22 @@ public void testGetDeclaredField() {
     }
 
     @Test
-    public void testGetDeclaredFieldAccessIllegalArgumentException1() {
+    public void testGetDeclaredFieldAccessNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getDeclaredField(null, "none"));
     }
 
     @Test
-    public void testGetDeclaredFieldAccessIllegalArgumentException2() {
+    public void testGetDeclaredFieldAccessIllegalArgumentException1() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getDeclaredField(PublicChild.class, null));
     }
 
     @Test
-    public void testGetDeclaredFieldAccessIllegalArgumentException3() {
+    public void testGetDeclaredFieldAccessIllegalArgumentException2() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getDeclaredField(PublicChild.class, ""));
     }
 
     @Test
-    public void testGetDeclaredFieldAccessIllegalArgumentException4() {
+    public void testGetDeclaredFieldAccessIllegalArgumentException3() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getDeclaredField(PublicChild.class, " "));
     }
 
@@ -321,22 +331,22 @@ public void testGetDeclaredFieldForceAccess() {
     }
 
     @Test
-    public void testGetDeclaredFieldForceAccessIllegalArgumentException1() {
+    public void testGetDeclaredFieldForceAccessNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.getDeclaredField(null, "none", true));
     }
 
     @Test
-    public void testGetDeclaredFieldForceAccessIllegalArgumentException2() {
+    public void testGetDeclaredFieldForceAccessIllegalArgumentException1() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getDeclaredField(PublicChild.class, null, true));
     }
 
     @Test
-    public void testGetDeclaredFieldForceAccessIllegalArgumentException3() {
+    public void testGetDeclaredFieldForceAccessIllegalArgumentException2() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getDeclaredField(PublicChild.class, "", true));
     }
 
     @Test
-    public void testGetDeclaredFieldForceAccessIllegalArgumentException4() {
+    public void testGetDeclaredFieldForceAccessIllegalArgumentException3() {
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.getDeclaredField(PublicChild.class, " ", true));
     }
 
@@ -346,12 +356,12 @@ public void testReadStaticField() throws Exception {
     }
 
     @Test
-    public void testReadStaticFieldIllegalArgumentException1() {
+    public void testReadStaticFieldNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.readStaticField(null));
     }
 
     @Test
-    public void testReadStaticFieldIllegalArgumentException2() throws Exception {
+    public void testReadStaticFieldIllegalArgumentException() throws Exception {
         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, "VALUE")));
         final Field nonStaticField = FieldUtils.getField(PublicChild.class, "s");
         assumeTrue(nonStaticField != null);
@@ -365,15 +375,15 @@ public void testReadStaticFieldForceAccess() throws Exception {
     }
 
     @Test
-    public void testReadStaticFieldForceAccessIllegalArgumentException1() {
+    public void testReadStaticFieldForceAccessNullPointerException() {
         assertThrows(NullPointerException.class, () -> FieldUtils.readStaticField(null, true));
     }
 
     @Test
-    public void testReadStaticFieldForceAccessIllegalArgumentException2() {
+    public void testReadStaticFieldForceAccessIllegalArgumentException() {
         final Field nonStaticField = FieldUtils.getField(PublicChild.class, "s", true);
         assumeTrue(nonStaticField != null);
-        assertThrows(IllegalArgumentException.class, () -> FieldUtils.readStaticField(nonStaticField));
+        assertThrows(IllegalArgumentException.class, () -> FieldUtils.readStaticField(nonStaticField, true));
     }
 
     @Test
@@ -386,7 +396,7 @@ public void testReadNamedStaticField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readStaticField(null, "none"),
-                "null class should cause an IllegalArgumentException");
+                "null class should cause an NullPointerException");
 
         assertThrows(
                 IllegalArgumentException.class,
@@ -406,7 +416,7 @@ public void testReadNamedStaticField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readStaticField(Foo.class, "does_not_exist"),
-                "a field that doesn't exist should cause an IllegalArgumentException");
+                "a field that doesn't exist should cause an NullPointerException");
 
         assertThrows(
                 IllegalArgumentException.class,
@@ -424,7 +434,7 @@ public void testReadNamedStaticFieldForceAccess() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readStaticField(null, "none", true),
-                "null class should cause an IllegalArgumentException");
+                "null class should cause an NullPointerException");
 
         assertThrows(
                 IllegalArgumentException.class,
@@ -444,7 +454,7 @@ public void testReadNamedStaticFieldForceAccess() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readStaticField(Foo.class, "does_not_exist", true),
-                "a field that doesn't exist should cause an IllegalArgumentException");
+                "a field that doesn't exist should cause an NullPointerException");
 
         assertThrows(
                 IllegalArgumentException.class,
@@ -455,6 +465,9 @@ public void testReadNamedStaticFieldForceAccess() throws Exception {
     @Test
     public void testReadDeclaredNamedStaticField() throws Exception {
         assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(Foo.class, "VALUE"));
+        assertThrows(
+                NullPointerException.class, () ->
+                FieldUtils.readDeclaredField(null, "VALUE"));
         assertThrows(
                 NullPointerException.class, () -> FieldUtils.readDeclaredStaticField(PublicChild.class, "VALUE"));
         assertThrows(
@@ -463,6 +476,15 @@ public void testReadDeclaredNamedStaticField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.readDeclaredStaticField(PublicChild.class, null));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.readDeclaredStaticField(PublicChild.class, ""));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.readDeclaredStaticField(PublicChild.class, " "));
     }
 
     @Test
@@ -475,6 +497,15 @@ public void testReadDeclaredNamedStaticFieldForceAccess() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "VALUE", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, null, true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, "", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, " ", true));
     }
 
     @Test
@@ -499,7 +530,7 @@ public void testReadField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readField(null, publicChild),
-                "a null field should cause an IllegalArgumentException");
+                "a null field should cause an NullPointerException");
     }
 
     @Test
@@ -528,7 +559,7 @@ public void testReadFieldForceAccess() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readField(null, publicChild, true),
-                "a null field should cause an IllegalArgumentException");
+                "a null field should cause an NullPointerException");
     }
 
     @Test
@@ -555,7 +586,7 @@ public void testReadNamedField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readField((Object) null, "none"),
-                "a null target should cause an IllegalArgumentException");
+                "a null target should cause an NullPointerException");
 
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.readField(publicChild, "b"));
 
@@ -602,7 +633,7 @@ public void testReadNamedFieldForceAccess() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readField((Object) null, "none", true),
-                "a null target should cause an IllegalArgumentException");
+                "a null target should cause an NullPointerException");
     }
 
     @Test
@@ -625,7 +656,7 @@ public void testReadDeclaredNamedField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readDeclaredField(null, "none"),
-                "a null target should cause an IllegalArgumentException");
+                "a null target should cause an NullPointerException");
 
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.readDeclaredField(publicChild, "s"));
         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s"));
@@ -661,7 +692,7 @@ public void testReadDeclaredNamedFieldForceAccess() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.readDeclaredField(null, "none", true),
-                "a null target should cause an IllegalArgumentException");
+                "a null target should cause an NullPointerException");
 
         assertThrows(IllegalArgumentException.class, () -> FieldUtils.readDeclaredField(publicChild, "s", true));
         assertEquals("ss", FieldUtils.readDeclaredField(publiclyShadowedChild, "s", true));
@@ -703,6 +734,10 @@ public void testWriteStaticField() throws Exception {
         assertThrows(
                 IllegalAccessException.class,
                 () -> FieldUtils.writeStaticField(StaticContainer.class.getDeclaredField("IMMUTABLE_PRIVATE"), "new"));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeStaticField(null, "new"));
     }
 
     @Test
@@ -731,6 +766,10 @@ public void testWriteStaticFieldForceAccess() throws Exception {
         assertThrows(
                 IllegalAccessException.class,
                 () -> FieldUtils.writeStaticField(StaticContainer.class.getDeclaredField("IMMUTABLE_PRIVATE"), "new", true));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeStaticField(null, "new", true));
     }
 
     @Test
@@ -758,6 +797,19 @@ public void testWriteNamedStaticField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new"));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeStaticField(null, "IMMUTABLE_PRIVATE", "new"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeStaticField(StaticContainerChild.class, null, "new"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeStaticField(StaticContainerChild.class, "", "new"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeStaticField(StaticContainerChild.class, " ", "new"));
     }
 
     @Test
@@ -782,6 +834,19 @@ public void testWriteNamedStaticFieldForceAccess() throws Exception {
         assertThrows(
                 IllegalAccessException.class,
                 () -> FieldUtils.writeStaticField(StaticContainerChild.class, "IMMUTABLE_PRIVATE", "new", true));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeStaticField(null, "IMMUTABLE_PRIVATE", "new", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeStaticField(StaticContainerChild.class, null, "new", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeStaticField(StaticContainerChild.class, "", "new", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeStaticField(StaticContainerChild.class, " ", "new", true));
     }
 
     @Test
@@ -809,6 +874,19 @@ public void testWriteDeclaredNamedStaticField() throws Exception {
         assertThrows(
                 NullPointerException.class,
                 () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new"));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeDeclaredStaticField(null, "mutablePublic", "new"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, null, "new"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, "", "new"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, " ", "new"));
     }
 
     @Test
@@ -833,6 +911,19 @@ public void testWriteDeclaredNamedStaticFieldForceAccess() throws Exception {
         assertThrows(
                 IllegalAccessException.class,
                 () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, "IMMUTABLE_PRIVATE", "new", true));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeDeclaredStaticField(null, "mutablePublic", "new", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, null, "new", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, "", "new", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredStaticField(StaticContainer.class, " ", "new", true));
     }
 
     @Test
@@ -849,6 +940,10 @@ public void testWriteField() throws Exception {
         assertThrows(
                 IllegalAccessException.class,
                 () -> FieldUtils.writeField(parentClass.getDeclaredField("d"), publicChild, Double.valueOf(Double.MAX_VALUE)));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeField(null, publicChild, "S"));
     }
 
     @Test
@@ -865,6 +960,10 @@ public void testWriteFieldForceAccess() throws Exception {
         field = parentClass.getDeclaredField("d");
         FieldUtils.writeField(field, publicChild, Double.valueOf(Double.MAX_VALUE), true);
         assertEquals(Double.valueOf(Double.MAX_VALUE), field.get(publicChild));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeField(null, publicChild, "S", true));
     }
 
     @Test
@@ -896,6 +995,19 @@ public void testWriteNamedField() throws Exception {
         assertThrows(
                 IllegalArgumentException.class,
                 () -> FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(1.0)));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeField((Object) null, "s", "s"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeField(publicChild, null, "s"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeField(publicChild, "", "s"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeField(publicChild, " ", "s"));
     }
 
     @Test
@@ -926,6 +1038,19 @@ public void testWriteNamedFieldForceAccess() throws Exception {
         assertEquals(Integer.valueOf(0), FieldUtils.readField(privatelyShadowedChild, "i", true));
         FieldUtils.writeField(privatelyShadowedChild, "d", Double.valueOf(0.0), true);
         assertEquals(Double.valueOf(0.0), FieldUtils.readField(privatelyShadowedChild, "d", true));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeField((Object) null, "s", "s", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeField(publicChild, null, "s", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeField(publicChild, "", "s", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeField(publicChild, " ", "s", true));
     }
 
     @Test
@@ -960,6 +1085,19 @@ public void testWriteDeclaredNamedField() throws Exception {
         assertThrows(
                 IllegalArgumentException.class,
                 () -> FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(1.0)));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeDeclaredField(null, "s", "S"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredField(publicChild, "null", "S"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredField(publicChild, "", "S"));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredField(publicChild, " ", "S"));
     }
 
     @Test
@@ -992,6 +1130,19 @@ public void testWriteDeclaredNamedFieldForceAccess() throws Exception {
         assertEquals(Integer.valueOf(0), FieldUtils.readDeclaredField(privatelyShadowedChild, "i", true));
         FieldUtils.writeDeclaredField(privatelyShadowedChild, "d", Double.valueOf(0.0), true);
         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, "d", true));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> FieldUtils.writeDeclaredField(null, "s", "S", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredField(publicChild, "null", "S", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredField(publicChild, "", "S", true));
+        assertThrows(
+                IllegalArgumentException.class,
+                () -> FieldUtils.writeDeclaredField(publicChild, " ", "S", true));
     }
 
     @Test
@@ -1011,6 +1162,11 @@ public void testRemoveFinalModifier() throws Exception {
         }
     }
 
+    @Test
+    public void testRemoveFinalModifierNullPointerException() {
+        assertThrows(NullPointerException.class, () -> FieldUtils.removeFinalModifier(null));
+    }
+
     @Test
     public void testRemoveFinalModifierWithAccess() throws Exception {
         final Field field = StaticContainer.class.getDeclaredField("IMMUTABLE_PRIVATE_2");
@@ -1023,6 +1179,11 @@ public void testRemoveFinalModifierWithAccess() throws Exception {
         }
     }
 
+    @Test
+    public void testRemoveFinalModifierWithAccessNullPointerException() {
+        assertThrows(NullPointerException.class, () -> FieldUtils.removeFinalModifier(null, true));
+    }
+
     @Test
     public void testRemoveFinalModifierWithoutAccess() throws Exception {
         final Field field = StaticContainer.class.getDeclaredField("IMMUTABLE_PRIVATE_2");
diff --git a/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java b/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java
index ad9265712..8a5030f88 100644
--- a/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java
@@ -447,6 +447,9 @@ public void testInvokeMethod() throws Exception {
                 MethodUtils.invokeMethod(testBean, "varOverloadEcho", "x", "y"));
         TestBean.verify(new ImmutablePair<>("Number...", new Number[]{17, 23, 42}),
                 MethodUtils.invokeMethod(testBean, "varOverloadEcho", 17, 23, 42));
+
+        assertThrows(NullPointerException.class, () -> MethodUtils.invokeMethod(null, "foo", 1, 2));
+        assertThrows(NullPointerException.class, () -> MethodUtils.invokeMethod(testBean, null, 1, 2));
     }
 
     @Test
@@ -492,6 +495,22 @@ public void testInvokeExactMethod() throws Exception {
                 NoSuchMethodException.class,
                 () -> MethodUtils.invokeExactMethod(testBean, "foo", NumberUtils.LONG_ONE));
         assertThrows(NoSuchMethodException.class, () -> MethodUtils.invokeExactMethod(testBean, "foo", Boolean.TRUE));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> MethodUtils.invokeExactMethod(null, "foo", NumberUtils.BYTE_ONE));
+        assertThrows(
+                NullPointerException.class,
+                () -> MethodUtils.invokeExactMethod(testBean, null, NumberUtils.BYTE_ONE));
+
+        assertThrows(
+                NullPointerException.class,
+                () -> MethodUtils.invokeExactMethod(null, "foo", new Object[]{NumberUtils.DOUBLE_ONE},
+                        new Class[]{Double.TYPE}));
+        assertThrows(
+                NullPointerException.class,
+                () -> MethodUtils.invokeExactMethod(testBean, null, new Object[]{NumberUtils.DOUBLE_ONE},
+                        new Class[]{Double.TYPE}));
     }
 
     @Test
@@ -893,17 +912,17 @@ public void testGetMethodsListWithAnnotation() throws NoSuchMethodException {
     }
 
     @Test
-    public void testGetMethodsListWithAnnotationIllegalArgumentException1() {
+    public void testGetMethodsListWithAnnotationNullPointerException1() {
         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsListWithAnnotation(FieldUtilsTest.class, null));
     }
 
     @Test
-    public void testGetMethodsListWithAnnotationIllegalArgumentException2() {
+    public void testGetMethodsListWithAnnotationNullPointerException2() {
         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsListWithAnnotation(null, Annotated.class));
     }
 
     @Test
-    public void testGetMethodsListWithAnnotationIllegalArgumentException3() {
+    public void testGetMethodsListWithAnnotationNullPointerException3() {
         assertThrows(NullPointerException.class, () -> MethodUtils.getMethodsListWithAnnotation(null, null));
     }
 
@@ -1007,6 +1026,11 @@ public void testInvokeMethodForceAccessWithArgs() throws Exception {
         assertEquals("privateStringStuff(double)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", 5.0d));
         assertEquals("privateStringStuff(String)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", "Hi There"));
         assertEquals("privateStringStuff(Object)", MethodUtils.invokeMethod(testBean, true, "privateStringStuff", new Date()));
+
+        assertThrows(NullPointerException.class,
+                () -> MethodUtils.invokeMethod(null, true, "privateStringStuff", "Hi There"));
+        assertThrows(NullPointerException.class,
+                () -> MethodUtils.invokeMethod(testBean, true, null, "Hi There"));
     }
 
     @Test
@@ -1056,6 +1080,9 @@ public void testGetMatchingMethod() throws NoSuchMethodException {
 
         assertEquals(MethodUtils.getMatchingMethod(GetMatchingMethodImpl.class, "testMethod5", RuntimeException.class),
                 GetMatchingMethodImpl.class.getMethod("testMethod5", Exception.class));
+
+        assertThrows(NullPointerException.class,
+                () -> MethodUtils.getMatchingMethod(null, "testMethod5", RuntimeException.class));
     }
 
     private static final class GetMatchingMethodClass {
diff --git a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java
index 49f2c0d7d..fb7a41206 100644
--- a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java
@@ -282,6 +282,11 @@ public void testDetermineTypeVariableAssignments() throws SecurityException,
         assertTrue(typeVarAssigns.containsKey(treeSetTypeVar));
         assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns
                 .get(treeSetTypeVar));
+
+        assertThrows(NullPointerException.class,
+                () -> TypeUtils.determineTypeArguments(TreeSet.class, null));
+        assertThrows(NullPointerException.class,
+                () -> TypeUtils.determineTypeArguments(null, iterableType));
     }
 
     @Test
@@ -984,6 +989,8 @@ public void testParameterizeWithOwnerVarArgsNullPointerException() {
     @Test
     public void testToLongString() {
         assertEquals(getClass().getName() + ":B", TypeUtils.toLongString(getClass().getTypeParameters()[0]));
+
+        assertThrows(NullPointerException.class, () -> TypeUtils.toLongString(null));
     }
 
     @Test
@@ -1007,6 +1014,8 @@ public void testTypesSatisfyVariables() throws SecurityException,
         typeVarAssigns.clear();
         typeVarAssigns.put(getClass().getMethod("stub3").getTypeParameters()[0], Integer.class);
         assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns));
+
+        assertThrows(NullPointerException.class, () -> TypeUtils.typesSatisfyVariables(null));
     }
 
     @Test
@@ -1017,6 +1026,11 @@ public void testUnboundedWildcardType() {
         assertArrayEquals(new Type[] { null }, TypeUtils.getImplicitLowerBounds(unbounded));
         assertEquals("?", TypeUtils.toString(unbounded));
         assertEquals("?", unbounded.toString());
+
+        assertThrows(NullPointerException.class,
+                () -> TypeUtils.getImplicitLowerBounds(null));
+        assertThrows(NullPointerException.class,
+                () -> TypeUtils.getImplicitUpperBounds(null));
     }
 
     @Test
