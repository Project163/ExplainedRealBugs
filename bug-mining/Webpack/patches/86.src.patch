diff --git a/lib/ConcatenationScope.js b/lib/ConcatenationScope.js
index 77d14b253..66515947b 100644
--- a/lib/ConcatenationScope.js
+++ b/lib/ConcatenationScope.js
@@ -39,16 +39,19 @@ const NAMESPACE_OBJECT_EXPORT = "__WEBPACK_NAMESPACE_OBJECT__";
 
 class ConcatenationScope {
 	/**
-	 * @param {ModuleInfo[]} modulesWithInfo all module info in order
+	 * @param {ModuleInfo[] | Map<Module, ModuleInfo>} modulesMap all module info by module
 	 * @param {ConcatenatedModuleInfo} currentModule the current module info
 	 */
-	constructor(modulesWithInfo, currentModule) {
+	constructor(modulesMap, currentModule) {
 		this._currentModule = currentModule;
-		this._modulesWithInfo = modulesWithInfo;
-		this._modulesMap = new Map();
-		for (const info of modulesWithInfo) {
-			this._modulesMap.set(info.module, info);
+		if (Array.isArray(modulesMap)) {
+			const map = new Map();
+			for (const info of modulesMap) {
+				map.set(info.module, info);
+			}
+			modulesMap = map;
 		}
+		this._modulesMap = modulesMap;
 	}
 
 	/**
diff --git a/lib/optimize/ConcatenatedModule.js b/lib/optimize/ConcatenatedModule.js
index 223c64b64..b13755a20 100644
--- a/lib/optimize/ConcatenatedModule.js
+++ b/lib/optimize/ConcatenatedModule.js
@@ -27,9 +27,11 @@ const makeSerializable = require("../util/makeSerializable");
 const propertyAccess = require("../util/propertyAccess");
 const {
 	filterRuntime,
-	mergeRuntime,
-	runtimeToString,
-	intersectRuntime
+	intersectRuntime,
+	mergeRuntimeCondition,
+	mergeRuntimeConditionNonFalse,
+	runtimeConditionToString,
+	subtractRuntimeCondition
 } = require("../util/runtime");
 
 /** @typedef {import("eslint-scope").Scope} Scope */
@@ -82,6 +84,7 @@ const {
  */
 
 /** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo } ModuleInfo */
+/** @typedef {ConcatenatedModuleInfo | ExternalModuleInfo | ReferenceToModuleInfo } ModuleInfoOrReference */
 
 /**
  * @typedef {Object} ConcatenatedModuleInfo
@@ -118,6 +121,13 @@ const {
  * @property {string} interopDefaultAccessName
  */
 
+/**
+ * @typedef {Object} ReferenceToModuleInfo
+ * @property {"reference"} type
+ * @property {RuntimeSpec | boolean} runtimeCondition
+ * @property {ConcatenatedModuleInfo | ExternalModuleInfo} target
+ */
+
 const RESERVED_NAMES = [
 	// internal names (should always be renamed)
 	ConcatenationScope.DEFAULT_EXPORT,
@@ -576,18 +586,6 @@ const getPathInAst = (ast, node) => {
 	}
 };
 
-/**
- * @param {ModuleInfo[]} modulesWithInfo modules
- * @returns {Map<Module, ModuleInfo>} mapping
- */
-const modulesWithInfoToMap = modulesWithInfo => {
-	const moduleToInfoMap = new Map();
-	for (const m of modulesWithInfo) {
-		moduleToInfoMap.set(m.module, m);
-	}
-	return moduleToInfoMap;
-};
-
 const TYPES = new Set(["javascript"]);
 
 class ConcatenatedModule extends Module {
@@ -797,12 +795,12 @@ class ConcatenatedModule extends Module {
 	_createConcatenationList(rootModule, modulesSet, runtime, moduleGraph) {
 		/** @type {ConcatenationEntry[]} */
 		const list = [];
-		/** @type {Set<Module>} */
-		const existingEntries = new Set();
+		/** @type {Map<Module, RuntimeSpec | true>} */
+		const existingEntries = new Map();
 
 		/**
 		 * @param {Module} module a module
-		 * @returns {Iterable<{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | boolean }>} imported modules in order
+		 * @returns {Iterable<{ connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} imported modules in order
 		 */
 		const getConcatenatedImports = module => {
 			let connections = Array.from(moduleGraph.getOutgoingConnections(module));
@@ -829,27 +827,23 @@ class ConcatenatedModule extends Module {
 			references.sort(
 				concatComparators(bySourceOrder, keepOriginalOrder(references))
 			);
-			/** @type {Map<Module, { connection, runtimeCondition }>} */
+			/** @type {Map<Module, { connection: ModuleGraphConnection, runtimeCondition: RuntimeSpec | true }>} */
 			const referencesMap = new Map();
 			for (const { connection } of references) {
 				const runtimeCondition = filterRuntime(runtime, r =>
 					connection.isTargetActive(r)
 				);
+				if (runtimeCondition === false) continue;
 				const module = connection.module;
 				const entry = referencesMap.get(module);
 				if (entry === undefined) {
 					referencesMap.set(module, { connection, runtimeCondition });
 					continue;
 				}
-				if (runtimeCondition === false || entry.runtimeCondition === true)
-					continue;
-				if (entry.runtimeCondition === false || runtimeCondition === true) {
-					entry.runtimeCondition = runtimeCondition;
-					continue;
-				}
-				entry.runtimeCondition = mergeRuntime(
+				entry.runtimeCondition = mergeRuntimeConditionNonFalse(
 					entry.runtimeCondition,
-					runtimeCondition
+					runtimeCondition,
+					runtime
 				);
 			}
 			return referencesMap.values();
@@ -857,22 +851,23 @@ class ConcatenatedModule extends Module {
 
 		/**
 		 * @param {ModuleGraphConnection} connection graph connection
-		 * @param {RuntimeSpec | boolean} runtimeCondition runtime condition
+		 * @param {RuntimeSpec | true} runtimeCondition runtime condition
 		 * @returns {void}
 		 */
 		const enterModule = (connection, runtimeCondition) => {
 			const module = connection.module;
 			if (!module) return;
-			if (existingEntries.has(module)) {
+			const existingEntry = existingEntries.get(module);
+			if (existingEntry === true) {
 				return;
 			}
 			if (modulesSet.has(module)) {
-				existingEntries.add(module);
+				existingEntries.set(module, true);
 				if (runtimeCondition !== true) {
 					throw new Error(
-						`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${
-							runtimeCondition && runtimeToString(runtimeCondition)
-						}). This should not happen.`
+						`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${runtimeConditionToString(
+							runtimeCondition
+						)}). This should not happen.`
 					);
 				}
 				const imports = getConcatenatedImports(module);
@@ -884,7 +879,39 @@ class ConcatenatedModule extends Module {
 					runtimeCondition
 				});
 			} else {
-				existingEntries.add(connection.module);
+				if (existingEntry !== undefined) {
+					const reducedRuntimeCondition = subtractRuntimeCondition(
+						runtimeCondition,
+						existingEntry,
+						runtime
+					);
+					if (reducedRuntimeCondition === false) return;
+					runtimeCondition = reducedRuntimeCondition;
+					existingEntries.set(
+						connection.module,
+						mergeRuntimeConditionNonFalse(
+							existingEntry,
+							runtimeCondition,
+							runtime
+						)
+					);
+				} else {
+					existingEntries.set(connection.module, runtimeCondition);
+				}
+				if (list.length > 0) {
+					const lastItem = list[list.length - 1];
+					if (
+						lastItem.type === "external" &&
+						lastItem.module === connection.module
+					) {
+						lastItem.runtimeCondition = mergeRuntimeCondition(
+							lastItem.runtimeCondition,
+							runtimeCondition,
+							runtime
+						);
+						return;
+					}
+				}
 				list.push({
 					type: "external",
 					get module() {
@@ -898,7 +925,7 @@ class ConcatenatedModule extends Module {
 			}
 		};
 
-		existingEntries.add(rootModule);
+		existingEntries.set(rootModule, true);
 		const imports = getConcatenatedImports(rootModule);
 		for (const { connection, runtimeCondition } of imports)
 			enterModule(connection, runtimeCondition);
@@ -965,10 +992,10 @@ class ConcatenatedModule extends Module {
 
 		const requestShortener = runtimeTemplate.requestShortener;
 		// Meta info for each module
-		const modulesWithInfo = this._getModulesWithInfo(moduleGraph, runtime);
-
-		// Create mapping from module to info
-		const moduleToInfoMap = modulesWithInfoToMap(modulesWithInfo);
+		const [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(
+			moduleGraph,
+			runtime
+		);
 
 		// Set with modules that need a generated namespace object
 		/** @type {Set<ConcatenatedModuleInfo>} */
@@ -976,9 +1003,9 @@ class ConcatenatedModule extends Module {
 
 		// Generate source code and analyse scopes
 		// Prepare a ReplaceSource for the final source
-		for (const info of modulesWithInfo) {
+		for (const info of moduleToInfoMap.values()) {
 			this._analyseModule(
-				modulesWithInfo,
+				moduleToInfoMap,
 				info,
 				dependencyTemplates,
 				runtimeTemplate,
@@ -1050,9 +1077,12 @@ class ConcatenatedModule extends Module {
 						if (ConcatenationScope.isModuleReference(name)) {
 							const match = ConcatenationScope.matchModuleReference(name);
 							if (!match) continue;
+							const referencedInfo = modulesWithInfo[match.index];
+							if (referencedInfo.type === "reference")
+								throw new Error("Module reference can't point to a reference");
 							const binding = getFinalBinding(
 								moduleGraph,
-								modulesWithInfo[match.index],
+								referencedInfo,
 								match.ids,
 								moduleToInfoMap,
 								runtime,
@@ -1096,7 +1126,7 @@ class ConcatenatedModule extends Module {
 		}
 
 		// generate names for symbols
-		for (const info of modulesWithInfo) {
+		for (const info of moduleToInfoMap.values()) {
 			const { usedNames: namespaceObjectUsedNames } = getUsedNamesInScopeInfo(
 				info.module.identifier(),
 				""
@@ -1210,15 +1240,18 @@ class ConcatenatedModule extends Module {
 		}
 
 		// Find and replace references to modules
-		for (const info of modulesWithInfo) {
+		for (const info of moduleToInfoMap.values()) {
 			if (info.type === "concatenated") {
 				for (const reference of info.globalScope.through) {
 					const name = reference.identifier.name;
 					const match = ConcatenationScope.matchModuleReference(name);
 					if (match) {
+						const referencedInfo = modulesWithInfo[match.index];
+						if (referencedInfo.type === "reference")
+							throw new Error("Module reference can't point to a reference");
 						const finalName = getFinalName(
 							moduleGraph,
-							modulesWithInfo[match.index],
+							referencedInfo,
 							match.ids,
 							moduleToInfoMap,
 							runtime,
@@ -1385,9 +1418,10 @@ ${defineGetters}`
 		}
 
 		// evaluate modules in order
-		for (const info of modulesWithInfo) {
+		for (const rawInfo of modulesWithInfo) {
 			let name;
 			let isConditional = false;
+			const info = rawInfo.type === "reference" ? rawInfo.target : rawInfo;
 			switch (info.type) {
 				case "concatenated": {
 					result.add(
@@ -1411,9 +1445,12 @@ ${defineGetters}`
 						)}\n`
 					);
 					runtimeRequirements.add(RuntimeGlobals.require);
+					const {
+						runtimeCondition
+					} = /** @type {ExternalModuleInfo | ReferenceToModuleInfo} */ (rawInfo);
 					const condition = runtimeTemplate.runtimeConditionExpression({
 						chunkGraph,
-						runtimeCondition: info.runtimeCondition,
+						runtimeCondition,
 						runtime,
 						runtimeRequirements
 					});
@@ -1471,7 +1508,7 @@ ${defineGetters}`
 	}
 
 	/**
-	 * @param {ModuleInfo[]} modulesWithInfo modulesWithInfo
+	 * @param {Map<Module, ModuleInfo>} modulesMap modulesMap
 	 * @param {ModuleInfo} info info
 	 * @param {DependencyTemplates} dependencyTemplates dependencyTemplates
 	 * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate
@@ -1480,7 +1517,7 @@ ${defineGetters}`
 	 * @param {RuntimeSpec} runtime runtime
 	 */
 	_analyseModule(
-		modulesWithInfo,
+		modulesMap,
 		info,
 		dependencyTemplates,
 		runtimeTemplate,
@@ -1492,10 +1529,7 @@ ${defineGetters}`
 			const m = info.module;
 			try {
 				// Create a concatenation scope to track and capture information
-				const concatenationScope = new ConcatenationScope(
-					modulesWithInfo,
-					info
-				);
+				const concatenationScope = new ConcatenationScope(modulesMap, info);
 
 				// TODO cache codeGeneration results
 				const codeGenResult = m.codeGeneration({
@@ -1567,7 +1601,7 @@ ${defineGetters}`
 	/**
 	 * @param {ModuleGraph} moduleGraph the module graph
 	 * @param {RuntimeSpec} runtime the runtime
-	 * @returns {ModuleInfo[]} module info items
+	 * @returns {[ModuleInfoOrReference[], Map<Module, ModuleInfo>]} module info items
 	 */
 	_getModulesWithInfo(moduleGraph, runtime) {
 		const orderedConcatenationList = this._createConcatenationList(
@@ -1576,46 +1610,65 @@ ${defineGetters}`
 			runtime,
 			moduleGraph
 		);
-		return orderedConcatenationList.map((info, index) => {
-			switch (info.type) {
-				case "concatenated": {
-					return {
-						type: "concatenated",
-						module: info.module,
-						index,
-						ast: undefined,
-						internalSource: undefined,
-						runtimeRequirements: undefined,
-						source: undefined,
-						globalScope: undefined,
-						moduleScope: undefined,
-						internalNames: new Map(),
-						exportMap: undefined,
-						rawExportMap: undefined,
-						namespaceExportSymbol: undefined,
-						namespaceObjectName: undefined,
-						interopNamespaceObjectUsed: false,
-						interopNamespaceObjectName: undefined,
-						interopDefaultAccessUsed: false,
-						interopDefaultAccessName: undefined
-					};
+		/** @type {Map<Module, ModuleInfo>} */
+		const map = new Map();
+		const list = orderedConcatenationList.map((info, index) => {
+			let item = map.get(info.module);
+			if (item === undefined) {
+				switch (info.type) {
+					case "concatenated":
+						item = {
+							type: "concatenated",
+							module: info.module,
+							index,
+							ast: undefined,
+							internalSource: undefined,
+							runtimeRequirements: undefined,
+							source: undefined,
+							globalScope: undefined,
+							moduleScope: undefined,
+							internalNames: new Map(),
+							exportMap: undefined,
+							rawExportMap: undefined,
+							namespaceExportSymbol: undefined,
+							namespaceObjectName: undefined,
+							interopNamespaceObjectUsed: false,
+							interopNamespaceObjectName: undefined,
+							interopDefaultAccessUsed: false,
+							interopDefaultAccessName: undefined
+						};
+						break;
+					case "external":
+						item = {
+							type: "external",
+							module: info.module,
+							runtimeCondition: info.runtimeCondition,
+							index,
+							name: undefined,
+							interopNamespaceObjectUsed: false,
+							interopNamespaceObjectName: undefined,
+							interopDefaultAccessUsed: false,
+							interopDefaultAccessName: undefined
+						};
+						break;
+					default:
+						throw new Error(
+							`Unsupported concatenation entry type ${info.type}`
+						);
 				}
-				case "external":
-					return {
-						type: "external",
-						module: info.module,
-						runtimeCondition: info.runtimeCondition,
-						index,
-						name: undefined,
-						interopNamespaceObjectUsed: false,
-						interopNamespaceObjectName: undefined,
-						interopDefaultAccessUsed: false,
-						interopDefaultAccessName: undefined
-					};
-				default:
-					throw new Error(`Unsupported concatenation entry type ${info.type}`);
+				map.set(item.module, item);
+				return item;
+			} else {
+				/** @type {ReferenceToModuleInfo} */
+				const ref = {
+					type: "reference",
+					runtimeCondition: info.runtimeCondition,
+					target: item
+				};
+				return ref;
 			}
 		});
+		return [list, map];
 	}
 
 	findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {
@@ -1676,6 +1729,7 @@ ${defineGetters}`
 					break;
 				case "external":
 					hash.update(`${chunkGraph.getModuleId(info.module)}`);
+					// TODO runtimeCondition
 					break;
 			}
 		}
diff --git a/lib/util/runtime.js b/lib/util/runtime.js
index 8f662f57b..d864989d7 100644
--- a/lib/util/runtime.js
+++ b/lib/util/runtime.js
@@ -11,6 +11,7 @@ const SortableSet = require("./SortableSet");
 /** @typedef {import("../Entrypoint").EntryOptions} EntryOptions */
 
 /** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */
+/** @typedef {RuntimeSpec | boolean} RuntimeCondition */
 
 /**
  * @param {Compilation} compilation the compilation
@@ -104,11 +105,22 @@ const getRuntimesString = set => {
  * @param {RuntimeSpec} runtime runtime(s)
  * @returns {string} readable version
  */
-exports.runtimeToString = runtime => {
+const runtimeToString = runtime => {
 	if (runtime === undefined) return "*";
 	if (typeof runtime === "string") return runtime;
 	return runtime.getFromUnorderedCache(getRuntimesString);
 };
+exports.runtimeToString = runtimeToString;
+
+/**
+ * @param {RuntimeCondition} runtimeCondition runtime condition
+ * @returns {string} readable version
+ */
+exports.runtimeConditionToString = runtimeCondition => {
+	if (runtimeCondition === true) return "true";
+	if (runtimeCondition === false) return "false";
+	return runtimeToString(runtimeCondition);
+};
 
 /**
  * @param {RuntimeSpec} a first
@@ -203,6 +215,46 @@ const mergeRuntime = (a, b) => {
 };
 exports.mergeRuntime = mergeRuntime;
 
+/**
+ * @param {RuntimeCondition} a first
+ * @param {RuntimeCondition} b second
+ * @param {RuntimeSpec} runtime full runtime
+ * @returns {RuntimeCondition} result
+ */
+exports.mergeRuntimeCondition = (a, b, runtime) => {
+	if (a === false) return b;
+	if (b === false) return a;
+	if (a === true || b === true) return true;
+	const merged = mergeRuntime(a, b);
+	if (merged === undefined) return undefined;
+	if (typeof merged === "string") {
+		if (typeof runtime === "string" && merged === runtime) return true;
+		return merged;
+	}
+	if (typeof runtime === "string" || runtime === undefined) return merged;
+	if (merged.size === runtime.size) return true;
+	return merged;
+};
+
+/**
+ * @param {RuntimeSpec | true} a first
+ * @param {RuntimeSpec | true} b second
+ * @param {RuntimeSpec} runtime full runtime
+ * @returns {RuntimeSpec | true} result
+ */
+exports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {
+	if (a === true || b === true) return true;
+	const merged = mergeRuntime(a, b);
+	if (merged === undefined) return undefined;
+	if (typeof merged === "string") {
+		if (typeof runtime === "string" && merged === runtime) return true;
+		return merged;
+	}
+	if (typeof runtime === "string" || runtime === undefined) return merged;
+	if (merged.size === runtime.size) return true;
+	return merged;
+};
+
 /**
  * @param {RuntimeSpec} a first (may be modified)
  * @param {RuntimeSpec} b second
@@ -280,7 +332,12 @@ exports.intersectRuntime = (a, b) => {
 	}
 };
 
-exports.subtractRuntime = (a, b) => {
+/**
+ * @param {RuntimeSpec} a first
+ * @param {RuntimeSpec} b second
+ * @returns {RuntimeSpec} result
+ */
+const subtractRuntime = (a, b) => {
 	if (a === undefined) {
 		return undefined;
 	} else if (b === undefined) {
@@ -316,6 +373,21 @@ exports.subtractRuntime = (a, b) => {
 		}
 	}
 };
+exports.subtractRuntime = subtractRuntime;
+
+/**
+ * @param {RuntimeCondition} a first
+ * @param {RuntimeCondition} b second
+ * @param {RuntimeSpec} runtime runtime
+ * @returns {RuntimeCondition} result
+ */
+exports.subtractRuntimeCondition = (a, b, runtime) => {
+	if (b === true) return false;
+	if (b === false) return a;
+	if (a === false) return false;
+	const result = subtractRuntime(a === true ? runtime : a, b);
+	return result === undefined ? false : result;
+};
 
 /**
  * @param {RuntimeSpec} runtime runtime
diff --git a/test/configCases/graph/issue-11863/a.js b/test/configCases/graph/issue-11863/a.js
new file mode 100644
index 000000000..f30aa0925
--- /dev/null
+++ b/test/configCases/graph/issue-11863/a.js
@@ -0,0 +1,5 @@
+import { value1 } from "./shared";
+
+it("should have to correct value", () => {
+	expect(value1).toBe(42);
+});
diff --git a/test/configCases/graph/issue-11863/b.js b/test/configCases/graph/issue-11863/b.js
new file mode 100644
index 000000000..04a21d85e
--- /dev/null
+++ b/test/configCases/graph/issue-11863/b.js
@@ -0,0 +1,5 @@
+import { value2 } from "./shared";
+
+it("should have to correct value", () => {
+	expect(value2).toBe(42);
+});
diff --git a/test/configCases/graph/issue-11863/c.js b/test/configCases/graph/issue-11863/c.js
new file mode 100644
index 000000000..90cfa268b
--- /dev/null
+++ b/test/configCases/graph/issue-11863/c.js
@@ -0,0 +1,5 @@
+import { value3 } from "./shared";
+
+it("should have to correct value", () => {
+	expect(value3).toBe(42);
+});
diff --git a/test/configCases/graph/issue-11863/shared-x.js b/test/configCases/graph/issue-11863/shared-x.js
new file mode 100644
index 000000000..4bc1fc563
--- /dev/null
+++ b/test/configCases/graph/issue-11863/shared-x.js
@@ -0,0 +1,3 @@
+export const value1 = 42;
+export const value2 = 42;
+export const value3 = 42;
diff --git a/test/configCases/graph/issue-11863/shared-y.js b/test/configCases/graph/issue-11863/shared-y.js
new file mode 100644
index 000000000..5390ec68a
--- /dev/null
+++ b/test/configCases/graph/issue-11863/shared-y.js
@@ -0,0 +1 @@
+export { value3 } from "./shared-x";
diff --git a/test/configCases/graph/issue-11863/shared-z.js b/test/configCases/graph/issue-11863/shared-z.js
new file mode 100644
index 000000000..ed9f0588a
--- /dev/null
+++ b/test/configCases/graph/issue-11863/shared-z.js
@@ -0,0 +1 @@
+export { value1 } from "./shared-x";
diff --git a/test/configCases/graph/issue-11863/shared.js b/test/configCases/graph/issue-11863/shared.js
new file mode 100644
index 000000000..3a13d5523
--- /dev/null
+++ b/test/configCases/graph/issue-11863/shared.js
@@ -0,0 +1,3 @@
+export { value1 } from "./shared-z";
+export { value2 } from "./shared-x";
+export * from "./shared-y";
diff --git a/test/configCases/graph/issue-11863/test.config.js b/test/configCases/graph/issue-11863/test.config.js
new file mode 100644
index 000000000..572778729
--- /dev/null
+++ b/test/configCases/graph/issue-11863/test.config.js
@@ -0,0 +1,14 @@
+module.exports = {
+	findBundle: function (i, options) {
+		return [
+			"shared.js",
+			"a.js",
+			"b.js",
+			"c.js",
+			"ab.js",
+			"ac.js",
+			"bc.js",
+			"abc.js"
+		];
+	}
+};
diff --git a/test/configCases/graph/issue-11863/webpack.config.js b/test/configCases/graph/issue-11863/webpack.config.js
new file mode 100644
index 000000000..e0616bcaa
--- /dev/null
+++ b/test/configCases/graph/issue-11863/webpack.config.js
@@ -0,0 +1,40 @@
+/** @type {import("../../../../").Configuration} */
+module.exports = {
+	entry: {
+		a: "./a",
+		b: "./b",
+		c: "./c",
+		ab: ["./a", "./b"],
+		ac: ["./a", "./c"],
+		bc: ["./b", "./c"],
+		abc: ["./a", "./b", "./c"]
+	},
+	target: "web",
+	output: {
+		filename: "[name].js",
+		library: { type: "commonjs-module" }
+	},
+	optimization: {
+		chunkIds: "named",
+		usedExports: true,
+		concatenateModules: true,
+		splitChunks: {
+			cacheGroups: {
+				forceMerge: {
+					test: /shared/,
+					enforce: true,
+					name: "shared",
+					chunks: "all"
+				}
+			}
+		}
+	},
+	module: {
+		rules: [
+			{
+				test: /shared/
+				// sideEffects: false
+			}
+		]
+	}
+};
diff --git a/types.d.ts b/types.d.ts
index 0402cc37f..bfb97c888 100644
--- a/types.d.ts
+++ b/types.d.ts
@@ -1727,7 +1727,9 @@ declare interface ConcatenationBailoutReasonContext {
 }
 declare class ConcatenationScope {
 	constructor(
-		modulesWithInfo: (ConcatenatedModuleInfo | ExternalModuleInfo)[],
+		modulesMap:
+			| (ConcatenatedModuleInfo | ExternalModuleInfo)[]
+			| Map<Module, ConcatenatedModuleInfo | ExternalModuleInfo>,
 		currentModule: ConcatenatedModuleInfo
 	);
 	isModuleInScope(module: Module): boolean;
