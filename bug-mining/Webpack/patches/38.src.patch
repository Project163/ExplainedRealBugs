diff --git a/lib/SourceMapDevToolPlugin.js b/lib/SourceMapDevToolPlugin.js
index da08af248..138e7e922 100644
--- a/lib/SourceMapDevToolPlugin.js
+++ b/lib/SourceMapDevToolPlugin.js
@@ -5,6 +5,7 @@
 
 "use strict";
 
+const asyncLib = require("neo-async");
 const validateOptions = require("schema-utils");
 const { ConcatSource, RawSource } = require("webpack-sources");
 const ModuleFilenameHelpers = require("./ModuleFilenameHelpers");
@@ -33,9 +34,6 @@ const schema = require("../schemas/plugins/SourceMapDevToolPlugin.json");
  * @property {SourceMap} sourceMap
  */
 
-/** @type {WeakMap<Source, { file: string, assets: Record<string, Source>}>} */
-const assetsCache = new WeakMap();
-
 /**
  * Creating {@link SourceMapTask} for given file
  * @param {string} file current compiled file
@@ -168,233 +166,279 @@ class SourceMapDevToolPlugin {
 					reportProgress(0.0);
 					/** @type {SourceMapTask[]} */
 					const tasks = [];
-					files.forEach((file, idx) => {
-						const asset = compilation.getAsset(file).source;
-						const cache = assetsCache.get(asset);
-						/**
-						 * If presented in cache, reassigns assets. Cache assets already have source maps.
-						 */
-						if (cache && cache.file === file) {
-							for (const cachedFile in cache.assets) {
-								if (cachedFile === file) {
-									compilation.updateAsset(cachedFile, cache.assets[cachedFile]);
-								} else {
-									compilation.emitAsset(cachedFile, cache.assets[cachedFile], {
-										development: true
-									});
-								}
-								/**
-								 * Add file to chunk, if not presented there
-								 */
-								if (cachedFile !== file) {
-									const chunk = fileToChunk.get(file);
-									if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);
-								}
-							}
-							return;
-						}
+					let fileIndex = 0;
+
+					asyncLib.each(
+						files,
+						(file, done) => {
+							const asset = compilation.getAsset(file).source;
+							const cacheIdent = `${compilation.compilerPath}/SourceMapDevToolPlugin/${file}`;
+							const cacheETag = createHash("md4");
+							asset.updateHash(cacheETag);
 
-						reportProgress(
-							(0.5 * idx) / files.length,
-							file,
-							"generate SourceMap"
-						);
-						/** @type {SourceMapTask | undefined} */
-						const task = getTaskForFile(file, asset, options, compilation);
-
-						if (task) {
-							const modules = task.modules;
-
-							for (let idx = 0; idx < modules.length; idx++) {
-								const module = modules[idx];
-								if (!moduleToSourceNameMapping.get(module)) {
-									moduleToSourceNameMapping.set(
-										module,
-										ModuleFilenameHelpers.createFilename(
-											module,
-											{
-												moduleFilenameTemplate: moduleFilenameTemplate,
-												namespace: namespace
-											},
-											{
-												requestShortener,
-												chunkGraph
+							compilation.cache.get(
+								cacheIdent,
+								cacheETag.digest("hex").toString(),
+								(err, assets) => {
+									/**
+									 * If presented in cache, reassigns assets. Cache assets already have source maps.
+									 */
+									if (assets) {
+										for (const cachedFile in assets) {
+											if (cachedFile === file) {
+												compilation.updateAsset(cachedFile, assets[cachedFile]);
+											} else {
+												compilation.emitAsset(cachedFile, assets[cachedFile], {
+													development: true
+												});
 											}
-										)
-									);
-								}
-							}
+											/**
+											 * Add file to chunk, if not presented there
+											 */
+											if (cachedFile !== file) {
+												const chunk = fileToChunk.get(file);
+												if (chunk !== undefined)
+													chunk.auxiliaryFiles.add(cachedFile);
+											}
+										}
 
-							tasks.push(task);
-						}
-					});
+										done();
 
-					reportProgress(0.5, "resolve sources");
-					/** @type {Set<string>} */
-					const usedNamesSet = new Set(moduleToSourceNameMapping.values());
-					/** @type {Set<string>} */
-					const conflictDetectionSet = new Set();
+										return;
+									}
 
-					/**
-					 * all modules in defined order (longest identifier first)
-					 * @type {Array<string | Module>}
-					 */
-					const allModules = Array.from(moduleToSourceNameMapping.keys()).sort(
-						(a, b) => {
-							const ai = typeof a === "string" ? a : a.identifier();
-							const bi = typeof b === "string" ? b : b.identifier();
-							return ai.length - bi.length;
-						}
-					);
+									reportProgress(
+										(0.5 * fileIndex++) / files.length,
+										file,
+										"generate SourceMap"
+									);
+									/** @type {SourceMapTask | undefined} */
+									const task = getTaskForFile(
+										file,
+										asset,
+										options,
+										compilation
+									);
 
-					// find modules with conflicting source names
-					for (let idx = 0; idx < allModules.length; idx++) {
-						const module = allModules[idx];
-						let sourceName = moduleToSourceNameMapping.get(module);
-						let hasName = conflictDetectionSet.has(sourceName);
-						if (!hasName) {
-							conflictDetectionSet.add(sourceName);
-							continue;
-						}
+									if (task) {
+										const modules = task.modules;
 
-						// try the fallback name first
-						sourceName = ModuleFilenameHelpers.createFilename(
-							module,
-							{
-								moduleFilenameTemplate: fallbackModuleFilenameTemplate,
-								namespace: namespace
-							},
-							{
-								requestShortener,
-								chunkGraph
-							}
-						);
-						hasName = usedNamesSet.has(sourceName);
-						if (!hasName) {
-							moduleToSourceNameMapping.set(module, sourceName);
-							usedNamesSet.add(sourceName);
-							continue;
-						}
+										for (let idx = 0; idx < modules.length; idx++) {
+											const module = modules[idx];
+											if (!moduleToSourceNameMapping.get(module)) {
+												moduleToSourceNameMapping.set(
+													module,
+													ModuleFilenameHelpers.createFilename(
+														module,
+														{
+															moduleFilenameTemplate: moduleFilenameTemplate,
+															namespace: namespace
+														},
+														{
+															requestShortener,
+															chunkGraph
+														}
+													)
+												);
+											}
+										}
 
-						// elsewise just append stars until we have a valid name
-						while (hasName) {
-							sourceName += "*";
-							hasName = usedNamesSet.has(sourceName);
-						}
-						moduleToSourceNameMapping.set(module, sourceName);
-						usedNamesSet.add(sourceName);
-					}
-					tasks.forEach((task, index) => {
-						reportProgress(
-							0.5 + (0.5 * index) / tasks.length,
-							task.file,
-							"attach SourceMap"
-						);
-						const assets = Object.create(null);
-						const file = task.file;
-						const chunk = fileToChunk.get(file);
-						const asset = task.asset;
-						const sourceMap = task.sourceMap;
-						const source = task.source;
-						const modules = task.modules;
-						const moduleFilenames = modules.map(m =>
-							moduleToSourceNameMapping.get(m)
-						);
-						sourceMap.sources = moduleFilenames;
-						if (options.noSources) {
-							sourceMap.sourcesContent = undefined;
-						}
-						sourceMap.sourceRoot = options.sourceRoot || "";
-						sourceMap.file = file;
-						assetsCache.set(asset, { file, assets });
-						/** @type {string | false} */
-						let currentSourceMappingURLComment = sourceMappingURLComment;
-						if (
-							currentSourceMappingURLComment !== false &&
-							/\.css($|\?)/i.test(file)
-						) {
-							currentSourceMappingURLComment = currentSourceMappingURLComment.replace(
-								/^\n\/\/(.*)$/,
-								"\n/*$1*/"
-							);
-						}
-						const sourceMapString = JSON.stringify(sourceMap);
-						if (sourceMapFilename) {
-							let filename = file;
-							const pathParams = {
-								chunk,
-								filename: options.fileContext
-									? relative(
-											outputFs,
-											`/${options.fileContext}`,
-											`/${filename}`
-									  )
-									: filename,
-								contentHash: /** @type {string} */ (createHash("md4")
-									.update(sourceMapString)
-									.digest("hex"))
-							};
-							let sourceMapFile = compilation.getPath(
-								sourceMapFilename,
-								pathParams
+										tasks.push(task);
+									}
+
+									done();
+								}
 							);
-							const sourceMapUrl = options.publicPath
-								? options.publicPath + sourceMapFile
-								: relative(
-										outputFs,
-										dirname(outputFs, `/${file}`),
-										`/${sourceMapFile}`
-								  );
-							/**
-							 * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented
-							 */
-							if (currentSourceMappingURLComment !== false) {
-								const asset = new ConcatSource(
-									new RawSource(source),
-									compilation.getPath(
-										currentSourceMappingURLComment,
-										Object.assign({ url: sourceMapUrl }, pathParams)
-									)
-								);
-								assets[file] = asset;
-								compilation.updateAsset(file, asset);
-							}
+						},
+						() => {
+							reportProgress(0.5, "resolve sources");
+							/** @type {Set<string>} */
+							const usedNamesSet = new Set(moduleToSourceNameMapping.values());
+							/** @type {Set<string>} */
+							const conflictDetectionSet = new Set();
+
 							/**
-							 * Add source map file to compilation assets and chunk files
+							 * all modules in defined order (longest identifier first)
+							 * @type {Array<string | Module>}
 							 */
-							const asset = new RawSource(sourceMapString);
-							assets[sourceMapFile] = asset;
-							compilation.emitAsset(sourceMapFile, asset, {
-								development: true
+							const allModules = Array.from(
+								moduleToSourceNameMapping.keys()
+							).sort((a, b) => {
+								const ai = typeof a === "string" ? a : a.identifier();
+								const bi = typeof b === "string" ? b : b.identifier();
+								return ai.length - bi.length;
 							});
-							if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);
-						} else {
-							if (currentSourceMappingURLComment === false) {
-								throw new Error(
-									"SourceMapDevToolPlugin: append can't be false when no filename is provided"
+
+							// find modules with conflicting source names
+							for (let idx = 0; idx < allModules.length; idx++) {
+								const module = allModules[idx];
+								let sourceName = moduleToSourceNameMapping.get(module);
+								let hasName = conflictDetectionSet.has(sourceName);
+								if (!hasName) {
+									conflictDetectionSet.add(sourceName);
+									continue;
+								}
+
+								// try the fallback name first
+								sourceName = ModuleFilenameHelpers.createFilename(
+									module,
+									{
+										moduleFilenameTemplate: fallbackModuleFilenameTemplate,
+										namespace: namespace
+									},
+									{
+										requestShortener,
+										chunkGraph
+									}
 								);
+								hasName = usedNamesSet.has(sourceName);
+								if (!hasName) {
+									moduleToSourceNameMapping.set(module, sourceName);
+									usedNamesSet.add(sourceName);
+									continue;
+								}
+
+								// elsewise just append stars until we have a valid name
+								while (hasName) {
+									sourceName += "*";
+									hasName = usedNamesSet.has(sourceName);
+								}
+								moduleToSourceNameMapping.set(module, sourceName);
+								usedNamesSet.add(sourceName);
 							}
-							/**
-							 * Add source map as data url to asset
-							 */
-							const asset = new ConcatSource(
-								new RawSource(source),
-								currentSourceMappingURLComment
-									.replace(/\[map\]/g, () => sourceMapString)
-									.replace(
-										/\[url\]/g,
-										() =>
-											`data:application/json;charset=utf-8;base64,${Buffer.from(
-												sourceMapString,
-												"utf-8"
-											).toString("base64")}`
-									)
+
+							let taskIndex = 0;
+
+							asyncLib.each(
+								tasks,
+								(task, done) => {
+									reportProgress(
+										0.5 + (0.5 * taskIndex++) / tasks.length,
+										task.file,
+										"attach SourceMap"
+									);
+									const assets = Object.create(null);
+									const file = task.file;
+									const chunk = fileToChunk.get(file);
+									const asset = task.asset;
+									const sourceMap = task.sourceMap;
+									const source = task.source;
+									const modules = task.modules;
+									const moduleFilenames = modules.map(m =>
+										moduleToSourceNameMapping.get(m)
+									);
+									sourceMap.sources = moduleFilenames;
+									if (options.noSources) {
+										sourceMap.sourcesContent = undefined;
+									}
+									sourceMap.sourceRoot = options.sourceRoot || "";
+									sourceMap.file = file;
+
+									const cacheIdent = `${compilation.compilerPath}/SourceMapDevToolPlugin/${file}`;
+									const cacheETag = createHash("md4");
+									asset.updateHash(cacheETag);
+
+									compilation.cache.store(
+										cacheIdent,
+										cacheETag.digest("hex").toString(),
+										assets,
+										() => {
+											/** @type {string | false} */
+											let currentSourceMappingURLComment = sourceMappingURLComment;
+											if (
+												currentSourceMappingURLComment !== false &&
+												/\.css($|\?)/i.test(file)
+											) {
+												currentSourceMappingURLComment = currentSourceMappingURLComment.replace(
+													/^\n\/\/(.*)$/,
+													"\n/*$1*/"
+												);
+											}
+											const sourceMapString = JSON.stringify(sourceMap);
+											if (sourceMapFilename) {
+												let filename = file;
+												const pathParams = {
+													chunk,
+													filename: options.fileContext
+														? relative(
+																outputFs,
+																`/${options.fileContext}`,
+																`/${filename}`
+														  )
+														: filename,
+													contentHash: /** @type {string} */ (createHash("md4")
+														.update(sourceMapString)
+														.digest("hex"))
+												};
+												let sourceMapFile = compilation.getPath(
+													sourceMapFilename,
+													pathParams
+												);
+												const sourceMapUrl = options.publicPath
+													? options.publicPath + sourceMapFile
+													: relative(
+															outputFs,
+															dirname(outputFs, `/${file}`),
+															`/${sourceMapFile}`
+													  );
+												/**
+												 * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented
+												 */
+												if (currentSourceMappingURLComment !== false) {
+													const asset = new ConcatSource(
+														new RawSource(source),
+														compilation.getPath(
+															currentSourceMappingURLComment,
+															Object.assign({ url: sourceMapUrl }, pathParams)
+														)
+													);
+													assets[file] = asset;
+													compilation.updateAsset(file, asset);
+												}
+												/**
+												 * Add source map file to compilation assets and chunk files
+												 */
+												const asset = new RawSource(sourceMapString);
+												assets[sourceMapFile] = asset;
+												compilation.emitAsset(sourceMapFile, asset, {
+													development: true
+												});
+												if (chunk !== undefined)
+													chunk.auxiliaryFiles.add(sourceMapFile);
+											} else {
+												if (currentSourceMappingURLComment === false) {
+													throw new Error(
+														"SourceMapDevToolPlugin: append can't be false when no filename is provided"
+													);
+												}
+												/**
+												 * Add source map as data url to asset
+												 */
+												const asset = new ConcatSource(
+													new RawSource(source),
+													currentSourceMappingURLComment
+														.replace(/\[map\]/g, () => sourceMapString)
+														.replace(
+															/\[url\]/g,
+															() =>
+																`data:application/json;charset=utf-8;base64,${Buffer.from(
+																	sourceMapString,
+																	"utf-8"
+																).toString("base64")}`
+														)
+												);
+												assets[file] = asset;
+												compilation.updateAsset(file, asset);
+											}
+
+											done();
+										}
+									);
+								},
+								() => reportProgress(1.0)
 							);
-							assets[file] = asset;
-							compilation.updateAsset(file, asset);
 						}
-					});
-					reportProgress(1.0);
+					);
 				}
 			);
 		});
