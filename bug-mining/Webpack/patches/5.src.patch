diff --git a/lib/EntryModuleNotFoundError.js b/lib/EntryModuleNotFoundError.js
deleted file mode 100644
index 128397f2c..000000000
--- a/lib/EntryModuleNotFoundError.js
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
-	MIT License http://www.opensource.org/licenses/mit-license.php
-	Author Tobias Koppers @sokra
-*/
-
-"use strict";
-
-const WebpackError = require("./WebpackError");
-
-class EntryModuleNotFoundError extends WebpackError {
-	constructor(err) {
-		super("Entry module not found: " + err);
-
-		this.name = "EntryModuleNotFoundError";
-		this.details = err.details;
-		this.error = err;
-
-		Error.captureStackTrace(this, this.constructor);
-	}
-}
-
-module.exports = EntryModuleNotFoundError;
diff --git a/test/Compiler.test.js b/test/Compiler.test.js
index fc762b72e..e130c8249 100644
--- a/test/Compiler.test.js
+++ b/test/Compiler.test.js
@@ -4,6 +4,7 @@
 const path = require("path");
 
 const webpack = require("../");
+const Stats = require("../lib/Stats");
 const WebpackOptionsDefaulter = require("../lib/WebpackOptionsDefaulter");
 const MemoryFs = require("memory-fs");
 
@@ -258,6 +259,73 @@ describe("Compiler", () => {
 			done();
 		});
 	});
+	it("should bubble up errors when wrapped in a promise and bail is true", async done => {
+		try {
+			const createCompiler = options => {
+				return new Promise((resolve, reject) => {
+					const c = webpack(options);
+					c.run((err, stats) => {
+						if (err) {
+							reject(err);
+						}
+						if (stats !== undefined && "errors" in stats) {
+							reject(err);
+						} else {
+							resolve(stats);
+						}
+					});
+				});
+			};
+			const compiler = await createCompiler({
+				context: __dirname,
+				mode: "production",
+				entry: "./missing-file",
+				output: {
+					path: "/",
+					filename: "bundle.js"
+				},
+				bail: true
+			});
+			done();
+			return compiler;
+		} catch (err) {
+			expect(err.toString()).toMatch(
+				"ModuleNotFoundError: Module not found: Error: Can't resolve './missing-file'"
+			);
+			done();
+		}
+	});
+	it("should not emit compilation errors in async (watch)", async done => {
+		try {
+			const createCompiler = options => {
+				return new Promise((resolve, reject) => {
+					const c = webpack(options);
+					c.outputFileSystem = new MemoryFs();
+					const watching = c.watch({}, (err, stats) => {
+						watching.close(() => {
+							if (err) return reject(err);
+							resolve(stats);
+						});
+					});
+				});
+			};
+			const compiler = await createCompiler({
+				context: __dirname,
+				mode: "production",
+				entry: "./missing-file",
+				output: {
+					path: "/",
+					filename: "bundle.js"
+				},
+				watch: true
+			});
+			expect(compiler).toBeInstanceOf(Stats);
+			done();
+		} catch (err) {
+			done(err);
+		}
+	});
+
 	it("should not emit on errors (watch)", done => {
 		const compiler = webpack({
 			context: __dirname,
diff --git a/test/fixtures/missing-file.js b/test/fixtures/missing-file.js
new file mode 100644
index 000000000..83cca9344
--- /dev/null
+++ b/test/fixtures/missing-file.js
@@ -0,0 +1,5 @@
+module.exports = function b() {
+	/* eslint-disable node/no-missing-require */
+	require("./nonexistentfile");
+	return "This is a missing file";
+};
