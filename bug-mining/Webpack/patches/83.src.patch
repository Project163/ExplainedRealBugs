diff --git a/lib/ChunkGraph.js b/lib/ChunkGraph.js
index f272b8a00..484948953 100644
--- a/lib/ChunkGraph.js
+++ b/lib/ChunkGraph.js
@@ -200,6 +200,8 @@ class ChunkGraph {
 		this._chunks = new WeakMap();
 		/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */
 		this._blockChunkGroups = new WeakMap();
+		/** @private @type {Map<string, string | number>} */
+		this._runtimeIds = new Map();
 		/** @type {ModuleGraph} */
 		this.moduleGraph = moduleGraph;
 
@@ -1144,6 +1146,23 @@ class ChunkGraph {
 		cgm.id = id;
 	}
 
+	/**
+	 * @param {string} runtime runtime
+	 * @returns {string | number} the id of the runtime
+	 */
+	getRuntimeId(runtime) {
+		return this._runtimeIds.get(runtime);
+	}
+
+	/**
+	 * @param {string} runtime runtime
+	 * @param {string | number} id the id of the runtime
+	 * @returns {void}
+	 */
+	setRuntimeId(runtime, id) {
+		this._runtimeIds.set(runtime, id);
+	}
+
 	/**
 	 * @param {Module} module the module
 	 * @param {RuntimeSpec} runtime the runtime
diff --git a/lib/Compilation.js b/lib/Compilation.js
index 5cec26fab..02c00a89e 100644
--- a/lib/Compilation.js
+++ b/lib/Compilation.js
@@ -1939,6 +1939,8 @@ Or do you want to use the entrypoints '${name}' and '${runtime}' independently o
 					this.hooks.optimizeChunkIds.call(this.chunks);
 					this.hooks.afterOptimizeChunkIds.call(this.chunks);
 
+					this.assignRuntimeIds();
+
 					this.sortItemsWithChunkIds();
 
 					if (shouldRecord) {
@@ -2556,6 +2558,21 @@ Or do you want to use the entrypoints '${name}' and '${runtime}' independently o
 		}
 	}
 
+	assignRuntimeIds() {
+		const { chunkGraph } = this;
+		const processEntrypoint = ep => {
+			const runtime = ep.options.runtime || ep.name;
+			const chunk = ep.getRuntimeChunk();
+			chunkGraph.setRuntimeId(runtime, chunk.id);
+		};
+		for (const ep of this.entrypoints.values()) {
+			processEntrypoint(ep);
+		}
+		for (const ep of this.asyncEntrypoints) {
+			processEntrypoint(ep);
+		}
+	}
+
 	sortItemsWithChunkIds() {
 		for (const chunkGroup of this.chunkGroups) {
 			chunkGroup.sortItems();
diff --git a/lib/RuntimeGlobals.js b/lib/RuntimeGlobals.js
index b55f8e55f..465c0b57c 100644
--- a/lib/RuntimeGlobals.js
+++ b/lib/RuntimeGlobals.js
@@ -173,6 +173,11 @@ exports.loadScript = "__webpack_require__.l";
  */
 exports.chunkName = "__webpack_require__.cn";
 
+/**
+ * the runtime id of the current runtime
+ */
+exports.runtimeId = "__webpack_require__.j";
+
 /**
  * the filename of the script part of the chunk
  */
diff --git a/lib/RuntimePlugin.js b/lib/RuntimePlugin.js
index 12712fb13..e3f7e85af 100644
--- a/lib/RuntimePlugin.js
+++ b/lib/RuntimePlugin.js
@@ -21,6 +21,7 @@ const HasOwnPropertyRuntimeModule = require("./runtime/HasOwnPropertyRuntimeModu
 const LoadScriptRuntimeModule = require("./runtime/LoadScriptRuntimeModule");
 const MakeNamespaceObjectRuntimeModule = require("./runtime/MakeNamespaceObjectRuntimeModule");
 const PublicPathRuntimeModule = require("./runtime/PublicPathRuntimeModule");
+const RuntimeIdRuntimeModule = require("./runtime/RuntimeIdRuntimeModule");
 const SystemContextRuntimeModule = require("./runtime/SystemContextRuntimeModule");
 const ShareRuntimeModule = require("./sharing/ShareRuntimeModule");
 const StringXor = require("./util/StringXor");
@@ -31,6 +32,7 @@ const StringXor = require("./util/StringXor");
 
 const GLOBALS_ON_REQUIRE = [
 	RuntimeGlobals.chunkName,
+	RuntimeGlobals.runtimeId,
 	RuntimeGlobals.compatGetDefaultExport,
 	RuntimeGlobals.createFakeNamespaceObject,
 	RuntimeGlobals.definePropertyGetters,
@@ -156,6 +158,12 @@ class RuntimePlugin {
 					);
 					return true;
 				});
+			compilation.hooks.runtimeRequirementInTree
+				.for(RuntimeGlobals.runtimeId)
+				.tap("RuntimePlugin", chunk => {
+					compilation.addRuntimeModule(chunk, new RuntimeIdRuntimeModule());
+					return true;
+				});
 			compilation.hooks.runtimeRequirementInTree
 				.for(RuntimeGlobals.publicPath)
 				.tap("RuntimePlugin", (chunk, set) => {
diff --git a/lib/RuntimeTemplate.js b/lib/RuntimeTemplate.js
index 3051efc75..a6cef7568 100644
--- a/lib/RuntimeTemplate.js
+++ b/lib/RuntimeTemplate.js
@@ -9,7 +9,9 @@ const InitFragment = require("./InitFragment");
 const RuntimeGlobals = require("./RuntimeGlobals");
 const Template = require("./Template");
 const { equals } = require("./util/ArrayHelpers");
+const compileBooleanMatcher = require("./util/compileBooleanMatcher");
 const propertyAccess = require("./util/propertyAccess");
+const { forEachRuntime, subtractRuntime } = require("./util/runtime");
 
 /** @typedef {import("../declarations/WebpackOptions").OutputNormalized} OutputOptions */
 /** @typedef {import("./AsyncDependenciesBlock")} AsyncDependenciesBlock */
@@ -562,6 +564,37 @@ class RuntimeTemplate {
 		return `${promise || "Promise.resolve()"}${appending}`;
 	}
 
+	/**
+	 * @param {Object} options options object
+	 * @param {ChunkGraph} options.chunkGraph the chunk graph
+	 * @param {RuntimeSpec=} options.runtime runtime for which this code will be generated
+	 * @param {RuntimeSpec | boolean=} options.runtimeCondition only execute the statement in some runtimes
+	 * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
+	 * @returns {string} expression
+	 */
+	runtimeConditionExpression({
+		chunkGraph,
+		runtimeCondition,
+		runtime,
+		runtimeRequirements
+	}) {
+		if (runtimeCondition === undefined) return "true";
+		if (typeof runtimeCondition === "boolean") return `${runtimeCondition}`;
+		const positiveRuntimeIds = new Set();
+		forEachRuntime(runtimeCondition, runtime =>
+			positiveRuntimeIds.add(chunkGraph.getRuntimeId(runtime))
+		);
+		const negativeRuntimeIds = new Set();
+		forEachRuntime(subtractRuntime(runtime, runtimeCondition), runtime =>
+			negativeRuntimeIds.add(chunkGraph.getRuntimeId(runtime))
+		);
+		runtimeRequirements.add(RuntimeGlobals.runtimeId);
+		return compileBooleanMatcher.fromLists(
+			Array.from(positiveRuntimeIds),
+			Array.from(negativeRuntimeIds)
+		)(RuntimeGlobals.runtimeId);
+	}
+
 	/**
 	 *
 	 * @param {Object} options options object
@@ -572,6 +605,8 @@ class RuntimeTemplate {
 	 * @param {string} options.importVar name of the import variable
 	 * @param {Module} options.originModule module in which the statement is emitted
 	 * @param {boolean=} options.weak true, if this is a weak dependency
+	 * @param {RuntimeSpec=} options.runtime runtime for which this code will be generated
+	 * @param {RuntimeSpec | boolean=} options.runtimeCondition only execute the statement in some runtimes
 	 * @param {Set<string>} options.runtimeRequirements if set, will be filled with runtime requirements
 	 * @returns {[string, string]} the import statement and the compat statement
 	 */
@@ -583,13 +618,23 @@ class RuntimeTemplate {
 		importVar,
 		originModule,
 		weak,
+		runtime,
+		runtimeCondition,
 		runtimeRequirements
 	}) {
+		const conditional = this.runtimeConditionExpression({
+			chunkGraph,
+			runtime,
+			runtimeCondition,
+			runtimeRequirements
+		});
 		if (!module) {
 			return [
-				this.missingModuleStatement({
+				`${
+					conditional !== "true" ? `if (${conditional}) ` : ""
+				}${this.missingModuleStatement({
 					request
-				}),
+				})}`,
 				""
 			];
 		}
@@ -598,12 +643,14 @@ class RuntimeTemplate {
 				// only weak referenced modules don't get an id
 				// we can always emit an error emitting code here
 				return [
-					this.weakError({
+					`${
+						conditional !== "true" ? `if (${conditional}) ` : ""
+					}${this.weakError({
 						module,
 						chunkGraph,
 						request,
 						type: "statements"
-					}),
+					})}`,
 					""
 				];
 			}
@@ -627,13 +674,17 @@ class RuntimeTemplate {
 			originModule.buildMeta.strictHarmonyModule
 		);
 		runtimeRequirements.add(RuntimeGlobals.require);
-		const importContent = `/* harmony import */ ${optDeclaration}${importVar} = __webpack_require__(${moduleId});\n`;
+		const importContent = `/* harmony import */ ${optDeclaration}${importVar} = ${
+			conditional !== "true" ? `${conditional} && ` : ""
+		}__webpack_require__(${moduleId});\n`;
 
 		if (exportsType === "dynamic") {
 			runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);
 			return [
 				importContent,
-				`/* harmony import */ ${optDeclaration}${importVar}_default = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${importVar});\n`
+				`/* harmony import */ ${optDeclaration}${importVar}_default = ${
+					conditional !== "true" ? `${conditional} && ` : ""
+				}/*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${importVar});\n`
 			];
 		}
 		return [importContent, ""];
diff --git a/lib/dependencies/HarmonyImportDependency.js b/lib/dependencies/HarmonyImportDependency.js
index 65e6be04f..52e7021cc 100644
--- a/lib/dependencies/HarmonyImportDependency.js
+++ b/lib/dependencies/HarmonyImportDependency.js
@@ -10,6 +10,7 @@ const HarmonyLinkingError = require("../HarmonyLinkingError");
 const InitFragment = require("../InitFragment");
 const Template = require("../Template");
 const AwaitDependenciesInitFragment = require("../async-modules/AwaitDependenciesInitFragment");
+const { filterRuntime } = require("../util/runtime");
 const ModuleDependency = require("./ModuleDependency");
 
 /** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
@@ -76,8 +77,16 @@ class HarmonyImportDependency extends ModuleDependency {
 	 */
 	getImportStatement(
 		update,
-		{ runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements }
+		{
+			runtimeTemplate,
+			module,
+			moduleGraph,
+			chunkGraph,
+			runtime,
+			runtimeRequirements
+		}
 	) {
+		const connection = moduleGraph.getConnection(this);
 		return runtimeTemplate.importStatement({
 			update,
 			module: moduleGraph.getModule(this),
@@ -85,6 +94,10 @@ class HarmonyImportDependency extends ModuleDependency {
 			importVar: this.getImportVar(moduleGraph),
 			request: this.request,
 			originModule: module,
+			runtime,
+			runtimeCondition: connection
+				? filterRuntime(runtime, r => connection.isTargetActive(r))
+				: undefined,
 			runtimeRequirements
 		});
 	}
diff --git a/lib/dependencies/PureExpressionDependency.js b/lib/dependencies/PureExpressionDependency.js
index 48e927569..b105d39b6 100644
--- a/lib/dependencies/PureExpressionDependency.js
+++ b/lib/dependencies/PureExpressionDependency.js
@@ -7,6 +7,7 @@
 
 const { UsageState } = require("../ExportsInfo");
 const makeSerializable = require("../util/makeSerializable");
+const { filterRuntime } = require("../util/runtime");
 const NullDependency = require("./NullDependency");
 
 /** @typedef {import("webpack-sources").ReplaceSource} ReplaceSource */
@@ -74,22 +75,41 @@ PureExpressionDependency.Template = class PureExpressionDependencyTemplate exten
 	 * @param {DependencyTemplateContext} templateContext the context object
 	 * @returns {void}
 	 */
-	apply(dependency, source, { moduleGraph, runtime }) {
+	apply(
+		dependency,
+		source,
+		{ chunkGraph, moduleGraph, runtime, runtimeTemplate, runtimeRequirements }
+	) {
 		const dep = /** @type {PureExpressionDependency} */ (dependency);
 
-		if (dep.usedByExports !== false) {
+		let condition = "null";
+
+		const usedByExports = dep.usedByExports;
+		if (usedByExports !== false) {
 			const selfModule = moduleGraph.getParentModule(dep);
 			const exportsInfo = moduleGraph.getExportsInfo(selfModule);
-			for (const exportName of dep.usedByExports) {
-				if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) {
-					return;
+			const runtimeCondition = filterRuntime(runtime, runtime => {
+				for (const exportName of usedByExports) {
+					if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) {
+						return true;
+					}
 				}
+				return false;
+			});
+			if (runtimeCondition === true) return;
+			if (runtimeCondition !== false) {
+				condition = runtimeTemplate.runtimeConditionExpression({
+					chunkGraph,
+					runtime,
+					runtimeCondition,
+					runtimeRequirements
+				});
 			}
 		}
 
 		source.insert(
 			dep.range[0],
-			"(/* unused pure expression or super */ null && ("
+			`(/* unused pure expression or super */ ${condition} && (`
 		);
 		source.insert(dep.range[1], "))");
 	}
diff --git a/lib/runtime/RuntimeIdRuntimeModule.js b/lib/runtime/RuntimeIdRuntimeModule.js
new file mode 100644
index 000000000..7e046eb6e
--- /dev/null
+++ b/lib/runtime/RuntimeIdRuntimeModule.js
@@ -0,0 +1,29 @@
+/*
+	MIT License http://www.opensource.org/licenses/mit-license.php
+*/
+
+"use strict";
+
+const RuntimeGlobals = require("../RuntimeGlobals");
+const RuntimeModule = require("../RuntimeModule");
+
+class RuntimeIdRuntimeModule extends RuntimeModule {
+	constructor() {
+		super("runtimeId");
+	}
+
+	/**
+	 * @returns {string} runtime code
+	 */
+	generate() {
+		const { chunk, compilation } = this;
+		const { chunkGraph } = compilation;
+		const runtime = chunk.runtime;
+		if (typeof runtime !== "string")
+			throw new Error("RuntimeIdRuntimeModule must be in a single runtime");
+		const id = chunkGraph.getRuntimeId(runtime);
+		return `${RuntimeGlobals.runtimeId} = ${JSON.stringify(id)};`;
+	}
+}
+
+module.exports = RuntimeIdRuntimeModule;
diff --git a/lib/util/compileBooleanMatcher.js b/lib/util/compileBooleanMatcher.js
index 14f1a2ca9..411760948 100644
--- a/lib/util/compileBooleanMatcher.js
+++ b/lib/util/compileBooleanMatcher.js
@@ -25,6 +25,15 @@ const compileBooleanMatcher = map => {
 	const negativeItems = Object.keys(map).filter(i => !map[i]);
 	if (positiveItems.length === 0) return false;
 	if (negativeItems.length === 0) return true;
+	return compileBooleanMatcherFromLists(positiveItems, negativeItems);
+};
+
+/**
+ * @param {string[]} positiveItems positive items
+ * @param {string[]} negativeItems negative items
+ * @returns {function(string): string} a template function to determine the value at runtime
+ */
+const compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {
 	if (positiveItems.length === 1)
 		return value => `${toSimpleString(positiveItems[0])} == ${value}`;
 	if (negativeItems.length === 1)
@@ -188,5 +197,6 @@ const itemsToRegexp = itemsArr => {
 	return `(${conditional.join("|")})`;
 };
 
+compileBooleanMatcher.fromLists = compileBooleanMatcherFromLists;
+compileBooleanMatcher.itemsToRegexp = itemsToRegexp;
 module.exports = compileBooleanMatcher;
-module.exports.itemsToRegexp = itemsToRegexp;
diff --git a/lib/util/runtime.js b/lib/util/runtime.js
index 321aec4b4..8f662f57b 100644
--- a/lib/util/runtime.js
+++ b/lib/util/runtime.js
@@ -280,6 +280,68 @@ exports.intersectRuntime = (a, b) => {
 	}
 };
 
+exports.subtractRuntime = (a, b) => {
+	if (a === undefined) {
+		return undefined;
+	} else if (b === undefined) {
+		return a;
+	} else if (a === b) {
+		return undefined;
+	} else if (typeof a === "string") {
+		if (typeof b === "string") {
+			return undefined;
+		} else if (b.has(a)) {
+			return undefined;
+		} else {
+			return a;
+		}
+	} else {
+		if (typeof b === "string") {
+			if (!a.has(b)) return a;
+			if (a.size === 2) {
+				for (const item of a) {
+					if (item !== b) return item;
+				}
+			}
+			const set = new SortableSet(a);
+			set.delete(b);
+		} else {
+			const set = new SortableSet();
+			for (const item of a) {
+				if (!b.has(item)) set.add(item);
+			}
+			if (set.size === 0) return undefined;
+			if (set.size === 1) for (const item of set) return item;
+			return set;
+		}
+	}
+};
+
+/**
+ * @param {RuntimeSpec} runtime runtime
+ * @param {function(RuntimeSpec): boolean} filter filter function
+ * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active
+ */
+exports.filterRuntime = (runtime, filter) => {
+	if (runtime === undefined) return filter(undefined);
+	if (typeof runtime === "string") return filter(runtime);
+	let some = false;
+	let every = true;
+	let result = undefined;
+	for (const r of runtime) {
+		const v = filter(r);
+		if (v) {
+			some = true;
+			result = mergeRuntimeOwned(result, r);
+		} else {
+			every = false;
+		}
+	}
+	if (!some) return false;
+	if (every) return true;
+	return result;
+};
+
 /**
  * @template T
  */
diff --git a/types.d.ts b/types.d.ts
index cf29c6535..b05ec10a3 100644
--- a/types.d.ts
+++ b/types.d.ts
@@ -784,6 +784,8 @@ declare class ChunkGraph {
 	disconnectChunkGroup(chunkGroup: ChunkGroup): void;
 	getModuleId(module: Module): string | number;
 	setModuleId(module: Module, id: string | number): void;
+	getRuntimeId(runtime: string): string | number;
+	setRuntimeId(runtime: string, id: string | number): void;
 	hasModuleHashes(
 		module: Module,
 		runtime: string | SortableSet<string>
@@ -1450,6 +1452,7 @@ declare class Compilation {
 	): void;
 	patchChunksAfterReasonRemoval(module: Module, chunk: Chunk): void;
 	removeChunkFromDependencies(block: DependenciesBlock, chunk: Chunk): void;
+	assignRuntimeIds(): void;
 	sortItemsWithChunkIds(): void;
 	summarizeDependencies(): void;
 	createModuleHashes(): void;
@@ -8234,6 +8237,24 @@ declare abstract class RuntimeTemplate {
 		 */
 		runtimeRequirements: Set<string>;
 	}): string;
+	runtimeConditionExpression(__0: {
+		/**
+		 * the chunk graph
+		 */
+		chunkGraph: ChunkGraph;
+		/**
+		 * runtime for which this code will be generated
+		 */
+		runtime?: string | SortableSet<string>;
+		/**
+		 * only execute the statement in some runtimes
+		 */
+		runtimeCondition?: string | boolean | SortableSet<string>;
+		/**
+		 * if set, will be filled with runtime requirements
+		 */
+		runtimeRequirements: Set<string>;
+	}): string;
 	importStatement(__0: {
 		/**
 		 * whether a new variable should be created or the existing one updated
@@ -8263,6 +8284,14 @@ declare abstract class RuntimeTemplate {
 		 * true, if this is a weak dependency
 		 */
 		weak?: boolean;
+		/**
+		 * runtime for which this code will be generated
+		 */
+		runtime?: string | SortableSet<string>;
+		/**
+		 * only execute the statement in some runtimes
+		 */
+		runtimeCondition?: string | boolean | SortableSet<string>;
 		/**
 		 * if set, will be filled with runtime requirements
 		 */
@@ -10112,6 +10141,7 @@ declare namespace exports {
 		export let scriptNonce: string;
 		export let loadScript: string;
 		export let chunkName: string;
+		export let runtimeId: string;
 		export let getChunkScriptFilename: string;
 		export let getChunkUpdateScriptFilename: string;
 		export let startup: string;
