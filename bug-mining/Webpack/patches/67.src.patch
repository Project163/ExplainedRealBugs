diff --git a/lib/buildChunkGraph.js b/lib/buildChunkGraph.js
index 96fe3522a..3f79ebe15 100644
--- a/lib/buildChunkGraph.js
+++ b/lib/buildChunkGraph.js
@@ -47,8 +47,8 @@ const { connectChunkGroupParentAndChild } = require("./GraphHelpers");
  */
 
 /**
- * @typedef {Object} ChunkGroupDep
- * @property {AsyncDependenciesBlock} block referencing block
+ * @typedef {Object} BlockChunkGroupConnection
+ * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group
  * @property {ChunkGroup} chunkGroup referenced chunk group
  */
 
@@ -136,7 +136,7 @@ const extractBlockModulesMap = compilation => {
  * @param {Compilation} compilation the compilation
  * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules
  * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules
- * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkGroupDependencies dependencies for chunk groups
+ * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks
  * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks
  * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here
  */
@@ -145,7 +145,7 @@ const visitModules = (
 	compilation,
 	inputEntrypointsAndModules,
 	chunkGroupInfoMap,
-	chunkGroupDependencies,
+	blockConnections,
 	blocksWithNestedBlocks,
 	allCreatedChunkGroups
 ) => {
@@ -387,6 +387,7 @@ const visitModules = (
 					c.addOptions(b.groupOptions);
 					c.addOrigin(module, b.loc, b.request);
 				}
+				blockConnections.set(b, []);
 			}
 			blockChunkGroups.set(b, cgi);
 		} else if (entryOptions) {
@@ -396,12 +397,10 @@ const visitModules = (
 		}
 
 		if (c !== undefined) {
-			// 2. We store the Block + Chunk Group mapping as dependency
-			// for the chunk group which is set in processQueue
-			let deps = chunkGroupDependencies.get(chunkGroup);
-			if (!deps) chunkGroupDependencies.set(chunkGroup, (deps = []));
-			deps.push({
-				block: b,
+			// 2. We store the connection for the block
+			// to connect it later if needed
+			blockConnections.get(b).push({
+				originChunkGroupInfo: chunkGroupInfo,
 				chunkGroup: c
 			});
 
@@ -1063,20 +1062,17 @@ const visitModules = (
  *
  * @param {Compilation} compilation the compilation
  * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks
- * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkGroupDependencies dependencies for chunk groups
+ * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks
  * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules
  */
 const connectChunkGroups = (
 	compilation,
 	blocksWithNestedBlocks,
-	chunkGroupDependencies,
+	blockConnections,
 	chunkGroupInfoMap
 ) => {
 	const { chunkGraph } = compilation;
 
-	/** @type {ModuleSetPlus} */
-	let resultingAvailableModules;
-
 	/**
 	 * Helper function to check if all modules of a chunk are available
 	 *
@@ -1095,46 +1091,38 @@ const connectChunkGroups = (
 	};
 
 	// For each edge in the basic chunk graph
-	/**
-	 * @param {ChunkGroupDep} dep the dependency used for filtering
-	 * @returns {boolean} used to filter "edges" (aka Dependencies) that were pointing
-	 * to modules that are already available. Also filters circular dependencies in the chunks graph
-	 */
-	const filterFn = dep => {
-		const depChunkGroup = dep.chunkGroup;
-		// TODO is this needed?
-		if (blocksWithNestedBlocks.has(dep.block)) return true;
-		if (areModulesAvailable(depChunkGroup, resultingAvailableModules)) {
-			return false; // break all modules are already available
+	for (const [block, connections] of blockConnections) {
+		// 1. Check if connection is needed
+		// When none of the dependencies need to be connected
+		// we can skip all of them
+		// It's not possible to filter each item so it doesn't create inconsistent
+		// connections and modules can only create one version
+		// TODO maybe decide this per runtime
+		if (
+			// TODO is this needed?
+			!blocksWithNestedBlocks.has(block) &&
+			connections.every(({ chunkGroup, originChunkGroupInfo }) =>
+				areModulesAvailable(
+					chunkGroup,
+					originChunkGroupInfo.resultingAvailableModules
+				)
+			)
+		) {
+			continue;
 		}
-		return true;
-	};
-
-	// For all deps, check if chunk groups need to be connected
-	for (const [chunkGroup, deps] of chunkGroupDependencies) {
-		if (deps.length === 0) continue;
-
-		// 1. Get info from chunk group info map
-		const info = chunkGroupInfoMap.get(chunkGroup);
-		resultingAvailableModules = info.resultingAvailableModules;
 
 		// 2. Foreach edge
-		for (let i = 0; i < deps.length; i++) {
-			const dep = deps[i];
+		for (let i = 0; i < connections.length; i++) {
+			const { chunkGroup, originChunkGroupInfo } = connections[i];
 
-			// Filter inline, rather than creating a new array from `.filter()`
-			// TODO check if inlining filterFn makes sense here
-			if (!filterFn(dep)) {
-				continue;
-			}
-			const depChunkGroup = dep.chunkGroup;
-			const depBlock = dep.block;
-
-			// 5. Connect block with chunk
-			chunkGraph.connectBlockAndChunkGroup(depBlock, depChunkGroup);
+			// 3. Connect block with chunk
+			chunkGraph.connectBlockAndChunkGroup(block, chunkGroup);
 
-			// 6. Connect chunk with parent
-			connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);
+			// 4. Connect chunk with parent
+			connectChunkGroupParentAndChild(
+				originChunkGroupInfo.chunkGroup,
+				chunkGroup
+			);
 		}
 	}
 };
@@ -1170,8 +1158,8 @@ const buildChunkGraph = (compilation, inputEntrypointsAndModules) => {
 
 	// SHARED STATE
 
-	/** @type {Map<ChunkGroup, ChunkGroupDep[]>} */
-	const chunkGroupDependencies = new Map();
+	/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */
+	const blockConnections = new Map();
 
 	/** @type {Set<ChunkGroup>} */
 	const allCreatedChunkGroups = new Set();
@@ -1190,7 +1178,7 @@ const buildChunkGraph = (compilation, inputEntrypointsAndModules) => {
 		compilation,
 		inputEntrypointsAndModules,
 		chunkGroupInfoMap,
-		chunkGroupDependencies,
+		blockConnections,
 		blocksWithNestedBlocks,
 		allCreatedChunkGroups
 	);
@@ -1202,7 +1190,7 @@ const buildChunkGraph = (compilation, inputEntrypointsAndModules) => {
 	connectChunkGroups(
 		compilation,
 		blocksWithNestedBlocks,
-		chunkGroupDependencies,
+		blockConnections,
 		chunkGroupInfoMap
 	);
 	logger.timeEnd("connectChunkGroups");
diff --git a/test/__snapshots__/StatsTestCases.test.js.snap b/test/__snapshots__/StatsTestCases.test.js.snap
index cb602e1d9..74b9551a2 100644
--- a/test/__snapshots__/StatsTestCases.test.js.snap
+++ b/test/__snapshots__/StatsTestCases.test.js.snap
@@ -1446,7 +1446,7 @@ chunk {284} (runtime: main) chunk.js (chunk) 2 bytes <{374}> <{753}> [rendered]
   > [10] ./index.js 9:1-10:12
   ./modules/c.js [115] 1 bytes {284} {753} [built] [code generated]
   ./modules/d.js [928] 1 bytes {284} {374} [built] [code generated]
-chunk {288} (runtime: main) cir2 from cir1.js (cir2 from cir1) 82 bytes <{592}> [rendered]
+chunk {288} (runtime: main) cir2 from cir1.js (cir2 from cir1) 82 bytes <{592}> >{592}< [rendered]
   > [655] ./circular1.js 1:0-79
   ./circular2.js [193] 81 bytes {288} {289} [built] [code generated]
   ./modules/e.js [798] 1 bytes {288} [built] [code generated]
@@ -1458,7 +1458,7 @@ chunk {374} (runtime: main) abd.js (abd) 3 bytes <{179}> >{284}< [rendered]
   ./modules/a.js [839] 1 bytes {90} {374} [built] [code generated]
   ./modules/b.js [836] 1 bytes {90} {374} [built] [code generated]
   ./modules/d.js [928] 1 bytes {284} {374} [built] [code generated]
-chunk {592} (runtime: main) cir1.js (cir1) 81 bytes <{179}> <{289}> >{288}< [rendered]
+chunk {592} (runtime: main) cir1.js (cir1) 81 bytes <{179}> <{288}> <{289}> >{288}< [rendered]
   > [10] ./index.js 13:0-54
   > [193] ./circular2.js 1:0-79
   ./circular1.js [655] 81 bytes {592} [built] [code generated]
diff --git a/test/configCases/graph/conditional-ensure/a.js b/test/configCases/graph/conditional-ensure/a.js
new file mode 100644
index 000000000..1ea9fcfdc
--- /dev/null
+++ b/test/configCases/graph/conditional-ensure/a.js
@@ -0,0 +1,7 @@
+import c1 from "./c1";
+
+it("should allow to import an conditionally unneeded chunk", async () => {
+	const c2 = await c1();
+	const c1_ = await c2.default();
+	expect(c1_.value).toBe(1);
+});
diff --git a/test/configCases/graph/conditional-ensure/b.js b/test/configCases/graph/conditional-ensure/b.js
new file mode 100644
index 000000000..32f013323
--- /dev/null
+++ b/test/configCases/graph/conditional-ensure/b.js
@@ -0,0 +1,7 @@
+import c2 from "./c2";
+
+it("should allow to import an conditionally unneeded chunk", async () => {
+	const c1 = await c2();
+	const c2_ = await c1.default();
+	expect(c2_.value).toBe(2);
+});
diff --git a/test/configCases/graph/conditional-ensure/c1.js b/test/configCases/graph/conditional-ensure/c1.js
new file mode 100644
index 000000000..bfd7d369c
--- /dev/null
+++ b/test/configCases/graph/conditional-ensure/c1.js
@@ -0,0 +1,2 @@
+export default () => import("./c2");
+export const value = 1;
diff --git a/test/configCases/graph/conditional-ensure/c2.js b/test/configCases/graph/conditional-ensure/c2.js
new file mode 100644
index 000000000..d04edb2a3
--- /dev/null
+++ b/test/configCases/graph/conditional-ensure/c2.js
@@ -0,0 +1,2 @@
+export default () => import("./c1");
+export const value = 2;
diff --git a/test/configCases/graph/conditional-ensure/webpack.config.js b/test/configCases/graph/conditional-ensure/webpack.config.js
new file mode 100644
index 000000000..c4cca6107
--- /dev/null
+++ b/test/configCases/graph/conditional-ensure/webpack.config.js
@@ -0,0 +1,15 @@
+/** @type {import("../../../../").Configuration} */
+module.exports = {
+	entry: {
+		bundle0: "./a",
+		bundle1: "./b"
+	},
+	optimization: {
+		flagIncludedChunks: false,
+		chunkIds: "named"
+	},
+	output: {
+		filename: "[name].js",
+		chunkFilename: "[id].[chunkhash].js"
+	}
+};
