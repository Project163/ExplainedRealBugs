diff --git a/lib/Compiler.js b/lib/Compiler.js
index 9d818f967..51e7546f4 100644
--- a/lib/Compiler.js
+++ b/lib/Compiler.js
@@ -97,6 +97,20 @@ const sortObject = (obj, keys) => {
 	return o;
 };
 
+/**
+ * @param {string} filename filename
+ * @param {string | string[] | undefined} hashes list of hashes
+ * @returns {boolean} true, if the filename contains any hash
+ */
+const includesHash = (filename, hashes) => {
+	if (!hashes) return false;
+	if (Array.isArray(hashes)) {
+		return hashes.some(hash => filename.includes(hash));
+	} else {
+		return filename.includes(hashes);
+	}
+};
+
 class Compiler {
 	/**
 	 * @param {string} context the compilation path
@@ -522,9 +536,19 @@ class Compiler {
 				15,
 				({ name: file, source, info }, callback) => {
 					let targetFile = file;
+					let immutable = info.immutable;
 					const queryStringIdx = targetFile.indexOf("?");
 					if (queryStringIdx >= 0) {
 						targetFile = targetFile.substr(0, queryStringIdx);
+						// We may remove the hash, which is in the query string
+						// So we recheck if the file is immutable
+						// This doesn't cover all cases, but immutable is only a performance optimization anyway
+						immutable =
+							immutable &&
+							(includesHash(targetFile, info.contenthash) ||
+								includesHash(targetFile, info.chunkhash) ||
+								includesHash(targetFile, info.modulehash) ||
+								includesHash(targetFile, info.fullhash));
 					}
 
 					const writeOut = err => {
@@ -639,7 +663,7 @@ ${other}`);
 
 						const processExistingFile = stats => {
 							// skip emitting if it's already there and an immutable file
-							if (info.immutable) {
+							if (immutable) {
 								updateWithReplacementSource(stats.size);
 								return alreadyWritten();
 							}
@@ -693,7 +717,7 @@ ${other}`);
 								return callback();
 							}
 
-							if (!info.immutable) {
+							if (!immutable) {
 								// We wrote to this file before which has very likely a different content
 								// skip comparing and assume content is different for performance
 								// This case happens often during watch mode.
diff --git a/test/watchCases/cache/immutable/0/index.js b/test/watchCases/cache/immutable/0/index.js
new file mode 100644
index 000000000..cfb9f9412
--- /dev/null
+++ b/test/watchCases/cache/immutable/0/index.js
@@ -0,0 +1,3 @@
+it("should update the output file", () => {
+	expect(WATCH_STEP).toBe("0");
+});
diff --git a/test/watchCases/cache/immutable/1/index.js b/test/watchCases/cache/immutable/1/index.js
new file mode 100644
index 000000000..5c8a656fd
--- /dev/null
+++ b/test/watchCases/cache/immutable/1/index.js
@@ -0,0 +1,3 @@
+it("should update the output file", () => {
+	expect(WATCH_STEP).toBe("1");
+});
diff --git a/test/watchCases/cache/immutable/webpack.config.js b/test/watchCases/cache/immutable/webpack.config.js
new file mode 100644
index 000000000..0925d384b
--- /dev/null
+++ b/test/watchCases/cache/immutable/webpack.config.js
@@ -0,0 +1,10 @@
+/** @type {import("../../../../").Configuration} */
+module.exports = {
+	mode: "production",
+	cache: {
+		type: "memory"
+	},
+	output: {
+		filename: "bundle.js?[contenthash]"
+	}
+};
