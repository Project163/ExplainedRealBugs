diff --git a/lib/Compilation.js b/lib/Compilation.js
index 58ada3d59..c8db5b912 100644
--- a/lib/Compilation.js
+++ b/lib/Compilation.js
@@ -43,6 +43,7 @@ const RuntimeTemplate = require("./RuntimeTemplate");
 const Stats = require("./Stats");
 const WebpackError = require("./WebpackError");
 const buildChunkGraph = require("./buildChunkGraph");
+const BuildCycleError = require("./errors/BuildCycleError");
 const { Logger, LogType } = require("./logging/Logger");
 const StatsFactory = require("./stats/StatsFactory");
 const StatsPrinter = require("./stats/StatsPrinter");
@@ -581,6 +582,14 @@ class Compilation {
 			processor: this._processModuleDependencies.bind(this)
 		});
 
+		/**
+		 * Modules in value are building during the build of Module in key.
+		 * Means value blocking key from finishing.
+		 * Needed to detect build cycles.
+		 * @type {WeakMap<Module, Set<Module>>}
+		 */
+		this.creatingModuleDuringBuild = new WeakMap();
+
 		/** @type {Map<string, EntryDependency[]>} */
 		this.entryDependencies = new Map();
 		/** @type {Map<string, Entrypoint>} */
@@ -1088,6 +1097,7 @@ class Compilation {
 	 * @property {Dependency[]} dependencies
 	 * @property {Module | null} originModule
 	 * @property {string=} context
+	 * @property {boolean=} recursive recurse into dependencies of the created module
 	 */
 
 	/**
@@ -1096,7 +1106,7 @@ class Compilation {
 	 * @returns {void}
 	 */
 	handleModuleCreation(
-		{ factory, dependencies, originModule, context },
+		{ factory, dependencies, originModule, context, recursive = true },
 		callback
 	) {
 		const moduleGraph = this.moduleGraph;
@@ -1153,7 +1163,46 @@ class Compilation {
 						}
 					}
 
+					// Check for cycles when build is trigger inside another build
+					let creatingModuleDuringBuildSet = undefined;
+					if (!recursive && this.buildQueue.isProcessing(originModule)) {
+						// Track build dependency
+						creatingModuleDuringBuildSet = this.creatingModuleDuringBuild.get(
+							originModule
+						);
+						if (creatingModuleDuringBuildSet === undefined) {
+							creatingModuleDuringBuildSet = new Set();
+							this.creatingModuleDuringBuild.set(
+								originModule,
+								creatingModuleDuringBuildSet
+							);
+						}
+						creatingModuleDuringBuildSet.add(originModule);
+
+						// When building is blocked by another module
+						// search for a cycle, cancel the cycle by throwing
+						// an error (otherwise this would deadlock)
+						const blockReasons = this.creatingModuleDuringBuild.get(module);
+						if (blockReasons !== undefined) {
+							const set = new Set(blockReasons);
+							for (const item of set) {
+								const blockReasons = this.creatingModuleDuringBuild.get(item);
+								if (blockReasons !== undefined) {
+									for (const m of blockReasons) {
+										if (m === module) {
+											return callback(new BuildCycleError(module));
+										}
+										set.add(m);
+									}
+								}
+							}
+						}
+					}
+
 					this.buildModule(module, err => {
+						if (creatingModuleDuringBuildSet !== undefined) {
+							creatingModuleDuringBuildSet.delete(module);
+						}
 						if (err) {
 							if (!err.module) {
 								err.module = module;
@@ -1163,6 +1212,11 @@ class Compilation {
 							return callback(err);
 						}
 
+						if (!recursive) {
+							callback(null, module);
+							return;
+						}
+
 						// This avoids deadlocks for circular dependencies
 						if (this.processDependenciesQueue.isProcessing(module)) {
 							return callback();
diff --git a/lib/dependencies/LoaderPlugin.js b/lib/dependencies/LoaderPlugin.js
index 36f51e726..af8157c2c 100644
--- a/lib/dependencies/LoaderPlugin.js
+++ b/lib/dependencies/LoaderPlugin.js
@@ -61,7 +61,8 @@ class LoaderPlugin {
 								factory,
 								dependencies: [dep],
 								originModule: loaderContext._module,
-								context: loaderContext.context
+								context: loaderContext.context,
+								recursive: false
 							},
 							err => {
 								compilation.buildQueue.decreaseParallelism();
diff --git a/lib/errors/BuildCycleError.js b/lib/errors/BuildCycleError.js
new file mode 100644
index 000000000..20203e5fc
--- /dev/null
+++ b/lib/errors/BuildCycleError.js
@@ -0,0 +1,28 @@
+/*
+	MIT License http://www.opensource.org/licenses/mit-license.php
+	Author Tobias Koppers @sokra
+*/
+
+"use strict";
+
+const WebpackError = require("../WebpackError");
+
+/** @typedef {import("../Module")} Module */
+
+class BuildCycleError extends WebpackError {
+	/**
+	 * Creates an instance of ModuleDependencyError.
+	 * @param {Module} module the module starting the cycle
+	 */
+	constructor(module) {
+		super(
+			"There is a circular build dependency, which makes it impossible to create this module"
+		);
+
+		this.name = "BuildCycleError";
+		this.module = module;
+		Error.captureStackTrace(this, this.constructor);
+	}
+}
+
+module.exports = BuildCycleError;
diff --git a/test/cases/errors/load-module-cycle/1/a.json b/test/cases/errors/load-module-cycle/1/a.json
new file mode 100644
index 000000000..9a389c969
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/1/a.json
@@ -0,0 +1 @@
+"./a.json"
diff --git a/test/cases/errors/load-module-cycle/2/a.json b/test/cases/errors/load-module-cycle/2/a.json
new file mode 100644
index 000000000..75e02a30f
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/2/a.json
@@ -0,0 +1 @@
+"./b.json"
diff --git a/test/cases/errors/load-module-cycle/2/b.json b/test/cases/errors/load-module-cycle/2/b.json
new file mode 100644
index 000000000..9a389c969
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/2/b.json
@@ -0,0 +1 @@
+"./a.json"
diff --git a/test/cases/errors/load-module-cycle/3/a.json b/test/cases/errors/load-module-cycle/3/a.json
new file mode 100644
index 000000000..75e02a30f
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/3/a.json
@@ -0,0 +1 @@
+"./b.json"
diff --git a/test/cases/errors/load-module-cycle/3/b.json b/test/cases/errors/load-module-cycle/3/b.json
new file mode 100644
index 000000000..5a2d1989f
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/3/b.json
@@ -0,0 +1 @@
+"./c.json"
diff --git a/test/cases/errors/load-module-cycle/3/c.json b/test/cases/errors/load-module-cycle/3/c.json
new file mode 100644
index 000000000..9a389c969
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/3/c.json
@@ -0,0 +1 @@
+"./a.json"
diff --git a/test/cases/errors/load-module-cycle/index.js b/test/cases/errors/load-module-cycle/index.js
new file mode 100644
index 000000000..e7b74a9e7
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/index.js
@@ -0,0 +1,15 @@
+it("should error loadModule when a cycle with 2 modules is requested", () => {
+	expect(require("./loader!./2/a")).toMatch(
+		/^source: err: There is a circular build dependency/
+	);
+});
+it("should error loadModule when a cycle with 3 modules is requested", () => {
+	expect(require("./loader!./3/a")).toMatch(
+		/^source: source: err: There is a circular build dependency/
+	);
+});
+it("should error loadModule when requesting itself", () => {
+	expect(require("./loader!./1/a")).toMatch(
+		/^err: There is a circular build dependency/
+	);
+});
diff --git a/test/cases/errors/load-module-cycle/loader.js b/test/cases/errors/load-module-cycle/loader.js
new file mode 100644
index 000000000..19a8c699b
--- /dev/null
+++ b/test/cases/errors/load-module-cycle/loader.js
@@ -0,0 +1,11 @@
+exports.default = function(source) {
+	const ref = JSON.parse(source);
+	const callback = this.async();
+	this.loadModule("../loader!" + ref, (err, source, sourceMap, module) => {
+		if (err) {
+			callback(null, JSON.stringify(`err: ${err && err.message}`));
+		} else {
+			callback(null, JSON.stringify(`source: ${JSON.parse(source)}`));
+		}
+	});
+};
