diff --git a/lib/dependencies/ImportMetaPlugin.js b/lib/dependencies/ImportMetaPlugin.js
index ccc2f3775..99f826dcc 100644
--- a/lib/dependencies/ImportMetaPlugin.js
+++ b/lib/dependencies/ImportMetaPlugin.js
@@ -56,26 +56,27 @@ class ImportMetaPlugin {
 							"ImportMetaPlugin",
 							toConstantDependency(parser, JSON.stringify("object"))
 						);
-					parser.hooks.metaProperty.tap(
-						"ImportMetaPlugin",
-						toConstantDependency(parser, "Object()")
-					);
-					parser.hooks.metaProperty.tap("ImportMetaPlugin", metaProperty => {
-						const CriticalDependencyWarning = getCriticalDependencyWarning();
-						parser.state.module.addWarning(
-							new ModuleDependencyWarning(
-								parser.state.module,
-								new CriticalDependencyWarning(
-									"Accessing import.meta directly is unsupported (only property access is supported)"
-								),
-								metaProperty.loc
-							)
-						);
-						const dep = new ConstDependency("Object()", metaProperty.range);
-						dep.loc = metaProperty.loc;
-						parser.state.module.addPresentationalDependency(dep);
-						return true;
-					});
+					parser.hooks.metaProperty
+						.for("import.meta")
+						.tap("ImportMetaPlugin", toConstantDependency(parser, "Object()"));
+					parser.hooks.metaProperty
+						.for("import.meta")
+						.tap("ImportMetaPlugin", metaProperty => {
+							const CriticalDependencyWarning = getCriticalDependencyWarning();
+							parser.state.module.addWarning(
+								new ModuleDependencyWarning(
+									parser.state.module,
+									new CriticalDependencyWarning(
+										"Accessing import.meta directly is unsupported (only property access is supported)"
+									),
+									metaProperty.loc
+								)
+							);
+							const dep = new ConstDependency("Object()", metaProperty.range);
+							dep.loc = metaProperty.loc;
+							parser.state.module.addPresentationalDependency(dep);
+							return true;
+						});
 					parser.hooks.evaluateTypeof
 						.for("import.meta")
 						.tap("ImportMetaPlugin", evaluateToString("object"));
diff --git a/lib/javascript/JavascriptParser.js b/lib/javascript/JavascriptParser.js
index 02fd90490..6a7619e8e 100644
--- a/lib/javascript/JavascriptParser.js
+++ b/lib/javascript/JavascriptParser.js
@@ -112,7 +112,7 @@ const getRootName = expression => {
 		case "ThisExpression":
 			return "this";
 		case "MetaProperty":
-			return "import.meta";
+			return `${expression.meta.name}.${expression.property.name}`;
 		default:
 			return undefined;
 	}
@@ -267,8 +267,8 @@ class JavascriptParser extends Parser {
 			optionalChaining: new SyncBailHook(["optionalChaining"]),
 			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
 			new: new HookMap(() => new SyncBailHook(["expression"])),
-			/** @type {SyncBailHook<[MetaPropertyNode], boolean | void>} */
-			metaProperty: new SyncBailHook(["metaProperty"]),
+			/** @type {HookMap<SyncBailHook<[MetaPropertyNode], boolean | void>>} */
+			metaProperty: new HookMap(() => new SyncBailHook(["metaProperty"])),
 			/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */
 			expression: new HookMap(() => new SyncBailHook(["expression"])),
 			/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */
@@ -963,7 +963,7 @@ class JavascriptParser extends Parser {
 
 			return this.callHooksForName(
 				this.hooks.evaluateIdentifier,
-				"import.meta",
+				getRootName(expr),
 				metaProperty
 			);
 		});
@@ -2740,7 +2740,7 @@ class JavascriptParser extends Parser {
 	 * @param {MetaPropertyNode} metaProperty meta property
 	 */
 	walkMetaProperty(metaProperty) {
-		this.hooks.metaProperty.call(metaProperty);
+		this.hooks.metaProperty.for(getRootName(metaProperty)).call(metaProperty);
 	}
 
 	callHooksForExpression(hookMap, expr, ...args) {
diff --git a/test/cases/parsing/meta-property/index.js b/test/cases/parsing/meta-property/index.js
new file mode 100644
index 000000000..3ebbca53c
--- /dev/null
+++ b/test/cases/parsing/meta-property/index.js
@@ -0,0 +1,19 @@
+class A {
+	constructor() {
+		if (new.target === B) {
+			this.val = 2;
+		} else {
+			this.val = 1;
+		}
+	}
+}
+
+class B extends A {}
+
+it("should respect meta property name", () => {
+	const b = new B();
+	const a = new A();
+
+	expect(b.val).toBe(2);
+	expect(a.val).toBe(1);
+});
diff --git a/types.d.ts b/types.d.ts
index bb0d33c85..ba5353e17 100644
--- a/types.d.ts
+++ b/types.d.ts
@@ -3588,7 +3588,7 @@ declare abstract class JavascriptParser extends Parser {
 		>;
 		optionalChaining: SyncBailHook<[ChainExpression], boolean | void>;
 		new: HookMap<SyncBailHook<[Expression], boolean | void>>;
-		metaProperty: SyncBailHook<[MetaProperty], boolean | void>;
+		metaProperty: HookMap<SyncBailHook<[MetaProperty], boolean | void>>;
 		expression: HookMap<SyncBailHook<[Expression], boolean | void>>;
 		expressionMemberChain: HookMap<
 			SyncBailHook<[Expression, string[]], boolean | void>
