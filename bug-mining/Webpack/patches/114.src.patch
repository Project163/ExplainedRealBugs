diff --git a/lib/Compilation.js b/lib/Compilation.js
index 0d2165967..c1d407302 100644
--- a/lib/Compilation.js
+++ b/lib/Compilation.js
@@ -3135,54 +3135,106 @@ Or do you want to use the entrypoints '${name}' and '${runtime}' independently o
 		}
 
 		this.logger.time("hashing: sort chunks");
-		// clone needed as sort below is in place mutation
-		const chunks = Array.from(this.chunks);
-		/**
-		 * sort here will bring all "falsy" values to the beginning
-		 * this is needed as the "hasRuntime()" chunks are dependent on the
-		 * hashes of the non-runtime chunks.
+		/*
+		 * all non-runtime chunks need to be hashes first,
+		 * since runtime chunk might use their hashes.
+		 * runtime chunks need to be hashed in the correct order
+		 * since they may depend on each other (for async entrypoints).
+		 * So we put all non-runtime chunks first and hash them in any order.
+		 * And order runtime chunks according to referenced between each other.
+		 * Chunks need to be in deterministic order since we add hashes to full chunk
+		 * during these hashing.
 		 */
-		const runtimeChunks = [];
+		/** @type {Chunk[]} */
+		const unorderedRuntimeChunks = [];
+		/** @type {Chunk[]} */
 		const otherChunks = [];
-		for (const c of chunks) {
+		for (const c of this.chunks) {
 			if (c.hasRuntime()) {
-				runtimeChunks.push({
-					chunk: c,
-					referencedChunks: new Set(
-						Array.from(c.getAllReferencedAsyncEntrypoints()).map(
-							e => e.chunks[e.chunks.length - 1]
-						)
-					)
-				});
+				unorderedRuntimeChunks.push(c);
 			} else {
 				otherChunks.push(c);
 			}
 		}
+		unorderedRuntimeChunks.sort(byId);
 		otherChunks.sort(byId);
-		runtimeChunks.sort((a, b) => {
-			const aDependOnB = a.referencedChunks.has(b.chunk);
-			const bDependOnA = b.referencedChunks.has(a.chunk);
-			if (aDependOnB && bDependOnA) {
-				const err = new WebpackError(
-					`Circular dependency between chunks with runtime (${
-						a.chunk.name || a.chunk.id
-					} and ${b.chunk.name || b.chunk.id}).
-This prevents using hashes of each other and should be avoided.`
-				);
-				err.chunk = a.chunk;
-				this.warnings.push(err);
-				return byId(a.chunk, b.chunk);
+
+		/** @typedef {{ chunk: Chunk, referencedBy: RuntimeChunkInfo[], remaining: number }} RuntimeChunkInfo */
+		/** @type {Map<Chunk, RuntimeChunkInfo>} */
+		const runtimeChunksMap = new Map();
+		for (const chunk of unorderedRuntimeChunks) {
+			runtimeChunksMap.set(chunk, {
+				chunk,
+				referencedBy: [],
+				remaining: 0
+			});
+		}
+		let remaining = 0;
+		for (const info of runtimeChunksMap.values()) {
+			for (const other of new Set(
+				Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map(
+					e => e.chunks[e.chunks.length - 1]
+				)
+			)) {
+				const otherInfo = runtimeChunksMap.get(other);
+				otherInfo.referencedBy.push(info);
+				info.remaining++;
+				remaining++;
 			}
-			if (aDependOnB) return 1;
-			if (bDependOnA) return -1;
-			return byId(a.chunk, b.chunk);
-		});
+		}
+		/** @type {Chunk[]} */
+		const runtimeChunks = [];
+		for (const info of runtimeChunksMap.values()) {
+			if (info.remaining === 0) {
+				runtimeChunks.push(info.chunk);
+			}
+		}
+		// If there are any references between chunks
+		// make sure to follow these chains
+		if (remaining > 0) {
+			const readyChunks = [];
+			for (const chunk of runtimeChunks) {
+				const info = runtimeChunksMap.get(chunk);
+				for (const otherInfo of info.referencedBy) {
+					remaining--;
+					if (--otherInfo.remaining === 0) {
+						readyChunks.push(otherInfo.chunk);
+					}
+				}
+				if (readyChunks.length > 0) {
+					// This ensures deterministic ordering, since referencedBy is non-deterministic
+					readyChunks.sort(byId);
+					for (const c of readyChunks) runtimeChunks.push(c);
+					readyChunks.length = 0;
+				}
+			}
+		}
+		// If there are still remaining references we have cycles and want to create a warning
+		if (remaining > 0) {
+			let circularRuntimeChunkInfo = [];
+			for (const info of runtimeChunksMap.values()) {
+				if (info.remaining !== 0) {
+					circularRuntimeChunkInfo.push(info);
+				}
+			}
+			circularRuntimeChunkInfo.sort(compareSelect(i => i.chunk, byId));
+			const err = new WebpackError(`Circular dependency between chunks with runtime (${Array.from(
+				circularRuntimeChunkInfo,
+				c => c.chunk.name || c.chunk.id
+			).join(", ")})
+This prevents using hashes of each other and should be avoided.`);
+			err.chunk = circularRuntimeChunkInfo[0].chunk;
+			this.warnings.push(err);
+			for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
+		}
 		this.logger.timeEnd("hashing: sort chunks");
+
 		const fullHashChunks = new Set();
 		/** @type {{module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}[]} */
 		const codeGenerationJobs = [];
 		/** @type {Map<string, Map<Module, {module: Module, hash: string, runtime: RuntimeSpec, runtimes: RuntimeSpec[]}>>} */
 		const codeGenerationJobsMap = new Map();
+
 		const processChunk = chunk => {
 			// Last minute module hash generation for modules that depend on chunk hashes
 			this.logger.time("hashing: hash runtime modules");
@@ -3252,7 +3304,7 @@ This prevents using hashes of each other and should be avoided.`
 			this.logger.timeAggregate("hashing: hash chunks");
 		};
 		otherChunks.forEach(processChunk);
-		for (const { chunk } of runtimeChunks) processChunk(chunk);
+		for (const chunk of runtimeChunks) processChunk(chunk);
 
 		this.logger.timeAggregateEnd("hashing: hash runtime modules");
 		this.logger.timeAggregateEnd("hashing: hash chunks");
diff --git a/test/configCases/worker/node-worker/index.js b/test/configCases/worker/node-worker/index.js
index 3523798c7..334dd2a58 100644
--- a/test/configCases/worker/node-worker/index.js
+++ b/test/configCases/worker/node-worker/index.js
@@ -1,7 +1,9 @@
 import { Worker } from "worker_threads";
 
 it("should allow to create a WebWorker", async () => {
-	const worker = new Worker(new URL("./worker.js", import.meta.url));
+	const worker = new Worker(
+		new URL("./worker.js" + __resourceQuery, import.meta.url)
+	);
 	worker.postMessage("ok");
 	const result = await new Promise(resolve => {
 		worker.on("message", data => {
diff --git a/test/configCases/worker/node-worker/test.config.js b/test/configCases/worker/node-worker/test.config.js
index 65ddf7b1d..ec6a7527c 100644
--- a/test/configCases/worker/node-worker/test.config.js
+++ b/test/configCases/worker/node-worker/test.config.js
@@ -1,5 +1,5 @@
 module.exports = {
-	findBundle: function(i, options) {
-		return ["main.js"];
+	findBundle: function (i, options) {
+		return ["a.js", "b.js", "c.js", "d.js"];
 	}
 };
diff --git a/test/configCases/worker/node-worker/webpack.config.js b/test/configCases/worker/node-worker/webpack.config.js
index aaf5279b8..e3210fc01 100644
--- a/test/configCases/worker/node-worker/webpack.config.js
+++ b/test/configCases/worker/node-worker/webpack.config.js
@@ -1,5 +1,11 @@
 module.exports = {
+	entry: {
+		a: { import: "./index.js?a", filename: "[name].js" },
+		b: { import: "./index.js?b", filename: "[name].js" },
+		c: { import: "./index.js?c", filename: "[name].js" },
+		d: { import: "./index.js?d", filename: "[name].js" }
+	},
 	output: {
-		filename: "[name].js"
+		filename: "[name].[contenthash].js"
 	}
 };
