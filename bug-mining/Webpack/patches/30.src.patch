diff --git a/lib/ModuleParseError.js b/lib/ModuleParseError.js
index 32c7a69c1..fd90970f4 100644
--- a/lib/ModuleParseError.js
+++ b/lib/ModuleParseError.js
@@ -13,11 +13,20 @@ class ModuleParseError extends WebpackError {
 	 * @param {Module} module the errored module
 	 * @param {string} source source code
 	 * @param {Error&any} err the parse error
+	 * @param {string[]} loaders the loaders used
 	 */
-	constructor(module, source, err) {
+	constructor(module, source, err, loaders) {
 		let message = "Module parse failed: " + err.message;
 		let loc = undefined;
 		message += "\nYou may need an appropriate loader to handle this file type.";
+		if (loaders.length >= 1) {
+			message += `\nTried processing with these loaders:${loaders
+				.map(l => `\n * ${l}`)
+				.join("")}.`;
+		} else {
+			message +=
+				"\nNo Loaders configured to process this file. See https://webpack.js.org/concepts#loaders";
+		}
 		if (
 			err.loc &&
 			typeof err.loc === "object" &&
diff --git a/lib/NormalModule.js b/lib/NormalModule.js
index 3e9dc5555..c68913acf 100644
--- a/lib/NormalModule.js
+++ b/lib/NormalModule.js
@@ -83,7 +83,6 @@ class NormalModule extends Module {
 		this.matchResource = matchResource;
 		this.loaders = loaders;
 		if (resolveOptions !== undefined) this.resolveOptions = resolveOptions;
-
 		// Info from Build
 		this.error = null;
 		this._source = null;
@@ -347,7 +346,6 @@ class NormalModule extends Module {
 	markModuleAsErrored(error) {
 		// Restore build meta from successful build to keep importing state
 		this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);
-
 		this.error = error;
 		this.errors.push(this.error);
 		this._source = new RawSource(
@@ -423,7 +421,6 @@ class NormalModule extends Module {
 			fileDependencies: new Set(),
 			contextDependencies: new Set()
 		};
-
 		return this.doBuild(options, compilation, resolver, fs, err => {
 			this._cachedSources.clear();
 
@@ -442,9 +439,31 @@ class NormalModule extends Module {
 				return callback();
 			}
 
+			const getLoaders = options => {
+				const module =
+					options && options.constructor === Object ? options.module || {} : {};
+				const rules = module.rules || [];
+				if (!rules.length) {
+					return [];
+				}
+				let arr = [];
+				const getLoader = rule => rule.loader || rule.use || "";
+				rules.forEach(rule => {
+					if (Array.isArray(rule.use)) {
+						rule.use.forEach(r => {
+							arr.push(getLoader(r));
+						});
+					} else {
+						arr.push(getLoader(rule));
+					}
+				});
+				return arr;
+			};
+
 			const handleParseError = e => {
 				const source = this._source.source();
-				const error = new ModuleParseError(this, source, e);
+				const loaders = getLoaders(options);
+				const error = new ModuleParseError(this, source, e, loaders);
 				this.markModuleAsErrored(error);
 				this._initBuildHash(compilation);
 				return callback();
diff --git a/test/Errors.test.js b/test/Errors.test.js
index 8d5a8fbd1..69ef25055 100644
--- a/test/Errors.test.js
+++ b/test/Errors.test.js
@@ -393,4 +393,113 @@ describe("Errors", () => {
 			}
 		);
 	});
+
+	it("should show loader used if it is present when module parsing fails", done => {
+		const folder = path.join(__dirname, "/fixtures");
+		getErrors(
+			{
+				mode: "development",
+				entry: path.resolve(folder, "./abc.html"),
+				module: {
+					rules: [
+						{
+							test: /\.json$/,
+							use: [{ loader: "json-loader" }]
+						}
+					]
+				}
+			},
+			(errors, warnings) => {
+				const messages = errors[0].split("\n");
+				const loaderUsedMessage = messages.filter(message =>
+					message.includes("* json-loader.")
+				)[0];
+				expect(loaderUsedMessage).toMatch("* json-loader.");
+				done();
+			}
+		);
+	});
+
+	it("should show all loaders used if they are in config when module parsing fails", done => {
+		const folder = path.join(__dirname, "/fixtures");
+		getErrors(
+			{
+				mode: "development",
+				entry: path.resolve(folder, "./abc.html"),
+				module: {
+					rules: [
+						{
+							test: /\.json$/,
+							use: [{ loader: "json-loader" }, { loader: "coffee-loader" }]
+						}
+					]
+				}
+			},
+			(errors, warnings) => {
+				const messages = errors[0].split("\n");
+				const loaderUsedMessage = messages.filter(message => {
+					return (
+						message.includes(" * json-loader") ||
+						message.includes(" * coffee-loader.")
+					);
+				});
+				expect(loaderUsedMessage).toEqual([
+					" * json-loader",
+					" * coffee-loader."
+				]);
+				done();
+			}
+		);
+	});
+
+	it("should show all loaders used if use is a string", done => {
+		const folder = path.join(__dirname, "/fixtures");
+		getErrors(
+			{
+				mode: "development",
+				entry: path.resolve(folder, "./abc.html"),
+				module: {
+					rules: [
+						{ test: /\.json$/, use: "json-loader" },
+						{ test: /\.coffee$/, use: "coffee-loader" }
+					]
+				}
+			},
+			(errors, warnings) => {
+				const messages = errors[0].split("\n");
+				const loaderUsedMessage = messages.filter(message => {
+					return (
+						message.includes(" * json-loader") ||
+						message.includes(" * coffee-loader.")
+					);
+				});
+				expect(loaderUsedMessage).toEqual([
+					" * json-loader",
+					" * coffee-loader."
+				]);
+				done();
+			}
+		);
+	});
+
+	it("should show 'No Loaders present to process this file.' if loaders are not included in config when module parsing fails", done => {
+		const folder = path.join(__dirname, "/fixtures");
+		getErrors(
+			{
+				mode: "development",
+				entry: path.resolve(folder, "./abc.html"),
+				module: {}
+			},
+			(errors, warnings) => {
+				const messages = errors[0].split("\n");
+				const loaderUsedMessage = messages.filter(message =>
+					message.includes("No Loaders configured")
+				)[0];
+				expect(loaderUsedMessage).toMatch(
+					"No Loaders configured to process this file. See https://webpack.js.org/concepts#loaders"
+				);
+				done();
+			}
+		);
+	});
 });
diff --git a/test/__snapshots__/StatsTestCases.test.js.snap b/test/__snapshots__/StatsTestCases.test.js.snap
index 3b0138b5d..651e55607 100644
--- a/test/__snapshots__/StatsTestCases.test.js.snap
+++ b/test/__snapshots__/StatsTestCases.test.js.snap
@@ -1573,10 +1573,10 @@ chunk    {7} main.js (main) 523 bytes >{0}< >{1}< >{2}< >{5}< [entry] [rendered]
 `;
 
 exports[`StatsTestCases should print correct stats for parse-error 1`] = `
-"  Asset      Size  Chunks  Chunk Names
-main.js  4.01 KiB       0  main
+"  Asset     Size  Chunks  Chunk Names
+main.js  4.1 KiB       0  main
 Entrypoint main = main.js
-[0] ./b.js 169 bytes {0} [built] [failed] [1 error]
+[0] ./b.js 258 bytes {0} [built] [failed] [1 error]
 [1] ./index.js + 1 modules 35 bytes {0} [built]
     | ./index.js 15 bytes [built]
     | ./a.js 15 bytes [built]
@@ -1584,6 +1584,7 @@ Entrypoint main = main.js
 ERROR in ./b.js 6:7
 Module parse failed: Unexpected token (6:7)
 You may need an appropriate loader to handle this file type.
+No Loaders configured to process this file. See https://webpack.js.org/concepts#loaders
 | includes
 | a
 > parser )
diff --git a/test/fixtures/abc.html b/test/fixtures/abc.html
new file mode 100644
index 000000000..a86002af2
--- /dev/null
+++ b/test/fixtures/abc.html
@@ -0,0 +1,6 @@
+<!DOCTYPE html>
+  <html>
+    <body>
+      <h1>I love webpack :)</h1>
+    </body>
+  </html>
\ No newline at end of file
