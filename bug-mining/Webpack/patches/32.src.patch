diff --git a/lib/optimize/SplitChunksPlugin.js b/lib/optimize/SplitChunksPlugin.js
index 4fb5cb2b7..3502c23eb 100644
--- a/lib/optimize/SplitChunksPlugin.js
+++ b/lib/optimize/SplitChunksPlugin.js
@@ -899,13 +899,14 @@ module.exports = class SplitChunksPlugin {
 						/** @type {Chunk} */
 						let newChunk;
 						// When no chunk name, check if we can reuse a chunk instead of creating a new one
-						let isReused = false;
+						let isExistingChunk = false;
+						let isReusedWithAllModules = false;
 						if (chunkName) {
 							const chunkByName = compilation.namedChunks.get(chunkName);
 							if (chunkByName !== undefined) {
 								newChunk = chunkByName;
 								item.chunks.delete(newChunk);
-								isReused = true;
+								isExistingChunk = true;
 							}
 						} else if (item.cacheGroup.reuseExistingChunk) {
 							outer: for (const chunk of item.chunks) {
@@ -941,13 +942,14 @@ module.exports = class SplitChunksPlugin {
 							if (newChunk) {
 								item.chunks.delete(newChunk);
 								chunkName = undefined;
-								isReused = true;
+								isExistingChunk = true;
+								isReusedWithAllModules = true;
 							}
 						}
 
 						// Skip when no chunk selected
 						// TODO check if this check is really needed, shouldn't chunks always be non-empty?
-						if (item.chunks.size === 0 && !isReused) continue;
+						if (item.chunks.size === 0 && !isExistingChunk) continue;
 
 						// Check if maxRequests condition can be fulfilled
 						// TODO try to avoid creating a new array here
@@ -983,7 +985,7 @@ module.exports = class SplitChunksPlugin {
 						});
 
 						if (validChunks.length < usedChunks.length) {
-							if (isReused) validChunks.push(newChunk);
+							if (isExistingChunk) validChunks.push(newChunk);
 							if (validChunks.length >= item.cacheGroup.minChunks) {
 								for (const module of item.modules) {
 									addModuleToChunksInfoMap(
@@ -1016,7 +1018,7 @@ module.exports = class SplitChunksPlugin {
 						}
 
 						// Create the new chunk if not reusing one
-						if (!isReused) {
+						if (!isExistingChunk) {
 							newChunk = compilation.addChunk(chunkName);
 						}
 						// Walk through all chunks
@@ -1026,9 +1028,11 @@ module.exports = class SplitChunksPlugin {
 						}
 
 						// Add a note to the chunk
-						newChunk.chunkReason = isReused
-							? "reused as split chunk"
-							: "split chunk";
+						newChunk.chunkReason =
+							(newChunk.chunkReason ? newChunk.chunkReason + ", " : "") +
+							(isReusedWithAllModules
+								? "reused as split chunk"
+								: "split chunk");
 						if (item.cacheGroup.key) {
 							newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;
 						}
@@ -1048,7 +1052,7 @@ module.exports = class SplitChunksPlugin {
 						if (item.cacheGroup.idHint) {
 							newChunk.idNameHints.add(item.cacheGroup.idHint);
 						}
-						if (!isReused) {
+						if (!isReusedWithAllModules) {
 							// Add all modules to the new chunk
 							for (const module of item.modules) {
 								if (!module.chunkCondition(newChunk, compilation)) continue;
diff --git a/test/configCases/split-chunks/reuse-chunk-name/b.js b/test/configCases/split-chunks/reuse-chunk-name/b.js
new file mode 100644
index 000000000..fba3204fe
--- /dev/null
+++ b/test/configCases/split-chunks/reuse-chunk-name/b.js
@@ -0,0 +1 @@
+module.exports = "b";
\ No newline at end of file
diff --git a/test/configCases/split-chunks/reuse-chunk-name/c.js b/test/configCases/split-chunks/reuse-chunk-name/c.js
new file mode 100644
index 000000000..ebaf7584d
--- /dev/null
+++ b/test/configCases/split-chunks/reuse-chunk-name/c.js
@@ -0,0 +1 @@
+module.exports = "c";
\ No newline at end of file
diff --git a/test/configCases/split-chunks/reuse-chunk-name/index.js b/test/configCases/split-chunks/reuse-chunk-name/index.js
new file mode 100644
index 000000000..283f2a7ab
--- /dev/null
+++ b/test/configCases/split-chunks/reuse-chunk-name/index.js
@@ -0,0 +1,4 @@
+import "./b";
+import "./c";
+
+it("should compile fine", () => {});
diff --git a/test/configCases/split-chunks/reuse-chunk-name/test.config.js b/test/configCases/split-chunks/reuse-chunk-name/test.config.js
new file mode 100644
index 000000000..480f5e08d
--- /dev/null
+++ b/test/configCases/split-chunks/reuse-chunk-name/test.config.js
@@ -0,0 +1,5 @@
+module.exports = {
+	findBundle: function(i, options) {
+		return ["common.js", "main.js"];
+	}
+};
diff --git a/test/configCases/split-chunks/reuse-chunk-name/webpack.config.js b/test/configCases/split-chunks/reuse-chunk-name/webpack.config.js
new file mode 100644
index 000000000..773d3304c
--- /dev/null
+++ b/test/configCases/split-chunks/reuse-chunk-name/webpack.config.js
@@ -0,0 +1,23 @@
+module.exports = {
+	output: {
+		filename: "[name].js"
+	},
+	target: "web",
+	optimization: {
+		splitChunks: {
+			chunks: "all",
+			cacheGroups: {
+				b: {
+					test: /b\.js/,
+					name: "common",
+					enforce: true
+				},
+				c: {
+					test: /c\.js/,
+					name: "common",
+					enforce: true
+				}
+			}
+		}
+	}
+};
