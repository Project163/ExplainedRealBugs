diff --git a/lib/Parser.js b/lib/Parser.js
index 9d9cf2e5b..5d83eee37 100644
--- a/lib/Parser.js
+++ b/lib/Parser.js
@@ -1777,7 +1777,14 @@ class Parser extends Tapable {
 		const args = options.map(renameArgOrThis);
 		const wasTopLevel = this.scope.topLevelScope;
 		this.scope.topLevelScope = false;
-		this.inScope(params.filter((identifier, idx) => !args[idx]), () => {
+		const scopeParams = params.filter((identifier, idx) => !args[idx]);
+
+		// Add function name in scope for recursive calls
+		if (functionExpression.id) {
+			scopeParams.push(functionExpression.id.name);
+		}
+
+		this.inScope(scopeParams, () => {
 			if (renameThis) {
 				this.scope.renames.set("this", renameThis);
 			}
diff --git a/test/cases/parsing/issue-8874/index.js b/test/cases/parsing/issue-8874/index.js
new file mode 100644
index 000000000..c16961f9e
--- /dev/null
+++ b/test/cases/parsing/issue-8874/index.js
@@ -0,0 +1,5 @@
+import myFunction from './module';
+
+it('should execute IIFE twice', () => {
+    expect(myFunction()).toBe(2);
+});
diff --git a/test/cases/parsing/issue-8874/module.js b/test/cases/parsing/issue-8874/module.js
new file mode 100644
index 000000000..67eb731c3
--- /dev/null
+++ b/test/cases/parsing/issue-8874/module.js
@@ -0,0 +1,15 @@
+import someFunction from './someFunction';
+
+export default function myFunction() {
+    let iifeExecutionCount = 0;
+
+    (function someFunction (recurse) {
+        iifeExecutionCount++;
+
+        if (recurse) {
+            someFunction(false);
+        }
+    })(true);
+
+    return iifeExecutionCount;
+}
\ No newline at end of file
diff --git a/test/cases/parsing/issue-8874/someFunction.js b/test/cases/parsing/issue-8874/someFunction.js
new file mode 100644
index 000000000..36407c6dd
--- /dev/null
+++ b/test/cases/parsing/issue-8874/someFunction.js
@@ -0,0 +1,3 @@
+export default function someFunction () {
+    console.log('imported someFunction');
+}
