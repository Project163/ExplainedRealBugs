diff --git a/lib/Compilation.js b/lib/Compilation.js
index aa0621c8a..ef86a55c5 100644
--- a/lib/Compilation.js
+++ b/lib/Compilation.js
@@ -71,6 +71,7 @@ const {
 	createFakeHook
 } = require("./util/deprecation");
 const { getRuntimeKey } = require("./util/runtime");
+const { isSourceEqual } = require("./util/source");
 
 /** @template T @typedef {import("tapable").AsArray<T>} AsArray<T> */
 /** @typedef {import("webpack-sources").Source} Source */
@@ -263,25 +264,6 @@ const byLocation = compareSelect(err => err.loc, compareLocations);
 
 const compareErrors = concatComparators(byModule, byLocation, byMessage);
 
-/**
- * @param {Source} a a source
- * @param {Source} b another source
- * @returns {boolean} true, when both sources are equal
- */
-const isSourceEqual = (a, b) => {
-	if (a === b) return true;
-	// TODO webpack 5: check .buffer() instead, it's called anyway during emit
-	/** @type {Buffer|string} */
-	let aSource = a.source();
-	/** @type {Buffer|string} */
-	let bSource = b.source();
-	if (aSource === bSource) return true;
-	if (typeof aSource === "string" && typeof bSource === "string") return false;
-	if (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, "utf-8");
-	if (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, "utf-8");
-	return aSource.equals(bSource);
-};
-
 class Compilation {
 	/**
 	 * Creates an instance of Compilation.
diff --git a/lib/Compiler.js b/lib/Compiler.js
index 934f6e0a2..bea484469 100644
--- a/lib/Compiler.js
+++ b/lib/Compiler.js
@@ -29,6 +29,7 @@ const WebpackError = require("./WebpackError");
 const { Logger } = require("./logging/Logger");
 const { join, dirname, mkdirp } = require("./util/fs");
 const { makePathsRelative } = require("./util/identifier");
+const { isSourceEqual } = require("./util/source");
 
 /** @typedef {import("webpack-sources").Source} Source */
 /** @typedef {import("../declarations/WebpackOptions").EntryNormalized} Entry */
@@ -530,6 +531,7 @@ class Compiler {
 
 			const assets = compilation.getAssets();
 			compilation.assets = { ...compilation.assets };
+			/** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */
 			const caseInsensitiveMap = new Map();
 			asyncLib.forEachLimit(
 				assets,
@@ -559,19 +561,6 @@ class Compiler {
 							targetFile
 						);
 
-						const caseInsensitiveTargetPath = targetPath.toLowerCase();
-						if (caseInsensitiveMap.has(caseInsensitiveTargetPath)) {
-							const other = caseInsensitiveMap.get(caseInsensitiveTargetPath);
-							const err = new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.
-This will lead to a race-condition and corrupted files on case-insensitive file systems.
-${targetPath}
-${other}`);
-							err.file = file;
-							return callback(err);
-						} else {
-							caseInsensitiveMap.set(caseInsensitiveTargetPath, targetPath);
-						}
-
 						// check if the target file has already been written by this Compiler
 						const targetFileGeneration = this._assetEmittingWrittenFiles.get(
 							targetPath
@@ -587,6 +576,46 @@ ${other}`);
 							this._assetEmittingSourceCache.set(source, cacheEntry);
 						}
 
+						let similarEntry;
+
+						const checkSimilarFile = () => {
+							const caseInsensitiveTargetPath = targetPath.toLowerCase();
+							similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);
+							if (similarEntry !== undefined) {
+								const { path: other, source: otherSource } = similarEntry;
+								if (isSourceEqual(otherSource, source)) {
+									// Size may or may not be available at this point.
+									// If it's not available add to "waiting" list and it will be updated once available
+									if (similarEntry.size !== undefined) {
+										updateWithReplacementSource(similarEntry.size);
+									} else {
+										if (!similarEntry.waiting) similarEntry.waiting = [];
+										similarEntry.waiting.push({ file, cacheEntry });
+									}
+									alreadyWritten();
+								} else {
+									const err = new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.
+This will lead to a race-condition and corrupted files on case-insensitive file systems.
+${targetPath}
+${other}`);
+									err.file = file;
+									callback(err);
+								}
+								return true;
+							} else {
+								caseInsensitiveMap.set(
+									caseInsensitiveTargetPath,
+									(similarEntry = {
+										path: targetPath,
+										source,
+										size: undefined,
+										waiting: undefined
+									})
+								);
+								return false;
+							}
+						};
+
 						/**
 						 * get the binary (Buffer) content from the Source
 						 * @returns {Buffer} content for the source
@@ -650,6 +679,20 @@ ${other}`);
 						};
 
 						const updateWithReplacementSource = size => {
+							updateFileWithReplacementSource(file, cacheEntry, size);
+							similarEntry.size = size;
+							if (similarEntry.waiting !== undefined) {
+								for (const { file, cacheEntry } of similarEntry.waiting) {
+									updateFileWithReplacementSource(file, cacheEntry, size);
+								}
+							}
+						};
+
+						const updateFileWithReplacementSource = (
+							file,
+							cacheEntry,
+							size
+						) => {
 							// Create a replacement resource which only allows to ask for size
 							// This allows to GC all memory allocated by the Source
 							// (expect when the Source is stored in any other cache)
@@ -718,6 +761,7 @@ ${other}`);
 							}
 
 							if (!immutable) {
+								if (checkSimilarFile()) return;
 								// We wrote to this file before which has very likely a different content
 								// skip comparing and assume content is different for performance
 								// This case happens often during watch mode.
@@ -725,6 +769,7 @@ ${other}`);
 							}
 						}
 
+						if (checkSimilarFile()) return;
 						if (this.options.output.compareBeforeEmit) {
 							this.outputFileSystem.stat(targetPath, (err, stats) => {
 								const exists = !err && stats.isFile();
diff --git a/lib/util/source.js b/lib/util/source.js
new file mode 100644
index 000000000..5f1334714
--- /dev/null
+++ b/lib/util/source.js
@@ -0,0 +1,61 @@
+/*
+	MIT License http://www.opensource.org/licenses/mit-license.php
+	Author Tobias Koppers @sokra
+*/
+
+"use strict";
+
+/** @typedef {import("webpack-sources").Source} Source */
+
+/** @type {WeakMap<Source, WeakMap<Source, boolean>>} */
+const equalityCache = new WeakMap();
+
+/**
+ * @param {Source} a a source
+ * @param {Source} b another source
+ * @returns {boolean} true, when both sources are equal
+ */
+const _isSourceEqual = (a, b) => {
+	// prefer .buffer(), it's called anyway during emit
+	/** @type {Buffer|string} */
+	let aSource = typeof a.buffer === "function" ? a.buffer() : a.source();
+	/** @type {Buffer|string} */
+	let bSource = typeof b.buffer === "function" ? b.buffer() : b.source();
+	if (aSource === bSource) return true;
+	if (typeof aSource === "string" && typeof bSource === "string") return false;
+	if (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, "utf-8");
+	if (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, "utf-8");
+	return aSource.equals(bSource);
+};
+
+/**
+ * @param {Source} a a source
+ * @param {Source} b another source
+ * @returns {boolean} true, when both sources are equal
+ */
+const isSourceEqual = (a, b) => {
+	if (a === b) return true;
+	const cache1 = equalityCache.get(a);
+	if (cache1 !== undefined) {
+		const result = cache1.get(b);
+		if (result !== undefined) return result;
+	}
+	const result = _isSourceEqual(a, b);
+	if (cache1 !== undefined) {
+		cache1.set(b, result);
+	} else {
+		const map = new WeakMap();
+		map.set(b, result);
+		equalityCache.set(a, map);
+	}
+	const cache2 = equalityCache.get(b);
+	if (cache2 !== undefined) {
+		cache2.set(a, result);
+	} else {
+		const map = new WeakMap();
+		map.set(a, result);
+		equalityCache.set(b, map);
+	}
+	return result;
+};
+exports.isSourceEqual = isSourceEqual;
diff --git a/test/configCases/asset-modules/different-query/index.js b/test/configCases/asset-modules/different-query/index.js
new file mode 100644
index 000000000..6c49de9c5
--- /dev/null
+++ b/test/configCases/asset-modules/different-query/index.js
@@ -0,0 +1,12 @@
+it("should handle different querystrings for assets correctly", () => {
+	const a = new URL("../_images/file.png?foo=bar", import.meta.url);
+	const b = new URL("../_images/file.png?bar=foo", import.meta.url);
+	const c = new URL("../_images/file.png", import.meta.url);
+	const d = new URL("../_images/file.png", import.meta.url);
+	expect(b.pathname).toBe(a.pathname);
+	expect(c.pathname).toBe(a.pathname);
+	expect(d.pathname).toBe(a.pathname);
+	expect(a.search).toBe("?foo=bar");
+	expect(b.search).toBe("?bar=foo");
+	expect(c.search).toBe("");
+});
diff --git a/test/configCases/asset-modules/different-query/webpack.config.js b/test/configCases/asset-modules/different-query/webpack.config.js
new file mode 100644
index 000000000..2a2dd0d26
--- /dev/null
+++ b/test/configCases/asset-modules/different-query/webpack.config.js
@@ -0,0 +1,4 @@
+module.exports = {
+	mode: "development",
+	target: "web"
+};
