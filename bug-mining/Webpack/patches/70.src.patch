diff --git a/lib/optimize/ConcatenatedModule.js b/lib/optimize/ConcatenatedModule.js
index 959f69c94..b2bf8c10a 100644
--- a/lib/optimize/ConcatenatedModule.js
+++ b/lib/optimize/ConcatenatedModule.js
@@ -316,17 +316,19 @@ const getFinalBinding = (
 			exportName
 		};
 	}
-	if (exportInfo.provided === false) {
-		return {
-			info,
-			rawName: "/* not provided export */ undefined",
-			ids: exportName.slice(1),
-			exportName
-		};
-	}
 	switch (info.type) {
 		case "concatenated": {
 			const exportId = exportName[0];
+			if (exportInfo.provided === false) {
+				// It's not provided, but it could be on the prototype
+				neededNamespaceObjects.add(info);
+				return {
+					info,
+					rawName: info.namespaceObjectName,
+					ids: exportName,
+					exportName
+				};
+			}
 			const directExport = info.exportMap && info.exportMap.get(exportId);
 			if (directExport) {
 				const usedName = /** @type {string[]} */ (exportsInfo.getUsedName(
@@ -1268,6 +1270,7 @@ class ConcatenatedModule extends Module {
 			const nsObj = [];
 			const exportsInfo = moduleGraph.getExportsInfo(info.module);
 			for (const exportInfo of exportsInfo.orderedExports) {
+				if (exportInfo.provided === false) continue;
 				const usedName = exportInfo.getUsedName(undefined, runtime);
 				if (usedName) {
 					const finalName = getFinalName(
@@ -1292,18 +1295,23 @@ class ConcatenatedModule extends Module {
 				}
 			}
 			const name = info.namespaceObjectName;
+			const defineGetters =
+				nsObj.length > 0
+					? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(
+							","
+					  )}\n});\n`
+					: "";
+			if (nsObj.length > 0)
+				runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
 			namespaceObjectSources.set(
 				info,
-				`\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(
-					requestShortener
-				)}\nvar ${name} = {};\n${
-					RuntimeGlobals.makeNamespaceObject
-				}(${name});\n${
-					RuntimeGlobals.definePropertyGetters
-				}(${name}, {${nsObj.join(",")}\n});\n`
+				`
+// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}
+var ${name} = {};
+${RuntimeGlobals.makeNamespaceObject}(${name});
+${defineGetters}`
 			);
 			runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);
-			runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
 		}
 
 		// define required namespace objects (must be before evaluation modules)
diff --git a/lib/optimize/MangleExportsPlugin.js b/lib/optimize/MangleExportsPlugin.js
index 2d1d811e4..5cdc5679f 100644
--- a/lib/optimize/MangleExportsPlugin.js
+++ b/lib/optimize/MangleExportsPlugin.js
@@ -18,9 +18,6 @@ const { compareSelect, compareStringsNumeric } = require("../util/comparators");
 /** @typedef {import("../ExportsInfo")} ExportsInfo */
 /** @typedef {import("../ExportsInfo").ExportInfo} ExportInfo */
 
-const OBJECT = [];
-const ARRAY = [];
-
 /**
  * @param {ExportsInfo} exportsInfo exports info
  * @returns {boolean} mangle is possible
@@ -42,15 +39,13 @@ const comparator = compareSelect(e => e.name, compareStringsNumeric);
 /**
  * @param {boolean} deterministic use deterministic names
  * @param {ExportsInfo} exportsInfo exports info
- * @param {boolean} canBeArray can be exports info point to an array
  * @returns {void}
  */
-const mangleExportsInfo = (deterministic, exportsInfo, canBeArray) => {
+const mangleExportsInfo = (deterministic, exportsInfo) => {
 	if (!canMangle(exportsInfo)) return;
 	const usedNames = new Set();
 	/** @type {ExportInfo[]} */
 	const mangleableExports = [];
-	const empty = canBeArray ? ARRAY : OBJECT;
 	for (const exportInfo of exportsInfo.ownedExports) {
 		const name = exportInfo.name;
 		if (!exportInfo.hasUsedName()) {
@@ -63,11 +58,8 @@ const mangleExportsInfo = (deterministic, exportsInfo, canBeArray) => {
 				(deterministic &&
 					name.length === 2 &&
 					/^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name)) ||
-				// Don't rename exports that are not provided and in prototype chain of JSON
-				(exportInfo.provided !== true && exportInfo.name in empty) ||
-				// Don't rename exports that are neither provided nor used
-				(exportInfo.provided === false &&
-					exportInfo.getUsed(undefined) === UsageState.Unused)
+				// Don't rename exports that are not provided
+				exportInfo.provided !== true
 			) {
 				exportInfo.setUsedName(name);
 				usedNames.add(name);
@@ -81,7 +73,7 @@ const mangleExportsInfo = (deterministic, exportsInfo, canBeArray) => {
 				used === UsageState.OnlyPropertiesUsed ||
 				used === UsageState.Unused
 			) {
-				mangleExportsInfo(deterministic, exportInfo.exportsInfo, true);
+				mangleExportsInfo(deterministic, exportInfo.exportsInfo);
 			}
 		}
 	}
@@ -152,7 +144,7 @@ class MangleExportsPlugin {
 				modules => {
 					for (const module of modules) {
 						const exportsInfo = moduleGraph.getExportsInfo(module);
-						mangleExportsInfo(deterministic, exportsInfo, false);
+						mangleExportsInfo(deterministic, exportsInfo);
 					}
 				}
 			);
diff --git a/test/cases/json/prototype-methods/array.json b/test/cases/json/prototype-methods/array.json
new file mode 100644
index 000000000..07868b19a
--- /dev/null
+++ b/test/cases/json/prototype-methods/array.json
@@ -0,0 +1 @@
+[1, 1, 2, 3, 5]
diff --git a/test/cases/json/prototype-methods/index.js b/test/cases/json/prototype-methods/index.js
new file mode 100644
index 000000000..c1d14567a
--- /dev/null
+++ b/test/cases/json/prototype-methods/index.js
@@ -0,0 +1,20 @@
+import data1 from "./array.json?1";
+import data2 from "./array.json?2";
+
+it("should allow to call prototype methods", () => {
+	expect(data1.map(d => d * 2)).toEqual([2, 2, 4, 6, 10]);
+	expect(data2.map(d => d * 2)).toEqual([2, 2, 4, 6, 10]);
+	expect(require("./array.json?2").map(d => d * 2)).toEqual([2, 2, 4, 6, 10]);
+	expect(require("./array.json?3").map(d => d * 2)).toEqual([2, 2, 4, 6, 10]);
+	try {
+		Object.prototype.smoosh = function () {
+			return this.map(d => d + 1);
+		};
+		expect(data1.smoosh()).toEqual([2, 2, 3, 4, 6]);
+		expect(data2.smoosh()).toEqual([2, 2, 3, 4, 6]);
+		expect(require("./array.json?2").smoosh()).toEqual([2, 2, 3, 4, 6]);
+		expect(require("./array.json?3").smoosh()).toEqual([2, 2, 3, 4, 6]);
+	} finally {
+		delete Object.prototype.smoosh;
+	}
+});
diff --git a/test/configCases/json/tree-shaking-default/index.js b/test/configCases/json/tree-shaking-default/index.js
index 0064b87fc..cdfb0bfee 100644
--- a/test/configCases/json/tree-shaking-default/index.js
+++ b/test/configCases/json/tree-shaking-default/index.js
@@ -27,10 +27,10 @@ it("should be able to write properties", () => {
 	// object methods
 	expect(data.nested.object.hasOwnProperty("test")).toBe(true);
 	// unknown object property
-	data.nested.object2.MANGLE_ME = 42;
-	expect(data.nested.object2.MANGLE_ME).toBe(42);
-	data.nested.object3.MANGLE_ME = { deep: "deep" };
-	expect(data.nested.object3.MANGLE_ME.deep).toBe("deep");
+	data.nested.object2.unknownProperty = 42;
+	expect(data.nested.object2.unknownProperty).toBe(42);
+	data.nested.object3.unknownProperty = { deep: "deep" };
+	expect(data.nested.object3.unknownProperty.deep).toBe("deep");
 	// number methods
 	expect(data.nested.number.toFixed(1)).toBe("42.0");
 	// nested in array
@@ -44,7 +44,8 @@ it("should not have unused keys in bundle", () => {
 	expect(content).not.toMatch(/\\?"UNUSEDKEY\\?"/);
 	expect(content).not.toMatch(/\\?"UNUSEDVALUE\\?"/);
 	expect(content).not.toMatch(/\\?"nested\\?"/);
-	expect(content).not.toMatch(/\.MANGLE_ME(\.deep)?(\s*=|\))/);
+	expect(content).toMatch(/\.unknownProperty\s*=/);
+	expect(content).toMatch(/\.unknownProperty\.deep\)/);
 	expect(content).not.toMatch(/\\?"dependencies\\?"/);
 	expect(content).not.toMatch(/\\?"scripts\\?"/);
 });
