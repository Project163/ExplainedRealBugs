diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserializer.java
index cba6e3b..56f9426 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserializer.java
@@ -16,11 +16,16 @@
 
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.core.JsonToken;
 import com.fasterxml.jackson.core.JsonTokenId;
+import com.fasterxml.jackson.databind.BeanProperty;
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.datatype.jsr310.DecimalUtils;
 
 import java.io.IOException;
@@ -28,13 +33,14 @@ import java.math.BigDecimal;
 import java.time.DateTimeException;
 import java.time.Duration;
 
+
 /**
  * Deserializer for Java 8 temporal {@link Duration}s.
  *
  * @author Nick Williams
  * @since 2.2.0
  */
-public class DurationDeserializer extends JSR310DeserializerBase<Duration>
+public class DurationDeserializer extends JSR310DeserializerBase<Duration> implements ContextualDeserializer
 {
     private static final long serialVersionUID = 1L;
 
@@ -45,6 +51,18 @@ public class DurationDeserializer extends JSR310DeserializerBase<Duration>
         super(Duration.class);
     }
 
+    /**
+     * Since 2.11
+     */
+    protected DurationDeserializer(DurationDeserializer base, Boolean leniency) {
+        super(base, leniency);
+    }
+
+    @Override
+    protected DurationDeserializer withLeniency(Boolean leniency) {
+        return new DurationDeserializer(this, leniency);
+    }
+
     @Override
     public Duration deserialize(JsonParser parser, DeserializationContext context) throws IOException
     {
@@ -63,6 +81,9 @@ public class DurationDeserializer extends JSR310DeserializerBase<Duration>
             case JsonTokenId.ID_STRING:
                 String string = parser.getText().trim();
                 if (string.length() == 0) {
+                    if (!isLenient()) {
+                        return _failForNotLenient(parser, context, JsonToken.VALUE_STRING);
+                    }
                     return null;
                 }
                 try {
@@ -81,4 +102,21 @@ public class DurationDeserializer extends JSR310DeserializerBase<Duration>
         return _handleUnexpectedToken(context, parser, JsonToken.VALUE_STRING,
                 JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_FLOAT);
     }
+
+    @Override
+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
+                                                BeanProperty property) throws JsonMappingException
+    {
+        JsonFormat.Value format = findFormatOverrides(ctxt, property, handledType());
+        DurationDeserializer deser = this;
+        if (format != null) {
+            if (format.hasLenient()) {
+                Boolean leniency = format.getLenient();
+                if (leniency != null) {
+                    deser = deser.withLeniency(leniency);
+                }
+            }
+        }
+        return deser;
+    }
 }
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserializer.java
index c2a86ba..519cb30 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserializer.java
@@ -151,6 +151,18 @@ public class InstantDeserializer<T extends Temporal>
         _adjustToContextTZOverride = adjustToContextTimezoneOverride;
     }
 
+    @SuppressWarnings("unchecked")
+    protected InstantDeserializer(InstantDeserializer<T> base, DateTimeFormatter f, Boolean leniency)
+    {
+        super((Class<T>) base.handledType(), f, leniency);
+        parsedToValue = base.parsedToValue;
+        fromMilliseconds = base.fromMilliseconds;
+        fromNanoseconds = base.fromNanoseconds;
+        adjust = base.adjust;
+        replaceZeroOffsetAsZ = (_formatter == DateTimeFormatter.ISO_INSTANT);
+        _adjustToContextTZOverride = base._adjustToContextTZOverride;
+    }
+
     @Override
     protected InstantDeserializer<T> withDateFormat(DateTimeFormatter dtf) {
         if (dtf == _formatter) {
@@ -159,10 +171,12 @@ public class InstantDeserializer<T extends Temporal>
         return new InstantDeserializer<T>(this, dtf);
     }
 
-    // !!! TODO: lenient vs strict?
     @Override
     protected InstantDeserializer<T> withLeniency(Boolean leniency) {
-        return this;
+        if (_isLenient == !Boolean.FALSE.equals(leniency)) {
+            return this;
+        }
+        return new InstantDeserializer<T>(this, _formatter, leniency);
     }
 
     @Override
@@ -186,6 +200,9 @@ public class InstantDeserializer<T extends Temporal>
             {
                 String string = parser.getText().trim();
                 if (string.length() == 0) {
+                    if (!isLenient()) {
+                        return _failForNotLenient(parser, context, JsonToken.VALUE_STRING);
+                    }
                     return null;
                 }
                 // only check for other parsing modes if we are using default formatter
@@ -245,10 +262,16 @@ public class InstantDeserializer<T extends Temporal>
         if (deserializer != this) {
             JsonFormat.Value val = findFormatOverrides(ctxt, property, handledType());
             if (val != null) {
-                return  new InstantDeserializer<>(deserializer, val.getFeature(JsonFormat.Feature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE));
+                deserializer = new InstantDeserializer<>(deserializer, val.getFeature(JsonFormat.Feature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE));
+                if (val.hasLenient()) {
+                    Boolean leniency = val.getLenient();
+                    if (leniency != null) {
+                        deserializer = deserializer.withLeniency(leniency);
+                    }
+                }
             }
         }
-        return this;
+        return deserializer;
     }
 
     protected boolean shouldAdjustToContextTimezone(DeserializationContext context) {
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java
index 43f1f00..d4087f8 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java
@@ -60,6 +60,16 @@ public abstract class JSR310DateTimeDeserializerBase<T>
         _shape = null;
     }
 
+    /**
+     * @since 2.11
+     */
+    public JSR310DateTimeDeserializerBase(Class<T> supportedType, DateTimeFormatter f, Boolean leniency) {
+        super(supportedType);
+        _formatter = f;
+        _isLenient = !Boolean.FALSE.equals(leniency);
+        _shape = null;
+    }
+
     /**
      * @since 2.10
      */
@@ -93,7 +103,6 @@ public abstract class JSR310DateTimeDeserializerBase<T>
         _isLenient = base._isLenient;
     }
 
-
     protected abstract JSR310DateTimeDeserializerBase<T> withDateFormat(DateTimeFormatter dtf);
 
     /**
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DeserializerBase.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DeserializerBase.java
index 2be1379..a075d01 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DeserializerBase.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DeserializerBase.java
@@ -27,6 +27,7 @@ import com.fasterxml.jackson.databind.JsonDeserializer;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
+import com.fasterxml.jackson.databind.util.ClassUtil;
 
 /**
  * Base class that indicates that all JSR310 datatypes are deserialized from scalar JSON types.
@@ -38,15 +39,57 @@ abstract class JSR310DeserializerBase<T> extends StdScalarDeserializer<T>
 {
     private static final long serialVersionUID = 1L;
 
+    /**
+     * Flag that indicates what leniency setting is enabled for this deserializer (either
+     * due {@link JsonFormat} annotation on property or class, or due to per-type
+     * "config override", or from global settings): leniency/strictness has effect
+     * on accepting some non-default input value representations (such as integer values
+     * for dates).
+     *<p>
+     * Note that global default setting is for leniency to be enabled, for Jackson 2.x,
+     * and has to be explicitly change to force strict handling: this is to keep backwards
+     * compatibility with earlier versions.
+     *
+     * @since 2.11
+     */
+    protected final boolean _isLenient;
+
+    /**
+     * @since 2.11
+     */
     protected JSR310DeserializerBase(Class<T> supportedType) {
         super(supportedType);
+        _isLenient = true;
+    }
+
+    protected JSR310DeserializerBase(Class<T> supportedType,
+                                     Boolean leniency) {
+        super(supportedType);
+        _isLenient = !Boolean.FALSE.equals(leniency);
+    }
+
+    protected JSR310DeserializerBase(JSR310DeserializerBase<T> base) {
+        super(base);
+        _isLenient = true;
+    }
+
+    protected JSR310DeserializerBase(JSR310DeserializerBase<T> base, Boolean leniency) {
+        super(base);
+        _isLenient = !Boolean.FALSE.equals(leniency);
     }
 
     /**
-     * @since 2.10
+     * @since 2.11
      */
-    protected JSR310DeserializerBase(JSR310DeserializerBase<?> base) {
-        super(base);
+    protected abstract JSR310DeserializerBase<T> withLeniency(Boolean leniency);
+
+    /**
+     * @return {@code true} if lenient handling is enabled; {code false} if not (strict mode)
+     *
+     * @since 2.11
+     */
+    protected boolean isLenient() {
+        return _isLenient;
     }
     
     @Override
@@ -122,6 +165,15 @@ abstract class JSR310DeserializerBase<T> extends StdScalarDeserializer<T>
                 handledType().getName());
     }
 
+    @SuppressWarnings("unchecked")
+    protected T _failForNotLenient(JsonParser p, DeserializationContext ctxt,
+                                   JsonToken expToken) throws IOException
+    {
+        return (T) ctxt.handleUnexpectedToken(handledType(), expToken, p,
+                "Cannot deserialize instance of %s out of %s token: not allowed because 'strict' mode set for property or type (enable 'lenient' handling to allow)",
+                ClassUtil.nameOf(handledType()), p.currentToken());
+    }
+
     /**
      * Helper method used to peel off spurious wrappings of DateTimeException
      *
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310StringParsableDeserializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310StringParsableDeserializer.java
index 24b2b86..e0372ec 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310StringParsableDeserializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310StringParsableDeserializer.java
@@ -22,11 +22,15 @@ import java.time.Period;
 import java.time.ZoneId;
 import java.time.ZoneOffset;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonParser;
 
 import com.fasterxml.jackson.core.JsonToken;
+import com.fasterxml.jackson.databind.BeanProperty;
 import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
 import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
 
 /**
@@ -41,6 +45,7 @@ import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
  */
 public class JSR310StringParsableDeserializer
     extends JSR310DeserializerBase<Object>
+        implements ContextualDeserializer
 {
     private static final long serialVersionUID = 1L;
 
@@ -66,17 +71,38 @@ public class JSR310StringParsableDeserializer
         _valueType = valueId;
     }
 
+    /**
+     * Since 2.11
+     */
+    protected JSR310StringParsableDeserializer(JSR310StringParsableDeserializer base, Boolean leniency) {
+        super(base, leniency);
+        _valueType = base._valueType;
+    }
+
     @SuppressWarnings("unchecked")
     protected static <T> JsonDeserializer<T> createDeserializer(Class<T> type, int typeId) {
         return (JsonDeserializer<T>) new JSR310StringParsableDeserializer(type, typeId);
     }
 
+    @Override
+    protected JSR310StringParsableDeserializer withLeniency(Boolean leniency) {
+        if (_isLenient == !Boolean.FALSE.equals(leniency)) {
+            return this;
+        }
+        // TODO: or should this be casting as above in createDeserializer? But then in createContext, we need to
+        // call the withLeniency method in this class. (See if we can follow InstantDeser convention here?)
+        return new JSR310StringParsableDeserializer(this, leniency);
+    }
+
     @Override
     public Object deserialize(JsonParser parser, DeserializationContext context) throws IOException
     {
         if (parser.hasToken(JsonToken.VALUE_STRING)) {
             String string = parser.getText().trim();
             if (string.length() == 0) {
+                if (!isLenient()) {
+                    return _failForNotLenient(parser, context, JsonToken.VALUE_STRING);
+                }
                 return null;
             }
             try {
@@ -118,4 +144,21 @@ public class JSR310StringParsableDeserializer
         }
         return deserializer.deserializeTypedFromAny(parser, context);
     }
+
+    @Override
+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,
+                                                BeanProperty property) throws JsonMappingException
+    {
+        JsonFormat.Value format = findFormatOverrides(ctxt, property, handledType());
+        JSR310StringParsableDeserializer deser = this;
+        if (format != null) {
+            if (format.hasLenient()) {
+                Boolean leniency = format.getLenient();
+                if (leniency != null) {
+                    deser = this.withLeniency(leniency);
+                }
+            }
+        }
+        return deser;
+    }
 }
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserializer.java
index 1452875..2a09eed 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserializer.java
@@ -48,15 +48,21 @@ public class LocalTimeDeserializer extends JSR310DateTimeDeserializerBase<LocalT
         super(LocalTime.class, formatter);
     }
 
+    /**
+     * Since 2.11
+     */
+    protected LocalTimeDeserializer(LocalTimeDeserializer base, Boolean leniency) {
+        super(base, leniency);
+    }
+
     @Override
     protected LocalTimeDeserializer withDateFormat(DateTimeFormatter formatter) {
         return new LocalTimeDeserializer(formatter);
     }
 
-    // !!! TODO: lenient vs strict?
     @Override
     protected LocalTimeDeserializer withLeniency(Boolean leniency) {
-        return this;
+        return new LocalTimeDeserializer(this, leniency);
     }
 
     @Override
@@ -68,6 +74,9 @@ public class LocalTimeDeserializer extends JSR310DateTimeDeserializerBase<LocalT
         if (parser.hasToken(JsonToken.VALUE_STRING)) {
             String string = parser.getText().trim();
             if (string.length() == 0) {
+                if (!isLenient()) {
+                    return _failForNotLenient(parser, context, JsonToken.VALUE_STRING);
+                }
                 return null;
             }
             DateTimeFormatter format = _formatter;
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserializer.java
index d828119..8c70342 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserializer.java
@@ -45,15 +45,21 @@ public class OffsetTimeDeserializer extends JSR310DateTimeDeserializerBase<Offse
         super(OffsetTime.class, dtf);
     }
 
+    /**
+     * Since 2.11
+     */
+    protected OffsetTimeDeserializer(OffsetTimeDeserializer base, Boolean leniency) {
+        super(base, leniency);
+    }
+
     @Override
     protected OffsetTimeDeserializer withDateFormat(DateTimeFormatter dtf) {
         return new OffsetTimeDeserializer(dtf);
     }
 
-    // !!! TODO: lenient vs strict?
     @Override
     protected OffsetTimeDeserializer withLeniency(Boolean leniency) {
-        return this;
+        return new OffsetTimeDeserializer(this, leniency);
     }
 
     @Override
@@ -65,6 +71,9 @@ public class OffsetTimeDeserializer extends JSR310DateTimeDeserializerBase<Offse
         if (parser.hasToken(JsonToken.VALUE_STRING)) {
             String string = parser.getText().trim();
             if (string.length() == 0) {
+                if (!isLenient()) {
+                    return _failForNotLenient(parser, context, JsonToken.VALUE_STRING);
+                }
                 return null;
             }
             try {
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserializer.java
index 9e5a05c..27ecf4e 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserializer.java
@@ -49,15 +49,21 @@ public class YearMonthDeserializer extends JSR310DateTimeDeserializerBase<YearMo
         super(YearMonth.class, formatter);
     }
 
+    /**
+     * Since 2.11
+     */
+    protected YearMonthDeserializer(YearMonthDeserializer base, Boolean leniency) {
+        super(base, leniency);
+    }
+
     @Override
     protected YearMonthDeserializer withDateFormat(DateTimeFormatter dtf)  {
         return new YearMonthDeserializer(dtf);
     }
 
-    // !!! TODO: lenient vs strict?
     @Override
     protected YearMonthDeserializer withLeniency(Boolean leniency) {
-        return this;
+        return new YearMonthDeserializer(this, leniency);
     }
 
     @Override
@@ -69,6 +75,9 @@ public class YearMonthDeserializer extends JSR310DateTimeDeserializerBase<YearMo
         if (parser.hasToken(JsonToken.VALUE_STRING)) {
             String string = parser.getText().trim();
             if (string.length() == 0) {
+                if (!isLenient()) {
+                    return _failForNotLenient(parser, context, JsonToken.VALUE_STRING);
+                }
                 return null;
             }
             try {
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserTest.java
index 68d2191..aff2c18 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/DurationDeserTest.java
@@ -2,8 +2,12 @@ package com.fasterxml.jackson.datatype.jsr310.deser;
 
 import java.math.BigInteger;
 import java.time.Duration;
+import java.time.LocalDateTime;
 import java.time.temporal.TemporalAmount;
+import java.util.Map;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.core.type.TypeReference;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -24,6 +28,8 @@ public class DurationDeserTest extends ModuleTestBase
 {
     private final ObjectReader READER = newMapper().readerFor(Duration.class);
 
+    private final TypeReference<Map<String, Duration>> MAP_TYPE_REF = new TypeReference<Map<String, Duration>>() { };
+
     @Test
     public void testDeserializationAsFloat01() throws Exception
     {
@@ -371,4 +377,52 @@ public class DurationDeserTest extends ModuleTestBase
     			.readerFor(Duration.class).readValue(aposToQuotes(json));
     	assertNull(value);
     }
+
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "duration";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String dateValAsNullStr = null;
+        String dateValAsEmptyStr = "";
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, dateValAsNullStr));
+        Map<String, Duration> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        Duration actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, dateValAsEmptyStr));
+        Map<String, Duration> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        Duration actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "duration";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(Duration.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+        final String dateValAsNullStr = null;
+
+        // even with strict, null value should be deserialized without throwing an exception
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, dateValAsNullStr));
+        Map<String, Duration> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String dateValAsEmptyStr = "";
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, dateValAsEmptyStr));
+        objectReader.readValue(valueFromEmptyStr);
+    }
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserTest.java
index 7503848..5858a03 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/InstantDeserTest.java
@@ -1,19 +1,13 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-import java.time.DateTimeException;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.ZoneId;
-import java.time.ZoneOffset;
-import java.time.ZonedDateTime;
+import java.time.*;
 import java.time.format.DateTimeFormatter;
 import java.time.temporal.ChronoUnit;
 import java.time.temporal.Temporal;
+import java.util.Map;
 
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import org.junit.Test;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
@@ -25,10 +19,14 @@ import com.fasterxml.jackson.datatype.jsr310.DecimalUtils;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertNull;
+
 public class InstantDeserTest extends ModuleTestBase
 {
     private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_INSTANT;
     private static final String CUSTOM_PATTERN = "yyyy-MM-dd HH:mm:ss";
+    private final TypeReference<Map<String, Instant>> MAP_TYPE_REF = new TypeReference<Map<String, Instant>>() { };
 
     static class Wrapper {
         @JsonFormat(
@@ -479,4 +477,49 @@ public class InstantDeserTest extends ModuleTestBase
 
         assertEquals(givenInstant, actual);
     }
+
+        /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "duration";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String dateValAsNullStr = null;
+        String dateValAsEmptyStr = "";
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, dateValAsNullStr));
+        Map<String, Duration> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        Duration actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, dateValAsEmptyStr));
+        Map<String, Duration> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        Duration actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "instant";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(Instant.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, Instant> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java
index 4441cae..0637ffa 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java
@@ -216,7 +216,7 @@ public class LocalDateDeserTest extends ModuleTestBase
     }
 
     @Test( expected =  MismatchedInputException.class)
-    public void testStrictDeserializFromEmptyString() throws Exception {
+    public void testStrictDeserializeFromEmptyString() throws Exception {
 
         final String key = "date";
         final ObjectMapper mapper = mapperBuilder().build();
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateTimeDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateTimeDeserTest.java
index 0881183..ea8b7b5 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateTimeDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateTimeDeserTest.java
@@ -208,7 +208,7 @@ public class LocalDateTimeDeserTest
     }
 
     @Test( expected =  MismatchedInputException.class)
-    public void testStrictDeserializFromEmptyString() throws Exception {
+    public void testStrictDeserializeFromEmptyString() throws Exception {
 
         final String key = "datetime";
         final ObjectMapper mapper = mapperBuilder().build();
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserTest.java
index 072e8fd..26c6b6a 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalTimeDeserTest.java
@@ -17,9 +17,12 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
 import java.io.IOException;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
 import java.time.LocalTime;
 import java.time.format.DateTimeParseException;
 import java.time.temporal.Temporal;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -27,7 +30,9 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
@@ -40,6 +45,7 @@ import org.junit.Test;
 public class LocalTimeDeserTest extends ModuleTestBase
 {
     private ObjectReader reader = newMapper().readerFor(LocalTime.class);
+    private final TypeReference<Map<String, LocalTime>> MAP_TYPE_REF = new TypeReference<Map<String, LocalTime>>() { };
 
     @Test
     public void testDeserializationAsTimestamp01() throws Exception
@@ -209,6 +215,48 @@ public class LocalTimeDeserTest extends ModuleTestBase
         assertEquals("The value is not correct.", time, value);
     }
 
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "localTime";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String dateValAsEmptyStr = "";
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, LocalTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        LocalTime actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, dateValAsEmptyStr));
+        Map<String, LocalTime> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        LocalTime actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting",null, actualDateFromEmptyStr);
+    }
+
+    @Test( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "localTime";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(LocalTime.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, LocalTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap("date", ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
 
     private void expectFailure(String aposJson) throws Throwable {
         try {
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/MonthDayDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/MonthDayDeserTest.java
index d0c4a63..1aebcc3 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/MonthDayDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/MonthDayDeserTest.java
@@ -2,10 +2,12 @@ package com.fasterxml.jackson.datatype.jsr310.deser;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
@@ -13,10 +15,12 @@ import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.time.LocalTime;
 import java.time.Month;
 import java.time.MonthDay;
 import java.time.format.DateTimeParseException;
 import java.time.temporal.TemporalAccessor;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -27,6 +31,7 @@ public class MonthDayDeserTest extends ModuleTestBase
 {
     private final ObjectMapper MAPPER = newMapper();
     private final ObjectReader READER = MAPPER.readerFor(MonthDay.class);
+    private final TypeReference<Map<String, MonthDay>> MAP_TYPE_REF = new TypeReference<Map<String, MonthDay>>() { };
 
     static class Wrapper {
         @JsonFormat(pattern="MM/dd")
@@ -151,6 +156,28 @@ public class MonthDayDeserTest extends ModuleTestBase
         assertEquals(input.value, output.value);
     }
 
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "monthDay";
+        final ObjectMapper mapper = mapperBuilder().build();
+        // leniency has no effect here because MonthDayDeser passes through to Java API MonthDay.parse method...
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, MonthDay> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
+
     private void expectFailure(String aposJson) throws Throwable {
         try {
             read(aposJson);
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetDateTimeDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetDateTimeDeserTest.java
index e7e45a5..3752f2e 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetDateTimeDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetDateTimeDeserTest.java
@@ -1,35 +1,34 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.OffsetDateTime;
-import java.time.ZoneId;
-import java.time.ZoneOffset;
+import java.time.*;
 import java.time.format.DateTimeFormatter;
 import java.time.temporal.ChronoField;
 import java.time.temporal.ChronoUnit;
 import java.time.temporal.Temporal;
+import java.util.Map;
 import java.util.TimeZone;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.SerializationFeature;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.DecimalUtils;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertNull;
 
 public class OffsetDateTimeDeserTest
     extends ModuleTestBase
 {
     private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
-
+    private final TypeReference<Map<String, OffsetDateTime>> MAP_TYPE_REF = new TypeReference<Map<String, OffsetDateTime>>() { };
     private static final ZoneId UTC = ZoneId.of("UTC");
 
     private static final ZoneId Z1 = ZoneId.of("America/Chicago");
@@ -615,6 +614,49 @@ public class OffsetDateTimeDeserTest
         assertEquals(givenInstant.atOffset(ZoneOffset.UTC), actual);
     }
 
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "OffsetDateTime";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, OffsetDateTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        OffsetDateTime actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        Map<String, OffsetDateTime> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        OffsetDateTime actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "OffsetDateTime";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(OffsetDateTime.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+        final String dateValAsNullStr = null;
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, OffsetDateTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
+
     private static void assertIsEqual(OffsetDateTime expected, OffsetDateTime actual)
     {
         assertTrue("The value is not correct. Expected timezone-adjusted <" + expected + ">, actual <" + actual + ">.",
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserTest.java
index a5db19c..10aff9b 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/OffsetTimeDeserTest.java
@@ -1,10 +1,13 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
@@ -12,10 +15,13 @@ import org.junit.Test;
 
 import java.io.IOException;
 import java.time.OffsetTime;
+import java.time.Year;
+import java.time.ZoneId;
 import java.time.ZoneOffset;
 import java.time.format.DateTimeParseException;
 import java.time.temporal.Temporal;
 import java.util.List;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -25,6 +31,9 @@ import static org.junit.Assert.fail;
 
 public class OffsetTimeDeserTest extends ModuleTestBase
 {
+
+    private final TypeReference<Map<String, OffsetTime>> MAP_TYPE_REF = new TypeReference<Map<String, OffsetTime>>() { };
+
     // for [datatype-jsr310#45]
     static class  Pojo45s {
         public String name;
@@ -237,6 +246,49 @@ public class OffsetTimeDeserTest extends ModuleTestBase
         assertNull(value);
     }
 
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "OffsetTime";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, OffsetTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        OffsetTime actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        Map<String, OffsetTime> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        OffsetTime actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "OffsetTime";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(OffsetTime.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+        final String dateValAsNullStr = null;
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, OffsetTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
+
     private void expectFailure(String json) throws Throwable {
         try {
             read(json);
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/PeriodDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/PeriodDeserTest.java
index a6d8ed1..da4cb10 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/PeriodDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/PeriodDeserTest.java
@@ -16,22 +16,29 @@
 
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
+import java.time.Instant;
 import java.time.Period;
+import java.time.YearMonth;
 import java.time.temporal.TemporalAmount;
+import java.util.Map;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
 import org.junit.Test;
 
+import static org.junit.Assert.*;
+import static org.junit.Assert.assertNull;
+
 public class PeriodDeserTest extends ModuleTestBase
 {
     private final ObjectMapper MAPPER = newMapper();
+    private final TypeReference<Map<String, Period>> MAP_TYPE_REF = new TypeReference<Map<String, Period>>() { };
 
     @Test
     public void testDeserialization01() throws Exception
@@ -65,4 +72,45 @@ public class PeriodDeserTest extends ModuleTestBase
         assertTrue("The value should be a Period.", value instanceof Period);
         assertEquals("The value is not correct.", period, value);
     }
+
+       /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "period";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, Period> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        Period actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        Map<String, Period> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        Period actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting",null, actualDateFromEmptyStr);
+    }
+
+    @Test( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "period";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(Period.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, Period> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap("date", ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearDeserTest.java
index 9824d80..767dfff 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearDeserTest.java
@@ -18,16 +18,20 @@ package com.fasterxml.jackson.datatype.jsr310.deser;
 
 import java.io.IOException;
 import java.time.Year;
+import java.time.YearMonth;
 import java.time.format.DateTimeParseException;
 import java.time.temporal.Temporal;
+import java.util.Map;
 import java.util.Objects;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
@@ -40,6 +44,9 @@ import static org.junit.Assert.fail;
 
 public class YearDeserTest extends ModuleTestBase
 {
+
+    private final TypeReference<Map<String, Year>> MAP_TYPE_REF = new TypeReference<Map<String, Year>>() { };
+
     static class FormattedYear {
         @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "'Y'yyyy")
         public Year value;
@@ -203,7 +210,29 @@ public class YearDeserTest extends ModuleTestBase
         ObjectTest result = MAPPER.readValue(json, ObjectTest.class);
         assertEquals(input, result);
     }
-    
+
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "Year";
+        final ObjectMapper mapper = mapperBuilder().build();
+        // YearDeserializer is always strict as far as empty strings, so lenient/strict has no effect
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, Year> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap("date", ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
+
     /*
     /**********************************************************
     /* Helper methods
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserTest.java
index 9034a0d..2fe9d73 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/YearMonthDeserTest.java
@@ -1,17 +1,24 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
 import org.junit.Test;
 
 import java.io.IOException;
+import java.time.LocalTime;
 import java.time.Month;
+import java.time.MonthDay;
 import java.time.YearMonth;
 import java.time.format.DateTimeParseException;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -21,6 +28,7 @@ import static org.junit.Assert.fail;
 public class YearMonthDeserTest extends ModuleTestBase
 {
     private final ObjectReader READER = newMapper().readerFor(YearMonth.class);
+    private final TypeReference<Map<String, YearMonth>> MAP_TYPE_REF = new TypeReference<Map<String, YearMonth>>() { };
 
     @Test
     public void testDeserializationAsString01() throws Exception
@@ -77,6 +85,48 @@ public class YearMonthDeserTest extends ModuleTestBase
     	assertNull(value);
     }
 
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "yearMonth";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String dateValAsEmptyStr = "";
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, YearMonth> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        YearMonth actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, dateValAsEmptyStr));
+        Map<String, YearMonth> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        YearMonth actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting",null, actualDateFromEmptyStr);
+    }
+
+    @Test( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "YearMonth";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(YearMonth.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, YearMonth> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap("date", ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
 
     private void expectFailure(String json) throws Throwable {
         try {
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneIdDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneIdDeserTest.java
index 7f7696f..424f48d 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneIdDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneIdDeserTest.java
@@ -17,10 +17,17 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 import java.time.ZoneId;
+import java.time.ZonedDateTime;
+import java.util.Map;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.MockObjectConfiguration;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
@@ -29,6 +36,7 @@ import org.junit.Test;
 public class ZoneIdDeserTest extends ModuleTestBase
 {
     private ObjectMapper MAPPER = newMapper();
+    private final TypeReference<Map<String, ZoneId>> MAP_TYPE_REF = new TypeReference<Map<String, ZoneId>>() { };
 
     private final ObjectMapper MOCK_OBJECT_MIXIN_MAPPER = mapperBuilder()
             .addMixIn(ZoneId.class, MockObjectConfiguration.class)
@@ -54,4 +62,47 @@ public class ZoneIdDeserTest extends ModuleTestBase
         ZoneId value = MOCK_OBJECT_MIXIN_MAPPER.readValue("[\"" + ZoneId.class.getName() + "\",\"America/Denver\"]", ZoneId.class);
         assertEquals("The value is not correct.", ZoneId.of("America/Denver"), value);
     }
+
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "zoneId";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, ZoneId> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        ZoneId actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        Map<String, ZoneId> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        ZoneId actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "zoneId";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(ZoneId.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+        final String dateValAsNullStr = null;
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, ZoneId> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneOffsetDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneOffsetDeserTest.java
index 8c151d1..7ac0486 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneOffsetDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZoneOffsetDeserTest.java
@@ -18,12 +18,15 @@ package com.fasterxml.jackson.datatype.jsr310.deser;
 
 import java.time.ZoneId;
 import java.time.ZoneOffset;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
@@ -38,6 +41,7 @@ public class ZoneOffsetDeserTest extends ModuleTestBase
 {
     private final static ObjectMapper MAPPER = newMapper();
     private final static ObjectReader READER = MAPPER.readerFor(ZoneOffset.class);
+    private final TypeReference<Map<String, ZoneOffset>> MAP_TYPE_REF = new TypeReference<Map<String, ZoneOffset>>() { };
 
     @Test
     public void testDeserializationFromString() throws Exception
@@ -121,4 +125,48 @@ public class ZoneOffsetDeserTest extends ModuleTestBase
                .readValue("[]");
         assertNull(value);
     }
+
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "zoneOffset";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, ZoneOffset> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        ZoneId actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        Map<String, ZoneOffset> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        ZoneId actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "zoneOffset";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(ZoneOffset.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+        final String dateValAsNullStr = null;
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, ZoneOffset> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
+
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZonedDateTimeDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZonedDateTimeDeserTest.java
index c8a35bf..3a8ef8b 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZonedDateTimeDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/ZonedDateTimeDeserTest.java
@@ -1,17 +1,23 @@
 package com.fasterxml.jackson.datatype.jsr310.deser;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
+import com.fasterxml.jackson.databind.exc.MismatchedInputException;
 import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
 
 import org.junit.Test;
 
 import java.io.IOException;
+import java.time.Duration;
 import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeParseException;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -20,6 +26,7 @@ import static org.junit.Assert.fail;
 public class ZonedDateTimeDeserTest extends ModuleTestBase
 {
     private final ObjectReader READER = newMapper().readerFor(ZonedDateTime.class);
+    private final TypeReference<Map<String, ZonedDateTime>> MAP_TYPE_REF = new TypeReference<Map<String, ZonedDateTime>>() { };
 
     @Test
     public void testDeserializationAsString01() throws Exception
@@ -96,6 +103,49 @@ public class ZonedDateTimeDeserTest extends ModuleTestBase
     	assertNull(value);
     }
 
+    /*
+    /**********************************************************
+    /* Tests for empty string handling
+    /**********************************************************
+     */
+
+    @Test
+    public void testLenientDeserializeFromEmptyString() throws Exception {
+
+        String key = "zoneDateTime";
+        ObjectMapper mapper = newMapper();
+        ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, ZonedDateTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        ZonedDateTime actualDateFromNullStr = actualMapFromNullStr.get(key);
+        assertNull(actualDateFromNullStr);
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        Map<String, ZonedDateTime> actualMapFromEmptyStr = objectReader.readValue(valueFromEmptyStr);
+        ZonedDateTime actualDateFromEmptyStr = actualMapFromEmptyStr.get(key);
+        assertEquals("empty string failed to deserialize to null with lenient setting", null, actualDateFromEmptyStr);
+    }
+
+    @Test ( expected =  MismatchedInputException.class)
+    public void testStrictDeserializeFromEmptyString() throws Exception {
+
+        final String key = "zonedDateTime";
+        final ObjectMapper mapper = mapperBuilder().build();
+        mapper.configOverride(ZonedDateTime.class)
+                .setFormat(JsonFormat.Value.forLeniency(false));
+
+        final ObjectReader objectReader = mapper.readerFor(MAP_TYPE_REF);
+        final String dateValAsNullStr = null;
+
+        String valueFromNullStr = mapper.writeValueAsString(asMap(key, null));
+        Map<String, ZonedDateTime> actualMapFromNullStr = objectReader.readValue(valueFromNullStr);
+        assertNull(actualMapFromNullStr.get(key));
+
+        String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
+        objectReader.readValue(valueFromEmptyStr);
+    }
+
     private void expectFailure(String json) throws Throwable {
         try {
             READER.readValue(aposToQuotes(json));
