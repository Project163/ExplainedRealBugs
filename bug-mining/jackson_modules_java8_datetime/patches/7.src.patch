diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java
index 1854299..37511c8 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/deser/JSR310DateTimeDeserializerBase.java
@@ -12,6 +12,7 @@ import com.fasterxml.jackson.databind.DeserializationContext;
 import com.fasterxml.jackson.databind.JsonDeserializer;
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.deser.ContextualDeserializer;
+import com.fasterxml.jackson.databind.util.ClassUtil;
 
 @SuppressWarnings("serial")
 public abstract class JSR310DateTimeDeserializerBase<T>
@@ -125,6 +126,7 @@ p.getNumberValue(), handledType().getName());
             JsonToken expToken) throws IOException
     {
        return (T) ctxt.handleUnexpectedToken(handledType(), expToken, p,
-               "not allowed because 'strict' mode set for property or type (enabled 'lenient' handling to allow)"); 
+"Cannot deserialize instance of %s out of %s token: not allowed because 'strict' mode set for property or type (enable 'lenient' handling to allow)",
+               ClassUtil.nameOf(handledType()), p.currentToken());
     }
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java
index 93ce417..96ef879 100644
--- a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/deser/LocalDateDeserTest.java
@@ -80,23 +80,15 @@ public class LocalDateDeserTest extends ModuleTestBase
     }
 
     @Test
-    public void testDeserializationAsString03() throws Exception
+    public void testDeserializationAsString02() throws Exception
     {
         LocalDateTime date = LocalDateTime.now();
-        LocalDate value = MAPPER.readValue('"' + date.toString() + '"', LocalDate.class);
-
-        assertNotNull("The value should not be null.", value);
-        assertEquals("The value is not correct.", date.toLocalDate(), value);
-    }
-
-    @Test(expected = JsonMappingException.class)
-    public void testDeserializationAsString04() throws Exception
-    {
-        this.MAPPER.readValue("\"2015-06-19TShouldNotParse\"", LocalDate.class);
+        assertEquals("The value is not correct.", date.toLocalDate(),
+                READER.readValue('"' + date.toString() + '"'));
     }
 
     @Test
-    public void testDeserializationAsString05() throws Exception
+    public void testDeserializationAsString03() throws Exception
     {
         Instant instant = Instant.now();
         LocalDate value = READER.readValue('"' + instant.toString() + '"');
@@ -104,25 +96,69 @@ public class LocalDateDeserTest extends ModuleTestBase
                 LocalDateTime.ofInstant(instant, ZoneOffset.UTC).toLocalDate(),
                 value);
     }
-    
+
     @Test
     public void testBadDeserializationAsString01() throws Throwable
     {
         try {
             READER.readValue(quote("notalocaldate"));
-            fail("expected DateTimeParseException");
+            fail("Should not pass");
         } catch (MismatchedInputException e) {
             verifyException(e, "Cannot deserialize value of type");
             verifyException(e, "from String \"");
         }
     }
 
+    @Test
+    public void testBadDeserializationAsString02() throws Exception
+    {
+        try {
+            READER.readValue(quote("2015-06-19TShouldNotParse"));
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Cannot deserialize value of type");
+            verifyException(e, "from String \"");
+        }
+    }
+    
     /*
     /**********************************************************
-    /* Deserialization from alternate representations
+    /* Deserialization from alternate representation: int (number
+    /* of days since Epoch)
     /**********************************************************
      */
 
+    // By default, lenient handling on so we can do this:
+    @Test
+    public void testLenientDeserializeFromInt() throws Exception
+    {
+        assertEquals("The value is not correct.", LocalDate.of(1970, Month.JANUARY, 3),
+                READER.readValue("2"));
+
+        assertEquals("The value is not correct.", LocalDate.of(1970, Month.FEBRUARY, 10),
+                READER.readValue("40"));
+    }
+
+    // But with alternate setting, not so
+    @Test
+    public void testStricDeserializeFromInt() throws Exception
+    {
+        ObjectMapper mapper = mapperBuilder()
+                .build();
+        mapper.configOverride(LocalDate.class)
+            .setFormat(JsonFormat.Value.forLeniency(false));
+        try {
+            mapper.readValue("2", LocalDate.class);
+            fail("Should not pass");
+        } catch (JsonMappingException e) {
+            verifyException(e, "Cannot deserialize instance of");
+            verifyException(e, "not allowed because 'strict' mode set for property or type");
+        }
+
+        // 17-Aug-2019, tatu: Should possibly test other mechanism too, but for now let's
+        //    be content with just one...
+    }
+
     /*
     /**********************************************************
     /* Tests for alternate array handling
