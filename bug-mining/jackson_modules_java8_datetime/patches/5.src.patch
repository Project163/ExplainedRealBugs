diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/InstantSerializerBase.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/InstantSerializerBase.java
index 0754df8..d263b31 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/InstantSerializerBase.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/InstantSerializerBase.java
@@ -113,8 +113,7 @@ public abstract class InstantSerializerBase<T extends Temporal>
     protected void _acceptTimestampVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
         throws JsonMappingException
     {
-        SerializerProvider prov = visitor.getProvider();
-        if ((prov != null) && useNanoseconds(prov)) {
+        if (useNanoseconds(visitor.getProvider())) {
             JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);
             if (v2 != null) {
                 v2.numberType(NumberType.BIG_DECIMAL);
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/JSR310FormattedSerializerBase.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/JSR310FormattedSerializerBase.java
index c88994d..adccf8d 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/JSR310FormattedSerializerBase.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/JSR310FormattedSerializerBase.java
@@ -18,6 +18,7 @@ package com.fasterxml.jackson.datatype.jsr310.ser;
 
 import java.lang.reflect.Type;
 import java.time.format.DateTimeFormatter;
+import java.util.List;
 import java.util.Locale;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
@@ -66,6 +67,14 @@ abstract class JSR310FormattedSerializerBase<T>
 
     protected final JsonFormat.Shape _shape;
 
+    /**
+     * Lazily constructed {@code JavaType} representing type
+     * {@code List<Integer>}.
+     *
+     * @since 2.10
+     */
+    protected transient volatile JavaType _integerListType;
+    
     protected JSR310FormattedSerializerBase(Class<T> supportedType) {
         this(supportedType, null);
     }
@@ -166,16 +175,14 @@ abstract class JSR310FormattedSerializerBase<T>
     public JsonNode getSchema(SerializerProvider provider, Type typeHint)
     {
         return createSchemaNode(
-                provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) ? "array" : "string", true
+            provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) ? "array" : "string", true
         );
     }
 
     @Override
     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
     {
-        SerializerProvider provider = visitor.getProvider();
-        boolean useTimestamp = (provider != null) && useTimestamp(provider);
-        if (useTimestamp) {
+        if (useTimestamp(visitor.getProvider())) {
             _acceptTimestampVisitor(visitor, typeHint);
         } else {
             JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);
@@ -188,12 +195,23 @@ abstract class JSR310FormattedSerializerBase<T>
     protected void _acceptTimestampVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
     {
         // By default, most sub-types use JSON Array, so do this:
-        JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);
+        // 28-May-2019, tatu: serialized as a List<Integer>, presumably
+        JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(_integerListType(visitor.getProvider()));
         if (v2 != null) {
             v2.itemsFormat(JsonFormatTypes.INTEGER);
         }
     }
 
+    protected JavaType _integerListType(SerializerProvider prov) {
+        JavaType t = _integerListType;
+        if (t == null) {
+            t = prov.getTypeFactory()
+                    .constructCollectionType(List.class, Integer.class);
+            _integerListType = t;
+        }
+        return t;
+    }
+    
     /**
      * Overridable method that determines {@link SerializationFeature} that is used as
      * the global default in determining if date/time value serialized should use numeric
@@ -221,7 +239,8 @@ abstract class JSR310FormattedSerializerBase<T>
             }
         }
         // assume that explicit formatter definition implies use of textual format
-        return (_formatter == null) && provider.isEnabled(getTimestampsFeature());
+        return (_formatter == null) && (provider != null)
+                && provider.isEnabled(getTimestampsFeature());
     }
 
     protected boolean _useTimestampExplicitOnly(SerializerProvider provider) {
@@ -243,6 +262,7 @@ abstract class JSR310FormattedSerializerBase<T>
                 return true;
             }
         }
-        return provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);
+        return (provider != null)
+                && provider.isEnabled(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS);
     }
 }
diff --git a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/LocalTimeSerializer.java b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/LocalTimeSerializer.java
index 9a385c9..68f2080 100644
--- a/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/LocalTimeSerializer.java
+++ b/datetime/src/main/java/com/fasterxml/jackson/datatype/jsr310/ser/LocalTimeSerializer.java
@@ -25,9 +25,13 @@ import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.core.JsonToken;
 import com.fasterxml.jackson.core.type.WritableTypeId;
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;
 import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
-
 /**
  * Serializer for Java 8 temporal {@link LocalTime}s.
  *
@@ -131,4 +135,19 @@ public class LocalTimeSerializer extends JSR310FormattedSerializerBase<LocalTime
     protected JSR310FormattedSerializerBase<?> withFeatures(Boolean writeZoneId, Boolean writeNanoseconds) {
         return new LocalTimeSerializer(this, _useTimestamp, writeNanoseconds, _formatter);
     }
+
+    // as per [modules-java8#105]
+    @Override
+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
+        throws JsonMappingException
+    {
+        if (useTimestamp(visitor.getProvider())) {
+            _acceptTimestampVisitor(visitor, typeHint);
+        } else {
+            JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);
+            if (v2 != null) {
+                v2.format(JsonValueFormat.TIME);
+            }
+        }
+    }
 }
diff --git a/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/misc/DateTimeSchemasTest.java b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/misc/DateTimeSchemasTest.java
new file mode 100644
index 0000000..428dcc2
--- /dev/null
+++ b/datetime/src/test/java/com/fasterxml/jackson/datatype/jsr310/misc/DateTimeSchemasTest.java
@@ -0,0 +1,212 @@
+package com.fasterxml.jackson.datatype.jsr310.misc;
+
+import java.time.LocalDate;
+import java.time.LocalTime;
+import java.time.ZonedDateTime;
+import java.util.*;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.jsonFormatVisitors.*;
+import com.fasterxml.jackson.datatype.jsr310.ModuleTestBase;
+
+public class DateTimeSchemasTest extends ModuleTestBase
+{
+    static class VisitorWrapper implements JsonFormatVisitorWrapper {
+        private SerializerProvider serializerProvider;
+        private final String baseName;
+        private final Map<String, String> traversedProperties;
+
+        public VisitorWrapper(SerializerProvider serializerProvider, String baseName, Map<String, String> traversedProperties) {
+            this.serializerProvider = serializerProvider;
+            this.baseName = baseName;
+            this.traversedProperties = traversedProperties;
+        }
+
+        private VisitorWrapper createSubtraverser(String bn) {
+            return new VisitorWrapper(getProvider(), bn, traversedProperties);
+        }
+
+        public Map<String, String> getTraversedProperties() {
+            return traversedProperties;
+        }
+
+        @Override
+        public JsonObjectFormatVisitor expectObjectFormat(JavaType type) throws JsonMappingException {
+            return new JsonObjectFormatVisitor.Base(serializerProvider) {
+                @Override
+                public void property(BeanProperty prop) throws JsonMappingException {
+                    anyProperty(prop);
+                }
+
+                @Override
+                public void optionalProperty(BeanProperty prop) throws JsonMappingException {
+                    anyProperty(prop);
+                }
+
+                private void anyProperty(BeanProperty prop) throws JsonMappingException {
+                    final String propertyName = prop.getFullName().toString();
+                    traversedProperties.put(baseName + propertyName, "");
+                    serializerProvider.findPrimaryPropertySerializer(prop.getType(), prop)
+                            .acceptJsonFormatVisitor(createSubtraverser(baseName + propertyName + "."), prop.getType());
+                }
+            };
+        }
+
+        @Override
+        public JsonArrayFormatVisitor expectArrayFormat(JavaType type) throws JsonMappingException {
+            traversedProperties.put(baseName, "ARRAY/"+type.getGenericSignature());
+            return null;
+        }
+
+        @Override
+        public JsonStringFormatVisitor expectStringFormat(JavaType type) throws JsonMappingException {
+            return new JsonStringFormatVisitor.Base() {
+                @Override
+                public void format(JsonValueFormat format) {
+                    traversedProperties.put(baseName, "STRING/"+format.name());
+                }
+            };
+        }
+
+        @Override
+        public JsonNumberFormatVisitor expectNumberFormat(JavaType type) throws JsonMappingException {
+            return new JsonNumberFormatVisitor.Base() {
+                @Override
+                public void numberType(JsonParser.NumberType format) {
+                    traversedProperties.put(baseName, "NUMBER/"+format.name());
+                }
+            };
+        }
+
+        @Override
+        public JsonIntegerFormatVisitor expectIntegerFormat(JavaType type) throws JsonMappingException {
+            return new JsonIntegerFormatVisitor.Base() {
+                @Override
+                public void numberType(JsonParser.NumberType format) {
+                    traversedProperties.put(baseName, "INTEGER/"+format.name());
+                }
+            };
+        }
+
+        @Override
+        public JsonBooleanFormatVisitor expectBooleanFormat(JavaType type) throws JsonMappingException {
+            traversedProperties.put(baseName, "BOOLEAN");
+            return new JsonBooleanFormatVisitor.Base();
+        }
+
+        @Override
+        public JsonNullFormatVisitor expectNullFormat(JavaType type) throws JsonMappingException {
+            return new JsonNullFormatVisitor.Base();
+        }
+
+        @Override
+        public JsonAnyFormatVisitor expectAnyFormat(JavaType type) throws JsonMappingException {
+            traversedProperties.put(baseName, "ANY");
+            return new JsonAnyFormatVisitor.Base();
+        }
+
+        @Override
+        public JsonMapFormatVisitor expectMapFormat(JavaType type) throws JsonMappingException {
+            traversedProperties.put(baseName, "MAP");
+            return new JsonMapFormatVisitor.Base(serializerProvider);
+        }
+
+        @Override
+        public SerializerProvider getProvider() {
+            return serializerProvider;
+        }
+
+        @Override
+        public void setProvider(SerializerProvider provider) {
+            this.serializerProvider = provider;
+        }
+    }
+
+    private final ObjectMapper MAPPER = newMapper();
+
+    // // // Local date/time types
+    
+    // [modules-java8#105]
+    @Test
+    public void testLocalTimeSchema() throws Exception
+    {
+        VisitorWrapper wrapper = new VisitorWrapper(null, "", new HashMap<String, String>());
+        MAPPER.writer().acceptJsonFormatVisitor(LocalTime.class, wrapper);
+        Map<String, String> properties = wrapper.getTraversedProperties();
+
+        // By default, serialized as an int array, so:
+        Assert.assertEquals(1, properties.size());
+        _verifyIntArrayType(properties.get(""));
+
+        // but becomes date/time
+        wrapper = new VisitorWrapper(null, "", new HashMap<String, String>());
+        MAPPER.writer().without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
+            .acceptJsonFormatVisitor(LocalTime.class, wrapper);
+        properties = wrapper.getTraversedProperties();
+        _verifyTimeType(properties.get(""));
+    }
+
+    @Test
+    public void testLocalDateSchema() throws Exception
+    {
+        VisitorWrapper wrapper = new VisitorWrapper(null, "", new HashMap<String, String>());
+        MAPPER.writer().acceptJsonFormatVisitor(LocalDate.class, wrapper);
+        Map<String, String> properties = wrapper.getTraversedProperties();
+
+        // By default, serialized as an int array, so:
+        Assert.assertEquals(1, properties.size());
+        _verifyIntArrayType(properties.get(""));
+
+        // but becomes date/time
+        wrapper = new VisitorWrapper(null, "", new HashMap<String, String>());
+        MAPPER.writer().without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
+            .acceptJsonFormatVisitor(LocalDate.class, wrapper);
+        properties = wrapper.getTraversedProperties();
+        _verifyDateType(properties.get(""));
+    }
+
+    // // // Zoned date/time types
+
+    @Test
+    public void testDateTimeSchema() throws Exception
+    {
+        VisitorWrapper wrapper = new VisitorWrapper(null, "", new HashMap<String, String>());
+        MAPPER.writer().acceptJsonFormatVisitor(ZonedDateTime.class, wrapper);
+        Map<String, String> properties = wrapper.getTraversedProperties();
+
+        // By default, serialized as an int array, so:
+        Assert.assertEquals(1, properties.size());
+        _verifyBigDecimalType(properties.get(""));
+
+        // but becomes date/time
+        wrapper = new VisitorWrapper(null, "", new HashMap<String, String>());
+        MAPPER.writer().without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
+            .acceptJsonFormatVisitor(ZonedDateTime.class, wrapper);
+        properties = wrapper.getTraversedProperties();
+        _verifyDateTimeType(properties.get(""));
+    }
+    
+    private void _verifyIntArrayType(String desc) {
+        Assert.assertEquals("ARRAY/Ljava/util/List<Ljava/lang/Integer;>;", desc);
+    }
+
+    private void _verifyTimeType(String desc) {
+        Assert.assertEquals("STRING/TIME", desc);
+    }
+
+    private void _verifyDateType(String desc) {
+        Assert.assertEquals("STRING/DATE", desc);
+    }
+
+    private void _verifyDateTimeType(String desc) {
+        Assert.assertEquals("STRING/DATE_TIME", desc);
+    }
+
+    private void _verifyBigDecimalType(String desc) {
+        Assert.assertEquals("NUMBER/BIG_DECIMAL", desc);
+    }
+}
