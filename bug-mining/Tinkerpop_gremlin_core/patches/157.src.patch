diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java
index 761426efe3..1010ca5fba 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java
@@ -34,6 +34,7 @@ import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversal;
 import org.apache.tinkerpop.gremlin.process.traversal.lambda.ConstantTraversal;
+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.LambdaFilterStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.event.Event;
 import org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.EventStrategy;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
@@ -274,8 +275,11 @@ public class MergeEdgeStep<S> extends MergeStep<S, Edge, Object> {
             edges = IteratorUtils.peek(edges, e -> {
 
                 // override current traverser with the matched Edge so that the option() traversal can operate
-                // on it properly
-                traverser.set((S) e);
+                // on it properly. this should only work this way for the start step form to retain the original
+                // behavior for 3.6.0 where you might do g.inject(Map).mergeE() and want that Map to pass through.
+                // in 4.x this will be rectified such that the edge will always be promoted and you will be forced
+                // to select() the map if you did want the behavior.
+                if (isStart) traverser.set((S) e);
 
                 // assume good input from GraphTraversal - folks might drop in a T here even though it is immutable
                 final Map<String, ?> onMatchMap = materializeMap(traverser, onMatchTraversal);
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java
index c9a1cf1b0d..d1166c98ce 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java
@@ -46,6 +46,7 @@ import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequire
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
 import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.Element;
 import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
@@ -142,6 +143,14 @@ public abstract class MergeStep<S, E, C> extends FlatMapStep<S, E>
         if (token == Merge.onCreate) {
             this.onCreateTraversal = this.integrateChild(traversalOption);
         } else if (token == Merge.onMatch) {
+            // add a guard rail to ensure that the incoming object is not an Element. this will prevent
+            // a possibly inadvertent mutation of the graph if you did something like g.V().mergeE(). for
+            // 3.x we won't allow this behavior at all but in 4.x we will make it consistent like it will
+            // be in 4.x
+            if (!isStart && traversalOption != null && !(traversalOption instanceof ConstantTraversal)) {
+                traversalOption.addStep(0, new GuardRailStep<>(traversalOption, getClass().getSimpleName()));
+            }
+
             this.onMatchTraversal = this.integrateChild(traversalOption);
         } else {
             throw new UnsupportedOperationException(String.format("Option %s for Merge is not supported", token.name()));
@@ -374,4 +383,30 @@ public abstract class MergeStep<S, E, C> extends FlatMapStep<S, E>
 
     protected abstract Set getAllowedTokens();
 
+    /**
+     * Guard rail to ensure that the incoming object is not an {@link Element}.
+     */
+    public static class GuardRailStep<S, E> extends ScalarMapStep<S, E> {
+        private final String stepType;
+
+        public GuardRailStep(final Traversal.Admin traversal, final String stepType) {
+            super(traversal);
+            this.stepType = stepType;
+        }
+
+        @Override
+        protected E map(final Traverser.Admin<S> t) {
+            if (t.get() instanceof Element) {
+                throw new IllegalArgumentException(
+                        String.format("The incoming traverser for %s cannot be an Element", stepType));
+            }
+            return (E) t.get();
+        }
+
+        @Override
+        public String toString() {
+            return StringFactory.stepString(this);
+        }
+    }
+
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java
index a976775a99..132adf3e7c 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java
@@ -93,8 +93,11 @@ public class MergeVertexStep<S> extends MergeStep<S, Vertex, Map> {
             // attach the onMatch properties
             vertices = IteratorUtils.peek(vertices, v -> {
 
-                // if this was a start step the traverser is initialized with Boolean/false, so override that with
-                // the matched Vertex so that the option() traversal can operate on it properly
+                // override current traverser with the matched Edge so that the option() traversal can operate
+                // on it properly. this should only work this way for the start step form to retain the original
+                // behavior for 3.6.0 where you might do g.inject(Map).mergeV() and want that Map to pass through.
+                // in 4.x this will be rectified such that the edge will always be promoted and you will be forced
+                // to select() the map if you did want the behavior.
                 if (isStart) traverser.set((S) v);
 
                 // assume good input from GraphTraversal - folks might drop in a T here even though it is immutable
