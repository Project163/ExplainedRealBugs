diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategy.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategy.java
index 4b18ef81dd..6f34d62226 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategy.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategy.java
@@ -44,6 +44,7 @@ import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.SideEffect
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.EmptyStep;
 import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;
 import org.apache.tinkerpop.gremlin.process.traversal.util.DefaultTraversal;
+import org.apache.tinkerpop.gremlin.process.traversal.util.EmptyTraversal;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.structure.Direction;
 import org.apache.tinkerpop.gremlin.structure.Edge;
@@ -58,7 +59,9 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -86,25 +89,9 @@ public final class SubgraphStrategy extends AbstractTraversalStrategy<TraversalS
     private SubgraphStrategy(final Builder builder) {
 
         this.vertexCriterion = null == builder.vertexCriterion ? null : builder.vertexCriterion.asAdmin().clone();
+        this.edgeCriterion = null == builder.edgeCriterion ? null : builder.edgeCriterion.asAdmin().clone();
         this.checkAdjacentVertices = builder.checkAdjacentVertices;
 
-        // if there is no vertex predicate there is no need to test either side of the edge - also this option can
-        // be simply configured in the builder to not be used
-        if (null == this.vertexCriterion || !checkAdjacentVertices) {
-            this.edgeCriterion = null == builder.edgeCriterion ? null : builder.edgeCriterion.asAdmin().clone();
-        } else {
-            final Traversal.Admin<Edge, ?> vertexPredicate;
-            vertexPredicate = __.<Edge>and(
-                    __.inV().filter(this.vertexCriterion),
-                    __.outV().filter(this.vertexCriterion)).asAdmin();
-
-            // if there is a vertex predicate then there is an implied edge filter on vertices even if there is no
-            // edge predicate provided by the user.
-            this.edgeCriterion = null == builder.edgeCriterion ?
-                    vertexPredicate :
-                    builder.edgeCriterion.asAdmin().clone().addStep(new TraversalFilterStep<>(builder.edgeCriterion.asAdmin(), vertexPredicate));
-        }
-
         this.vertexPropertyCriterion = null == builder.vertexPropertyCriterion ? null : builder.vertexPropertyCriterion.asAdmin().clone();
 
         if (null != this.vertexCriterion)
@@ -116,16 +103,19 @@ public final class SubgraphStrategy extends AbstractTraversalStrategy<TraversalS
     }
 
     private static void applyCriterion(final List<Step> stepsToApplyCriterionAfter, final Traversal.Admin traversal,
-                                       final Traversal.Admin<? extends Element, ?> criterion) {
+                                       final Function<Step<?,?>, Optional<Traversal.Admin<? extends Element, ?>>> criterionMaker) {
         for (final Step<?, ?> step : stepsToApplyCriterionAfter) {
             // re-assign the step label to the criterion because the label should apply seamlessly after the filter
-            final Step filter = new TraversalFilterStep<>(traversal, criterion.clone());
-            TraversalHelper.insertAfterStep(filter, step, traversal);
-            TraversalHelper.copyLabels(step, filter, true);
+            final Optional<Traversal.Admin<? extends Element, ?>> crit = criterionMaker.apply(step);
+            if (crit.isPresent()) {
+                final Step filter = new TraversalFilterStep<>(traversal, crit.get());
+                TraversalHelper.insertAfterStep(filter, step, traversal);
+                TraversalHelper.copyLabels(step, filter, true);
+            }
         }
     }
 
-    private static final char processesPropertyType(Step step) {
+    private static char processesPropertyType(Step step) {
         while (!(step instanceof EmptyStep)) {
             if (step instanceof FilterStep || step instanceof SideEffectStep)
                 step = step.getPreviousStep();
@@ -151,7 +141,6 @@ public final class SubgraphStrategy extends AbstractTraversalStrategy<TraversalS
             return;
         }
 
-        //
         final List<GraphStep> graphSteps = TraversalHelper.getStepsOfAssignableClass(GraphStep.class, traversal);
         final List<VertexStep> vertexSteps = TraversalHelper.getStepsOfAssignableClass(VertexStep.class, traversal);
         if (null != this.vertexCriterion) {
@@ -161,24 +150,49 @@ public final class SubgraphStrategy extends AbstractTraversalStrategy<TraversalS
             vertexStepsToInsertFilterAfter.addAll(TraversalHelper.getStepsOfAssignableClass(AddVertexStep.class, traversal));
             vertexStepsToInsertFilterAfter.addAll(TraversalHelper.getStepsOfAssignableClass(AddVertexStartStep.class, traversal));
             vertexStepsToInsertFilterAfter.addAll(graphSteps.stream().filter(GraphStep::returnsVertex).collect(Collectors.toList()));
-            applyCriterion(vertexStepsToInsertFilterAfter, traversal, this.vertexCriterion);
+            vertexStepsToInsertFilterAfter.addAll(vertexSteps.stream().filter(VertexStep::returnsVertex).collect(Collectors.toList()));
+            applyCriterion(vertexStepsToInsertFilterAfter, traversal, s -> Optional.of(this.vertexCriterion.clone()));
         }
 
-        if (null != this.edgeCriterion) {
+        if (null != this.edgeCriterion || checkAdjacentVertices) {
             final List<Step> edgeStepsToInsertFilterAfter = new ArrayList<>();
             edgeStepsToInsertFilterAfter.addAll(TraversalHelper.getStepsOfAssignableClass(AddEdgeStep.class, traversal));
             edgeStepsToInsertFilterAfter.addAll(graphSteps.stream().filter(GraphStep::returnsEdge).collect(Collectors.toList()));
             edgeStepsToInsertFilterAfter.addAll(vertexSteps.stream().filter(VertexStep::returnsEdge).collect(Collectors.toList()));
-            applyCriterion(edgeStepsToInsertFilterAfter, traversal, this.edgeCriterion);
+            applyCriterion(edgeStepsToInsertFilterAfter, traversal, s -> {
+                if (checkAdjacentVertices && this.vertexCriterion != null) {
+                    if (s instanceof VertexStep) {
+                        // based on the directionality of the step choose the appropriate filter direction to apply.
+                        // we scan skip AddEdgeStep, because its vertices must be in the Subgraph for it to even work.
+                        final Direction d = ((VertexStep) s).getDirection();
+                        final Traversal.Admin<Edge, ? extends Element> vertexPredicate;
+                        vertexPredicate = getVertexPredicateGivenDirection(d);
+                        return applyVertexPredicate(vertexPredicate);
+                    } else if (s instanceof GraphStep) {
+                        // for E() we need to test both incident vertices as there is no directionality
+                        final Traversal.Admin<Edge, ? extends Element> vertexPredicate = __.<Edge>and(
+                                __.inV().filter(this.vertexCriterion.clone()),
+                                __.outV().filter(this.vertexCriterion.clone())).asAdmin();
+                        return applyVertexPredicate(vertexPredicate);
+                    }
+                }
+
+                if (null == edgeCriterion)
+                    return Optional.empty();
+                else {
+                    final Traversal.Admin<Edge, ?> ec = edgeCriterion.clone();
+                    TraversalHelper.applyTraversalRecursively(t -> t.getStartStep().addLabel(MARKER), ec);
+                    return Optional.of(ec);
+                }
+            });
         }
 
-        // turn g.V().out() to g.V().outE().inV() only if there is an edge predicate otherwise
+        // turn g.V().out() to g.V().outE().inV() only if there is an edge predicate
         for (final VertexStep<?> step : vertexSteps) {
             if (step.returnsEdge())
                 continue;
-            if (null != this.vertexCriterion && null == edgeCriterion) {
-                TraversalHelper.insertAfterStep(new TraversalFilterStep<>(traversal, (Traversal) this.vertexCriterion.clone()), step, traversal);
-            } else {
+
+            if (edgeCriterion != null) {
                 final VertexStep<Edge> someEStep = new VertexStep<>(traversal, Edge.class, step.getDirection(), step.getEdgeLabels());
                 final Step<Edge, Vertex> someVStep = step.getDirection() == Direction.BOTH ?
                         new EdgeOtherVertexStep(traversal) :
@@ -188,8 +202,8 @@ public final class SubgraphStrategy extends AbstractTraversalStrategy<TraversalS
                 TraversalHelper.insertAfterStep(someVStep, someEStep, traversal);
                 TraversalHelper.copyLabels(step, someVStep, true);
 
-                if (null != this.edgeCriterion)
-                    TraversalHelper.insertAfterStep(new TraversalFilterStep<>(traversal, this.edgeCriterion.clone()), someEStep, traversal);
+                TraversalHelper.insertAfterStep(new TraversalFilterStep<>(traversal, this.edgeCriterion.clone()), someEStep, traversal);
+
                 if (null != this.vertexCriterion)
                     TraversalHelper.insertAfterStep(new TraversalFilterStep<>(traversal, this.vertexCriterion.clone()), someVStep, traversal);
             }
@@ -270,6 +284,30 @@ public final class SubgraphStrategy extends AbstractTraversalStrategy<TraversalS
         }
     }
 
+    private Optional<Traversal.Admin<? extends Element, ?>> applyVertexPredicate(final Traversal.Admin<Edge, ? extends Element> vertexPredicate) {
+        if (null == edgeCriterion) {
+            TraversalHelper.applyTraversalRecursively(t -> t.getStartStep().addLabel(MARKER), vertexPredicate);
+            return Optional.of(vertexPredicate);
+        } else {
+            final Traversal.Admin<Edge, ?> ec = edgeCriterion.clone();
+            ec.addStep(new TraversalFilterStep<>(ec, vertexPredicate));
+            TraversalHelper.applyTraversalRecursively(t -> t.getStartStep().addLabel(MARKER), ec);
+            return Optional.of(ec);
+        }
+    }
+
+    private Traversal.Admin<Edge, Vertex> getVertexPredicateGivenDirection(final Direction d) {
+        final Traversal.Admin<Edge, Vertex> vertexPredicate;
+        if (d == Direction.OUT) {
+            vertexPredicate = __.inV().filter(this.vertexCriterion.clone()).asAdmin();
+        } else if (d == Direction.IN) {
+            vertexPredicate = __.outV().filter(this.vertexCriterion.clone()).asAdmin();
+        } else {
+            vertexPredicate = __.otherV().filter(this.vertexCriterion.clone()).asAdmin();
+        }
+        return vertexPredicate;
+    }
+
     @Override
     public Configuration getConfiguration() {
         final Map<String, Object> map = new HashMap<>();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/InlineFilterStrategy.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/InlineFilterStrategy.java
index 6d71c84fa4..d2713218c5 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/InlineFilterStrategy.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/InlineFilterStrategy.java
@@ -110,10 +110,11 @@ public final class InlineFilterStrategy extends AbstractTraversalStrategy<Traver
     ////////////////////////////
     ///////////////////////////
 
-    private static final boolean processHasStep(final HasStep<?> step, final Traversal.Admin<?, ?> traversal) {
+    private static boolean processHasStep(final HasStep<?> step, final Traversal.Admin<?, ?> traversal) {
         if (step.getPreviousStep() instanceof HasStep) {
             final HasStep<?> previousStep = (HasStep<?>) step.getPreviousStep();
-            for (final HasContainer hasContainer : step.getHasContainers()) {
+            final List<HasContainer> hasContainers = new ArrayList<>(step.getHasContainers());
+            for (final HasContainer hasContainer : hasContainers) {
                 previousStep.addHasContainer(hasContainer);
             }
             TraversalHelper.copyLabels(step, previousStep, false);
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategyTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategyTest.java
index 5147e8ff9a..1d7ba5dc47 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategyTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/decoration/SubgraphStrategyTest.java
@@ -57,6 +57,7 @@ import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.has;
 import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.hasLabel;
 import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.inV;
 import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.is;
+import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.otherV;
 import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.out;
 import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.outV;
 import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.values;
@@ -82,18 +83,18 @@ public class SubgraphStrategyTest {
                     {__.bothV(), 1},
                     {__.inV(), 1},
                     {__.outV(), 1},
-                    {__.in(), 2},
-                    {__.in("test"), 2},
-                    {__.both(), 2},
-                    {__.both("test"), 2},
-                    {__.out(), 2},
-                    {__.out("test"), 2},
-                    {__.out().inE().otherV(), 4},
+                    {__.in(), 3},
+                    {__.in("test"), 3},
+                    {__.both(), 3},
+                    {__.both("test"), 3},
+                    {__.out(), 3},
+                    {__.out("test"), 3},
+                    {__.out().bothE().otherV(), 5},
                     {g.addV(), 1},
                     {g.V(1).addE("test"), 2},
-                    {__.in().out(), 4},
-                    {__.out().out().out(), 6},
-                    {__.in().out().in(), 6},
+                    {__.in().out(), 6},
+                    {__.out().out().out(), 9},
+                    {__.in().out().in(), 9},
                     {__.inE().outV().inE().outV(), 4}});
         }
 
@@ -145,9 +146,9 @@ public class SubgraphStrategyTest {
         @Parameterized.Parameters(name = "{0}")
         public static Iterable<Object[]> generateTestParameters() {
             return Arrays.asList(new Traversal[][]{
-                    {__.outE(), __.outE().hasLabel("knows").and(
-                            inV().has("name", "marko").has("age", 29),
-                            outV().has("name", "marko").has("age", 29))},
+                    {__.outE(), __.outE().hasLabel("knows").filter(inV().has("name", "marko").has("age", 29)) },
+                    {__.inE(), __.inE().hasLabel("knows").filter(outV().has("name", "marko").has("age", 29)) },
+                    {__.bothE(), __.bothE().hasLabel("knows").filter(otherV().has("name", "marko").has("age", 29)) },
                     {__.V(), __.V().has("name", "marko").has("age", 29)},
                     {__.V().has("location", "santa fe"), __.V().has("name", "marko").has("age", 29).has("location", "santa fe")},
                     {__.V().where(has("location", "santa fe")), __.V().has("name", "marko").has("age", 29).has("location", "santa fe")},
@@ -200,13 +201,13 @@ public class SubgraphStrategyTest {
             final Traversal.Admin<?, ?> t = out().inE().asAdmin();
             t.setStrategies(t.getStrategies().clone().addStrategies(strategy, StandardVerificationStrategy.instance()));
             t.applyStrategies();
-            assertEquals(t.getSteps().get(0).getClass(), VertexStep.class);
-            assertEquals(t.getSteps().get(1).getClass(), TraversalFilterStep.class);
-            assertEquals(AndStep.class, ((TraversalFilterStep<?>) t.getSteps().get(1)).getLocalChildren().get(0).getStartStep().getClass());
+            assertEquals(VertexStep.class, t.getSteps().get(0).getClass());
+            assertEquals(TraversalFilterStep.class, t.getSteps().get(1).getClass());
+            assertEquals(VertexStep.class, ((TraversalFilterStep<?>) t.getSteps().get(1)).getLocalChildren().get(0).getStartStep().getClass());
             assertEquals(0, ((TraversalFilterStep<?>) t.getSteps().get(1)).getLocalChildren().get(0).getStartStep().getLabels().size());
-            assertEquals(t.getSteps().get(2).getClass(), EdgeVertexStep.class);
-            assertEquals(t.getSteps().get(3).getClass(), TraversalFilterStep.class);
-            assertEquals(VertexStep.class, ((TraversalFilterStep<?>) t.getSteps().get(3)).getLocalChildren().get(0).getStartStep().getClass());
+            assertEquals(VertexStep.class, t.getSteps().get(2).getClass());
+            assertEquals(TraversalFilterStep.class, t.getSteps().get(3).getClass());
+            assertEquals(EdgeVertexStep.class, ((TraversalFilterStep<?>) t.getSteps().get(3)).getLocalChildren().get(0).getStartStep().getClass());
             assertEquals(0, ((TraversalFilterStep<?>) t.getSteps().get(3)).getLocalChildren().get(0).getStartStep().getLabels().size());
             TraversalHelper.getStepsOfAssignableClassRecursively(Step.class, t).forEach(step -> assertTrue(step.getLabels().isEmpty()));
         }
