diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/remote/traversal/AbstractRemoteTraversal.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/remote/traversal/AbstractRemoteTraversal.java
index 363de6eea3..d4583d3981 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/remote/traversal/AbstractRemoteTraversal.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/remote/traversal/AbstractRemoteTraversal.java
@@ -127,6 +127,11 @@ public abstract class AbstractRemoteTraversal<S,E> implements RemoteTraversal<S,
         throw new UnsupportedOperationException("Remote traversals do not support this method");
     }
 
+    @Override
+    public void lock() {
+        throw new UnsupportedOperationException("Remote traversals do not support this method");
+    }
+
     @Override
     public Optional<Graph> getGraph() {
         throw new UnsupportedOperationException("Remote traversals do not support this method");
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Traversal.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Traversal.java
index da221d5ed6..494ba58f60 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Traversal.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Traversal.java
@@ -543,7 +543,12 @@ public interface Traversal<S, E> extends Iterator<E>, Serializable, Cloneable, A
         public boolean isLocked();
 
         /**
-         * Gets the {@link Graph} instance associated to this {@link Traversal}.
+         * Lock the traversal and perform any final adjustments to it after strategy application.
+         */
+        public void lock();
+
+        /**
+         * Gets the {@link Graph} instance associated directly to this {@link Traversal} or through its parent.
          */
         public Optional<Graph> getGraph();
 
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/lambda/AbstractLambdaTraversal.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/lambda/AbstractLambdaTraversal.java
index ac8919fff5..7f84469ee1 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/lambda/AbstractLambdaTraversal.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/lambda/AbstractLambdaTraversal.java
@@ -31,6 +31,7 @@ import org.apache.tinkerpop.gremlin.process.traversal.traverser.B_O_TraverserGen
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
 import org.apache.tinkerpop.gremlin.process.traversal.util.EmptyTraversalSideEffects;
 import org.apache.tinkerpop.gremlin.process.traversal.util.EmptyTraversalStrategies;
+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.structure.Graph;
 
 import java.util.Collections;
@@ -170,6 +171,11 @@ public abstract class AbstractLambdaTraversal<S, E> implements Traversal.Admin<S
         return null == this.bypassTraversal || this.bypassTraversal.isLocked();
     }
 
+    @Override
+    public void lock() {
+       if (this.bypassTraversal != null) bypassTraversal.lock();
+    }
+
     /**
      * Implementations of this class can never be a root-level traversal as they are specialized implementations
      * intended to be child traversals by design.
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java
index 4f314dcf8b..499fa26551 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java
@@ -121,63 +121,20 @@ public class DefaultTraversal<S, E> implements Traversal.Admin<S, E> {
     @Override
     public void applyStrategies() throws IllegalStateException {
         if (this.locked) throw Traversal.Exceptions.traversalIsLocked();
-        TraversalHelper.reIdSteps(this.stepPosition, this);
-        final boolean hasGraph = null != this.graph;
-
-        // we only want to apply strategies on the top-level step or if we got some graphcomputer stuff going on.
-        // seems like in that case, the "top-level" of the traversal is really held by the VertexProgramStep which
-        // needs to have strategies applied on "pure" copies of the traversal it is holding (i think). it further
-        // seems that we need three recursions over the traversal hierarchy to ensure everything "works", where
-        // strategy application requires top-level strategies and side-effects pushed into each child and then after
-        // application of the strategies we need to call applyStrategies() on all the children to ensure that their
-        // steps get reId'd and traverser requirements are set.
-        if (isRoot() || this.getParent() instanceof VertexProgramStep) {
 
-            // prepare the traversal and all its children for strategy application
-            TraversalHelper.applyTraversalRecursively(t -> {
-                if (hasGraph) t.setGraph(this.graph);
-                t.setStrategies(this.strategies);
-                t.setSideEffects(this.sideEffects);
-            }, this);
-
-            // note that prior to applying strategies to children we used to set side-effects and strategies of all
-            // children to that of the parent. under this revised model of strategy application from TINKERPOP-1568
-            // it doesn't appear to be necessary to do that (at least from the perspective of the test suite). by,
-            // moving side-effect setting after actual recursive strategy application we save a loop and by
-            // consequence also fix a problem where strategies might reset something in sideeffects which seems to
-            // happen in TranslationStrategy.
+        // apply strategies in order on a root traversal only or a traversal that is logically considered a root
+        // for GraphComputer as a child of VertexProgramStep.
+        if (isRoot() || this.getParent() instanceof VertexProgramStep) {
             final Iterator<TraversalStrategy<?>> strategyIterator = this.strategies.iterator();
             while (strategyIterator.hasNext()) {
                 final TraversalStrategy<?> strategy = strategyIterator.next();
-                TraversalHelper.applyTraversalRecursively(t -> {
-                    strategy.apply(t);
-
-                    // after the strategy is applied, it may have modified the traversal where a new traversal object
-                    // was added. if the strategy didn't set the Graph object it could leave that new traversal in a
-                    // state where another strategy might fail if that dependency is not satisfied
-                    TraversalHelper.applyTraversalRecursively(i -> {
-                        if (hasGraph) i.setGraph(this.graph);
-                    }, this);
-                }, this);
+                TraversalHelper.applyTraversalRecursively(strategy::apply, this);
             }
-
-            // don't need to re-apply strategies to "this" - leads to endless recursion in GraphComputer.
-            TraversalHelper.applyTraversalRecursively(t -> {
-                if (hasGraph) t.setGraph(this.graph);
-                if(!(t.isRoot()) && t != this && !t.isLocked()) {
-                    t.setSideEffects(this.sideEffects);
-                    t.applyStrategies();
-                }
-            }, this);
         }
-        
-        this.finalEndStep = this.getEndStep();
 
-        // finalize requirements
-        if (this.isRoot()) {
-            resetTraverserRequirements();
-        }
-        this.locked = true;
+        // lock the traversal and its children for execution, finalizing the copy of any data from parent to child
+        // as needed
+        this.lock();
     }
 
     private void resetTraverserRequirements() {
@@ -337,6 +294,45 @@ public class DefaultTraversal<S, E> implements Traversal.Admin<S, E> {
         return this.locked;
     }
 
+    /**
+     * Allow the locked property of the traversal to be directly set by those who know what they are doing. Are you
+     * sure you know what you're doing?
+     */
+    public void setLocked(final boolean locked) {
+        this.locked = locked;
+    }
+
+    @Override
+    public void lock() {
+        TraversalHelper.reIdSteps(stepPosition, this);
+
+        // normalize strategies, side-effects, and Graph through children. obviously ignore the root traversal, since
+        // there is no parent to draw data from and ignore stuff wrapped for GraphComputer execution and the root
+        // from which to draw child data from is logically the current traversal.
+        if (!isRoot() && !(parent instanceof VertexProgramStep)) {
+            final TraversalParent parent = getParent();
+            final Traversal.Admin parentTraversal = parent.asStep().getTraversal().asAdmin();
+            this.setStrategies(parentTraversal.getStrategies());
+            this.setSideEffects(parentTraversal.getSideEffects());
+
+            // not sure why java is complaining about generics here that i have to do this??
+            if (parentTraversal.getGraph().isPresent())
+                this.setGraph((Graph) parentTraversal.getGraph().get());
+        }
+
+        this.finalEndStep = this.getEndStep();
+
+        if (this.isRoot()) {
+            resetTraverserRequirements();
+        }
+
+        // lock the parent before the children
+        this.locked = true;
+
+        // now lock all the children
+        TraversalHelper.applyTraversalRecursively(Admin::lock, this, true);
+    }
+
     /**
      * Determines if the traversal has been fully iterated and resources released.
      */
@@ -408,7 +404,13 @@ public class DefaultTraversal<S, E> implements Traversal.Admin<S, E> {
 
     @Override
     public Optional<Graph> getGraph() {
-        return Optional.ofNullable(this.graph);
+        final Optional<Graph> optionalGraph =  Optional.ofNullable(this.graph);
+        if (!optionalGraph.isPresent() || optionalGraph.get() == EmptyGraph.instance()) {
+            final TraversalParent parent = getParent();
+            if (parent != EmptyStep.instance())
+                return parent.asStep().getTraversal().getGraph();
+        }
+        return optionalGraph;
     }
 
     @Override
@@ -420,7 +422,7 @@ public class DefaultTraversal<S, E> implements Traversal.Admin<S, E> {
     public void setGraph(final Graph graph) {
         this.graph = graph;
     }
-    
+
     @Override
     public boolean equals(final Object other) {
         return other != null && other.getClass().equals(this.getClass()) && this.equals(((Traversal.Admin) other));
@@ -435,4 +437,4 @@ public class DefaultTraversal<S, E> implements Traversal.Admin<S, E> {
         }
         return result;
     }
-}
+}
\ No newline at end of file
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/EmptyTraversal.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/EmptyTraversal.java
index d3f6215a5a..2b94b85276 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/EmptyTraversal.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/EmptyTraversal.java
@@ -112,6 +112,11 @@ public final class EmptyTraversal<S, E> implements Traversal.Admin<S, E> {
         return true;
     }
 
+    @Override
+    public void lock() {
+        // nothing to do here as this type of traversal is always in a locked state
+    }
+
     @Override
     public TraverserGenerator getTraverserGenerator() {
         return null;
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java
index 2099ff85b6..9625a56174 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java
@@ -488,7 +488,19 @@ public final class TraversalHelper {
      * @param traversal the root traversal to start application
      */
     public static void applyTraversalRecursively(final Consumer<Traversal.Admin<?, ?>> consumer, final Traversal.Admin<?, ?> traversal) {
-        consumer.accept(traversal);
+        applyTraversalRecursively(consumer, traversal, false);
+    }
+
+    /**
+     * Apply the provider {@link Consumer} function to the provided {@link Traversal} and all of its children.
+     *
+     * @param consumer  the function to apply to the each traversal in the tree
+     * @param traversal the root traversal to start application
+     */
+    public static void applyTraversalRecursively(final Consumer<Traversal.Admin<?, ?>> consumer, final Traversal.Admin<?, ?> traversal,
+                                                 final boolean applyToChildrenOnly) {
+        if (!applyToChildrenOnly)
+            consumer.accept(traversal);
 
         // we get accused of concurrentmodification if we try a for(Iterable)
         final List<Step> steps = traversal.getSteps();
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/TraversalTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/TraversalTest.java
index 05b1f6a17d..b7c352e23a 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/TraversalTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/TraversalTest.java
@@ -360,6 +360,11 @@ public class TraversalTest {
             return false;
         }
 
+        @Override
+        public void lock() {
+
+        }
+
         @Override
         public Optional<Graph> getGraph() {
             return null;
