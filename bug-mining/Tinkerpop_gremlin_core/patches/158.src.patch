diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java
index 84c4c3c06d..4cc91d5326 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeEdgeStep.java
@@ -275,11 +275,11 @@ public class MergeEdgeStep<S> extends MergeStep<S, Edge, Object> {
             edges = IteratorUtils.peek(edges, e -> {
 
                 // override current traverser with the matched Edge so that the option() traversal can operate
-                // on it properly. this should only work this way for the start step form to retain the original
-                // behavior for 3.6.0 where you might do g.inject(Map).mergeE() and want that Map to pass through.
-                // in 4.x this will be rectified such that the edge will always be promoted and you will be forced
-                // to select() the map if you did want the behavior.
-                if (isStart) traverser.set((S) e);
+                // on it properly. prior to 4.x this only worked for start steps, but now it works consistently
+                // with mid-traversal usage. this breaks past behavior like g.inject(Map).mergeE() where you
+                // could operate on the Map directly with the child traversal. from 4.x onward you will have to do
+                // something like g.inject(Map).as('a').mergeE().option(onMatch, select('a'))
+                traverser.set((S) e);
 
                 // assume good input from GraphTraversal - folks might drop in a T here even though it is immutable
                 final Map<String, ?> onMatchMap = materializeMap(traverser, onMatchTraversal);
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java
index d1166c98ce..c185308133 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeStep.java
@@ -143,14 +143,6 @@ public abstract class MergeStep<S, E, C> extends FlatMapStep<S, E>
         if (token == Merge.onCreate) {
             this.onCreateTraversal = this.integrateChild(traversalOption);
         } else if (token == Merge.onMatch) {
-            // add a guard rail to ensure that the incoming object is not an Element. this will prevent
-            // a possibly inadvertent mutation of the graph if you did something like g.V().mergeE(). for
-            // 3.x we won't allow this behavior at all but in 4.x we will make it consistent like it will
-            // be in 4.x
-            if (!isStart && traversalOption != null && !(traversalOption instanceof ConstantTraversal)) {
-                traversalOption.addStep(0, new GuardRailStep<>(traversalOption, getClass().getSimpleName()));
-            }
-
             this.onMatchTraversal = this.integrateChild(traversalOption);
         } else {
             throw new UnsupportedOperationException(String.format("Option %s for Merge is not supported", token.name()));
@@ -383,30 +375,4 @@ public abstract class MergeStep<S, E, C> extends FlatMapStep<S, E>
 
     protected abstract Set getAllowedTokens();
 
-    /**
-     * Guard rail to ensure that the incoming object is not an {@link Element}.
-     */
-    public static class GuardRailStep<S, E> extends ScalarMapStep<S, E> {
-        private final String stepType;
-
-        public GuardRailStep(final Traversal.Admin traversal, final String stepType) {
-            super(traversal);
-            this.stepType = stepType;
-        }
-
-        @Override
-        protected E map(final Traverser.Admin<S> t) {
-            if (t.get() instanceof Element) {
-                throw new IllegalArgumentException(
-                        String.format("The incoming traverser for %s cannot be an Element", stepType));
-            }
-            return (E) t.get();
-        }
-
-        @Override
-        public String toString() {
-            return StringFactory.stepString(this);
-        }
-    }
-
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java
index 6adc458fd1..c1d4d95547 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/MergeVertexStep.java
@@ -94,12 +94,12 @@ public class MergeVertexStep<S> extends MergeStep<S, Vertex, Map> {
             // attach the onMatch properties
             vertices = IteratorUtils.peek(vertices, v -> {
 
-                // override current traverser with the matched Edge so that the option() traversal can operate
-                // on it properly. this should only work this way for the start step form to retain the original
-                // behavior for 3.6.0 where you might do g.inject(Map).mergeV() and want that Map to pass through.
-                // in 4.x this will be rectified such that the edge will always be promoted and you will be forced
-                // to select() the map if you did want the behavior.
-                if (isStart) traverser.set((S) v);
+                // override current traverser with the matched Vertex so that the option() traversal can operate
+                // on it properly. prior to 4.x this only worked for start steps, but now it works consistently
+                // with mid-traversal usage. this breaks past behavior like g.inject(Map).mergeV() where you
+                // could operate on the Map directly with the child traversal. from 4.x onward you will have to do
+                // something like g.inject(Map).as('a').mergeV().option(onMatch, select('a'))
+                traverser.set((S) v);
 
                 // assume good input from GraphTraversal - folks might drop in a T here even though it is immutable
                 final Map<String, Object> onMatchMap = materializeMap(traverser, onMatchTraversal);
