diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDsl.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDsl.java
index d3a807f2f3..700c8ee0cb 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDsl.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDsl.java
@@ -74,4 +74,24 @@ public @interface GremlinDsl {
      * </ul>
      */
     public boolean generateDefaultMethods() default true;
+
+    /**
+     * Annotation that allows the user to directly override the type parameters on generated anonymous methods. If this
+     * annotation is not specified then the processor will attempt to infer the correct type parameters to use when
+     * generating the anonymous method representations of the DSL methods.
+     */
+    @Target(ElementType.METHOD)
+    @Retention(RetentionPolicy.CLASS)
+    public @interface AnonymousMethod {
+
+        /**
+         * The type parameters to apply to the return type of the method applied in the order that they are specified.
+         */
+        public String[] returnTypeParameters() default {};
+
+        /**
+         * The type parameters to apply to the method in the order that they are specified.
+         */
+        public String[] methodTypeParameters() default {};
+    }
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDslProcessor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDslProcessor.java
index 470dd4bc1c..cdfad6a16b 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDslProcessor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/dsl/GremlinDslProcessor.java
@@ -61,9 +61,11 @@ import javax.tools.Diagnostic;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 /**
  * A custom Java annotation processor for the {@link GremlinDsl} annotation that helps to generate DSLs classes.
@@ -135,24 +137,39 @@ public class GremlinDslProcessor extends AbstractProcessor {
 
         // process the methods of the GremlinDsl annotated class
         for (ExecutableElement templateMethod : findMethodsOfElement(ctx.annotatedDslType, null)) {
+            final Optional<GremlinDsl.AnonymousMethod> methodAnnotation = Optional.ofNullable(templateMethod.getAnnotation(GremlinDsl.AnonymousMethod.class));
+
             final String methodName = templateMethod.getSimpleName().toString();
 
-            final TypeName returnType = getReturnTypeDefinition(ctx.traversalClassName, templateMethod);
+            // either use the direct return type of the DSL specification or override it with specification from
+            // GremlinDsl.AnonymousMethod
+            final TypeName returnType = methodAnnotation.isPresent() && methodAnnotation.get().returnTypeParameters().length > 0 ?
+                    getOverridenReturnTypeDefinition(ctx.traversalClassName, methodAnnotation.get().returnTypeParameters()) :
+                    getReturnTypeDefinition(ctx.traversalClassName, templateMethod);
+            
             final MethodSpec.Builder methodToAdd = MethodSpec.methodBuilder(methodName)
                     .addModifiers(Modifier.STATIC, Modifier.PUBLIC)
                     .addExceptions(templateMethod.getThrownTypes().stream().map(TypeName::get).collect(Collectors.toList()))
                     .returns(returnType);
 
-            templateMethod.getTypeParameters().forEach(tp -> methodToAdd.addTypeVariable(TypeVariableName.get(tp)));
-
-            // might have to deal with an "S" (in __ it's usually an "A") - how to make this less bound to that convention?
-            final List<? extends TypeMirror> returnTypeArguments = getTypeArguments(templateMethod);
-            returnTypeArguments.stream().filter(rtm -> rtm instanceof TypeVariable).forEach(rtm -> {
-                if (((TypeVariable) rtm).asElement().getSimpleName().contentEquals("S"))
-                    methodToAdd.addTypeVariable(TypeVariableName.get(((TypeVariable) rtm).asElement().getSimpleName().toString()));
-            });
+            // either use the method type parameter specified from the GremlinDsl.AnonymousMethod or just infer them
+            // from the DSL specification. "inferring" relies on convention and sometimes doesn't work for all cases.
+            final String startGeneric = methodAnnotation.isPresent() && methodAnnotation.get().methodTypeParameters().length > 0 ?
+                    methodAnnotation.get().methodTypeParameters()[0] : "S";
+            if (methodAnnotation.isPresent() && methodAnnotation.get().methodTypeParameters().length > 0)
+                Stream.of(methodAnnotation.get().methodTypeParameters()).map(TypeVariableName::get).forEach(methodToAdd::addTypeVariable);
+            else {
+                templateMethod.getTypeParameters().forEach(tp -> methodToAdd.addTypeVariable(TypeVariableName.get(tp)));
+
+                // might have to deal with an "S" (in __ it's usually an "A") - how to make this less bound to that convention?
+                final List<? extends TypeMirror> returnTypeArguments = getTypeArguments(templateMethod);
+                returnTypeArguments.stream().filter(rtm -> rtm instanceof TypeVariable).forEach(rtm -> {
+                    if (((TypeVariable) rtm).asElement().getSimpleName().contentEquals("S"))
+                        methodToAdd.addTypeVariable(TypeVariableName.get(((TypeVariable) rtm).asElement().getSimpleName().toString()));
+                });
+            }
 
-            addMethodBody(methodToAdd, templateMethod, "return __.<S>start().$L(", ")", methodName);
+            addMethodBody(methodToAdd, templateMethod, "return __.<" + startGeneric + ">start().$L(", ")", methodName);
             anonymousClass.addMethod(methodToAdd.build());
         }
 
@@ -425,6 +442,27 @@ public class GremlinDslProcessor extends AbstractProcessor {
         methodToAdd.addStatement(body, statementArgs);
     }
 
+    private TypeName getOverridenReturnTypeDefinition(final ClassName returnClazz, final String[] typeValues) {
+        return ParameterizedTypeName.get(returnClazz, Stream.of(typeValues).map(tv -> {
+            try {
+                return ClassName.get(Class.forName(tv));
+            } catch (ClassNotFoundException cnfe) {
+                if (tv.contains("extends")) {
+                    final String[] sides = tv.toString().split(" extends ");
+                    final TypeVariableName name = TypeVariableName.get(sides[0]);
+                    try {
+                        name.withBounds(ClassName.get(Class.forName(sides[1])));
+                    } catch (Exception ex) {
+                        name.withBounds(TypeVariableName.get(sides[1]));
+                    }
+                    return name;
+                } else {
+                    return TypeVariableName.get(tv);
+                }
+            }
+        }).collect(Collectors.toList()).toArray(new TypeName[typeValues.length]));
+    }
+
     private TypeName getReturnTypeDefinition(final ClassName returnClazz, final ExecutableElement templateMethod) {
         final List<? extends TypeMirror> returnTypeArguments = getTypeArguments(templateMethod);
 
diff --git a/gremlin-core/src/test/resources/org/apache/tinkerpop/gremlin/process/traversal/dsl/SocialTraversalDsl.java b/gremlin-core/src/test/resources/org/apache/tinkerpop/gremlin/process/traversal/dsl/SocialTraversalDsl.java
index 4c3133063f..66db1289a1 100644
--- a/gremlin-core/src/test/resources/org/apache/tinkerpop/gremlin/process/traversal/dsl/SocialTraversalDsl.java
+++ b/gremlin-core/src/test/resources/org/apache/tinkerpop/gremlin/process/traversal/dsl/SocialTraversalDsl.java
@@ -18,9 +18,9 @@
  */
 package org.apache.tinkerpop.gremlin.process.traversal.dsl;
 
-import org.apache.tinkerpop.gremlin.process.traversal.dsl.GremlinDsl;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversal;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
+import org.apache.tinkerpop.gremlin.process.traversal.P;
 
 /**
  * @author Stephen Mallette (http://stephen.genoprime.com)
@@ -28,10 +28,25 @@ import org.apache.tinkerpop.gremlin.structure.Vertex;
 @GremlinDsl
 public interface SocialTraversalDsl<S, E> extends GraphTraversal.Admin<S, E> {
     public default GraphTraversal<S, Vertex> knows(final String personName) {
-        return out("knows").hasLabel("person").has("name", personName);
+        return ((SocialTraversalDsl) out("knows")).person().has("name", personName);
     }
 
     public default <E2 extends Number> GraphTraversal<S, E2> meanAgeOfFriends() {
+        return ((SocialTraversalDsl) out("knows")).person().values("age").mean();
+    }
+
+    @GremlinDsl.AnonymousMethod(returnTypeParameters = {"A", "A"}, methodTypeParameters = {"A"})
+    public default GraphTraversal<S, E> person() {
+        return hasLabel("person");
+    }
+
+    @GremlinDsl.AnonymousMethod(returnTypeParameters = {"A", "org.apache.tinkerpop.gremlin.structure.Vertex"}, methodTypeParameters = {"A"})
+    public default GraphTraversal<S, Vertex> knowsOverride(final String personName) {
+        return out("knows").hasLabel("person").has("name", personName);
+    }
+
+    @GremlinDsl.AnonymousMethod(returnTypeParameters = {"A", "E2"}, methodTypeParameters = {"A", "E2 extends java.lang.Number"})
+    public default <E2 extends Number> GraphTraversal<S, E2> meanAgeOfFriendsOverride() {
         return out("knows").hasLabel("person").values("age").mean();
     }
 }
