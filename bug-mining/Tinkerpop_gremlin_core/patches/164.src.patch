diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/util/ComputerGraph.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/util/ComputerGraph.java
index 77453fe14b..26b3e595e8 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/util/ComputerGraph.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/util/ComputerGraph.java
@@ -49,7 +49,7 @@ import java.util.stream.Collectors;
  */
 public final class ComputerGraph implements Graph {
 
-    private enum State {VERTEX_PROGRAM, MAP_REDUCE}
+    public enum State {VERTEX_PROGRAM, MAP_REDUCE}
 
     private ComputerVertex starVertex;
     private final Set<String> computeKeys;
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Barrier.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Barrier.java
index 9ee9e5f9b1..e3381e689f 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Barrier.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Barrier.java
@@ -73,4 +73,11 @@ public interface Barrier<B> extends MemoryComputing<B> {
     public default void done() {
 
     }
+
+    /**
+     * If a barrier is unproductive then provide an empty object suitable to the implementation which can be used
+     * to represent that state. This is important for cases like {@code by(out().order().fold())} where the
+     * {@code order()} might filter but the {@code fold()} means the traversal is productive.
+     */
+    public B getEmptyBarrier();
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/FilteringBarrier.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/FilteringBarrier.java
new file mode 100644
index 0000000000..917f69161d
--- /dev/null
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/FilteringBarrier.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.process.traversal.step;
+
+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.RangeGlobalStep;
+
+/**
+ * Marker interface for a {@link Barrier} that can behave as a filter, like {@link RangeGlobalStep}
+ */
+public interface FilteringBarrier<S> extends Barrier<S> {
+}
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Grouping.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Grouping.java
index 0f3c1ff7d8..64d6052b2b 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Grouping.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/Grouping.java
@@ -56,6 +56,13 @@ public interface Grouping<S, K, V> {
         return null != determineBarrierStep(getValueTraversal());
     }
 
+    /**
+     * The first non-local {@link Barrier} step ascertained by calls to {@link #determineBarrierStep(Traversal.Admin)}
+     * is cached for a {@code Grouping}. After strategy application it is important that the cache be reset to ensure
+     * that any modifications to the child traversal are accounted for.
+     */
+    public void resetBarrierFromValueTraversal();
+
     /**
      * Determines the first non-local {@link Barrier} step in the provided traversal. This method is used by {@link GroupStep}
      * and {@link GroupSideEffectStep} to ultimately determine the reducing bi-operator.
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/LocalBarrier.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/LocalBarrier.java
index 899c43b8f3..0b7869617b 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/LocalBarrier.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/LocalBarrier.java
@@ -33,4 +33,8 @@ public interface LocalBarrier<S> extends Barrier<TraverserSet<S>> {
         return MemoryComputeKey.of(((Step) this).getId(), Operator.and, false, true);
     }
 
+    @Override
+    default TraverserSet<S> getEmptyBarrier() {
+        return new TraverserSet<>();
+    }
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java
index a8a1015721..13ec2b8d25 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java
@@ -40,8 +40,13 @@ public interface ProfilingAware {
 
     /**
      * Prepares the step for any internal changes that might help ensure that profiling will work as expected.
+     * @deprecated As of release 3.8.0, not directly replaced because a simple call to {@link Step#reset()} at traversal
+     * lock can more generally do what is needed by this much more specific API.
      */
-    public void prepareForProfiling();
+    @Deprecated
+    public default void prepareForProfiling() {
+
+    }
 
     /**
      * A helper class which holds a {@link Barrier} and it's related {@link ProfileStep} so that the latter can have
@@ -85,6 +90,11 @@ public interface ProfilingAware {
             this.barrier.addBarrier(barrier);
         }
 
+        @Override
+        public Object getEmptyBarrier() {
+            return new Object();
+        }
+
         @Override
         public MemoryComputeKey getMemoryComputeKey() {
             return this.barrier.getMemoryComputeKey();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/DedupGlobalStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/DedupGlobalStep.java
index 9f5b0e5f5c..16d7ee4657 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/DedupGlobalStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/DedupGlobalStep.java
@@ -23,14 +23,13 @@ import org.apache.tinkerpop.gremlin.process.traversal.Operator;
 import org.apache.tinkerpop.gremlin.process.traversal.Pop;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
-import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;
+import org.apache.tinkerpop.gremlin.process.traversal.step.FilteringBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.GraphComputing;
 import org.apache.tinkerpop.gremlin.process.traversal.step.PathProcessor;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Scoping;
 import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
-import org.apache.tinkerpop.gremlin.process.traversal.util.FastNoSuchElementException;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalProduct;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
 import org.apache.tinkerpop.gremlin.structure.Property;
@@ -53,7 +52,8 @@ import java.util.function.BinaryOperator;
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public final class DedupGlobalStep<S> extends FilterStep<S> implements TraversalParent, Scoping, GraphComputing, Barrier<Map<Object, Traverser.Admin<S>>>, ByModulating, PathProcessor {
+public final class DedupGlobalStep<S> extends FilterStep<S> implements TraversalParent, Scoping, GraphComputing,
+        FilteringBarrier<Map<Object, Traverser.Admin<S>>>, ByModulating, PathProcessor {
 
     private Traversal.Admin<S, Object> dedupTraversal = null;
     private Set<Object> duplicateSet = new HashSet<>();
@@ -191,6 +191,11 @@ public final class DedupGlobalStep<S> extends FilterStep<S> implements Traversal
 
     }
 
+    @Override
+    public Map<Object, Traverser.Admin<S>> getEmptyBarrier() {
+        return new HashMap<>();
+    }
+
     @Override
     public boolean hasNextBarrier() {
         return null != this.barrier || this.starts.hasNext();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/RangeGlobalStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/RangeGlobalStep.java
index 9824332785..a0bf19489d 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/RangeGlobalStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/RangeGlobalStep.java
@@ -21,13 +21,12 @@ package org.apache.tinkerpop.gremlin.process.traversal.step.filter;
 import org.apache.tinkerpop.gremlin.process.computer.MemoryComputeKey;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
-import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Bypassing;
+import org.apache.tinkerpop.gremlin.process.traversal.step.FilteringBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Ranging;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.util.TraverserSet;
 import org.apache.tinkerpop.gremlin.process.traversal.util.FastNoSuchElementException;
-import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;
 import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
 import org.apache.tinkerpop.gremlin.util.iterator.IteratorUtils;
 
@@ -42,7 +41,7 @@ import java.util.function.BinaryOperator;
  * @author Bob Briody (http://bobbriody.com)
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public final class RangeGlobalStep<S> extends FilterStep<S> implements Ranging, Bypassing, Barrier<TraverserSet<S>> {
+public final class RangeGlobalStep<S> extends FilterStep<S> implements Ranging, Bypassing, FilteringBarrier<TraverserSet<S>> {
 
     private long low;
     private final long high;
@@ -155,6 +154,11 @@ public final class RangeGlobalStep<S> extends FilterStep<S> implements Ranging,
 
     }
 
+    @Override
+    public TraverserSet<S> getEmptyBarrier() {
+        return new TraverserSet<>();
+    }
+
     @Override
     public boolean hasNextBarrier() {
         return this.starts.hasNext();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/TailGlobalStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/TailGlobalStep.java
index cc746c8bb3..c6493ed80e 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/TailGlobalStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/filter/TailGlobalStep.java
@@ -21,8 +21,8 @@ package org.apache.tinkerpop.gremlin.process.traversal.step.filter;
 import org.apache.tinkerpop.gremlin.process.computer.MemoryComputeKey;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
-import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Bypassing;
+import org.apache.tinkerpop.gremlin.process.traversal.step.FilteringBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.AbstractStep;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.util.TraverserSet;
@@ -39,7 +39,7 @@ import java.util.Set;
 /**
  * @author Matt Frantz (http://github.com/mhfrantz)
  */
-public final class TailGlobalStep<S> extends AbstractStep<S, S> implements Bypassing, Barrier<TraverserSet<S>> {
+public final class TailGlobalStep<S> extends AbstractStep<S, S> implements Bypassing, FilteringBarrier<TraverserSet<S>> {
 
     private final long limit;
     private Deque<Traverser.Admin<S>> tail;
@@ -137,6 +137,11 @@ public final class TailGlobalStep<S> extends AbstractStep<S, S> implements Bypas
 
     }
 
+    @Override
+    public TraverserSet<S> getEmptyBarrier() {
+        return new TraverserSet<>();
+    }
+
     @Override
     public boolean hasNextBarrier() {
         return this.starts.hasNext();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java
index ff7ba1c99d..c34e73d4ad 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java
@@ -20,17 +20,19 @@
 package org.apache.tinkerpop.gremlin.process.traversal.step.map;
 
 import org.apache.tinkerpop.gremlin.process.traversal.Operator;
+import org.apache.tinkerpop.gremlin.process.traversal.Step;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
+import org.apache.tinkerpop.gremlin.process.traversal.step.FilteringBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Grouping;
-import org.apache.tinkerpop.gremlin.process.traversal.step.ProfilingAware;
 import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;
 import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
-import org.apache.tinkerpop.gremlin.process.traversal.step.util.ProfileStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.ReducingBarrierStep;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.SupplyingBarrierStep;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
 import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
 import org.apache.tinkerpop.gremlin.util.function.HashMapSupplier;
@@ -47,13 +49,12 @@ import java.util.function.BinaryOperator;
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
 public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>>
-        implements ByModulating, TraversalParent, ProfilingAware, Grouping<S, K, V> {
+        implements ByModulating, TraversalParent, Grouping<S, K, V> {
 
     private char state = 'k';
     private Traversal.Admin<S, K> keyTraversal;
     private Traversal.Admin<S, V> valueTraversal;
     private Barrier barrierStep;
-    private boolean resetBarrierForProfiling = false;
 
     public GroupStep(final Traversal.Admin traversal) {
         super(traversal);
@@ -63,15 +64,6 @@ public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>>
         this.setSeedSupplier(HashMapSupplier.instance());
     }
 
-    /**
-     * Reset the {@link Barrier} on the step to be wrapped in a {@link ProfiledBarrier} which can properly start/stop
-     * the timer on the associated {@link ProfileStep}.
-     */
-    @Override
-    public void prepareForProfiling() {
-        resetBarrierForProfiling = barrierStep != null;
-    }
-
     @Override
     public Traversal.Admin<S, K> getKeyTraversal() {
         return this.keyTraversal;
@@ -88,6 +80,12 @@ public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>>
         this.setReducingBiOperator(new GroupBiOperator<>(null == this.barrierStep ? Operator.assign : this.barrierStep.getMemoryComputeKey().getReducer()));
     }
 
+    @Override
+    public void resetBarrierFromValueTraversal() {
+        this.barrierStep = determineBarrierStep(this.valueTraversal);
+        this.setReducingBiOperator(new GroupBiOperator<>(null == this.barrierStep ? Operator.assign : this.barrierStep.getMemoryComputeKey().getReducer()));
+    }
+
     @Override
     public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {
         if ('k' == this.state) {
@@ -115,22 +113,26 @@ public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>>
         this.valueTraversal.reset();
         this.valueTraversal.addStart(traverser);
 
-        // reset the barrierStep as there are now ProfileStep instances present and the timers won't start right
-        // without specific configuration through wrapping both the Barrier and ProfileStep in ProfiledBarrier
-        if (resetBarrierForProfiling) {
-            barrierStep = determineBarrierStep(valueTraversal);
-
-            // the barrier only needs to be reset once
-            resetBarrierForProfiling = false;
-        }
-
         TraversalUtil.produce(traverser, this.keyTraversal).ifProductive(p -> {
+            // if there's no barrier then add the result of the valueTraversal as the value. if there is a barrier,
+            // then pop the next barrier value into the map. there are cases where hasNextBarrier is false in which
+            // case CollectingBarrierStep instances get special handling but only when there are
+            // Supplying/ReducingBarrierStep somewhere in the traversal. these step instances like fold() or sum()
+            // can take an empty TraverserSet and actually produce an output. if that isn't accounted for the key will
+            // just get filtered out. TINKERPOP-2971
             if (null == this.barrierStep) {
                 if (this.valueTraversal.hasNext()) {
                     map.put((K) p, (V) this.valueTraversal.next());
                 }
-            } else if (this.barrierStep.hasNextBarrier())
+            } else if (this.barrierStep.hasNextBarrier()) {
                 map.put((K) p, (V) this.barrierStep.nextBarrier());
+            } else if (this.barrierStep instanceof FilteringBarrier) {
+                final int barrierStepIndex = TraversalHelper.stepIndex((Step) barrierStep, valueTraversal) + 1;
+                if (valueTraversal.getSteps().stream().skip(barrierStepIndex).anyMatch(
+                            step -> step instanceof SupplyingBarrierStep || step instanceof ReducingBarrierStep)) {
+                    map.put((K) p, (V) this.barrierStep.getEmptyBarrier());
+                }
+            }
         });
 
         return map;
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java
index f4cc2b0ee9..7fe9626495 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java
@@ -19,18 +19,21 @@
 package org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect;
 
 import org.apache.tinkerpop.gremlin.process.traversal.Operator;
+import org.apache.tinkerpop.gremlin.process.traversal.Step;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;
+import org.apache.tinkerpop.gremlin.process.traversal.step.FilteringBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Grouping;
-import org.apache.tinkerpop.gremlin.process.traversal.step.ProfilingAware;
 import org.apache.tinkerpop.gremlin.process.traversal.step.SideEffectCapable;
 import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;
 import org.apache.tinkerpop.gremlin.process.traversal.step.map.GroupStep;
-import org.apache.tinkerpop.gremlin.process.traversal.step.util.ProfileStep;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.ReducingBarrierStep;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.SupplyingBarrierStep;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
 import org.apache.tinkerpop.gremlin.structure.util.StringFactory;
 import org.apache.tinkerpop.gremlin.util.function.HashMapSupplier;
@@ -45,13 +48,12 @@ import java.util.Set;
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
 public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S>
-        implements SideEffectCapable<Map<K, ?>, Map<K, V>>, TraversalParent, ByModulating, ProfilingAware, Grouping<S, K, V> {
+        implements SideEffectCapable<Map<K, ?>, Map<K, V>>, TraversalParent, ByModulating, Grouping<S, K, V> {
 
     private char state = 'k';
     private Traversal.Admin<S, K> keyTraversal;
     private Traversal.Admin<S, V> valueTraversal;
     private Barrier barrierStep;
-    private boolean resetBarrierForProfiling = false;
     ///
     private String sideEffectKey;
 
@@ -66,15 +68,6 @@ public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S>
                         this.barrierStep.getMemoryComputeKey().getReducer()));
     }
 
-    /**
-     * Reset the {@link Barrier} on the step to be wrapped in a {@link ProfilingAware.ProfiledBarrier} which can
-     * properly start/stop the timer on the associated {@link ProfileStep}.
-     */
-    @Override
-    public void prepareForProfiling() {
-        resetBarrierForProfiling = barrierStep != null;
-    }
-
     @Override
     public Traversal.Admin<S, K> getKeyTraversal() {
         return this.keyTraversal;
@@ -94,6 +87,15 @@ public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S>
                         this.barrierStep.getMemoryComputeKey().getReducer()));
     }
 
+    @Override
+    public void resetBarrierFromValueTraversal() {
+        this.barrierStep = determineBarrierStep(this.valueTraversal);
+        this.getTraversal().getSideEffects().registerIfAbsent(this.sideEffectKey, HashMapSupplier.instance(),
+                new GroupStep.GroupBiOperator<>(null == this.barrierStep ?
+                        Operator.assign :
+                        this.barrierStep.getMemoryComputeKey().getReducer()));
+    }
+
     @Override
     public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {
         if ('k' == this.state) {
@@ -121,22 +123,20 @@ public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S>
         this.valueTraversal.reset();
         this.valueTraversal.addStart(traverser);
 
-        // reset the barrierStep as there are now ProfileStep instances present and the timers won't start right
-        // without specific configuration through wrapping both the Barrier and ProfileStep in ProfiledBarrier
-        if (resetBarrierForProfiling) {
-            barrierStep = determineBarrierStep(valueTraversal);
-
-            // the barrier only needs to be reset once
-            resetBarrierForProfiling = false;
-        }
-
         TraversalUtil.produce(traverser, this.keyTraversal).ifProductive(p -> {
             if (null == this.barrierStep) {
                 if (this.valueTraversal.hasNext()) {
                     map.put((K) p, (V) this.valueTraversal.next());
                 }
-            } else if (this.barrierStep.hasNextBarrier())
+            } else if (this.barrierStep.hasNextBarrier()) {
                 map.put((K) p, (V) this.barrierStep.nextBarrier());
+            } else if (this.barrierStep instanceof FilteringBarrier) {
+                final int barrierStepIndex = TraversalHelper.stepIndex((Step) barrierStep, valueTraversal) + 1;
+                if (valueTraversal.getSteps().stream().skip(barrierStepIndex).anyMatch(
+                        step -> step instanceof SupplyingBarrierStep || step instanceof ReducingBarrierStep)) {
+                    map.put((K) p, (V) this.barrierStep.getEmptyBarrier());
+                }
+            }
         });
 
         if (!map.isEmpty())
@@ -192,6 +192,12 @@ public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S>
         return result;
     }
 
+    @Override
+    public void reset() {
+        super.reset();
+        this.barrierStep = determineBarrierStep(this.valueTraversal);
+    }
+
     @Override
     public Map<K, V> generateFinalResult(final Map<K, ?> object) {
         return doFinalReduction((Map<K, Object>) object, this.valueTraversal);
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/SideEffectCapStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/SideEffectCapStep.java
index 3e9d1c704e..78d01aab51 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/SideEffectCapStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/SideEffectCapStep.java
@@ -71,6 +71,12 @@ public final class SideEffectCapStep<S, E> extends SupplyingBarrierStep<S, E> {
         return Collections.singleton(TraverserRequirement.SIDE_EFFECTS);
     }
 
+    @Override
+    public Boolean getEmptyBarrier() {
+        // if the barrier is empty then it must be "done"
+        return true;
+    }
+
     @Override
     protected E supply() {
         if (null == this.sideEffectCapableSteps) {
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/CollectingBarrierStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/CollectingBarrierStep.java
index a2418e8909..30c22159a2 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/CollectingBarrierStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/CollectingBarrierStep.java
@@ -22,7 +22,7 @@ import org.apache.tinkerpop.gremlin.process.computer.MemoryComputeKey;
 import org.apache.tinkerpop.gremlin.process.traversal.Operator;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
-import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
+import org.apache.tinkerpop.gremlin.process.traversal.step.FilteringBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.ProjectedTraverser;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.util.TraverserSet;
@@ -39,7 +39,7 @@ import java.util.function.BinaryOperator;
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public abstract class CollectingBarrierStep<S> extends AbstractStep<S, S> implements Barrier<TraverserSet<S>> {
+public abstract class CollectingBarrierStep<S> extends AbstractStep<S, S> implements FilteringBarrier<TraverserSet<S>> {
 
     protected TraverserSet<S> traverserSet;
     private int maxBarrierSize;
@@ -96,6 +96,11 @@ public abstract class CollectingBarrierStep<S> extends AbstractStep<S, S> implem
         }
     }
 
+    @Override
+    public TraverserSet<S> getEmptyBarrier() {
+        return new TraverserSet<>();
+    }
+
     @Override
     public void addBarrier(final TraverserSet<S> barrier) {
         barrier.forEach(traverser -> traverser.setSideEffects(this.getTraversal().getSideEffects()));
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ReducingBarrierStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ReducingBarrierStep.java
index 6004d0da71..4c3f74e161 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ReducingBarrierStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ReducingBarrierStep.java
@@ -24,7 +24,6 @@ import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Generating;
-import org.apache.tinkerpop.gremlin.process.traversal.step.map.SumGlobalStep;
 import org.apache.tinkerpop.gremlin.process.traversal.util.FastNoSuchElementException;
 
 import java.io.Serializable;
@@ -111,6 +110,11 @@ public abstract class ReducingBarrierStep<S, E> extends AbstractStep<S, E> imple
             this.seed = this.reducingBiOperator.apply(this.seed, this.projectTraverser(this.starts.next()));
     }
 
+    @Override
+    public E getEmptyBarrier() {
+        return (E) NON_EMITTING_SEED;
+    }
+
     @Override
     public boolean hasNextBarrier() {
         this.processAllStarts();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java
index dedd567ed6..81abdb37a9 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java
@@ -62,11 +62,6 @@ public final class ProfileStrategy extends AbstractTraversalStrategy<TraversalSt
                 // Create and inject ProfileStep
                 final ProfileStep profileStepToAdd = new ProfileStep(traversal);
                 traversal.addStep((i * 2) + 1, profileStepToAdd);
-
-                final Step stepToBeProfiled = traversal.getSteps().get(i * 2);
-                if (stepToBeProfiled instanceof ProfilingAware) {
-                    ((ProfilingAware) stepToBeProfiled).prepareForProfiling();
-                }
             }
         }
     }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java
index 499fa26551..f4f62a147c 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DefaultTraversal.java
@@ -28,6 +28,7 @@ import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategies;
 import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.TraverserGenerator;
+import org.apache.tinkerpop.gremlin.process.traversal.step.Grouping;
 import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.EmptyStep;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
@@ -132,6 +133,11 @@ public class DefaultTraversal<S, E> implements Traversal.Admin<S, E> {
             }
         }
 
+        // Grouping steps potentially have barriers. those barriers need to get reset after strategies are applied
+        // or else they can old incorrect references if those barriers are rewritten by strategies.
+        steps.stream().filter(s -> s instanceof Grouping).forEach(
+                step -> ((Grouping<?, ?, ?>) step).resetBarrierFromValueTraversal());
+
         // lock the traversal and its children for execution, finalizing the copy of any data from parent to child
         // as needed
         this.lock();
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/io/gryo/GryoVersion.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/io/gryo/GryoVersion.java
index 4ee9f99bf9..f4eb044b0b 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/io/gryo/GryoVersion.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/io/gryo/GryoVersion.java
@@ -22,6 +22,7 @@ import org.apache.tinkerpop.gremlin.process.computer.GraphFilter;
 import org.apache.tinkerpop.gremlin.process.computer.MapReduce;
 import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.decoration.VertexProgramStrategy;
 import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.optimization.GraphFilterStrategy;
+import org.apache.tinkerpop.gremlin.process.computer.util.ComputerGraph;
 import org.apache.tinkerpop.gremlin.process.computer.util.MapMemory;
 import org.apache.tinkerpop.gremlin.process.remote.traversal.DefaultRemoteTraverser;
 import org.apache.tinkerpop.gremlin.process.traversal.Bytecode;
@@ -302,6 +303,11 @@ public enum GryoVersion {
             add(GryoTypeReg.of(ReferencePath.class, 85));
 
             add(GryoTypeReg.of(StarGraph.class, 86, new StarGraphSerializer(Direction.BOTH, new GraphFilter())));
+            // skipping 199,200 given GValue,GType in 4.x
+            add(GryoTypeReg.of(StarGraph.StarAdjacentVertex.class, 201));
+            add(GryoTypeReg.of(ComputerGraph.class, 202));
+            add(GryoTypeReg.of(ComputerGraph.State.class, 203));
+            add(GryoTypeReg.of(ComputerGraph.ComputerAdjacentVertex.class, 204));                    // ***LAST ID***
 
             add(GryoTypeReg.of(Edge.class, 65, new GryoSerializersV3.EdgeSerializer()));
             add(GryoTypeReg.of(Vertex.class, 66, new GryoSerializersV3.VertexSerializer()));
@@ -324,7 +330,7 @@ public enum GryoVersion {
             add(GryoTypeReg.of(Bytecode.class, 122, new GryoSerializersV3.BytecodeSerializer()));
             add(GryoTypeReg.of(P.class, 124, new GryoSerializersV3.PSerializer()));
             add(GryoTypeReg.of(TextP.class, 186, new GryoSerializersV3.TextPSerializer()));
-            add(GryoTypeReg.of(Text.RegexPredicate.class, 197));                                       // ***LAST ID***
+            add(GryoTypeReg.of(Text.RegexPredicate.class, 197));
             add(GryoTypeReg.of(Lambda.class, 125, new GryoSerializersV3.LambdaSerializer()));
             add(GryoTypeReg.of(Bytecode.Binding.class, 126, new GryoSerializersV3.BindingSerializer()));
             add(GryoTypeReg.of(Order.class, 127));
@@ -506,6 +512,11 @@ public enum GryoVersion {
             add(GryoTypeReg.of(ReferencePath.class, 85));
 
             add(GryoTypeReg.of(StarGraph.class, 86, new StarGraphSerializer(Direction.BOTH, new GraphFilter())));
+            // skipping 199,200 given GValue,GType in 4.x 
+            add(GryoTypeReg.of(StarGraph.StarAdjacentVertex.class, 201));
+            add(GryoTypeReg.of(ComputerGraph.class, 202));
+            add(GryoTypeReg.of(ComputerGraph.State.class, 203));
+            add(GryoTypeReg.of(ComputerGraph.ComputerAdjacentVertex.class, 204));                    // ***LAST ID***
 
             add(GryoTypeReg.of(Edge.class, 65, new GryoSerializersV1.EdgeSerializer()));
             add(GryoTypeReg.of(Vertex.class, 66, new GryoSerializersV1.VertexSerializer()));
@@ -537,7 +548,7 @@ public enum GryoVersion {
             add(GryoTypeReg.of(Pop.class, 133));
             add(GryoTypeReg.of(SackFunctions.Barrier.class, 135));
             add(GryoTypeReg.of(Pick.class, 137));
-            add(GryoTypeReg.of(DT.class, 198));     // ***LAST ID***
+            add(GryoTypeReg.of(DT.class, 198));
             add(GryoTypeReg.of(Merge.class, 196));
             add(GryoTypeReg.of(HashSetSupplier.class, 136, new UtilSerializers.HashSetSupplierSerializer()));
             add(GryoTypeReg.of(MultiComparator.class, 165));
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/util/detached/DetachedFactory.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/util/detached/DetachedFactory.java
index d353e5187d..a75169ff1a 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/util/detached/DetachedFactory.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/structure/util/detached/DetachedFactory.java
@@ -18,6 +18,7 @@
  */
 package org.apache.tinkerpop.gremlin.structure.util.detached;
 
+import org.apache.tinkerpop.gremlin.process.computer.util.ComputerGraph;
 import org.apache.tinkerpop.gremlin.process.traversal.Path;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.BulkSet;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.Tree;
@@ -45,7 +46,10 @@ public class DetachedFactory {
     }
 
     public static DetachedVertex detach(final Vertex vertex, final boolean withProperties) {
-        return vertex instanceof DetachedVertex ? (DetachedVertex) vertex : new DetachedVertex(vertex, withProperties);
+        // ComputerAdjacentVertex doesn't have properties, but we still want to detach them. force to false for
+        // grabbing properties in this case.
+        return vertex instanceof DetachedVertex ? (DetachedVertex) vertex :
+                new DetachedVertex(vertex, withProperties && !(vertex instanceof ComputerGraph.ComputerAdjacentVertex));
     }
 
     public static DetachedEdge detach(final Edge edge, final boolean withProperties) {
