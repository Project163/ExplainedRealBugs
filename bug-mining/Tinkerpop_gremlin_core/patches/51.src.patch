diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java
new file mode 100644
index 0000000000..a8a1015721
--- /dev/null
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/ProfilingAware.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.process.traversal.step;
+
+import org.apache.tinkerpop.gremlin.process.computer.MemoryComputeKey;
+import org.apache.tinkerpop.gremlin.process.traversal.Step;
+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GroupStep;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.ProfileStep;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.finalization.ProfileStrategy;
+
+import java.util.NoSuchElementException;
+
+/**
+ * Marks a {@link Step} as one that is aware of profiling. A good example of where this is important is with
+ * {@link GroupStep} which needs to track and hold a {@link Barrier}, which is important for the
+ * {@link ProfileStrategy} to know about. Once the {@link ProfileStep} is injected the {@link Barrier} needs to be
+ * recalculated so that the timer can be properly started on the associated {@link ProfileStep}. Without that indirect
+ * start of the timer, the operation related to the {@link Barrier} will not be properly accounted for and when
+ * metrics are normalized it is possible to end up with a negative timing.
+ *
+ * @author Stephen Mallette (http://stephen.genoprime.com)
+ */
+public interface ProfilingAware {
+
+    /**
+     * Prepares the step for any internal changes that might help ensure that profiling will work as expected.
+     */
+    public void prepareForProfiling();
+
+    /**
+     * A helper class which holds a {@link Barrier} and it's related {@link ProfileStep} so that the latter can have
+     * its timer started and stopped appropriately.
+     */
+    public static final class ProfiledBarrier implements Barrier {
+
+        private final Barrier barrier;
+        private final ProfileStep profileStep;
+
+        public ProfiledBarrier(final Barrier barrier, final ProfileStep profileStep) {
+            this.barrier = barrier;
+            this.profileStep = profileStep;
+        }
+
+        @Override
+        public void processAllStarts() {
+            this.profileStep.start();
+            this.barrier.processAllStarts();
+            this.profileStep.stop();
+        }
+
+        @Override
+        public boolean hasNextBarrier() {
+            this.profileStep.start();
+            final boolean b = this.barrier.hasNextBarrier();
+            this.profileStep.stop();
+            return b;
+        }
+
+        @Override
+        public Object nextBarrier() throws NoSuchElementException {
+            this.profileStep.start();
+            final Object o = this.barrier.nextBarrier();
+            this.profileStep.stop();
+            return o;
+        }
+
+        @Override
+        public void addBarrier(final Object barrier) {
+            this.barrier.addBarrier(barrier);
+        }
+
+        @Override
+        public MemoryComputeKey getMemoryComputeKey() {
+            return this.barrier.getMemoryComputeKey();
+        }
+
+        @Override
+        public void done() {
+            this.barrier.done();
+        }
+    }
+}
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java
index b8c2f13c25..fa5271846d 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/GroupStep.java
@@ -29,10 +29,12 @@ import org.apache.tinkerpop.gremlin.process.traversal.lambda.ElementValueTravers
 import org.apache.tinkerpop.gremlin.process.traversal.lambda.FunctionTraverser;
 import org.apache.tinkerpop.gremlin.process.traversal.lambda.IdentityTraversal;
 import org.apache.tinkerpop.gremlin.process.traversal.lambda.TokenTraversal;
+import org.apache.tinkerpop.gremlin.process.traversal.step.ProfilingAware;
 import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;
 import org.apache.tinkerpop.gremlin.process.traversal.step.LocalBarrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.ProfileStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.ReducingBarrierStep;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
@@ -50,12 +52,13 @@ import java.util.function.BinaryOperator;
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>> implements ByModulating, TraversalParent {
+public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>> implements ByModulating, TraversalParent, ProfilingAware {
 
     private char state = 'k';
     private Traversal.Admin<S, K> keyTraversal;
     private Traversal.Admin<S, V> valueTraversal;
     private Barrier barrierStep;
+    private boolean resetBarrierForProfiling = false;
 
     public GroupStep(final Traversal.Admin traversal) {
         super(traversal);
@@ -68,20 +71,35 @@ public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>>
     /**
      * Determines the first (non-local) barrier step in the provided traversal. This method is used by {@link GroupStep}
      * and {@link org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.GroupSideEffectStep} to ultimately
-     * determine the reducing reducing bi-operator.
+     * determine the reducing bi-operator.
      *
      * @param traversal The traversal to inspect.
      * @return The first non-local barrier step or {@code null} if no such step was found.
      */
     public static <S, V> Barrier determineBarrierStep(final Traversal.Admin<S, V> traversal) {
-        for (final Step step : traversal.getSteps()) {
+        final List<Step> steps = traversal.getSteps();
+        for (int ix = 0; ix < steps.size(); ix++) {
+            final Step step = steps.get(ix);
             if (step instanceof Barrier && !(step instanceof LocalBarrier)) {
-                return (Barrier) step;
+                final Barrier b = (Barrier) step;
+                if (ix < steps.size() - 1 && steps.get(ix + 1) instanceof ProfileStep)
+                    return new ProfilingAware.ProfiledBarrier(b, (ProfileStep) steps.get(ix + 1));
+                else
+                    return b;
             }
         }
         return null;
     }
 
+    /**
+     * Reset the {@link Barrier} on the step to be wrapped in a {@link ProfiledBarrier} which can properly start/stop
+     * the timer on the associated {@link ProfileStep}.
+     */
+    @Override
+    public void prepareForProfiling() {
+        resetBarrierForProfiling = barrierStep != null;
+    }
+
     @Override
     public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {
         if ('k' == this.state) {
@@ -102,6 +120,11 @@ public final class GroupStep<S, K, V> extends ReducingBarrierStep<S, Map<K, V>>
         final Map<K, V> map = new HashMap<>(1);
         this.valueTraversal.reset();
         this.valueTraversal.addStart(traverser);
+
+        // reset the barrierStep as there are now ProfileStep instances present and the timers won't start right
+        // without specific configuration through wrapping both the Barrier and ProfileStep in ProfiledBarrier
+        if (resetBarrierForProfiling) barrierStep = determineBarrierStep(valueTraversal);
+
         if (null == this.barrierStep) {
             if (this.valueTraversal.hasNext())
                 map.put(TraversalUtil.applyNullable(traverser, this.keyTraversal), (V) this.valueTraversal.next());
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java
index 4a38cb7de7..a5a9b4c2f3 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/GroupSideEffectStep.java
@@ -24,9 +24,11 @@ import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Barrier;
 import org.apache.tinkerpop.gremlin.process.traversal.step.ByModulating;
+import org.apache.tinkerpop.gremlin.process.traversal.step.ProfilingAware;
 import org.apache.tinkerpop.gremlin.process.traversal.step.SideEffectCapable;
 import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;
 import org.apache.tinkerpop.gremlin.process.traversal.step.map.GroupStep;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.ProfileStep;
 import org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalUtil;
@@ -42,12 +44,13 @@ import java.util.Set;
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
  */
-public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S> implements SideEffectCapable<Map<K, ?>, Map<K, V>>, TraversalParent, ByModulating {
+public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S> implements SideEffectCapable<Map<K, ?>, Map<K, V>>, TraversalParent, ByModulating, ProfilingAware {
 
     private char state = 'k';
     private Traversal.Admin<S, K> keyTraversal;
     private Traversal.Admin<S, V> valueTraversal;
     private Barrier barrierStep;
+    private boolean resetBarrierForProfiling = false;
     ///
     private String sideEffectKey;
 
@@ -62,6 +65,15 @@ public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S> implem
                         this.barrierStep.getMemoryComputeKey().getReducer()));
     }
 
+    /**
+     * Reset the {@link Barrier} on the step to be wrapped in a {@link ProfilingAware.ProfiledBarrier} which can
+     * properly start/stop the timer on the associated {@link ProfileStep}.
+     */
+    @Override
+    public void prepareForProfiling() {
+        resetBarrierForProfiling = barrierStep != null;
+    }
+
     @Override
     public void modulateBy(final Traversal.Admin<?, ?> kvTraversal) {
         if ('k' == this.state) {
@@ -85,6 +97,11 @@ public final class GroupSideEffectStep<S, K, V> extends SideEffectStep<S> implem
         final Map<K, V> map = new HashMap<>(1);
         this.valueTraversal.reset();
         this.valueTraversal.addStart(traverser);
+
+        // reset the barrierStep as there are now ProfileStep instances present and the timers won't start right
+        // without specific configuration through wrapping both the Barrier and ProfileStep in ProfiledBarrier
+        if (resetBarrierForProfiling) barrierStep = GroupStep.determineBarrierStep(valueTraversal);
+
         if (null == this.barrierStep) {
             if (this.valueTraversal.hasNext())
                 map.put(TraversalUtil.applyNullable(traverser, this.keyTraversal), (V) this.valueTraversal.next());
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ProfileStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ProfileStep.java
index 0bc5f4ff91..66cf10a845 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ProfileStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/util/ProfileStep.java
@@ -46,6 +46,15 @@ public final class ProfileStep<S> extends AbstractStep<S, S> implements MemoryCo
         return metrics;
     }
 
+    public void start() {
+        this.initializeIfNeeded();
+        this.metrics.start();
+    }
+
+    public void stop() {
+        this.metrics.stop();
+    }
+
     @Override
     public Traverser.Admin<S> next() {
         Traverser.Admin<S> start = null;
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java
index b5f0b86acd..ceedb38d3e 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/finalization/ProfileStrategy.java
@@ -22,6 +22,7 @@ import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.VertexPr
 import org.apache.tinkerpop.gremlin.process.traversal.Step;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.step.ProfilingAware;
 import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.ProfileSideEffectStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.EmptyStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.ProfileStep;
@@ -57,7 +58,13 @@ public final class ProfileStrategy extends AbstractTraversalStrategy<TraversalSt
                 if (steps.get(i * 2) instanceof ProfileSideEffectStep)
                     break;
                 // Create and inject ProfileStep
-                traversal.addStep((i * 2) + 1, new ProfileStep(traversal));
+                final ProfileStep profileStepToAdd = new ProfileStep(traversal);
+                traversal.addStep((i * 2) + 1, profileStepToAdd);
+
+                final Step stepToBeProfiled = traversal.getSteps().get(i * 2);
+                if (stepToBeProfiled instanceof ProfilingAware) {
+                    ((ProfilingAware) stepToBeProfiled).prepareForProfiling();
+                }
             }
         }
     }
