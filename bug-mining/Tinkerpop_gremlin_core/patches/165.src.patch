diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitor.java
index 2a3b214bba..7d808d16c4 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitor.java
@@ -18,25 +18,13 @@
  */
 package org.apache.tinkerpop.gremlin.language.grammar;
 
-import org.apache.tinkerpop.gremlin.process.traversal.DT;
-import org.apache.tinkerpop.gremlin.process.traversal.Merge;
-import org.apache.tinkerpop.gremlin.process.traversal.Operator;
-import org.apache.tinkerpop.gremlin.process.traversal.Order;
-import org.apache.tinkerpop.gremlin.process.traversal.Pop;
-import org.apache.tinkerpop.gremlin.process.traversal.SackFunctions;
-import org.apache.tinkerpop.gremlin.process.traversal.Scope;
-import org.apache.tinkerpop.gremlin.structure.Column;
-import org.apache.tinkerpop.gremlin.structure.Direction;
-import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.Vertex;
-import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.apache.tinkerpop.gremlin.util.iterator.IteratorUtils;
 
 import java.lang.reflect.Array;
-import java.util.Comparator;
 import java.util.Date;
 import java.util.Map;
-import java.util.function.Function;
+import java.util.Objects;
 
 public class ArgumentVisitor extends DefaultGremlinBaseVisitor<Object> {
 
@@ -91,13 +79,6 @@ public class ArgumentVisitor extends DefaultGremlinBaseVisitor<Object> {
         return visitGenericLiteralArgument(ctx);
     }
 
-    /**
-     * Wrapper for visit function for {@link Direction} types.
-     */
-    public Direction parseDirection(final GremlinParser.TraversalDirectionArgumentContext ctx) {
-        return (Direction) visitTraversalDirectionArgument(ctx);
-    }
-
     /**
      * Wrapper for visit function for {@link Vertex} types.
      */
@@ -105,76 +86,6 @@ public class ArgumentVisitor extends DefaultGremlinBaseVisitor<Object> {
         return (Vertex) visitStructureVertexArgument(ctx);
     }
 
-    /**
-     * Wrapper for visit function for {@link Order} types.
-     */
-    public Order parseOrder(final GremlinParser.TraversalOrderArgumentContext ctx) {
-        return (Order) visitTraversalOrderArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link Scope} types.
-     */
-    public Scope parseScope(final GremlinParser.TraversalScopeArgumentContext ctx) {
-        return (Scope) visitTraversalScopeArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link T} types.
-     */
-    public T parseT(final GremlinParser.TraversalTokenArgumentContext ctx) {
-        return (T) visitTraversalTokenArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link VertexProperty.Cardinality} types.
-     */
-    public VertexProperty.Cardinality parseCardinality(final GremlinParser.TraversalCardinalityArgumentContext ctx) {
-        return (VertexProperty.Cardinality) visitTraversalCardinalityArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link Merge} types.
-     */
-    public Merge parseMerge(final GremlinParser.TraversalMergeArgumentContext ctx) {
-        return (Merge) visitTraversalMergeArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link Pop} types.
-     */
-    public Pop parsePop(final GremlinParser.TraversalPopArgumentContext ctx) {
-        return (Pop) visitTraversalPopArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link DT} types.
-     */
-    public DT parseDT(final GremlinParser.TraversalDTArgumentContext ctx) {
-        return (DT) visitTraversalDTArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@link Pop} types.
-     */
-    public Column parseColumn(final GremlinParser.TraversalColumnArgumentContext ctx) {
-        return (Column) visitTraversalColumnArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@code Function} types like {@link T} and {@link Column}.
-     */
-    public Function parseFunction(final GremlinParser.TraversalFunctionArgumentContext ctx) {
-        return (Function) visitTraversalFunctionArgument(ctx);
-    }
-
-    /**
-     * Wrapper for visit function for {@code Comparator} types like {@link Order}.
-     */
-    public Comparator parseComparator(final GremlinParser.TraversalComparatorArgumentContext ctx) {
-        return (Comparator) visitTraversalComparatorArgument(ctx);
-    }
-
     /**
      * Wrapper for visit function for {@code Map} types.
      */
@@ -293,15 +204,6 @@ public class ArgumentVisitor extends DefaultGremlinBaseVisitor<Object> {
         }
     }
 
-    @Override
-    public Object visitTraversalDirectionArgument(final GremlinParser.TraversalDirectionArgumentContext ctx) {
-        if (ctx.traversalDirection() != null) {
-            return TraversalEnumParser.parseTraversalDirectionFromContext(ctx.traversalDirection());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
     @Override
     public Object visitStructureVertexArgument(final GremlinParser.StructureVertexArgumentContext ctx) {
         if (ctx.structureVertex() != null) {
@@ -311,112 +213,6 @@ public class ArgumentVisitor extends DefaultGremlinBaseVisitor<Object> {
         }
     }
 
-    @Override
-    public Object visitTraversalOrderArgument(final GremlinParser.TraversalOrderArgumentContext ctx) {
-        if (ctx.traversalOrder() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Order.class, ctx.traversalOrder());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalScopeArgument(final GremlinParser.TraversalScopeArgumentContext ctx) {
-        if (ctx.traversalScope() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalTokenArgument(final GremlinParser.TraversalTokenArgumentContext ctx) {
-        if (ctx.traversalToken() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx.traversalToken());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalCardinalityArgument(final GremlinParser.TraversalCardinalityArgumentContext ctx) {
-        if (ctx.traversalCardinality() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(VertexProperty.Cardinality.class, ctx.traversalCardinality());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalMergeArgument(final GremlinParser.TraversalMergeArgumentContext ctx) {
-        if (ctx.traversalMerge() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Merge.class, ctx.traversalMerge());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalPopArgument(final GremlinParser.TraversalPopArgumentContext ctx) {
-        if (ctx.traversalPop() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Pop.class, ctx.traversalPop());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalDTArgument(final GremlinParser.TraversalDTArgumentContext ctx) {
-        if (ctx.traversalDT() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(DT.class, ctx.traversalDT());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalColumnArgument(final GremlinParser.TraversalColumnArgumentContext ctx) {
-        if (ctx.traversalColumn() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Column.class, ctx.traversalColumn());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalComparatorArgument(final GremlinParser.TraversalComparatorArgumentContext ctx) {
-        if (ctx.traversalComparator() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Order.class, ctx.traversalComparator().traversalOrder());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalFunctionArgument(final GremlinParser.TraversalFunctionArgumentContext ctx) {
-        if (ctx.traversalFunction() != null) {
-            final GremlinParser.TraversalFunctionContext tfc = ctx.traversalFunction();
-            if (tfc.traversalToken() != null) {
-                return TraversalEnumParser.parseTraversalEnumFromContext(T.class, tfc.traversalToken());
-            } else if (tfc.traversalColumn() != null)
-                return TraversalEnumParser.parseTraversalEnumFromContext(Column.class, tfc.traversalColumn());
-            else {
-                throw new GremlinParserException("Unrecognized enum for traversal function");
-            }
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
-    @Override
-    public Object visitTraversalBiFunctionArgument(final GremlinParser.TraversalBiFunctionArgumentContext ctx) {
-        if (ctx.traversalBiFunction() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(Operator.class, ctx.traversalBiFunction().traversalOperator());
-        } else {
-            return visitVariable(ctx.variable());
-        }
-    }
-
     @Override
     public Object visitGenericLiteralMapArgument(final GremlinParser.GenericLiteralMapArgumentContext ctx) {
         if (ctx.genericLiteralMap() != null) {
@@ -437,13 +233,18 @@ public class ArgumentVisitor extends DefaultGremlinBaseVisitor<Object> {
         }
     }
 
-    @Override
-    public Object visitTraversalSackMethodArgument(final GremlinParser.TraversalSackMethodArgumentContext ctx) {
-        if (ctx.traversalSackMethod() != null) {
-            return TraversalEnumParser.parseTraversalEnumFromContext(SackFunctions.Barrier.class, ctx.traversalSackMethod());
-        } else {
-            return visitVariable(ctx.variable());
+    /**
+     * Parse a string literal varargs, and return a string array
+     */
+    public String[] parseStringVarargs(final GremlinParser.StringLiteralVarargsArgumentContext varargsArgumentContext) {
+        if (varargsArgumentContext == null || varargsArgumentContext.stringNullableArgument() == null) {
+            return new String[0];
         }
+        return varargsArgumentContext.stringNullableArgument()
+                .stream()
+                .filter(Objects::nonNull)
+                .map(antlr.argumentVisitor::parseString)
+                .toArray(String[]::new);
     }
 
     @Override
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/DefaultGremlinBaseVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/DefaultGremlinBaseVisitor.java
index 98b0532e84..bfa4f36497 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/DefaultGremlinBaseVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/DefaultGremlinBaseVisitor.java
@@ -1074,7 +1074,7 @@ public class DefaultGremlinBaseVisitor<T> extends AbstractParseTreeVisitor<T> im
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalToken(final GremlinParser.TraversalTokenContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalT(final GremlinParser.TraversalTContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
@@ -1616,109 +1616,89 @@ public class DefaultGremlinBaseVisitor<T> extends AbstractParseTreeVisitor<T> im
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitStructureVertexArgument(GremlinParser.StructureVertexArgumentContext ctx) { notImplemented(ctx);  return null; }
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override public T visitTraversalDirectionArgument(GremlinParser.TraversalDirectionArgumentContext ctx) { notImplemented(ctx); return null; }
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override public T visitTraversalOrderArgument(final GremlinParser.TraversalOrderArgumentContext ctx) { notImplemented(ctx); return null; }
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override public T visitTraversalScopeArgument(final GremlinParser.TraversalScopeArgumentContext ctx) { notImplemented(ctx); return null; }
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override public T visitTraversalTokenArgument(final GremlinParser.TraversalTokenArgumentContext ctx) { notImplemented(ctx); return null; }
-	/**
-	 * {@inheritDoc}
-	 */
-	@Override public T visitTraversalCardinalityArgument(final GremlinParser.TraversalCardinalityArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitGenericLiteralVarargs(final GremlinParser.GenericLiteralVarargsContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalMergeArgument(final GremlinParser.TraversalMergeArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitGenericLiteralMapArgument(final GremlinParser.GenericLiteralMapArgumentContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalPopArgument(final GremlinParser.TraversalPopArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitGenericLiteralMapNullableArgument(final GremlinParser.GenericLiteralMapNullableArgumentContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalColumnArgument(final GremlinParser.TraversalColumnArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitStringLiteralVarargs(final GremlinParser.StringLiteralVarargsContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalComparatorArgument(final GremlinParser.TraversalComparatorArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalMethod_option_Merge_Map_Cardinality(final GremlinParser.TraversalMethod_option_Merge_Map_CardinalityContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalFunctionArgument(final GremlinParser.TraversalFunctionArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalSourceSelfMethod_withoutStrategies(final GremlinParser.TraversalSourceSelfMethod_withoutStrategiesContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalBiFunctionArgument(final GremlinParser.TraversalBiFunctionArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitClassTypeList(final GremlinParser.ClassTypeListContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalDTArgument(final GremlinParser.TraversalDTArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitClassTypeExpr(final GremlinParser.ClassTypeExprContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalSackMethodArgument(final GremlinParser.TraversalSackMethodArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitClassType(final GremlinParser.ClassTypeContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitGenericLiteralVarargs(final GremlinParser.GenericLiteralVarargsContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitConfiguration(final GremlinParser.ConfigurationContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitGenericLiteralMapArgument(final GremlinParser.GenericLiteralMapArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitKeyword(final GremlinParser.KeywordContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitGenericLiteralMapNullableArgument(final GremlinParser.GenericLiteralMapNullableArgumentContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalBarrier(final GremlinParser.TraversalBarrierContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitStringLiteralVarargs(final GremlinParser.StringLiteralVarargsContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitGenericLiteralSet(final GremlinParser.GenericLiteralSetContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalMethod_option_Merge_Map_Cardinality(final GremlinParser.TraversalMethod_option_Merge_Map_CardinalityContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalTShort(final GremlinParser.TraversalTShortContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalSourceSelfMethod_withoutStrategies(final GremlinParser.TraversalSourceSelfMethod_withoutStrategiesContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalTLong(final GremlinParser.TraversalTLongContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitClassTypeList(final GremlinParser.ClassTypeListContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalDirectionShort(final GremlinParser.TraversalDirectionShortContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitClassTypeExpr(final GremlinParser.ClassTypeExprContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitTraversalDirectionLong(final GremlinParser.TraversalDirectionLongContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitClassType(final GremlinParser.ClassTypeContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitGenericLiteralMapNullable(final GremlinParser.GenericLiteralMapNullableContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitConfiguration(final GremlinParser.ConfigurationContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitStringLiteralVarargsArgument(final GremlinParser.StringLiteralVarargsArgumentContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitKeyword(final GremlinParser.KeywordContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitMapKey(final GremlinParser.MapKeyContext ctx) { notImplemented(ctx); return null; }
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitTraversalBarrier(final GremlinParser.TraversalBarrierContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitNakedKey(final GremlinParser.NakedKeyContext ctx) { notImplemented(ctx); return null;}
 	/**
 	 * {@inheritDoc}
 	 */
-	@Override public T visitGenericLiteralSet(final GremlinParser.GenericLiteralSetContext ctx) { notImplemented(ctx); return null; }
+	@Override public T visitStructureVertexArgument(final GremlinParser.StructureVertexArgumentContext ctx) { notImplemented(ctx); return null; }
 }
\ No newline at end of file
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GenericLiteralVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GenericLiteralVisitor.java
index e2ba797db2..07eb21f048 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GenericLiteralVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GenericLiteralVisitor.java
@@ -143,13 +143,13 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
      * Parse a string literal varargs, and return an string array
      */
     public String[] parseStringVarargs(final GremlinParser.StringLiteralVarargsContext varargsContext) {
-        if (varargsContext == null || varargsContext.stringNullableArgument() == null) {
+        if (varargsContext == null) {
             return new String[0];
         }
-        return varargsContext.stringNullableArgument()
+        return varargsContext.stringNullableLiteral()
                 .stream()
                 .filter(Objects::nonNull)
-                .map(antlr.argumentVisitor::parseString)
+                .map(this::parseString)
                 .toArray(String[]::new);
     }
 
@@ -328,21 +328,25 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
 
         // filter out tokens and just grab map entries
         ctx.children.stream().filter(c -> c instanceof GremlinParser.MapEntryContext).forEach(c -> {
-            // [key : value] - index 0 is key, index 1 is COLON, index 2 is value
-            // also note that a child count of 5 indicates the key is an expression wrapped
-            // in parens as in `[(T.id): 1]`
-            final boolean isKeyExpression = c.getChildCount() == 5;
-            final Object kctx = isKeyExpression ? c.getChild(1) : c.getChild(0);
+            // [key : value] index 0 is key in the MapKeyContext unless it is wrapped in parens
+            // [(T.id): 1] in which case they key will be found at index 1 within the MapKeyContext
+            final GremlinParser.MapKeyContext mapKeyContext = ((GremlinParser.MapEntryContext) c).mapKey();
+            final boolean isKeyExpression = mapKeyContext.LPAREN() != null && mapKeyContext.RPAREN() != null;
+            final Object kctx = isKeyExpression ? mapKeyContext.getChild(1) : mapKeyContext.getChild(0);
             final Object key;
             if (kctx instanceof GremlinParser.StringLiteralContext) {
                 key = visitStringLiteral((GremlinParser.StringLiteralContext) kctx);
             } else if (kctx instanceof GremlinParser.NumericLiteralContext) {
                 key = visitNumericLiteral((GremlinParser.NumericLiteralContext) kctx);
-            } else if (kctx instanceof GremlinParser.TraversalTokenContext) {
-                key = visitTraversalToken((GremlinParser.TraversalTokenContext) kctx);
+            } else if (kctx instanceof GremlinParser.TraversalTContext) {
+                key = visitTraversalT((GremlinParser.TraversalTContext) kctx);
+            } else if (kctx instanceof GremlinParser.TraversalTLongContext) {
+                key = visitTraversalTLong((GremlinParser.TraversalTLongContext) kctx);
             } else if (kctx instanceof GremlinParser.TraversalDirectionContext) {
                 key = visitTraversalDirection((GremlinParser.TraversalDirectionContext) kctx);
-            } else if (kctx instanceof GremlinParser.GenericLiteralCollectionContext) {
+            } else if (kctx instanceof GremlinParser.TraversalDirectionLongContext) {
+                key = visitTraversalDirectionLong((GremlinParser.TraversalDirectionLongContext) kctx);
+            }else if (kctx instanceof GremlinParser.GenericLiteralCollectionContext) {
                 key = visitGenericLiteralCollection((GremlinParser.GenericLiteralCollectionContext) kctx);
             } else if (kctx instanceof GremlinParser.GenericLiteralSetContext) {
                 key = visitGenericLiteralSet((GremlinParser.GenericLiteralSetContext) kctx);
@@ -350,14 +354,15 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
                 key = visitGenericLiteralMap((GremlinParser.GenericLiteralMapContext) kctx);
             } else if (kctx instanceof GremlinParser.KeywordContext) {
                 key = ((GremlinParser.KeywordContext) kctx).getText();
+            } else if (kctx instanceof GremlinParser.NakedKeyContext) {
+                key = ((GremlinParser.NakedKeyContext) kctx).getText();
             } else if (kctx instanceof TerminalNode) {
                 key = ((TerminalNode) kctx).getText();
             } else {
                 throw new GremlinParserException("Invalid key for map " + ((ParseTree) kctx).getText());
             }
 
-            final int valueIndex = isKeyExpression ? 4 : 2;
-            final Object value = visitGenericLiteral((GremlinParser.GenericLiteralContext) c.getChild(valueIndex));
+            final Object value = visitGenericLiteral((GremlinParser.GenericLiteralContext) c.getChild(2));
             literalMap.put(key, value);
         });
 
@@ -461,6 +466,9 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
      */
     @Override
     public Object visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         final String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
@@ -520,7 +528,12 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
      * {@inheritDoc}
      */
     @Override
-    public Object visitTraversalToken(final GremlinParser.TraversalTokenContext ctx) {
+    public Object visitTraversalT(final GremlinParser.TraversalTContext ctx) {
+        return TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx);
+    }
+
+    @Override
+    public Object visitTraversalTLong(final GremlinParser.TraversalTLongContext ctx) {
         return TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx);
     }
 
@@ -529,18 +542,17 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
      */
     @Override
     public Object visitTraversalCardinality(final GremlinParser.TraversalCardinalityContext ctx) {
-        // could be Cardinality.single() the method or single the enum so grab the right child index based on
-        // number of children
-        if (ctx.getChildCount() == 1) {
+        // if there is a paren, we're doing the function call, otherwise it's just the enum
+        if (null == ctx.LPAREN()) {
             return TraversalEnumParser.parseTraversalEnumFromContext(VertexProperty.Cardinality.class, ctx);
         } else {
-            final int idx = ctx.getChildCount() == 5 ? 1 : 0;
+            final int idx = ctx.getChildCount() == 6 ? 2 : 0;
             final String specifiedCard = ctx.children.get(idx).getText();
-            if (specifiedCard.endsWith(VertexProperty.Cardinality.single.name()))
+            if (ctx.K_SINGLE() != null)
                 return VertexProperty.Cardinality.single(visitGenericLiteral(ctx.genericLiteral()));
-            else if (specifiedCard.endsWith(VertexProperty.Cardinality.list.name()))
+            else if (ctx.K_LIST() != null)
                 return VertexProperty.Cardinality.list(visitGenericLiteral(ctx.genericLiteral()));
-            else if (specifiedCard.endsWith(VertexProperty.Cardinality.set.name()))
+            else if (ctx.K_SET() != null)
                 return VertexProperty.Cardinality.set(visitGenericLiteral(ctx.genericLiteral()));
             else
                 throw new GremlinParserException(String.format(
@@ -556,6 +568,11 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
         return TraversalEnumParser.parseTraversalDirectionFromContext(ctx);
     }
 
+    @Override
+    public Object visitTraversalDirectionLong(final GremlinParser.TraversalDirectionLongContext ctx) {
+        return TraversalEnumParser.parseTraversalDirectionFromContext(ctx);
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -653,7 +670,7 @@ public class GenericLiteralVisitor extends DefaultGremlinBaseVisitor<Object> {
 
     @Override
     public Object visitStringNullableLiteral(final GremlinParser.StringNullableLiteralContext ctx) {
-        if (ctx.NullLiteral() != null)
+        if (ctx.K_NULL() != null)
             return null;
         else
             return StringEscapeUtils.unescapeJava(stripQuotes(ctx.getText()));
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GremlinQueryParser.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GremlinQueryParser.java
index 7ab7392af2..4efb5fcf69 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GremlinQueryParser.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/GremlinQueryParser.java
@@ -26,8 +26,6 @@ import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Map;
-
 /**
  * Parses Gremlin strings to an {@code Object}, typically to a {@link Traversal}.
  */
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParser.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParser.java
index ec282de3df..0c43f9ba49 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParser.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParser.java
@@ -55,4 +55,14 @@ public class TraversalEnumParser {
             text = text.substring(Direction.class.getSimpleName().length() + 1);
         return Direction.directionValueOf(text);
     }
+
+    /**
+     * Parsing of {@link Direction} requires some special handling because of aliases (from/to).
+     */
+    public static Direction parseTraversalDirectionFromContext(final GremlinParser.TraversalDirectionLongContext context) {
+        String text = context.getText();
+        if (text.startsWith(Direction.class.getSimpleName()))
+            text = text.substring(Direction.class.getSimpleName().length() + 1);
+        return Direction.directionValueOf(text);
+    }
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalMethodVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalMethodVisitor.java
index 5de8c23240..fbf4ecb2d2 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalMethodVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalMethodVisitor.java
@@ -18,11 +18,18 @@
  */
 package org.apache.tinkerpop.gremlin.language.grammar;
 
+import org.apache.tinkerpop.gremlin.process.traversal.DT;
+import org.apache.tinkerpop.gremlin.process.traversal.Merge;
 import org.apache.tinkerpop.gremlin.process.traversal.Operator;
 import org.apache.tinkerpop.gremlin.process.traversal.Order;
+import org.apache.tinkerpop.gremlin.process.traversal.Pop;
 import org.apache.tinkerpop.gremlin.process.traversal.SackFunctions;
+import org.apache.tinkerpop.gremlin.process.traversal.Scope;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversal;
+import org.apache.tinkerpop.gremlin.structure.Column;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality;
 
 import java.util.Map;
@@ -163,7 +170,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_aggregate_String(final GremlinParser.TraversalMethod_aggregate_StringContext ctx) {
-        return graphTraversal.aggregate(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.aggregate(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -172,8 +179,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public GraphTraversal visitTraversalMethod_aggregate_Scope_String(final GremlinParser.TraversalMethod_aggregate_Scope_StringContext ctx) {
         return graphTraversal.aggregate(
-                antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
-                antlr.argumentVisitor.parseString(ctx.stringArgument()));
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
+                antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -207,9 +214,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public GraphTraversal visitTraversalMethod_as(final GremlinParser.TraversalMethod_asContext ctx) {
         if (ctx.getChildCount() == 4) {
-            return graphTraversal.as(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+            return graphTraversal.as(antlr.genericVisitor.parseString(ctx.stringLiteral()));
         } else {
-            return graphTraversal.as(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+            return graphTraversal.as(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                     antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
         }
     }
@@ -235,7 +242,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_barrier_int(final GremlinParser.TraversalMethod_barrier_intContext ctx) {
-        return graphTraversal.barrier(antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
+        return graphTraversal.barrier(antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).intValue());
     }
 
     /**
@@ -243,7 +250,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_both(final GremlinParser.TraversalMethod_bothContext ctx) {
-        return graphTraversal.both(antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
+        return graphTraversal.both(antlr.argumentVisitor.parseStringVarargs(ctx.stringLiteralVarargsArgument()));
     }
 
     /**
@@ -251,7 +258,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_bothE(final GremlinParser.TraversalMethod_bothEContext ctx) {
-        return graphTraversal.bothE(antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
+        return graphTraversal.bothE(antlr.argumentVisitor.parseStringVarargs(ctx.stringLiteralVarargsArgument()));
     }
 
     /**
@@ -291,7 +298,14 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_by_Function(final GremlinParser.TraversalMethod_by_FunctionContext ctx) {
-        return graphTraversal.by(antlr.argumentVisitor.parseFunction(ctx.traversalFunctionArgument()));
+        final GremlinParser.TraversalFunctionContext fctx = ctx.traversalFunction();
+        if (fctx.traversalT() != null) {
+            return graphTraversal.by(TraversalEnumParser.parseTraversalEnumFromContext(T.class, fctx.traversalT()));
+        } else if (fctx.traversalColumn() != null) {
+            return graphTraversal.by(TraversalEnumParser.parseTraversalEnumFromContext(Column.class, fctx.traversalColumn()));
+        } else {
+            throw new GremlinParserException("Invalid traversal function: " + fctx.getText());
+        }
     }
 
     /**
@@ -299,8 +313,15 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_by_Function_Comparator(final GremlinParser.TraversalMethod_by_Function_ComparatorContext ctx) {
-        return graphTraversal.by(antlr.argumentVisitor.parseFunction(ctx.traversalFunctionArgument()),
-                antlr.argumentVisitor.parseComparator(ctx.traversalComparatorArgument()));
+        final GremlinParser.TraversalFunctionContext fctx = ctx.traversalFunction();
+        final Order order = TraversalEnumParser.parseTraversalEnumFromContext(Order.class, ctx.traversalComparator().traversalOrder());
+        if (fctx.traversalT() != null) {
+            return graphTraversal.by(TraversalEnumParser.parseTraversalEnumFromContext(T.class, fctx.traversalT()), order);
+        } else if (fctx.traversalColumn() != null) {
+            return graphTraversal.by(TraversalEnumParser.parseTraversalEnumFromContext(Column.class, fctx.traversalColumn()), order);
+        } else {
+            throw new GremlinParserException("Invalid traversal function: " + fctx.getText());
+        }
     }
 
     /**
@@ -316,7 +337,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_by_String(final GremlinParser.TraversalMethod_by_StringContext ctx) {
-        return graphTraversal.by(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.by(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -324,7 +345,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_by_String_Comparator(final GremlinParser.TraversalMethod_by_String_ComparatorContext ctx) {
-        return graphTraversal.by(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+        return graphTraversal.by(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                 TraversalEnumParser.parseTraversalEnumFromContext(Order.class, ctx.getChild(4)));
     }
 
@@ -333,7 +354,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_by_T(final GremlinParser.TraversalMethod_by_TContext ctx) {
-        return graphTraversal.by(antlr.argumentVisitor.parseT(ctx.traversalTokenArgument()));
+        return graphTraversal.by(TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx.traversalT()));
     }
 
     /**
@@ -359,9 +380,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public GraphTraversal visitTraversalMethod_cap(final GremlinParser.TraversalMethod_capContext ctx) {
         if (ctx.getChildCount() == 4) {
-            return graphTraversal.cap(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+            return graphTraversal.cap(antlr.genericVisitor.parseString(ctx.stringLiteral()));
         } else {
-            return graphTraversal.cap(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+            return graphTraversal.cap(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                     antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
         }
     }
@@ -371,7 +392,14 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_choose_Function(final GremlinParser.TraversalMethod_choose_FunctionContext ctx) {
-        return graphTraversal.choose(antlr.argumentVisitor.parseFunction(ctx.traversalFunctionArgument()));
+        final GremlinParser.TraversalFunctionContext fctx = ctx.traversalFunction();
+        if (fctx.traversalT() != null) {
+            return graphTraversal.choose(TraversalEnumParser.parseTraversalEnumFromContext(T.class, fctx.traversalT()));
+        } else if (fctx.traversalColumn() != null) {
+            return graphTraversal.choose(TraversalEnumParser.parseTraversalEnumFromContext(Column.class, fctx.traversalColumn()));
+        } else {
+            throw new GremlinParserException("Invalid traversal function: " + fctx.getText());
+        }
     }
 
     /**
@@ -475,7 +503,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_count_Scope(final GremlinParser.TraversalMethod_count_ScopeContext ctx) {
-        return graphTraversal.count(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.count(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -491,7 +519,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_dedup_Scope_String(final GremlinParser.TraversalMethod_dedup_Scope_StringContext ctx) {
-        return graphTraversal.dedup(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
+        return graphTraversal.dedup(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
                 antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
     }
 
@@ -564,7 +593,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public Traversal visitTraversalMethod_fail_String(final GremlinParser.TraversalMethod_fail_StringContext ctx) {
-        return this.graphTraversal.fail(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return this.graphTraversal.fail(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -614,7 +643,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_from_String(final GremlinParser.TraversalMethod_from_StringContext ctx) {
-        return graphTraversal.from(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.from(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -638,7 +667,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_groupCount_String(final GremlinParser.TraversalMethod_groupCount_StringContext ctx) {
-        return graphTraversal.groupCount(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.groupCount(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -654,7 +683,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_group_String(final GremlinParser.TraversalMethod_group_StringContext ctx) {
-        return graphTraversal.group(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.group(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -688,9 +717,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public GraphTraversal visitTraversalMethod_hasKey_String_String(final GremlinParser.TraversalMethod_hasKey_String_StringContext ctx) {
         if (ctx.getChildCount() == 4) {
-            return graphTraversal.hasKey(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()));
+            return graphTraversal.hasKey(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()));
         } else {
-            return graphTraversal.hasKey(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
+            return graphTraversal.hasKey(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()),
                     antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
         }
     }
@@ -712,7 +741,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
             return graphTraversal.hasLabel(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()));
         } else {
             return graphTraversal.hasLabel(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
-                    antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
+                    antlr.argumentVisitor.parseStringVarargs(ctx.stringLiteralVarargsArgument()));
         }
     }
 
@@ -721,7 +750,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_hasNot(final GremlinParser.TraversalMethod_hasNotContext ctx) {
-        return graphTraversal.hasNot(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()));
+        return graphTraversal.hasNot(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()));
     }
 
     /**
@@ -746,7 +775,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_String(final GremlinParser.TraversalMethod_has_StringContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()));
+        return graphTraversal.has(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()));
     }
 
     /**
@@ -754,7 +783,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_String_Object(final GremlinParser.TraversalMethod_has_String_ObjectContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
+        return graphTraversal.has(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()),
                 antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument()));
     }
 
@@ -763,7 +792,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_String_P(final GremlinParser.TraversalMethod_has_String_PContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
+        return graphTraversal.has(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()),
                 antlr.traversalPredicateVisitor.visitTraversalPredicate(ctx.traversalPredicate()));
     }
 
@@ -772,8 +801,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_String_String_Object(final GremlinParser.TraversalMethod_has_String_String_ObjectContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument(0)),
-                antlr.argumentVisitor.parseString(ctx.stringNullableArgument(1)),
+        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
+                antlr.genericVisitor.parseString(ctx.stringNullableLiteral()),
                 antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument()));
     }
 
@@ -782,8 +811,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_String_String_P(final GremlinParser.TraversalMethod_has_String_String_PContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument(0)),
-                antlr.argumentVisitor.parseString(ctx.stringNullableArgument(1)),
+        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
+                antlr.genericVisitor.parseString(ctx.stringNullableLiteral()),
                 antlr.traversalPredicateVisitor.visitTraversalPredicate(ctx.traversalPredicate()));
     }
 
@@ -792,7 +821,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_String_Traversal(final GremlinParser.TraversalMethod_has_String_TraversalContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()),
+        return graphTraversal.has(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
 
@@ -801,7 +830,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_T_Object(final GremlinParser.TraversalMethod_has_T_ObjectContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseT(ctx.traversalTokenArgument()),
+        return graphTraversal.has(TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx.traversalT()),
                 antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument()));
     }
 
@@ -810,7 +839,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_T_P(final GremlinParser.TraversalMethod_has_T_PContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseT(ctx.traversalTokenArgument()),
+        return graphTraversal.has(TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx.traversalT()),
                 antlr.traversalPredicateVisitor.visitTraversalPredicate(ctx.traversalPredicate()));
     }
 
@@ -819,7 +848,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_has_T_Traversal(final GremlinParser.TraversalMethod_has_T_TraversalContext ctx) {
-        return graphTraversal.has(antlr.argumentVisitor.parseT(ctx.traversalTokenArgument()),
+        return graphTraversal.has(TraversalEnumParser.parseTraversalEnumFromContext(T.class, ctx.traversalT()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
 
@@ -921,7 +950,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_limit_Scope_long(final GremlinParser.TraversalMethod_limit_Scope_longContext ctx) {
-        return graphTraversal.limit(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
+        return graphTraversal.limit(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
                 antlr.argumentVisitor.parseNumber(ctx.integerArgument()).longValue());
     }
 
@@ -948,12 +978,12 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
 
     @Override
     public GraphTraversal visitTraversalMethod_loops_String(final GremlinParser.TraversalMethod_loops_StringContext ctx) {
-        return graphTraversal.loops(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.loops(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     @Override
     public GraphTraversal visitTraversalMethod_repeat_String_Traversal(final GremlinParser.TraversalMethod_repeat_String_TraversalContext ctx) {
-        return graphTraversal.repeat((antlr.argumentVisitor.parseString(ctx.stringArgument())),
+        return graphTraversal.repeat(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
 
@@ -977,7 +1007,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
         if (ctx.withOptionKeys() != null) {
             return graphTraversal.with((String) WithOptionsVisitor.instance().visitWithOptionKeys(ctx.withOptionKeys()));
         } else {
-            return graphTraversal.with(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+            return graphTraversal.with(antlr.genericVisitor.parseString(ctx.stringLiteral()));
         }
     }
 
@@ -987,7 +1017,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
         if (ctx.withOptionKeys() != null) {
             k = (String) WithOptionsVisitor.instance().visitWithOptionKeys(ctx.withOptionKeys());
         } else {
-            k = antlr.argumentVisitor.parseString(ctx.stringArgument());
+            k = antlr.genericVisitor.parseString(ctx.stringLiteral());
         }
 
         final Object o;
@@ -1036,7 +1066,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_max_Scope(final GremlinParser.TraversalMethod_max_ScopeContext ctx) {
-        return graphTraversal.max(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.max(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1052,7 +1082,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_mean_Scope(final GremlinParser.TraversalMethod_mean_ScopeContext ctx) {
-        return graphTraversal.mean(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.mean(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1076,7 +1106,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_min_Scope(final GremlinParser.TraversalMethod_min_ScopeContext ctx) {
-        return graphTraversal.min(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.min(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1117,7 +1147,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_option_Merge_Map(final GremlinParser.TraversalMethod_option_Merge_MapContext ctx) {
-        return graphTraversal.option(antlr.argumentVisitor.parseMerge(ctx.traversalMergeArgument()),
+        return graphTraversal.option(
+                TraversalEnumParser.parseTraversalEnumFromContext(Merge.class, ctx.traversalMerge()),
                 (Map) antlr.argumentVisitor.visitGenericLiteralMapNullableArgument(ctx.genericLiteralMapNullableArgument()));
     }
 
@@ -1126,7 +1157,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_option_Merge_Traversal(final GremlinParser.TraversalMethod_option_Merge_TraversalContext ctx) {
-        return this.graphTraversal.option(antlr.argumentVisitor.parseMerge(ctx.traversalMergeArgument()),
+        return this.graphTraversal.option(
+                TraversalEnumParser.parseTraversalEnumFromContext(Merge.class, ctx.traversalMerge()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
 
@@ -1136,16 +1168,16 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public Traversal visitTraversalMethod_option_Merge_Map_Cardinality(final GremlinParser.TraversalMethod_option_Merge_Map_CardinalityContext ctx) {
         if (ctx.genericLiteralMapNullableArgument().nullLiteral() != null) {
-            return this.graphTraversal.option(antlr.argumentVisitor.parseMerge(ctx.traversalMergeArgument()), (Map) null);
+            return this.graphTraversal.option(TraversalEnumParser.parseTraversalEnumFromContext(Merge.class, ctx.traversalMerge()), (Map) null);
         }
 
         if (ctx.genericLiteralMapNullableArgument().variable() != null) {
-            return graphTraversal.option(antlr.argumentVisitor.parseMerge(ctx.traversalMergeArgument()),
+            return graphTraversal.option(TraversalEnumParser.parseTraversalEnumFromContext(Merge.class, ctx.traversalMerge()),
                     (Map) antlr.argumentVisitor.visitVariable(ctx.genericLiteralMapNullableArgument().variable()),
                     TraversalEnumParser.parseTraversalEnumFromContext(Cardinality.class, ctx.traversalCardinality()));
         }
 
-        return graphTraversal.option(antlr.argumentVisitor.parseMerge(ctx.traversalMergeArgument()),
+        return graphTraversal.option(TraversalEnumParser.parseTraversalEnumFromContext(Merge.class, ctx.traversalMerge()),
                 (Map) new GenericLiteralVisitor(antlr).visitGenericLiteralMap(ctx.genericLiteralMapNullableArgument().genericLiteralMap()),
                 TraversalEnumParser.parseTraversalEnumFromContext(Cardinality.class, ctx.traversalCardinality()));
     }
@@ -1180,7 +1212,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_order_Scope(final GremlinParser.TraversalMethod_order_ScopeContext ctx) {
-        return graphTraversal.order(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.order(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1196,7 +1228,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_out(final GremlinParser.TraversalMethod_outContext ctx) {
-        return graphTraversal.out(antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
+        return graphTraversal.out(antlr.argumentVisitor.parseStringVarargs(ctx.stringLiteralVarargsArgument()));
     }
 
     /**
@@ -1204,7 +1236,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_outE(final GremlinParser.TraversalMethod_outEContext ctx) {
-        return graphTraversal.outE(antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
+        return graphTraversal.outE(antlr.argumentVisitor.parseStringVarargs(ctx.stringLiteralVarargsArgument()));
     }
 
     /**
@@ -1273,7 +1305,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_profile_String(final GremlinParser.TraversalMethod_profile_StringContext ctx) {
-        return graphTraversal.profile(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.profile(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1282,9 +1314,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public GraphTraversal visitTraversalMethod_project(final GremlinParser.TraversalMethod_projectContext ctx) {
         if (ctx.getChildCount() == 4) {
-            return graphTraversal.project(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+            return graphTraversal.project(antlr.genericVisitor.parseString(ctx.stringLiteral()));
         } else {
-            return graphTraversal.project(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+            return graphTraversal.project(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                     antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
         }
     }
@@ -1318,7 +1350,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_property_Cardinality_Object_Object_Object(final GremlinParser.TraversalMethod_property_Cardinality_Object_Object_ObjectContext ctx) {
-        return graphTraversal.property(antlr.argumentVisitor.parseCardinality(ctx.traversalCardinalityArgument()),
+        return graphTraversal.property(TraversalEnumParser.parseTraversalEnumFromContext(Cardinality.class, ctx.traversalCardinality()),
                 antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument(0)),
                 antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument(1)),
                 antlr.genericVisitor.parseObjectVarargs(ctx.genericLiteralVarargs()));
@@ -1344,7 +1376,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public Traversal visitTraversalMethod_property_Cardinality_Object(final GremlinParser.TraversalMethod_property_Cardinality_ObjectContext  ctx) {
-        return graphTraversal.property(Cardinality.list, antlr.argumentVisitor.parseMap(ctx.genericLiteralMapNullableArgument()));
+        return graphTraversal.property(TraversalEnumParser.parseTraversalEnumFromContext(Cardinality.class, ctx.traversalCardinality()),
+                antlr.argumentVisitor.parseMap(ctx.genericLiteralMapNullableArgument()));
     }
 
     /**
@@ -1360,7 +1393,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_range_Scope_long_long(final GremlinParser.TraversalMethod_range_Scope_long_longContext ctx) {
-        return graphTraversal.range(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
+        return graphTraversal.range(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
                 antlr.argumentVisitor.parseNumber(ctx.integerArgument(0)).longValue(),
                 antlr.argumentVisitor.parseNumber(ctx.integerArgument(1)).longValue());
     }
@@ -1395,7 +1429,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_sample_Scope_int(final GremlinParser.TraversalMethod_sample_Scope_intContext ctx) {
-        return graphTraversal.sample(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
+        return graphTraversal.sample(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
                 antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
     }
 
@@ -1404,7 +1439,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_sample_int(final GremlinParser.TraversalMethod_sample_intContext ctx) {
-        return graphTraversal.sample(antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
+        return graphTraversal.sample(antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).intValue());
     }
 
     /**
@@ -1412,7 +1447,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_select_Column(final GremlinParser.TraversalMethod_select_ColumnContext ctx) {
-        return graphTraversal.select(antlr.argumentVisitor.parseColumn(ctx.traversalColumnArgument()));
+        return graphTraversal.select(TraversalEnumParser.parseTraversalEnumFromContext(Column.class, ctx.traversalColumn()));
     }
 
     /**
@@ -1420,8 +1455,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_select_Pop_String(final GremlinParser.TraversalMethod_select_Pop_StringContext ctx) {
-        return graphTraversal.select(antlr.argumentVisitor.parsePop(ctx.traversalPopArgument()),
-                antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.select(
+                TraversalEnumParser.parseTraversalEnumFromContext(Pop.class, ctx.traversalPop()),
+                antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1429,15 +1465,17 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_select_Pop_String_String_String(final GremlinParser.TraversalMethod_select_Pop_String_String_StringContext ctx) {
-        return graphTraversal.select(antlr.argumentVisitor.parsePop(ctx.traversalPopArgument()),
-                antlr.argumentVisitor.parseString(ctx.stringArgument(0)),
-                antlr.argumentVisitor.parseString(ctx.stringArgument(1)),
+        return graphTraversal.select(
+                TraversalEnumParser.parseTraversalEnumFromContext(Pop.class, ctx.traversalPop()),
+                antlr.genericVisitor.parseString(ctx.stringLiteral(0)),
+                antlr.genericVisitor.parseString(ctx.stringLiteral(1)),
                 antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
     }
 
     @Override
     public GraphTraversal visitTraversalMethod_select_Pop_Traversal(final GremlinParser.TraversalMethod_select_Pop_TraversalContext ctx) {
-        return graphTraversal.select(antlr.argumentVisitor.parsePop(ctx.traversalPopArgument()),
+        return graphTraversal.select(
+                TraversalEnumParser.parseTraversalEnumFromContext(Pop.class, ctx.traversalPop()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
 
@@ -1446,7 +1484,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_select_String(final GremlinParser.TraversalMethod_select_StringContext ctx) {
-        return graphTraversal.select(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.select(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1454,8 +1492,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_select_String_String_String(final GremlinParser.TraversalMethod_select_String_String_StringContext ctx) {
-        return graphTraversal.select(antlr.argumentVisitor.parseString(ctx.stringArgument(0)),
-                antlr.argumentVisitor.parseString(ctx.stringArgument(1)),
+        return graphTraversal.select(antlr.genericVisitor.parseString(ctx.stringLiteral(0)),
+                antlr.genericVisitor.parseString(ctx.stringLiteral(1)),
                 antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
     }
 
@@ -1485,7 +1523,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_skip_Scope_long(final GremlinParser.TraversalMethod_skip_Scope_longContext ctx) {
-        return graphTraversal.skip(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
+        return graphTraversal.skip(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
                 antlr.argumentVisitor.parseNumber(ctx.integerArgument()).longValue());
     }
 
@@ -1502,7 +1541,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_store(final GremlinParser.TraversalMethod_storeContext ctx) {
-        return graphTraversal.store(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.store(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1510,7 +1549,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_subgraph(final GremlinParser.TraversalMethod_subgraphContext ctx) {
-        return graphTraversal.subgraph(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.subgraph(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1526,7 +1565,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_sum_Scope(final GremlinParser.TraversalMethod_sum_ScopeContext ctx) {
-        return graphTraversal.sum(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.sum(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1542,7 +1581,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_tail_Scope(final GremlinParser.TraversalMethod_tail_ScopeContext ctx) {
-        return graphTraversal.tail(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.tail(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1550,7 +1589,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_tail_Scope_long(final GremlinParser.TraversalMethod_tail_Scope_longContext ctx) {
-        return graphTraversal.tail(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
+        return graphTraversal.tail(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
                 antlr.argumentVisitor.parseNumber(ctx.integerArgument()).longValue());
     }
 
@@ -1567,7 +1607,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_timeLimit(final GremlinParser.TraversalMethod_timeLimitContext ctx) {
-        return graphTraversal.timeLimit(antlr.argumentVisitor.parseNumber(ctx.integerArgument()).longValue());
+        return graphTraversal.timeLimit(antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).longValue());
     }
 
     /**
@@ -1575,7 +1615,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_times(final GremlinParser.TraversalMethod_timesContext ctx) {
-        return graphTraversal.times(antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
+        return graphTraversal.times(antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).intValue());
     }
 
     /**
@@ -1583,7 +1623,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_toE(final GremlinParser.TraversalMethod_toEContext ctx) {
-        return graphTraversal.toE(antlr.argumentVisitor.parseDirection(ctx.traversalDirectionArgument()),
+        return graphTraversal.toE(
+                TraversalEnumParser.parseTraversalEnumFromContext(Direction.class, ctx.traversalDirection()),
                 antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
     }
 
@@ -1592,7 +1633,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_toV(final GremlinParser.TraversalMethod_toVContext ctx) {
-        return graphTraversal.toV(antlr.argumentVisitor.parseDirection(ctx.traversalDirectionArgument()));
+        return graphTraversal.toV(TraversalEnumParser.parseTraversalEnumFromContext(Direction.class, ctx.traversalDirection()));
     }
 
     /**
@@ -1600,7 +1641,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_to_Direction_String(final GremlinParser.TraversalMethod_to_Direction_StringContext ctx) {
-        return graphTraversal.to(antlr.argumentVisitor.parseDirection(ctx.traversalDirectionArgument()),
+        return graphTraversal.to(
+                TraversalEnumParser.parseTraversalEnumFromContext(Direction.class, ctx.traversalDirection()),
                 antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
     }
 
@@ -1609,7 +1651,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_to_String(final GremlinParser.TraversalMethod_to_StringContext ctx) {
-        return graphTraversal.to(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.to(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1633,7 +1675,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_tree_String(final GremlinParser.TraversalMethod_tree_StringContext ctx) {
-        return graphTraversal.tree(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.tree(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1691,9 +1733,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
     @Override
     public GraphTraversal visitTraversalMethod_valueMap_boolean_String(final GremlinParser.TraversalMethod_valueMap_boolean_StringContext ctx) {
         if (ctx.getChildCount() == 4) {
-            return graphTraversal.valueMap((boolean) antlr.argumentVisitor.visitBooleanArgument(ctx.booleanArgument()));
+            return graphTraversal.valueMap((boolean) antlr.genericVisitor.visitBooleanLiteral(ctx.booleanLiteral()));
         } else {
-            return graphTraversal.valueMap((boolean) antlr.argumentVisitor.visitBooleanArgument(ctx.booleanArgument()),
+            return graphTraversal.valueMap((boolean) antlr.genericVisitor.visitBooleanLiteral(ctx.booleanLiteral()),
                     antlr.genericVisitor.parseStringVarargs(ctx.stringLiteralVarargs()));
         }
     }
@@ -1719,7 +1761,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_where_String_P(final GremlinParser.TraversalMethod_where_String_PContext ctx) {
-        return graphTraversal.where(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+        return graphTraversal.where(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                 antlr.traversalPredicateVisitor.visitTraversalPredicate(ctx.traversalPredicate()));
     }
 
@@ -1736,7 +1778,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_math(final GremlinParser.TraversalMethod_mathContext ctx) {
-        return graphTraversal.math(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.math(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1777,7 +1819,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public Traversal visitTraversalMethod_call_string(final GremlinParser.TraversalMethod_call_stringContext ctx) {
-        return graphTraversal.call(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.call(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1785,7 +1827,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public Traversal visitTraversalMethod_call_string_map(final GremlinParser.TraversalMethod_call_string_mapContext ctx) {
-        return graphTraversal.call(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+        return graphTraversal.call(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                                    antlr.argumentVisitor.parseMap(ctx.genericLiteralMapArgument()));
     }
 
@@ -1794,7 +1836,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public Traversal visitTraversalMethod_call_string_traversal(final GremlinParser.TraversalMethod_call_string_traversalContext ctx) {
-        return graphTraversal.call(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+        return graphTraversal.call(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
 
@@ -1803,7 +1845,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public Traversal visitTraversalMethod_call_string_map_traversal(final GremlinParser.TraversalMethod_call_string_map_traversalContext ctx) {
-        return graphTraversal.call(antlr.argumentVisitor.parseString(ctx.stringArgument()),
+        return graphTraversal.call(antlr.genericVisitor.parseString(ctx.stringLiteral()),
                 antlr.argumentVisitor.parseMap(ctx.genericLiteralMapArgument()),
                 antlr.tvisitor.visitNestedTraversal(ctx.nestedTraversal()));
     }
@@ -1833,7 +1875,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_format_String(GremlinParser.TraversalMethod_format_StringContext ctx)  {
-        return graphTraversal.format(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+        return graphTraversal.format(antlr.genericVisitor.parseString(ctx.stringLiteral()));
     }
 
     /**
@@ -1849,7 +1891,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_asString_Scope(final GremlinParser.TraversalMethod_asString_ScopeContext ctx) {
-        return graphTraversal.asString(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.asString(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1865,7 +1907,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_toUpper_Scope(final GremlinParser.TraversalMethod_toUpper_ScopeContext ctx) {
-        return graphTraversal.toUpper(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.toUpper(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1881,7 +1923,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_toLower_Scope(final GremlinParser.TraversalMethod_toLower_ScopeContext ctx) {
-        return graphTraversal.toLower(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.toLower(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1897,7 +1939,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_length_Scope(final GremlinParser.TraversalMethod_length_ScopeContext ctx) {
-        return graphTraversal.length(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.length(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1913,7 +1955,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_trim_Scope(final GremlinParser.TraversalMethod_trim_ScopeContext ctx) {
-        return graphTraversal.trim(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.trim(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1929,7 +1971,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_lTrim_Scope(final GremlinParser.TraversalMethod_lTrim_ScopeContext ctx) {
-        return graphTraversal.lTrim(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.lTrim(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1945,7 +1987,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_rTrim_Scope(final GremlinParser.TraversalMethod_rTrim_ScopeContext ctx) {
-        return graphTraversal.rTrim(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()));
+        return graphTraversal.rTrim(TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()));
     }
 
     /**
@@ -1961,8 +2003,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_replace_String_String(final GremlinParser.TraversalMethod_replace_String_StringContext ctx) {
-        return graphTraversal.replace(antlr.argumentVisitor.parseString(ctx.stringNullableArgument(0)),
-                antlr.argumentVisitor.parseString(ctx.stringNullableArgument(1)));
+        return graphTraversal.replace(antlr.genericVisitor.parseString(ctx.stringNullableLiteral(0)),
+                antlr.genericVisitor.parseString(ctx.stringNullableLiteral(1)));
     }
 
     /**
@@ -1970,9 +2012,10 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_replace_Scope_String_String(final GremlinParser.TraversalMethod_replace_Scope_String_StringContext ctx) {
-        return graphTraversal.replace(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
-                antlr.argumentVisitor.parseString(ctx.stringNullableArgument(0)),
-                antlr.argumentVisitor.parseString(ctx.stringNullableArgument(1)));
+        return graphTraversal.replace(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
+                antlr.genericVisitor.parseString(ctx.stringNullableLiteral(0)),
+                antlr.genericVisitor.parseString(ctx.stringNullableLiteral(1)));
     }
 
     /**
@@ -1980,7 +2023,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_split_String(final GremlinParser.TraversalMethod_split_StringContext ctx) {
-        return graphTraversal.split(antlr.argumentVisitor.parseString(ctx.stringNullableArgument()));
+        return graphTraversal.split(antlr.genericVisitor.parseString(ctx.stringNullableLiteral()));
     }
 
     /**
@@ -1988,8 +2031,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_split_Scope_String(final GremlinParser.TraversalMethod_split_Scope_StringContext ctx) {
-        return graphTraversal.split(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
-                antlr.argumentVisitor.parseString(ctx.stringNullableArgument()));
+        return graphTraversal.split(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
+                antlr.genericVisitor.parseString(ctx.stringNullableLiteral()));
     }
 
     /**
@@ -1997,7 +2041,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_substring_int(final GremlinParser.TraversalMethod_substring_intContext ctx) {
-        return graphTraversal.substring(antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
+        return graphTraversal.substring(antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).intValue());
     }
 
     /**
@@ -2005,8 +2049,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_substring_Scope_int(final GremlinParser.TraversalMethod_substring_Scope_intContext ctx) {
-        return graphTraversal.substring(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
-                antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
+        return graphTraversal.substring(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
+                antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).intValue());
     }
 
     /**
@@ -2014,8 +2059,8 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_substring_int_int(final GremlinParser.TraversalMethod_substring_int_intContext ctx) {
-        return graphTraversal.substring(antlr.argumentVisitor.parseNumber(ctx.integerArgument(0)).intValue(),
-                antlr.argumentVisitor.parseNumber(ctx.integerArgument(1)).intValue());
+        return graphTraversal.substring(antlr.genericVisitor.parseIntegral(ctx.integerLiteral(0)).intValue(),
+                antlr.genericVisitor.parseIntegral(ctx.integerLiteral(1)).intValue());
     }
 
     /**
@@ -2023,9 +2068,10 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_substring_Scope_int_int(final GremlinParser.TraversalMethod_substring_Scope_int_intContext ctx) {
-        return graphTraversal.substring(antlr.argumentVisitor.parseScope(ctx.traversalScopeArgument()),
-                antlr.argumentVisitor.parseNumber(ctx.integerArgument(0)).intValue(),
-                antlr.argumentVisitor.parseNumber(ctx.integerArgument(1)).intValue());
+        return graphTraversal.substring(
+                TraversalEnumParser.parseTraversalEnumFromContext(Scope.class, ctx.traversalScope()),
+                antlr.genericVisitor.parseIntegral(ctx.integerLiteral(0)).intValue(),
+                antlr.genericVisitor.parseIntegral(ctx.integerLiteral(1)).intValue());
     }
 
     /**
@@ -2041,8 +2087,9 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_dateAdd(final GremlinParser.TraversalMethod_dateAddContext ctx) {
-        return graphTraversal.dateAdd(antlr.argumentVisitor.parseDT(ctx.traversalDTArgument()),
-                antlr.argumentVisitor.parseNumber(ctx.integerArgument()).intValue());
+        return graphTraversal.dateAdd(
+                TraversalEnumParser.parseTraversalEnumFromContext(DT.class, ctx.traversalDT()),
+                antlr.genericVisitor.parseIntegral(ctx.integerLiteral()).intValue());
     }
 
     /**
@@ -2058,7 +2105,7 @@ public class TraversalMethodVisitor extends TraversalRootVisitor<GraphTraversal>
      */
     @Override
     public GraphTraversal visitTraversalMethod_dateDiff_Date(final GremlinParser.TraversalMethod_dateDiff_DateContext ctx) {
-        return graphTraversal.dateDiff(antlr.argumentVisitor.parseDate(ctx.dateArgument()));
+        return graphTraversal.dateDiff(antlr.genericVisitor.parseDate(ctx.dateLiteral()));
     }
 
 
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitor.java
index e2cad13811..d9f639e0d1 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitor.java
@@ -144,7 +144,7 @@ public class TraversalPredicateVisitor extends DefaultGremlinBaseVisitor<P> {
     @Override
     public P visitTraversalPredicate_within(final GremlinParser.TraversalPredicate_withinContext ctx) {
         // called with no args which is valid for java/groovy
-        if (ctx.getChildCount() == 3) return P.within();
+        if (null == ctx.genericLiteralListArgument()) return P.within();
 
         final Object arguments = antlr.argumentVisitor.visitGenericLiteralListArgument(ctx.genericLiteralListArgument());
 
@@ -166,7 +166,7 @@ public class TraversalPredicateVisitor extends DefaultGremlinBaseVisitor<P> {
     @Override
     public P visitTraversalPredicate_without(final GremlinParser.TraversalPredicate_withoutContext ctx) {
         // called with no args which is valid for java/groovy
-        if (ctx.getChildCount() == 3) return P.without();
+        if (null == ctx.genericLiteralListArgument()) return P.without();
 
         final Object arguments = antlr.argumentVisitor.visitGenericLiteralListArgument(ctx.genericLiteralListArgument());
 
@@ -232,11 +232,11 @@ public class TraversalPredicateVisitor extends DefaultGremlinBaseVisitor<P> {
 
     /**
      * Get 2 generic literal arguments from the antlr parse tree context, where the arguments have the child index
-     * of 2 and 4
+     * of 2 and 4 in the short form and 4 and 6 in the long form (e.g. between(1,2) vs P.between(1,2) respectively)
      */
     private Object[] getDoubleGenericLiteralArgument(final ParseTree ctx) {
-        final int childIndexOfParameterFirst = 2;
-        final int childIndexOfParameterSecond = 4;
+        final int childIndexOfParameterFirst = ctx.getChildCount() == 8 ? 4 : 2;
+        final int childIndexOfParameterSecond = ctx.getChildCount() == 8 ? 6 : 4;
 
         final Object first = antlr.argumentVisitor.visitGenericLiteralArgument(
                 ParseTreeContextCastHelper.castChildToGenericLiteral(ctx, childIndexOfParameterFirst));
@@ -248,10 +248,10 @@ public class TraversalPredicateVisitor extends DefaultGremlinBaseVisitor<P> {
 
     /**
      * Get 1 generic literal argument from the antlr parse tree context, where the arguments have the child index
-     * of 2
+     * of 2 with the short form and 4 on the long form (e.g. eq(1) vs P.eq(1) respectively)
      */
-    private Object getSingleGenericLiteralArgument(final ParseTree ctx) {
-        final int childIndexOfParameterValue = 2;
+    private Object getSingleGenericLiteralArgument(final ParseTree ctx) {;
+        final int childIndexOfParameterValue = ctx.getChildCount() == 6 ? 4 : 2;
 
         return antlr.argumentVisitor.visitGenericLiteralArgument(
                 ParseTreeContextCastHelper.castChildToGenericLiteral(ctx, childIndexOfParameterValue));
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSelfMethodVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSelfMethodVisitor.java
index 28e2528c29..34568da1f2 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSelfMethodVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSelfMethodVisitor.java
@@ -78,7 +78,7 @@ public class TraversalSourceSelfMethodVisitor extends DefaultGremlinBaseVisitor<
             return source.withSack(antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument()));
         } else {
             return source.withSack(antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument()),
-                    (BinaryOperator) antlr.argumentVisitor.visitTraversalBiFunctionArgument(ctx.traversalBiFunctionArgument()));
+                    TraversalEnumParser.parseTraversalEnumFromContext(Operator.class, ctx.traversalBiFunction().traversalOperator()));
         }
     }
 
@@ -94,7 +94,7 @@ public class TraversalSourceSelfMethodVisitor extends DefaultGremlinBaseVisitor<
         } else {
             return source.withSideEffect(antlr.argumentVisitor.parseString(ctx.stringArgument()),
                     antlr.argumentVisitor.visitGenericLiteralArgument(ctx.genericLiteralArgument()),
-                    (BinaryOperator) antlr.argumentVisitor.visitTraversalBiFunctionArgument(ctx.traversalBiFunctionArgument()));
+                    TraversalEnumParser.parseTraversalEnumFromContext(Operator.class, ctx.traversalBiFunction().traversalOperator()));
         }
     }
 
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSpawnMethodVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSpawnMethodVisitor.java
index 2227635f80..22f8d1f769 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSpawnMethodVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalSourceSpawnMethodVisitor.java
@@ -109,7 +109,7 @@ public class TraversalSourceSpawnMethodVisitor extends DefaultGremlinBaseVisitor
     @Override
     public GraphTraversal visitTraversalSourceSpawnMethod_io(final GremlinParser.TraversalSourceSpawnMethod_ioContext ctx) {
         if (ctx.getChildCount() > 2) {
-            this.graphTraversal = this.traversalSource.io(antlr.argumentVisitor.parseString(ctx.stringArgument()));
+            this.graphTraversal = this.traversalSource.io(antlr.genericVisitor.parseString(ctx.stringLiteral()));
         }
         return graphTraversal;
     }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/AbstractTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/AbstractTranslateVisitor.java
index bb771a7548..53c571c532 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/AbstractTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/AbstractTranslateVisitor.java
@@ -49,10 +49,10 @@ public abstract class AbstractTranslateVisitor extends TranslateVisitor {
         return null;
     }
 
-    protected void handleStringLiteralText(final String text) {
-        sb.append("\"");
-        sb.append(text);
-        sb.append("\"");
+    @Override
+    public Void visitNakedKey(final GremlinParser.NakedKeyContext ctx) {
+        handleStringLiteralText(ctx.getText());
+        return null;
     }
 
     @Override
@@ -60,7 +60,7 @@ public abstract class AbstractTranslateVisitor extends TranslateVisitor {
         final String keyword = ctx.getText();
 
         // translate differently based on the context of the keyword's parent.
-        if (ctx.getParent() instanceof GremlinParser.MapEntryContext) {
+        if (ctx.getParent() instanceof GremlinParser.MapKeyContext) {
             // if the keyword is a key in a map, then it's a string literal essentially
             handleStringLiteralText(keyword);
         } else {
@@ -70,4 +70,10 @@ public abstract class AbstractTranslateVisitor extends TranslateVisitor {
 
         return null;
     }
+
+    protected void handleStringLiteralText(final String text) {
+        sb.append("\"");
+        sb.append(text);
+        sb.append("\"");
+    }
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/DotNetTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/DotNetTranslateVisitor.java
index 6811eae2f5..7a0a8f74a7 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/DotNetTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/DotNetTranslateVisitor.java
@@ -79,7 +79,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitInfLiteral(final GremlinParser.InfLiteralContext ctx) {
-        if (ctx.SignedInfLiteral().getText().equals("-Infinity"))
+        if (ctx.SignedInfLiteral() != null && ctx.SignedInfLiteral().getText().equals("-Infinity"))
             sb.append("Double.NegativeInfinity");
         else
             sb.append("Double.PositiveInfinity");
@@ -127,6 +127,9 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         final String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
@@ -223,22 +226,20 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
     @Override
     public Void visitMapEntry(final GremlinParser.MapEntryContext ctx) {
         sb.append("{ ");
-        // if it is a terminal node that isn't a starting form like "(T.id)" then it has to be processed as a string
-        // for Java but otherwise it can just be handled as a generic literal
-        final boolean isKeyWrappedInParens = ctx.getChild(0).getText().equals("(");
-        if (ctx.getChild(0) instanceof TerminalNode && !isKeyWrappedInParens) {
-            handleStringLiteralText(ctx.getChild(0).getText());
-        }  else {
-            final int indexOfActualKey = isKeyWrappedInParens ? 1 : 0;
-            visit(ctx.getChild(indexOfActualKey));
-        }
+        visit(ctx.mapKey());
         sb.append(", ");
-        final int indexOfValue = isKeyWrappedInParens ? 4 : 2;
-        visit(ctx.getChild(indexOfValue)); // value
+        visit(ctx.genericLiteral()); // value
         sb.append(" }");
         return null;
     }
 
+    @Override
+    public Void visitMapKey(final GremlinParser.MapKeyContext ctx) {
+        final int keyIndex = ctx.LPAREN() != null && ctx.RPAREN() != null ? 1 : 0;
+        visit(ctx.getChild(keyIndex));
+        return null;
+    }
+
     @Override
     public Void visitTraversalStrategy(final GremlinParser.TraversalStrategyContext ctx) {
 
@@ -296,25 +297,6 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         return null;
     }
 
-    @Override
-    public Void visitTraversalCardinality(final GremlinParser.TraversalCardinalityContext ctx) {
-        // handle the enum style of cardinality if there is one child, otherwise it's the function call style
-        if (ctx.getChildCount() == 1)
-            appendExplicitNaming(ctx.getText(), VertexProperty.Cardinality.class.getSimpleName());
-        else {
-            String txt = ctx.getChild(0).getText();
-            if (txt.startsWith("Cardinality.")) {
-                txt = txt.replaceFirst("Cardinality.", "");
-            }
-            appendExplicitNaming(txt, "CardinalityValue");
-            appendStepOpen();
-            visit(ctx.getChild(2));
-            appendStepClose();
-        }
-
-        return null;
-    }
-
     @Override
     public Void visitTraversalSourceSpawnMethod_inject(final GremlinParser.TraversalSourceSpawnMethod_injectContext ctx) {
         return handleGenerics(ctx);
@@ -446,7 +428,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("<object>").append("((string) ");
-        visit(ctx.stringArgument());
+        visit(ctx.stringLiteral());
         sb.append(")");
         return null;
     }
@@ -456,7 +438,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("<object>").append("(");
-        visit(ctx.stringArgument());
+        visit(ctx.stringLiteral());
         sb.append(", ");
         sb.append("(IDictionary<object, object>) ");
         visit(ctx.genericLiteralMapArgument());
@@ -469,7 +451,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("<object>").append("(");
-        visit(ctx.stringArgument());
+        visit(ctx.stringLiteral());
         sb.append(", ");
         sb.append("(ITraversal) ");
         visit(ctx.nestedTraversal());
@@ -482,7 +464,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("<object>").append("(");
-        visit(ctx.stringArgument());
+        visit(ctx.stringLiteral());
         sb.append(", ");
         sb.append("(IDictionary<object, object>) ");
         visit(ctx.genericLiteralMapArgument());
@@ -577,8 +559,8 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        tryAppendCastToString(ctx.stringNullableArgument());
-        visit(ctx.stringNullableArgument());
+        tryAppendCastToString(ctx.stringNullableLiteral());
+        visit(ctx.stringNullableLiteral());
         sb.append(", ");
         tryAppendCastToObject(ctx.genericLiteralArgument());
         visit(ctx.genericLiteralArgument());
@@ -591,8 +573,8 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        tryAppendCastToString(ctx.stringNullableArgument());
-        visit(ctx.stringNullableArgument());
+        tryAppendCastToString(ctx.stringNullableLiteral());
+        visit(ctx.stringNullableLiteral());
         sb.append(", ");
         visit(ctx.traversalPredicate());
         sb.append(")");
@@ -604,11 +586,11 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        tryAppendCastToString(ctx.stringNullableArgument(0));
-        visit(ctx.stringNullableArgument(0));
+        tryAppendCastToString(ctx.stringNullableArgument());
+        visit(ctx.stringNullableArgument());
         sb.append(", ");
-        tryAppendCastToString(ctx.stringNullableArgument(1));
-        visit(ctx.stringNullableArgument(1));
+        tryAppendCastToString(ctx.stringNullableLiteral());
+        visit(ctx.stringNullableLiteral());
         sb.append(", ");
         tryAppendCastToObject(ctx.genericLiteralArgument());
         visit(ctx.genericLiteralArgument());
@@ -621,11 +603,11 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        tryAppendCastToString(ctx.stringNullableArgument(0));
-        visit(ctx.stringNullableArgument(0));
+        tryAppendCastToString(ctx.stringNullableArgument());
+        visit(ctx.stringNullableArgument());
         sb.append(", ");
-        tryAppendCastToString(ctx.stringNullableArgument(1));
-        visit(ctx.stringNullableArgument(1));
+        tryAppendCastToString(ctx.stringNullableLiteral());
+        visit(ctx.stringNullableLiteral());
         sb.append(", ");
         visit(ctx.traversalPredicate());
         sb.append(")");
@@ -637,8 +619,8 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        tryAppendCastToString(ctx.stringNullableArgument());
-        visit(ctx.stringNullableArgument());
+        tryAppendCastToString(ctx.stringNullableLiteral());
+        visit(ctx.stringNullableLiteral());
         sb.append(", ");
         visit(ctx.nestedTraversal());
         sb.append(")");
@@ -650,9 +632,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        if (ctx.traversalTokenArgument().variable() != null)
-            sb.append("(T) ");
-        visit(ctx.traversalTokenArgument());
+        visit(ctx.traversalT());
         sb.append(", ");
         tryAppendCastToObject(ctx.genericLiteralArgument());
         visit(ctx.genericLiteralArgument());
@@ -665,9 +645,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        if (ctx.traversalTokenArgument().variable() != null)
-            sb.append("(T) ");
-        visit(ctx.traversalTokenArgument());
+        visit(ctx.traversalT());
         sb.append(", ");
         visit(ctx.traversalPredicate());
         sb.append(")");
@@ -679,9 +657,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         final String step = ctx.getChild(0).getText();
         sb.append(convertToPascalCase(step));
         sb.append("(");
-        if (ctx.traversalTokenArgument().variable() != null)
-            sb.append("(T) ");
-        visit(ctx.traversalTokenArgument());
+        visit(ctx.traversalT());
         sb.append(", ");
         visit(ctx.nestedTraversal());
         sb.append(")");
@@ -705,8 +681,8 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
             final String step = ctx.getChild(0).getText();
             sb.append(convertToPascalCase(step));
             sb.append("(");
-            tryAppendCastToString(ctx.stringNullableArgument());
-            visit(ctx.stringNullableArgument());
+            tryAppendCastToString(ctx.stringNullableLiteral());
+            visit(ctx.stringNullableLiteral());
             sb.append(")");
             return null;
         } else {
@@ -753,7 +729,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
     @Override
     public Void visitTraversalMethod_hasLabel_String_String(final GremlinParser.TraversalMethod_hasLabel_String_StringContext ctx) {
         // if there is only one argument then cast to string otherwise it's ambiguous with hasLabel(P)
-        if (ctx.stringLiteralVarargs() == null || ctx.stringLiteralVarargs().getChildCount() == 0) {
+        if (ctx.stringLiteralVarargsArgument() == null || ctx.stringLiteralVarargsArgument().getChildCount() == 0) {
             final String step = ctx.getChild(0).getText();
             sb.append(convertToPascalCase(step));
             sb.append("(");
@@ -885,7 +861,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         // call is ambiguous without an explicit cast
         visit(ctx.getChild(0));
         sb.append("(");
-        visit(ctx.traversalMergeArgument());
+        visit(ctx.traversalMerge());
         sb.append(", ");
         sb.append("(IDictionary<object, object>) ");
         visit(ctx.genericLiteralMapNullableArgument()); // second argument
@@ -898,7 +874,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         // call is ambiguous without an explicit cast
         visit(ctx.getChild(0));
         sb.append("(");
-        visit(ctx.traversalMergeArgument());
+        visit(ctx.traversalMerge());
         sb.append(", ");
         sb.append("(ITraversal) ");
         visit(ctx.nestedTraversal());
@@ -932,9 +908,7 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
             final String step = ctx.getChild(0).getText();
             sb.append(convertToPascalCase(step));
             sb.append("(");
-            if (ctx.traversalCardinalityArgument().variable() != null)
-                sb.append("(Cardinality) ");
-            visit(ctx.traversalCardinalityArgument());
+            visit(ctx.traversalCardinality());
             sb.append(", ");
             tryAppendCastToObject(ctx.genericLiteralArgument(0));
             visit(ctx.genericLiteralArgument(0));
@@ -1163,8 +1137,19 @@ public class DotNetTranslateVisitor extends AbstractTranslateVisitor {
         }
     }
 
+    @Override
+    protected String getCardinalityFunctionClass() {
+        return "CardinalityValue";
+    }
+
     private void tryAppendCastToString(final GremlinParser.StringNullableArgumentContext ctx) {
-        if (ctx.variable() != null || ctx.stringNullableLiteral().NullLiteral() != null) {
+        if (ctx.variable() != null || ctx.stringNullableLiteral().K_NULL() != null) {
+            sb.append("(string) ");
+        }
+    }
+
+    private void tryAppendCastToString(final GremlinParser.StringNullableLiteralContext ctx) {
+        if (ctx.K_NULL() != null) {
             sb.append("(string) ");
         }
     }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GoTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GoTranslateVisitor.java
index ea3976211f..32130ed631 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GoTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GoTranslateVisitor.java
@@ -64,7 +64,7 @@ public class GoTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitInfLiteral(final GremlinParser.InfLiteralContext ctx) {
-        if (ctx.SignedInfLiteral().getText().equals("-Infinity"))
+        if (ctx.SignedInfLiteral() != null && ctx.SignedInfLiteral().getText().equals("-Infinity"))
             sb.append("math.Inf(-1)");
         else
             sb.append("math.Inf(1)");
@@ -89,6 +89,9 @@ public class GoTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
@@ -150,18 +153,16 @@ public class GoTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitMapEntry(final GremlinParser.MapEntryContext ctx) {
-        // if it is a terminal node that isn't a starting form like "(T.id)" then it has to be processed as a string
-        // for Java but otherwise it can just be handled as a generic literal
-        final boolean isKeyWrappedInParens = ctx.getChild(0).getText().equals("(");
-        if (ctx.getChild(0) instanceof TerminalNode && !isKeyWrappedInParens) {
-            handleStringLiteralText(ctx.getChild(0).getText());
-        }  else {
-            final int indexOfActualKey = isKeyWrappedInParens ? 1 : 0;
-            visit(ctx.getChild(indexOfActualKey));
-        }
+        visit(ctx.mapKey());
         sb.append(": ");
-        final int indexOfValue = isKeyWrappedInParens ? 4 : 2;
-        visit(ctx.getChild(indexOfValue)); // value
+        visit(ctx.genericLiteral());
+        return null;
+    }
+
+    @Override
+    public Void visitMapKey(final GremlinParser.MapKeyContext ctx) {
+        final int keyIndex = ctx.LPAREN() != null && ctx.RPAREN() != null ? 1 : 0;
+        visit(ctx.getChild(keyIndex));
         return null;
     }
 
@@ -283,22 +284,8 @@ public class GoTranslateVisitor extends AbstractTranslateVisitor {
     }
 
     @Override
-    public Void visitTraversalCardinality(final GremlinParser.TraversalCardinalityContext ctx) {
-        // handle the enum style of cardinality if there is one child, otherwise it's the function call style
-        if (ctx.getChildCount() == 1)
-            appendExplicitNaming(ctx.getText(), VertexProperty.Cardinality.class.getSimpleName());
-        else {
-            String txt = ctx.getChild(0).getText();
-            if (txt.startsWith("Cardinality.")) {
-                txt = txt.replaceFirst("Cardinality.", "");
-            }
-            appendExplicitNaming(txt, "CardinalityValue");
-            appendStepOpen();
-            visit(ctx.getChild(2));
-            appendStepClose();
-        }
-
-        return null;
+    protected String getCardinalityFunctionClass() {
+        return "CardinalityValue";
     }
 
     protected void visitP(final ParserRuleContext ctx, final Class<?> clazzOfP, final String methodName) {
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GroovyTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GroovyTranslateVisitor.java
index 40a35cffe4..f2c51a8a61 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GroovyTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/GroovyTranslateVisitor.java
@@ -92,6 +92,9 @@ public class GroovyTranslateVisitor extends TranslateVisitor {
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         final String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
@@ -117,11 +120,10 @@ public class GroovyTranslateVisitor extends TranslateVisitor {
 
     @Override
     public Void visitInfLiteral(final GremlinParser.InfLiteralContext ctx) {
-        if (ctx.SignedInfLiteral().getText().equals("-Infinity")) {
+        if (ctx.SignedInfLiteral() != null && ctx.SignedInfLiteral().getText().equals("-Infinity"))
             sb.append("Double.NEGATIVE_INFINITY");
-        } else {
+        else
             sb.append("Double.POSITIVE_INFINITY");
-        }
         return null;
     }
 
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavaTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavaTranslateVisitor.java
index 9802e26db0..f0843b18d8 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavaTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavaTranslateVisitor.java
@@ -134,22 +134,20 @@ public class JavaTranslateVisitor extends AbstractTranslateVisitor {
     @Override
     public Void visitMapEntry(final GremlinParser.MapEntryContext ctx) {
         sb.append("put(");
-        // if it is a terminal node that isn't a starting form like "(T.id)" then it has to be processed as a string
-        // for Java but otherwise it can just be handled as a generic literal
-        final boolean isKeyWrappedInParens = ctx.getChild(0).getText().equals("(");
-        if (ctx.getChild(0) instanceof TerminalNode && !isKeyWrappedInParens) {
-            handleStringLiteralText(ctx.getChild(0).getText());
-        }  else {
-            final int indexOfActualKey = isKeyWrappedInParens ? 1 : 0;
-            visit(ctx.getChild(indexOfActualKey));
-        }
+        visit(ctx.mapKey());
         sb.append(", ");
-        final int indexOfValue = isKeyWrappedInParens ? 4 : 2;
-        visit(ctx.getChild(indexOfValue)); // value
+        visit(ctx.genericLiteral()); // value
         sb.append(");");
         return null;
     }
 
+    @Override
+    public Void visitMapKey(final GremlinParser.MapKeyContext ctx) {
+        final int keyIndex = ctx.LPAREN() != null && ctx.RPAREN() != null ? 1 : 0;
+        visit(ctx.getChild(keyIndex));
+        return null;
+    }
+
     @Override
     public Void visitDateLiteral(final GremlinParser.DateLiteralContext ctx) {
         // child at 2 is the date argument to datetime() and comes enclosed in quotes
@@ -169,7 +167,7 @@ public class JavaTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitInfLiteral(final GremlinParser.InfLiteralContext ctx) {
-        if (ctx.SignedInfLiteral().getText().equals("-Infinity"))
+        if (ctx.SignedInfLiteral() != null && ctx.SignedInfLiteral().getText().equals("-Infinity"))
             sb.append("Double.NEGATIVE_INFINITY");
         else
             sb.append("Double.POSITIVE_INFINITY");
@@ -220,6 +218,9 @@ public class JavaTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         final String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavascriptTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavascriptTranslateVisitor.java
index e6deeea7e2..364b1f5ad6 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavascriptTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/JavascriptTranslateVisitor.java
@@ -113,22 +113,23 @@ public class JavascriptTranslateVisitor extends AbstractTranslateVisitor {
     @Override
     public Void visitMapEntry(final GremlinParser.MapEntryContext ctx) {
         // if it is a terminal node that isn't a starting form like "(T.id)" then it has to be processed as a string
-        // for Java but otherwise it can just be handled as a generic literal
+        // for Javascript but otherwise it can just be handled as a generic literal
         final boolean isKeyWrappedInParens = ctx.getChild(0).getText().equals("(");
         sb.append("[");
-        if (ctx.getChild(0) instanceof TerminalNode && !isKeyWrappedInParens) {
-            wrapTextInQuotes(ctx.getChild(0).getText());
-        }  else {
-            final int indexOfActualKey = isKeyWrappedInParens ? 1 : 0;
-            visit(ctx.getChild(indexOfActualKey));
-        }
+        visit(ctx.mapKey());
         sb.append(", ");
-        final int indexOfValue = isKeyWrappedInParens ? 4 : 2;
-        visit(ctx.getChild(indexOfValue)); // value
+        visit(ctx.genericLiteral()); // value
         sb.append("]");
         return null;
     }
 
+    @Override
+    public Void visitMapKey(final GremlinParser.MapKeyContext ctx) {
+        final int keyIndex = ctx.LPAREN() != null && ctx.RPAREN() != null ? 1 : 0;
+        visit(ctx.getChild(keyIndex));
+        return null;
+    }
+
     @Override
     public Void visitDateLiteral(final GremlinParser.DateLiteralContext ctx) {
         // child at 2 is the date argument to datetime() and comes enclosed in quotes
@@ -148,7 +149,7 @@ public class JavascriptTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitInfLiteral(final GremlinParser.InfLiteralContext ctx) {
-        if (ctx.SignedInfLiteral().getText().equals("-Infinity"))
+        if (ctx.SignedInfLiteral() != null && ctx.SignedInfLiteral().getText().equals("-Infinity"))
             sb.append("Number.NEGATIVE_INFINITY");
         else
             sb.append("Number.POSITIVE_INFINITY");
@@ -173,6 +174,9 @@ public class JavascriptTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         final String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
@@ -219,22 +223,8 @@ public class JavascriptTranslateVisitor extends AbstractTranslateVisitor {
     }
 
     @Override
-    public Void visitTraversalCardinality(final GremlinParser.TraversalCardinalityContext ctx) {
-        // handle the enum style of cardinality if there is one child, otherwise it's the function call style
-        if (ctx.getChildCount() == 1)
-            appendExplicitNaming(ctx.getText(), VertexProperty.Cardinality.class.getSimpleName());
-        else {
-            String txt = ctx.getChild(0).getText();
-            if (txt.startsWith("Cardinality.")) {
-                txt = txt.replaceFirst("Cardinality.", "");
-            }
-            appendExplicitNaming(txt, "CardinalityValue");
-            appendStepOpen();
-            visit(ctx.getChild(2));
-            appendStepClose();
-        }
-
-        return null;
+    protected String getCardinalityFunctionClass() {
+        return "CardinalityValue";
     }
 
     @Override
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/PythonTranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/PythonTranslateVisitor.java
index f90165f76f..9d2109b2da 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/PythonTranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/PythonTranslateVisitor.java
@@ -19,7 +19,6 @@
 package org.apache.tinkerpop.gremlin.language.translator;
 
 import org.antlr.v4.runtime.tree.ParseTree;
-import org.antlr.v4.runtime.tree.TerminalNode;
 import org.apache.tinkerpop.gremlin.language.grammar.GremlinParser;
 import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategies;
 import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;
@@ -143,17 +142,18 @@ public class PythonTranslateVisitor extends AbstractTranslateVisitor {
     @Override
     public Void visitMapEntry(final GremlinParser.MapEntryContext ctx) {
         // if it is a terminal node that isn't a starting form like "(T.id)" then it has to be processed as a string
-        // for Java but otherwise it can just be handled as a generic literal
-        final boolean isKeyWrappedInParens = ctx.getChild(0).getText().equals("(");
-        if (ctx.getChild(0) instanceof TerminalNode && !isKeyWrappedInParens) {
-            handleStringLiteralText(ctx.getChild(0).getText());
-        }  else {
-            final int indexOfActualKey = isKeyWrappedInParens ? 1 : 0;
-            visit(ctx.getChild(indexOfActualKey));
-        }
+        // for python but otherwise it can just be handled as a generic literal
+        final GremlinParser.MapKeyContext mapKeyContext = ctx.mapKey();
+        visit(mapKeyContext);
         sb.append(": ");
-        final int indexOfValue = isKeyWrappedInParens ? 4 : 2;
-        visit(ctx.getChild(indexOfValue)); // value
+        visit(ctx.getChild(2)); // value
+        return null;
+    }
+
+    @Override
+    public Void visitMapKey(final GremlinParser.MapKeyContext ctx) {
+        final int keyIndex = ctx.LPAREN() != null && ctx.RPAREN() != null ? 1 : 0;
+        visit(ctx.getChild(keyIndex));
         return null;
     }
 
@@ -180,7 +180,7 @@ public class PythonTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitInfLiteral(final GremlinParser.InfLiteralContext ctx) {
-        if (ctx.SignedInfLiteral().getText().equals("-Infinity"))
+        if (ctx.SignedInfLiteral() != null && ctx.SignedInfLiteral().getText().equals("-Infinity"))
             sb.append("float('-inf')");
         else
             sb.append("float('inf')");
@@ -245,6 +245,9 @@ public class PythonTranslateVisitor extends AbstractTranslateVisitor {
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
+
         final String floatLiteral = ctx.getText().toLowerCase();
 
         // check suffix
@@ -296,22 +299,8 @@ public class PythonTranslateVisitor extends AbstractTranslateVisitor {
     }
 
     @Override
-    public Void visitTraversalCardinality(final GremlinParser.TraversalCardinalityContext ctx) {
-        // handle the enum style of cardinality if there is one child, otherwise it's the function call style
-        if (ctx.getChildCount() == 1)
-            appendExplicitNaming(ctx.getText(), VertexProperty.Cardinality.class.getSimpleName());
-        else {
-            String txt = ctx.getChild(0).getText();
-            if (txt.startsWith("Cardinality.")) {
-                txt = txt.replaceFirst("Cardinality.", "");
-            }
-            appendExplicitNaming(txt, "CardinalityValue");
-            appendStepOpen();
-            visit(ctx.getChild(2));
-            appendStepClose();
-        }
-
-        return null;
+    protected String getCardinalityFunctionClass() {
+        return "CardinalityValue";
     }
 
     @Override
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/TranslateVisitor.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/TranslateVisitor.java
index ba8f0680ba..19051670d3 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/TranslateVisitor.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/language/translator/TranslateVisitor.java
@@ -20,6 +20,7 @@ package org.apache.tinkerpop.gremlin.language.translator;
 
 import org.antlr.v4.runtime.ParserRuleContext;
 import org.antlr.v4.runtime.tree.AbstractParseTreeVisitor;
+import org.antlr.v4.runtime.tree.ParseTree;
 import org.antlr.v4.runtime.tree.TerminalNode;
 import org.apache.tinkerpop.gremlin.language.grammar.GremlinParser;
 import org.apache.tinkerpop.gremlin.language.grammar.GremlinVisitor;
@@ -39,7 +40,9 @@ import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality;
 
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 /**
  * A Gremlin to Gremlin translator. Makes no changes to input except:
@@ -1477,6 +1480,11 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
         return visitChildren(ctx);
     }
 
+    @Override
+    public Void visitStructureVertexArgument(GremlinParser.StructureVertexArgumentContext ctx) {
+        return visitChildren(ctx);
+    }
+
     @Override
     public Void visitTraversalStrategy(final GremlinParser.TraversalStrategyContext ctx) {
         return visitChildren(ctx);
@@ -1489,7 +1497,7 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
     }
 
     @Override
-    public Void visitTraversalToken(final GremlinParser.TraversalTokenContext ctx) {
+    public Void visitTraversalT(final GremlinParser.TraversalTContext ctx) {
         appendExplicitNaming(ctx.getText(), T.class.getSimpleName());
         return null;
     }
@@ -1520,14 +1528,16 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
 
     @Override
     public Void visitTraversalCardinality(final GremlinParser.TraversalCardinalityContext ctx) {
-        // handle the enum style of cardinality if there is one child, otherwise it's the function call style
-        if (ctx.getChildCount() == 1)
-            appendExplicitNaming(ctx.getText(), Cardinality.class.getSimpleName());
-        else {
-            appendExplicitNaming(ctx.getChild(0).getText(), Cardinality.class.getSimpleName());
+        // handle the enum style of cardinality if there are no parens otherwise is the function call.
+        if (ctx.LPAREN() != null && ctx.RPAREN() != null) {
+            final int idx = ctx.K_CARDINALITY() != null ? 2 : 0;
+            final String txt = ctx.getChild(idx).getText();
+            appendExplicitNaming(txt, getCardinalityFunctionClass());
             appendStepOpen();
-            visit(ctx.getChild(2));
+            visit(ctx.genericLiteral());
             appendStepClose();
+        } else {
+            appendExplicitNaming(ctx.getText(), "Cardinality");
         }
 
         return null;
@@ -1633,21 +1643,16 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
         sb.append(processGremlinSymbol(methodName));
         appendStepOpen();
 
-        // if there are commas then there are multiple arguments that are being handled literally e.g. between
-        final long commas = ctx.children.stream().filter(t -> t instanceof TerminalNode && t.getText().equals(",")).count();
-        if (commas > 0) {
-            // the number of commas indicates how many arguments there are. for each argument, visit the child
-            for (int ix = 0; ix < (commas * 2) + 1; ix+=2) {
-                visit(ctx.getChild(ix + 2));
-                if (ix < commas) {
-                    appendArgumentSeparator();
-                }
-            }
-        } else {
-            // there is only one argument, visit the child
-            if (ctx.getChildCount() > 3)
-                visit(ctx.getChild(2));
+        final List<ParseTree> list =  ctx.children.stream().filter(
+                t -> t instanceof GremlinParser.GenericLiteralArgumentContext ||
+                              t instanceof GremlinParser.GenericLiteralListArgumentContext ||
+                              t instanceof GremlinParser.StringArgumentContext ||
+                              t instanceof GremlinParser.TraversalPredicateContext).collect(Collectors.toList());
+        for (int ix = 0; ix < list.size(); ix++) {
+            visit(list.get(ix));
+            if (ix < list.size() - 1) appendArgumentSeparator();
         }
+
         appendStepClose();
     }
 
@@ -2074,76 +2079,6 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
         return visitChildren(ctx);
     }
 
-    @Override
-    public Void visitStructureVertexArgument(final GremlinParser.StructureVertexArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalCardinalityArgument(final GremlinParser.TraversalCardinalityArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalColumnArgument(final GremlinParser.TraversalColumnArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalDirectionArgument(final GremlinParser.TraversalDirectionArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalMergeArgument(final GremlinParser.TraversalMergeArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalOrderArgument(final GremlinParser.TraversalOrderArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalPopArgument(final GremlinParser.TraversalPopArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalSackMethodArgument(final GremlinParser.TraversalSackMethodArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalScopeArgument(final GremlinParser.TraversalScopeArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalTokenArgument(final GremlinParser.TraversalTokenArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalComparatorArgument(final GremlinParser.TraversalComparatorArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalFunctionArgument(final GremlinParser.TraversalFunctionArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalBiFunctionArgument(final GremlinParser.TraversalBiFunctionArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
-    @Override
-    public Void visitTraversalDTArgument(final GremlinParser.TraversalDTArgumentContext ctx) {
-        return visitChildren(ctx);
-    }
-
     @Override
     public Void visitTraversalStrategyList(final GremlinParser.TraversalStrategyListContext ctx) {
         return visitChildren(ctx);
@@ -2242,6 +2177,8 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
 
     @Override
     public Void visitFloatLiteral(final GremlinParser.FloatLiteralContext ctx) {
+        if (ctx.infLiteral() != null) return visit(ctx.infLiteral());
+        if (ctx.nanLiteral() != null) return visit(ctx.nanLiteral());
         sb.append(ctx.getText().toLowerCase());
         return null;
     }
@@ -2318,7 +2255,7 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
         final String keyword = ctx.getText();
 
         // translate differently based on the context of the keyword's parent.
-        if (ctx.getParent() instanceof GremlinParser.MapEntryContext || ctx.getParent() instanceof GremlinParser.ConfigurationContext) {
+        if (ctx.getParent() instanceof GremlinParser.MapKeyContext || ctx.getParent() instanceof GremlinParser.ConfigurationContext) {
             // if the keyword is a key in a map, then it's a string literal essentially
             sb.append(keyword);
         } else {
@@ -2352,7 +2289,7 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
                 // seems we still sometimes interpret this as a TerminalNode like when newing up a class
                 // which is optional syntax and will go away in the future.
                 sb.append("new");
-                if (!(node.getParent() instanceof GremlinParser.MapEntryContext))
+                if (!(node.getParent() instanceof GremlinParser.MapKeyContext))
                     sb.append(" "); // includes a space for when not use in context of a Map entry key...one off
                 break;
             default:
@@ -2361,6 +2298,50 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
         return null;
     }
 
+    @Override
+    public Void visitTraversalTShort(final GremlinParser.TraversalTShortContext ctx) {
+        appendExplicitNaming(ctx.getText(), T.class.getSimpleName());
+        return null;
+    }
+
+    @Override
+    public Void visitTraversalTLong(final GremlinParser.TraversalTLongContext ctx) {
+        appendExplicitNaming(ctx.getText(), T.class.getSimpleName());
+        return null;
+    }
+
+    @Override
+    public Void visitTraversalDirectionShort(final GremlinParser.TraversalDirectionShortContext ctx) {
+        appendExplicitNaming(ctx.getText(), Direction.class.getSimpleName());
+        return null;
+    }
+
+    @Override
+    public Void visitTraversalDirectionLong(final GremlinParser.TraversalDirectionLongContext ctx) {
+        appendExplicitNaming(ctx.getText(), Direction.class.getSimpleName());
+        return null;
+    }
+
+    @Override
+    public Void visitGenericLiteralMapNullable(final GremlinParser.GenericLiteralMapNullableContext ctx) {
+        return visitChildren(ctx);
+    }
+
+    @Override
+    public Void visitStringLiteralVarargsArgument(final GremlinParser.StringLiteralVarargsArgumentContext ctx) {
+        return visitChildren(ctx);
+    }
+
+    @Override
+    public Void visitMapKey(final GremlinParser.MapKeyContext ctx) {
+        return visitChildren(ctx);
+    }
+
+    @Override
+    public Void visitNakedKey(final GremlinParser.NakedKeyContext ctx) {
+        return visitChildren(ctx);
+    }
+
     protected void appendExplicitNaming(final String txt, final String prefix) {
         if (!txt.startsWith(prefix + ".")) {
             sb.append(processGremlinSymbol(prefix)).append(".");
@@ -2375,4 +2356,8 @@ public class TranslateVisitor extends AbstractParseTreeVisitor<Void> implements
     protected void appendAnonymousSpawn() {
         sb.append("__.");
     }
+
+    protected String getCardinalityFunctionClass() {
+        return Cardinality.class.getSimpleName();
+    }
 }
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/AddPropertyStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/AddPropertyStep.java
index 7d155a40bd..3dfef89285 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/AddPropertyStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/sideEffect/AddPropertyStep.java
@@ -106,10 +106,6 @@ public class AddPropertyStep<S extends Element> extends SideEffectStep<S>
                     "Property cardinality can only be set for a Vertex but the traversal encountered %s for key: %s",
                     element.getClass().getSimpleName(), key));
 
-        VertexProperty.Cardinality cardinality = this.cardinality != null
-                ? this.cardinality
-                : element.graph().features().vertex().getCardinality(key);
-
         final Optional<EventStrategy> optEventStrategy = getTraversal().getStrategies().getStrategy(EventStrategy.class);
         final boolean eventingIsConfigured = EventUtil.hasAnyCallbacks(callbackRegistry)
                 && optEventStrategy.isPresent();
@@ -120,10 +116,14 @@ public class AddPropertyStep<S extends Element> extends SideEffectStep<S>
                 captureRemovedProperty(element, key, value, es) :
                 VertexProperty.empty();
 
+        final VertexProperty.Cardinality card = this.cardinality != null
+                ? this.cardinality
+                : element.graph().features().vertex().getCardinality(key);
+
         // update property
         if (element instanceof Vertex) {
-            if (null != this.cardinality) {
-                ((Vertex) element).property(this.cardinality, key, value, vertexPropertyKeyValues);
+            if (null != card) {
+                ((Vertex) element).property(card, key, value, vertexPropertyKeyValues);
             } else if (vertexPropertyKeyValues.length > 0) {
                 ((Vertex) element).property(key, value, vertexPropertyKeyValues);
             } else {
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitorTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitorTest.java
index 43f33054b5..09f211ea81 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitorTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/ArgumentVisitorTest.java
@@ -110,55 +110,11 @@ public class ArgumentVisitorTest {
                 {Object.class, "'test'", "test", createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
                 {Object.class, "x", "test", createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "test")))},
                 {Object.class, "x", now, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", now)))},
-                {Object.class, "[1,2,3]", Arrays.asList(1, 2, 3), createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", now)))},
+                {Object.class, "[1,2,3]", Arrays.asList(1, 2, 3), createAntlr(VariableResolver.NoVariableResolver.instance())},
                 {Object.class, "x", P.eq(100), createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", P.eq(100))))},
-                {Direction.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Direction.class, "Direction.OUT", Direction.OUT, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Direction.class, "OUT", Direction.OUT, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Direction.class, "x", Direction.OUT, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Direction.OUT)))},
-                {Direction.class, "x", Direction.from, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Direction.from)))},
                 {Vertex.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
                 {Vertex.class, "new Vertex(1i,'person')", new ReferenceVertex(1, "person"), createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Direction.from)))},
                 {Vertex.class, "x", new ReferenceVertex(1, "person"), createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", new ReferenceVertex(1, "person"))))},
-                {Order.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Order.class, "Order.desc", Order.desc, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Order.class, "x", Order.desc, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Order.desc)))},
-                {Scope.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Scope.class, "Scope.local", Scope.local, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Scope.class, "local", Scope.local, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Scope.class, "x", Scope.local, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Scope.local)))},
-                {T.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {T.class, "T.label", T.label, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {T.class, "label", T.label, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {T.class, "x", T.label, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", T.label)))},
-                {VertexProperty.Cardinality.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {VertexProperty.Cardinality.class, "Cardinality.list", VertexProperty.Cardinality.list, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {VertexProperty.Cardinality.class, "list", VertexProperty.Cardinality.list, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {VertexProperty.Cardinality.class, "x", VertexProperty.Cardinality.list, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", VertexProperty.Cardinality.list)))},
-                {DT.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {DT.class, "DT.hour", DT.hour, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {DT.class, "hour", DT.hour, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {DT.class, "x", DT.hour, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", DT.hour)))},
-                {Merge.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Merge.class, "Merge.onMatch", Merge.onMatch, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Merge.class, "onMatch", Merge.onMatch, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Merge.class, "x", Merge.onMatch, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Merge.onMatch)))},
-                {Pop.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Pop.class, "Pop.last", Pop.last, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Pop.class, "last", Pop.last, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Pop.class, "x", Pop.last, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Pop.last)))},
-                {Operator.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Operator.class, "Operator.sum", Operator.sum, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Operator.class, "sum", Operator.sum, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Operator.class, "x", Operator.sum, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Operator.sum)))},
-                {Column.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {Column.class, "Column.keys", Column.keys, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Column.class, "keys", Column.keys, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {Column.class, "x", Column.keys, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", Column.keys)))},
-                {SackFunctions.Barrier.class, "x", new VariableResolverException("x"), createAntlr(VariableResolver.NoVariableResolver.instance())},
-                {SackFunctions.Barrier.class, "Barrier.normSack", SackFunctions.Barrier.normSack, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {SackFunctions.Barrier.class, "Barrier.normSack", SackFunctions.Barrier.normSack, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", "nope")))},
-                {SackFunctions.Barrier.class, "x", SackFunctions.Barrier.normSack, createAntlr(new VariableResolver.DefaultVariableResolver(ElementHelper.asMap("x", SackFunctions.Barrier.normSack)))},
         });
     }
 
@@ -201,68 +157,13 @@ public class ArgumentVisitorTest {
                 final GremlinParser.GenericLiteralListArgumentContext ctx = parser.genericLiteralListArgument();
                 return antlrToLanguage.argumentVisitor.parseObjectVarargs(ctx);
             });
-        } else if (clazz.equals(Direction.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalDirectionArgumentContext ctx = parser.traversalDirectionArgument();
-                return antlrToLanguage.argumentVisitor.parseDirection(ctx);
-            });
         } else if (clazz.equals(Vertex.class)) {
             assertParsing(() -> {
                 final GremlinParser.StructureVertexArgumentContext ctx = parser.structureVertexArgument();
                 return antlrToLanguage.argumentVisitor.parseVertex(ctx);
             });
-        } else if (clazz.equals(Order.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalOrderArgumentContext ctx = parser.traversalOrderArgument();
-                return antlrToLanguage.argumentVisitor.parseOrder(ctx);
-            });
-        } else if (clazz.equals(Scope.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalScopeArgumentContext ctx = parser.traversalScopeArgument();
-                return antlrToLanguage.argumentVisitor.parseScope(ctx);
-            });
-        } else if (clazz.equals(T.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalTokenArgumentContext ctx = parser.traversalTokenArgument();
-                return antlrToLanguage.argumentVisitor.parseT(ctx);
-            });
-        } else if (clazz.equals(VertexProperty.Cardinality.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalCardinalityArgumentContext ctx = parser.traversalCardinalityArgument();
-                return antlrToLanguage.argumentVisitor.parseCardinality(ctx);
-            });
-        } else if (clazz.equals(DT.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalDTArgumentContext ctx = parser.traversalDTArgument();
-                return antlrToLanguage.argumentVisitor.parseDT(ctx);
-            });
-        } else if (clazz.equals(Merge.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalMergeArgumentContext ctx = parser.traversalMergeArgument();
-                return antlrToLanguage.argumentVisitor.parseMerge(ctx);
-            });
-        } else if (clazz.equals(Pop.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalPopArgumentContext ctx = parser.traversalPopArgument();
-                return antlrToLanguage.argumentVisitor.parsePop(ctx);
-            });
-        } else if (clazz.equals(Operator.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalBiFunctionArgumentContext ctx = parser.traversalBiFunctionArgument();
-                return antlrToLanguage.argumentVisitor.visitTraversalBiFunctionArgument(ctx);
-            });
-        } else if (clazz.equals(Column.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalColumnArgumentContext ctx = parser.traversalColumnArgument();
-                return antlrToLanguage.argumentVisitor.parseColumn(ctx);
-            });
-        } else if (clazz.equals(SackFunctions.Barrier.class)) {
-            assertParsing(() -> {
-                final GremlinParser.TraversalSackMethodArgumentContext ctx = parser.traversalSackMethodArgument();
-                return antlrToLanguage.argumentVisitor.visitTraversalSackMethodArgument(ctx);
-            });
         } else {
-            fail("Missing an assertion type");
+            fail("Missing an assertion type: " + clazz.getSimpleName());
         }
     }
 
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/GeneralLiteralVisitorTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/GeneralLiteralVisitorTest.java
index 175f9129d2..d7b4ffbe24 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/GeneralLiteralVisitorTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/GeneralLiteralVisitorTest.java
@@ -20,6 +20,8 @@ package org.apache.tinkerpop.gremlin.language.grammar;
 
 import org.antlr.v4.runtime.CharStreams;
 import org.antlr.v4.runtime.CommonTokenStream;
+import org.apache.tinkerpop.gremlin.structure.Direction;
+import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.VertexProperty;
 import org.hamcrest.Matchers;
 import org.junit.Assert;
@@ -37,6 +39,7 @@ import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -537,39 +540,49 @@ public class GeneralLiteralVisitorTest {
         public String script;
 
         @Parameterized.Parameter(value = 1)
-        public int expectedNumKeysInMap;
+        public Map<Object, Object> expectedMap;
 
-        @Parameterized.Parameters()
+        @Parameterized.Parameters(name = "{index}: shouldParse({0})")
         public static Iterable<Object[]> generateTestParameters() {
             return Arrays.asList(new Object[][]{
-                    {"[\"name\":\"simba\"]", 1},
-                    {"[(\"name\"):\"simba\"]", 1},
-                    {"[name:\"simba\", age: 29]", 2},
-                    {"[:]", 0},
-                    {"[1:'a']", 1},
-                    {"[edges: 'person', T.id: 1]", 2},
-                    {"[label: 'person', T.id: 1]", 2},
-                    {"[(label): 'person', (T.id): 1]", 2},
-                    {"[from: 'source', Direction.to: 'target']", 2},
-                    {"[(from): 'source', (Direction.to): 'target']", 2},
-                    {"[\"name\":\"simba\",\"age\":32]", 2},
-                    {"[\"name\":\"simba\",\"age\":[2,3]]", 2},
-                    {"[(3I):\"32\",([1I, 2I, 3.1D]):4I,\"x\":4I,\"+x\":8I]", 4},
-                    {"[(3I):\"32\",[1I, 2I, 3.1D]:4I,\"x\":4I,\"+x\":8I]", 4},
-                    {"[[label: 'person', T.id: 1]:\"x\"]", 1},
-                    {"[([label: 'person', T.id: 1]):\"x\"]", 1},
-                    {"[new: true]", 1},
-                    {"[new : true]", 1},
-                    {"['new' : true]", 1},
-                    {"[s: {'x'}]", 1},
-                    {"[l: ['x']]", 1},
-                    {"[({'x'}): 'x']", 1},
-                    {"[{'x'}: 'x']", 1},
-                    {"[['x']: ['x',{'y'}]]", 1},
-                    {"[['x']: ['x',['y']]]", 1},
+                    {"[\"name\":\"simba\"]", createMap(new Object[]{"name", "simba"})},
+                    {"[(\"name\"):\"simba\"]", createMap(new Object[]{"name", "simba"})},
+                    {"[name:\"simba\", age: 29]", createMap(new Object[]{"name", "simba", "age", 29})},
+                    {"[:]", createMap(new Object[]{})},
+                    {"[1:'a']", createMap(new Object[]{1, "a"})},
+                    {"[edges: 'person', T.id: 1]", createMap(new Object[]{"edges", "person", T.id, 1})},
+                    {"[(T.label): 'person', T.id: 1]", createMap(new Object[]{T.label, "person", T.id, 1})},
+                    {"[T.label: 'person', T.id: 1]", createMap(new Object[]{T.label, "person", T.id, 1})},
+                    {"['label': 'person', T.id: 1]", createMap(new Object[]{"label", "person", T.id, 1})},
+                    {"[label: 'person', T.id: 1]", createMap(new Object[]{"label", "person", T.id, 1})},
+                    {"[(label): 'person', (T.id): 1]", createMap(new Object[]{T.label, "person", T.id, 1})},
+                    {"[from: 'source', Direction.to: 'target']", createMap(new Object[]{"from", "source", Direction.to, "target"})},
+                    {"[(from): 'source', (Direction.to): 'target']", createMap(new Object[]{Direction.from, "source", Direction.to, "target"})},
+                    {"[\"name\":\"simba\",\"age\":32]", createMap(new Object[]{"name", "simba", "age", 32})},
+                    {"[\"name\":\"simba\",\"age\":[2,3]]", createMap(new Object[]{"name", "simba", "age", Arrays.asList(2, 3)})},
+                    {"[3L:\"32\",([1I, 2I, 3.1D]):4I,\"x\":4I,\"+x\":8I]", createMap(new Object[]{3L, "32", Arrays.asList(1, 2, 3.1), 4, "x", 4, "+x", 8})},
+                    {"[[label: 'person', T.id: 1]:\"x\"]", createMap(new Object[]{createMap(new Object[]{"label", "person", T.id, 1}), "x"})},
+                    {"[([label: 'person', T.id: 1]):\"x\"]", createMap(new Object[]{createMap(new Object[]{"label", "person", T.id, 1}), "x"})},
+                    {"[new: true]", createMap(new Object[]{"new", true})},
+                    {"[new : true]", createMap(new Object[]{"new", true})},
+                    {"['new' : true]", createMap(new Object[]{"new", true})},
+                    {"[s: {'x'}]", createMap(new Object[]{"s", new HashSet<>(Arrays.asList("x"))})},
+                    {"[l: ['x']]", createMap(new Object[]{"l", Arrays.asList("x")})},
+                    {"[({'x'}): 'x']", createMap(new Object[]{new HashSet<>(Arrays.asList("x")), "x"})},
+                    {"[{'x'}: 'x']", createMap(new Object[]{new HashSet<>(Arrays.asList("x")), "x"})},
+                    {"[['x']: ['x',{'y'}]]", createMap(new Object[]{Arrays.asList("x"), Arrays.asList("x", new HashSet<>(Arrays.asList("y")))})},
+                    {"[['x']: ['x',['y']]]", createMap(new Object[]{Arrays.asList("x"), Arrays.asList("x", Arrays.asList("y"))})},
             });
         }
 
+        private static Map<Object, Object> createMap(final Object[] keyValuePairs) {
+            final Map<Object, Object> map = new HashMap<>();
+            for (int i = 0; i < keyValuePairs.length; i += 2) {
+                map.put(keyValuePairs[i], keyValuePairs[i + 1]);
+            }
+            return map;
+        }
+
         @Test
         public void shouldParse() {
             final GremlinLexer lexer = new GremlinLexer(CharStreams.fromString(script));
@@ -580,9 +593,9 @@ public class GeneralLiteralVisitorTest {
             // verify type is Map
             assertThat(script, genericLiteral, instanceOf(Map.class));
 
-            // verify total number of elements
+            // verify the parsed map matches the expected map
             final Map<Object, Object> genericLiterals = (Map<Object, Object>) genericLiteral;
-            assertEquals(expectedNumKeysInMap, genericLiterals.size());
+            assertEquals(expectedMap, genericLiterals);
         }
     }
 
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParserTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParserTest.java
index 0f181d6793..c12ddd9de4 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParserTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalEnumParserTest.java
@@ -57,7 +57,7 @@ public class TraversalEnumParserTest {
                     {"org.apache.tinkerpop.gremlin.process.traversal.Merge", "traversalMerge"},
                     {"org.apache.tinkerpop.gremlin.process.traversal.SackFunctions$Barrier", "traversalSackMethod"},
                     {"org.apache.tinkerpop.gremlin.process.traversal.Operator", "traversalOperator"},
-                    {"org.apache.tinkerpop.gremlin.structure.T", "traversalToken"},
+                    {"org.apache.tinkerpop.gremlin.structure.T", "traversalT"},
                     {"org.apache.tinkerpop.gremlin.structure.Column", "traversalColumn"},
                     {"org.apache.tinkerpop.gremlin.structure.Direction", "traversalDirection"},
                     {"org.apache.tinkerpop.gremlin.structure.VertexProperty$Cardinality", "traversalCardinality"},
@@ -93,7 +93,7 @@ public class TraversalEnumParserTest {
                     {"org.apache.tinkerpop.gremlin.process.traversal.Scope", "traversalScope"},
                     {"org.apache.tinkerpop.gremlin.process.traversal.Order", "traversalOrder"},
                     {"org.apache.tinkerpop.gremlin.process.traversal.Merge", "traversalMerge"},
-                    {"org.apache.tinkerpop.gremlin.structure.T", "traversalToken"}
+                    {"org.apache.tinkerpop.gremlin.structure.T", "traversalT"}
             });
         }
 
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitorTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitorTest.java
index 54bc2065ad..3f3c574c65 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitorTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/grammar/TraversalPredicateVisitorTest.java
@@ -39,7 +39,7 @@ public class TraversalPredicateVisitorTest {
     @Parameterized.Parameter(value = 1)
     public P expected;
 
-    @Parameterized.Parameters()
+    @Parameterized.Parameters(name = "{0}")
     public static Iterable<Object[]> generateTestParameters() {
         return Arrays.asList(new Object[][]{
                 {"eq(10)", P.eq(10)},
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/translator/GremlinTranslatorTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/translator/GremlinTranslatorTest.java
index 985cd2f356..64a7d95400 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/translator/GremlinTranslatorTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/language/translator/GremlinTranslatorTest.java
@@ -48,7 +48,7 @@ public class GremlinTranslatorTest {
         public static Collection<Object[]> data() {
             return Arrays.asList(new Object[][]{
                     {"g.V(l1)", Collections.singletonList("l1")},
-                    {"g.V().hasLabel('person').has(x, y).as('a').out('knows').as('b').select('a', 'b')", Arrays.asList("x", "y")},
+                    {"g.V().hasLabel('person').has('name', x).as('a').out(y).as('b').select('a', 'b')", Arrays.asList("x", "y")},
                     {"g.V(x).map(out(y).count())", Arrays.asList("x", "y")},
             });
         }
