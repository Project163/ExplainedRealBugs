diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStep.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStep.java
index 50577f448e..0a0620be91 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStep.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStep.java
@@ -18,6 +18,7 @@
  */
 package org.apache.tinkerpop.gremlin.process.traversal.step.map;
 
+import java.io.Serializable;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.Traverser;
 import org.apache.tinkerpop.gremlin.process.traversal.step.Configuring;
@@ -78,24 +79,6 @@ public class IndexStep<S, E> extends ScalarMapStep<S, E> implements TraversalPar
         return super.hashCode() ^ this.indexer.hashCode();
     }
 
-    private static List<List<Object>> indexedList(final Iterator<?> iterator) {
-        final List<List<Object>> list = new ArrayList<>();
-        int i = 0;
-        while (iterator.hasNext()) {
-            list.add(Arrays.asList(iterator.next(), i++));
-        }
-        return Collections.unmodifiableList(list);
-    }
-
-    private static Map<Integer, Object> indexedMap(final Iterator<?> iterator) {
-        final Map<Integer, Object> map = new LinkedHashMap<>();
-        int i = 0;
-        while (iterator.hasNext()) {
-            map.put(i++, iterator.next());
-        }
-        return Collections.unmodifiableMap(map);
-    }
-
     @Override
     public Set<TraverserRequirement> getRequirements() {
         return Collections.singleton(TraverserRequirement.OBJECT);
@@ -112,10 +95,10 @@ public class IndexStep<S, E> extends ScalarMapStep<S, E> implements TraversalPar
             }
             if (indexer == WithOptions.list) {
                 this.indexerType = IndexerType.LIST;
-                this.indexer = IndexStep::indexedList;
+                this.indexer = ListIndexFunction.instance();
             } else if (indexer == WithOptions.map) {
                 this.indexerType = IndexerType.MAP;
-                this.indexer = IndexStep::indexedMap;
+                this.indexer = MapIndexFunction.instance();
             } else {
                 throw INVALID_CONFIGURATION_EXCEPTION;
             }
@@ -145,5 +128,39 @@ public class IndexStep<S, E> extends ScalarMapStep<S, E> implements TraversalPar
             return type;
         }
     }
+    
+    public static final class ListIndexFunction implements Function<Iterator<?>, Object>, Serializable {
+        private static final ListIndexFunction INSTANCE = new ListIndexFunction();
+        private ListIndexFunction() {}
+        public List<List<Object>> apply(final Iterator<?> iterator) {
+            final List<List<Object>> list = new ArrayList<>();
+            int i = 0;
+            while (iterator.hasNext()) {
+                list.add(Arrays.asList(iterator.next(), i++));
+            }
+            return Collections.unmodifiableList(list);
+        }
+
+        public static ListIndexFunction instance() {
+            return INSTANCE;
+        }
+    }
+
+    public static final class MapIndexFunction implements Function<Iterator<?>, Object>, Serializable {
+        private static final MapIndexFunction INSTANCE = new MapIndexFunction();
+        private MapIndexFunction() {}
+        public Map<Integer, Object> apply(final Iterator<?> iterator) {
+            final Map<Integer, Object> map = new LinkedHashMap<>();
+            int i = 0;
+            while (iterator.hasNext()) {
+                map.put(i++, iterator.next());
+            }
+            return Collections.unmodifiableMap(map);
+        }
+
+        public static MapIndexFunction instance() {
+            return INSTANCE;
+        }
+    }
 }
 
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStepTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStepTest.java
index a3b407174f..cd2ca9ca9b 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStepTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/step/map/IndexStepTest.java
@@ -18,16 +18,18 @@
  */
 package org.apache.tinkerpop.gremlin.process.traversal.step.map;
 
+import java.util.Arrays;
+import java.util.List;
+import org.apache.commons.lang3.SerializationUtils;
 import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
 import org.apache.tinkerpop.gremlin.process.traversal.step.StepTest;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.WithOptions;
+import org.apache.tinkerpop.gremlin.process.traversal.util.DefaultTraversal;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.List;
-
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Daniel Kuppitz (http://gremlin.guru)
@@ -46,4 +48,30 @@ public class IndexStepTest extends StepTest {
     public void testDefault() {
         assertEquals(__.index(), __.index().with(WithOptions.indexer, WithOptions.list));
     }
+
+    @Test
+    public void testListIndexerSerializationDeserializationRoundTrip() {
+        // serialization and deserialization should not throw exception
+        byte[] serialized = SerializationUtils.serialize(__.index().with(WithOptions.indexer, WithOptions.list));
+        Object deserialized = SerializationUtils.deserialize(serialized);
+
+        DefaultTraversal<Object, Object> gtr = (DefaultTraversal<Object, Object>) deserialized;
+        assertEquals(1, gtr.getSteps().size());
+        IndexStep<Object, Object> step = (IndexStep<Object, Object>) gtr.getSteps().get(0);
+        assertEquals(IndexStep.IndexerType.LIST, step.getIndexerType());
+        assertTrue(step.getIndexer() instanceof IndexStep.ListIndexFunction);
+    }
+
+    @Test
+    public void testMapIndexerSerializationDeserializationRoundTrip() {
+        // serialization and deserialization should not throw exception
+        byte[] serialized = SerializationUtils.serialize(__.index().with(WithOptions.indexer, WithOptions.map));
+        Object deserialized = SerializationUtils.deserialize(serialized);
+
+        DefaultTraversal<Object, Object> gtr = (DefaultTraversal<Object, Object>) deserialized;
+        assertEquals(1, gtr.getSteps().size());
+        IndexStep<Object, Object> step = (IndexStep<Object, Object>) gtr.getSteps().get(0);
+        assertEquals(IndexStep.IndexerType.MAP, step.getIndexerType());
+        assertTrue(step.getIndexer() instanceof IndexStep.MapIndexFunction);
+    }
 }
