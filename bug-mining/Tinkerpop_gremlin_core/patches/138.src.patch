diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/FilterRankingStrategy.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/FilterRankingStrategy.java
index 65723a2894..9ebfeb7ed8 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/FilterRankingStrategy.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/strategy/optimization/FilterRankingStrategy.java
@@ -38,17 +38,15 @@ import org.apache.tinkerpop.gremlin.process.traversal.step.filter.WhereTraversal
 import org.apache.tinkerpop.gremlin.process.traversal.step.map.OrderGlobalStep;
 import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;
 import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
-import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.javatuples.Pair;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Collectors;
 
 /**
@@ -83,20 +81,37 @@ public final class FilterRankingStrategy extends AbstractTraversalStrategy<Trave
             // traversals. This little cache keeps the effective data of that function which is if there is a
             // lambda in the children and the set of scope keys. note that the lambda sorta trumps the labels in
             // that if there is a lambda there's no real point to doing any sort of eval of the labels.
+            //
+            // this cache holds the parent and a pair. the first item in the pair is a boolean which is true if
+            // lambda is present and false otherwise. the second item in the pair is a set of labels from any
+            // Scoping steps
             final Map<TraversalParent, Pair<Boolean, Set<String>>> traversalParentCache = new HashMap<>();
             final Map<Step, Integer> stepRanking = new HashMap<>();
 
-            // build up the little cache
+            // gather the parents and their Scoping/LambdaHolder steps to build up the cache. since the traversal is
+            // processed in depth first manner, the entries gathered to m are deepest child first and held in order,
+            // so that the cache can be constructed with parent's knowing their children were processed first
             final Map<TraversalParent, List<Step<?,?>>> m =
-                    TraversalHelper.getStepsOfAssignableClassRecursively(traversal, Scoping.class, LambdaHolder.class).stream().
-                    collect(Collectors.groupingBy(step -> ((Step) step).getTraversal().getParent()));
+                    TraversalHelper.getStepsOfAssignableClassRecursivelyFromDepth(traversal, TraversalParent.class).stream().
+                    collect(Collectors.groupingBy(step -> ((Step) step).getTraversal().getParent(), LinkedHashMap::new, Collectors.toList()));
+
+            // build the cache and use it to detect if any children impact the Pair in any way. in the case of a
+            // child with a lambda, the parent would simply inherit that true. in the case of additional labels they
+            // would just be appended to the list for the parent.
             m.forEach((k, v) -> {
-                final boolean hasLambda = v.stream().anyMatch(s -> s instanceof LambdaHolder);
+                final boolean hasLambda = v.stream().anyMatch(s -> s instanceof LambdaHolder ||
+                        (traversalParentCache.containsKey(s) && traversalParentCache.get(s).getValue0()));
                 if (hasLambda) {
                     traversalParentCache.put(k, Pair.with(true, Collections.emptySet()));
                 } else {
-                    traversalParentCache.put(k, Pair.with(false, v.stream().filter(s -> s instanceof Scoping).
-                            flatMap(s -> ((Scoping) s).getScopeKeys().stream()).collect(Collectors.toSet())));
+                    final Set<String> currentEntryScopeLabels = v.stream().filter(s -> s instanceof Scoping).
+                            flatMap(s -> ((Scoping) s).getScopeKeys().stream()).collect(Collectors.toSet());
+                    final Set<String> allScopeLabels = new HashSet<>(currentEntryScopeLabels);
+                    v.stream().filter(traversalParentCache::containsKey).forEach(s -> {
+                        final TraversalParent parent = (TraversalParent) s;
+                        allScopeLabels.addAll(traversalParentCache.get(parent).getValue1());
+                    });
+                    traversalParentCache.put(k, Pair.with(false, allScopeLabels));
                 }
             });
 
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DepthComparator.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DepthComparator.java
new file mode 100644
index 0000000000..13eb36dfbb
--- /dev/null
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/DepthComparator.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.process.traversal.util;
+
+import org.apache.tinkerpop.gremlin.process.traversal.Step;
+import org.apache.tinkerpop.gremlin.process.traversal.step.util.EmptyStep;
+
+import java.util.Comparator;
+
+/**
+ * A {@code Comparator} that compares steps on the depth of the traversal that they are in.
+ */
+public final class DepthComparator implements Comparator<Step<?,?>> {
+
+    private static final DepthComparator instance = new DepthComparator();
+
+    private DepthComparator() {}
+
+    public static DepthComparator instance() {
+        return instance;
+    }
+
+    @Override
+    public int compare(final Step<?, ?> step1, final Step<?, ?> step2) {
+        return getDepth(step2) - getDepth(step1);
+    }
+
+    private int getDepth(final Step<?,?> step) {
+        return step == null || step instanceof EmptyStep ? 0 : getDepth((Step) step.getTraversal().getParent()) + 1;
+    }
+}
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java
index 9625a56174..19117d6e9a 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelper.java
@@ -54,14 +54,17 @@ import org.apache.tinkerpop.gremlin.util.iterator.IteratorUtils;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.Stack;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
 
 /**
  * @author Marko A. Rodriguez (http://markorodriguez.com)
@@ -313,6 +316,38 @@ public final class TraversalHelper {
         return list;
     }
 
+    /**
+     * Get steps of the specified classes throughout the traversal, collecting them in a fashion that orders them
+     * from the deepest steps first.
+     */
+    public static List<Step<?,?>> getStepsOfAssignableClassRecursivelyFromDepth(final Traversal.Admin<?, ?> traversal, final Class<?>... stepClasses) {
+        final List<Step<?,?>> list = new ArrayList<>();
+        final Stack<Step<?,?>> stack = new Stack<>();
+
+        traversal.getSteps().forEach(stack::push);
+
+        while (!stack.isEmpty()) {
+            final Step<?,?> current = stack.pop();
+            list.add(current);
+
+            if (current instanceof TraversalParent) {
+                ((TraversalParent) current).getLocalChildren().forEach(localChild -> localChild.getSteps().forEach(stack::push));
+                ((TraversalParent) current).getGlobalChildren().forEach(globalChild -> globalChild.getSteps().forEach(stack::push));
+            }
+        }
+
+        // sort by depth
+        list.sort(DepthComparator.instance());
+
+        return list.stream().filter(s -> {
+            for (Class<?> stepClass : stepClasses) {
+                if (stepClass.isAssignableFrom(s.getClass()))
+                    return true;
+            }
+            return false;
+        }).collect(Collectors.toList());
+    }
+
     public static boolean isGlobalChild(Traversal.Admin<?, ?> traversal) {
         while (!(traversal.isRoot())) {
             if (traversal.getParent().getLocalChildren().contains(traversal))
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelperTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelperTest.java
index 5e277ad3cf..c7884451ac 100644
--- a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelperTest.java
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/traversal/util/TraversalHelperTest.java
@@ -41,8 +41,6 @@ import org.apache.tinkerpop.gremlin.process.traversal.step.map.TraversalMapStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.IdentityStep;
 import org.apache.tinkerpop.gremlin.process.traversal.step.util.EmptyStep;
-import org.apache.tinkerpop.gremlin.process.traversal.util.DefaultTraversal;
-import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;
 import org.apache.tinkerpop.gremlin.structure.PropertyType;
 import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.structure.util.empty.EmptyGraph;
@@ -446,4 +444,45 @@ public class TraversalHelperTest {
         assertEquals(3, steps.stream().filter(s -> s instanceof VertexStep).count());
         assertEquals(1, steps.stream().filter(s -> s instanceof FoldStep).count());
     }
+
+    @Test
+    public void shouldGetStepsOfAssignableClassRecursivelyFromDepthNoTypes() {
+        final Traversal.Admin<?,?> traversal = __.V().repeat(__.out()).project("x").by(out().in().fold()).asAdmin();
+        final List<Step<?,?>> steps = TraversalHelper.getStepsOfAssignableClassRecursivelyFromDepth(traversal);
+        assertEquals(0, steps.size());
+    }
+
+    @Test
+    public void shouldGetStepsOfAssignableClassRecursivelyFromDepthOneType() {
+        final Traversal.Admin<?,?> traversal = __.V().repeat(__.out()).project("x").by(out().in().fold()).asAdmin();
+        final List<Step<?,?>> steps = TraversalHelper.getStepsOfAssignableClassRecursivelyFromDepth(traversal, VertexStep.class);
+        assertEquals(3, steps.size());
+        assertThat(steps.stream().allMatch(s -> s instanceof VertexStep), is(true));
+    }
+
+    @Test
+    public void shouldGetStepsOfAssignableClassRecursivelyFromDepthMultipleTypes() {
+        final Traversal.Admin<?,?> traversal = __.V().repeat(__.out()).project("x").by(out().in().fold()).asAdmin();
+        final List<Step<?,?>> steps = TraversalHelper.getStepsOfAssignableClassRecursivelyFromDepth(traversal, VertexStep.class, FoldStep.class);
+        assertEquals(4, steps.size());
+        assertEquals(3, steps.stream().filter(s -> s instanceof VertexStep).count());
+        assertEquals(1, steps.stream().filter(s -> s instanceof FoldStep).count());
+    }
+
+    @Test
+    public void shouldGetStepsOfAssignableClassRecursivelyFromDepthEnsureOrder() {
+        final Traversal.Admin<?,?> traversal = __.V().union(
+                __.union(__.values("a"),
+                         __.union(__.values("b"), __.union(__.values("c"))),
+                         __.values("d")),
+                __.values("e")).values("f").asAdmin();
+        final List<Step<?,?>> steps = TraversalHelper.getStepsOfAssignableClassRecursivelyFromDepth(traversal, PropertiesStep.class);
+        assertEquals(6, steps.size());
+        assertEquals("c", ((PropertiesStep) steps.get(0)).getPropertyKeys()[0]);
+        assertEquals("b", ((PropertiesStep) steps.get(1)).getPropertyKeys()[0]);
+        assertEquals("d", ((PropertiesStep) steps.get(2)).getPropertyKeys()[0]);
+        assertEquals("a", ((PropertiesStep) steps.get(3)).getPropertyKeys()[0]);
+        assertEquals("e", ((PropertiesStep) steps.get(4)).getPropertyKeys()[0]);
+        assertEquals("f", ((PropertiesStep) steps.get(5)).getPropertyKeys()[0]);
+    }
 }
