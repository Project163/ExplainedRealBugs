<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:51:32 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-4882] Bottleneck in the asynchronous persistent cache</title>
                <link>https://issues.apache.org/jira/browse/OAK-4882</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;The class responsible for accepting new cache operations which will be handled asynchronously is &lt;a href=&quot;https://github.com/apache/jackrabbit-oak/blob/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/persistentCache/async/CacheActionDispatcher.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;CacheActionDispatcher&lt;/a&gt;. In case of a high load, when the queue is full (=1024 entries), the &lt;a href=&quot;https://github.com/apache/jackrabbit-oak/blob/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/persistentCache/async/CacheActionDispatcher.java#L86&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;add()&lt;/a&gt; method removes the oldest 256 entries. However, we can&apos;t afford losing the updates (as it may result in having stale entries in the cache), so all the removed entries are compacted into one big invalidate action.&lt;/p&gt;

&lt;p&gt;The compaction action (&lt;a href=&quot;https://github.com/apache/jackrabbit-oak/blob/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/persistentCache/async/CacheActionDispatcher.java#L97&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;CacheActionDispatcher#cleanTheQueue&lt;/a&gt;) still holds the lock taken in add() method, so threads which tries to add something to the queue have to wait until cleanTheQueue() ends.&lt;/p&gt;

&lt;p&gt;Maybe we can optimise the CacheActionDispatcher#add-&amp;gt;cleanTheQueue part, so it won&apos;t hold the lock for the whole time.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13009470">OAK-4882</key>
            <summary>Bottleneck in the asynchronous persistent cache</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="tomek.rekawek">Tomek R&#281;kawek</assignee>
                                    <reporter username="tomek.rekawek">Tomek R&#281;kawek</reporter>
                        <labels>
                    </labels>
                <created>Tue, 4 Oct 2016 08:26:00 +0000</created>
                <updated>Tue, 16 Feb 2021 09:55:53 +0000</updated>
                            <resolved>Wed, 2 Nov 2016 12:43:14 +0000</resolved>
                                    <version>1.4.8</version>
                    <version>1.5.10</version>
                                    <fixVersion>1.4.10</fixVersion>
                    <fixVersion>1.5.13</fixVersion>
                    <fixVersion>1.6.0</fixVersion>
                                    <component>cache</component>
                    <component>documentmk</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>8</watches>
                                                                                                                                                            <comments>
                            <comment id="15544723" author="tomek.rekawek" created="Tue, 4 Oct 2016 08:27:05 +0000"  >&lt;p&gt;//cc: &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chetanm&quot; class=&quot;user-hover&quot; rel=&quot;chetanm&quot;&gt;chetanm&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15544731" author="tomek.rekawek" created="Tue, 4 Oct 2016 08:31:28 +0000"  >&lt;p&gt;Thread dump, redacted by Chetan:&lt;/p&gt;

&lt;p&gt;A read blocks on cache load (multiple thread reading same value)&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&quot;X.X.X.X [1471910520681] GET /... HTTP/1.1&quot; prio=10 tid=0x00007f9c9d296000 nid=0x6b80 waiting for monitor entry [0x00007f9d79058000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.apache.jackrabbit.oak.cache.CacheLIRS$Segment.access(CacheLIRS.java:884)
	- waiting to lock &amp;lt;0x00000004030760a8&amp;gt; (a org.apache.jackrabbit.oak.cache.CacheLIRS$Segment)
	at org.apache.jackrabbit.oak.cache.CacheLIRS$Segment.get(CacheLIRS.java:867)
	at org.apache.jackrabbit.oak.cache.CacheLIRS.getIfPresent(CacheLIRS.java:362)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.NodeCache.getIfPresent(NodeCache.java:127)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.NodeCache.get(NodeCache.java:142)
	at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.getNode(DocumentNodeStore.java:824)
	at org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.getChildNode(DocumentNodeState.java:253)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then the thread which is loading is blocked on eviction&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&quot;X.X.X.X [1471910536795] GET /... HTTP/1.1&quot; prio=10 tid=0x00007f9c9fafe800 nid=0x4437 waiting for monitor entry [0x00007f9dcddbf000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheActionDispatcher.add(CacheActionDispatcher.java:87)
	- waiting to lock &amp;lt;0x000000040293ada0&amp;gt; (a org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheActionDispatcher)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheWriteQueue.addPut(CacheWriteQueue.java:78)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.NodeCache.evicted(NodeCache.java:221)
	at org.apache.jackrabbit.oak.plugins.document.DocumentMK$Builder$1.evicted(DocumentMK.java:986)
	at org.apache.jackrabbit.oak.plugins.document.DocumentMK$Builder$1.evicted(DocumentMK.java:982)
	at org.apache.jackrabbit.oak.cache.CacheLIRS.evicted(CacheLIRS.java:217)
	at org.apache.jackrabbit.oak.cache.CacheLIRS$Segment.evict(CacheLIRS.java:1214)
	at org.apache.jackrabbit.oak.cache.CacheLIRS$Segment.put(CacheLIRS.java:1131)
	- locked &amp;lt;0x00000004030760a8&amp;gt; (a org.apache.jackrabbit.oak.cache.CacheLIRS$Segment)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here CacheActionDispatcher.add is synchronized and has 6 threads waiting. Now the thread which has the lock is busy with eviction&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;&quot;X.X.X.X [1471909807710] POST /... HTTP/1.1&quot; prio=10 tid=0x00007f9c8d65b800 nid=0x5937 runnable [0x00007f9c43645000]
   java.lang.Thread.State: RUNNABLE
	at java.util.HashMap.createEntry(HashMap.java:869)
	at java.util.HashMap.addEntry(HashMap.java:856)
	at java.util.HashMap.put(HashMap.java:484)
	at java.util.HashSet.add(HashSet.java:217)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheWriteQueue.addInvalidate(CacheWriteQueue.java:61)
	- locked &amp;lt;0x0000000402e522c0&amp;gt; (a org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheWriteQueue)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheActionDispatcher.cleanTheQueue(CacheActionDispatcher.java:103)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheActionDispatcher.add(CacheActionDispatcher.java:88)
	- locked &amp;lt;0x000000040293ada0&amp;gt; (a org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheActionDispatcher)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.async.CacheWriteQueue.addPut(CacheWriteQueue.java:78)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.NodeCache.evicted(NodeCache.java:221)
	at org.apache.jackrabbit.oak.plugins.document.DocumentMK$Builder$1.evicted(DocumentMK.java:986)
	at org.apache.jackrabbit.oak.plugins.document.DocumentMK$Builder$1.evicted(DocumentMK.java:982)
	at org.apache.jackrabbit.oak.cache.CacheLIRS.evicted(CacheLIRS.java:217)
	at org.apache.jackrabbit.oak.cache.CacheLIRS$Segment.evict(CacheLIRS.java:1214)
	at org.apache.jackrabbit.oak.cache.CacheLIRS$Segment.put(CacheLIRS.java:1131)
	- locked &amp;lt;0x0000000402e55ad8&amp;gt; (a org.apache.jackrabbit.oak.cache.CacheLIRS$Segment)
	at org.apache.jackrabbit.oak.cache.CacheLIRS.put(CacheLIRS.java:258)
	at org.apache.jackrabbit.oak.cache.CacheLIRS.put(CacheLIRS.java:269)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.NodeCache.getIfPresent(NodeCache.java:133)
	at org.apache.jackrabbit.oak.plugins.document.persistentCache.NodeCache.get(NodeCache.java:142)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15594791" author="tomek.rekawek" created="Fri, 21 Oct 2016 10:57:37 +0000"  >&lt;p&gt;The first possible improvement is to remove the &lt;tt&gt;synchronized&lt;/tt&gt; keyword from the &lt;tt&gt;CacheActionDispatcher&lt;/tt&gt;:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/persistentCache/async/CacheActionDispatcher.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/persistentCache/async/CacheActionDispatcher.java
@@ -83,7 +83,7 @@ public class CacheActionDispatcher implements Runnable {
      *
      * @param action to be added
      */
-    synchronized void add(CacheAction&amp;lt;?, ?&amp;gt; action) {
+    void add(CacheAction&amp;lt;?, ?&amp;gt; action) {
         if (queue.size() &amp;gt;= MAX_SIZE) {
             cleanTheQueue();
         }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;tt&gt;queue&lt;/tt&gt; is synchronized anyway and the cleanTheQueue() operation doesn&apos;t have to be executed atomically.&lt;/p&gt;</comment>
                            <comment id="15594800" author="chetanm" created="Fri, 21 Oct 2016 11:01:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tomek.rekawek&quot; class=&quot;user-hover&quot; rel=&quot;tomek.rekawek&quot;&gt;tomek.rekawek&lt;/a&gt; It would also be helpful to have a oak-run level benchmark which can reproduce such contention. This would then help validate any enhancement done to improve it in a deterministic way&lt;/p&gt;</comment>
                            <comment id="15594824" author="tomek.rekawek" created="Fri, 21 Oct 2016 11:16:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chetanm&quot; class=&quot;user-hover&quot; rel=&quot;chetanm&quot;&gt;chetanm&lt;/a&gt;, absolutely, we need more systematic way to reproduce and test it. I&apos;ll take care of preparing appropriate test case.&lt;/p&gt;</comment>
                            <comment id="15604732" author="tomek.rekawek" created="Tue, 25 Oct 2016 09:10:32 +0000"  >&lt;p&gt;I&apos;m still working on reproducing the original issue in a controlled way.&lt;/p&gt;

&lt;p&gt;In the meantime, I was thinking about the complexity of the asynchronous queue part of the persistent cache (the &lt;tt&gt;org.apache.jackrabbit.oak.plugins.document.persistentCache.async&lt;/tt&gt; package). Most of it is caused by the fact, that the queue guarantees that each &lt;tt&gt;put()&lt;/tt&gt; operation will be either (1) executed or (2) replaced with &lt;tt&gt;invalidate()&lt;/tt&gt; if the queue becomes full.&lt;/p&gt;

&lt;p&gt;The requirement (2) was introduced to avoid stale cache entries. However, right now the cache values are immutable anyway (as their key is path+revision). I think we should use this property to simplify the asynchronous queue (and therefore improve the performance).&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761&quot; title=&quot;Persistent cache: add data in a different thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2761&quot;&gt;&lt;del&gt;OAK-2761&lt;/del&gt;&lt;/a&gt; Marcel &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761?focusedCommentId=15130422&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15130422&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;mentioned&lt;/a&gt; that the PersistenceCache is a general mechanism and that the immutability property may not be hold for the future uses. However, I think we should first improve the existing implementation (especially that we already know about a few Oak customers dealing with the described bottleneck) and worry about the mutable cases if/when they appear. It seems that the current solution won&apos;t work for these cases anyway.&lt;/p&gt;

&lt;p&gt;I&apos;ll try to make it clear in the code that the asynchronous queue only works for PersistentCache cases storing immutable values, so it won&apos;t hit us in the future.&lt;/p&gt;

&lt;p&gt;WDYT?&lt;/p&gt;

&lt;p&gt;//cc: &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chetanm&quot; class=&quot;user-hover&quot; rel=&quot;chetanm&quot;&gt;chetanm&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mreutegg&quot; class=&quot;user-hover&quot; rel=&quot;mreutegg&quot;&gt;mreutegg&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15604808" author="tmueller" created="Tue, 25 Oct 2016 09:44:25 +0000"  >&lt;p&gt;Yes, I think in theory we don&apos;t need to support updating entries (or better: don&apos;t need to &lt;em&gt;guarantee&lt;/em&gt; that updating entries always works).&lt;/p&gt;

&lt;p&gt;It might seem a bit more complex right now, but the complexity is not strictly needed. Right now, the invalidate methods are called from DocumentNodeStore.invalidateNodeCache for example, but just from within tests. And entries are updated, that&apos;s true (DocumentNodeStore.getChildren, &quot;not enough children loaded - load more, and put that in the cache&quot;). So if the updated entry is stored, then that&apos;s better, but if it&apos;s not &lt;em&gt;always&lt;/em&gt; stored, then that&apos;s not a problem. The alternative is to use different keys, but that also has drawbacks.&lt;/p&gt;

&lt;p&gt;&amp;gt; PersistenceCache is a general mechanism&lt;/p&gt;

&lt;p&gt;Yes, but I think we can limit what features we support, and what guarantees we have. It&apos;s more important that the &quot;async&quot; part is always async, than to guarantee that updates to existing entries always go through.&lt;/p&gt;</comment>
                            <comment id="15604861" author="mmarth" created="Tue, 25 Oct 2016 10:07:24 +0000"  >&lt;p&gt;fwiw: IMHO the persistent cache should be fully tuned to take advantage of the immutability of revisions (i.e. remove update operations)&lt;/p&gt;</comment>
                            <comment id="15605044" author="tomek.rekawek" created="Tue, 25 Oct 2016 11:43:32 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mmarth&quot; class=&quot;user-hover&quot; rel=&quot;mmarth&quot;&gt;mmarth&lt;/a&gt;, great, thanks for the feedback.&lt;/p&gt;

&lt;p&gt;So, I was thinking about naive approach in which we just drop the new put/invalidate actions if the queue if already full. It&apos;s a bit aggressive, but will certainly fix all the bottlenecks (as we won&apos;t wait for anything). Also, seems like a good starting point for the future improvements. From what &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt; wrote it seems it should behave correctly.&lt;/p&gt;</comment>
                            <comment id="15605142" author="mmarth" created="Tue, 25 Oct 2016 12:12:33 +0000"  >&lt;p&gt;I am not sure if dropping update/invalidate operations occasionally is a good idea (it makes it hard to understand the caching behaviour). IMO it would be clearer to make it explicit that the persistent cache is meant for immutable entries only - and actually get the benefits from that constraint, i.e. no worries about updates etc. If there are other use cases that do require mutable entries then those could maybe be treated in a separate pers-cache instance that explicitly allows mutable entries.&lt;/p&gt;</comment>
                            <comment id="15605371" author="tomek.rekawek" created="Tue, 25 Oct 2016 13:52:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mmarth&quot; class=&quot;user-hover&quot; rel=&quot;mmarth&quot;&gt;mmarth&lt;/a&gt;, the problem here is as follows:&lt;/p&gt;

&lt;p&gt;a) in case of a high load, there is a lot of persistent cache updates,&lt;br/&gt;
b) the H2 MVStore used for the persistence, sometimes need to maintain its files,&lt;br/&gt;
c) the maintenance takes place in the thread invoking &lt;tt&gt;put()&lt;/tt&gt; method. The maintenance process blocks all the other threads from putting anything into the cache (so they have to wait until maintenance is done) and basically makes the impression that the whole instance hangs.&lt;/p&gt;

&lt;p&gt;That&apos;s why the &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761&quot; title=&quot;Persistent cache: add data in a different thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2761&quot;&gt;&lt;del&gt;OAK-2761&lt;/del&gt;&lt;/a&gt; introduced mechanism to &lt;tt&gt;put()&lt;/tt&gt; entries to the MVStore asynchronously, using some queue. The question is what to do if the queue is full. Should we:&lt;/p&gt;

&lt;p&gt;1) block the caller - however, this will lead to (c) case again, as after some time of high load the queue will be full again,&lt;br/&gt;
2) remove the oldest or drop the most recent &lt;tt&gt;put()&lt;/tt&gt; entries - this option has disadvantage described in your post&lt;br/&gt;
3) ?&lt;/p&gt;</comment>
                            <comment id="15605385" author="chetanm" created="Tue, 25 Oct 2016 14:00:53 +0000"  >&lt;blockquote&gt;&lt;p&gt;remove the oldest or drop the most recent put() entries - this option has disadvantage described in your post&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We can improve a bit here by applying some heuristics&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;maintain some kind of access stats on cached DocumentNodeState and only write back those nodes back to persistent cache which have hit count &amp;gt; n (n say = 1) This would reduce the load on write back&lt;/li&gt;
	&lt;li&gt;Keep a flag that entry in inmemory cache is one from persistent - In such a case avoid writing it back again&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Such heuristics need to be checked in real world setups to see how effective they are&lt;/p&gt;</comment>
                            <comment id="15605437" author="mmarth" created="Tue, 25 Oct 2016 14:18:55 +0000"  >&lt;p&gt;I see - thanks for explaining. In that case dropping put() seems reasonable (your option 2). But the way you describe it, it seems that the file maintenance is actually the problem (or rather the fact that maintenance blocks put operations). I thought that the pers-cache is a) append-only and b) uses rotating files. If so, it seems possible to keep adding entries even while files get rotated or old files removed...&lt;/p&gt;</comment>
                            <comment id="15608112" author="tomek.rekawek" created="Wed, 26 Oct 2016 10:42:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mmarth&quot; class=&quot;user-hover&quot; rel=&quot;mmarth&quot;&gt;mmarth&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;But the way you describe it, it seems that the file maintenance is actually the problem (or rather the fact that maintenance blocks put operations). I thought that the pers-cache is a) append-only and b) uses rotating files. If so, it seems possible to keep adding entries even while files get rotated or old files removed...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is my understanding of the initial cause of the &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761&quot; title=&quot;Persistent cache: add data in a different thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2761&quot;&gt;&lt;del&gt;OAK-2761&lt;/del&gt;&lt;/a&gt;. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt;, could you elaborate on the cause of hangs described in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761&quot; title=&quot;Persistent cache: add data in a different thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2761&quot;&gt;&lt;del&gt;OAK-2761&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;The whole async queue idea was introduced to fix this very issue, so if it can be fixed on the persistence layer level, it&apos;d be even better. In the meantime, I&apos;ll carry on with the async queue work. It&apos;s optional (the async queue is disabled by default and can be enabled via system property), so we can try to tackle the issue from two sides.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chetanm&quot; class=&quot;user-hover&quot; rel=&quot;chetanm&quot;&gt;chetanm&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We can improve a bit here by applying some heuristics&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks for the ideas. I submitted a draft patch. The heuristics have been put into &lt;tt&gt;NodeCache#qualifiesToPersist()&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="15614762" author="tomek.rekawek" created="Fri, 28 Oct 2016 08:35:16 +0000"  >&lt;p&gt;I committed the async queue simplified as in the discussion above. The commit also includes heuristics suggest by Chetan.&lt;/p&gt;

&lt;p&gt;Trunk: &lt;a href=&quot;https://svn.apache.org/r1766966&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1766966&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1766992&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1766992&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1767661&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1767661&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1767991&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1767991&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1768084&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1768084&lt;/a&gt;.&lt;br/&gt;
1.4: &lt;a href=&quot;https://svn.apche.org/r1766970&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1766970&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1766993&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1766993&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1767662&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1767662&lt;/a&gt;, &lt;a href=&quot;https://svn.apache.org/r1767992&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;r1767992&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15614788" author="chetanm" created="Fri, 28 Oct 2016 08:43:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tomek.rekawek&quot; class=&quot;user-hover&quot; rel=&quot;tomek.rekawek&quot;&gt;tomek.rekawek&lt;/a&gt; It would be helpful to invest in some benchmark which can reproduce the issue and validate any approach against that. Otherwise we may hit issue somewhere else. &lt;/p&gt;

&lt;p&gt;Also I would feel more comfortable if this change gets some more test runs before we merge it to branch. &lt;/p&gt;</comment>
                            <comment id="15621825" author="tomek.rekawek" created="Mon, 31 Oct 2016 10:30:31 +0000"  >&lt;p&gt;Implemented a simple benchmark in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-5035&quot; title=&quot;Implement mini-benchmark for PersistentCache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-5035&quot;&gt;&lt;del&gt;OAK-5035&lt;/del&gt;&lt;/a&gt;. The way to reproduce &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761&quot; title=&quot;Persistent cache: add data in a different thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2761&quot;&gt;&lt;del&gt;original issue&lt;/del&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;$ java -DcacheOptions=&quot;size=100,+compact,-async&quot; -jar target/oak-run-1.6-SNAPSHOT.jar benchmark --concurrency=8 PersistentCacheTest Oak-Mongo
Apache Jackrabbit Oak 1.6-SNAPSHOT
# PersistentCacheTest              C     min     10%     50%     90%     max       N
Oak-Mongo                          8     122     215     278     353    3403    1520
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The max = 3403 indicates that at some point during the test the threads are locked on the compaction process during generation switch (it can be confirmed with a debugger). On the other hand, after enabling +async mode the results are as follows:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;java -DcacheOptions=&quot;size=100,+compact,+async&quot; -jar target/oak-run-1.6-SNAPSHOT.jar benchmark --concurrency=8 PersistentCacheTest Oak-Mongo
Apache Jackrabbit Oak 1.6-SNAPSHOT
# PersistentCacheTest              C     min     10%     50%     90%     max       N
Oak-Mongo                          8      55      73      91     124     356    4998
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, it seems that there&apos;s no more hangup there.&lt;/p&gt;

&lt;p&gt;I&apos;ll also try to measure how many put() entries are discarded (by the heuristics and the full queue).&lt;/p&gt;</comment>
                            <comment id="15629029" author="tomek.rekawek" created="Wed, 2 Nov 2016 13:49:55 +0000"  >&lt;p&gt;Using stats from &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-5038&quot; title=&quot;Extend PersistentCacheStats with async queue-related stats&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-5038&quot;&gt;&lt;del&gt;OAK-5038&lt;/del&gt;&lt;/a&gt; it is possible to measure how many entries are rejected because of the full queue. It seems that the don&apos;t-write-persisted-entries-again condition helps a great deal here. After enabling it, the queue performance is enough to process all the entries (nothing is rejected at all). As a test I started Sling-based CMS on Mongo - it creates a lot of content during its initialisation.&lt;/p&gt;</comment>
                            <comment id="15631894" author="chetanm" created="Thu, 3 Nov 2016 07:14:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tomek.rekawek&quot; class=&quot;user-hover&quot; rel=&quot;tomek.rekawek&quot;&gt;tomek.rekawek&lt;/a&gt; New numbers look good. Should we now enable this feature by default?&lt;/p&gt;

&lt;p&gt;/cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15632034" author="tomek.rekawek" created="Thu, 3 Nov 2016 08:23:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chetanm&quot; class=&quot;user-hover&quot; rel=&quot;chetanm&quot;&gt;chetanm&lt;/a&gt;, I think we can try it, at least for trunk. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt; opinion on the recent changes would be priceless &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15637471" author="tomek.rekawek" created="Fri, 4 Nov 2016 19:49:13 +0000"  >&lt;p&gt;Enabled the async mode by default in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-5071&quot; title=&quot;Persistent cache: use the asynchronous mode by default&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-5071&quot;&gt;&lt;del&gt;OAK-5071&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15663659" author="edivad" created="Mon, 14 Nov 2016 11:35:34 +0000"  >&lt;p&gt;Bulk close for 1.5.13&lt;/p&gt;</comment>
                            <comment id="15686912" author="catholicon" created="Tue, 22 Nov 2016 14:42:31 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tomek.rekawek&quot; class=&quot;user-hover&quot; rel=&quot;tomek.rekawek&quot;&gt;tomek.rekawek&lt;/a&gt;, since &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2761&quot; title=&quot;Persistent cache: add data in a different thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2761&quot;&gt;&lt;del&gt;OAK-2761&lt;/del&gt;&lt;/a&gt; was back ported to 1.2 as well. Does it make sense to backport this one too ? (sorry I haven&apos;t checked code .. may be it&apos;s not applicable at all in 1.2 branch)&lt;/p&gt;</comment>
                            <comment id="15686989" author="tomek.rekawek" created="Tue, 22 Nov 2016 15:13:38 +0000"  >&lt;p&gt;It makes perfect sense. I&apos;ll take care of this tomorrow.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310060">
                    <name>Container</name>
                                                                <inwardlinks description="Is contained by">
                                        <issuelink>
            <issuekey id="13022817">OAK-5147</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12785845">OAK-2686</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12820732">OAK-2761</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13018236">OAK-5071</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13022446">OAK-5138</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13022471">OAK-5142</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12835302" name="OAK-4882.patch" size="34024" author="tomek.rekawek" created="Wed, 26 Oct 2016 10:35:45 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="13016558">OAK-5035</subtask>
                            <subtask id="13016609">OAK-5038</subtask>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 51 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i34ejj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>