<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:36:24 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-534] Inefficient NodeState comparison with MongoMK</title>
                <link>https://issues.apache.org/jira/browse/OAK-534</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;Oak on MongoMK currently results in complete tree traversal for any kind of modification. This is caused by the fact that MongoMK does not support the optional :hash system property. In this case KernelNodeState.compareAgainstBaseState() falls back to a generic implementation, which traverses the complete tree to find out if a subtree was modified.&lt;/p&gt;

&lt;p&gt;The NodeState comparison is triggered in almost all commit hook and validator implementations to find out what changed with the given commit.&lt;/p&gt;

&lt;p&gt;I see a number of options to solve this:&lt;/p&gt;

&lt;p&gt;1) Add support for :hash system property in MongoMK&lt;br/&gt;
2) Use MK.diff() to find out if something was modified in a subtree&lt;br/&gt;
3) Use MK.getJournal() to find out if something was modified in a subtree&lt;/p&gt;

&lt;p&gt;Some initial thoughts on presented options to start the discussion (feel free to jump in and add more):&lt;/p&gt;

&lt;p&gt;Adding the :hash system property in MongoMK might not be that easy, because the implementation tries to avoid contention on the root node by not updating it with every commit. It only updates the nodes that actually changed. A straight forward implementation of :hash requires updating all ancestors of modified nodes.&lt;/p&gt;

&lt;p&gt;Option 2) seems to require additional work in MongoMK because the diff() implementation in MongoMK is using oak-mk DiffBuilder. The builder in turn will then call SimpleMongoNodeStore.compare(), which seems to use the same generic comparison implementation as the fallback in KernelNodeState.compareAgainstBaseState().&lt;/p&gt;

&lt;p&gt;AFAICS 3) might be a viable option with the recent support for branches in getJournal() (&lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-501&quot; title=&quot;Add journal support for branches&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-501&quot;&gt;&lt;del&gt;OAK-501&lt;/del&gt;&lt;/a&gt;). But I don&apos;t know how efficient this is implemented in MongoMK.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12624599">OAK-534</key>
            <summary>Inefficient NodeState comparison with MongoMK</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="mreutegg">Marcel Reutegger</reporter>
                        <labels>
                    </labels>
                <created>Wed, 19 Dec 2012 09:44:05 +0000</created>
                <updated>Wed, 13 Nov 2013 11:29:01 +0000</updated>
                            <resolved>Wed, 13 Nov 2013 11:29:01 +0000</resolved>
                                    <version>0.5</version>
                                                    <component>core</component>
                    <component>mongomk</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="13535825" author="mreutegg" created="Wed, 19 Dec 2012 09:50:23 +0000"  >&lt;p&gt;Just noticed there is alreay a TODO in KernelNodeState.compareAgainstBaseState() suggesting 2). As mentioned already, I think this will not work with MongoMK because of the way diff() is implemented there.&lt;/p&gt;</comment>
                            <comment id="13535836" author="mduerig" created="Wed, 19 Dec 2012 10:08:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;AFAICS 3) might be a viable option...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is not easy to retrofit the journal to generate the callbacks in &lt;tt&gt;NodeStateDiff&lt;/tt&gt;. I initially tried exactly the same for my POC of the oak-core implementation of rebase in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-464&quot; title=&quot;RootImpl.rebase() doesn&amp;#39;t handle move operations correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-464&quot;&gt;&lt;del&gt;OAK-464&lt;/del&gt;&lt;/a&gt;. See &lt;a href=&quot;https://github.com/mduerig/jackrabbit-oak/commit/42e8d60132ca2207c03fa79fd1ddca22406fc58a&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/mduerig/jackrabbit-oak/commit/42e8d60132ca2207c03fa79fd1ddca22406fc58a&lt;/a&gt;. In the end I decided to change the call backs there to closer match the journal semantics. &lt;/p&gt;

&lt;p&gt;The problem is that when diffing the node states, you have a consolidated view of all changes while when looking at the journal you see all kind of changes which interact/cancel each other in some way. Consider the still very simple case&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&amp;gt;/a:/x/a
+/x/a/b:{}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;this would need to fire an addNode call for /x/a/b which is not obvious from looking at individual journal entries. &lt;/p&gt;
</comment>
                            <comment id="13535853" author="tmueller" created="Wed, 19 Dec 2012 10:32:35 +0000"  >&lt;p&gt;As for 3): The method is getJournal(from, to, path). If oak-core would read the journal in the same way as it currently reads the nodes (starting from the root), that is if it calls getJournal(a, b, &quot;/&quot;) a lot, then the MicroKernel implementation would have to serialize the journal. As far as I understand, the MongoMK currently does that, but it does somewhat  limit scalability (the journal couldn&apos;t be sharded in the future).&lt;/p&gt;</comment>
                            <comment id="13535860" author="tmueller" created="Wed, 19 Dec 2012 11:01:16 +0000"  >&lt;p&gt;Reading from the MicroKernel is only needed for observation, and to update the cache in oak-core, right?&lt;/p&gt;

&lt;p&gt;I mean, changes that occurred within the &lt;em&gt;same&lt;/em&gt; oak-core instance don&apos;t need to be re-read from the MicroKernel after they were committed (or even before they were committed). Or do they?&lt;/p&gt;</comment>
                            <comment id="13535861" author="mreutegg" created="Wed, 19 Dec 2012 11:02:45 +0000"  >&lt;blockquote&gt;&lt;p&gt;It is not easy to retrofit the journal to generate the callbacks in NodeStateDiff.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually, I didn&apos;t want to do that. What I had in mind was a simple call to check whether there are journal entries at all for the revision range and path. If there are none, I&apos;d assume there were no changes and the two NodeStates and below subtree did not change.&lt;/p&gt;

&lt;p&gt;Is this conclusion correct?&lt;/p&gt;</comment>
                            <comment id="13535874" author="mduerig" created="Wed, 19 Dec 2012 11:15:42 +0000"  >&lt;blockquote&gt;&lt;p&gt;If there are none, I&apos;d assume there were no changes and the two NodeStates and below subtree did not change.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You mean you&apos;d look at the journal to short cut the equality check? If there is no journal entry for a given path, there are no changes in the sub tree at that path and diffing needs not descend into that tree. Otherwise it would have to (although there might still be no changes). &lt;/p&gt;

&lt;p&gt;Might work...&lt;/p&gt;</comment>
                            <comment id="13535877" author="mreutegg" created="Wed, 19 Dec 2012 11:20:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;You mean you&apos;d look at the journal to short cut the equality check?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that&apos;s the idea.&lt;/p&gt;</comment>
                            <comment id="13535893" author="tmueller" created="Wed, 19 Dec 2012 11:42:57 +0000"  >&lt;p&gt;That should work. Letting the MicroKernel create the journal just to check if there was anything changed (so basically just check if the journal is empty or not) sounds very wasteful, but it should work as a short term solution.&lt;/p&gt;

&lt;p&gt;But as I wrote earlier, if oak-core would read the journal in the same way as it currently reads the nodes (starting from the root), that is if it calls getJournal(a, b, &quot;/&quot;) a lot, then the MicroKernel implementation would have to serialize the journal.&lt;/p&gt;

&lt;p&gt;So even thought we could speed up oak-core with MongoMK, we don&apos;t really have a scalable solution yet.&lt;/p&gt;</comment>
                            <comment id="13535900" author="meteatamel" created="Wed, 19 Dec 2012 12:16:19 +0000"  >&lt;p&gt;&amp;gt; So even thought we could speed up oak-core with MongoMK, we don&apos;t really have a scalable solution yet.&lt;/p&gt;

&lt;p&gt;Where would that scalable solution be? In oak-core or MicroKernel? Either solution in MicroKernel (implementing hash or using getJournal) seems like a scalability problem but oak-core needs to know if a subtree changed efficiently, so it&apos;s not clear to me how we can have both scalability and efficient subtree change detection, at least in today&apos;s design.&lt;/p&gt;

&lt;p&gt;&amp;gt; Yes, that&apos;s the idea.&lt;/p&gt;

&lt;p&gt;Maybe we could use getRevisionHistory as well? Although that&apos;s time based and might not be what we want. Since all we care is whether a subtree under a path changed or not, another idea is to have a simplified getJournal method that simply returns true or false depending on whether a subtree changed or not. This might be implemented more efficiently but requires an additional API on MicroKernel.&lt;/p&gt;</comment>
                            <comment id="13535905" author="mduerig" created="Wed, 19 Dec 2012 12:25:44 +0000"  >&lt;p&gt;Couldn&apos;t we integrate the journal querying approach, which Marcel proposed with the :hash property approach? The Microkernel could generate that property on the fly querying the journal internally. This would save us the extra round trips between oak-core and oak-mk and would also not require additional APIs.&lt;/p&gt;</comment>
                            <comment id="13535906" author="tmueller" created="Wed, 19 Dec 2012 12:27:27 +0000"  >&lt;p&gt;&amp;gt; Where would that scalable solution be? In oak-core or MicroKernel?&lt;/p&gt;

&lt;p&gt;It would need to be in both. It was our plan to have a scalable design, now it seems both the MongoMK and oak-core are not actually scalable.&lt;/p&gt;

&lt;p&gt;&amp;gt; oak-core needs to know if a subtree changed efficiently&lt;/p&gt;

&lt;p&gt;Yes, to update the cache and for observation. But for nodes that are not in the cache and are never requested by a user, it is not needed. There is no need for oak-core to know that something changed in the repository in the path &quot;/x/y/z&quot; if there is no observation listener for that path, and if the user doesn&apos;t request that path. But it seems, currently oak-core would want to know that there was a change immediately, by requesting the content hash of the root node, or the journal of the root node. If any of both have to be accurate up to the latest millisecond, then I believe it&apos;s not possible to have a scalable microkernel implementation.&lt;/p&gt;

&lt;p&gt;&amp;gt; at least in today&apos;s design.&lt;/p&gt;

&lt;p&gt;Yes, that&apos;s my point. It seems to be the current design is not scalable.&lt;/p&gt;</comment>
                            <comment id="13535915" author="jukkaz" created="Wed, 19 Dec 2012 12:42:10 +0000"  >&lt;p&gt;As noticed by Marcel about option 2), this came up already in the summer, see &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-227&quot; title=&quot;MicroKernel API: add depth parameter to diff method&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-227&quot;&gt;&lt;del&gt;OAK-227&lt;/del&gt;&lt;/a&gt;. Is there a fundamental reason why MongoMK couldn&apos;t efficiently implement that?&lt;/p&gt;</comment>
                            <comment id="13535924" author="mreutegg" created="Wed, 19 Dec 2012 13:00:53 +0000"  >&lt;p&gt;I think it should be possible to implement that efficiently for some of the cases. AFAIU diff() is very generic and allows you to diff in both directions. I.e. you can also request reverse diffs and diffs across private branches.&lt;/p&gt;

&lt;p&gt;For the more common cases we could probably use a similar or the same implementation as in getJournal(), which works with the entries in the commits collection. A commit also has an entry for affected paths. This should help narrow down the relevant commits already in the mongo query.&lt;/p&gt;

&lt;p&gt;Regarding 3), it turns out GetJournalCommand with a path filter also uses DiffBuilder and traverses the complete tree :-/&lt;/p&gt;</comment>
                            <comment id="13535931" author="meteatamel" created="Wed, 19 Dec 2012 13:10:25 +0000"  >&lt;p&gt;&amp;gt; Regarding 3), it turns out GetJournalCommand with a path filter also uses DiffBuilder and traverses the complete tree :-/&lt;/p&gt;

&lt;p&gt;Unfortunately yes. When I first implemented getJournal, I tried to mirror MicroKernelImpl as much as possible with the hopes that we could merge common parts of both MicroKernels at some point. At the time, it didn&apos;t seem like traversing the tree would be a big deal, that&apos;s what MicroKernelImpl does as well. But do we have to do that? As you said, we could use affectedPaths in commits collection to filter for path right instead of relying on DiffBuilder?&lt;/p&gt;</comment>
                            <comment id="13535936" author="tmueller" created="Wed, 19 Dec 2012 13:14:10 +0000"  >&lt;p&gt;To make the design really scalable, the only change required would be if the journal / the :hash property don&apos;t need to be reflected &lt;em&gt;immediately&lt;/em&gt; on the root node, just eventually (after a few seconds or so). &lt;/p&gt;

&lt;p&gt;That is, for a change made by the local MongoMK, the :hash property could be updated immediately (and the journal available immediately), but for a change made by another MongoMK, the :hash property would be changed (and the journal entry for the change would appear) a little bit later. Depending on the size of the repository for example a second after the change occurred, so that there is no contention and no strict synchronization required.&lt;/p&gt;


</comment>
                            <comment id="13535949" author="tmueller" created="Wed, 19 Dec 2012 13:27:24 +0000"  >&lt;p&gt;As a longer term solution, I&apos;m in favor of 1) (Add support for :hash system property in MongoMK), but with a small change: instead of the content hash, the :hash system property would be something like a counter that reflects the known changes within a subtree.&lt;/p&gt;

&lt;p&gt;Local changes would be known immediately, and non-local changes (changes made by another MongoMK) would be reflected eventually, within a few seconds.&lt;/p&gt;

&lt;p&gt;The MongoMK would need to be changed so that local changes immediately update the property for all parent nodes (including the root), but just in-memory. So there would be an in-memory structure needed to keep track of the changes. The changes would be persisted eventually in the backend storage MongoDB, so that other MongoMKs would get informed about changes. Also, the in-memory structure would need to be updated from time to time from the stored state, to pick up changes made by others.&lt;/p&gt;

&lt;p&gt;That way, no change in oak-core are needed, except that oak-core would need to deal with the fact that changes made by others don&apos;t appear immediately. Maybe that&apos;s already the case (and if not, that&apos;s the required cost to make it scalable.)&lt;/p&gt;</comment>
                            <comment id="13535977" author="meteatamel" created="Wed, 19 Dec 2012 14:06:02 +0000"  >&lt;p&gt;I&apos;m wondering whether we cannot reuse revision id as a hash rather than a counter? So the hash at a node would contain the highest revision id of all nodes under that node. Wouldn&apos;t this work?&lt;/p&gt;</comment>
                            <comment id="13535987" author="mduerig" created="Wed, 19 Dec 2012 14:12:31 +0000"  >&lt;p&gt;I think this should work. But wouldn&apos;t that require updating all nodes up to the root on every change? OTHO if we could generate the :hash property on the fly with that value, then I think we are fine.&lt;/p&gt;</comment>
                            <comment id="13536011" author="tmueller" created="Wed, 19 Dec 2012 15:03:23 +0000"  >&lt;p&gt;Yes. I think the &quot;:hash&quot; property doesn&apos;t actually need to be a content hash for oak-core to work. So instead, we could use (for example) a combination of the last local revision (let&apos;s say &quot;r4054&quot;) and a stored update counter (let&apos;s say &quot;1234&quot;). So the &quot;:hash&quot; property returned to oak-core would be &quot;r4054-12345&quot;, which means the latest local revision to the root node was &quot;r4054&quot;, and the stored mod-count was &quot;12345&quot;. Whenever anything was committed locally, the revision of the root node is changed (&quot;r4055&quot;, &quot;r4060&quot;, &quot;r4062&quot;), while the stored counter would stay. From time to time (let&apos;s say every 5 seconds), the root node counter is incremented. Even if there are many changes, and many MongoMKs, I don&apos;t think this would be a problem for MongoDB. Each MongoMK would from time to time read the update counter.&lt;/p&gt;

&lt;p&gt;&amp;gt; I&apos;m wondering whether we cannot reuse revision id as a hash rather than a counter&lt;/p&gt;

&lt;p&gt;The data in MongoDB could be a counter, and (only if there were local commits) the MongoMK would append the local revision. So the &quot;:hash&quot; property returned to oak-core would change if either the counter changes or there was a local commit.&lt;/p&gt;

&lt;p&gt;&amp;gt; But wouldn&apos;t that require updating all nodes up to the root on every change?&lt;/p&gt;

&lt;p&gt;Yes, but only in-memory within MongoMK.&lt;/p&gt;

&lt;p&gt;&amp;gt; generate the :hash property on the fly with that value&lt;/p&gt;

&lt;p&gt;Yes.&lt;/p&gt;</comment>
                            <comment id="13536045" author="tmueller" created="Wed, 19 Dec 2012 15:39:10 +0000"  >&lt;p&gt;Would it make sense to create a prototype of this solution?&lt;/p&gt;</comment>
                            <comment id="13536059" author="jukkaz" created="Wed, 19 Dec 2012 15:52:37 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think the &quot;:hash&quot; property doesn&apos;t actually need to be a content hash for oak-core to work.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It doesn&apos;t need to be a content hash, but hashA != hashB needs to imply contentA != contentB, which is not necessarily the case with revision ids.&lt;/p&gt;</comment>
                            <comment id="13536064" author="tmueller" created="Wed, 19 Dec 2012 15:59:36 +0000"  >&lt;p&gt;&amp;gt; but hashA != hashB needs to imply contentA != contentB&lt;/p&gt;

&lt;p&gt;I thought hashA = hashB implies contentA = contentB. What would happend in oak-core if hashA != hashB but contentA = contentB?&lt;/p&gt;</comment>
                            <comment id="13536077" author="mreutegg" created="Wed, 19 Dec 2012 16:15:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;Would it make sense to create a prototype of this solution?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I find it difficult to understand what the exact implications are of this solution and what side effects it may have.&lt;/p&gt;

&lt;p&gt;I&apos;m currently exploring a way to provide a somewhat efficient MK.diff() implementation for the special case required in KernelNodeState (specific path and depth=0).&lt;/p&gt;</comment>
                            <comment id="13536433" author="jukkaz" created="Wed, 19 Dec 2012 21:26:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;I thought hashA = hashB implies contentA = contentB.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It does, but the reverse is also required. See the MK javadocs on the semantics of :hash.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What would happend in oak-core if hashA != hashB but contentA = contentB?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We&apos;d need to adapt KernelNodeState.equals(), otherwise oak-core could get tricked into recursing down to unmodified subtrees, possibly triggering access control or other validation errors even when nothing actually changed.&lt;/p&gt;

&lt;p&gt;Note that in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-468&quot; title=&quot;Identifier- or hash-based access in the MicroKernel&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-468&quot;&gt;&lt;del&gt;OAK-468&lt;/del&gt;&lt;/a&gt; we already came up with the optional &quot;:id&quot; property that can be used instead of &quot;:hash&quot; when only the idA = idB -&amp;gt; contentA = contentB implication can be guaranteed. So far oak-core doesn&apos;t yet leverage this property, but I&apos;d suggest we rather add support for it instead of modifying the &quot;:hash&quot; contract.&lt;/p&gt;</comment>
                            <comment id="13536842" author="tmueller" created="Thu, 20 Dec 2012 07:46:05 +0000"  >&lt;p&gt;About many child nodes: if the &quot;:hash&quot; or &quot;:id&quot; property is different, and the node has millions of child nodes, then all of those nodes would need to be read with approach 1), right?&lt;/p&gt;</comment>
                            <comment id="13536844" author="tmueller" created="Thu, 20 Dec 2012 07:49:25 +0000"  >&lt;p&gt;About access control, aren&apos;t there cases where parents are not accessible but children are? So isn&apos;t it a problem anyway to traverse down the tree?&lt;/p&gt;</comment>
                            <comment id="13536864" author="mreutegg" created="Thu, 20 Dec 2012 08:36:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;About access control&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;There&apos;s no access control at this level.&lt;/p&gt;</comment>
                            <comment id="13536869" author="jukkaz" created="Thu, 20 Dec 2012 08:46:03 +0000"  >&lt;blockquote&gt;&lt;p&gt;About many child nodes: if the &quot;:hash&quot; or &quot;:id&quot; property is different, and the node has millions of child nodes, then all of those nodes would need to be read with approach 1), right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Right. That&apos;s why we came up with &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-227&quot; title=&quot;MicroKernel API: add depth parameter to diff method&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-227&quot;&gt;&lt;del&gt;OAK-227&lt;/del&gt;&lt;/a&gt; earlier, and why option 2 is ultimately the best solution here (needs to be implemented also in oak-core). The &quot;:hash&quot; or &quot;:id&quot; properties can be used to optimize away certain diff() and getNodes() calls, so they&apos;re still useful to have also with option 2.&lt;/p&gt;</comment>
                            <comment id="13536874" author="mreutegg" created="Thu, 20 Dec 2012 09:08:06 +0000"  >&lt;p&gt;Attached patch introduces a OneLevelDiffCommand, which is used when MK.diff() is called with depth = 0. It&apos;s a specialized version of DiffCommand, which works with the commits collection to find out what the affected paths are in a given revision range.&lt;/p&gt;

&lt;p&gt;Please note that I also had to fix a test case to get the mongomk tests running reliably on my Windows machine, but that&apos;s most likely unrelated to this issue.&lt;/p&gt;</comment>
                            <comment id="13537038" author="mreutegg" created="Thu, 20 Dec 2012 14:21:58 +0000"  >&lt;p&gt;Applied patch in revision 1424481. Please review and provide feedback.&lt;/p&gt;

&lt;p&gt;I don&apos;t consider this issue fixed with this commit. But it&apos;s at least a start.&lt;/p&gt;</comment>
                            <comment id="13558894" author="mreutegg" created="Mon, 21 Jan 2013 16:38:24 +0000"  >&lt;p&gt;I now encountered the &apos;many child nodes&apos; issue raised by Thomas. My Oak repository on MongoMK has&lt;br/&gt;
an index on jcr:uuid and contains roughly 7000 referenceable nodes. When a referenceable nodes&lt;br/&gt;
is added, the NodeState comparison now triggers diff calls for each of the index entries even&lt;br/&gt;
though only one of them was added. This is because the simple implementation I added does not&lt;br/&gt;
leverage the child node change information provided by the diff, but instead performs a diff&lt;br/&gt;
on each of the index entry nodes.&lt;/p&gt;</comment>
                            <comment id="13821232" author="mreutegg" created="Wed, 13 Nov 2013 11:29:01 +0000"  >&lt;p&gt;This issue was filed for the initial version of the MongoMK. Resolving as WONTFIX.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12561858" name="OAK-534.patch" size="10671" author="mreutegg" created="Thu, 20 Dec 2012 09:08:06 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>300422</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 1 week, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1685z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>244455</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>