<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:42:56 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-333] 1000 byte path limit in MongoMK</title>
                <link>https://issues.apache.org/jira/browse/OAK-333</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;In an infinite loop try to add nodes one under another to have N0/N1/N2...NN. At some point, the current parent node will not be found and the current commit will fail. I think this happens when the path length exceeds 1000 characters. Is this enough for a path? I was able to create this way only 222 levels in the tree (and my node names were really short N1, N2 ...)&lt;/p&gt;

&lt;p&gt;There&apos;s an automated tests for this: NodeExistsCommandMongoTest.testTreeDepth&lt;/p&gt;</description>
                <environment></environment>
        <key id="12608656">OAK-333</key>
            <summary>1000 byte path limit in MongoMK</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="thomasm">Thomas Mueller</assignee>
                                    <reporter username="meteatamel">Mete Atamel</reporter>
                        <labels>
                    </labels>
                <created>Fri, 21 Sep 2012 15:35:01 +0000</created>
                <updated>Tue, 8 Oct 2019 15:22:07 +0000</updated>
                            <resolved>Wed, 19 Mar 2014 15:00:52 +0000</resolved>
                                    <version>0.5</version>
                                    <fixVersion>0.19</fixVersion>
                                    <component>mongomk</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="13461705" author="meteatamel" created="Mon, 24 Sep 2012 09:47:43 +0000"  >&lt;p&gt;Attaching a patch. The patch doesn&apos;t solve this problem, it merely moves the test to the right location but it does solve &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-330&quot; title=&quot;Some MongoMK tests do not use CommitImpl constructor correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-330&quot;&gt;&lt;del&gt;OAK-330&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-332&quot; title=&quot;[MongoMK] Node is not visible in head revision&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-332&quot;&gt;&lt;del&gt;OAK-332&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13461747" author="jukkaz" created="Mon, 24 Sep 2012 11:45:24 +0000"  >&lt;p&gt;Patch committed in revision 1389305.&lt;/p&gt;</comment>
                            <comment id="13461798" author="alex.parvulescu" created="Mon, 24 Sep 2012 13:56:51 +0000"  >&lt;p&gt;removed &quot;fix-version: 0.5&quot;&lt;/p&gt;</comment>
                            <comment id="13497825" author="meteatamel" created="Thu, 15 Nov 2012 07:52:35 +0000"  >&lt;p&gt;Note that the test for this issue is MongoMKLimitsTest#pathLimit. It&apos;s currently marked with @Ignore.&lt;/p&gt;</comment>
                            <comment id="13508646" author="tmueller" created="Mon, 3 Dec 2012 11:02:29 +0000"  >&lt;p&gt;One way to solve this (potential) problem is to shrink long paths, using a replacment table, similar to what we do in Jackrabbit 2.x using the name index.&lt;/p&gt;

&lt;p&gt;(A) One solution is to shrink the paths is to have a &apos;replacement table&apos; for long path elements (similar to MS-DOS filenames). For example, path elements longer than 19 bytes could be replaced with a shorter version (&quot;/x/longPathElementBlaBlaBla/anotherLongPlathElement/y&quot; could be replaced with &quot;/x/longPath~1/anotherLo~2/y&quot;, using the name index &quot;longPath~1&quot; = &quot;longPathElementBlaBlaBla&quot; and &quot;anotherLo~2&quot; = &quot;anotherLongPlathElement&quot;). This would limit each element to be 19 bytes, so that a path could always contain 50 elements (the &apos;/&apos; is also one byte). This is still a potential problem, but only for very rare cases (one could say &quot;misbehaving applications&quot;). The disadvantage is that shortening is required even if the path itself is quite short, but only one path element is long. So shortening would be used quite a lot.&lt;/p&gt;

&lt;p&gt;(B) Another solution is to shrink multiple the combination of multiple elements. &lt;br/&gt;
(&quot;/x/longPathElementBlaBlaBla/anotherLongPlathElement/y&quot; would be replaced with &quot;~1/y&quot; using the name index &quot;~1&quot; = &quot;/x/longPathElementBlaBlaBla/anotherLongPlathElement&quot;). One could even allow recursive replacement, so that there is no limit. This would avoid having to shorten path that are short and contain just one or few longer elements. The advantage is that shortening is only required for extreme cases.&lt;/p&gt;

&lt;p&gt;Each MicroKernel would need to know exactly when shortening is required, without having to read this collection each time. For variant (A) this is quite easy (shortening is required for all elements longer than 20 bytes), for variant (B) it would be a bit more complex: shortening is required if the total length of the parent of the path exceeds 500 bytes (only the parent is shortened). It is also required for each path element that exceeds 500 bytes.&lt;/p&gt;

&lt;p&gt;Above, it is assumed that &quot;~&quot; is illegal within a path. I guess this is not the case, so another character needs to be used as an shortening character.&lt;/p&gt;
</comment>
                            <comment id="13511438" author="mduerig" created="Thu, 6 Dec 2012 15:05:27 +0000"  >&lt;p&gt;Before we jump to conclusion, could someone clarify the origin of this limitation: What MongoDB specific limitation does cause this?&lt;/p&gt;</comment>
                            <comment id="13511459" author="tmueller" created="Thu, 6 Dec 2012 15:31:30 +0000"  >&lt;p&gt;The limitation is &quot;Indexed items can be no larger than 1024 bytes. This value is the indexed content (i.e. the field value, or compound field value.)&quot; - see also &lt;a href=&quot;http://docs.mongodb.org/manual/reference/limits/#Index%20Size&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://docs.mongodb.org/manual/reference/limits/#Index%20Size&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13526250" author="fmeschbe" created="Fri, 7 Dec 2012 09:25:56 +0000"  >&lt;p&gt;From the peanut gallery of users: Whatever the solution is, there must not be any arbitrary limits along the lines of &quot;no one is ever going to write a program larger than 640KB&quot;.&lt;/p&gt;</comment>
                            <comment id="13526252" author="mduerig" created="Fri, 7 Dec 2012 09:29:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;The limitation is &quot;Indexed items can be no larger than 1024 bytes.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Couldn&apos;t we - in addition to the path - store a hash of the path and index that instead of the path itself? &lt;/p&gt;</comment>
                            <comment id="13526282" author="tmueller" created="Fri, 7 Dec 2012 10:19:24 +0000"  >&lt;p&gt;Indexing the hash of the path would be very bad for performance, because it would cause nodes that are logically close to each other (have a similar path) to be distributed over the whole (possibly sharded) repository. See also  &lt;/p&gt;

&lt;p&gt;Shard Keys:&lt;br/&gt;
&lt;a href=&quot;http://docs.mongodb.org/manual/core/sharding-internals/#sharding-internals-shard-keys&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://docs.mongodb.org/manual/core/sharding-internals/#sharding-internals-shard-keys&lt;/a&gt; :&lt;/p&gt;

&lt;p&gt;Query Isolation:&lt;br/&gt;
&lt;a href=&quot;http://docs.mongodb.org/manual/core/sharding-internals/#sharding-shard-key-query-isolation&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://docs.mongodb.org/manual/core/sharding-internals/#sharding-shard-key-query-isolation&lt;/a&gt;&lt;br/&gt;
&quot;The fastest queries in a sharded environment are those that mongos will route to a single shard&quot;&lt;/p&gt;

&lt;p&gt;Now, let&apos;s assume we use the hash code of the path as the shard key (and not the path). If we do that, each query to retrieve a number of nodes with a given depth (let&apos;s say depth 3) will have to first read the parent node, then for each child node read the child node, and so on. That&apos;s almost n queries (where n is the number of returned nodes)!&lt;/p&gt;

&lt;p&gt;When using the path as the shared key, it&apos;s just one query (path like &apos;/.../%&apos; and depth between 3 and 6), which is routed to just one shard normally, because all nodes are stored in the same shard.&lt;/p&gt;


</comment>
                            <comment id="13526304" author="mduerig" created="Fri, 7 Dec 2012 10:45:39 +0000"  >&lt;p&gt;What about hashing just the overflowing part of the path. I.e. for&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/a/very/&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;/path/that/exceeds/a/length/limit
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;convert it to something like&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/a/very/&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;/path/that/&amp;lt;hash(exceeds/a/length/limit)&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and index that?&lt;/p&gt;
</comment>
                            <comment id="13526313" author="tmueller" created="Fri, 7 Dec 2012 10:57:41 +0000"  >&lt;p&gt;It would still have the same basic performance problems as indexing the hash, once the path gets too long. &lt;/p&gt;

&lt;p&gt;In (B) above, I described a solution that is somewhat similar, but avoids the problem: instead shrinking the end of the path, I suggested to shrink the beginning of the path. So if the path exceeds a limit, the first limit/2 characters are replaced with index, which could be the hash code actually. So&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/a/very/&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;/path/that/exceeds/a/length/limit
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;would be converted to&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&amp;lt;id(/a/very/&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;/path/that)&amp;gt;/exceeds/a/length/limit
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Instead of a simple hash, I would use a lookup table. This lookup table would normally be empty (as normally there are no long paths). If a path is too long, then the left 50% of the path is stored there. So that each path that starts with /a/very/long/path/that uses the same shorter prefix).&lt;/p&gt;

&lt;p&gt;Similar to the name index we use in Jackrabbit, the id of the long prefix could be the hash code of the prefix.&lt;/p&gt;

&lt;p&gt;That way, similar paths stay on the same mongo shard.&lt;/p&gt;</comment>
                            <comment id="13526318" author="mduerig" created="Fri, 7 Dec 2012 11:05:55 +0000"  >&lt;blockquote&gt;&lt;p&gt;So if the path exceeds a limit, the first limit/2 characters are replaced&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;But then a path of lenght &amp;gt; 2*limit would still exceed the limit. &lt;/p&gt;</comment>
                            <comment id="13526325" author="tmueller" created="Fri, 7 Dec 2012 11:32:24 +0000"  >&lt;p&gt;&amp;gt; So if the path exceeds a limit, the first limit/2 characters are replaced&lt;/p&gt;

&lt;p&gt;See the comment above, &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-333?focusedCommentId=13508646&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13508646&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/OAK-333?focusedCommentId=13508646&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13508646&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&quot;One could even allow recursive replacement, so that there is no limit.&quot;&lt;/p&gt;

&lt;p&gt;But actually I don&apos;t think recursion is needed. There are other solutions that don&apos;t require recursion, such as replace multiples of limit/2 bytes in once step.&lt;/p&gt;

&lt;p&gt;I guess the next question will be what if the path is longer than 16 MB (the MongoDB limit for documents)? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13526327" author="mduerig" created="Fri, 7 Dec 2012 11:42:47 +0000"  >&lt;blockquote&gt;&lt;p&gt;There are other solutions that don&apos;t require recursion, such as replace multiples of limit/2 bytes in once step.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But that would result in similar limitations wrt. to sharding as you describe above since a much longer path with the same prefix as a shorter path might end up with a different replacement for its initial part. &lt;/p&gt;

&lt;p&gt;The hash based approach avoids that. Here the limitation wrt. sharding only starts to show when sharding is actually done at a very deep path level which I think is quite unlikely. &lt;/p&gt;



</comment>
                            <comment id="13526339" author="tmueller" created="Fri, 7 Dec 2012 11:57:58 +0000"  >&lt;p&gt;&amp;gt; &amp;gt; replace multiples of limit/2 bytes in once step&lt;br/&gt;
&amp;gt; But that would result in similar limitations wrt. to sharding as you describe above since a much longer path with the same prefix as a shorter path might end up with a different replacement for its initial part.&lt;/p&gt;

&lt;p&gt;Yes, there would be one replacement for paths with length 500-1000 bytes, and a different replacement for a path with length 1000-1500 bytes, and so on. That&apos;s true. However, it sounds to me this is just a theoretical problem, and not a real one. I&apos;m not even sure that in reality we will encounter paths that are larger than 1000 bytes, let alone path longer than 2000 bytes.&lt;/p&gt;

&lt;p&gt;&amp;gt; The hash based approach avoids that.&lt;/p&gt;

&lt;p&gt;Yes, it avoid that, but with the cost of a different (and I believe much bigger) problem, which is: you would need to read each node separately once the path exceeds a certain limit. Plus nodes with a similar name would be stored in completely different place in the index (within the same mongo shard). This is a similar problem than what we have in Jackrabbit 2.x with the randomly distributed node ids.&lt;/p&gt;</comment>
                            <comment id="13564336" author="mreutegg" created="Mon, 28 Jan 2013 15:24:00 +0000"  >&lt;p&gt;I propose to turn the path of a node into &amp;lt;hashOfParentPath&amp;gt;/nodeName. This keeps locality to some degree. I.e. all children of a node will be on the same shard, assuming we use hashOfParentPath as the sharding key.&lt;/p&gt;</comment>
                            <comment id="13564370" author="tmueller" created="Mon, 28 Jan 2013 16:12:20 +0000"  >&lt;p&gt;I think using the hash would be relatively  bad for read performance for a larger repository (for example when traversing all nodes), similar to the randomly distributed node ids of Jackrabbit 2.x. How bad exactly is an option question of course, we would need to run some tests. In order to run such tests, would it be possible to use a switch (static final boolean) in the code, so that this can be tested?&lt;/p&gt;

&lt;p&gt;Is &amp;lt;hashOfParentPath&amp;gt; a cryptographic hash?&lt;/p&gt;</comment>
                            <comment id="13564399" author="tmueller" created="Mon, 28 Jan 2013 16:43:23 +0000"  >&lt;p&gt;Please note there would still be a limit, now on the node name.&lt;/p&gt;</comment>
                            <comment id="13565190" author="mreutegg" created="Tue, 29 Jan 2013 08:45:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;similar to the randomly distributed node ids of Jackrabbit 2.x&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It depends on the node structure. The most frequent problem pattern I saw in the past where nodes with a couple of hundres child nodes. We always said that&apos;s fine and you would only get into trouble when you have thousands of nodes. But as experience showed that&apos;s not 100% correct. In Jackrabbit 2.x this indeed results in hundres of random I/O because of the random UUIDs of the child nodes. With the proposed hash of the parent path that&apos;s not the case. The key (hash) to look up the child nodes is unique. The remaining problem is where those nodes are stored on disk. But I guess that&apos;s something we cannot control anyway if we depend on a 3rd party storage mechanism like MongoDB or H2.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&amp;lt;hashOfParentPath&amp;gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, I&apos;d use SHA-1.&lt;/p&gt;</comment>
                            <comment id="13565192" author="mreutegg" created="Tue, 29 Jan 2013 08:46:56 +0000"  >&lt;blockquote&gt;&lt;p&gt;still be a limit, now on the node name&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that&apos;s correct. But to be honest, I&apos;d be OK to say this is a known limitation of MongoMK.&lt;/p&gt;</comment>
                            <comment id="13565257" author="tmueller" created="Tue, 29 Jan 2013 10:31:41 +0000"  >&lt;p&gt;&amp;gt; couple of hundres child nodes&lt;/p&gt;

&lt;p&gt;Yes, I also saw slightly decreased performance for this case. However, I think the normal case is just a few child node. Actually it would make sense to gather some statistics about that (percentage of nodes with no child nodes, percentage of nodes with x-y child node) so we have a better picture.&lt;/p&gt;

&lt;p&gt;&amp;gt; The remaining problem is where those nodes are stored on disk. But I guess that&apos;s something we cannot control anyway if we depend on a 3rd party storage mechanism like MongoDB or H2.&lt;/p&gt;

&lt;p&gt;Well, if the key is randomly distributed, then it will be slow in any storage engine (MongoDB, Oracle, MySQL, PostgreSQL, Cassandra, and so on), with very few exceptions. One exception is in-memory storage, the second exception is if the value is relatively large (a few megabytes) such that reading the value is the bottleneck and not indexing.&lt;/p&gt;</comment>
                            <comment id="13565261" author="tmueller" created="Tue, 29 Jan 2013 10:44:47 +0000"  >&lt;p&gt;&amp;gt; node name limit&lt;/p&gt;

&lt;p&gt;I wonder how big the problem is. Non-ASCII characters are converted to &lt;tt&gt;_&lt;em&gt;x0000&lt;/em&gt;_&lt;/tt&gt; as far as I know, so 7 bytes per character. With SHA-1, 41 characters are needed for the prefix, so that a node name might contain up to 137 non-ASCII characters. When storing a title or subject (possibly user generated) in a node name that&apos;s still a bit low I think.&lt;/p&gt;</comment>
                            <comment id="13565274" author="mreutegg" created="Tue, 29 Jan 2013 10:49:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;gather some statistics&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Static analysis is not sufficient. E.g. there is no need to optimize reading some content structure if it is not read at all or only a small fraction of it.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Non-ASCII characters are converted to x0000&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why and where?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;41 characters are needed for the prefix&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The prefix can be in a separate field.&lt;/p&gt;</comment>
                            <comment id="13565276" author="jukkaz" created="Tue, 29 Jan 2013 10:50:31 +0000"  >&lt;blockquote&gt;&lt;p&gt;Actually it would make sense to gather some statistics about that ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;See &lt;a href=&quot;http://markmail.org/message/kxe3iy2hnodxsghe&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://markmail.org/message/kxe3iy2hnodxsghe&lt;/a&gt; for a start.&lt;/p&gt;</comment>
                            <comment id="13565289" author="tmueller" created="Tue, 29 Jan 2013 11:43:07 +0000"  >&lt;p&gt;&amp;gt; Non-ASCII characters are converted to x0000&lt;/p&gt;

&lt;p&gt;Sorry, I think thats not related to the problem... It seems this is only for XML export / import, and the query engine. So I guess it wouldn&apos;t apply here. When using UTF-8, non-ASCII characters might need 3 bytes, so the limit would be 333 such characters.&lt;/p&gt;

&lt;p&gt;&amp;gt; there is no need to optimize reading some content structure if it is not read at all or only a small fraction of it.&lt;/p&gt;

&lt;p&gt;The use case I had in mind was traversing nodes (for example reading 15 nodes at a time, worst case traversing the whole repository). I think that&apos;s quite a common use case but I don&apos;t have any number.&lt;/p&gt;

&lt;p&gt;&amp;gt; Node structure statistics&lt;/p&gt;

&lt;p&gt;Thanks Jukka, that&apos;s very interesting! In that case 93% of all nodes would have a unique parent path hash, and for 7% of all nodes the hash wouldn&apos;t be unique. That&apos;s only 7% &apos;better&apos; than the Jackrabbit 2.x case were each node has a unique node id.&lt;/p&gt;


</comment>
                            <comment id="13816043" author="tmueller" created="Thu, 7 Nov 2013 15:24:16 +0000"  >&lt;p&gt;Some real-world data: for a common application (default installation), the longest path is 312 characters, in the index /oak:index/slingResourceType. Most long paths are within this index, and the nodetype index. Most paths are about 70 characters long. The path length distribution is (resolution 10):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;length, number of nodes
310	1
300	5
290	22
280	69
270	129
260	323
250	517
240	831
230	1078
220	1427
210	2056
200	2807
190	4023
180	5273
170	7273
160	10293
150	13973
140	17327
130	20884
120	24295
110	51864
100	42770
90	53701
80	76674
70	104120
60	38429
50	36931
40	29283
30	43875
20	7588
10	261
0	26
query:
select length(path)/10*10 length, count(*) from test group by length order by 1 desc;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also interesting, the number of path elements. The distribution is:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;depth, number of nodes
29	12
28	31
27	69
26	168
25	398
24	561
23	787
22	963
21	1353
20	2101
19	3319
18	4456
17	4986
16	8399
15	14425
14	18811
13	22238
12	29710
11	34470
10	207770
9	55331
8	26096
7	17895
6	97935
5	19592
4	25081
3	935
2	180
1	55
0	1
query:
select depth, count(*) from test group by depth order by depth desc;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13831515" author="reschke" created="Mon, 25 Nov 2013 14:58:18 +0000"  >&lt;p&gt;Note that this test is still disabled, and, when enabled, fails with:&lt;/p&gt;

&lt;p&gt;-------------------------------------------------------------------------------&lt;br/&gt;
Test set: org.apache.jackrabbit.oak.plugins.mongomk.impl.MongoMKLimitsTest&lt;br/&gt;
-------------------------------------------------------------------------------&lt;br/&gt;
Tests run: 2, Failures: 0, Errors: 1, Skipped: 1, Time elapsed: 0.061 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!&lt;br/&gt;
pathLimit(org.apache.jackrabbit.oak.plugins.mongomk.impl.MongoMKLimitsTest)  Time elapsed: 0.059 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!&lt;br/&gt;
org.apache.jackrabbit.mk.api.MicroKernelException: java.lang.NullPointerException&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.MongoDocumentStore.findAndModify(MongoDocumentStore.java:371)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.MongoDocumentStore.createOrUpdate(MongoDocumentStore.java:383)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.Commit.rollback(Commit.java:329)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.Commit.applyToDocumentStore(Commit.java:277)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.Commit.applyToDocumentStore(Commit.java:166)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.Commit.apply(Commit.java:149)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.MongoNodeStore.apply(MongoNodeStore.java:902)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.MongoMK.commit(MongoMK.java:393)&lt;br/&gt;
	at org.apache.jackrabbit.oak.plugins.mongomk.impl.MongoMKLimitsTest.pathLimit(MongoMKLimitsTest.java:50)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;/p&gt;</comment>
                            <comment id="13914407" author="reschke" created="Thu, 27 Feb 2014 11:21:19 +0000"  >&lt;p&gt;A few comments:&lt;/p&gt;

&lt;p&gt;1) The limit is on bytes, not characters; thus you can have ~1000 ASCII characters, but only ~333 Euro signs, because of UTF-8. So this may be a much bigger problem for non-western locales&lt;/p&gt;

&lt;p&gt;2) Another problem is that until recently, mongodb did accept the write operation and just failed to update the index; thus the persistence problem is obscured, and may not surface anytime soon due to caching. mongodb 2.5.5 fixes that (see &lt;a href=&quot;https://jira.mongodb.org/browse/SERVER-5290&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://jira.mongodb.org/browse/SERVER-5290&lt;/a&gt;, I just verified with /mongodb-win32-x86_64-2008plus-2.6.0-rc0)&lt;/p&gt;</comment>
                            <comment id="13914450" author="reschke" created="Thu, 27 Feb 2014 12:26:26 +0000"  >&lt;p&gt;test case for long node names over JCR&lt;/p&gt;</comment>
                            <comment id="13933158" author="tmueller" created="Thu, 13 Mar 2014 12:18:22 +0000"  >&lt;p&gt;Revision 1577129: long paths are now treated specially: the parent path is hashed (SHA-256). The thresholds can be configured using the system properties &quot;oak.pathShort&quot; (default 330, number of characters) and &quot;oak.pathLong&quot; (default 700, number of bytes of the UTF-8 representation of the parent). The &quot;oak.pathShort&quot; is just an optimization so that short paths are not further investigated.&lt;/p&gt;</comment>
                            <comment id="13933213" author="tmueller" created="Thu, 13 Mar 2014 13:05:41 +0000"  >&lt;p&gt;Revision 1577148: test case&lt;/p&gt;</comment>
                            <comment id="13939716" author="mreutegg" created="Tue, 18 Mar 2014 20:17:20 +0000"  >&lt;p&gt;With these changes several tests fail. Unfortunately our travis builds failed already before and we didn&apos;t notice this regression.&lt;/p&gt;

&lt;p&gt;As a quick workaround I reverted the changes in CacheInvalidator: &lt;a href=&quot;http://svn.apache.org/r1579027&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/r1579027&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The problem is that the cache may also contain NodeDocument.NULL entries. These don&apos;t have a path nor an id. Because of this I got the following exception in the logs:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;19:51:24.827 WARN  [main] DocumentNodeStore.java:1285        Background operation failed: java.lang.NullPointerException
java.lang.NullPointerException: null
        at org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(Utils.java:265) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.plugins.document.NodeDocument.getPath(NodeDocument.java:1175) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.plugins.document.mongo.CacheInvalidator$HierarchicalInvalidator.constructTreeFromPaths(CacheInvalidator.java:279) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.plugins.document.mongo.CacheInvalidator$HierarchicalInvalidator.invalidateCache(CacheInvalidator.java:177) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore.invalidateCache(MongoDocumentStore.java:189) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.backgroundRead(DocumentNodeStore.java:1333) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.runBackgroundOperations(DocumentNodeStore.java:1280) ~[oak-core-0.19-SNAPSHOT.jar:0.19-SNAPSHOT]
        at org.apache.jackrabbit.oak.jcr.ConcurrentAddNodesClusterIT.runBackgroundOps(ConcurrentAddNodesClusterIT.java:326) [test-classes/:na]
        at org.apache.jackrabbit.oak.jcr.ConcurrentAddNodesClusterIT.rebaseVisibility(ConcurrentAddNodesClusterIT.java:249) [test-classes/:na]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The stack trace also shows one of the tests to reliably reproduce the failure: ConcurrentAddNodesClusterIT.rebaseVisibility in oak-jcr&lt;/p&gt;</comment>
                            <comment id="13940347" author="tmueller" created="Wed, 19 Mar 2014 09:46:41 +0000"  >&lt;p&gt;I see. It looks like I didn&apos;t run this test... Suggested patch:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Index: src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java
===================================================================
--- src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java	(revision 1579181)
+++ src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java	(working copy)
@@ -41,6 +41,7 @@
 import org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument;
 import org.apache.jackrabbit.oak.plugins.document.Collection;
 import org.apache.jackrabbit.oak.plugins.document.Document;
+import org.apache.jackrabbit.oak.plugins.document.NodeDocument;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -276,8 +277,12 @@
                 //check them
                 //TODO Need to determine way to determine if the
                 //key is referring to a split document
-                String path = Utils.getPathFromId(e.getKey().toString());
                 result.cacheSize++;
+                CachedNodeDocument doc = e.getValue();
+                if (doc == NodeDocument.NULL) {
+                    continue;
+                }
+                String path = e.getValue().getPath();
                 for (String name : PathUtils.elements(path)) {
                     current = current.child(name);
                 }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13940354" author="tmueller" created="Wed, 19 Mar 2014 10:01:26 +0000"  >&lt;p&gt;I confirmed with Chetan that the patch above should work. I still get an exception running the IT tests, but I think that is not related to this issue:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Tests in error: 
  addNodes2(org.apache.jackrabbit.oak.jcr.ConcurrentAddNodesClusterIT): OakMerge0002: OakMerge0002: Conflicting concurrent change. Update operation failed: key: 0:/ update {_revisions.r144d9c56ca0-0-1=SET_MAP_ENTRY c-r144d9c59f99-4-1, _modified=SET 279044602, _collisions.r144d9c56ba2-0-1=CONTAINS_MAP_ENTRY false, _collisions.r144d9c56c9c-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56bb8-0-1=SET_MAP_ENTRY c-r144d9c59f99-2-1, _collisions.r144d9c59efd-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56bb0-0-1=SET_MAP_ENTRY c-r144d9c59f99-1-1, _revisions.r144d9c59efd-0-1=SET_MAP_ENTRY c-r144d9c59f99-5-1, _collisions.r144d9c56bb0-0-1=CONTAINS_MAP_ENTRY false, _collisions.r144d9c56ca0-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56ba2-0-1=SET_MAP_ENTRY c-r144d9c59f99-0-1, _collisions.r144d9c56bb8-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56c9c-0-1=SET_MAP_ENTRY c-r144d9c59f99-3-1} (retries 4, 6333 ms)

Running org.apache.jackrabbit.oak.jcr.ConcurrentAddNodesClusterIT
Tests run: 4, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 33.062 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
addNodes2(org.apache.jackrabbit.oak.jcr.ConcurrentAddNodesClusterIT)  Time elapsed: 16.896 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!
javax.jcr.RepositoryException: OakMerge0002: OakMerge0002: Conflicting concurrent change. Update operation failed: key: 0:/ update {_revisions.r144d9c56ca0-0-1=SET_MAP_ENTRY c-r144d9c59f99-4-1, _modified=SET 279044602, _collisions.r144d9c56ba2-0-1=CONTAINS_MAP_ENTRY false, _collisions.r144d9c56c9c-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56bb8-0-1=SET_MAP_ENTRY c-r144d9c59f99-2-1, _collisions.r144d9c59efd-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56bb0-0-1=SET_MAP_ENTRY c-r144d9c59f99-1-1, _revisions.r144d9c59efd-0-1=SET_MAP_ENTRY c-r144d9c59f99-5-1, _collisions.r144d9c56bb0-0-1=CONTAINS_MAP_ENTRY false, _collisions.r144d9c56ca0-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56ba2-0-1=SET_MAP_ENTRY c-r144d9c59f99-0-1, _collisions.r144d9c56bb8-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56c9c-0-1=SET_MAP_ENTRY c-r144d9c59f99-3-1} (retries 4, 6333 ms)
	at org.apache.jackrabbit.oak.api.CommitFailedException.asRepositoryException(CommitFailedException.java:247)
	at org.apache.jackrabbit.oak.api.CommitFailedException.asRepositoryException(CommitFailedException.java:212)
	at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.newRepositoryException(SessionDelegate.java:617)
	at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.save(SessionDelegate.java:502)
	at org.apache.jackrabbit.oak.jcr.session.SessionImpl$8.perform(SessionImpl.java:414)
	at org.apache.jackrabbit.oak.jcr.session.SessionImpl$8.perform(SessionImpl.java:411)
	at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.perform(SessionDelegate.java:263)
	at org.apache.jackrabbit.oak.jcr.session.SessionImpl.perform(SessionImpl.java:124)
	at org.apache.jackrabbit.oak.jcr.session.SessionImpl.save(SessionImpl.java:411)
	at org.apache.jackrabbit.oak.jcr.ConcurrentAddNodesClusterIT.addNodes2(ConcurrentAddNodesClusterIT.java:213)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)
Caused by: org.apache.jackrabbit.oak.api.CommitFailedException: OakMerge0002: OakMerge0002: Conflicting concurrent change. Update operation failed: key: 0:/ update {_revisions.r144d9c56ca0-0-1=SET_MAP_ENTRY c-r144d9c59f99-4-1, _modified=SET 279044602, _collisions.r144d9c56ba2-0-1=CONTAINS_MAP_ENTRY false, _collisions.r144d9c56c9c-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56bb8-0-1=SET_MAP_ENTRY c-r144d9c59f99-2-1, _collisions.r144d9c59efd-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56bb0-0-1=SET_MAP_ENTRY c-r144d9c59f99-1-1, _revisions.r144d9c59efd-0-1=SET_MAP_ENTRY c-r144d9c59f99-5-1, _collisions.r144d9c56bb0-0-1=CONTAINS_MAP_ENTRY false, _collisions.r144d9c56ca0-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56ba2-0-1=SET_MAP_ENTRY c-r144d9c59f99-0-1, _collisions.r144d9c56bb8-0-1=CONTAINS_MAP_ENTRY false, _revisions.r144d9c56c9c-0-1=SET_MAP_ENTRY c-r144d9c59f99-3-1} (retries 4, 6333 ms)
	at org.apache.jackrabbit.oak.spi.state.AbstractNodeStoreBranch.merge(AbstractNodeStoreBranch.java:304)
	at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.merge(DocumentNodeStoreBranch.java:143)
	at org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.merge(DocumentRootBuilder.java:147)
	at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.merge(DocumentNodeStore.java:1212)
	at org.apache.jackrabbit.oak.core.MutableRoot.commit(MutableRoot.java:242)
	at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.commit(SessionDelegate.java:357)
	at org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate.save(SessionDelegate.java:500)
	... 38 more


&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13940355" author="tmueller" created="Wed, 19 Mar 2014 10:03:12 +0000"  >&lt;p&gt;Revision 1579182&lt;/p&gt;</comment>
                            <comment id="13940492" author="tmueller" created="Wed, 19 Mar 2014 14:14:32 +0000"  >&lt;p&gt;Cache invalidation is still broken &lt;/p&gt;</comment>
                            <comment id="13940505" author="tmueller" created="Wed, 19 Mar 2014 14:30:48 +0000"  >&lt;p&gt;I think all negative cache entries with a long path need to be invalidated. That should be relatively simple to implement.&lt;/p&gt;

&lt;p&gt;Unit test:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Index: src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java
===================================================================
--- src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java	(revision 1579222)
+++ src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java	(working copy)
@@ -41,6 +41,8 @@
 
 import static org.apache.jackrabbit.oak.plugins.document.mongo.CacheInvalidator.InvalidationResult;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public class CacheInvalidationIT extends AbstractMongoConnectionTest {
 
@@ -135,6 +137,43 @@
     }
 
     @Test
+    public void testCacheInvalidationHierarchicalNotExist()
+            throws CommitFailedException {
+
+        NodeBuilder b2 = getRoot(c2).builder();
+        // we create x/other, so that x is known to have a child node
+        b2.child(&quot;x&quot;).child(&quot;other&quot;);
+        b2.child(&quot;y&quot;);
+        c2.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        c2.runBackgroundOperations();
+        c1.runBackgroundOperations();
+
+        // we check for the existence of &quot;x/futureX&quot;, which
+        // should create a negative entry in the cache
+        NodeState x = getRoot(c1).getChildNode(&quot;x&quot;);
+        assertTrue(x.exists());
+        assertFalse(x.getChildNode(&quot;futureX&quot;).exists());
+        // we don&apos;t check for the existence of &quot;y/futureY&quot;
+        NodeState y = getRoot(c1).getChildNode(&quot;y&quot;);
+        assertTrue(y.exists());
+
+        // now we add both &quot;futureX&quot; and &quot;futureY&quot;
+        // in the other cluster node
+        b2.child(&quot;x&quot;).child(&quot;futureX&quot;).setProperty(&quot;z&quot;, &quot;1&quot;);
+        c2.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        b2.child(&quot;y&quot;).child(&quot;futureY&quot;).setProperty(&quot;z&quot;, &quot;2&quot;);
+        c2.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        
+        c2.runBackgroundOperations();
+        c1.runBackgroundOperations();
+
+        // both nodes should now be visible
+        assertTrue(getRoot(c1).getChildNode(&quot;y&quot;).getChildNode(&quot;futureY&quot;).exists());
+        assertTrue(getRoot(c1).getChildNode(&quot;x&quot;).getChildNode(&quot;futureX&quot;).exists());
+
+    }
+
+    @Test
     public void testCacheInvalidationLinear() throws CommitFailedException {
         final int totalPaths = createScenario();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13940524" author="tmueller" created="Wed, 19 Mar 2014 14:46:07 +0000"  >&lt;p&gt;Proposed patch (excluding the test above):&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;Index: src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java
===================================================================
--- src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java	(revision 1579182)
+++ src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java	(working copy)
@@ -279,13 +279,24 @@
                 //key is referring to a split document
                 result.cacheSize++;
                 CachedNodeDocument doc = e.getValue();
+                String path;
                 if (doc == NodeDocument.NULL) {
-                     // we only need to process documents that exist
-                    continue;
+                    String id = e.getKey().toString();
+                    if (Utils.isIdFromLongPath(id)) {
+                        LOG.debug(&quot;Negative cache entry with long path {}. Invalidating&quot;, id);
+                        documentStore.invalidateCache(Collection.NODES, id);
+                        path = null;
+                    } else {
+                        path = Utils.getPathFromId(id);
+                    }
+                } else {
+                    path = doc.getPath();
                 }
-                String path = doc.getPath();
-                for (String name : PathUtils.elements(path)) {
-                    current = current.child(name);
+                if (path != null) {
+                    for (String name : PathUtils.elements(path)) {
+                        current = current.child(name);
+                    }
                 }
             }
             return root;
Index: src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
===================================================================
--- src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java	(revision 1579181)
+++ src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java	(working copy)
@@ -260,12 +260,17 @@
         }
         return true;
     }
+    
+    public static boolean isIdFromLongPath(String id) {
+        int index = id.indexOf(&apos;:&apos;);
+        return id.charAt(index + 1) == &apos;h&apos;;
+    }
 
     public static String getPathFromId(String id) {
-        int index = id.indexOf(&apos;:&apos;);
-        if (id.charAt(index + 1) == &apos;h&apos;) {
+        if (isIdFromLongPath(id)) {
             throw new IllegalArgumentException(&quot;Id is hashed: &quot; + id);
         }
+        int index = id.indexOf(&apos;:&apos;);
         return id.substring(index + 1);
     }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13940541" author="chetanm" created="Wed, 19 Mar 2014 14:59:30 +0000"  >&lt;p&gt;+1 Patch look fine &lt;/p&gt;</comment>
                            <comment id="13940542" author="tmueller" created="Wed, 19 Mar 2014 15:00:43 +0000"  >&lt;p&gt;Revision 1579250&lt;/p&gt;</comment>
                            <comment id="13941739" author="reschke" created="Thu, 20 Mar 2014 13:52:51 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt; can we make the required length for IDs part of the API contract (in the RDBDocumentStore, it would be good to know what to limit the ID column to)&lt;/p&gt;</comment>
                            <comment id="13945072" author="alex.parvulescu" created="Mon, 24 Mar 2014 13:36:41 +0000"  >&lt;p&gt;Bulk close for the 0.19 release.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12703185">OAK-1602</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12782569">OAK-2644</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12703948">OAK-1629</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12702863">OAK-1589</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12782256">OAK-2636</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12631515" name="NodeNameLimitsTest.java" size="1794" author="reschke" created="Thu, 27 Feb 2014 12:26:26 +0000"/>
                            <attachment id="12546276" name="OAK-333.patch" size="29422" author="meteatamel" created="Mon, 24 Sep 2012 09:47:55 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>256732</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 34 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0iqqf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>107425</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>