<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:37:26 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-781] Clarify / fix effects of MISSING_NODE as base state of NodeBuilder</title>
                <link>https://issues.apache.org/jira/browse/OAK-781</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;Having a &lt;tt&gt;MISSING_NODE&lt;/tt&gt; respectively a node state that returns false for its &lt;tt&gt;exists&lt;/tt&gt; method as a base state of a node builder results in undefined behaviour. We need to clarify how to handle such cases for resolving &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-766&quot; title=&quot;TreeImpl#*Location: unable retrieve child location if access to parent is denied&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-766&quot;&gt;&lt;del&gt;OAK-766&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12642905">OAK-781</key>
            <summary>Clarify / fix effects of MISSING_NODE as base state of NodeBuilder</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mduerig">Michael D&#252;rig</assignee>
                                    <reporter username="mduerig">Michael D&#252;rig</reporter>
                        <labels>
                    </labels>
                <created>Wed, 17 Apr 2013 11:48:20 +0000</created>
                <updated>Fri, 13 Dec 2013 09:01:13 +0000</updated>
                            <resolved>Wed, 27 Nov 2013 08:28:30 +0000</resolved>
                                                    <fixVersion>0.13</fixVersion>
                                    <component>core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13633973" author="mduerig" created="Wed, 17 Apr 2013 12:14:54 +0000"  >&lt;p&gt;In revision 1468861 I committed a test case demonstrating a failing assertion when accessing the builder for a node when a intermediate node in the hierarchy does not exist. &lt;/p&gt;</comment>
                            <comment id="13633979" author="mduerig" created="Wed, 17 Apr 2013 12:25:28 +0000"  >&lt;p&gt;The failing assertion is&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.lang.AssertionError
	at org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilder.write(MemoryNodeBuilder.java:259)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and AFAIU does not hold any more since we introduced the additional semantics of non existing node states. &lt;/p&gt;</comment>
                            <comment id="13633990" author="mduerig" created="Wed, 17 Apr 2013 12:43:48 +0000"  >&lt;p&gt;I removed the offending assertion at revision 1468873.&lt;/p&gt;</comment>
                            <comment id="13634007" author="mduerig" created="Wed, 17 Apr 2013 13:12:28 +0000"  >&lt;p&gt;At revision 1468890 I added another test case that demonstrates the main issue here: Modifying node &lt;tt&gt;c&lt;/tt&gt; in a hierarchy &lt;tt&gt;/a/b/c&lt;/tt&gt; with &lt;tt&gt;b.exists() == false&lt;/tt&gt; results in the original node &lt;tt&gt;c&lt;/tt&gt; being overlaid by a new node &lt;tt&gt;c&lt;/tt&gt;. That new node is missing all the original items that where present on the original version of &lt;tt&gt;c&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13635111" author="mduerig" created="Thu, 18 Apr 2013 12:02:05 +0000"  >&lt;p&gt;Turns out that above behaviour was caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-782&quot; title=&quot;MemoryNodeBuilder.setNode() loses property values &quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-782&quot;&gt;&lt;del&gt;OAK-782&lt;/del&gt;&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;A remaining point for clarifying is whether in the above case, after &lt;tt&gt;c&lt;/tt&gt; has been modifies, node &lt;tt&gt;b&lt;/tt&gt; should return &lt;tt&gt;true&lt;/tt&gt; or &lt;tt&gt;false&lt;/tt&gt; for &lt;tt&gt;exists&lt;/tt&gt;. Currently it returns &lt;tt&gt;true&lt;/tt&gt;. &lt;/p&gt;</comment>
                            <comment id="13635128" author="jukkaz" created="Thu, 18 Apr 2013 12:50:38 +0000"  >&lt;p&gt;I think a crucial bit here is the behavior of the &lt;tt&gt;child(String)&lt;/tt&gt; method. It&apos;s defined to automatically create a new child node if the named child does not already exist, which is a bit troublesome when you mix read permissions in the picture. Instead we might want to explicitly split the method to separate &lt;tt&gt;getChild(String)&lt;/tt&gt; and &lt;tt&gt;addChild(String)&lt;/tt&gt; methods that make the intention of higher-level operations clear. For example, if the test case used &lt;tt&gt;getChild(&quot;b&quot;)&lt;/tt&gt; then the &lt;tt&gt;b.exists()&lt;/tt&gt; call should return &lt;tt&gt;false&lt;/tt&gt;, and if &lt;tt&gt;addChild(&quot;b&quot;)&lt;/tt&gt; it should return &lt;tt&gt;true&lt;/tt&gt;. Also, if &lt;tt&gt;addChild(&quot;b&quot;)&lt;/tt&gt; was called, then the later &lt;tt&gt;c.hasProperty(&quot;c&quot;)&lt;/tt&gt; should return &lt;tt&gt;false&lt;/tt&gt; as the newly added &quot;b&quot; node should shadow the previous, partially read-protected subtree.&lt;/p&gt;</comment>
                            <comment id="13635144" author="mduerig" created="Thu, 18 Apr 2013 13:17:14 +0000"  >&lt;p&gt;Sounds good. In this case it might also make sense to add an &lt;tt&gt;exists()&lt;/tt&gt; methods to &lt;tt&gt;NodeBuilder&lt;/tt&gt;. &lt;/p&gt;

&lt;p&gt;&lt;tt&gt;child&lt;/tt&gt; will then have the semantics of &lt;tt&gt;exists(name) ? getNode(name) : addNode(name)&lt;/tt&gt;. &lt;/p&gt;</comment>
                            <comment id="13635147" author="jukkaz" created="Thu, 18 Apr 2013 13:19:29 +0000"  >&lt;p&gt;The attached patch contains a quick draft of the proposed new methods: &lt;tt&gt;exists()&lt;/tt&gt;, &lt;tt&gt;getChild(String)&lt;/tt&gt; and &lt;tt&gt;addChild(String)&lt;/tt&gt;. Note that the &lt;tt&gt;addChild&lt;/tt&gt; method, as drafted, is actually equivalent to &lt;tt&gt;setNode(name, EMPTY_NODE)&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The implementation in &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; will probably need some more thought, and we&apos;d need to update at least &lt;tt&gt;TreeImpl&lt;/tt&gt; and a few other cases to use the new methods instead of always calling &lt;tt&gt;child(String)&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13635155" author="mduerig" created="Thu, 18 Apr 2013 13:31:21 +0000"  >&lt;p&gt;Draft looks good API wise. The &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; implementation is broken though. Lets approach this incrementally and apply the API part and use &lt;tt&gt;TODO&lt;/tt&gt; in the implementations. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;update at least TreeImpl&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, this is &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-766&quot; title=&quot;TreeImpl#*Location: unable retrieve child location if access to parent is denied&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-766&quot;&gt;&lt;del&gt;OAK-766&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13635228" author="jukkaz" created="Thu, 18 Apr 2013 15:05:06 +0000"  >&lt;p&gt;Committed the API bits plus dummy implementations in revision 1469360.&lt;/p&gt;</comment>
                            <comment id="13636501" author="mduerig" created="Fri, 19 Apr 2013 15:44:19 +0000"  >&lt;p&gt;Attached patch implements the behaviour defined herein and passed all tests.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;MutableNodeState&lt;/tt&gt; and &lt;tt&gt;ModifiedNodeState&lt;/tt&gt; contain a flag indicating whether the state exists or not. This flag is cleared by the node builder when the base state does not exist and set otherwise. Apart from that these two node state implementations do not yet correctly implement the &lt;tt&gt;NodeState&lt;/tt&gt; contract wrt. existence and iterability. &lt;/p&gt;</comment>
                            <comment id="13636519" author="mduerig" created="Fri, 19 Apr 2013 15:59:22 +0000"  >&lt;p&gt;Stepping a bit back, I&apos;m not convinced whether the patch takes the correct implementation approach. &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; is a complex beast with a lot of dark secrets. Looping non existent nodes through it increases complexity even further. While my patch passes all tests, I can&apos;t confidently say that it is correct. Neither am I confident that we can maintain and extend this further down the line. Maybe we should take a more rigorous approach here and reimplement or refactor &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; from the ground up?&lt;/p&gt;</comment>
                            <comment id="13637810" author="jukkaz" created="Mon, 22 Apr 2013 07:35:32 +0000"  >&lt;p&gt;You&apos;re probably right about the need for an overhaul of the MemoryNodeBuilder implementation, as it has evolved quite a bit from the original design. Since this is a pretty central piece of functionality, it might be a good idea to start such an effort by better documenting the intended design and increasing test coverage. I&apos;ll start with a few design notes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Attached patch implements the behaviour defined herein and passed all tests.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Looks like a step in the right direction, though as you say, we&apos;ll probably need some more work here. Some comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;I&apos;m not sure about the explicit &lt;tt&gt;exists&lt;/tt&gt; flag. It would seem like a better idea to use the &lt;tt&gt;exists()&lt;/tt&gt; status of the underlying base &lt;tt&gt;NodeState&lt;/tt&gt;, as AFAICT that should already cover everything we need. I.e. &lt;tt&gt;MemoryNodeBuilder.exists()&lt;/tt&gt; would be implemented as &lt;tt&gt;return read().exists()&lt;/tt&gt;, returning the existence of either the read or write base state, depending on the state of the builder.&lt;/li&gt;
	&lt;li&gt;Re: iterability vs. existence; We need to clarify the bit in the &lt;tt&gt;NodeState&lt;/tt&gt; contract that says that &lt;tt&gt;!exists()&lt;/tt&gt; implies &lt;tt&gt;!getChildNodeEntries().iterator().hasNext()&lt;/tt&gt; (and similarly for &lt;tt&gt;getProperties()&lt;/tt&gt;). That seems like the natural thing to do, but there might be some backwards compatibility issues we need to consider. I&apos;ll start a thread on oak-dev@ about that.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13638030" author="jukkaz" created="Mon, 22 Apr 2013 14:23:54 +0000"  >&lt;p&gt;I started by updating and clarifying the client-level documentation in &lt;a href=&quot;https://github.com/apache/jackrabbit-oak/blob/trunk/doc/nodestate.md&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/jackrabbit-oak/blob/trunk/doc/nodestate.md&lt;/a&gt;. See especially the notes about &lt;tt&gt;exists()&lt;/tt&gt; in both NodeState and NodeBuilder.&lt;/p&gt;

&lt;p&gt;While updating the documentation, it occurred to me that renaming &lt;tt&gt;getChild&lt;/tt&gt; and &lt;tt&gt;addChild&lt;/tt&gt; to &lt;tt&gt;getNode&lt;/tt&gt; and &lt;tt&gt;addNode&lt;/tt&gt; respectively might be a good idea, as that would make them match the naming of the existing &lt;tt&gt;setNode&lt;/tt&gt; and &lt;tt&gt;removeNode&lt;/tt&gt; methods.&lt;/p&gt;

&lt;p&gt;Thinking more generally about the MemoryNodeBuilder, here are some key goals on which much of the implementation design is (or should be) based on:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Efficient read-only access. Since we are using NodeBuilders in TreeImpl for both read-only and read-write cases (doing otherwise would be pretty complicated), the implementation needs to add as little overhead as possible when accessing content from the underlying base state when no changes have been made.&lt;/li&gt;
	&lt;li&gt;No unnecessary memory overhead. The required memory or disk space should grow at most linearly with the amount of modified content. Most notably traversing through a content hierarchy while making no changes &lt;b&gt;must not&lt;/b&gt; result in hard references to all visited nodes. Also weak references should be avoided.&lt;/li&gt;
	&lt;li&gt;Extensibility. It should be easy to extend the MemoryNodeBuilder class with custom mechanism especially for purging pending changes to the underlying storage, as different backends like KernelNodeStore and SegmentNodeStore may want to use different algorithms for that. For example the SegmentNodeStore could more easily purge partial subtrees even while other parts of the tree are still being modified.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I&apos;ll follow up with some more detailed design notes later.&lt;/p&gt;</comment>
                            <comment id="13638901" author="mduerig" created="Tue, 23 Apr 2013 09:16:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;It would seem like a better idea to use the exists() status of the underlying base NodeState&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Right, hat should do.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;it occurred to me that renaming getChild and addChild...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Agreed. IMO we should even rename the rename &lt;tt&gt;addChild(String)&lt;/tt&gt; to &lt;tt&gt;setNode(String)&lt;/tt&gt; since it has the semantics of &lt;tt&gt;setNode(&quot;foo&quot;, EMPTY_NODE)&lt;/tt&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Thinking more generally about the MemoryNodeBuilder...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think the current design makes sense in general and fulfils the first two bullet points above. What we need to do IMO is &lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;update the Javadoc the current design,&lt;/li&gt;
	&lt;li&gt;don&apos;t access &lt;tt&gt;MutableNodeState&lt;/tt&gt;&apos;s state directly but use accessors whose name capture the intended semantics,&lt;/li&gt;
	&lt;li&gt;differentiate between &lt;tt&gt;read() / write()&lt;/tt&gt; and a new set of methods (e.g. &lt;tt&gt;base() / head()&lt;/tt&gt;. The former pair would update a builder&apos;s state for read / write access while the latter pair would update a builder&apos;s base / head state. Currently this functionality is intertwined in &lt;tt&gt;read() / write()&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Regarding moving the purge logic below the &lt;tt&gt;NodeBuilder&lt;/tt&gt; there is &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-659&quot; title=&quot;Move purge logic for transient changes below the NodeBuilder interface&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-659&quot;&gt;&lt;del&gt;OAK-659&lt;/del&gt;&lt;/a&gt;. As stated in the cited &lt;a href=&quot;http://markmail.org/message/lbc3rx2p3sssvqj5&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;discussion &lt;/a&gt;, the transient move operations are troublesome. Maybe we could use an approach as suggested in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-783&quot; title=&quot;Reflect Move and Rename upon Root#commit&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-783&quot;&gt;&lt;del&gt;OAK-783&lt;/del&gt;&lt;/a&gt; and annotate moved nodes with a reference to their source in their original revision? I think this should give us enough information to come up with workable solutions later on. &lt;/p&gt;</comment>
                            <comment id="13638953" author="jukkaz" created="Tue, 23 Apr 2013 10:59:51 +0000"  >&lt;p&gt;As additional &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; documentation I attached a class diagram that outlines key parts of the design.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;IMO we should even rename the rename addChild(String) to setNode(String) since it has the semantics of setNode(&quot;foo&quot;, EMPTY_NODE).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed; or just drop the separate method signature in favor of &lt;tt&gt;setNode(&quot;foo&quot;, EMPTY_NODE)&lt;/tt&gt;.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;What we need to do IMO is&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;update the Javadoc the current design&lt;/p&gt;

&lt;p&gt;My take here was to start form a bit higher level before going directly to Javadoc, as earlier on I spent some hours of effort on MemoryNodeBuilder javadocs that nowadays are already out of date.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;don&apos;t access MutableNodeState&apos;s state directly but use accessors whose name capture the intended semantics&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1 We should also move MutableNodeState to a separate, package-private class instead of keeping it internal to MemoryNodeBuilder. It originally started as an internal class to keep it tightly hidden as a MemoryNodeBuilder implementation detail, but it&apos;s getting complex enough to warrant it&apos;s own source file and separate unit tests.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;purge logic&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;OK, let&apos;s follow up in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-659&quot; title=&quot;Move purge logic for transient changes below the NodeBuilder interface&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-659&quot;&gt;&lt;del&gt;OAK-659&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;
</comment>
                            <comment id="13640323" author="mduerig" created="Wed, 24 Apr 2013 10:39:39 +0000"  >&lt;p&gt;At revision 1471355 I committed a reworked version of the &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; that addresses above points:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;MutableNodeState&lt;/tt&gt; is now a package private top level class. Its intend is to capture the state of mutations to existing nodes.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; in contrast maintains the hierarchy information and refers to &lt;tt&gt;MutableNodeState&lt;/tt&gt; instances as necessary.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Still to be done:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;-&lt;del&gt;Javadoc&lt;/del&gt;- Done at revision 1471389&lt;/li&gt;
	&lt;li&gt;There seems to be some drop in performance when going full stack. Needs investigation.&lt;/li&gt;
	&lt;li&gt;-&lt;del&gt;&lt;tt&gt;MutableNodeState#setChildNode.setChildNode()&lt;/tt&gt; needs a better implementation. See FIXME&lt;/del&gt;- Done at revision 1471494&lt;/li&gt;
	&lt;li&gt;-&lt;del&gt;&lt;tt&gt;ModifiedNodeState&lt;/tt&gt; does not yet adhere to the &lt;tt&gt;NodeState&lt;/tt&gt; contract wrt. to existence and iterability. See FIXME.&lt;/del&gt;- Done at revision 1471465&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13641892" author="mduerig" created="Thu, 25 Apr 2013 15:31:04 +0000"  >&lt;p&gt;Revision 1475796 replaces &lt;tt&gt;isConnected&lt;/tt&gt; with &lt;tt&gt;exists&lt;/tt&gt;. This is used for a tentative fix of &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-766&quot; title=&quot;TreeImpl#*Location: unable retrieve child location if access to parent is denied&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-766&quot;&gt;&lt;del&gt;OAK-766&lt;/del&gt;&lt;/a&gt; at revision 1475819, which was the cause for this issue in the first place. &lt;/p&gt;

&lt;p&gt;Overall this concludes the main work here. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jukkaz&quot; class=&quot;user-hover&quot; rel=&quot;jukkaz&quot;&gt;jukkaz&lt;/a&gt; please review &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13645460" author="jukkaz" created="Tue, 30 Apr 2013 10:57:05 +0000"  >&lt;p&gt;Looks pretty good. The only bigger comment I have is about the way &lt;tt&gt;MutableNodeState&lt;/tt&gt; instances are created and used. The way I see it, there should only ever be at most one &lt;tt&gt;MutableNodeState&lt;/tt&gt; instance per path within the scope of a single root builder; that instance would contain the modified state of that node and be referenced by all up-to-date builder instances associated with that path (within the scope of that root builder).&lt;/p&gt;</comment>
                            <comment id="13645614" author="jukkaz" created="Tue, 30 Apr 2013 14:22:04 +0000"  >&lt;p&gt;As a side issue, I&apos;m looking at how to streamline the use of the modified properties and nodes maps in the &lt;tt&gt;ModifiedNodeState&lt;/tt&gt; and &lt;tt&gt;MutableNodeState&lt;/tt&gt; classes. Especially I&apos;d like to replace the current &lt;tt&gt;null&lt;/tt&gt; entries in the nodes map with non-existent &lt;tt&gt;NodeState&lt;/tt&gt; instances to simplify the handling of cases like modifications to a readable child of a non-readable parent.&lt;/p&gt;</comment>
                            <comment id="13645658" author="mduerig" created="Tue, 30 Apr 2013 15:19:27 +0000"  >&lt;blockquote&gt;&lt;p&gt;The only bigger comment I have is about the way MutableNodeState instances are created and used.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As discussed off line, this is a slight mismatch in the concept of how &lt;tt&gt;MutableNodeState&lt;/tt&gt; instances are used: &lt;tt&gt;MutableNodeState.getChildNode(String name, boolean connect)&lt;/tt&gt; returns &quot;non connected&quot; instances in the case where &lt;tt&gt;connect&lt;/tt&gt; is false and a child &lt;tt&gt;name&lt;/tt&gt; has not been modified before. This is in contrast to the initial idea where there should only ever be at most one &lt;tt&gt;MutableNodeState&lt;/tt&gt; instance per path within the scope of a single root builder.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jukkaz&quot; class=&quot;user-hover&quot; rel=&quot;jukkaz&quot;&gt;jukkaz&lt;/a&gt; came up with the idea of letting the head state be a generic NodeState that gets updated whenever headRevision grows, until content is changes in thus builder (or one of its descendants) in which case the head state becomes a &lt;tt&gt;MutableNodeState&lt;/tt&gt; and will remain so from that point on.&lt;/p&gt;

&lt;p&gt;I quickly tried to come up with a patch for this but soon realised that this in a way puts us back into a pre &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-781&quot; title=&quot;Clarify / fix effects of MISSING_NODE as base state of NodeBuilder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-781&quot;&gt;&lt;del&gt;OAK-781&lt;/del&gt;&lt;/a&gt; situation where a lot of tricky state tracking was done in &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt;. From this POV I prefer the current solution where we have a &quot;dirty secret&quot; in one place, which we could clearly mark and document.&lt;/p&gt;</comment>
                            <comment id="13646544" author="jukkaz" created="Wed, 1 May 2013 12:49:25 +0000"  >&lt;p&gt;See &lt;a href=&quot;https://github.com/jukka/jackrabbit-oak/commit/ebf0aa60c76b1c4574b536bcfb27b233f957fba8&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jukka/jackrabbit-oak/commit/ebf0aa60c76b1c4574b536bcfb27b233f957fba8&lt;/a&gt; for an initial draft of what I had in mind. It seems to work reasonably well except for bringing back the LargeMoveIT performance issue. More work still needed.&lt;/p&gt;

&lt;p&gt;Also note that I encountered some weird behavior when I tried to adjust the way the isModified() method works. For now in the patch it&apos;s unmodified except for a few FIXMEs that I added to point out that we probably need to revisit the implementation and its intended semantics. Perhaps best to do that in a followup issue.&lt;/p&gt;</comment>
                            <comment id="13646567" author="mduerig" created="Wed, 1 May 2013 13:28:33 +0000"  >&lt;p&gt;As discussed off line I&apos;d prefer a solution where the state tracking is more explicit. The magic constant -1 obfuscates the intended semantics which in the end leads to faster deterioration of the code.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;some weird behavior when I tried to adjust the way the isModified() method works&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good catch! The semantics of that method is determined by &lt;tt&gt;Node.isModified&lt;/tt&gt;. That is, it should not take the state of child nodes into account. Probably the easiest solution here is to use &lt;tt&gt;NodeStateDiff&lt;/tt&gt; and ignore &lt;tt&gt;childNodeChanged&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13646640" author="jukkaz" created="Wed, 1 May 2013 15:22:33 +0000"  >&lt;p&gt;Updated patch in &lt;a href=&quot;https://github.com/jukka/jackrabbit-oak/commit/55afcf2fe2d5b9f1c07e3ee80d4d3612f31eef41&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jukka/jackrabbit-oak/commit/55afcf2fe2d5b9f1c07e3ee80d4d3612f31eef41&lt;/a&gt;. It replaces the &lt;tt&gt;headRevision == -1&lt;/tt&gt; check by splitting the &lt;tt&gt;head&lt;/tt&gt; variable into separate &lt;tt&gt;readHead&lt;/tt&gt; and &lt;tt&gt;writeHead&lt;/tt&gt; variables, the latter of which is of type &lt;tt&gt;MutableNodeState&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Still, the state tracking conditionals remain somewhat scattered around the &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; class. Stepping back a bit it occurs to me that we&apos;re really trying to fit together three somewhat separate concerns here:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Implementing the &lt;tt&gt;NodeBuilder&lt;/tt&gt; interface&lt;/li&gt;
	&lt;li&gt;Keeping track of the connectedness state of the builder&lt;/li&gt;
	&lt;li&gt;Managing the shared state of all modified content&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Originally the middle concern was a part of &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; and now it&apos;s mostly done in &lt;tt&gt;MutableNodeState&lt;/tt&gt;, especially with the &lt;tt&gt;connect&lt;/tt&gt; argument to &lt;tt&gt;getChildNode()&lt;/tt&gt;. My patch is trying to push that concern back to &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; in an attempt to keep the role of &lt;tt&gt;MutableNodeState&lt;/tt&gt; cleaner.&lt;/p&gt;

&lt;p&gt;With that in mind, it occurs me that what we&apos;d really need here is a separate abstraction for explicitly tracking the connectedness state of a builder. We could for example use the state pattern to represent the distinct connected and unconnected states of a &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; instance. The &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; class would remain responsible for tracking the base but would delegate tracking of the head to the connectedness state, implemented as (nested) classes like &lt;tt&gt;UnconnectedHead&lt;/tt&gt; and &lt;tt&gt;ConnectedHead&lt;/tt&gt; that would implement a &lt;tt&gt;Head&lt;/tt&gt; state interface.&lt;/p&gt;

&lt;p&gt;The &lt;tt&gt;UnconnectedHead&lt;/tt&gt; state would encapsulate the current &lt;tt&gt;headRevision&lt;/tt&gt; logic and the mechanism for connecting a builder to a shared &lt;tt&gt;MutableNodeState&lt;/tt&gt; instance when needed. At that point the &lt;tt&gt;ConnectedHead&lt;/tt&gt; state would take over and transparently direct all further content accesses to that shared &lt;tt&gt;MutableNodeState&lt;/tt&gt; instance.&lt;/p&gt;

&lt;p&gt;As an additional benefit of such a structure, we could explicitly model a &lt;tt&gt;RootHead&lt;/tt&gt; state that&apos;s always connected and that could keep track of the &lt;tt&gt;headRevision&lt;/tt&gt; counter of the root builder. That way we wouldn&apos;t need to keep the revision counter around in connected builders where it&apos;s no longer needed.&lt;/p&gt;

&lt;p&gt;See the attached class diagram (memorynodebuilder-2.png) for an outline of how all these classes would fit together.&lt;/p&gt;</comment>
                            <comment id="13646666" author="mduerig" created="Wed, 1 May 2013 15:54:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;With that in mind, it occurs me that what we&apos;d really need here is a separate abstraction for explicitly tracking the connectedness state of a builder.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Good point! Since neither having this in &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; nor in &lt;tt&gt;MutableNodeState&lt;/tt&gt; is satisfactory this is a strong indication that we need a separate abstraction. I like the idea with the state pattern. I think this makes tracking the connectedness state as explicit as it should be.&lt;/p&gt;</comment>
                            <comment id="13651735" author="anchela" created="Wed, 8 May 2013 09:17:19 +0000"  >&lt;p&gt;according to jukka this is the reason for the failure of PermissionHookTest#testImplicitAceRemoval&lt;br/&gt;
with that information in mind i extended the various remove-permission tests in oak-jcr. most of them&lt;br/&gt;
were just testing if the permission was granted/denied without actually executing the removal.&lt;/p&gt;

&lt;p&gt;-&amp;gt; i will mark all of them with a reference to this issue.&lt;/p&gt;</comment>
                            <comment id="13665078" author="mduerig" created="Thu, 23 May 2013 11:28:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;i will mark all of them with a reference to this issue.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I fixed these at revision 1485648&lt;/p&gt;

&lt;p&gt;The problem was &lt;tt&gt;SecuredNodeRebaseDiff#deleteChangedNode&lt;/tt&gt; not correctly handling the case where a node is deleted that has invisible child nodes. Furthermore &lt;tt&gt;WriteTest#testRemove7&lt;/tt&gt; did a save call on the super user session instead of the test session. &lt;/p&gt;
</comment>
                            <comment id="13666747" author="mduerig" created="Fri, 24 May 2013 22:28:02 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-781&quot; title=&quot;Clarify / fix effects of MISSING_NODE as base state of NodeBuilder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-781&quot;&gt;&lt;del&gt;OAK-781&lt;/del&gt;&lt;/a&gt;-2.patch is an attempt in implementing &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-781?focusedCommentId=13646640&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13646640&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;Jukka&apos;s proposal &lt;/a&gt; of using a separate abstraction for tracking connectedness. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jukkaz&quot; class=&quot;user-hover&quot; rel=&quot;jukkaz&quot;&gt;jukkaz&lt;/a&gt; please have a look when you come around to it.&lt;/p&gt;</comment>
                            <comment id="13668311" author="jukkaz" created="Tue, 28 May 2013 13:55:33 +0000"  >&lt;p&gt;Looks good. Some comments:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;We could simplify the Head class by having MemoryNodeBuilder methods directly call the read() and write() methods on the current head.&lt;/li&gt;
	&lt;li&gt;The read(), write() and getNodeState() methods of Head might be better called getCurrentNodeState(), getMutableNodeState() and getImmutableNodeState(). The semantics would be that the &quot;current&quot; state is either mutable or immutable and can only be considered stable across one method call, just like the read() method now behaves.&lt;/li&gt;
	&lt;li&gt;We could avoid the instanceof check by pushing Head.getNodeState() (or getImmutableNodeState() as suggested above) down to the subclasses.&lt;/li&gt;
	&lt;li&gt;The ConnectedHead.read() method shouldn&apos;t have a need to check the base revision, as MutableNodeState.reset() on the root state will already take care of refreshing all connected states.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13668600" author="mduerig" created="Tue, 28 May 2013 19:54:10 +0000"  >&lt;p&gt;Thanks for the review. I applied the patch at revision 1487086 taking the first two bullet points into consideration. I will follow up re. the last two bullet points in separate comments. &lt;/p&gt;</comment>
                            <comment id="13668659" author="mduerig" created="Tue, 28 May 2013 20:51:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;We could avoid the instanceof check by...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This presumes that an unconnected &lt;tt&gt;Head&lt;/tt&gt; never has a &lt;tt&gt;MutableNodeState&lt;/tt&gt;, which is not true. Obtaining a &lt;tt&gt;MemoryNodeBuilder&lt;/tt&gt; from a &lt;tt&gt;ModifiedNodeState&lt;/tt&gt; results in such a situation by virtue of the unwrapping of the &lt;tt&gt;ModifiedNodeState&lt;/tt&gt; happening in the constructor of &lt;tt&gt;MutableNodeState&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13668668" author="mduerig" created="Tue, 28 May 2013 20:56:38 +0000"  >&lt;blockquote&gt;&lt;p&gt;The ConnectedHead.read() method shouldn&apos;t have a need to check the base revision...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which means resetting the &lt;tt&gt;MutableNodeState&lt;/tt&gt; in &lt;tt&gt;RootHead.reset()&lt;/tt&gt; instead of acquiring a new instance. The side effect of which is making the reset operation eager and bringing back the performance problem with &lt;tt&gt;LargeMoveIT&lt;/tt&gt;&lt;/p&gt;</comment>
                            <comment id="13668670" author="mduerig" created="Tue, 28 May 2013 20:58:23 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-781&quot; title=&quot;Clarify / fix effects of MISSING_NODE as base state of NodeBuilder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-781&quot;&gt;&lt;del&gt;OAK-781&lt;/del&gt;&lt;/a&gt;_reset.patch demonstrates the performance regression for &lt;tt&gt;LargeMoveTestIT&lt;/tt&gt;&lt;/p&gt;</comment>
                            <comment id="13669228" author="mduerig" created="Wed, 29 May 2013 13:22:56 +0000"  >&lt;p&gt;Revision 1487474 addresses the instanceof checking issue by making state transitions between the connectedness states more explicit: &lt;tt&gt;Head&lt;/tt&gt; now has a &lt;tt&gt;update()&lt;/tt&gt; method, which updates the &lt;tt&gt;head&lt;/tt&gt; field of the associated builder to point to the correct &lt;tt&gt;Head&lt;/tt&gt; instance. &lt;/p&gt;</comment>
                            <comment id="13669236" author="mduerig" created="Wed, 29 May 2013 13:30:39 +0000"  >&lt;p&gt;Updated &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-781&quot; title=&quot;Clarify / fix effects of MISSING_NODE as base state of NodeBuilder&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-781&quot;&gt;&lt;del&gt;OAK-781&lt;/del&gt;&lt;/a&gt;_reset.patch on top of the latest changes.&lt;/p&gt;</comment>
                            <comment id="13669308" author="mduerig" created="Wed, 29 May 2013 14:39:49 +0000"  >&lt;p&gt;In a quick chat Jukka and myself came to the conclusion that it might be best to not rely on &lt;tt&gt;MutableNodeState.reset()&lt;/tt&gt; for implementing &lt;tt&gt;NodeBuilder.reset()&lt;/tt&gt; but rather track this internally like it is currently done. Revision 1487502 improves this by reusing the logic from &lt;tt&gt;UnconnectedHead.update()&lt;/tt&gt; in &lt;tt&gt;ConnectedHead.update()&lt;/tt&gt; instead of duplicating it.&lt;/p&gt;</comment>
                            <comment id="13832847" author="jukkaz" created="Tue, 26 Nov 2013 18:32:52 +0000"  >&lt;p&gt;Is there still stuff to be done here? AFAICT this works pretty well now.&lt;/p&gt;</comment>
                            <comment id="13833578" author="mduerig" created="Wed, 27 Nov 2013 08:28:30 +0000"  >&lt;p&gt;Fixed by now. Let&apos;s follow up with specific issues as necessary. &lt;/p&gt;</comment>
                            <comment id="13847272" author="alex.parvulescu" created="Fri, 13 Dec 2013 09:01:13 +0000"  >&lt;p&gt;bulk close for the 0.13 release&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12641627">OAK-766</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12646589">OAK-813</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12579318" name="0001-OAK-781-Clarify-fix-effects-of-MISSING_NODE-as-base-.patch" size="5093" author="jukkaz" created="Thu, 18 Apr 2013 13:19:29 +0000"/>
                            <attachment id="12584768" name="OAK-781-2.patch" size="18459" author="mduerig" created="Fri, 24 May 2013 22:28:02 +0000"/>
                            <attachment id="12579557" name="OAK-781.patch" size="16583" author="mduerig" created="Fri, 19 Apr 2013 15:44:19 +0000"/>
                            <attachment id="12585205" name="OAK-781_reset.patch" size="1946" author="mduerig" created="Wed, 29 May 2013 13:30:39 +0000"/>
                            <attachment id="12580023" name="memorynodebuilder-1.png" size="14167" author="jukkaz" created="Tue, 23 Apr 2013 10:59:51 +0000"/>
                            <attachment id="12581363" name="memorynodebuilder-2.png" size="23129" author="jukkaz" created="Wed, 1 May 2013 15:22:33 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>323316</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 49 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1js6f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>323661</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>