<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:45:21 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-2020] NodeState view at given version is not stable with DocumentNodeStore</title>
                <link>https://issues.apache.org/jira/browse/OAK-2020</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;DocumentNodeStore should provide same NodeState for given (path, revision)  whenever a NodeState is obtained from it. This fails in some cases if the Node cache in DocumentNodeStore gets overflown and then the NodeState returned differs. This causes issues like&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Spurious Commits see - Some commit would fails with conflicts in paths which were not modified in that commit&lt;/li&gt;
	&lt;li&gt;Diff logic would traverse those paths which are not related to changes done in that commit&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;More details would be provided in comments below&lt;/p&gt;</description>
                <environment></environment>
        <key id="12732797">OAK-2020</key>
            <summary>NodeState view at given version is not stable with DocumentNodeStore</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mreutegg">Marcel Reutegger</assignee>
                                    <reporter username="chetanm">Chetan Mehrotra</reporter>
                        <labels>
                    </labels>
                <created>Fri, 8 Aug 2014 09:33:13 +0000</created>
                <updated>Wed, 1 Oct 2014 13:06:02 +0000</updated>
                            <resolved>Tue, 19 Aug 2014 12:27:15 +0000</resolved>
                                                    <fixVersion>1.0.5</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>mongomk</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="14090652" author="chetanm" created="Fri, 8 Aug 2014 11:21:04 +0000"  >&lt;p&gt;Added a testcase in &lt;a href=&quot;http://svn.apache.org/r1616719&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/r1616719&lt;/a&gt; to demonstrate the issue&lt;/p&gt;</comment>
                            <comment id="14090676" author="chetanm" created="Fri, 8 Aug 2014 12:00:14 +0000"  >&lt;p&gt;&lt;b&gt;Case 1 - Spurious Commits  causing Conflicts&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Following testcase demonstrates spurious commits.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void diffWithConflict() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception{
        &lt;span class=&quot;code-comment&quot;&gt;//Last rev on /&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; would be 1-0-1
&lt;/span&gt;        createNodes(&lt;span class=&quot;code-quote&quot;&gt;&quot;/&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;/a&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;/&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;/b/b1&quot;&lt;/span&gt;);

        &lt;span class=&quot;code-comment&quot;&gt;//1. Dummy commits to bump the version no
&lt;/span&gt;        createNodes(&lt;span class=&quot;code-quote&quot;&gt;&quot;/fake/b&quot;&lt;/span&gt;);
        createNodes(&lt;span class=&quot;code-quote&quot;&gt;&quot;/fake/c&quot;&lt;/span&gt;);

        &lt;span class=&quot;code-comment&quot;&gt;//Root rev = 3-0-1
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//Root rev = 3-0-1
&lt;/span&gt;
        &lt;span class=&quot;code-comment&quot;&gt;//2. Create a node under /&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;/a but hold on commit
&lt;/span&gt;        NodeBuilder b1 = ns.getRoot().builder();
        createNodes(b1, &lt;span class=&quot;code-quote&quot;&gt;&quot;/&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;/a/a1&quot;&lt;/span&gt;);

        &lt;span class=&quot;code-comment&quot;&gt;//3. Remove a node under /&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;/b and commit it
&lt;/span&gt;        NodeBuilder b2 = ns.getRoot().builder();
        b2.child(&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;&quot;&lt;/span&gt;).child(&lt;span class=&quot;code-quote&quot;&gt;&quot;b&quot;&lt;/span&gt;).child(&lt;span class=&quot;code-quote&quot;&gt;&quot;b1&quot;&lt;/span&gt;).remove();
        merge(b2);

        &lt;span class=&quot;code-comment&quot;&gt;//4. Now merge and commit the changes in b1 and include conflict hooks
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//For now exception would be thrown
&lt;/span&gt;        ns.merge(b1,
                &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CompositeHook(
                        &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ConflictHook(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; AnnotatingConflictHandler()),
                        &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; EditorHook(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ConflictValidatorProvider())
                ),
                CommitInfo.EMPTY);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Testcase performs following steps &lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;DocumentNodeStore is created with cache disabled and simple rev counter&lt;/li&gt;
	&lt;li&gt;Base node structure is create at Rev 1-0-1. Here lastRev of /var is 1-0-1
	&lt;ul&gt;
		&lt;li&gt;/var/a&lt;/li&gt;
		&lt;li&gt;/var/b/b1&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Some dummy commits are made to increase the rev to 3-0-1&lt;/li&gt;
	&lt;li&gt;Session 1  (B1) - Added a new node /var/a/a1. Change yet not merged&lt;/li&gt;
	&lt;li&gt;Session 2 (B2) - Removes node at /var/b/b1 and commits it. This sets the lastRev of /var to 4-0-1&lt;/li&gt;
	&lt;li&gt;Session 1 tries to commit but fails with conflict
&lt;blockquote&gt;&lt;p&gt;Commit failed due to unresolved conflicts in /var/b = {changeDeletedNode = {b1}}&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;org.apache.jackrabbit.oak.api.CommitFailedException: OakState0001: Unresolved conflicts in /var/b
	at org.apache.jackrabbit.oak.plugins.commit.ConflictValidator.failOnMergeConflict(ConflictValidator.java:84)
	at org.apache.jackrabbit.oak.plugins.commit.ConflictValidator.propertyAdded(ConflictValidator.java:54)
	at org.apache.jackrabbit.oak.spi.commit.EditorDiff.propertyAdded(EditorDiff.java:82)
	at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:374)
	at org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148)
	at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:395)
	at org.apache.jackrabbit.oak.spi.commit.EditorDiff.childNodeChanged(EditorDiff.java:148)
	at org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.compareAgainstBaseState(ModifiedNodeState.java:395)
	at org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52)
	at org.apache.jackrabbit.oak.spi.commit.EditorHook.processCommit(EditorHook.java:54)
	at org.apache.jackrabbit.oak.spi.commit.CompositeHook.processCommit(CompositeHook.java:60)
	at org.apache.jackrabbit.oak.spi.state.AbstractNodeStoreBranch$InMemory.merge(AbstractNodeStoreBranch.java:509)
	at org.apache.jackrabbit.oak.spi.state.AbstractNodeStoreBranch.merge(AbstractNodeStoreBranch.java:310)
	at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.merge(DocumentNodeStoreBranch.java:142)
	at org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.merge(DocumentRootBuilder.java:159)
	at org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.merge(DocumentNodeStore.java:1291)
	at org.apache.jackrabbit.oak.plugins.document.NodeStoreDiffTest.diffWithConflict(NodeStoreDiffTest.java:85)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Ideally this should not have failed as b1 was not removed in B1. Same testcase passes when cache is enabled. Now following flow happens when merge is performed on B1 then first a rebase is performed in AbstractNodeStoreBranch.InMemory#rebase.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@Override
void rebase() {
    N root = getRoot();
    NodeBuilder builder = root.builder();
    head.compareAgainstBaseState(base, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ConflictAnnotatingRebaseDiff(builder));
    head = builder.getNodeState();
    base = root;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;In that rebase ModifiedNodeState.compareAgainstBaseState is invoked which then compares the base states.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; compareAgainstBaseState(
        NodeState base, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; NodeStateDiff diff) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; == base) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// no differences
&lt;/span&gt;    }

    ...
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.base.compareAgainstBaseState(base, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NodeStateDiff() {
    ...
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;In ideal case &lt;tt&gt;this.base&lt;/tt&gt; and &lt;tt&gt;base&lt;/tt&gt; should be same for /var. But thats not the case&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;this.base - /var, lastRev 1-0-1&lt;/li&gt;
	&lt;li&gt;base - /var lastRev 3-0-1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As cache is disabled when DocumentNodeState fetches the /var with readRevision set to 3-0-1 (lastRev of root node when B1 was started) then calls is made to NodeDocument#getNodeAtRevision. Here the logic decides that at given readRevision (3-0-1) how does /var looks like. In doing so it has to set the lastRev of returned node. When {{base}}was created then lastRev of /var was 1-0-1 but the current value of lastRev at /var is 4-0-1. Then in NodeDocument logic the lastRev is determined which as per below flow is set to readRev i.e. 3-0-1. Due to this later when /var/b/b1 is read then there version are found to be different also (they are set to readRev) which triggers changeDeletedNode clause&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (Revision r : lastRevs.values()) {
            &lt;span class=&quot;code-comment&quot;&gt;// ignore &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; newer than readRevision
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isRevisionNewer(nodeStore, r, readRevision)) {
                &lt;span class=&quot;code-comment&quot;&gt;// the node has a _lastRev which is newer than readRevision
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; means we don&apos;t know when &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; node was
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// modified by an operation on a descendant node between
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// current lastRevision and readRevision. therefore we have
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// to stay on the safe side and use readRevision
&lt;/span&gt;                lastRevision = readRevision;
                &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
            } 
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Problem&lt;/b&gt;&lt;br/&gt;
As explained above due to way DocumentNodeStore work a node like /var read at same rev is fetched with different value which causes diff logic to fail. When cache is present and previously read DocumentNodeState is cached then same value is returned and hence diff logic works fine. The problem comes because we cannot accurately determine the NodeState at previous revision from persisted state i.e. as show above though the lastRev of /var should have been 1-0-1 but that data is lost and it changes to 3-0-1&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Solution&lt;/b&gt;&lt;br/&gt;
Need to work out. For now to reduce the problem from occurring we can increase the cache size for nodeCache such that correct data is present in cache. Howeever this would not work properly if such reading from old revision is performed on a different cluster node say with AsyncIndexUpdate and read there at previous version might miss out on some changes. Still need to confirm that part.&lt;/p&gt;</comment>
                            <comment id="14092529" author="tmueller" created="Mon, 11 Aug 2014 07:33:33 +0000"  >&lt;p&gt;&amp;gt; DocumentNodeStore should provide same NodeState for given (path, revision) &lt;br/&gt;
&amp;gt; whenever a NodeState is obtained from it.&lt;/p&gt;

&lt;p&gt;Does it need to be the same object, or would it be enough if it&apos;s a different object, but the same hash code, and NodeState.equals(..) would return true?&lt;/p&gt;</comment>
                            <comment id="14092533" author="chetanm" created="Mon, 11 Aug 2014 07:42:06 +0000"  >&lt;p&gt;&amp;gt;Does it need to be the same object, or would it be enough if it&apos;s a different object, but the same hash code, and NodeState.equals(..) would return true?&lt;/p&gt;

&lt;p&gt;Need not be same Java reference. Key thing required is that they should have same lastRevision as the DocumentNodeState equals relies on that and whats being observed here is that lastRevision changes when same Node at same version is fetched at later point in time&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; that) {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; == that) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (that &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; DocumentNodeState) {
            DocumentNodeState other = (DocumentNodeState) that;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (getPath().equals(other.getPath())) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; lastRevision.equals(other.lastRevision);
            }
        } ...
    }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14100506" author="mreutegg" created="Mon, 18 Aug 2014 10:02:25 +0000"  >&lt;p&gt;The DocumentNodeState.equals() method must be changed. The lastRevision is not an accurate indicator whether two nodes are equal. It can be use in compareAgainstBaseState() because NodeStateDiff.childNodeChanged() is fuzzy. The method is called when there &lt;b&gt;may&lt;/b&gt; be changes. This is what the DocumentNodeStore will do when it compares two nodes with different lastRevisions even though in reality the sub tree did not changes. The equals() method must be more strict. &lt;/p&gt;</comment>
                            <comment id="14100677" author="mreutegg" created="Mon, 18 Aug 2014 14:21:14 +0000"  >&lt;p&gt;In &lt;a href=&quot;http://svn.apache.org/r1618613&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/r1618613&lt;/a&gt; I fixed the equals() method and enabled the tests. Previously the method would return false when the lastRevisions of two states were different. Now it only returns true when the lastRevisions are equal (or the sub tree did not change between the two revisions). Please note that I also slightly changed the comparison of the lastRevision. The DocumentNodeState now first compares the (read) revision and then the lastRevision. DocumentNodeStates are considered equal if either of them is equal. As can be seen in the test, it may happen that a DocumentNodeState is read multiple times with the same read revision, but the lastRev may be different. This is as designed, when the some node below that node is modified and the current (most recent) lastRev becomes more recent than the read revision.&lt;/p&gt;

&lt;p&gt;With this change some invocations of DocumentNodeState.equals() may be more expensive than before. While the method previously just returned false pretty quickly when the lastRevision differed for two DocumentNodeState, the method will now traverse down the tree until it finds the node where the lastRevision is equal or less the read revision. In most cases this is quite isolated in the hierarchy, e.g. when there are concurrent changes and a rebase is needed. Comparing the benchmark numbers of write tests before and after the change did not show significant changes in timing.&lt;/p&gt;</comment>
                            <comment id="14102164" author="mreutegg" created="Tue, 19 Aug 2014 12:27:15 +0000"  >&lt;p&gt;Performed some further application level tests and did not see performance degradation with this fix. Resolving as fixed.&lt;/p&gt;</comment>
                            <comment id="14102219" author="mreutegg" created="Tue, 19 Aug 2014 14:01:31 +0000"  >&lt;p&gt;Merged fix into 1.0 branch in &lt;a href=&quot;http://svn.apache.org/r1618866&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://svn.apache.org/r1618866&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>410825</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 13 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1yoj3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>410818</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>