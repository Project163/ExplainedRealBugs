<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:45:28 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-2045] Long running JCR session prevent live cleanup in Segment FileStore</title>
                <link>https://issues.apache.org/jira/browse/OAK-2045</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;Cleanup operation in SegmentNodeStore detects the un referenced garbage and clean it up. To determine the reference validity it starts with an initial set of SegmentId which have a live java reference. &lt;/p&gt;

&lt;p&gt;This works fine for simple setup but when Oak repository is used in an application (like Sling) where application code can create long running session (for observation) then such session are bound to old NodeState at time of startup. Such references prevent the cleanup logic to remove older revisions while system is running. Such revisions can only be removed via an offline compaction-&amp;gt; cleanup.&lt;/p&gt;

&lt;p&gt;Need to find out a way where we can &lt;em&gt;migrate&lt;/em&gt; such old NodeState references to newer revisions&lt;/p&gt;</description>
                <environment></environment>
        <key id="12735772">OAK-2045</key>
            <summary>Long running JCR session prevent live cleanup in Segment FileStore</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="mduerig">Michael D&#252;rig</assignee>
                                    <reporter username="chetanm">Chetan Mehrotra</reporter>
                        <labels>
                            <label>gc</label>
                    </labels>
                <created>Thu, 21 Aug 2014 12:32:27 +0000</created>
                <updated>Tue, 8 Oct 2019 15:21:26 +0000</updated>
                            <resolved>Tue, 9 Jun 2015 08:30:36 +0000</resolved>
                                                                    <component>segmentmk</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="14108381" author="chetanm" created="Sun, 24 Aug 2014 08:59:49 +0000"  >&lt;p&gt;Updated patch with which the testcase passes. For this I need to drop the segments cache in the SegmentTracker as it was holding a reference to SegmentId&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=alexparvulescu&quot; class=&quot;user-hover&quot; rel=&quot;alexparvulescu&quot;&gt;alexparvulescu&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jukkaz&quot; class=&quot;user-hover&quot; rel=&quot;jukkaz&quot;&gt;jukkaz&lt;/a&gt; Would Dropping the cache for testcase is fine?&lt;/p&gt;</comment>
                            <comment id="14108416" author="chetanm" created="Sun, 24 Aug 2014 14:05:25 +0000"  >&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12663965/12663965_OAK-2045-segment-fault-approach.patch&quot; title=&quot;OAK-2045-segment-fault-approach.patch attached to OAK-2045&quot;&gt;patch&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; based on Segment fault approach which relies on logical linking of SegmentNodeState based on path they refer to post cleanup.&lt;/p&gt;

&lt;p&gt;Each segmentId would records its in memory creationTime. Further each &lt;tt&gt;SegmentNodeState&lt;/tt&gt; would maintain a path property if the state is part of repository tree. While performing cleanup those segmentId would be marked stale which are considered &lt;em&gt;old&lt;/em&gt;. Due to this when a SegmentNodeState which refers to an old revision tries to access any property then it would result in a &lt;tt&gt;SegmentStaleException&lt;/tt&gt;. Upon detecting such an exception aka &lt;em&gt;SegmentFault&lt;/em&gt; the state would locate the latest nodeState for the given path and update its segmentId.&lt;/p&gt;

&lt;p&gt;SegementNodeState maintains an in memory state of templateId. Once the backing segment turn stale this state also need to be purged. To manage that each SegmentNodeState registers itself with the SegementId. Once any SegmentId is marked stale then each linked SegmentNodeState is refreshed such that they let go of in memory state.&lt;/p&gt;

&lt;p&gt;This should enable JCR session which hold reference to old NodeState upon startup be linked to latest NodeState and allow collection of revisions from those states. &lt;/p&gt;

&lt;p&gt;Points to consider&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;cleanup and lastCreationTime - The time argument passed to cleanup call should be older than any pending session operation. This can be based on lastSave from SessionMbeans.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;b&gt;Cons&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Need to make the segmentId and offset volatile in Record which does not look good and might have some effect on access performance&lt;/li&gt;
	&lt;li&gt;SegmentId maintains a wekreference list of the SegmentNodeState - This might need bit more care&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=alexparvulescu&quot; class=&quot;user-hover&quot; rel=&quot;alexparvulescu&quot;&gt;alexparvulescu&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jukkaz&quot; class=&quot;user-hover&quot; rel=&quot;jukkaz&quot;&gt;jukkaz&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mduerig&quot; class=&quot;user-hover&quot; rel=&quot;mduerig&quot;&gt;mduerig&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=thomasm&quot; class=&quot;user-hover&quot; rel=&quot;thomasm&quot;&gt;thomasm&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mreutegg&quot; class=&quot;user-hover&quot; rel=&quot;mreutegg&quot;&gt;mreutegg&lt;/a&gt; Kindly review on the approach taken. Tracking the SegmentNodeState so as notify them of templateId change is proving to be costly ... so looking into that.&lt;/p&gt;</comment>
                            <comment id="14108911" author="mduerig" created="Mon, 25 Aug 2014 09:01:27 +0000"  >&lt;p&gt;While I think the &quot;segment fault approach&quot; is the right, one we should not put the full path in each &lt;tt&gt;SegmentNodeState&lt;/tt&gt;. This will create a lot of memory overhead as we have seen before in similar settings. Instead we should rely on a mapping from the old to the new node state. With &lt;tt&gt;CompactionMap&lt;/tt&gt; we already have something along these lines.&lt;/p&gt;</comment>
                            <comment id="14108923" author="alex.parvulescu" created="Mon, 25 Aug 2014 09:11:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;For this I need to drop the segments cache in the SegmentTracker as it was holding a reference to SegmentId&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think it&apos;s ok to drop this cache, it will get recreated as needed. I see no other way around the fact that it keeps a hard reference. My original approach was to drop it from the #setCompactionMap method.&lt;/p&gt;</comment>
                            <comment id="14108939" author="mduerig" created="Mon, 25 Aug 2014 09:25:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;make the segmentId and offset volatile in Record&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This also affects the notion of identity for &lt;tt&gt;Record&lt;/tt&gt; instances. AFICS it even breaks the contract of the &lt;tt&gt;hashCode&lt;/tt&gt; method as equal node states might have different hash codes now. &lt;/p&gt;</comment>
                            <comment id="14108942" author="mduerig" created="Mon, 25 Aug 2014 09:27:52 +0000"  >&lt;blockquote&gt;&lt;p&gt;&lt;tt&gt;SegmentStaleException&lt;/tt&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This one is only handled in &lt;tt&gt;SegmentNodeStates&lt;/tt&gt;. I foresee issues for &lt;tt&gt;SegmentBlob&lt;/tt&gt; which clients also might keep references to. &lt;/p&gt;</comment>
                            <comment id="14108970" author="chetanm" created="Mon, 25 Aug 2014 10:02:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;Instead we should rely on a mapping from the old to the new node state. With CompactionMap we already have something along these lines.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The problem with CompactionMap based approach is that we need to maintain the map state (for still living SegmentId) across all the cleanup operations. And if the segmentId got shifted multiple times then track it all along. Given that path looks more stable&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This also affects the notion of identity for Record instances. AFICS it even breaks the contract of the hashCode method as equal node states might have different hash codes now. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yup thats a drawback of this approach. But then the old NodeState is now linked to latest revision so effectively we have a newer NodeState. One way or the other this contract would be broken under this approach&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This one is only handled in SegmentNodeStates. I foresee issues for SegmentBlob which clients also might keep references to. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Thanks for highlighting that. Would update the patch to handle the case for SegmentBlob also. Main focus is on type of Records which might be directly referred by calling code. So &lt;tt&gt;SegmentNodeState&lt;/tt&gt; is possible but PropertyState is not likely. SegmentBlob thought would be referred in the Lucene OakDirectory so need to accounted for.&lt;/p&gt;</comment>
                            <comment id="14108992" author="mduerig" created="Mon, 25 Aug 2014 10:25:44 +0000"  >&lt;blockquote&gt;&lt;p&gt;The problem with CompactionMap based approach is that we need to maintain the map state (for still living SegmentId) across all the cleanup operations. And if the segmentId got shifted multiple times then track it all along. Given that path looks more stable&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s no better with the path. Only that here that information is right in the node state instead in a separate place. So in the end I don&apos;t see much of a difference except for the path to take up too much space. This &lt;b&gt;will&lt;/b&gt; create issues. &lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;One way or the other this contract would be broken under this approach&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Which is a clear indication to me that we should rethink the approach. Breaking the equality contract for node states will haunt us forever. &lt;/p&gt;

&lt;p&gt;What we probably need to do is to use a virtualised address space: currently the record id points directly to the storage location. By making this a virtual address and going through a mapping, different generations could use different mappings without breaking fundamental contracts.. &lt;/p&gt;</comment>
                            <comment id="14135541" author="chetanm" created="Tue, 16 Sep 2014 14:41:51 +0000"  >&lt;p&gt;Updated work in progress patch which now uses Compaction map to relink RecordId as suggested above. &lt;/p&gt;</comment>
                            <comment id="14144635" author="chetanm" created="Tue, 23 Sep 2014 10:13:21 +0000"  >&lt;p&gt;Had discussion with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mduerig&quot; class=&quot;user-hover&quot; rel=&quot;mduerig&quot;&gt;mduerig&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=alexparvulescu&quot; class=&quot;user-hover&quot; rel=&quot;alexparvulescu&quot;&gt;alexparvulescu&lt;/a&gt; and it was found that CompactionMap based mapping approach would not work in all cases . For example if node is modified few times before compaction is run then CompactionMap would only have mapping for last state. So any NodeState reference to previous state would not be mapped.&lt;/p&gt;

&lt;p&gt;Given that a path based approach might be more stable to perform the mapping. Attaching &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12670683/12670683_OAK-2045-segment-fault-approach-2-path-based.patch&quot; title=&quot;OAK-2045-segment-fault-approach-2-path-based.patch attached to OAK-2045&quot;&gt;a patch using path based approach&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;. Its a WIP as not all code paths are covered. For e.g. if a SegmentNodeState gets created via MapRecord then it would not have path set.&lt;/p&gt;</comment>
                            <comment id="14195889" author="mduerig" created="Tue, 4 Nov 2014 08:48:37 +0000"  >&lt;p&gt;Much of the discussion also relating to this issue has currently moved to &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2192&quot; title=&quot;Concurrent commit during compaction results in mixed segments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2192&quot;&gt;&lt;del&gt;OAK-2192&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="14248417" author="mduerig" created="Tue, 16 Dec 2014 16:09:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2192&quot; title=&quot;Concurrent commit during compaction results in mixed segments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2192&quot;&gt;&lt;del&gt;OAK-2192&lt;/del&gt;&lt;/a&gt; is resolved now. This changes the scope of this issue a bit as now long running sessions won&apos;t hold segments from being collected but such sessions might run into a &lt;tt&gt;SegmentNotFoundException&lt;/tt&gt;. In our tests this didn&apos;t come up so far as all long running sessions seem to first call refresh when becoming active again. &lt;/p&gt;</comment>
                            <comment id="14578571" author="mduerig" created="Tue, 9 Jun 2015 08:30:36 +0000"  >&lt;p&gt;Resolving as won&apos;t fix as this is an inherent property of how revision gc is designed on the SegmentMK. See &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2408&quot; title=&quot;Investigate ways to make revision gc more precise &quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2408&quot;&gt;&lt;del&gt;OAK-2408&lt;/del&gt;&lt;/a&gt; for how this conclusion was reached and &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-2849&quot; title=&quot;Improve revision gc on SegmentMK&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-2849&quot;&gt;&lt;del&gt;OAK-2849&lt;/del&gt;&lt;/a&gt; for improvements to revision gc within the current design.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12765997">OAK-2384</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12744052">OAK-2140</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12748055">OAK-2192</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12767764">OAK-2408</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12743524">OAK-2124</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12748055">OAK-2192</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12669071" name="OAK-2045-segment-fault-approach-1.patch" size="29020" author="chetanm" created="Tue, 16 Sep 2014 14:41:51 +0000"/>
                            <attachment id="12670683" name="OAK-2045-segment-fault-approach-2-path-based.patch" size="24597" author="chetanm" created="Tue, 23 Sep 2014 10:13:21 +0000"/>
                            <attachment id="12663965" name="OAK-2045-segment-fault-approach.patch" size="26096" author="chetanm" created="Sun, 24 Aug 2014 14:05:25 +0000"/>
                            <attachment id="12663960" name="OAK-2045-test-fix.patch" size="1750" author="chetanm" created="Sun, 24 Aug 2014 08:59:49 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311120" key="com.pyxis.greenhopper.jira:gh-epic-link">
                        <customfieldname>Epic Link</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>OAK-2849</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 23 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1z6kf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>