<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 18:36:30 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[OAK-535] MergeCommand reads complete tree into memory</title>
                <link>https://issues.apache.org/jira/browse/OAK-535</link>
                <project id="12313221" key="OAK">Jackrabbit Oak</project>
                    <description>&lt;p&gt;Merging commits to a branch back to head in MongoMK calls MergeCommand, which reads the complete tree into memory. The more content is in the repository, the longer it takes to store even a simple update as a property change.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12624818">OAK-535</key>
            <summary>MergeCommand reads complete tree into memory</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="mreutegg">Marcel Reutegger</assignee>
                                    <reporter username="mreutegg">Marcel Reutegger</reporter>
                        <labels>
                    </labels>
                <created>Thu, 20 Dec 2012 13:56:33 +0000</created>
                <updated>Wed, 11 Sep 2013 06:16:17 +0000</updated>
                            <resolved>Wed, 11 Sep 2013 06:16:17 +0000</resolved>
                                    <version>0.5</version>
                                                    <component>mongomk</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="13537029" author="meteatamel" created="Thu, 20 Dec 2012 14:03:42 +0000"  >&lt;p&gt;To provide more context why this is the case, when a branch is merged into the trunk, MergeCommand does a 3-way merge (borrowed from MicroKernelImpl) among branch root, current trunk head, and the common ancestor of trunk and branch. So it needs to fetch nodes at those mentioned paths in order to do comparisons but the problem is it&apos;s not obvious what the path and depth of that fetch should be. So as a start, I went with &quot;/&quot; as path and unlimited depth to fetch everything but that obviously is not going to work for lots of nodes. After some testing, it looked to me that we should be able to limit the depth to the max depth of the branch and that works for the branch/merge tests but fails in other scenarios like quickstart. We might also be able to limit the path of the getNodes calls (instead of using &quot;/&quot;) but haven&apos;t had the chance to investigate that yet.&lt;/p&gt;</comment>
                            <comment id="13537030" author="meteatamel" created="Thu, 20 Dec 2012 14:05:29 +0000"  >&lt;p&gt;This is a patch that shows some of my attempts to fix the issue but it doesn&apos;t fix the issue fully.&lt;/p&gt;</comment>
                            <comment id="13537081" author="mreutegg" created="Thu, 20 Dec 2012 15:31:20 +0000"  >&lt;p&gt;I&apos;m wondering if we need the full fledged 3-way merge in all cases. Shouldn&apos;t it be possible to skip the step of merging head into the branch, when we can detect there were no changes between the point the branch was created and the commit (aka the request to merge the branch into head)?&lt;/p&gt;</comment>
                            <comment id="13546973" author="meteatamel" created="Tue, 8 Jan 2013 16:09:22 +0000"  >&lt;p&gt;Removed one of the getNodes call in rev 1430348.&lt;/p&gt;</comment>
                            <comment id="13552570" author="mreutegg" created="Mon, 14 Jan 2013 10:53:31 +0000"  >&lt;p&gt;This is a work-in-progress patch, which shows what kind of optimization I have in mind.&lt;/p&gt;

&lt;p&gt;MergeCommand checks if there were any commits to head in the meantime. If there are none, then the branch commits are aggregated into a single one and commit to head.&lt;/p&gt;

&lt;p&gt;Unfortunately I see some unexpected behaviour in some cases when multiple commits are aggregated. E.g. see additional test movesInBranch() in MongoMKBranchMergeTest.&lt;/p&gt;</comment>
                            <comment id="13552571" author="mreutegg" created="Mon, 14 Jan 2013 10:55:00 +0000"  >&lt;p&gt;Please note that the diff aggregation is pretty quick&apos;n&apos;dirty and creates a very verbose diff with absolute paths for every diff operation.&lt;/p&gt;</comment>
                            <comment id="13552602" author="meteatamel" created="Mon, 14 Jan 2013 12:18:11 +0000"  >&lt;p&gt;Hi Marcel, I applied your change but it also fails with&lt;br/&gt;
GraniteInstallTest. I&apos;ll see if I can figure out what might be wrong.&lt;/p&gt;

&lt;p&gt;-Mete&lt;/p&gt;


</comment>
                            <comment id="13552616" author="mreutegg" created="Mon, 14 Jan 2013 12:39:38 +0000"  >&lt;p&gt;A bit off-topic, but still related because my optimization attempt lead me to look into CommitCommandInstructionVisitor: wouldn&apos;t it make sense to simplify visit(MoveNodeInstruction instruction) to:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;        &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; srcPath = instruction.getSourcePath();
        &lt;span class=&quot;code-comment&quot;&gt;// copy source to destination
&lt;/span&gt;        visit(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CopyNodeInstructionImpl(instruction.getPath(),
                srcPath, instruction.getDestPath()));
        &lt;span class=&quot;code-comment&quot;&gt;// delete source tree
&lt;/span&gt;        visit(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RemoveNodeInstructionImpl(PathUtils.getParentPath(srcPath),
                PathUtils.getName(srcPath)));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This would remove some duplicate code and should be about the same what the current code does, right?&lt;/p&gt;</comment>
                            <comment id="13552629" author="meteatamel" created="Mon, 14 Jan 2013 12:55:46 +0000"  >&lt;p&gt;As long as unit tests especially MongoMKCommitMoveTest and MicroKernelIT pass, I&apos;m in favor of simplifying MoveNodeInstruction to what you suggested.&lt;/p&gt;</comment>
                            <comment id="13552632" author="meteatamel" created="Mon, 14 Jan 2013 12:58:57 +0000"  >&lt;p&gt;BTW, movesInBranch test looks like a general problem with MoveNodeInstruction. If you apply the same sequence against trunk with no branch/merge, you get the same failure.&lt;/p&gt;</comment>
                            <comment id="13552661" author="meteatamel" created="Mon, 14 Jan 2013 14:00:45 +0000"  >&lt;p&gt;Attached the fix for the move node problem I mentioned before. Marcel, let me know if you want me to submit this?&lt;/p&gt;</comment>
                            <comment id="13552679" author="mreutegg" created="Mon, 14 Jan 2013 14:21:17 +0000"  >&lt;p&gt;I think the path prefix check is not correct and will also match nodes, which are not actually descendants of the moved node. E.g. consider nodes /a/b and /a/bb. Wouldn&apos;t moving /a/b also mark /a/bb as deleted with you patch?&lt;/p&gt;</comment>
                            <comment id="13552688" author="meteatamel" created="Mon, 14 Jan 2013 14:42:47 +0000"  >&lt;p&gt;Possibly and your comment highlighted another problem with the current MoveNodeInstruction. In &quot;copy existing nodes&quot; part, it tries to fetch all descendants of the moved node, /a/b, using FetchNodesAction but FetchNodesAction will fetch /a/bb as well when it shouldn&apos;t. &lt;/p&gt;</comment>
                            <comment id="13552801" author="mreutegg" created="Mon, 14 Jan 2013 15:45:38 +0000"  >&lt;p&gt;Here&apos;s my proposal.&lt;/p&gt;

&lt;p&gt;This patch also removes the troublesome call to FetchNodesAction.&lt;/p&gt;</comment>
                            <comment id="13552827" author="meteatamel" created="Mon, 14 Jan 2013 16:07:09 +0000"  >&lt;p&gt;Nice. Your patch looks more elegant and passes all the unit tests, so I say let&apos;s check it in. In the meantime, I&apos;ll open another bug for that FetchNodesAction issue.&lt;/p&gt;</comment>
                            <comment id="13553584" author="mreutegg" created="Tue, 15 Jan 2013 08:12:53 +0000"  >&lt;p&gt;Committed the patch in revision: 1433308&lt;/p&gt;</comment>
                            <comment id="13553629" author="mreutegg" created="Tue, 15 Jan 2013 10:18:03 +0000"  >&lt;p&gt;I now also committed my &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-535&quot; title=&quot;MergeCommand reads complete tree into memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-535&quot;&gt;&lt;del&gt;OAK-535&lt;/del&gt;&lt;/a&gt;.patch from yesterday.&lt;/p&gt;

&lt;p&gt;Trivial merges are now simply re-applied to trunk.&lt;/p&gt;</comment>
                            <comment id="13554910" author="mreutegg" created="Wed, 16 Jan 2013 10:30:46 +0000"  >&lt;p&gt;Optimized diff normalization in revision: 1433884&lt;/p&gt;</comment>
                            <comment id="13555073" author="meteatamel" created="Wed, 16 Jan 2013 14:29:14 +0000"  >&lt;p&gt;I&apos;m attaching a further optimization to Marcel&apos;s initial MergeCommand optimization. Basically, even if there have been commits on trunk since the branch was created, MergeCommand now checks whether those commits are conflicting with branch commits. If not, it simply reapplies branch commits to trunk.&lt;/p&gt;</comment>
                            <comment id="13555093" author="mreutegg" created="Wed, 16 Jan 2013 14:56:23 +0000"  >&lt;p&gt;Good work. One thing I&apos;m not sure of. getNonConflictingCommitsDiff() collects affectedPathsBranch and affectedPathsTrunk in the same loop. Does this guarantee that an overlapping commit is detected?&lt;/p&gt;</comment>
                            <comment id="13555104" author="meteatamel" created="Wed, 16 Jan 2013 15:15:24 +0000"  >&lt;p&gt;Yeah I tried to minimize FetchCommit and looping as much as I can and I think overlapping affected paths should be detected with this algorithm. Every time an affected path is detected for branch/trunk, it&apos;s checked against trunk/branch set. If trunk/brach set does not have it yet, then the affected path will be put into branch/trunk set and checked again for trunk/branch against branch/trunk set. Since we fetch all commits from branch root until latest commit, it should contain all the relevant affected paths. But if you can think of a case where the algorithms fails, please let me know.&lt;/p&gt;</comment>
                            <comment id="13555108" author="mreutegg" created="Wed, 16 Jan 2013 15:22:19 +0000"  >&lt;p&gt;You are right, I was thinking through the various cases and it does indeed work with the single loop.&lt;/p&gt;

&lt;p&gt;Feel free to commit.&lt;/p&gt;</comment>
                            <comment id="13555117" author="meteatamel" created="Wed, 16 Jan 2013 15:29:03 +0000"  >&lt;p&gt;Committed with rev 1433907&lt;/p&gt;</comment>
                            <comment id="13564343" author="mreutegg" created="Mon, 28 Jan 2013 15:33:04 +0000"  >&lt;p&gt;I was thinking about this problem again and was wondering if we can leverage the commit history again when we have a concurrent (potentially conflicting) commit. Instead of reading the tree and performing a diff, couldn&apos;t we just apply the commits between the branch root and the current head revision on top of the trunk? While doing this we could check for conflicts and abort if necessary.&lt;/p&gt;</comment>
                            <comment id="13564362" author="meteatamel" created="Mon, 28 Jan 2013 16:01:10 +0000"  >&lt;p&gt;You need to be able to apply these branch commits to trunk without actually committing to trunk until you&apos;re sure that all branch commits are OK to commit to trunk. Because one or more branch commits might be conflicting with trunk and in that case, no branch commit should go to trunk. That&apos;s why currently MergeCommand reads the tree and generates a diff and applies that diff to trunk in one commit. How would you do that in this approach?&lt;/p&gt;</comment>
                            <comment id="13565186" author="mreutegg" created="Tue, 29 Jan 2013 08:34:39 +0000"  >&lt;p&gt;Now that I think more about this, I&apos;d even go as far as ripping out all the merge code from MergeCommand.&lt;/p&gt;

&lt;p&gt;If we look at MergeCommand and what it is supposed to do, then it&apos;s basically gathering all the commits from the branch and apply it to trunk based on the branch root revision. That&apos;s the same as calling MK.commit() with the combined branch commit diffs and the branch root revision. The point is, MK.commit() must implement he rebase anyway and CommitCommand does that already, but IMO insufficiently. I think detecting concurrent and possibly conflicting commits and performing the merge should be done in CommitCommand (CommitCommand.readAndMergeExistingNodes()). MergeCommand will then simply gather the diffs and pass it to CommitCommand.&lt;/p&gt;</comment>
                            <comment id="13565218" author="meteatamel" created="Tue, 29 Jan 2013 09:22:36 +0000"  >&lt;p&gt;Currently, readAndMergeExistingNodes tries to merge nodes between baseRevisionId and headRevisionId, then nodes/commits are saved and then saveAndSetHeadRevision tries to detect commits that happened since nodes/commits are saved and see if they are conflicting. If they are not conflicting, saveAndSetHeadRevision tries to update the baseRevisionIds and let things progress (&lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-585&quot; title=&quot;Reduce cost of commit retry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-585&quot;&gt;&lt;del&gt;OAK-585&lt;/del&gt;&lt;/a&gt;). Are you suggesting that we also need to somehow combine readAndMergeExistingNodes &amp;amp; saveAndSetHeadRevision?&lt;/p&gt;</comment>
                            <comment id="13565249" author="mreutegg" created="Tue, 29 Jan 2013 10:15:43 +0000"  >&lt;p&gt;No, I suggest to implement conflict detection in readAndMergeExistingNodes().&lt;/p&gt;</comment>
                            <comment id="13565288" author="meteatamel" created="Tue, 29 Jan 2013 11:36:41 +0000"  >&lt;p&gt;Is conflict detection only in readAndMergeExistingNodes enough though? There&apos;s a gap between when nodes/commit are saved and when headRevId is incremented. In that gap, what if some other MK does some conflicting commits? Wouldn&apos;t we need the same conflict detection that we&apos;d have in readAndMergeExistingNodes at saveAndSetHeadRevision in order to avoid leaving garbage nodes/commits behind?&lt;/p&gt;</comment>
                            <comment id="13565291" author="mreutegg" created="Tue, 29 Jan 2013 11:44:11 +0000"  >&lt;p&gt;The check we have in saveAndSetHeadRevision() just detects concurrent commits, but it cannot tell whether concurrent commits conflict. I think we could keep saveAndSetHeadRevision() as is. If saveAndSetHeadRevision() fails, then the commit is retried with the new head revision. Conflict detection and resolution (if needed) on the tree level then happens in readAndMergeExistingNodes().&lt;/p&gt;</comment>
                            <comment id="13565302" author="meteatamel" created="Tue, 29 Jan 2013 12:06:54 +0000"  >&lt;p&gt;What you described regarding saveAndSetHeadRevision is already the case but then we have &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-585&quot; title=&quot;Reduce cost of commit retry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-585&quot;&gt;&lt;del&gt;OAK-585&lt;/del&gt;&lt;/a&gt; about too many commit retries. Let&apos;s continue the discussion in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-585&quot; title=&quot;Reduce cost of commit retry&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-585&quot;&gt;&lt;del&gt;OAK-585&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13565408" author="mduerig" created="Tue, 29 Jan 2013 14:43:44 +0000"  >&lt;p&gt;From the oak-core perspective the important part here is the fast forward merge. That is, the merge where there are no changes on trunk. &lt;/p&gt;

&lt;p&gt;Since oak-core has not enough information to handle the case where a merge conflicts (see &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-496&quot; title=&quot;More specific error reporting for Microkernel.commit&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-496&quot;&gt;&lt;del&gt;OAK-496&lt;/del&gt;&lt;/a&gt;), the current implementation of oak-core rebases a branch on top of the current trunk and then merges the rebased trunk. Since the current MicroKernel does not expose any rebase functionality (&lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-536&quot; title=&quot;Implement rebase for branches in Microkernel&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-536&quot;&gt;&lt;del&gt;OAK-536&lt;/del&gt;&lt;/a&gt;) oak-core implements rebasing by creating a new branch and applying all changes from the current branch to that new branch. Apart from being expensive (wasting branches, additional round trips), this also suffers from the same &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-535?focusedCommentId=13565288&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13565288&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;race condition Mete describes&lt;/a&gt; only worse since this is exposed over component boundaries. &lt;/p&gt;

&lt;p&gt;So, since oak-core doesn&apos;t care too much about the conflict case on merge but quite in the contrary, I suggest not to care about this case too much. I think it is fine to just be able to detect conflicts and throw an exception in this case. Make it dead simple: there is a conflict in merging a branch to trunk when the base revision of the trunk is not equal to the head revision of the head. It is the responsibility of the caller to make sure that branches are properly rebased before being merge. &lt;/p&gt;

&lt;p&gt;See also &lt;a href=&quot;http://wiki.apache.org/jackrabbit/Conflict%20handling%20through%20rebasing%20branches&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://wiki.apache.org/jackrabbit/Conflict%20handling%20through%20rebasing%20branches&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="13565472" author="mreutegg" created="Tue, 29 Jan 2013 15:57:16 +0000"  >&lt;p&gt;I&apos;d love to have a MergeCommand, which fails fast. See attached patch. But now some tests fail, because they expect a MK implementation will consider concurrent sibling creation as non-conflicting.&lt;/p&gt;

&lt;p&gt;Removing the child node list in the parent node as proposed in &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-586&quot; title=&quot;Support for large number of child nodes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-586&quot;&gt;&lt;del&gt;OAK-586&lt;/del&gt;&lt;/a&gt; would resolve this issue.&lt;/p&gt;</comment>
                            <comment id="13565505" author="mduerig" created="Tue, 29 Jan 2013 16:41:39 +0000"  >&lt;blockquote&gt;&lt;p&gt;some tests fail, because they expect a MK implementation will consider concurrent sibling creation as non-conflicting.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;... and &lt;tt&gt;getNonConflictingCommitsDiff()&lt;/tt&gt; considers these as conflicting right? This is the same finding &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-585?focusedCommentId=13564137&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13564137&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;Mete reported earlier&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;I think we need to put some effort into defining what we consider a conflict and what not. &lt;a href=&quot;http://wiki.apache.org/jackrabbit/Conflict%20handling%20through%20rebasing%20branches&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;Here &lt;/a&gt; (towards the end of the page) is the definition I use for rebasing. It is based on the expectations of oak-core and ultimately JCR. Specifically note the delete-delete conflicts. Those would be easy to resolve. However the JCR TCK mandates these to be conflicts. See &lt;tt&gt;org.apache.jackrabbit.test.api.NodeTest#testRemoveInvalidItemStateException&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13566658" author="mreutegg" created="Wed, 30 Jan 2013 17:21:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;and getNonConflictingCommitsDiff() considers these as conflicting right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, that&apos;s correct.&lt;/p&gt;</comment>
                            <comment id="13576745" author="meteatamel" created="Tue, 12 Feb 2013 16:29:59 +0000"  >&lt;p&gt;Note that the patch I attached to &lt;a href=&quot;https://issues.apache.org/jira/browse/OAK-586&quot; title=&quot;Support for large number of child nodes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;OAK-586&quot;&gt;&lt;del&gt;OAK-586&lt;/del&gt;&lt;/a&gt; works with FailFastMergeCommand.patch as well.&lt;/p&gt;</comment>
                            <comment id="13764039" author="mreutegg" created="Wed, 11 Sep 2013 06:16:17 +0000"  >&lt;p&gt;Resolving as WONTFIX. This issue was reported for the previous design of the MongoMK.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12566992" name="FailFastMergeCommand.patch" size="10189" author="mreutegg" created="Tue, 29 Jan 2013 15:57:16 +0000"/>
                            <attachment id="12564683" name="OAK-535.patch" size="13895" author="mreutegg" created="Mon, 14 Jan 2013 10:53:31 +0000"/>
                            <attachment id="12565126" name="mergecommandoptimization.patch" size="4805" author="meteatamel" created="Wed, 16 Jan 2013 14:29:14 +0000"/>
                            <attachment id="12561896" name="mergefixattempt.patch" size="10402" author="meteatamel" created="Thu, 20 Dec 2012 14:05:29 +0000"/>
                            <attachment id="12564706" name="movepatch.diff" size="3807" author="meteatamel" created="Mon, 14 Jan 2013 14:00:45 +0000"/>
                            <attachment id="12564721" name="moves-in-commit.patch" size="15040" author="mreutegg" created="Mon, 14 Jan 2013 15:45:38 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>301326</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 10 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i16rp3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>247619</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>