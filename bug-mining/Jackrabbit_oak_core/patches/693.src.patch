diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
index b53576f388..75510da8d3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
@@ -325,7 +325,7 @@ public class Commit {
                     // to set isNew to false. If we get here the
                     // commitRoot document already exists and
                     // only needs an update
-                    UpdateOp commit = commitRoot.clone(commitRoot.getId());
+                    UpdateOp commit = commitRoot.shallowCopy(commitRoot.getId());
                     commit.setNew(false);
                     // only set revision on commit root when there is
                     // no collision for this commit revision
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
index 75ba4d4743..a917a2dfd0 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
@@ -73,9 +73,20 @@ public final class UpdateOp {
      *
      * @param id the primary key.
      */
-    public UpdateOp clone(String id) {
+    public UpdateOp shallowCopy(String id) {
         return new UpdateOp(id, isNew, isDelete, changes);
     }
+
+    /**
+     * Creates a deep copy of this update operation. Changes to the returned
+     * {@code UpdateOp} do not affect this object.
+     *
+     * @return a copy of this operation.
+     */
+    public UpdateOp copy() {
+        return new UpdateOp(id, isNew, isDelete,
+                new HashMap<Key, Operation>(changes));
+    }
     
     public String getId() {
         return id;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/memory/MemoryDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/memory/MemoryDocumentStore.java
index 620d813cd3..a72bf35fc0 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/memory/MemoryDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/memory/MemoryDocumentStore.java
@@ -242,7 +242,7 @@ public class MemoryDocumentStore implements DocumentStore {
                 if (!map.containsKey(key)) {
                     continue;
                 }
-                internalCreateOrUpdate(collection, updateOp.clone(key), true);
+                internalCreateOrUpdate(collection, updateOp.shallowCopy(key), true);
             }
         } finally {
             lock.unlock();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
index 57b83e0b83..99a102e189 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
@@ -368,6 +368,8 @@ public class MongoDocumentStore implements DocumentStore {
                                                  boolean upsert,
                                                  boolean checkConditions) {
         DBCollection dbCollection = getDBCollection(collection);
+        // make sure we don't modify the original updateOp
+        updateOp = updateOp.copy();
         DBObject update = createUpdate(updateOp);
 
         Lock lock = getAndLock(updateOp.getId());
@@ -453,7 +455,6 @@ public class MongoDocumentStore implements DocumentStore {
         for (int i = 0; i < updateOps.size(); i++) {
             inserts[i] = new BasicDBObject();
             UpdateOp update = updateOps.get(i);
-            update.increment(Document.MOD_COUNT, 1);
             T target = collection.newDocument(this);
             UpdateUtils.applyChanges(target, update, comparator);
             docs.add(target);
@@ -484,6 +485,10 @@ public class MongoDocumentStore implements DocumentStore {
                         break;
                 }
             }
+            if (!inserts[i].containsField(Document.MOD_COUNT)) {
+                inserts[i].put(Document.MOD_COUNT, 1L);
+                target.put(Document.MOD_COUNT, 1L);
+            }
         }
 
         DBCollection dbCollection = getDBCollection(collection);
@@ -519,6 +524,8 @@ public class MongoDocumentStore implements DocumentStore {
                                             UpdateOp updateOp) {
         DBCollection dbCollection = getDBCollection(collection);
         QueryBuilder query = QueryBuilder.start(Document.ID).in(keys);
+        // make sure we don't modify the original updateOp
+        updateOp = updateOp.copy();
         DBObject update = createUpdate(updateOp);
         long start = start();
         try {
@@ -543,7 +550,7 @@ public class MongoDocumentStore implements DocumentStore {
                             nodesCache.invalidate(new StringValue(entry.getKey()));
                         } else {
                             applyToCache(Collection.NODES, entry.getValue(),
-                                    updateOp.clone(entry.getKey()));
+                                    updateOp.shallowCopy(entry.getKey()));
                         }
                     } finally {
                         lock.unlock();
@@ -559,7 +566,7 @@ public class MongoDocumentStore implements DocumentStore {
 
     @CheckForNull
     <T extends Document> T convertFromDBObject(@Nonnull Collection<T> collection,
-                                                       @Nullable DBObject n) {
+                                               @Nullable DBObject n) {
         T copy = null;
         if (n != null) {
             copy = collection.newDocument(this);
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MongoDocumentStoreIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MongoDocumentStoreIT.java
index d9cbd78b0d..c4a60daf64 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MongoDocumentStoreIT.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MongoDocumentStoreIT.java
@@ -22,6 +22,7 @@ import java.util.Map;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.junit.Test;
 
@@ -30,6 +31,9 @@ import com.google.common.collect.Maps;
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
 
 /**
  * Tests {@code MongoDocumentStore} with concurrent updates.
@@ -55,7 +59,7 @@ public class MongoDocumentStoreIT extends AbstractMongoConnectionTest {
                     for (int i = 0; i < UPDATES_PER_THREAD; i++) {
                         UpdateOp update = new UpdateOp(id, false);
                         update.setMapEntry("prop", r, String.valueOf(i));
-                        docStore.createOrUpdate(Collection.NODES, update);
+                        docStore.createOrUpdate(NODES, update);
                     }
                 }
             }));
@@ -68,7 +72,7 @@ public class MongoDocumentStoreIT extends AbstractMongoConnectionTest {
                 try {
                     Map<Revision, Integer> previous = Maps.newHashMap();
                     while (running.get()) {
-                        NodeDocument doc = docStore.find(Collection.NODES, id);
+                        NodeDocument doc = docStore.find(NODES, id);
                         if (doc == null) {
                             throw new Exception("document is null");
                         }
@@ -105,7 +109,7 @@ public class MongoDocumentStoreIT extends AbstractMongoConnectionTest {
         for (Exception e : exceptions) {
             throw e;
         }
-        NodeDocument doc = docStore.find(Collection.NODES, id);
+        NodeDocument doc = docStore.find(NODES, id);
         assertNotNull(doc);
         Map<Revision, String> values = doc.getLocalMap("prop");
         assertNotNull(values);
@@ -129,8 +133,33 @@ public class MongoDocumentStoreIT extends AbstractMongoConnectionTest {
     public void negativeCache() throws Exception {
         String id = Utils.getIdFromPath("/test");
         DocumentStore docStore = mk.getDocumentStore();
-        assertNull(docStore.find(Collection.NODES, id));
+        assertNull(docStore.find(NODES, id));
         mk.commit("/", "+\"test\":{}", null, null);
-        assertNotNull(docStore.find(Collection.NODES, id));
+        assertNotNull(docStore.find(NODES, id));
+    }
+
+    @Test
+    public void modCount() throws Exception {
+        DocumentStore docStore = mk.getDocumentStore();
+        String head = mk.commit("/", "+\"test\":{}", null, null);
+        mk.commit("/test", "^\"prop\":\"v1\"", head, null);
+        // make sure _lastRev is persisted and _modCount updated accordingly
+        mk.runBackgroundOperations();
+
+        NodeDocument doc = docStore.find(NODES, Utils.getIdFromPath("/test"));
+        assertNotNull(doc);
+        Number mc1 = doc.getModCount();
+        assertNotNull(mc1);
+        try {
+            mk.commit("/test", "^\"prop\":\"v2\"", head, null);
+            fail();
+        } catch (MicroKernelException e) {
+            // expected
+        }
+        doc = docStore.find(NODES, Utils.getIdFromPath("/test"));
+        assertNotNull(doc);
+        Number mc2 = doc.getModCount();
+        assertNotNull(mc2);
+        assertTrue(mc2.longValue() > mc1.longValue());
     }
 }
