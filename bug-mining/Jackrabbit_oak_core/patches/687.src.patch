diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java
index 22956cc014..2e817ab8d4 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java
@@ -234,7 +234,11 @@ public abstract class AbstractQueryTest {
         try {
             Result result = executeQuery(query, language, NO_BINDINGS);
             for (ResultRow row : result.getRows()) {
-                lines.add(readRow(row, pathsOnly));
+                String r = readRow(row, pathsOnly);
+                if (query.startsWith("explain ")) {
+                    r = formatPlan(r);
+                }
+                lines.add(r);
             }
             if (!query.contains("order by")) {
                 Collections.sort(lines);
@@ -473,6 +477,14 @@ public abstract class AbstractQueryTest {
         return sql;
     }
     
+    static String formatPlan(String plan) {
+        plan = plan.replaceAll(" where ", "\n  where ");
+        plan = plan.replaceAll(" inner join ", "\n  inner join ");
+        plan = plan.replaceAll(" on ", "\n  on ");
+        plan = plan.replaceAll(" and ", "\n  and ");
+        return plan;
+    }
+    
     /**
      * A line reader that supports multi-line statements, where lines that start
      * with a space belong to the previous line.
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql1.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql1.txt
index e85fde6f2a..0daf78cde1 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql1.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql1.txt
@@ -14,6 +14,7 @@
 # limitations under the License.
 #
 # Syntax:
+# * lines that start with spaces belong to the previous line
 # * lines starting with "#" are remarks.
 # * lines starting with "select" are queries, followed by expected results and an empty line
 # * lines starting with "explain" are followed by expected query plan and an empty line
@@ -29,14 +30,21 @@ sql1 select prop1 from nt:unstructured where prop1 is not null order by prop1 as
 
 sql1 select excerpt(.) from nt:resource where contains(., 'jackrabbit')
 
-sql1 select * from nt:base where jcr:path like '/testroot/%' and birth > timestamp '1976-01-01T00:00:00.000+01:00'
+sql1 select * from nt:base 
+  where jcr:path like '/testroot/%' 
+  and birth > timestamp '1976-01-01T00:00:00.000+01:00'
 
-sql1 select * from nt:base where jcr:path like '/testroot/%' and value like 'foo\_bar' escape '\'
+sql1 select * from nt:base 
+  where jcr:path like '/testroot/%' 
+  and value like 'foo\_bar' escape '\'
 
-sql1 select * from nt:unstructured where "jcr:path" = '/testroot/foo' and contains(., 'fox')
+sql1 select * from nt:unstructured 
+  where "jcr:path" = '/testroot/foo' and contains(., 'fox')
 
-sql1 select * from nt:unstructured where "jcr:path" like '/testroot/%' and contains(., 'fox test')
+sql1 select * from nt:unstructured 
+  where "jcr:path" like '/testroot/%' and contains(., 'fox test')
 
 # not supported currently
-# sql1 select [jcr:path], [jcr:score], * from [nt:base] where (0 is not null) and isdescendantnode('/testroot')
+# sql1 select [jcr:path], [jcr:score], * from [nt:base] 
+#   where (0 is not null) and isdescendantnode('/testroot')
 
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt
index a5bd198ff7..810412e698 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt
@@ -14,11 +14,13 @@
 # limitations under the License.
 #
 # Syntax:
+# * lines that start with spaces belong to the previous line
 # * lines starting with "#" are remarks.
 # * lines starting with "select" are queries, followed by expected results and an empty line
 # * lines starting with "explain" are followed by expected query plan and an empty line
 # * lines starting with "sql1" are run using the sql1 language
-# * lines starting with "xpath2sql" are just converted from xpath to sql2
+# * lines starting with "xpath2sql" are just converted
+  from xpath to sql2
 # * all other lines are are committed into the microkernel (line by line)
 # * new tests are typically be added on top, after the syntax docs
 # * use ascii character only
@@ -27,21 +29,37 @@
 
 commit / + "test": { "a": { "name": "Hello" }, "b": { "name" : "World" }}
 
-select [jcr:path] from [nt:base] where [a/name] = 'Hello' or [b/name] = 'World'
+select [jcr:path]
+  from [nt:base]
+  where [a/name] = 'Hello' or [b/name] = 'World'
 /test
 
-select distinct [jcr:path] from [nt:base] where [a/name] = 'Hello' or [b/name] = 'World'
+select distinct [jcr:path]
+  from [nt:base]
+  where [a/name] = 'Hello' or [b/name] = 'World'
 /test
 
-select [jcr:path] from [nt:base] where [name] = 'Hello' union select [jcr:path] from [nt:base] where [name] = 'World'
+select [jcr:path]
+  from [nt:base]
+  where [name] = 'Hello' union select [jcr:path]
+  from [nt:base]
+  where [name] = 'World'
 /test/a
 /test/b
 
-select [jcr:path] from [nt:base] where [name] is not null union select [jcr:path] from [nt:base] where [name] is not null
+select [jcr:path]
+  from [nt:base]
+  where [name] is not null union select [jcr:path]
+  from [nt:base]
+  where [name] is not null
 /test/a
 /test/b
 
-select [jcr:path] from [nt:base] where [name] is not null union all select [jcr:path] from [nt:base] where [name] is not null
+select [jcr:path]
+  from [nt:base]
+  where [name] is not null union all select [jcr:path]
+  from [nt:base]
+  where [name] is not null
 /test/a
 /test/a
 /test/b
@@ -56,7 +74,12 @@ commit / + "test": { "a": { "x": "1", "yes": { } }, "b": { "yes" : { } }, "c": {
 xpath test//yes/..[@x]
 /test/a, null, null
 
-select b.[jcr:path] as [jcr:path], b.[jcr:score] as [jcr:score] from [nt:base] as a inner join [nt:base] as b on ischildnode(a, b) where name(a) = 'yes' and isdescendantnode(a, '/test') and b.[x] is not null
+select b.[jcr:path] as [jcr:path], b.[jcr:score] as [jcr:score]
+  from [nt:base] as a
+  inner join [nt:base] as b on ischildnode(a, b)
+  where name(a) = 'yes'
+  and isdescendantnode(a, '/test')
+  and b.[x] is not null
 /test/a, null
 
 commit / - "test"
@@ -65,7 +88,9 @@ commit / - "test"
 
 commit / + "test": { "space space": { "x": "1" }}
 
-select [jcr:path] from [nt:base] where issamenode([/test/space space])
+select [jcr:path]
+  from [nt:base]
+  where issamenode([/test/space space])
 /test/space space
 
 commit / - "test"
@@ -74,44 +99,73 @@ commit / - "test"
 
 commit / + "test": { "a": { "name": ["Hello", "World" ] }, "b": { "name" : "Hello" }}
 
-select [jcr:path] from [nt:base] where name = 'Hello'
+select [jcr:path]
+  from [nt:base]
+  where name = 'Hello'
 /test/a
 /test/b
 
-select [jcr:path] from [nt:base] where name = 'World'
+select [jcr:path]
+  from [nt:base]
+  where name = 'World'
 /test/a
 
-select [jcr:path] from [nt:base] where isdescendantnode('/test') and name = 'World'
+select [jcr:path]
+  from [nt:base]
+  where isdescendantnode('/test')
+  and name = 'World'
 /test/a
 
 commit / - "test"
 
 # expected error on two selectors with the same name
 
-select [jcr:path] from [nt:base] as p inner join [nt:base] as p on ischildnode(p, p) where p.[jcr:path] = '/'
-java.text.ParseException: select [jcr:path] from [nt:base] as p inner join [nt:base] as p on ischildnode(p, p) where p.[jcr:path] = '/': Two selectors with the same name: p
+select [jcr:path]
+  from [nt:base] as p
+  inner join [nt:base] as p on ischildnode(p, p)
+  where p.[jcr:path] = '/'
+java.text.ParseException: select [jcr:path]
+  from [nt:base] as p
+  inner join [nt:base] as p on ischildnode(p, p)
+  where p.[jcr:path] = '/': Two selectors with the same name: p
 
 # combining 'not' and 'and'
 
 commit / + "test": { "a": { "id": "10" }, "b": { "id" : "20" }}
 
-select [jcr:path] from [nt:base] where id is not null and not id = '100' and id <> '20'
+select [jcr:path]
+  from [nt:base]
+  where id is not null
+  and not id = '100'
+  and id <> '20'
 /test/a
 
-select [jcr:path] from [nt:base] where id < '1000'
+select [jcr:path]
+  from [nt:base]
+  where id < '1000'
 /test/a
 
-select [jcr:path] from [nt:base] where id is not null and not (id = '100' and id <> '20')
+select [jcr:path]
+  from [nt:base]
+  where id is not null
+  and not (id = '100'
+  and id <> '20')
 /test/a
 /test/b
 
-select [jcr:path] from [nt:base] where id = '10'
+select [jcr:path]
+  from [nt:base]
+  where id = '10'
 /test/a
 
-select [jcr:path], id from [nt:base] where id = '10'
+select [jcr:path], id
+  from [nt:base]
+  where id = '10'
 /test/a, 10
 
-select [jcr:path] from [nt:base] where id > '10'
+select [jcr:path]
+  from [nt:base]
+  where id > '10'
 /test/b
 
 commit / - "test"
@@ -120,56 +174,82 @@ commit / - "test"
 
 commit / + "test": { "name": "hello world" }
 
-select [jcr:path] from [nt:base] where contains(name, 'hello')
+select [jcr:path]
+  from [nt:base]
+  where contains(name, 'hello')
 /test
 
-select [jcr:path] from [nt:base] where contains(*, 'hello')
+select [jcr:path]
+  from [nt:base]
+  where contains(*, 'hello')
 /test
 
 commit / - "test"
 
 # other tests
 
-select [jcr:path] from [nt:base] as a where issamenode(a, '/')
+select [jcr:path]
+  from [nt:base] as a
+  where issamenode(a, '/')
 /
 
 commit / + "test": { "My Documents": { "x" : {}}}
 
-select [jcr:path] from [nt:base] where name() = 'My_x0020_Documents'
+select [jcr:path]
+  from [nt:base]
+  where name() = 'My_x0020_Documents'
 
-select [jcr:path] from [nt:base] where name() like '%My Documents%'
+select [jcr:path]
+  from [nt:base]
+  where name() like '%My Documents%'
 /test/My Documents
 
-select [jcr:path] from [nt:base] where name() = 'My Documents'
+select [jcr:path]
+  from [nt:base]
+  where name() = 'My Documents'
 /test/My Documents
 
 commit / - "test"
 
 commit / + "test": { "jcr:resource": {}, "resource": { "x" : {}}}
 
-select [jcr:path] from [nt:base] where id = -1
+select [jcr:path]
+  from [nt:base]
+  where id = -1
 
-select [jcr:path] from [nt:base] as b where isdescendantnode(b, '/test')
+select [jcr:path]
+  from [nt:base] as b
+  where isdescendantnode(b, '/test')
 /test/jcr:resource
 /test/resource
 /test/resource/x
 
-select [jcr:path] from [nt:base] as b where ischildnode(b, '/test')
+select [jcr:path]
+  from [nt:base] as b
+  where ischildnode(b, '/test')
 /test/jcr:resource
 /test/resource
 
-select [jcr:path] from [nt:base] as b where issamenode(b, '/test')
+select [jcr:path]
+  from [nt:base] as b
+  where issamenode(b, '/test')
 /test
 
-select [jcr:path] from [nt:base] where name() = 'resource'
+select [jcr:path]
+  from [nt:base]
+  where name() = 'resource'
 /test/resource
 
-select [jcr:path] from [nt:base] as b where localname(b) = 'resource'
+select [jcr:path]
+  from [nt:base] as b
+  where localname(b) = 'resource'
 /jcr:system/jcr:nodeTypes/nt:resource
 /test/jcr:resource
 /test/resource
 
-select [jcr:path] from [nt:base] as x where isdescendantnode(x, '/test')
+select [jcr:path]
+  from [nt:base] as x
+  where isdescendantnode(x, '/test')
 /test/jcr:resource
 /test/resource
 /test/resource/x
@@ -180,60 +260,96 @@ commit / + "parents": { "p0": {"id": "0"}, "p1": {"id": "1"}, "p2": {"id": "2"}}
 commit / + "children": { "c1": {"p": "1"}, "c2": {"p": "1"}, "c3": {"p": "2"}, "c4": {"p": "3"}}
 
 # relative property
-select [jcr:path] from [nt:base] where [c1/p] = '1'
+select [jcr:path]
+  from [nt:base]
+  where [c1/p] = '1'
 /children
 
-select [jcr:path] from [nt:base] as p where p.[jcr:path] = '/parents'
+select [jcr:path]
+  from [nt:base] as p
+  where p.[jcr:path] = '/parents'
 /parents
 
-select [jcr:path] from [nt:base] as [p] where [p].[jcr:path] = '/parents'
+select [jcr:path]
+  from [nt:base] as [p]
+  where [p].[jcr:path] = '/parents'
 /parents
 
-select p.[jcr:path], p2.[jcr:path] from [nt:base] as p inner join [nt:base] as p2 on ischildnode(p2, p) where p.[jcr:path] = '/'
+select p.[jcr:path], p2.[jcr:path]
+  from [nt:base] as p
+  inner join [nt:base] as p2 on ischildnode(p2, p)
+  where p.[jcr:path] = '/'
 /, /children
 /, /jcr:system
 /, /oak:index
 /, /parents
 
-select p.[jcr:path], p2.[jcr:path] from [nt:base] as p inner join [nt:base] as p2 on isdescendantnode(p2, p) where p.[jcr:path] = '/parents'
+select p.[jcr:path], p2.[jcr:path]
+  from [nt:base] as p
+  inner join [nt:base] as p2 on isdescendantnode(p2, p)
+  where p.[jcr:path] = '/parents'
 /parents, /parents/p0
 /parents, /parents/p1
 /parents, /parents/p2
 
-select p.[jcr:path], p2.[jcr:path] from [nt:base] as p inner join [nt:base] as p2 on issamenode(p2, p) where p.[jcr:path] = '/parents'
+select p.[jcr:path], p2.[jcr:path]
+  from [nt:base] as p
+  inner join [nt:base] as p2 on issamenode(p2, p)
+  where p.[jcr:path] = '/parents'
 /parents, /parents
 
-select id from [nt:base] where id is not null
+select id
+  from [nt:base]
+  where id is not null
 0
 1
 2
 
-select id from [nt:base] where id is not null order by id desc
+select id
+  from [nt:base]
+  where id is not null order by id desc
 2
 1
 0
 
-select c.[jcr:path], p.[jcr:path] from [nt:base] as c right outer join [nt:base] as p on p.id = c.p where p.id is not null and not isdescendantnode(p, '/jcr:system')
+select c.[jcr:path], p.[jcr:path]
+  from [nt:base] as c
+  right outer join [nt:base] as p on p.id = c.p
+  where p.id is not null
+  and not isdescendantnode(p, '/jcr:system')
 /children/c1, /parents/p1
 /children/c2, /parents/p1
 /children/c3, /parents/p2
 null, /parents/p0
 
-select p.[jcr:path], c.[jcr:path] from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null
+select p.[jcr:path], c.[jcr:path]
+  from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
 /parents/p0, null
 /parents/p1, /children/c1
 /parents/p1, /children/c2
 /parents/p2, /children/c3
 
-select p.[jcr:path], c.[jcr:path] from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is null
+select p.[jcr:path], c.[jcr:path]
+  from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and c.p is null
 /parents/p0, null
 
-select p.[jcr:path], c.[jcr:path] from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is not null
+select p.[jcr:path], c.[jcr:path]
+  from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and c.p is not null
 /parents/p1, /children/c1
 /parents/p1, /children/c2
 /parents/p2, /children/c3
 
-select p.[jcr:path], c.[jcr:path] from [nt:base] as p inner join [nt:base] as c on p.id = c.p
+select p.[jcr:path], c.[jcr:path]
+  from [nt:base] as p
+  inner join [nt:base] as c on p.id = c.p
 /parents/p1, /children/c1
 /parents/p1, /children/c2
 /parents/p2, /children/c3
@@ -245,27 +361,42 @@ commit / + "testRoot": {}
 commit /testRoot + "test": { "hello": { "x": "1" }, "world": { "x": "2" } }
 commit /testRoot + "test2": { "id":"1", "x": "2" }
 
-select [jcr:path] from [nt:base] where isdescendantnode('/testRoot')
+select [jcr:path]
+  from [nt:base]
+  where isdescendantnode('/testRoot')
 /testRoot/test
 /testRoot/test/hello
 /testRoot/test/world
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where id = '1'
+select [jcr:path]
+  from [nt:base]
+  where id = '1'
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where id = '1' and x = '2'
+select [jcr:path]
+  from [nt:base]
+  where id = '1'
+  and x = '2'
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where id = '1' or x = '2'
+select [jcr:path]
+  from [nt:base]
+  where id = '1' or x = '2'
 /testRoot/test/world
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where not (id = '1' or x = '2') and isdescendantnode('/testRoot')
+select [jcr:path]
+  from [nt:base]
+  where not (id = '1' or x = '2')
+  and isdescendantnode('/testRoot')
 /testRoot/test
 /testRoot/test/hello
 
-select [jcr:path] from [nt:base] where x is null and isdescendantnode('/testRoot')
+select [jcr:path]
+  from [nt:base]
+  where x is null
+  and isdescendantnode('/testRoot')
 /testRoot/test
 
 commit /testRoot - "test"
@@ -277,50 +408,78 @@ commit /testRoot + "test3": { "name": "Hallo" }
 commit /testRoot + "test4": { "name": "10%" }
 commit /testRoot + "test5": { "name": "10 percent" }
 
-select name from [nt:base] where name is not null order by upper(name)
+select name
+  from [nt:base]
+  where name is not null order by upper(name)
 10 percent
 10%
 Hallo
 hello
 World!
 
-select [jcr:path] from [nt:base] where length(name) = 5
+select [jcr:path]
+  from [nt:base]
+  where length(name) = 5
 /testRoot/test
 /testRoot/test3
 
-select [jcr:path] from [nt:base] where upper(name) = 'HELLO'
+select [jcr:path]
+  from [nt:base]
+  where upper(name) = 'HELLO'
 /testRoot/test
 
-select [jcr:path] from [nt:base] where lower(name) = 'world!'
+select [jcr:path]
+  from [nt:base]
+  where lower(name) = 'world!'
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where name like 'W%'
+select [jcr:path]
+  from [nt:base]
+  where name like 'W%'
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where name like '%o_%'
+select [jcr:path]
+  from [nt:base]
+  where name like '%o_%'
 /testRoot/test2
 
-select [jcr:path] from [nt:base] where name like '__llo'
+select [jcr:path]
+  from [nt:base]
+  where name like '__llo'
 /testRoot/test
 /testRoot/test3
 
-select [jcr:path] from [nt:base] where upper(name) like 'H_LLO'
+select [jcr:path]
+  from [nt:base]
+  where upper(name) like 'H_LLO'
 /testRoot/test
 /testRoot/test3
 
-select [jcr:path] from [nt:base] where upper(name) like 'H\_LLO'
+select [jcr:path]
+  from [nt:base]
+  where upper(name) like 'H\_LLO'
 
-select [jcr:path] from [nt:base] where upper(name) like '10%'
+select [jcr:path]
+  from [nt:base]
+  where upper(name) like '10%'
 /testRoot/test4
 /testRoot/test5
 
-select [jcr:path] from [nt:base] where upper(name) like '10\%'
+select [jcr:path]
+  from [nt:base]
+  where upper(name) like '10\%'
 /testRoot/test4
 
 # errors
 
-select [jcr:path] from [nt:base] where name =+ 'Hello'
-java.text.ParseException: Query: select [jcr:path] from [nt:base] where name =+ 'Hello(*)'; expected: Illegal operation: + Hello
-
-select [jcr:path] from [nt:base] where name => 'Hello'
-java.text.ParseException: Query: select [jcr:path] from [nt:base] where name =>(*)'Hello'; expected: (, ., =, <>, <, >, <=, >=, LIKE, IN, IS, NOT
+select [jcr:path]
+  from [nt:base]
+  where name =+ 'Hello'
+java.text.ParseException: Query: select [jcr:path]
+  from [nt:base]
+  where name =+ 'Hello(*)'; expected: Illegal operation: + Hello
+
+select [jcr:path]
+  from [nt:base] where name => 'Hello'
+java.text.ParseException: Query: select [jcr:path]
+  from [nt:base] where name =>(*)'Hello'; expected: (, ., =, <>, <, >, <=, >=, LIKE, IN, IS, NOT
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt
index 2039dd5fbe..629d9da178 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt
@@ -14,6 +14,7 @@
 # limitations under the License.
 #
 # Syntax:
+# * lines that start with spaces belong to the previous line
 # * lines starting with "#" are remarks.
 # * lines starting with "select" are queries, followed by expected results and an empty line
 # * lines starting with "explain" are followed by expected query plan and an empty line
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
index 45c2d095b1..9c5e53d3b4 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
@@ -14,6 +14,7 @@
 # limitations under the License.
 #
 # Syntax:
+# * lines that start with spaces belong to the previous line
 # * lines starting with "#" are remarks.
 # * lines starting with "select" are queries, followed by expected results and an empty line
 # * lines starting with "explain" are followed by expected query plan and an empty line
@@ -23,73 +24,221 @@
 # * new tests are typically be added on top, after the syntax docs
 # * use ascii character only
 
-explain select e.[jcr:path] from [nt:base] as a inner join [nt:base] as b on ischildnode(b, a) inner join [nt:base] as c on ischildnode(c, b) inner join [nt:base] as d on ischildnode(d, c) inner join [nt:base] as e on ischildnode(e, d) where name(a) = 'a' and isdescendantnode(a, '/b') and name(b) = 'c' and name(c) = 'd' and name(d) = 'e' and (e.[jcr:uuid] = '1' or e.[jcr:uuid] = '2' or e.[jcr:uuid] = '3' or e.[jcr:uuid] = '4')
-[nt:base] as [e] /* property jcr:uuid where ([e].[jcr:uuid] is not null) and ([e].[jcr:uuid] in(cast('1' as string), cast('2' as string), cast('3' as string), cast('4' as string))) */ inner join [nt:base] as [d] /* traverse "* && //parent/of/join" where name([d]) = cast('e' as string) */ on ischildnode([e], [d]) inner join [nt:base] as [c] /* traverse "* && //parent/of/join" where name([c]) = cast('d' as string) */ on ischildnode([d], [c]) inner join [nt:base] as [b] /* traverse "* && //parent/of/join" where name([b]) = cast('c' as string) */ on ischildnode([c], [b]) inner join [nt:base] as [a] /* traverse "/b//* && //parent/of/join" where (name([a]) = cast('a' as string)) and (isdescendantnode([a], [/b])) */ on ischildnode([b], [a])
-
-explain select e.[jcr:path] from [nt:base] as a inner join [nt:base] as b on ischildnode(b, a) inner join [nt:base] as c on ischildnode(c, b) inner join [nt:base] as d on ischildnode(d, c) inner join [nt:base] as e on ischildnode(e, d) where name(a) = 'a' and isdescendantnode(a, '/b') and name(b) = 'c' and name(c) = 'd' and name(d) = 'e' and (e.[jcr:uuid] = '1' or e.[jcr:uuid] = '2' or e.[jcr:uuid] = '3' or e.[jcr:uuid] = '4')
-[nt:base] as [e] /* property jcr:uuid where ([e].[jcr:uuid] is not null) and ([e].[jcr:uuid] in(cast('1' as string), cast('2' as string), cast('3' as string), cast('4' as string))) */ inner join [nt:base] as [d] /* traverse "* && //parent/of/join" where name([d]) = cast('e' as string) */ on ischildnode([e], [d]) inner join [nt:base] as [c] /* traverse "* && //parent/of/join" where name([c]) = cast('d' as string) */ on ischildnode([d], [c]) inner join [nt:base] as [b] /* traverse "* && //parent/of/join" where name([b]) = cast('c' as string) */ on ischildnode([c], [b]) inner join [nt:base] as [a] /* traverse "/b//* && //parent/of/join" where (name([a]) = cast('a' as string)) and (isdescendantnode([a], [/b])) */ on ischildnode([b], [a])
-
-explain select excerpt(.) from [nt:resource] where contains(*, 'jackrabbit')
-[nt:resource] as [nt:resource] /* traverse "*" where contains([nt:resource].[*], cast('jackrabbit' as string)) */
-
-explain select excerpt(.) from [nt:resource] where contains(*, 'jackrabbit') or contains(*, 'jackrabbit')
-[nt:resource] as [nt:resource] /* traverse "*" where contains([nt:resource].[*], cast('jackrabbit' as string)) */
-
-explain select excerpt(.) from [nt:resource] where (contains(*, 'jackrabbit') or contains(*, 'jackrabbit')) and x = '1'
-[nt:resource] as [nt:resource] /* traverse "*" where (contains([nt:resource].[*], cast('jackrabbit' as string))) and ([nt:resource].[x] = cast('1' as string)) */
-
-explain select * from [nt:base] where [jcr:uuid]=1 or [b]=2
+explain select e.[jcr:path]
+  from [nt:base] as a
+  inner join [nt:base] as b on ischildnode(b, a)
+  inner join [nt:base] as c on ischildnode(c, b)
+  inner join [nt:base] as d on ischildnode(d, c)
+  inner join [nt:base] as e on ischildnode(e, d)
+  where name(a) = 'a'
+  and isdescendantnode(a, '/b')
+  and name(b) = 'c'
+  and name(c) = 'd'
+  and name(d) = 'e'
+  and (e.[jcr:uuid] = '1' or e.[jcr:uuid] = '2' or e.[jcr:uuid] = '3' or e.[jcr:uuid] = '4')
+[nt:base] as [e] /* property jcr:uuid
+  where ([e].[jcr:uuid] is not null)
+  and ([e].[jcr:uuid] in(cast('1' as string), cast('2' as string), cast('3' as string), cast('4' as string))) */
+  inner join [nt:base] as [d] /* traverse "* && //parent/of/join"
+  where name([d]) = cast('e' as string) */
+  on ischildnode([e], [d])
+  inner join [nt:base] as [c] /* traverse "* && //parent/of/join"
+  where name([c]) = cast('d' as string) */
+  on ischildnode([d], [c])
+  inner join [nt:base] as [b] /* traverse "* && //parent/of/join"
+  where name([b]) = cast('c' as string) */
+  on ischildnode([c], [b])
+  inner join [nt:base] as [a] /* traverse "/b//* && //parent/of/join"
+  where (name([a]) = cast('a' as string))
+  and (isdescendantnode([a], [/b])) */
+  on ischildnode([b], [a])
+
+explain select e.[jcr:path]
+  from [nt:base] as a
+  inner join [nt:base] as b on ischildnode(b, a)
+  inner join [nt:base] as c on ischildnode(c, b)
+  inner join [nt:base] as d on ischildnode(d, c)
+  inner join [nt:base] as e on ischildnode(e, d)
+  where name(a) = 'a'
+  and isdescendantnode(a, '/b')
+  and name(b) = 'c'
+  and name(c) = 'd'
+  and name(d) = 'e'
+  and (e.[jcr:uuid] = '1' or e.[jcr:uuid] = '2' or e.[jcr:uuid] = '3' or e.[jcr:uuid] = '4')
+[nt:base] as [e] /* property jcr:uuid
+  where ([e].[jcr:uuid] is not null)
+  and ([e].[jcr:uuid] in(cast('1' as string), cast('2' as string), cast('3' as string), cast('4' as string))) */
+  inner join [nt:base] as [d] /* traverse "* && //parent/of/join"
+  where name([d]) = cast('e' as string) */
+  on ischildnode([e], [d])
+  inner join [nt:base] as [c] /* traverse "* && //parent/of/join"
+  where name([c]) = cast('d' as string) */
+  on ischildnode([d], [c])
+  inner join [nt:base] as [b] /* traverse "* && //parent/of/join"
+  where name([b]) = cast('c' as string) */
+  on ischildnode([c], [b])
+  inner join [nt:base] as [a] /* traverse "/b//* && //parent/of/join"
+  where (name([a]) = cast('a' as string))
+  and (isdescendantnode([a], [/b])) */
+  on ischildnode([b], [a])
+
+explain select excerpt(.)
+  from [nt:resource]
+  where contains(*, 'jackrabbit')
+[nt:resource] as [nt:resource] /* traverse "*"
+  where contains([nt:resource].[*], cast('jackrabbit' as string)) */
+
+explain select excerpt(.)
+  from [nt:resource]
+  where contains(*, 'jackrabbit') or contains(*, 'jackrabbit')
+[nt:resource] as [nt:resource] /* traverse "*"
+  where contains([nt:resource].[*], cast('jackrabbit' as string)) */
+
+explain select excerpt(.)
+  from [nt:resource]
+  where (contains(*, 'jackrabbit') or contains(*, 'jackrabbit'))
+  and x = '1'
+[nt:resource] as [nt:resource] /* traverse "*"
+  where (contains([nt:resource].[*], cast('jackrabbit' as string)))
+  and ([nt:resource].[x] = cast('1' as string)) */
+
+explain select *
+  from [nt:base]
+  where [jcr:uuid]=1 or [b]=2
 [nt:base] as [nt:base] /* traverse "*" */
 
-explain select b.[jcr:uuid] from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where (a.[jcr:uuid] = '1' or a.[jcr:uuid] = '2')
-[nt:base] as [a] /* property jcr:uuid where ([a].[jcr:uuid] is not null) and ([a].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */ inner join [nt:base] as [b] /* traverse "* && //path/from/join//*" */ on isdescendantnode([b], [a])
-
-explain select b.[jcr:uuid] from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where (a.[jcr:uuid] = '1' or a.[jcr:uuid] = '2') and b.[jcr:uuid] is not null
-[nt:base] as [a] /* property jcr:uuid where ([a].[jcr:uuid] is not null) and ([a].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */ inner join [nt:base] as [b] /* property jcr:uuid where [b].[jcr:uuid] is not null */ on isdescendantnode([b], [a])
-
-explain select * from [nt:base] where length([jcr:uuid])=1 or upper([jcr:uuid])='1' or lower([jcr:uuid])='3'
-[nt:base] as [nt:base] /* property jcr:uuid where [nt:base].[jcr:uuid] is not null */
-
-explain select * from [nt:base] where [jcr:uuid] = '1' or ([jcr:uuid] = '2' and [b] = '3')
-[nt:base] as [nt:base] /* property jcr:uuid where ([nt:base].[jcr:uuid] is not null) and ([nt:base].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */
-
-explain select * from [nt:base] where [jcr:uuid] in('1', '2')
-[nt:base] as [nt:base] /* property jcr:uuid where [nt:base].[jcr:uuid] in(cast('1' as string), cast('2' as string)) */
-
-explain select * from [nt:base] where [jcr:uuid] = '1' or [jcr:uuid] = '2'
-[nt:base] as [nt:base] /* property jcr:uuid where ([nt:base].[jcr:uuid] is not null) and ([nt:base].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */
-
-explain select * from [nt:base] where [jcr:uuid] = '123'
-[nt:base] as [nt:base] /* property jcr:uuid=123 where [nt:base].[jcr:uuid] = cast('123' as string) */
-
-explain select * from [nt:base] where [jcr:uuid] is not null
-[nt:base] as [nt:base] /* property jcr:uuid where [nt:base].[jcr:uuid] is not null */
-
-explain select * from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where a.[jcr:uuid] is not null and b.[jcr:uuid] is not null
-[nt:base] as [a] /* property jcr:uuid where [a].[jcr:uuid] is not null */ inner join [nt:base] as [b] /* property jcr:uuid where [b].[jcr:uuid] is not null */ on isdescendantnode([b], [a])
-
-explain select * from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where (a.[jcr:uuid]=1 or a.[jcr:uuid]=2) and (b.[jcr:uuid]=3 or b.[jcr:uuid]=4)
-[nt:base] as [a] /* property jcr:uuid where ([a].[jcr:uuid] is not null) and ([a].[jcr:uuid] in(cast('1' as long), cast('2' as long))) */ inner join [nt:base] as [b] /* property jcr:uuid where ([b].[jcr:uuid] is not null) and ([b].[jcr:uuid] in(cast('3' as long), cast('4' as long))) */ on isdescendantnode([b], [a])
-
-explain select * from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where a.[jcr:uuid] is not null and b.[x] is not null
-[nt:base] as [a] /* property jcr:uuid where [a].[jcr:uuid] is not null */ inner join [nt:base] as [b] /* traverse "* && //path/from/join//*" where [b].[x] is not null */ on isdescendantnode([b], [a])
-
-explain select [rep:excerpt] from [nt:base] where [jcr:uuid] is not null
-[nt:base] as [nt:base] /* property jcr:uuid (rep:excerpt) where [nt:base].[jcr:uuid] is not null */
+explain select b.[jcr:uuid]
+  from [nt:base] as a
+  inner join [nt:base] as b on isdescendantnode(b, a)
+  where (a.[jcr:uuid] = '1' or a.[jcr:uuid] = '2')
+[nt:base] as [a] /* property jcr:uuid
+  where ([a].[jcr:uuid] is not null)
+  and ([a].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */
+  inner join [nt:base] as [b] /* traverse "* && //path/from/join//*" */
+  on isdescendantnode([b], [a])
+
+explain select b.[jcr:uuid]
+  from [nt:base] as a
+  inner join [nt:base] as b on isdescendantnode(b, a)
+  where (a.[jcr:uuid] = '1' or a.[jcr:uuid] = '2')
+  and b.[jcr:uuid] is not null
+[nt:base] as [a] /* property jcr:uuid
+  where ([a].[jcr:uuid] is not null)
+  and ([a].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */
+  inner join [nt:base] as [b] /* property jcr:uuid
+  where [b].[jcr:uuid] is not null */
+  on isdescendantnode([b], [a])
+
+explain select *
+  from [nt:base]
+  where length([jcr:uuid])=1 or upper([jcr:uuid])='1' or lower([jcr:uuid])='3'
+[nt:base] as [nt:base] /* property jcr:uuid
+  where [nt:base].[jcr:uuid] is not null */
+
+explain select *
+  from [nt:base]
+  where [jcr:uuid] = '1' or ([jcr:uuid] = '2'
+  and [b] = '3')
+[nt:base] as [nt:base] /* property jcr:uuid
+  where ([nt:base].[jcr:uuid] is not null)
+  and ([nt:base].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */
+
+explain select *
+  from [nt:base]
+  where [jcr:uuid] in('1', '2')
+[nt:base] as [nt:base] /* property jcr:uuid
+  where [nt:base].[jcr:uuid] in(cast('1' as string), cast('2' as string)) */
+
+explain select *
+  from [nt:base]
+  where [jcr:uuid] = '1' or [jcr:uuid] = '2'
+[nt:base] as [nt:base] /* property jcr:uuid
+  where ([nt:base].[jcr:uuid] is not null)
+  and ([nt:base].[jcr:uuid] in(cast('1' as string), cast('2' as string))) */
+
+explain select *
+  from [nt:base]
+  where [jcr:uuid] = '123'
+[nt:base] as [nt:base] /* property jcr:uuid=123
+  where [nt:base].[jcr:uuid] = cast('123' as string) */
+
+explain select *
+  from [nt:base]
+  where [jcr:uuid] is not null
+[nt:base] as [nt:base] /* property jcr:uuid
+  where [nt:base].[jcr:uuid] is not null */
+
+explain select *
+  from [nt:base] as a
+  inner join [nt:base] as b on isdescendantnode(b, a)
+  where a.[jcr:uuid] is not null
+  and b.[jcr:uuid] is not null
+[nt:base] as [a] /* property jcr:uuid
+  where [a].[jcr:uuid] is not null */
+  inner join [nt:base] as [b] /* property jcr:uuid
+  where [b].[jcr:uuid] is not null */
+  on isdescendantnode([b], [a])
+
+explain select *
+  from [nt:base] as a
+  inner join [nt:base] as b on isdescendantnode(b, a)
+  where (a.[jcr:uuid]=1 or a.[jcr:uuid]=2)
+  and (b.[jcr:uuid]=3 or b.[jcr:uuid]=4)
+[nt:base] as [a] /* property jcr:uuid
+  where ([a].[jcr:uuid] is not null)
+  and ([a].[jcr:uuid] in(cast('1' as long), cast('2' as long))) */
+  inner join [nt:base] as [b] /* property jcr:uuid
+  where ([b].[jcr:uuid] is not null)
+  and ([b].[jcr:uuid] in(cast('3' as long), cast('4' as long))) */
+  on isdescendantnode([b], [a])
+
+explain select *
+  from [nt:base] as a
+  inner join [nt:base] as b on isdescendantnode(b, a)
+  where a.[jcr:uuid] is not null
+  and b.[x] is not null
+[nt:base] as [a] /* property jcr:uuid
+  where [a].[jcr:uuid] is not null */
+  inner join [nt:base] as [b] /* traverse "* && //path/from/join//*"
+  where [b].[x] is not null */
+  on isdescendantnode([b], [a])
+
+explain select [rep:excerpt]
+  from [nt:base]
+  where [jcr:uuid] is not null
+[nt:base] as [nt:base] /* property jcr:uuid (rep:excerpt)
+  where [nt:base].[jcr:uuid] is not null */
 
 commit / + "test": { "jcr:uuid": "xyz", "a": { "jcr:uuid": "123" } }
 
-select [jcr:path] from [nt:base] where [jcr:uuid] is not null
+select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] is not null
 /test
 /test/a
 
-select [jcr:path] from [nt:base] where [jcr:uuid] = '123' union select [jcr:path] from [nt:base] where [jcr:uuid] = '312' union select [jcr:path] from [nt:base] where [jcr:uuid] = '231'
+select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] = '123'
+  union select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] = '312'
+  union select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] = '231'
 /test/a
 
-select [jcr:path] from [nt:base] where [jcr:uuid] = '123' union select [jcr:path] from [nt:base] where [jcr:uuid] = '312'
+select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] = '123'
+  union select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] = '312'
 /test/a
 
-select [jcr:path] from [nt:base] where [jcr:uuid] = 'xyz'
+select [jcr:path]
+  from [nt:base]
+  where [jcr:uuid] = 'xyz'
 /test
 
 commit / - "test"
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_measure.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_measure.txt
index 25f121315f..36500567a8 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_measure.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_measure.txt
@@ -14,6 +14,7 @@
 # limitations under the License.
 #
 # Syntax:
+# * lines that start with spaces belong to the previous line
 # * lines starting with "#" are remarks.
 # * lines starting with "select" are queries, followed by expected results and an empty line
 # * lines starting with "explain" are followed by expected query plan and an empty line
@@ -27,81 +28,138 @@ commit / + "testRoot": { }
 commit /testRoot + "parents": { "p0": {"id": "0"}, "p1": {"id": "1"}, "p2": {"id": "2"}}
 commit /testRoot + "children": { "c1": {"p": "1"}, "c2": {"p": "1"}, "c3": {"p": "2"}, "c4": {"p": "3"}}
 
-select p.[jcr:path], c.[jcr:path] from [nt:base] as p inner join [nt:base] as c on p.id = c.p where isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+select p.[jcr:path], c.[jcr:path] from [nt:base] as p
+  inner join [nt:base] as c on p.id = c.p
+  where isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 /testRoot/parents/p1, /testRoot/children/c1
 /testRoot/parents/p1, /testRoot/children/c2
 /testRoot/parents/p2, /testRoot/children/c3
 
-select [jcr:path] from [nt:base] as p where p.[testRoot/children/*/*] = '3'
+select [jcr:path] from [nt:base] as p
+  where p.[testRoot/children/*/*] = '3'
 /
 
-select [jcr:path], p.[children/c1/*] from [nt:base] as p where p.[children/c1/*] is not null
+select [jcr:path], p.[children/c1/*] from [nt:base] as p
+  where p.[children/c1/*] is not null
 /testRoot, [1]
 
-select [jcr:path], [jcr:score], * from [nt:base] as a where ([id] = '0' or [p0/id] = '0')
+select [jcr:path], [jcr:score], * from [nt:base] as a
+  where ([id] = '0' or [p0/id] = '0')
 /testRoot/parents, null, null
 /testRoot/parents/p0, null, null
 
-select [jcr:path], [jcr:score], * from [nt:base] as a where ([id] = '0' or [*/id] = '0')
+select [jcr:path], [jcr:score], * from [nt:base] as a
+  where ([id] = '0' or [*/id] = '0')
 /testRoot/parents, null, null
 /testRoot/parents/p0, null, null
 
-select c.[jcr:path], p.[jcr:path] from [nt:base] as c right outer join [nt:base] as p on p.id = c.p where p.id is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+select c.[jcr:path], p.[jcr:path] from [nt:base] as c
+  right outer join [nt:base] as p on p.id = c.p
+  where p.id is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 /testRoot/children/c1, /testRoot/parents/p1
 /testRoot/children/c2, /testRoot/parents/p1
 /testRoot/children/c3, /testRoot/parents/p2
 
-measure select * from [nt:base] as c right outer join [nt:base] as p on p.id = c.p where p.id is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as c
+  right outer join [nt:base] as p on p.id = c.p
+  where p.id is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-select p.[jcr:path], c.[jcr:path] from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+select p.[jcr:path], c.[jcr:path] from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 /testRoot/parents/p1, /testRoot/children/c1
 /testRoot/parents/p1, /testRoot/children/c2
 /testRoot/parents/p2, /testRoot/children/c3
 
-measure select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-measure select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and c.p is null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 0
 
-measure select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and c.p is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-measure select * from [nt:base] as p inner join [nt:base] as c on p.id = c.p where isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  inner join [nt:base] as c on p.id = c.p
+  where isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-measure select * from [nt:base] as c right outer join [nt:base] as p on p.id = c.p where p.id is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as c
+  right outer join [nt:base] as p on p.id = c.p
+  where p.id is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-measure select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-measure select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and c.p is null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 0
 
-measure select * from [nt:base] as p left outer join [nt:base] as c on p.id = c.p where p.id is not null and c.p is not null and isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  left outer join [nt:base] as c on p.id = c.p
+  where p.id is not null
+  and c.p is not null
+  and isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
 
-measure select * from [nt:base] as p inner join [nt:base] as c on p.id = c.p where isdescendantnode(p, '/testRoot') and isdescendantnode(c, '/testRoot')
+measure select * from [nt:base] as p
+  inner join [nt:base] as c on p.id = c.p
+  where isdescendantnode(p, '/testRoot')
+  and isdescendantnode(c, '/testRoot')
 c, 30
 p, 10
 query, 3
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt
index cb3971b0c1..d2744e0aae 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt
@@ -14,6 +14,7 @@
 # limitations under the License.
 #
 # Syntax:
+# * lines that start with spaces belong to the previous line
 # * lines starting with "#" are remarks.
 # * lines starting with "select" are queries, followed by expected results and an empty line
 # * lines starting with "explain" are followed by expected query plan and an empty line
