diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
index af9e82ef53..a15386c767 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
@@ -131,14 +131,15 @@ public interface Query {
     boolean isSortedByIndex();
     
     /**
-     * Perform optimisation on the object itself. To avoid any potential error due to state
-     * variables perfom the optimisation before the {@link #init()}.
+     * Try to convert the query to an alternative form, specially a "union". To
+     * avoid any potential error due to state variables perform the conversion
+     * before the {@link #init()}.
      * 
-     * @return {@code this} if no optimisations are possible or a new instance of a {@link Query}.
-     *         Cannot return null.
+     * @return {@code this} if no conversions are possible or a new instance of
+     *         a {@link Query}. Cannot return null.
      */
     @Nonnull
-    Query optimise();
+    Query buildAlternativeQuery();
     
     /**
      * <p>
@@ -161,12 +162,6 @@ public interface Query {
      */
     boolean isInit();
     
-    /**
-     * @return {@code true} if the query is a result of optimisations. {@code false} if it's the
-     *         originally computed one.
-     */
-    boolean isOptimised();
-    
     /**
      * @return the original statement as it was used to construct the object. If not provided the
      *         {@link #toString()} will be used instead.
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
index 90b469b7f5..a4aa7f474d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
@@ -18,11 +18,11 @@ package org.apache.jackrabbit.oak.query;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.ImmutableSet.of;
-import static com.google.common.collect.Sets.newHashSet;
 import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;
 
 import java.text.ParseException;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -49,24 +49,26 @@ import org.slf4j.MDC;
 public abstract class QueryEngineImpl implements QueryEngine {
     
     /**
-     * used to instruct the {@link QueryEngineImpl} on how to act with respect of the SQL2
+     * Used to instruct the {@link QueryEngineImpl} on how to act with respect of the SQL2
      * optimisation.
      */
-    public static enum ForceOptimised {
+    public static enum QuerySelectionMode {
+        
         /**
-         * will force the original SQL2 query to be executed
+         * Will execute the cheapest (default).
          */
-        ORIGINAL, 
-        
+        CHEAPEST,
+
         /**
-         * will force the computed optimised query to be executed. If available.
+         * Will use the original SQL2 query.
          */
-        OPTIMISED, 
+        ORIGINAL, 
         
         /**
-         * will execute the cheapest.
+         * Will force the computed alternate query to be executed. If available.
          */
-        CHEAPEST
+        ALTERNATIVE
+        
     }
 
     private static final AtomicInteger ID_COUNTER = new AtomicInteger();
@@ -95,10 +97,11 @@ public abstract class QueryEngineImpl implements QueryEngine {
     private boolean traversalEnabled = true;
     
     /**
-     * Whether the query engine should be forced to use the optimised version of the query if
-     * available.
+     * Which query to select in case multiple options are available. Whether the
+     * query engine should pick the one with the lowest expected cost (default),
+     * or the original, or the alternative.
      */
-    private ForceOptimised forceOptimised = ForceOptimised.CHEAPEST;
+    private QuerySelectionMode querySelectionMode = QuerySelectionMode.CHEAPEST;
 
     /**
      * Get the execution context for a single query execution.
@@ -125,12 +128,22 @@ public abstract class QueryEngineImpl implements QueryEngine {
     public List<String> getBindVariableNames(
             String statement, String language, Map<String, String> mappings)
             throws ParseException {
-        Set<Query> qs = parseQuery(statement, language, getExecutionContext(), mappings);
+        List<Query> qs = parseQuery(statement, language, getExecutionContext(), mappings);
         
         return qs.iterator().next().getBindVariableNames();
     }
 
-    private static Set<Query> parseQuery(
+    /**
+     * Parse the query.
+     * 
+     * @param statement the statement
+     * @param language the language
+     * @param context the context
+     * @param mappings the mappings
+     * @return the list of queries, where the first is the original, and all
+     *         others are alternatives (for example, a "union" query)
+     */
+    private static List<Query> parseQuery(
             String statement, String language, ExecutionContext context,
             Map<String, String> mappings) throws ParseException {
         
@@ -156,7 +169,7 @@ public abstract class QueryEngineImpl implements QueryEngine {
             parser.setAllowTextLiterals(false);
         }
         
-        Set<Query> queries = newHashSet();
+        ArrayList<Query> queries = new ArrayList<Query>();
         
         Query q;
         
@@ -190,9 +203,9 @@ public abstract class QueryEngineImpl implements QueryEngine {
                 LOG.trace("Skipping optimisation as internal query.");
             } else {
                 LOG.trace("Attempting optimisation");
-                Query q2 = q.optimise();
+                Query q2 = q.buildAlternativeQuery();
                 if (q2 != q) {
-                    LOG.debug("Optimised query available. {}", q2);
+                    LOG.debug("Alternative query available: {}", q2);
                     queries.add(q2);
                 }
             }
@@ -241,7 +254,7 @@ public abstract class QueryEngineImpl implements QueryEngine {
         }
 
         ExecutionContext context = getExecutionContext();
-        Set<Query> queries = parseQuery(statement, language, context, mappings);
+        List<Query> queries = parseQuery(statement, language, context, mappings);
         
         for (Query q : queries) {
             q.setExecutionContext(context);
@@ -257,7 +270,7 @@ public abstract class QueryEngineImpl implements QueryEngine {
 
         boolean mdc = false;
         try {
-            Query query = prepareAndGetCheapest(queries); 
+            Query query = prepareAndSelect(queries); 
             mdc = setupMDC(query);
             return query.executeQuery();
         } finally {
@@ -268,29 +281,29 @@ public abstract class QueryEngineImpl implements QueryEngine {
     }
     
     /**
-     * will prepare all the available queries and by based on the {@link ForceOptimised} flag return
+     * Prepare all the available queries and by based on the {@link QuerySelectionMode} flag return
      * the appropriate.
      * 
-     * @param queries the list of queries to be executed. cannot be null
-     * @return
+     * @param queries the list of queries to be executed. Cannot be null.
+     *      If there are multiple, the first one is the original, and the second the alternative.
+     * @return the query
      */
     @Nonnull
-    private Query prepareAndGetCheapest(@Nonnull final Set<Query> queries) {
+    private Query prepareAndSelect(@Nonnull List<Query> queries) {
         Query result = null;
         
         if (checkNotNull(queries).size() == 1) {
             // we only have the original query so we prepare and return it.
             result = queries.iterator().next();
             result.prepare();
-            LOG.debug("No optimisations found. Query: {}", result);
+            LOG.debug("No alternatives found. Query: {}", result);
         } else {
             double bestCost = Double.POSITIVE_INFINITY;
-            double originalCost = Double.POSITIVE_INFINITY;
-            Query original = null;
             
-            // always prepare all of the queries and compute the cheapest as it's the default behaviour.
-            // It should trigger more errors during unit and integration testing. Changing
-            // `forceOptimised` flag should be in case used only during testing.
+            // Always prepare all of the queries and compute the cheapest as
+            // it's the default behaviour. That way, we always log the cost and
+            // can more easily analyze problems. The querySelectionMode flag can
+            // be used to override the cheapest.
             for (Query q : checkNotNull(queries)) {
                 q.prepare();
                 double cost = q.getEstimatedCost();
@@ -303,50 +316,22 @@ public abstract class QueryEngineImpl implements QueryEngine {
                     result = q;
                     bestCost = cost;
                 }
-                if (!q.isOptimised()) {
-                    original = q;
-                    originalCost = cost;
-                }
-            }
-            
-            if (original != null && bestCost == originalCost && result != original) {
-                // if the optimised cost is the same as the original SQL2 query we prefer the original. As
-                // we deal with references the `cheapest!=original` should work.
-                LOG.trace("Same cost for original and optimised. Using original");
-                result = original;
             }
 
-            switch (forceOptimised) {
+            switch (querySelectionMode) {
             case ORIGINAL:
                 LOG.debug("Forcing the original SQL2 query to be executed by flag");
-                for (Query q  : checkNotNull(queries)) {
-                    if (!q.isOptimised()) {
-                        result = q;
-                    }
-                }
+                result = queries.get(0);
                 break;
 
-            case OPTIMISED:
-                LOG.debug("Forcing the optimised SQL2 query to be executed by flag");
-                for (Query q  : checkNotNull(queries)) {
-                    if (q.isOptimised()) {
-                        result = q;
-                    }
-                }
+            case ALTERNATIVE:
+                LOG.debug("Forcing the alternative SQL2 query to be executed by flag");
+                result = queries.get(1);
                 break;
 
             // CHEAPEST is the default behaviour
             case CHEAPEST:
             default:
-                if (result == null) {
-                    // this should not really happen. Defensive coding.
-                    LOG.debug("Cheapest is null. Returning the original SQL2 query.");
-                    for (Query q  : checkNotNull(queries)) {
-                        if (!q.isOptimised()) {
-                            result = q;
-                        }
-                    }
-                }
             }
         }
         
@@ -380,9 +365,9 @@ public abstract class QueryEngineImpl implements QueryEngine {
      * Instruct the query engine on how to behave with regards to the SQL2 optimised query if
      * available.
      * 
-     * @param forceOptimised cannot be null
+     * @param querySelectionMode cannot be null
      */
-    protected void setForceOptimised(@Nonnull ForceOptimised forceOptimised) {
-        this.forceOptimised = forceOptimised;
+    protected void setQuerySelectionMode(@Nonnull QuerySelectionMode querySelectionMode) {
+        this.querySelectionMode = querySelectionMode;
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java
index 9583ae2f21..3862472cc4 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java
@@ -172,11 +172,6 @@ public class QueryImpl implements Query {
      * whether the object has been initialised or not
      */
     private boolean init;
-    
-    /**
-     * whether the query is a result of optimisation or original one.
-     */
-    private boolean optimised;
 
     private boolean isSortedByIndex;
 
@@ -191,20 +186,13 @@ public class QueryImpl implements Query {
     private boolean isInternal;
 
     QueryImpl(String statement, SourceImpl source, ConstraintImpl constraint,
-            ColumnImpl[] columns, NamePathMapper mapper, QueryEngineSettings settings) {
-        this(statement, source, constraint, columns, mapper, settings, false);
-    }
-
-    QueryImpl(String statement, SourceImpl source, ConstraintImpl constraint,
-        ColumnImpl[] columns, NamePathMapper mapper, QueryEngineSettings settings, 
-        final boolean optimised) {
+        ColumnImpl[] columns, NamePathMapper mapper, QueryEngineSettings settings) {
         this.statement = statement;
         this.source = source;
         this.constraint = constraint;
         this.columns = columns;
         this.namePathMapper = mapper;
         this.settings = settings;
-        this.optimised = optimised;
     }
 
     @Override
@@ -1198,12 +1186,11 @@ public class QueryImpl implements Query {
     }
 
     @Override
-    public Query optimise() {
-        // optimising for UNION
-        Query optimised = this;
+    public Query buildAlternativeQuery() {
+        Query result = this;
         
         if (constraint != null) {
-            Set<ConstraintImpl> unionList = constraint.simplifyForUnion();
+            Set<ConstraintImpl> unionList = constraint.convertToUnion();
             if (unionList.size() > 1) {
                 // there are some cases where multiple ORs simplify into a single one. If we get a
                 // union list of just one we don't really have to UNION anything.
@@ -1212,7 +1199,7 @@ public class QueryImpl implements Query {
                 // we have something to do here.
                 for (ConstraintImpl c : unionList) {
                     if (right != null) {
-                        right = newOptimisedUnionQuery(left, right);
+                        right = newAlternativeUnionQuery(left, right);
                     } else {
                         // pulling left to the right
                         if (left != null) {
@@ -1221,7 +1208,7 @@ public class QueryImpl implements Query {
                     }
                     
                     // cloning original query
-                    left = (QueryImpl) this.copyOf(true);
+                    left = (QueryImpl) this.copyOf();
                     
                     // cloning the constraints and assigning to new query
                     left.constraint = (ConstraintImpl) copyElementAndCheckReference(c);
@@ -1229,11 +1216,11 @@ public class QueryImpl implements Query {
                     left.statement = recomposeStatement(left);
                 }
                 
-                optimised = newOptimisedUnionQuery(left, right);
+                result = newAlternativeUnionQuery(left, right);
             }
         }
         
-        return optimised;
+        return result;
     }
     
     private static String recomposeStatement(@Nonnull QueryImpl query) {
@@ -1258,29 +1245,26 @@ public class QueryImpl implements Query {
     }
     
     /**
-     * convenience method for creating a UnionQueryImpl with proper settings.
+     * Convenience method for creating a UnionQueryImpl with proper settings.
      * 
-     * @param left
-     * @param right
-     * @return
+     * @param left the first subquery
+     * @param right the second subquery
+     * @return the union query
      */
-    private UnionQueryImpl newOptimisedUnionQuery(@Nonnull Query left, @Nonnull Query right) {
+    private UnionQueryImpl newAlternativeUnionQuery(@Nonnull Query left, @Nonnull Query right) {
         UnionQueryImpl u = new UnionQueryImpl(
             false, 
             checkNotNull(left, "`left` cannot be null"), 
             checkNotNull(right, "`right` cannot be null"),
-            this.settings, 
-            true);
+            this.settings);
         u.setExplain(explain);
+        u.setMeasure(measure);
+        u.setInternal(isInternal);
         return u;
     }
     
     @Override
-    public Query copyOf() throws IllegalStateException {
-        return copyOf(false);
-    }
-    
-    private Query copyOf(final boolean optimised) {
+    public Query copyOf() {
         if (isInit()) {
             throw new IllegalStateException("QueryImpl cannot be cloned once initialised.");
         }
@@ -1296,8 +1280,7 @@ public class QueryImpl implements Query {
             this.constraint,
             cols.toArray(new ColumnImpl[0]),
             this.namePathMapper,
-            this.settings,
-            optimised);
+            this.settings);
         copy.explain = this.explain;
         copy.distinct = this.distinct;
         
@@ -1309,11 +1292,6 @@ public class QueryImpl implements Query {
         return init;
     }
 
-    @Override
-    public boolean isOptimised() {
-        return optimised;
-    }
-
     @Override
     public boolean isInternal() {
         return isInternal;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
index 269cc46b25..74eae41f7f 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
@@ -56,22 +56,12 @@ public class UnionQueryImpl implements Query {
     private final QueryEngineSettings settings;
     private boolean isInternal;
     
-    /**
-     * whether the query is a result of optimisation or not
-     */
-    private boolean optimised;
-    
-    UnionQueryImpl(boolean unionAll, Query left, Query right, QueryEngineSettings settings) {
-        this(unionAll, left, right, settings, false);
-    }
-
     UnionQueryImpl(final boolean unionAll, final Query left, final Query right,
-                   final QueryEngineSettings settings, final boolean optimised) {
+                   final QueryEngineSettings settings) {
         this.unionAll = unionAll;
         this.left = left;
         this.right = right;
         this.settings = settings;
-        this.optimised = optimised;
     }
 
     @Override
@@ -370,7 +360,7 @@ public class UnionQueryImpl implements Query {
     }
 
     @Override
-    public Query optimise() {
+    public Query buildAlternativeQuery() {
         return this;
     }
 
@@ -384,11 +374,6 @@ public class UnionQueryImpl implements Query {
         return left.isInit() || right.isInit();
     }
 
-    @Override
-    public boolean isOptimised() {
-        return optimised;
-    }
-
     @Override
     public String getStatement() {
         return toString();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java
index 993a2cd1aa..a6d4ceb710 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/AndImpl.java
@@ -219,17 +219,17 @@ public class AndImpl extends ConstraintImpl {
     }
 
     @Override
-    public Set<ConstraintImpl> simplifyForUnion() {
+    public Set<ConstraintImpl> convertToUnion() {
         Set<ConstraintImpl> union = Sets.newHashSet();
         Set<ConstraintImpl> result = Sets.newHashSet();
         Set<ConstraintImpl> nonUnion = Sets.newHashSet();
         
         for (ConstraintImpl c : constraints) {
-            Set<ConstraintImpl> ccc = c.simplifyForUnion();
-            if (ccc.isEmpty()) {
+            Set<ConstraintImpl> converted = c.convertToUnion();
+            if (converted.isEmpty()) {
                 nonUnion.add(c);
             } else {
-                union.addAll(ccc);
+                union.addAll(converted);
             }
         }
         if (!union.isEmpty() && nonUnion.size() == 1) {
@@ -240,7 +240,7 @@ public class AndImpl extends ConstraintImpl {
                 result.add(new AndImpl(c, right));
             }
         } else {
-            // in this case prefer to be conservative and don't optimise. This could happen when for
+            // in this case prefer to be conservative and don't optimize. This could happen when for
             // example: WHERE (a OR b) AND (c OR d).
             // This should be translated into a AND c, a AND d, b AND c, b AND d.
         }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ConstraintImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ConstraintImpl.java
index 8d0c5085e9..24f1407235 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ConstraintImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ConstraintImpl.java
@@ -161,23 +161,21 @@ public abstract class ConstraintImpl extends AstElement {
     }
     
     /**
+     * Compute a set of sub-constraints that could be used for composing UNION
+     * statements. For example in case of "c=1 or c=2", it will return to the
+     * caller {@code [c=1, c=2]}. Those can be later on used for re-composing
+     * conditions.
      * <p>
-     * Compute a Set of sub-constraints that could be used for composing UNION statements. For
-     * example in case of {@code OR (c1, c2)} it will return to the caller {@code [c1, c2]}. Those
-     * can be later on used for re-composing conditions.
-     * </p>
+     * If it is not possible to convert to a union, it must return an empty set.
      * <p>
-     * If no union optimisations are possible it must return an empty set.
-     * </p>
-     * <p>
-     * Default implementation in {@link ConstraintImpl#simplifyForUnion()} always return an empty
-     * set.
-     * </p>
+     * The default implementation in {@link ConstraintImpl#convertToUnion()}
+     * always return an empty set.
      * 
-     * @return the set of constraints, if available
+     * @return the set of union constraints, if available, or an empty set if
+     *         conversion is not possible
      */
     @Nonnull
-    public Set<ConstraintImpl> simplifyForUnion() {
+    public Set<ConstraintImpl> convertToUnion() {
         return Collections.emptySet();
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/OrImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/OrImpl.java
index 43c11bdee0..880ef028e7 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/OrImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/OrImpl.java
@@ -358,17 +358,17 @@ public class OrImpl extends ConstraintImpl {
     }
 
     @Override
-    public Set<ConstraintImpl> simplifyForUnion() {
-        Set<ConstraintImpl> cc = Sets.newHashSet();
+    public Set<ConstraintImpl> convertToUnion() {
+        Set<ConstraintImpl> result = Sets.newHashSet();
         for (ConstraintImpl c : getConstraints()) {
-            Set<ConstraintImpl> ccc = c.simplifyForUnion(); 
-            if (ccc.isEmpty()) {
-                cc.add(c);
+            Set<ConstraintImpl> converted = c.convertToUnion(); 
+            if (converted.isEmpty()) {
+                result.add(c);
             } else {
-                cc.addAll(ccc);
+                result.addAll(converted);
             }
         }
-        return cc;
+        return result;
     }
 
     @Override
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/MultiPropertyOrTestOptimisation.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/MultiPropertyOrTestOptimisation.java
index c90fba2b72..2d51cc6629 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/MultiPropertyOrTestOptimisation.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/MultiPropertyOrTestOptimisation.java
@@ -16,7 +16,7 @@
  */
 package org.apache.jackrabbit.oak.plugins.index.property;
 
-import static org.apache.jackrabbit.oak.query.QueryEngineImpl.ForceOptimised.OPTIMISED;
+import static org.apache.jackrabbit.oak.query.QueryEngineImpl.QuerySelectionMode.ALTERNATIVE;
 
 import org.junit.Before;
 
@@ -29,7 +29,7 @@ public class MultiPropertyOrTestOptimisation extends MultiPropertyOrTest {
     @Before
     public void before() throws Exception {
         super.before();
-        setForceOptimised(OPTIMISED);
+        setQuerySelectionMode(ALTERNATIVE);
         setTraversalEnabled(false);
     }    
 }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java
index aeb1f11a97..d901d7b107 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/AbstractQueryTest.java
@@ -56,7 +56,7 @@ import org.apache.jackrabbit.oak.json.TypeCodes;
 import org.apache.jackrabbit.oak.plugins.memory.BooleanPropertyState;
 import org.apache.jackrabbit.oak.plugins.memory.StringPropertyState;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
-import org.apache.jackrabbit.oak.query.QueryEngineImpl.ForceOptimised;
+import org.apache.jackrabbit.oak.query.QueryEngineImpl.QuerySelectionMode;
 import org.apache.jackrabbit.oak.query.xpath.XPathToSQL2Converter;
 import org.junit.Before;
 
@@ -329,8 +329,8 @@ public abstract class AbstractQueryTest {
         ((QueryEngineImpl) qe).setTraversalEnabled(traversalEnabled);
     }
     
-    protected void setForceOptimised(@Nonnull ForceOptimised forceOptimised) {
-        ((QueryEngineImpl) qe).setForceOptimised(checkNotNull(forceOptimised));
+    protected void setQuerySelectionMode(@Nonnull QuerySelectionMode querySelectionMode) {
+        ((QueryEngineImpl) qe).setQuerySelectionMode(checkNotNull(querySelectionMode));
     }
 
     protected static String readRow(ResultRow row, boolean pathOnly) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/FilterTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/FilterTest.java
index 4fb47f3eb3..f562a5a560 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/FilterTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/FilterTest.java
@@ -17,11 +17,11 @@
 
 package org.apache.jackrabbit.oak.query;
 
-import static junit.framework.Assert.assertFalse;
 import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;
 import static org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent.INITIAL_CONTENT;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 
 import java.text.ParseException;
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2OptimiseQueryTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2OptimiseQueryTest.java
index a340770d74..cf671e012f 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2OptimiseQueryTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2OptimiseQueryTest.java
@@ -24,9 +24,9 @@ import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;
 import static org.apache.jackrabbit.oak.api.Type.NAME;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.NT_OAK_UNSTRUCTURED;
-import static org.apache.jackrabbit.oak.query.QueryEngineImpl.ForceOptimised.CHEAPEST;
-import static org.apache.jackrabbit.oak.query.QueryEngineImpl.ForceOptimised.OPTIMISED;
-import static org.apache.jackrabbit.oak.query.QueryEngineImpl.ForceOptimised.ORIGINAL;
+import static org.apache.jackrabbit.oak.query.QueryEngineImpl.QuerySelectionMode.CHEAPEST;
+import static org.apache.jackrabbit.oak.query.QueryEngineImpl.QuerySelectionMode.ALTERNATIVE;
+import static org.apache.jackrabbit.oak.query.QueryEngineImpl.QuerySelectionMode.ORIGINAL;
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
@@ -97,11 +97,11 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
         statement = String.format("SELECT * FROM [%s] WHERE p = 'a' OR p = 'b'",
             NT_OAK_UNSTRUCTURED);
         expected = of("/test/a", "/test/b", "/test2/a");
-        setForceOptimised(ORIGINAL);
+        setQuerySelectionMode(ORIGINAL);
         original = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(OPTIMISED);
+        setQuerySelectionMode(ALTERNATIVE);
         optimised = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(CHEAPEST);
+        setQuerySelectionMode(CHEAPEST);
         cheapest = executeQuery(statement, JCR_SQL2, true);
         assertOrToUnionResults(expected, original, optimised, cheapest);
         
@@ -109,11 +109,11 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
             "SELECT * FROM [%s] WHERE p = 'a' OR p = 'b' OR p = 'c' OR p = 'd' OR p = 'e' ",
             NT_OAK_UNSTRUCTURED);
         expected = of("/test/a", "/test/b", "/test/c", "/test/d", "/test/e", "/test2/a");
-        setForceOptimised(ORIGINAL);
+        setQuerySelectionMode(ORIGINAL);
         original = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(OPTIMISED);
+        setQuerySelectionMode(ALTERNATIVE);
         optimised = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(CHEAPEST);
+        setQuerySelectionMode(CHEAPEST);
         cheapest = executeQuery(statement, JCR_SQL2, true);
         assertOrToUnionResults(expected, original, optimised, cheapest);
 
@@ -121,11 +121,11 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
             "SELECT * FROM [%s] WHERE (p = 'a' OR p = 'b') AND (p1 = 'a1' OR p1 = 'b1')",
             NT_OAK_UNSTRUCTURED);
         expected = of("/test/a", "/test/b");
-        setForceOptimised(ORIGINAL);
+        setQuerySelectionMode(ORIGINAL);
         original = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(OPTIMISED);
+        setQuerySelectionMode(ALTERNATIVE);
         optimised = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(CHEAPEST);
+        setQuerySelectionMode(CHEAPEST);
         cheapest = executeQuery(statement, JCR_SQL2, true);
         assertOrToUnionResults(expected, original, optimised, cheapest);
 
@@ -133,11 +133,11 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
             "SELECT * FROM [%s] WHERE (p = 'a' AND p1 = 'a1') OR (p = 'b' AND p1 = 'b1')",
             NT_OAK_UNSTRUCTURED);
         expected = of("/test/a", "/test/b");
-        setForceOptimised(ORIGINAL);
+        setQuerySelectionMode(ORIGINAL);
         original = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(OPTIMISED);
+        setQuerySelectionMode(ALTERNATIVE);
         optimised = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(CHEAPEST);
+        setQuerySelectionMode(CHEAPEST);
         cheapest = executeQuery(statement, JCR_SQL2, true);
         assertOrToUnionResults(expected, original, optimised, cheapest);
         
@@ -148,11 +148,11 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
             + "AND ISDESCENDANTNODE(c, '/test') "
             + "ORDER BY added DESC";
         expected = of("/test/a", "/test/b", "/test/c");
-        setForceOptimised(ORIGINAL);
+        setQuerySelectionMode(ORIGINAL);
         original = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(OPTIMISED);
+        setQuerySelectionMode(ALTERNATIVE);
         optimised = executeQuery(statement, JCR_SQL2, true);
-        setForceOptimised(CHEAPEST);
+        setQuerySelectionMode(CHEAPEST);
         cheapest = executeQuery(statement, JCR_SQL2, true);
         assertOrToUnionResults(expected, original, optimised, cheapest);
     }
@@ -197,7 +197,7 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
                 + "(c.[p1]='a' OR c.[p2]='b') ";
         original = parser.parse(statement, false);
         assertNotNull(original);
-        optimised = original.optimise();
+        optimised = original.buildAlternativeQuery();
         assertNotNull(optimised);
         assertNotSame(original, optimised);
         assertTrue(optimised instanceof UnionQueryImpl);
@@ -210,7 +210,7 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
                 + "ISDESCENDANTNODE(c, '/test') ";
         original = parser.parse(statement, false);
         assertNotNull(original);
-        optimised = original.optimise();
+        optimised = original.buildAlternativeQuery();
         assertNotNull(optimised);
         assertNotSame(original, optimised);
         
@@ -222,7 +222,7 @@ public class SQL2OptimiseQueryTest extends  AbstractQueryTest {
                 + "ISDESCENDANTNODE(c, '/test') ";
         original = parser.parse(statement, false);
         assertNotNull(original);
-        optimised = original.optimise();
+        optimised = original.buildAlternativeQuery();
         assertNotNull(optimised);
         assertNotSame(original, optimised);
     }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java
index 0a28376453..8118198b10 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java
@@ -16,10 +16,10 @@
  */
 package org.apache.jackrabbit.oak.query;
 
-import static junit.framework.Assert.assertTrue;
 import static org.apache.jackrabbit.JcrConstants.JCR_SYSTEM;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_NODE_TYPES;
 import static org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent.INITIAL_CONTENT;
+import static org.junit.Assert.assertTrue;
 
 import java.text.ParseException;
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/AndImplTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/AndImplTest.java
index 504d204b84..2ca4f8662c 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/AndImplTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/AndImplTest.java
@@ -40,7 +40,7 @@ public class AndImplTest {
         op2 = mock(ComparisonImpl.class);
         and = new AndImpl(op1, op2);
         expected = emptySet();
-        assertThat(and.simplifyForUnion(), is(expected));
+        assertThat(and.convertToUnion(), is(expected));
 
         op1 = mockConstraint("op1", ComparisonImpl.class);
         op2 = mockConstraint("op2", ComparisonImpl.class);
@@ -50,7 +50,7 @@ public class AndImplTest {
             (ConstraintImpl) new AndImpl(op1, op3)
             , (ConstraintImpl) new AndImpl(op2, op3)
         );
-        assertThat(and.simplifyForUnion(), is(expected));
+        assertThat(and.convertToUnion(), is(expected));
 
         op1 = mockConstraint("op1", ComparisonImpl.class);
         op2 = mockConstraint("op2", ComparisonImpl.class);
@@ -62,7 +62,7 @@ public class AndImplTest {
             , (ConstraintImpl) new AndImpl(op2, op3)
             , (ConstraintImpl) new AndImpl(op4, op3)
         );
-        assertThat(and.simplifyForUnion(), is(expected));
+        assertThat(and.convertToUnion(), is(expected));
 }
     
     /**
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/OrImplTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/OrImplTest.java
index 0416d6e925..decc68ce65 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/OrImplTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/ast/OrImplTest.java
@@ -35,14 +35,14 @@ public class OrImplTest {
         op2 = mock(ComparisonImpl.class);
         or = new OrImpl(op1, op2);
         expected = of(op1, op2);
-        assertThat(or.simplifyForUnion(), is(expected));
+        assertThat(or.convertToUnion(), is(expected));
         
         op1 = mock(ComparisonImpl.class);
         op2 = mock(ComparisonImpl.class);
         op3 = mock(ComparisonImpl.class);
         or = new OrImpl(new OrImpl(op1, op2), op3);
         expected = of(op1, op2, op3);
-        assertThat(or.simplifyForUnion(), is(expected));
+        assertThat(or.convertToUnion(), is(expected));
 
         op1 = mock(ComparisonImpl.class);
         op2 = mock(ComparisonImpl.class);
@@ -50,6 +50,6 @@ public class OrImplTest {
         op4 = mock(ComparisonImpl.class);
         or = new OrImpl(new OrImpl(new OrImpl(op1, op4), op2), op3);
         expected = of(op1, op2, op3, op4);
-        assertThat(or.simplifyForUnion(), is(expected));
+        assertThat(or.convertToUnion(), is(expected));
     }
 }
