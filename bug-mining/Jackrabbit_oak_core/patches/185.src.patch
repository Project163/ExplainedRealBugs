diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java
index 462d5b0d4a..e7b494018a 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndex.java
@@ -70,21 +70,31 @@ class NodeTypeIndex implements QueryIndex, JcrConstants {
             throw new IllegalStateException(
                     "NodeType index is used even when no index is available for filter " + filter);
         }
-        return Cursors.newPathCursor(lookup.find(
+        return Cursors.newPathCursor(lookup.query(
                 resolveNodeType(root, filter.getNodeType())));
     }
-
+    
     @Override
     public String getPlan(Filter filter, NodeState root) {
-        // TODO: return plan according to query()
-        return null;
+        return "nodeType " + filter.getNodeType() + " path " + filter.getPath();
+    }
+
+    @Deprecated
+    public Cursor queryOld(Filter filter, NodeState root) {
+        NodeTypeIndexLookup lookup = new NodeTypeIndexLookup(root);
+        if (!hasNodeTypeRestriction(filter) || !lookup.isIndexed(filter.getPath())) {
+            throw new IllegalStateException(
+                    "NodeType index is used even when no index is available for filter " + filter);
+        }
+        return Cursors.newPathCursor(lookup.find(
+                resolveNodeType(root, filter.getNodeType())));
     }
 
     @Override
     public String getIndexName() {
-        return "nodetype";
+        return "nodeType";
     }
-
+    
     //----------------------------< internal >----------------------------------
 
     private static boolean hasNodeTypeRestriction(Filter filter) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java
index 59cee7a769..a601064fad 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/nodetype/NodeTypeIndexLookup.java
@@ -24,6 +24,7 @@ import org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexLookup;
 import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 
 /**
@@ -79,6 +80,7 @@ class NodeTypeIndexLookup implements JcrConstants {
      * @param nodeTypes the names of the node types to match.
      * @return the set of matched paths.
      */
+    @Deprecated
     public Set<String> find(Iterable<String> nodeTypes) {
         Set<String> paths = Sets.newHashSet();
         Property2IndexLookup lookup = new Property2IndexLookup(root);
@@ -87,5 +89,27 @@ class NodeTypeIndexLookup implements JcrConstants {
         paths.addAll(lookup.find(JCR_MIXINTYPES, ntNames));
         return paths;
     }
+    
+    /**
+     * Returns the paths that match the given node types.
+     *
+     * @param nodeTypes the names of the node types to match.
+     * @return the set of matched paths.
+     */
+    public Iterable<String> query(Iterable<String> nodeTypes) {
+        // TODO currently, fetch all data to avoid duplicate entries:
+        // the following code sometimes returns duplicate entries:
+        // final PropertyValue ntNames = PropertyValues.newName(nodeTypes);
+        // Property2IndexLookup lookup = new Property2IndexLookup(root);
+        // return Iterables.concat(
+        //     lookup.query(JCR_PRIMARYTYPE, ntNames),
+        //     lookup.query(JCR_MIXINTYPES, ntNames));
+        Set<String> paths = Sets.newHashSet();
+        Property2IndexLookup lookup = new Property2IndexLookup(root);
+        PropertyValue ntNames = PropertyValues.newName(nodeTypes);
+        Iterables.addAll(paths, lookup.query(JCR_PRIMARYTYPE, ntNames));
+        Iterables.addAll(paths, lookup.query(JCR_MIXINTYPES, ntNames));
+        return paths;
+    }
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2Index.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2Index.java
index b04947a9b7..d4a0c1c2ee 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2Index.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2Index.java
@@ -104,7 +104,7 @@ class Property2Index implements QueryIndex {
 
     @Override
     public String getIndexName() {
-        return "oak:index";
+        return "p2";
     }
 
     @Override
@@ -127,9 +127,57 @@ class Property2Index implements QueryIndex {
         // not an appropriate index
         return Double.POSITIVE_INFINITY;
     }
-
+    
     @Override
     public Cursor query(Filter filter, NodeState root) {
+        Iterable<String> paths = null;
+
+        Property2IndexLookup lookup = new Property2IndexLookup(root);
+        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
+            // TODO support indexes on a path
+            // currently, only indexes on the root node are supported
+            if (lookup.isIndexed(pr.propertyName, "/")) {
+                // equality
+                if (pr.firstIncluding && pr.lastIncluding
+                    && pr.first != null && pr.first.equals(pr.last)) {
+                    // "[property] = $value"
+                    paths = lookup.query(pr.propertyName, pr.first);
+                    break;
+                } else if (pr.first == null && pr.last == null) {
+                    // "[property] is not null"
+                    // TODO don't load all entries in memory
+                    paths = lookup.query(pr.propertyName, null);
+                    break;
+                }
+            }
+        }
+        if (paths == null) {
+            throw new IllegalStateException("Property index is used even when no index is available for filter " + filter);
+        }
+        return Cursors.newPathCursor(paths);
+    }
+    
+    @Override
+    public String getPlan(Filter filter, NodeState root) {
+        StringBuilder buff = new StringBuilder("p2");
+        Property2IndexLookup lookup = new Property2IndexLookup(root);
+        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {
+            // TODO support indexes on a path
+            // currently, only indexes on the root node are supported
+            if (lookup.isIndexed(pr.propertyName, "/")) {
+                if (pr.firstIncluding && pr.lastIncluding
+                    && pr.first != null && pr.first.equals(pr.last)) {
+                    buff.append(' ').append(pr.propertyName).append('=').append(pr.first);
+                } else if (pr.first == null && pr.last == null) {
+                    buff.append(' ').append(pr.propertyName);
+                }
+            }
+        }
+        return buff.toString();
+   }
+    
+    @Deprecated
+    public Cursor queryOld(Filter filter, NodeState root) {
         Set<String> paths = null;
 
         Property2IndexLookup lookup = new Property2IndexLookup(root);
@@ -147,7 +195,7 @@ class Property2Index implements QueryIndex {
                 } else if (pr.first == null && pr.last == null) {
                     // "[property] is not null"
                     // TODO don't load all entries in memory
-                    set = lookup.find(pr.propertyName, (PropertyValue) null);
+                    set = lookup.find(pr.propertyName, null);
                 }
                 // only keep the intersection
                 // TODO this requires all paths are loaded in memory
@@ -165,10 +213,4 @@ class Property2Index implements QueryIndex {
         }
         return Cursors.newPathCursor(paths);
     }
-
-    @Override
-    public String getPlan(Filter filter, NodeState root) {
-        // TODO the index should return better query plans
-        return "oak:index"; 
-    }
 }
\ No newline at end of file
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java
index d8a3f2a765..664a54a7b6 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexLookup.java
@@ -19,6 +19,7 @@ package org.apache.jackrabbit.oak.plugins.index.p2;
 import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;
 
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
 
 import javax.annotation.Nullable;
@@ -30,7 +31,6 @@ import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.plugins.index.IndexConstants;
 import org.apache.jackrabbit.oak.plugins.index.p2.strategy.ContentMirrorStoreStrategy;
 import org.apache.jackrabbit.oak.plugins.index.p2.strategy.IndexStoreStrategy;
-import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
@@ -91,20 +91,6 @@ public class Property2IndexLookup {
         }
         return false;
     }
-    
-    /**
-     * Searches for a given <code>String<code> value within this index.
-     * 
-     * <p><b>Note</b> if the property you are looking for is not of type <code>String<code>, 
-     * the converted key value might not match the index key, and there will be no hits on the index.</p>
-     * 
-     * @param name the property name
-     * @param value the property value
-     * @return the set of matched paths
-     */
-    public Set<String> find(String name, String value) {
-        return find(name, PropertyValues.newString(value));
-    }
 
     /**
      * Searches for a given value within this index.
@@ -113,6 +99,7 @@ public class Property2IndexLookup {
      * @param value the property value (null to check for property existence)
      * @return the set of matched paths
      */
+    @Deprecated
     public Set<String> find(String name, PropertyValue value) {
         NodeState state = getIndexDataNode(root, name);
         if (state == null) {
@@ -126,6 +113,15 @@ public class Property2IndexLookup {
         }
         return paths;
     }
+    
+    public Iterable<String> query(String name, PropertyValue value) {
+        NodeState state = getIndexDataNode(root, name);
+        if (state == null) {
+            throw new IllegalArgumentException("No index for " + name);
+        }
+        List<String> values = value == null ? null : Property2Index.encode(value);
+        return store.query(name, state, values);
+    }
 
     public double getCost(String name, PropertyValue value) {
         // TODO the cost method is currently reading all the data - 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java
index 0c0a5cad79..4d732e5e6e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/ContentMirrorStoreStrategy.java
@@ -17,6 +17,7 @@
 package org.apache.jackrabbit.oak.plugins.index.p2.strategy;
 
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
@@ -27,15 +28,25 @@ import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.plugins.memory.MemoryChildNodeEntry;
 import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 
 /**
  * TODO document
  */
 public class ContentMirrorStoreStrategy implements IndexStoreStrategy {
 
+    static final Logger LOG = LoggerFactory.getLogger(ContentMirrorStoreStrategy.class);
+
     @Override
     public void remove(NodeBuilder index, String key, Iterable<String> values) {
         if (!index.hasChildNode(key)) {
@@ -134,6 +145,7 @@ public class ContentMirrorStoreStrategy implements IndexStoreStrategy {
     }
 
     @Override
+    @Deprecated    
     public Set<String> find(NodeState index, Iterable<String> values) {
         Set<String> paths = new HashSet<String>();
         if (values == null) {
@@ -151,11 +163,138 @@ public class ContentMirrorStoreStrategy implements IndexStoreStrategy {
         }
         return paths;
     }
+    
+    @Override
+    public Iterable<String> query(final String indexName, 
+            final NodeState index, final Iterable<String> values) {
+        return new Iterable<String>() {
+            @Override
+            public Iterator<String> iterator() {
+                PathIterator it = new PathIterator(indexName);
+                if (values == null) {
+                    it.setPathContainsValue(true);
+                    it.enqueue(index.getChildNodeEntries().iterator());
+                } else {
+                    for (String p : values) {
+                        NodeState property = index.getChildNode(p);
+                        if (property != null) {
+                            // we have an entry for this value, so use it
+                            it.enqueue(Iterators.singletonIterator(
+                                    new MemoryChildNodeEntry("", property)));
+                        }
+                    }
+                }
+                // avoid duplicate entries
+                // TODO load entries lazily
+                Set<String> paths = Sets.newHashSet();
+                Iterators.addAll(paths, it);
+                return paths.iterator();
+            }
+        };
+    }
+    
+    /**
+     * An iterator over paths within an index node.
+     */
+    static class PathIterator implements Iterator<String> {
+        
+        private final String indexName;
+        private final Deque<Iterator<? extends ChildNodeEntry>> nodeIterators =
+                Queues.newArrayDeque();
+        private int readCount;
+        private boolean init;
+        private boolean closed;
+        private String parentPath;
+        private String currentPath;
+        private boolean pathContainsValue;
+        
+        PathIterator(String indexName) {
+            this.indexName = indexName;
+            parentPath = "";
+            currentPath = "/";
+        }
+        
+        void enqueue(Iterator<? extends ChildNodeEntry> it) {
+            nodeIterators.addLast(it);
+        }
+        
+        void setPathContainsValue(boolean pathContainsValue) {
+            this.pathContainsValue = pathContainsValue;
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (!closed && !init) {
+                fetchNext();
+                init = true;
+            }
+            return !closed;
+        }
+        
+        private void fetchNext() {
+            while (!nodeIterators.isEmpty()) {
+                Iterator<? extends ChildNodeEntry> iterator = nodeIterators.getLast();
+                if (iterator.hasNext()) {
+                    ChildNodeEntry entry = iterator.next();
+
+                    readCount++;
+                    if (readCount % 100 == 0) {
+                        LOG.warn("Traversed " + readCount + " nodes using index " + indexName);
+                    }
+
+                    NodeState node = entry.getNodeState();
+
+                    String name = entry.getName();
+                    if (NodeStateUtils.isHidden(name)) {
+                        continue;
+                    }
+                    currentPath = PathUtils.concat(parentPath, name);
+
+                    nodeIterators.addLast(node.getChildNodeEntries().iterator());
+                    parentPath = currentPath;
+
+                    if (matches(node)) {
+                        return;
+                    }
+                    
+                } else {
+                    nodeIterators.removeLast();
+                    parentPath = PathUtils.getParentPath(parentPath);
+                }
+            }
+            currentPath = null;
+            closed = true;
+        }
+
+
+        @Override
+        public String next() {
+            if (closed) {
+                throw new IllegalStateException("This iterator is closed");
+            }
+            if (!init) {
+                fetchNext();
+                init = true;
+            }
+            String result = currentPath;
+            fetchNext();
+            if (pathContainsValue) {
+                String value = PathUtils.elements(result).iterator().next();
+                result = PathUtils.relativize(value, result);
+            }
+            return result;
+        }
+
+        @Override
+        public void remove() {
+            throw new UnsupportedOperationException();
+        }
+        
+    }
 
     private void getMatchingPaths(NodeState state, String path,
             Set<String> paths) {
-        PropertyState ps = state.getProperty("match");
-        if (ps != null && !ps.isArray() && ps.getValue(Type.BOOLEAN)) {
+        if (matches(state)) {
             paths.add(path);
         }
         for (ChildNodeEntry c : state.getChildNodeEntries()) {
@@ -164,6 +303,11 @@ public class ContentMirrorStoreStrategy implements IndexStoreStrategy {
             getMatchingPaths(childState, PathUtils.concat(path, name), paths);
         }
     }
+    
+    static boolean matches(NodeState state) {
+        PropertyState ps = state.getProperty("match");
+        return ps != null && !ps.isArray() && ps.getValue(Type.BOOLEAN);
+    }
 
     @Override
     public int count(NodeState index, Iterable<String> values) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/IndexStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/IndexStoreStrategy.java
index d4a27a3bcd..ba3beedf1e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/IndexStoreStrategy.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/p2/strategy/IndexStoreStrategy.java
@@ -53,13 +53,24 @@ public interface IndexStoreStrategy {
             Iterable<String> values) throws CommitFailedException;
 
     /**
-     * Search for a given set of values
+     * Search for a given set of values.
      * 
      * @param index index node (may not be null)
      * @param values values to look for (null to check for property existence)
      * @return the set of paths corresponding to the given values
      */
+    @Deprecated
     Set<String> find(NodeState index, Iterable<String> values);
+    
+    /**
+     * Search for a given set of values.
+     * 
+     * @param indexName the name of the index (for logging)
+     * @param index index node (may not be null)
+     * @param values values to look for (null to check for property existence)
+     * @return an iterator of paths
+     */
+    Iterable<String> query(String indexName, NodeState index, Iterable<String> values);
 
     /**
      * Count the occurrence of a given set of values. Used in calculating the
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexHookManagerTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexHookManagerTest.java
index a4249c0ffa..0b4c070033 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexHookManagerTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexHookManagerTest.java
@@ -24,16 +24,20 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
+import java.util.Set;
+
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexHookProvider;
 import org.apache.jackrabbit.oak.plugins.index.p2.Property2IndexLookup;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeState;
+import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.junit.Test;
 
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 
 public class IndexHookManagerTest {
 
@@ -85,15 +89,19 @@ public class IndexHookManagerTest {
                 ":index");
 
         Property2IndexLookup lookup = new Property2IndexLookup(indexed);
-        assertEquals(ImmutableSet.of("testRoot"), lookup.find("foo", "abc"));
+        assertEquals(ImmutableSet.of("testRoot"), find(lookup, "foo", "abc"));
 
         Property2IndexLookup lookupChild = new Property2IndexLookup(indexed
                 .getChildNode("newchild").getChildNode("other"));
         assertEquals(ImmutableSet.of("testChild"),
-                lookupChild.find("foo", "xyz"));
-        assertEquals(ImmutableSet.of(), lookupChild.find("foo", "abc"));
+                find(lookupChild, "foo", "xyz"));
+        assertEquals(ImmutableSet.of(), find(lookupChild, "foo", "abc"));
 
     }
+    
+    private static Set<String> find(Property2IndexLookup lookup, String name, String value) {
+        return Sets.newHashSet(lookup.query(name, PropertyValues.newString(value)));
+    }
 
     /**
      * Reindex Test
@@ -134,7 +142,7 @@ public class IndexHookManagerTest {
 
         // next, lookup
         Property2IndexLookup lookup = new Property2IndexLookup(indexed);
-        assertEquals(ImmutableSet.of("testRoot"), lookup.find("foo", "abc"));
+        assertEquals(ImmutableSet.of("testRoot"), find(lookup, "foo", "abc"));
     }
 
     /**
@@ -175,7 +183,7 @@ public class IndexHookManagerTest {
 
         // next, lookup
         Property2IndexLookup lookup = new Property2IndexLookup(indexed);
-        assertEquals(ImmutableSet.of("testRoot"), lookup.find("foo", "abc"));
+        assertEquals(ImmutableSet.of("testRoot"), find(lookup, "foo", "abc"));
     }
 
     /**
@@ -217,7 +225,7 @@ public class IndexHookManagerTest {
 
         // next, lookup
         Property2IndexLookup lookup = new Property2IndexLookup(indexed);
-        assertEquals(ImmutableSet.of("testRoot"), lookup.find("foo", "abc"));
+        assertEquals(ImmutableSet.of("testRoot"), find(lookup, "foo", "abc"));
     }
 
     private static NodeState checkPathExists(NodeState state, String... verify) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexTest.java
index f3a6204f9d..1cadd1192b 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/p2/Property2IndexTest.java
@@ -16,18 +16,22 @@
  */
 package org.apache.jackrabbit.oak.plugins.index.p2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
 import java.util.Arrays;
+import java.util.Set;
 
-import com.google.common.collect.ImmutableSet;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.index.IndexHook;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeState;
+import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 
 /**
  * Test the Property2 index mechanism.
@@ -66,12 +70,17 @@ public class Property2IndexTest {
 
         // Query the index
         Property2IndexLookup lookup = new Property2IndexLookup(builder.getNodeState());
-        assertEquals(ImmutableSet.of("a", "b"), lookup.find("foo", "abc"));
-        assertEquals(ImmutableSet.of("b"), lookup.find("foo", "def"));
-        assertEquals(ImmutableSet.of(), lookup.find("foo", "ghi"));
-        assertEquals(MANY, lookup.find("foo", "xyz").size());
+        assertEquals(ImmutableSet.of("a", "b"), find(lookup, "foo", "abc"));
+        assertEquals(ImmutableSet.of("b"), find(lookup, "foo", "def"));
+        assertEquals(ImmutableSet.of(), find(lookup, "foo", "ghi"));
+        assertEquals(MANY, find(lookup, "foo", "xyz").size());
+        assertEquals(MANY + 2, find(lookup, "foo", null).size());
         
     }
+    
+    private static Set<String> find(Property2IndexLookup lookup, String name, String value) {
+        return Sets.newHashSet(lookup.query(name, value == null ? null : PropertyValues.newString(value)));
+    }
 
     @Test
     public void testCustomConfigPropertyLookup() throws Exception {
@@ -103,14 +112,14 @@ public class Property2IndexTest {
 
         // Query the index
         Property2IndexLookup lookup = new Property2IndexLookup(builder.getNodeState());
-        assertEquals(ImmutableSet.of("a", "b"), lookup.find("foo", "abc"));
-        assertEquals(ImmutableSet.of("b"), lookup.find("foo", "def"));
-        assertEquals(ImmutableSet.of(), lookup.find("foo", "ghi"));
-        assertEquals(MANY, lookup.find("foo", "xyz").size());
-        assertEquals(ImmutableSet.of("a"), lookup.find("extrafoo", "pqr"));
+        assertEquals(ImmutableSet.of("a", "b"), find(lookup, "foo", "abc"));
+        assertEquals(ImmutableSet.of("b"), find(lookup, "foo", "def"));
+        assertEquals(ImmutableSet.of(), find(lookup, "foo", "ghi"));
+        assertEquals(MANY, find(lookup, "foo", "xyz").size());
+        assertEquals(ImmutableSet.of("a"), find(lookup, "extrafoo", "pqr"));
         
         try {
-            assertEquals(ImmutableSet.of(), lookup.find("pqr", "foo"));
+            assertEquals(ImmutableSet.of(), find(lookup, "pqr", "foo"));
             fail();
         } catch (IllegalArgumentException e) {
             // expected: no index for "pqr"
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
index 933df9e14d..94c2e10830 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
@@ -26,10 +26,10 @@
 # property type (value prefix) index
 
 explain select * from [nt:base] where [jcr:uuid] = '123'
-[nt:base] as [nt:base] /* oak:index where [nt:base].[jcr:uuid] = cast('123' as string) */
+[nt:base] as [nt:base] /* p2 jcr:uuid=123 where [nt:base].[jcr:uuid] = cast('123' as string) */
 
 explain select * from [nt:base] where [jcr:uuid] is not null
-[nt:base] as [nt:base] /* oak:index where [nt:base].[jcr:uuid] is not null */
+[nt:base] as [nt:base] /* p2 jcr:uuid where [nt:base].[jcr:uuid] is not null */
 
 commit / + "test": { "jcr:uuid": "xyz", "a": { "jcr:uuid": "123" } }
 
