diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java
index c9b4efbbf2..035713eaf4 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java
@@ -16,13 +16,27 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.Uninterruptibles;
 import org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator;
+import org.apache.jackrabbit.oak.stats.Clock;
+import org.junit.Ignore;
 import org.junit.Test;
 
 /**
@@ -283,4 +297,72 @@ public class RevisionTest {
         assertEquals(new Revision(0x30, 0, 0), comp.getRevisionSeen(r21));
     }
 
+    @Ignore("OAK-1807")
+    @Test
+    public void uniqueRevision() throws Exception {
+        //Revision.setClock(new Clock.Virtual());
+        final BlockingQueue<Revision> revisionQueue = Queues.newLinkedBlockingQueue();
+        int noOfThreads = 60;
+        final int noOfLoops = 1000;
+        List<Thread> workers = new ArrayList<Thread>();
+        final AtomicBoolean stop = new AtomicBoolean();
+        final CountDownLatch startLatch = new CountDownLatch(1);
+        final CountDownLatch stopLatch = new CountDownLatch(noOfThreads);
+        for (int i = 0; i < noOfThreads; i++) {
+            workers.add(new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    Uninterruptibles.awaitUninterruptibly(startLatch);
+                    for (int j = 0; j < noOfLoops && !stop.get(); j++) {
+                        revisionQueue.add(Revision.newRevision(1));
+                    }
+                    stopLatch.countDown();
+                }
+            }));
+        }
+
+        final List<Revision> duplicates = Lists.newArrayList();
+        final Set<Revision> seenRevs = Sets.newHashSet();
+        workers.add(new Thread(new Runnable() {
+            @Override
+            public void run() {
+                startLatch.countDown();
+
+                while (!stop.get()) {
+                    List<Revision> revs = Lists.newArrayList();
+                    Queues.drainUninterruptibly(revisionQueue, revs, 5, 100, TimeUnit.MILLISECONDS);
+                    record(revs);
+                }
+
+                List<Revision> revs = Lists.newArrayList();
+                revisionQueue.drainTo(revs);
+                record(revs);
+            }
+
+            private void record(List<Revision> revs) {
+                for (Revision rev : revs) {
+                    if (!seenRevs.add(rev)) {
+                        duplicates.add(rev);
+                    }
+                }
+
+                if (!duplicates.isEmpty()) {
+                    stop.set(true);
+                }
+            }
+        }));
+
+        for (Thread t : workers) {
+            t.start();
+        }
+
+        stopLatch.await();
+        stop.set(true);
+
+        for (Thread t : workers) {
+            t.join();
+        }
+        assertTrue(String.format("Duplicate rev seen %s %n Seen %s", duplicates, seenRevs), duplicates.isEmpty());
+    }
+
 }
