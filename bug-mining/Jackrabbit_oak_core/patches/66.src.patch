diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/IndexWrapper.java b/oak-core/src/main/java/org/apache/jackrabbit/mk/index/IndexWrapper.java
index e7086cf56b..f15c77c191 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/IndexWrapper.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/mk/index/IndexWrapper.java
@@ -28,6 +28,9 @@ import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.mk.json.JsopReader;
 import org.apache.jackrabbit.mk.json.JsopStream;
 import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.plugins.index.Indexer;
+import org.apache.jackrabbit.oak.plugins.index.PrefixIndex;
+import org.apache.jackrabbit.oak.plugins.index.PropertyIndex;
 import org.apache.jackrabbit.mk.wrapper.MicroKernelWrapper;
 import org.apache.jackrabbit.mk.wrapper.MicroKernelWrapperBase;
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ContentRepositoryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ContentRepositoryImpl.java
index 4ffc2ea803..68dc34b7aa 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ContentRepositoryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ContentRepositoryImpl.java
@@ -26,7 +26,7 @@ import javax.security.auth.login.LoginException;
 
 import org.apache.jackrabbit.mk.api.MicroKernel;
 import org.apache.jackrabbit.mk.core.MicroKernelImpl;
-import org.apache.jackrabbit.mk.index.Indexer;
+import org.apache.jackrabbit.oak.plugins.index.Indexer;
 import org.apache.jackrabbit.oak.api.ContentRepository;
 import org.apache.jackrabbit.oak.api.ContentSession;
 import org.apache.jackrabbit.oak.kernel.KernelNodeStore;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTree.java
similarity index 99%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTree.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTree.java
index e2aa70f9b5..c8b4dc7fe3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTree.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTree.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
 import org.apache.jackrabbit.mk.json.JsopBuilder;
 import org.apache.jackrabbit.oak.commons.PathUtils;
@@ -264,7 +264,7 @@ public class BTree {
         }
     }
 
-    String getName() {
+    public String getName() {
         return name;
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreeLeaf.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreeLeaf.java
similarity index 94%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreeLeaf.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreeLeaf.java
index 6a0f9d0b71..afe0ac098f 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreeLeaf.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreeLeaf.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
 import java.util.Arrays;
 
@@ -25,9 +25,9 @@ import org.apache.jackrabbit.oak.util.ArrayUtils;
 /**
  * An index leaf page.
  */
-class BTreeLeaf extends BTreePage {
+public class BTreeLeaf extends BTreePage {
 
-    BTreeLeaf(BTree tree, BTreeNode parent, String name, String[] data, String[] paths) {
+    public BTreeLeaf(BTree tree, BTreeNode parent, String name, String[] data, String[] paths) {
         super(tree, parent, name, data, paths);
         verify();
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreeNode.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreeNode.java
similarity index 96%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreeNode.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreeNode.java
index 3bea3e4f07..485b9f0e58 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreeNode.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreeNode.java
@@ -14,9 +14,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
 import java.util.Arrays;
+
 import org.apache.jackrabbit.mk.json.JsopBuilder;
 import org.apache.jackrabbit.oak.util.ArrayUtils;
 import org.apache.jackrabbit.oak.commons.PathUtils;
@@ -24,11 +25,11 @@ import org.apache.jackrabbit.oak.commons.PathUtils;
 /**
  * An index node page.
  */
-class BTreeNode extends BTreePage {
+public class BTreeNode extends BTreePage {
 
     private String[] children;
 
-    BTreeNode(BTree tree, BTreeNode parent, String name, String[] keys, String[] values, String[] children) {
+    public BTreeNode(BTree tree, BTreeNode parent, String name, String[] keys, String[] values, String[] children) {
         super(tree, parent, name, keys, values);
         this.children = children;
         verify();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreePage.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreePage.java
similarity index 95%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreePage.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreePage.java
index 3d28a1e17f..31bdb841bd 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/BTreePage.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/BTreePage.java
@@ -14,14 +14,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
 import org.apache.jackrabbit.oak.commons.PathUtils;
 
 /**
  * An index page.
  */
-abstract class BTreePage {
+abstract public class BTreePage {
 
     protected final BTree tree;
     protected BTreeNode parent;
@@ -65,7 +65,7 @@ abstract class BTreePage {
         return parent == null ? "" : parent.getPath();
     }
 
-    String getPath() {
+    public String getPath() {
         return PathUtils.concat(getParentPath(), name);
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Cursor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/Cursor.java
similarity index 98%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/Cursor.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/Cursor.java
index 2e1b1ac1a2..f0e0149910 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Cursor.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/Cursor.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
 import java.util.Iterator;
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/Indexer.java
similarity index 92%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/Indexer.java
index f3e7f03846..5f9a0379ff 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Indexer.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/Indexer.java
@@ -14,11 +14,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
 
 import org.apache.jackrabbit.mk.ExceptionFactory;
 import org.apache.jackrabbit.mk.api.MicroKernel;
 import org.apache.jackrabbit.mk.api.MicroKernelException;
+import org.apache.jackrabbit.mk.index.IndexWrapper;
 import org.apache.jackrabbit.mk.json.JsopBuilder;
 import org.apache.jackrabbit.mk.json.JsopReader;
 import org.apache.jackrabbit.mk.json.JsopTokenizer;
@@ -30,12 +37,8 @@ import org.apache.jackrabbit.oak.query.index.PrefixContentIndex;
 import org.apache.jackrabbit.oak.query.index.PropertyContentIndex;
 import org.apache.jackrabbit.oak.spi.QueryIndex;
 import org.apache.jackrabbit.oak.spi.QueryIndexProvider;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map.Entry;
+import org.apache.jackrabbit.oak.spi.query.Index;
+import org.apache.jackrabbit.oak.spi.query.IndexUtils;
 
 /**
  * A index mechanism. An index is bound to a certain repository, and supports
@@ -47,7 +50,8 @@ public class Indexer implements QueryIndexProvider {
      * The root node of the index definition (configuration) nodes.
      */
     // TODO OAK-178 discuss where to store index config data
-    public static final String INDEX_CONFIG_PATH = "/jcr:system/indexes";
+    public static final String INDEX_CONFIG_PATH = IndexUtils.DEFAULT_INDEX_HOME + "/indexes";
+            //"/jcr:system/indexes";
 
     /**
      * For each index, the index content is stored relative to the index
@@ -59,18 +63,18 @@ public class Indexer implements QueryIndexProvider {
     /**
      * The node name prefix of a prefix index.
      */
-    static final String TYPE_PREFIX = "prefix@";
+    public static final String TYPE_PREFIX = "prefix@";
 
     /**
      * The node name prefix of a property index.
      */
     // TODO support multi-property indexes
-    static final String TYPE_PROPERTY = "property@";
+    public static final String TYPE_PROPERTY = "property@";
 
     /**
      * Marks a unique index.
      */
-    static final String UNIQUE = "unique";
+    public static final String UNIQUE = "unique";
 
     /**
      * The maximum length of the write buffer.
@@ -93,7 +97,7 @@ public class Indexer implements QueryIndexProvider {
     /**
      * An index node name to index map.
      */
-    private HashMap<String, Index> indexes = new HashMap<String, Index>();
+    private HashMap<String, PIndex> indexes = new HashMap<String, PIndex>();
 
     /**
      * A prefix to prefix index map.
@@ -105,7 +109,7 @@ public class Indexer implements QueryIndexProvider {
      */
     private final HashMap<String, PropertyIndex> propertyIndexes = new HashMap<String, PropertyIndex>();
 
-    Indexer(MicroKernel mk) {
+    public Indexer(MicroKernel mk) {
         this.mk = mk;
     }
 
@@ -126,7 +130,7 @@ public class Indexer implements QueryIndexProvider {
         return new Indexer(mk);
     }
 
-    String getIndexRootNode() {
+    public String getIndexRootNode() {
         return indexRootNode;
     }
 
@@ -157,13 +161,13 @@ public class Indexer implements QueryIndexProvider {
                 String k = n.getChildNodeName(i);
                 PropertyIndex prop = PropertyIndex.fromNodeName(this, k);
                 if (prop != null) {
-                    indexes.put(prop.getIndexNodeName(), prop);
+                    indexes.put(prop.getDefinition().getName(), prop);
                     propertyIndexes.put(prop.getPropertyName(), prop);
                     queryIndexList = null;
                 }
                 PrefixIndex pref = PrefixIndex.fromNodeName(this, k);
                 if (pref != null) {
-                    indexes.put(pref.getIndexNodeName(), pref);
+                    indexes.put(pref.getDefinition().getName(), pref);
                     prefixIndexes.put(pref.getPrefix(), pref);
                     queryIndexList = null;
                 }
@@ -173,7 +177,7 @@ public class Indexer implements QueryIndexProvider {
 
     private void removePropertyIndex(String property, boolean unique) {
         PropertyIndex index = propertyIndexes.remove(property);
-        indexes.remove(index.getIndexNodeName());
+        indexes.remove(index.getDefinition().getName());
         queryIndexList = null;
     }
 
@@ -184,7 +188,7 @@ public class Indexer implements QueryIndexProvider {
         }
         PropertyIndex index = new PropertyIndex(this, property, unique);
         buildIndex(index);
-        indexes.put(index.getIndexNodeName(), index);
+        indexes.put(index.getDefinition().getName(), index);
         propertyIndexes.put(index.getPropertyName(), index);
         queryIndexList = null;
         return index;
@@ -192,7 +196,7 @@ public class Indexer implements QueryIndexProvider {
 
     private void removePrefixIndex(String prefix) {
          PrefixIndex index = prefixIndexes.remove(prefix);
-         indexes.remove(index.getIndexNodeName());
+         indexes.remove(index.getDefinition().getName());
          queryIndexList = null;
     }
 
@@ -203,7 +207,7 @@ public class Indexer implements QueryIndexProvider {
         }
         PrefixIndex index = new PrefixIndex(this, prefix);
         buildIndex(index);
-        indexes.put(index.getIndexNodeName(), index);
+        indexes.put(index.getDefinition().getName(), index);
         prefixIndexes.put(index.getPrefix(), index);
         queryIndexList = null;
         return index;
@@ -214,7 +218,7 @@ public class Indexer implements QueryIndexProvider {
         return mk.nodeExists(PathUtils.concat(indexRootNode, name), revision);
     }
 
-    void createNodes(String path) {
+    public void createNodes(String path) {
         String rev = mk.getHeadRevision();
         JsopBuilder jsop = new JsopBuilder();
         String p = "/";
@@ -233,7 +237,7 @@ public class Indexer implements QueryIndexProvider {
         revision = mk.commit(indexRootNode, jsop, revision, null);
     }
 
-    BTreePage getPageIfCached(BTree tree, BTreeNode parent, String name) {
+    public BTreePage getPageIfCached(BTree tree, BTreeNode parent, String name) {
         String p = getPath(tree, parent, name);
         return modified.get(p);
     }
@@ -244,7 +248,7 @@ public class Indexer implements QueryIndexProvider {
         return PathUtils.concat(indexRoot, p);
     }
 
-    BTreePage getPage(BTree tree, BTreeNode parent, String name) {
+    public BTreePage getPage(BTree tree, BTreeNode parent, String name) {
         String p = getPath(tree, parent, name);
         BTreePage page;
         page = modified.get(p);
@@ -297,7 +301,7 @@ public class Indexer implements QueryIndexProvider {
         return data;
     }
 
-    void buffer(String diff) {
+    public void buffer(String diff) {
         if (buffer == null) {
             buffer = new StringBuilder(diff);
         } else {
@@ -305,7 +309,7 @@ public class Indexer implements QueryIndexProvider {
         }
     }
 
-    void modified(BTree tree, BTreePage page, boolean deleted) {
+    public void modified(BTree tree, BTreePage page, boolean deleted) {
         String indexRoot = PathUtils.concat(indexRootNode, tree.getName());
         String p = PathUtils.concat(indexRoot, INDEX_CONTENT, page.getPath());
         if (deleted) {
@@ -315,7 +319,7 @@ public class Indexer implements QueryIndexProvider {
         }
     }
 
-    void moveCache(BTree tree, String oldPath) {
+    public void moveCache(BTree tree, String oldPath) {
         String indexRoot = PathUtils.concat(indexRootNode, tree.getName());
         String o = PathUtils.concat(indexRoot, INDEX_CONTENT, oldPath);
         HashMap<String, BTreePage> moved = new HashMap<String, BTreePage>();
@@ -343,7 +347,7 @@ public class Indexer implements QueryIndexProvider {
         }
     }
 
-    synchronized void updateUntil(String toRevision) {
+    synchronized public void updateUntil(String toRevision) {
         if (DISABLED) {
             return;
         }
@@ -394,7 +398,7 @@ public class Indexer implements QueryIndexProvider {
      * @param toRevision the new index revision
      * @return the new head revision
      */
-    String updateEnd(String toRevision) {
+    public String updateEnd(String toRevision) {
         readRevision = toRevision;
         JsopBuilder jsop = new JsopBuilder();
         jsop.tag('^').key(PathUtils.concat(INDEX_CONTENT, "rev")).value(readRevision);
@@ -423,7 +427,7 @@ public class Indexer implements QueryIndexProvider {
      * @param t the changes
      * @param lastRevision
      */
-    void updateIndex(String rootPath, JsopReader t, String lastRevision) {
+    public void updateIndex(String rootPath, JsopReader t, String lastRevision) {
         while (true) {
             int r = t.read();
             if (r == JsopReader.END) {
@@ -512,7 +516,7 @@ public class Indexer implements QueryIndexProvider {
             // don't index the index data itself
             return;
         }
-        for (Index index : indexes.values()) {
+        for (PIndex index : indexes.values()) {
             if (remove) {
                 index.addOrRemoveNode(n, false);
             }
@@ -587,7 +591,7 @@ public class Indexer implements QueryIndexProvider {
         NodeImpl n = NodeImpl.parse(map, t, 0, path);
         if (n.hasProperty(property)) {
             n.setPath(nodePath);
-            for (Index index : indexes.values()) {
+            for (PIndex index : indexes.values()) {
                 index.addOrRemoveProperty(nodePath, property, n.getProperty(property), false);
             }
         }
@@ -600,7 +604,7 @@ public class Indexer implements QueryIndexProvider {
         }
         String nodePath = PathUtils.getParentPath(path);
         String property = PathUtils.getName(path);
-        for (Index index : indexes.values()) {
+        for (PIndex index : indexes.values()) {
             index.addOrRemoveProperty(nodePath, property, value, true);
         }
     }
@@ -637,12 +641,12 @@ public class Indexer implements QueryIndexProvider {
         }
     }
 
-    private void buildIndex(Index index) {
+    private void buildIndex(PIndex index) {
         // TODO index: add ability to start / stop / restart indexing; log the progress
         addRecursive(index, "/");
     }
 
-    private void addRecursive(Index index, String path) {
+    private void addRecursive(PIndex index, String path) {
         if (isInIndex(path)) {
             return;
         }
@@ -683,11 +687,11 @@ public class Indexer implements QueryIndexProvider {
         return queryIndexList;
     }
 
-    PrefixIndex getPrefixIndex(String prefix) {
+    public PrefixIndex getPrefixIndex(String prefix) {
         return prefixIndexes.get(prefix);
     }
 
-    PropertyIndex getPropertyIndex(String property) {
+    public PropertyIndex getPropertyIndex(String property) {
         return propertyIndexes.get(property);
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Index.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PIndex.java
similarity index 85%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/Index.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PIndex.java
index 032a4d237f..324938632a 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/Index.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PIndex.java
@@ -14,24 +14,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
 import java.util.Iterator;
+
 import org.apache.jackrabbit.mk.simple.NodeImpl;
+import org.apache.jackrabbit.oak.spi.query.Index;
 
 /**
  * An index is a lookup mechanism. It typically uses a tree to store data. It
  * updates the tree whenever a node was changed. The index is updated
  * automatically.
  */
-public interface Index {
-
-    /**
-     * Get the unique index name. This is also the name of the index node.
-     *
-     * @return the index name
-     */
-    String getIndexNodeName();
+public interface PIndex extends Index{
 
     /**
      * The given node was added or removed.
@@ -62,11 +57,4 @@ public interface Index {
      */
     Iterator<String> getPaths(String value, String revision);
 
-    /**
-     * Whether each value may only appear once in the index.
-     *
-     * @return true if unique
-     */
-    boolean isUnique();
-
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/PrefixIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PrefixIndex.java
similarity index 78%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/PrefixIndex.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PrefixIndex.java
index 768c70c0f7..c0bd59c176 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/PrefixIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PrefixIndex.java
@@ -14,28 +14,45 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
+import java.io.IOException;
 import java.util.Iterator;
+
 import org.apache.jackrabbit.mk.json.JsopReader;
 import org.apache.jackrabbit.mk.json.JsopTokenizer;
 import org.apache.jackrabbit.mk.simple.NodeImpl;
+import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinitionImpl;
+import org.apache.jackrabbit.oak.spi.query.IndexUtils;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.apache.jackrabbit.oak.spi.state.NodeStore;
 
 /**
  * An index for all values with a given prefix.
  */
-public class PrefixIndex implements Index {
+public class PrefixIndex implements PIndex {
 
     private final Indexer indexer;
     private final BTree tree;
     private final String prefix;
 
+    private final IndexDefinition indexDefinition;
+
     public PrefixIndex(Indexer indexer, String prefix) {
+        this(indexer, prefix, new IndexDefinitionImpl(prefix,
+                PropertyIndexFactory.TYPE_PREFIX, PathUtils.concat(
+                        IndexUtils.DEFAULT_INDEX_HOME, prefix), false, null));
+    }
+
+    public PrefixIndex(Indexer indexer, String prefix, IndexDefinition indexDefinition) {
         this.indexer = indexer;
         this.prefix = prefix;
         this.tree = new BTree(indexer, Indexer.TYPE_PREFIX + prefix, false);
         tree.setMinSize(10);
+        this.indexDefinition = indexDefinition;
     }
 
     public static PrefixIndex fromNodeName(Indexer indexer, String nodeName) {
@@ -51,8 +68,8 @@ public class PrefixIndex implements Index {
     }
 
     @Override
-    public String getIndexNodeName() {
-        return tree.getName();
+    public IndexDefinition getDefinition() {
+        return indexDefinition;
     }
 
     @Override
@@ -128,8 +145,15 @@ public class PrefixIndex implements Index {
     }
 
     @Override
-    public boolean isUnique() {
-        return tree.isUnique();
+    public void close() throws IOException {
+        // not needed
+    }
+
+    @Override
+    public NodeState editCommit(NodeStore store, NodeState before,
+            NodeState after) throws CommitFailedException {
+        // TODO Auto-generated method stub
+        return null;
     }
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PropertyIndex.java
similarity index 74%
rename from oak-core/src/main/java/org/apache/jackrabbit/mk/index/PropertyIndex.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PropertyIndex.java
index c2eabf52e4..5c1c20ed03 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/mk/index/PropertyIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PropertyIndex.java
@@ -14,33 +14,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.mk.index;
+package org.apache.jackrabbit.oak.plugins.index;
 
+import java.io.IOException;
 import java.util.Iterator;
+
 import org.apache.jackrabbit.mk.json.JsopReader;
 import org.apache.jackrabbit.mk.json.JsopTokenizer;
 import org.apache.jackrabbit.mk.simple.NodeImpl;
+import org.apache.jackrabbit.oak.api.CommitFailedException;
+import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinitionImpl;
+import org.apache.jackrabbit.oak.spi.query.IndexUtils;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.apache.jackrabbit.oak.spi.state.NodeStore;
 
 /**
  * A node handler that maps the property value to the key, and the path of the
  * node to the value. Only string and numbers are indexes (arrays, true, false,
  * and null are not indexes).
  */
-public class PropertyIndex implements Index {
+public class PropertyIndex implements PIndex {
 
     private final Indexer indexer;
     private final BTree tree;
     private final String propertyName;
 
-    PropertyIndex(Indexer indexer, String propertyName, boolean unique) {
+    private final IndexDefinition indexDefinition;
+
+    public PropertyIndex(Indexer indexer, String propertyName, boolean unique) {
+        this(indexer, propertyName, unique, new IndexDefinitionImpl(
+                propertyName, PropertyIndexFactory.TYPE_PREFIX,
+                PathUtils.concat(IndexUtils.DEFAULT_INDEX_HOME, propertyName),
+                false, null));
+    }
+
+    public PropertyIndex(Indexer indexer, String propertyName, boolean unique, IndexDefinition indexDefinition) {
         this.indexer = indexer;
         this.propertyName = propertyName;
         this.tree = new BTree(indexer, Indexer.TYPE_PROPERTY + propertyName +
                 (unique ? "," + Indexer.UNIQUE : ""), unique);
         tree.setMinSize(10);
+        this.indexDefinition = indexDefinition;
     }
 
-    static PropertyIndex fromNodeName(Indexer indexer, String nodeName) {
+    public static PropertyIndex fromNodeName(Indexer indexer, String nodeName) {
         if (!nodeName.startsWith(Indexer.TYPE_PROPERTY)) {
             return null;
         }
@@ -58,8 +77,8 @@ public class PropertyIndex implements Index {
     }
 
     @Override
-    public String getIndexNodeName() {
-        return tree.getName();
+    public IndexDefinition getDefinition() {
+        return indexDefinition;
     }
 
     @Override
@@ -132,8 +151,15 @@ public class PropertyIndex implements Index {
     }
 
     @Override
-    public boolean isUnique() {
-        return tree.isUnique();
+    public NodeState editCommit(NodeStore store, NodeState before,
+            NodeState after) throws CommitFailedException {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public void close() throws IOException {
+        // not needed
     }
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PropertyIndexFactory.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PropertyIndexFactory.java
new file mode 100644
index 0000000000..f75adf28fd
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/PropertyIndexFactory.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.index;
+
+import org.apache.jackrabbit.mk.api.MicroKernel;
+import org.apache.jackrabbit.oak.spi.query.Index;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexFactory;
+
+public class PropertyIndexFactory implements IndexFactory {
+
+    public static final String TYPE_PROPERTY = "property";
+    public static final String TYPE_PREFIX = "prefix";
+
+    private Indexer indexer;
+
+    @Override
+    public void init(MicroKernel mk) {
+        this.indexer = new Indexer(mk);
+    }
+
+    @Override
+    public String[] getTypes() {
+        return new String[] { TYPE_PREFIX, TYPE_PROPERTY };
+    }
+
+    @Override
+    public Index createIndex(IndexDefinition indexDefinition) {
+        if (TYPE_PREFIX.equals(indexDefinition.getType())) {
+            String prefix = indexDefinition.getProperties().get("prefix");
+            if (prefix != null) {
+                return new PrefixIndex(indexer, prefix, indexDefinition);
+            }
+            return null;
+        }
+        if (TYPE_PROPERTY.equals(indexDefinition.getType())) {
+            String name = indexDefinition.getProperties().get("pname");
+            if (name != null) {
+                return new PropertyIndex(indexer, name,
+                        indexDefinition.isUnique(), indexDefinition);
+            }
+        }
+        return null;
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditor.java
index 6c7b3ee2d3..141952a933 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditor.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditor.java
@@ -18,7 +18,11 @@ package org.apache.jackrabbit.oak.plugins.lucene;
 
 import static org.apache.jackrabbit.oak.plugins.lucene.FieldFactory.newPathField;
 import static org.apache.jackrabbit.oak.plugins.lucene.FieldFactory.newPropertyField;
+import static org.apache.jackrabbit.oak.spi.query.IndexUtils.DEFAULT_INDEX_HOME;
+import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.DEFAULT_INDEX_NAME;
+import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.INDEX_DATA_CHILD_NAME;
 import static org.apache.jackrabbit.oak.plugins.lucene.TermFactory.newPathTerm;
+import static org.apache.jackrabbit.oak.spi.query.IndexUtils.split;
 
 import java.io.IOException;
 
@@ -27,7 +31,11 @@ import javax.jcr.PropertyType;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.CoreValue;
 import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.spi.commit.CommitEditor;
+import org.apache.jackrabbit.oak.spi.query.Index;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinitionImpl;
 import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;
@@ -45,7 +53,7 @@ import org.apache.tika.exception.TikaException;
 /**
  * This class updates a Lucene index when node content is changed.
  */
-public class LuceneEditor implements CommitEditor {
+public class LuceneEditor implements CommitEditor, Index {
 
     private static final Tika TIKA = new Tika();
 
@@ -67,20 +75,27 @@ public class LuceneEditor implements CommitEditor {
         }
     }
 
+    private final IndexDefinition indexDefinition;
+
     private final String[] path;
 
-    public LuceneEditor(String... path) {
-        this.path = path;
+    public LuceneEditor(IndexDefinition indexDefinition) {
+        this.indexDefinition = indexDefinition;
+        this.path = split(indexDefinition.getPath(), INDEX_DATA_CHILD_NAME);
     }
 
+    /**
+     * Used for testing purposes only
+     */
     public LuceneEditor() {
-        this(LuceneIndexUtils.DEFAULT_INDEX_PATH);
+        this(new IndexDefinitionImpl(DEFAULT_INDEX_NAME,
+                LuceneIndexFactory.TYPE, PathUtils.concat(DEFAULT_INDEX_HOME,
+                        DEFAULT_INDEX_NAME), false, null));
     }
 
     @Override
-    public NodeState editCommit(
-            NodeStore store, NodeState before, NodeState after)
-            throws CommitFailedException {
+    public NodeState editCommit(NodeStore store, NodeState before,
+            NodeState after) throws CommitFailedException {
         try {
             OakDirectory directory = new OakDirectory(store, after, path);
 
@@ -96,6 +111,7 @@ public class LuceneEditor implements CommitEditor {
 
             return directory.getRoot();
         } catch (IOException e) {
+            e.printStackTrace();
             throw new CommitFailedException(
                     "Failed to update the full text search index", e);
         }
@@ -121,8 +137,7 @@ public class LuceneEditor implements CommitEditor {
                 throw exception;
             }
             if (modified) {
-                writer.updateDocument(
-                        newPathTerm(path),
+                writer.updateDocument(newPathTerm(path),
                         makeDocument(path, state));
             }
         }
@@ -157,8 +172,8 @@ public class LuceneEditor implements CommitEditor {
         }
 
         @Override
-        public void childNodeChanged(
-                String name, NodeState before, NodeState after) {
+        public void childNodeChanged(String name, NodeState before,
+                NodeState after) {
             if (NodeStateUtils.isHidden(name)) {
                 return;
             }
@@ -199,18 +214,19 @@ public class LuceneEditor implements CommitEditor {
                 throws IOException {
             writer.deleteDocuments(newPathTerm(path));
             for (ChildNodeEntry entry : state.getChildNodeEntries()) {
-                deleteSubtree(path + "/" + entry.getName(), entry.getNodeState());
+                deleteSubtree(path + "/" + entry.getName(),
+                        entry.getNodeState());
             }
         }
 
-        private static Document makeDocument(
-                String path, NodeState state) {
+        private static Document makeDocument(String path, NodeState state) {
             Document document = new Document();
             document.add(newPathField(path));
             for (PropertyState property : state.getProperties()) {
                 String pname = property.getName();
                 for (CoreValue value : property.getValues()) {
-                    document.add(newPropertyField(pname, parseStringValue(value)));
+                    document.add(newPropertyField(pname,
+                            parseStringValue(value)));
                 }
             }
             return document;
@@ -234,4 +250,13 @@ public class LuceneEditor implements CommitEditor {
 
     }
 
+    @Override
+    public void close() throws IOException {
+        // TODO implement close
+    }
+
+    @Override
+    public IndexDefinition getDefinition() {
+        return indexDefinition;
+    }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndex.java
index ed4f3927e0..15828e8159 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndex.java
@@ -18,7 +18,9 @@ package org.apache.jackrabbit.oak.plugins.lucene;
 
 import static org.apache.jackrabbit.oak.plugins.lucene.FieldNames.PATH;
 import static org.apache.jackrabbit.oak.plugins.lucene.FieldNames.PATH_SELECTOR;
+import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.INDEX_DATA_CHILD_NAME;
 import static org.apache.jackrabbit.oak.plugins.lucene.TermFactory.newPathTerm;
+import static org.apache.jackrabbit.oak.spi.query.IndexUtils.split;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -33,6 +35,7 @@ import org.apache.jackrabbit.oak.spi.Filter;
 import org.apache.jackrabbit.oak.spi.Filter.PropertyRestriction;
 import org.apache.jackrabbit.oak.spi.IndexRow;
 import org.apache.jackrabbit.oak.spi.QueryIndex;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.apache.lucene.index.DirectoryReader;
@@ -56,11 +59,15 @@ public class LuceneIndex implements QueryIndex {
 
     private final NodeStore store;
 
-    private final LuceneIndexInfo index;
+    private final IndexDefinition index;
 
-    public LuceneIndex(NodeStore store, LuceneIndexInfo index) {
+    private final String[] indexDataPath;
+
+    public LuceneIndex(NodeStore store, IndexDefinition indexDefinition) {
         this.store = store;
-        this.index = index;
+        this.index = indexDefinition;
+        this.indexDataPath = split(indexDefinition.getPath(),
+                INDEX_DATA_CHILD_NAME);
     }
 
     @Override
@@ -81,7 +88,7 @@ public class LuceneIndex implements QueryIndex {
     @Override
     public Cursor query(Filter filter, String revisionId, NodeState root) {
         try {
-            Directory directory = new OakDirectory(store, root, index.getPath());
+            Directory directory = new OakDirectory(store, root, indexDataPath);
             try {
                 IndexReader reader = DirectoryReader.open(directory);
                 try {
@@ -111,6 +118,7 @@ public class LuceneIndex implements QueryIndex {
                 directory.close();
             }
         } catch (IOException e) {
+            e.printStackTrace();
             return new PathCursor(Collections.<String> emptySet());
         }
     }
@@ -157,7 +165,7 @@ public class LuceneIndex implements QueryIndex {
                 last = pr.last.getString();
             }
 
-            if (first .equals(last) && pr.firstIncluding && pr.lastIncluding) {
+            if (first.equals(last) && pr.firstIncluding && pr.lastIncluding) {
                 qs.add(new TermQuery(new Term(name, first)));
             } else {
                 qs.add(TermRangeQuery.newStringRange(name, first, last,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexFactory.java
similarity index 52%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexInfo.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexFactory.java
index 8f45b729f7..6eacd1e13b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexInfo.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexFactory.java
@@ -16,46 +16,28 @@
  */
 package org.apache.jackrabbit.oak.plugins.lucene;
 
-import java.util.Arrays;
-import java.util.List;
+import org.apache.jackrabbit.mk.api.MicroKernel;
+import org.apache.jackrabbit.oak.spi.query.Index;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexFactory;
 
-/**
- * LuceneIndexInfo contains information about a lucene index
- * 
- */
-public class LuceneIndexInfo {
-
-    /**
-     * the index name
-     */
-    private final String name;
-
-    /**
-     * the index path, broken into path segments
-     */
-    private final String[] path;
-
-    public LuceneIndexInfo(String name, String[] path) {
-        this.name = name;
-        this.path = path;
-    }
+public class LuceneIndexFactory implements IndexFactory {
 
-    public LuceneIndexInfo(String name, List<String> path) {
-        this(name, path.toArray(new String[path.size()]));
-    }
+    public static final String TYPE = "lucene";
 
-    public String getName() {
-        return name;
+    @Override
+    public void init(MicroKernel mk) {
+        // not needed
     }
 
-    public String[] getPath() {
-        return path;
+    @Override
+    public String[] getTypes() {
+        return new String[] { TYPE };
     }
 
     @Override
-    public String toString() {
-        return "IndexInfo [name=" + name + ", path=" + Arrays.toString(path)
-                + "]";
+    public Index createIndex(IndexDefinition indexDefinition) {
+        return new LuceneEditor(indexDefinition);
     }
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexProvider.java
index 3dd5eec95c..1d77db9611 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexProvider.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexProvider.java
@@ -27,6 +27,7 @@ import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.kernel.KernelNodeStore;
 import org.apache.jackrabbit.oak.spi.QueryIndex;
 import org.apache.jackrabbit.oak.spi.QueryIndexProvider;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.slf4j.Logger;
@@ -89,7 +90,7 @@ public class LuceneIndexProvider implements QueryIndexProvider {
         }
 
         List<QueryIndex> tempIndexes = new ArrayList<QueryIndex>();
-        for (LuceneIndexInfo childIndex : getIndexInfos(index, indexPath)) {
+        for (IndexDefinition childIndex : getIndexInfos(index, indexPath)) {
             LOG.debug("adding a new lucene index instance @ {}", childIndex);
             tempIndexes.add(new LuceneIndex(store, childIndex));
         }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexUtils.java
index cbfcb1c70a..d804b1b436 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexUtils.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneIndexUtils.java
@@ -18,24 +18,28 @@ package org.apache.jackrabbit.oak.plugins.lucene;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
+import org.apache.jackrabbit.oak.api.CoreValueFactory;
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinitionImpl;
 import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
 public class LuceneIndexUtils {
 
-    /**
-     * switch to "oak:index" as soon as it is possible
-     */
-    public static final String DEFAULT_INDEX_HOME = "/oak-index";
+    public static final String DEFAULT_INDEX_NAME = "default-lucene";
 
-    public static final String DEFAULT_INDEX_NAME = "default";
+    public static final String INDEX_DATA_CHILD_NAME = ":data";
 
-    public static final String[] DEFAULT_INDEX_PATH = { "oak-index", "default",
-            ":data" };
+    // public static final String[] DEFAULT_INDEX_PATH = { "oak-index",
+    // "default",
+    // ":data" };
 
     private LuceneIndexUtils() {
 
@@ -46,23 +50,20 @@ public class LuceneIndexUtils {
      * You still need to call #commit afterwards to persist the changes
      * 
      * @param index
-     * @param path
      * @param indexName
      * @return
      */
-    public static Tree createIndexNode(Tree index, String path, String indexName) {
-        for (String e : PathUtils.elements(path)) {
-            if (PathUtils.denotesRoot(e)) {
-                continue;
-            }
-            if (index.hasChild(e)) {
-                index = index.getChild(e);
-            } else {
-                index = index.addChild(e);
-            }
+    public static Tree createIndexNode(Tree index, String indexName,
+            CoreValueFactory vf) {
+        if (index.hasChild(indexName)) {
+            index = index.getChild(indexName);
+        } else {
+            index = index.addChild(indexName);
         }
-        if (!index.hasChild(":data")) {
-            index.addChild(":data");
+        index.setProperty(IndexDefinition.TYPE_PROPERTY_NAME,
+                vf.createValue(LuceneIndexFactory.TYPE));
+        if (!index.hasChild(INDEX_DATA_CHILD_NAME)) {
+            index.addChild(INDEX_DATA_CHILD_NAME);
         }
         return index;
     }
@@ -72,37 +73,44 @@ public class LuceneIndexUtils {
      * Checks if any of the index's children qualifies as an index node, and
      * returns the list of good candidates.
      * 
-     * For now each child that has a :data node is considered to be a potential
-     * index
+     * For now each child that has a "type=lucene" property and a ":data" node
+     * is considered to be a potential index
      * 
      * @param indexHome
      *            the location of potential index nodes
      * @return the list of existing indexes
      */
-    public static List<LuceneIndexInfo> getIndexInfos(NodeState indexHome,
+    public static List<IndexDefinition> getIndexInfos(NodeState indexHome,
             String parentPath) {
         if (indexHome == null) {
-            return Collections.<LuceneIndexInfo> emptyList();
+            return Collections.<IndexDefinition> emptyList();
         }
-        List<String> parent = segmentPath(parentPath);
-        List<LuceneIndexInfo> tempIndexes = new ArrayList<LuceneIndexInfo>();
+        List<IndexDefinition> tempIndexes = new ArrayList<IndexDefinition>();
         for (ChildNodeEntry c : indexHome.getChildNodeEntries()) {
             NodeState child = c.getNodeState();
-            if (child.hasChildNode(":data")) {
-                List<String> childIndexPath = new ArrayList<String>(parent);
-                childIndexPath.add(c.getName());
-                childIndexPath.add(":data");
-                tempIndexes.add(new LuceneIndexInfo(c.getName(), childIndexPath));
+
+            PropertyState type = child
+                    .getProperty(IndexDefinition.TYPE_PROPERTY_NAME);
+            if (type == null
+                    || type.isArray()
+                    || !LuceneIndexFactory.TYPE.equals(type.getValue()
+                            .getString())) {
+                continue;
             }
-        }
-        return tempIndexes;
-    }
 
-    private static List<String> segmentPath(String path) {
-        List<String> pathElements = new ArrayList<String>();
-        for (String e : PathUtils.elements(path)) {
-            pathElements.add(e);
+            if (child.hasChildNode(INDEX_DATA_CHILD_NAME)) {
+                Map<String, String> props = new HashMap<String, String>();
+                for (PropertyState ps : child.getProperties()) {
+                    if (ps != null && !ps.isArray()) {
+                        String v = ps.getValue().getString();
+                        props.put(ps.getName(), v);
+                    }
+                }
+                tempIndexes.add(new IndexDefinitionImpl(c.getName(), type
+                        .getValue().getString(), PathUtils.concat(parentPath,
+                        c.getName()), false, null));
+            }
         }
-        return pathElements;
+        return tempIndexes;
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PrefixContentIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PrefixContentIndex.java
index fa90f3814e..8e80bf05e1 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PrefixContentIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PrefixContentIndex.java
@@ -19,10 +19,12 @@
 package org.apache.jackrabbit.oak.query.index;
 
 import java.util.Iterator;
+
 import javax.jcr.PropertyType;
-import org.apache.jackrabbit.mk.index.PrefixIndex;
+
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.kernel.CoreValueMapper;
+import org.apache.jackrabbit.oak.plugins.index.PrefixIndex;
 import org.apache.jackrabbit.oak.spi.Cursor;
 import org.apache.jackrabbit.oak.spi.Filter;
 import org.apache.jackrabbit.oak.spi.IndexRow;
@@ -89,7 +91,7 @@ public class PrefixContentIndex implements QueryIndex {
 
     @Override
     public String getIndexName() {
-        return index.getIndexNodeName();
+        return index.getDefinition().getName();
     }
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PropertyContentIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PropertyContentIndex.java
index e6e0f762d8..5a1967cc2b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PropertyContentIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/PropertyContentIndex.java
@@ -19,8 +19,8 @@
 package org.apache.jackrabbit.oak.query.index;
 
 import java.util.Iterator;
-import org.apache.jackrabbit.mk.index.PropertyIndex;
 import org.apache.jackrabbit.oak.api.CoreValue;
+import org.apache.jackrabbit.oak.plugins.index.PropertyIndex;
 import org.apache.jackrabbit.oak.spi.Cursor;
 import org.apache.jackrabbit.oak.spi.Filter;
 import org.apache.jackrabbit.oak.spi.IndexRow;
@@ -49,7 +49,7 @@ public class PropertyContentIndex implements QueryIndex {
             // only support equality matches (for now)
             return Double.MAX_VALUE;
         }
-        boolean unique = index.isUnique();
+        boolean unique = index.getDefinition().isUnique();
         return unique ? 2 : 20;
     }
 
@@ -76,7 +76,7 @@ public class PropertyContentIndex implements QueryIndex {
 
     @Override
     public String getIndexName() {
-        return index.getIndexNodeName();
+        return index.getDefinition().getName();
     }
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Index.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Index.java
new file mode 100644
index 0000000000..d930160eef
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Index.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import java.io.Closeable;
+
+import javax.annotation.Nonnull;
+
+import org.apache.jackrabbit.oak.spi.commit.CommitEditor;
+
+/**
+ * An index is a lookup mechanism. It typically uses a tree to store data. It
+ * updates the tree whenever a node was changed. The index is updated
+ * automatically.
+ */
+public interface Index extends CommitEditor, Closeable {
+
+    /**
+     * Get the the index definition. This contains the name, type, uniqueness
+     * and other properties.
+     * 
+     * @return the index definition
+     */
+    @Nonnull
+    IndexDefinition getDefinition();
+
+//    /**
+//     * The given node was added or removed.
+//     *
+//     * @param node the node including (old or new) data
+//     * @param add true if added, false if removed
+//     */
+//    void addOrRemoveNode(NodeImpl node, boolean add);
+//
+//    /**
+//     * The given property was added or removed.
+//     *
+//     * @param nodePath the path of the node
+//     * @param propertyName the property name
+//     * @param value the old (when deleting) or new (when adding) value
+//     * @param add true if added, false if removed
+//     */
+//    void addOrRemoveProperty(String nodePath, String propertyName,
+//            String value, boolean add);
+//
+//    /**
+//     * Get an iterator over the paths for the given value. For unique
+//     * indexes, the iterator will contain at most one element.
+//     *
+//     * @param value the value, or null to return all indexed rows
+//     * @param revision the revision
+//     * @return an iterator of the paths (an empty iterator if not found)
+//     */
+//    Iterator<String> getPaths(String value, String revision);
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexDefinition.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexDefinition.java
new file mode 100644
index 0000000000..a4d4fbae82
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexDefinition.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import java.util.Map;
+
+import javax.annotation.Nonnull;
+
+/**
+ * Defines an index definition
+ * 
+ */
+public interface IndexDefinition {
+
+    String TYPE_PROPERTY_NAME = "type";
+
+    String UNIQUE_PROPERTY_NAME = "unique";
+
+    /**
+     * Get the unique index name. This is also the name of the index node.
+     * 
+     * @return the index name
+     */
+    @Nonnull
+    String getName();
+
+    /**
+     * @return the index type
+     */
+    @Nonnull
+    String getType();
+
+    /**
+     * @return the index path, includung the name as the last segment
+     */
+    @Nonnull
+    String getPath();
+
+    /**
+     * Whether each value may only appear once in the index.
+     * 
+     * @return true if unique
+     */
+    boolean isUnique();
+
+    /**
+     * @return the index properties
+     */
+    @Nonnull
+    Map<String, String> getProperties();
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexDefinitionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexDefinitionImpl.java
new file mode 100644
index 0000000000..93436f1ab9
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexDefinitionImpl.java
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class IndexDefinitionImpl implements IndexDefinition {
+
+    private final String name;
+    private final String type;
+    private final String path;
+    private final boolean unique;
+    private final Map<String, String> properties;
+
+    public IndexDefinitionImpl(String name, String type, String path,
+            boolean unique, Map<String, String> properties) {
+        this.name = name;
+        this.type = type;
+        this.path = path;
+        this.unique = unique;
+        if (properties != null) {
+            this.properties = properties;
+        } else {
+            this.properties = new HashMap<String, String>();
+        }
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public String getType() {
+        return type;
+    }
+
+    @Override
+    public String getPath() {
+        return path;
+    }
+
+    @Override
+    public boolean isUnique() {
+        return unique;
+    }
+
+    @Override
+    public Map<String, String> getProperties() {
+        return properties;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((path == null) ? 0 : path.hashCode());
+        result = prime * result + ((type == null) ? 0 : type.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        IndexDefinitionImpl other = (IndexDefinitionImpl) obj;
+        if (path == null) {
+            if (other.path != null)
+                return false;
+        } else if (!path.equals(other.path))
+            return false;
+        if (type == null) {
+            if (other.type != null)
+                return false;
+        } else if (!type.equals(other.type))
+            return false;
+        return true;
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexFactory.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexFactory.java
new file mode 100644
index 0000000000..956922f238
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexFactory.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import javax.annotation.CheckForNull;
+import javax.annotation.Nonnull;
+
+import org.apache.jackrabbit.mk.api.MicroKernel;
+
+public interface IndexFactory {
+
+    /**
+     * initializes the provided factory
+     */
+    void init(MicroKernel mk);
+
+    /**
+     * @return the index types that this factory can create
+     */
+    @Nonnull
+    String[] getTypes();
+
+    /**
+     * @param indexDefinition
+     * @return
+     */
+    @CheckForNull
+    Index createIndex(IndexDefinition indexDefinition);
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexManager.java
new file mode 100644
index 0000000000..f4e0b5913f
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexManager.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import java.io.Closeable;
+import java.util.Set;
+
+import javax.annotation.Nonnull;
+
+/**
+ * <p>
+ * Index Manager keeps track of all the available indexes.
+ * </p>
+ * 
+ * <p>
+ * As a configuration reference it will use the index definitions nodes at
+ * {@link IndexUtils#DEFAULT_INDEX_HOME}.
+ * </p>
+ * 
+ * <p>
+ * TODO It *should* define an API for managing indexes (CRUD ops)
+ * </p>
+ * 
+ * <p>
+ * TODO Document simple node properties to create an index type
+ * </p>
+ * </p>
+ */
+public interface IndexManager extends Closeable {
+
+    /**
+     * Creates an index by passing the {@link IndexDefinition} to the registered
+     * {@link IndexFactory}(es)
+     * 
+     * @param indexDefinition
+     */
+    void registerIndex(IndexDefinition... indexDefinition);
+
+    void registerIndexFactory(IndexFactory factory);
+
+    void init();
+
+    @Nonnull
+    Set<IndexDefinition> getIndexes();
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexManagerImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexManagerImpl.java
new file mode 100644
index 0000000000..eb810b7306
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexManagerImpl.java
@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.apache.jackrabbit.mk.api.MicroKernel;
+import org.apache.jackrabbit.oak.api.ContentSession;
+import org.apache.jackrabbit.oak.api.Tree;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.collect.ImmutableSet;
+
+public class IndexManagerImpl implements IndexManager {
+
+    // TODO implement an observation listener so that the {@link
+    // IndexManagerImpl} automatically creates new indexes based on new nodes
+    // added under {@link #indexConfigPath}
+
+    private static final Logger LOG = LoggerFactory
+            .getLogger(IndexManagerImpl.class);
+
+    private final String indexConfigPath;
+
+    private final ContentSession session;
+
+    private final MicroKernel mk;
+
+    private final Map<String, IndexFactory> indexFactories = new ConcurrentHashMap<String, IndexFactory>();
+
+    private final Map<IndexDefinition, Index> indexes = new ConcurrentHashMap<IndexDefinition, Index>();
+
+    public IndexManagerImpl(String indexConfigPath, ContentSession session,
+            MicroKernel mk) {
+        this.indexConfigPath = indexConfigPath;
+        this.session = session;
+        this.mk = mk;
+    }
+
+    @Override
+    public void registerIndexFactory(IndexFactory factory) {
+        factory.init(mk);
+        for (String type : factory.getTypes()) {
+            if (indexFactories.remove(type) != null) {
+                // TODO is override allowed?
+            }
+            indexFactories.put(type, factory);
+        }
+    }
+
+    @Override
+    public void init() {
+        //
+        // TODO hardwire default property indexes first ?
+        // registerIndexFactory(type, factory);
+        Tree definitions = session.getCurrentRoot().getTree(indexConfigPath);
+        if (definitions == null) {
+            return;
+        }
+
+        List<IndexDefinition> defs = new ArrayList<IndexDefinition>();
+        for (Tree c : definitions.getChildren()) {
+            IndexDefinition def = IndexUtils.getDefs(indexConfigPath, c);
+            if (def == null) {
+                LOG.warn("Skipping illegal index definition name {} @ {}",
+                        c.getName(), indexConfigPath);
+                continue;
+            }
+            if (indexes.get(def.getName()) != null) {
+                LOG.warn("Skipping existing index definition name {} @ {}",
+                        c.getName(), indexConfigPath);
+                continue;
+            }
+            defs.add(def);
+        }
+        registerIndex(defs.toArray(new IndexDefinition[defs.size()]));
+    }
+
+    @Override
+    public void registerIndex(IndexDefinition... indexDefinition) {
+        for (IndexDefinition def : indexDefinition) {
+            if (def == null) {
+                continue;
+            }
+            IndexFactory f = indexFactories.get(def.getType());
+            if (f == null) {
+                LOG.warn(
+                        "Skipping unknown index definition type {}, name {} @ {}",
+                        new String[] { def.getType(), indexConfigPath,
+                                def.getName() });
+                continue;
+            }
+            Index index = f.createIndex(def);
+            if (index != null) {
+                indexes.put(def, index);
+            }
+        }
+    }
+
+    @Override
+    public Set<IndexDefinition> getIndexes() {
+        return ImmutableSet.copyOf(indexes.keySet());
+    }
+
+    @Override
+    public synchronized void close() throws IOException {
+        Iterator<IndexDefinition> iterator = indexes.keySet().iterator();
+        while (iterator.hasNext()) {
+            IndexDefinition id = iterator.next();
+            try {
+                indexes.get(id).close();
+            } catch (IOException e) {
+                LOG.error("error closing index {}", id.getName(), e);
+            }
+            iterator.remove();
+        }
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexUtils.java
new file mode 100644
index 0000000000..43af744c3d
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/IndexUtils.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.api.Tree;
+import org.apache.jackrabbit.oak.commons.PathUtils;
+
+public class IndexUtils {
+
+    /**
+     * switch to "oak:index" as soon as it is possible
+     */
+    public static final String DEFAULT_INDEX_HOME = "/oak-index";
+
+    public static IndexDefinition getDefs(String path, Tree tree) {
+        String name = tree.getName();
+        PropertyState typeProp = tree
+                .getProperty(IndexDefinition.TYPE_PROPERTY_NAME);
+        if (typeProp == null || typeProp.isArray()) {
+            return null;
+        }
+        String type = typeProp.getValue().getString();
+
+        boolean unique = false;
+        PropertyState uniqueProp = tree
+                .getProperty(IndexDefinition.UNIQUE_PROPERTY_NAME);
+        if (uniqueProp != null && !uniqueProp.isArray()) {
+            unique = uniqueProp.getValue().getBoolean();
+        }
+
+        Map<String, String> props = new HashMap<String, String>();
+        for (PropertyState ps : tree.getProperties()) {
+            if (ps != null && !ps.isArray()) {
+                String v = ps.getValue().getString();
+                props.put(ps.getName(), v);
+            }
+        }
+        return new IndexDefinitionImpl(name, type,
+                PathUtils.concat(path, name), unique, props);
+    }
+
+    /**
+     * Splits a give path into its segments and optionally appends a new path to
+     * the resulting array
+     * 
+     * @return array containing the path segments
+     */
+    public static String[] split(String pathIn, String append) {
+        List<String> paths = new ArrayList<String>();
+        for (String p : pathIn.split("/")) {
+            if (p.trim().length() != 0) {
+                paths.add(p);
+            }
+        }
+        if (append != null && append.trim().length() != 0) {
+            paths.add(append);
+        }
+
+        return paths.toArray(new String[paths.size()]);
+    }
+
+}
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/mk/index/IndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/mk/index/IndexTest.java
index 15fd1af1e9..cfe0ee355e 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/mk/index/IndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/mk/index/IndexTest.java
@@ -22,6 +22,10 @@ import java.util.TreeMap;
 import junit.framework.Assert;
 import org.apache.jackrabbit.mk.api.MicroKernel;
 import org.apache.jackrabbit.mk.core.MicroKernelImpl;
+import org.apache.jackrabbit.oak.plugins.index.BTree;
+import org.apache.jackrabbit.oak.plugins.index.Cursor;
+import org.apache.jackrabbit.oak.plugins.index.Indexer;
+import org.apache.jackrabbit.oak.plugins.index.PropertyIndex;
 import org.junit.Test;
 
 /**
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PrefixIndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PrefixIndexTest.java
index 8e7c8112b3..bf61cd6b80 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PrefixIndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PrefixIndexTest.java
@@ -20,6 +20,8 @@ import java.util.Iterator;
 import junit.framework.Assert;
 import org.apache.jackrabbit.mk.api.MicroKernel;
 import org.apache.jackrabbit.mk.core.MicroKernelImpl;
+import org.apache.jackrabbit.oak.plugins.index.Indexer;
+import org.apache.jackrabbit.oak.plugins.index.PrefixIndex;
 import org.junit.Test;
 
 /**
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PropertyIndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PropertyIndexTest.java
index 3a834f4535..27cdd4f0cb 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PropertyIndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/mk/index/PropertyIndexTest.java
@@ -19,6 +19,8 @@ package org.apache.jackrabbit.mk.index;
 import junit.framework.Assert;
 import org.apache.jackrabbit.mk.api.MicroKernel;
 import org.apache.jackrabbit.mk.core.MicroKernelImpl;
+import org.apache.jackrabbit.oak.plugins.index.Indexer;
+import org.apache.jackrabbit.oak.plugins.index.PropertyIndex;
 import org.junit.Test;
 
 /**
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/mk/wrapper/IndexWrapperTest.java b/oak-core/src/test/java/org/apache/jackrabbit/mk/wrapper/IndexWrapperTest.java
index 8f0975157d..beea3f9c26 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/mk/wrapper/IndexWrapperTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/mk/wrapper/IndexWrapperTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.jackrabbit.mk.wrapper;
 
+import static org.apache.jackrabbit.oak.plugins.index.Indexer.INDEX_CONFIG_PATH;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import org.apache.jackrabbit.mk.api.MicroKernel;
@@ -36,47 +37,47 @@ public class IndexWrapperTest {
 
     @Test
     public void getNodes() {
-        assertNull(mk.getNodes("/jcr:system/indexes/unknown", head, 1, 0, -1, null));
+        assertNull(mk.getNodes(INDEX_CONFIG_PATH + "/unknown", head, 1, 0, -1, null));
         assertNull(mk.getNodes("/unknown", head, 1, 0, -1, null));
     }
 
     @Test
     public void prefix() {
-        head = mk.commit("/jcr:system/indexes", "+ \"prefix@x\": {}", head, "");
+        head = mk.commit(INDEX_CONFIG_PATH, "+ \"prefix@x\": {}", head, "");
         head = mk.commit("/", "+ \"n1\": { \"value\":\"a:no\" }", head, "");
         head = mk.commit("/", "+ \"n2\": { \"value\":\"x:yes\" }", head, "");
         head = mk.commit("/", "+ \"n3\": { \"value\":\"x:a\" }", head, "");
         head = mk.commit("/", "+ \"n4\": { \"value\":\"x:a\" }", head, "");
-        String empty = mk.getNodes("/jcr:system/indexes/prefix@x?x:no", head, 1, 0, -1, null);
+        String empty = mk.getNodes(INDEX_CONFIG_PATH + "/prefix@x?x:no", head, 1, 0, -1, null);
         assertEquals("[]", empty);
-        String yes = mk.getNodes("/jcr:system/indexes/prefix@x?x:yes", head, 1, 0, -1, null);
+        String yes = mk.getNodes(INDEX_CONFIG_PATH + "/prefix@x?x:yes", head, 1, 0, -1, null);
         assertEquals("[\"/n2/value\"]", yes);
-        String a = mk.getNodes("/jcr:system/indexes/prefix@x?x:a", head, 1, 0, -1, null);
+        String a = mk.getNodes(INDEX_CONFIG_PATH + "/prefix@x?x:a", head, 1, 0, -1, null);
         assertEquals("[\"/n3/value\",\"/n4/value\"]", a);
     }
 
     @Test
     public void propertyUnique() {
-        head = mk.commit("/jcr:system/indexes", "+ \"property@id,unique\": {}", head, "");
+        head = mk.commit(INDEX_CONFIG_PATH, "+ \"property@id,unique\": {}", head, "");
         head = mk.commit("/", "+ \"n1\": { \"value\":\"empty\" }", head, "");
         head = mk.commit("/", "+ \"n2\": { \"id\":\"1\" }", head, "");
-        String empty = mk.getNodes("/jcr:system/indexes/property@id,unique?0", head, 1, 0, -1, null);
+        String empty = mk.getNodes(INDEX_CONFIG_PATH + "/property@id,unique?0", head, 1, 0, -1, null);
         assertEquals("[]", empty);
-        String one = mk.getNodes("/jcr:system/indexes/property@id,unique?1", head, 1, 0, -1, null);
+        String one = mk.getNodes(INDEX_CONFIG_PATH + "/property@id,unique?1", head, 1, 0, -1, null);
         assertEquals("[\"/n2\"]", one);
     }
 
     @Test
     public void propertyNonUnique() {
-        head = mk.commit("/jcr:system/indexes", "+ \"property@ref\": {}", head, "");
+        head = mk.commit(INDEX_CONFIG_PATH, "+ \"property@ref\": {}", head, "");
         head = mk.commit("/", "+ \"n1\": { \"ref\":\"a\" }", head, "");
         head = mk.commit("/", "+ \"n2\": { \"ref\":\"b\" }", head, "");
         head = mk.commit("/", "+ \"n3\": { \"ref\":\"b\" }", head, "");
-        String empty = mk.getNodes("/jcr:system/indexes/property@ref?no", head, 1, 0, -1, null);
+        String empty = mk.getNodes(INDEX_CONFIG_PATH + "/property@ref?no", head, 1, 0, -1, null);
         assertEquals("[]", empty);
-        String one = mk.getNodes("/jcr:system/indexes/property@ref?a", head, 1, 0, -1, null);
+        String one = mk.getNodes(INDEX_CONFIG_PATH + "/property@ref?a", head, 1, 0, -1, null);
         assertEquals("[\"/n1\"]", one);
-        String two = mk.getNodes("/jcr:system/indexes/property@ref?b", head, 1, 0, -1, null);
+        String two = mk.getNodes(INDEX_CONFIG_PATH + "/property@ref?b", head, 1, 0, -1, null);
         assertEquals("[\"/n2\",\"/n3\"]", two);
     }
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/AbstractLuceneQueryTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/AbstractLuceneQueryTest.java
index 2fb8e9b0f1..254c4665da 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/AbstractLuceneQueryTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/AbstractLuceneQueryTest.java
@@ -29,6 +29,7 @@ import org.apache.jackrabbit.oak.api.Result;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.SessionQueryEngine;
 import org.apache.jackrabbit.oak.api.Tree;
+import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.core.ContentRepositoryImpl;
 import org.apache.jackrabbit.oak.core.DefaultConflictHandler;
 import org.apache.jackrabbit.oak.plugins.name.NameValidatorProvider;
@@ -43,7 +44,7 @@ import org.apache.jackrabbit.oak.spi.commit.ValidatingEditor;
 import org.apache.jackrabbit.oak.spi.commit.ValidatorProvider;
 import org.junit.Before;
 
-import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.DEFAULT_INDEX_HOME;
+import static org.apache.jackrabbit.oak.spi.query.IndexUtils.DEFAULT_INDEX_HOME;
 import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.DEFAULT_INDEX_NAME;
 import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.createIndexNode;
 
@@ -64,11 +65,11 @@ public abstract class AbstractLuceneQueryTest extends AbstractOakTest {
     @Before
     public void before() throws Exception {
         super.before();
-
         session = createAdminSession();
-        cleanupIndexNode();
+        root = session.getCurrentRoot();
         vf = session.getCoreValueFactory();
         qe = session.getQueryEngine();
+        cleanupIndexNode();
 
     }
 
@@ -98,24 +99,32 @@ public abstract class AbstractLuceneQueryTest extends AbstractOakTest {
 
     /**
      * Recreates an empty index node, ready to be used in tests
-     *
+     * 
      * @throws Exception
      */
     private void cleanupIndexNode() throws Exception {
-        root = session.getCurrentRoot();
         Tree index = root.getTree(DEFAULT_INDEX_HOME);
         if (index != null) {
             index = index.getChild(TEST_INDEX_NAME);
             if (index != null) {
                 index.remove();
             }
+        } else {
+            index = root.getTree("/");
+            for (String p : PathUtils.elements(DEFAULT_INDEX_HOME)) {
+                if (index.hasChild(p)) {
+                    index = index.getChild(p);
+                } else {
+                    index = index.addChild(p);
+                }
+            }
         }
-        createIndexNode(root.getTree("/"), DEFAULT_INDEX_HOME, TEST_INDEX_NAME);
+
+        createIndexNode(root.getTree(DEFAULT_INDEX_HOME), TEST_INDEX_NAME, vf);
         root.commit(DefaultConflictHandler.OURS);
     }
 
     protected Result executeQuery(String statement) throws ParseException {
-        return qe.executeQuery(statement, SQL2, Long.MAX_VALUE, 0,
-                null, null);
+        return qe.executeQuery(statement, SQL2, Long.MAX_VALUE, 0, null, null);
     }
 }
\ No newline at end of file
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditorTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditorTest.java
index d50498ae07..4581c6ea08 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditorTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/lucene/LuceneEditorTest.java
@@ -16,6 +16,12 @@
  */
 package org.apache.jackrabbit.oak.plugins.lucene;
 
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.DEFAULT_INDEX_NAME;
+import static org.apache.jackrabbit.oak.spi.query.IndexUtils.DEFAULT_INDEX_HOME;
+
 import org.apache.jackrabbit.mk.core.MicroKernelImpl;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
@@ -29,35 +35,29 @@ import org.apache.jackrabbit.oak.query.index.FilterImpl;
 import org.apache.jackrabbit.oak.spi.Cursor;
 import org.apache.jackrabbit.oak.spi.Filter;
 import org.apache.jackrabbit.oak.spi.QueryIndex;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinition;
+import org.apache.jackrabbit.oak.spi.query.IndexDefinitionImpl;
 import org.junit.Test;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
-import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.DEFAULT_INDEX_NAME;
-import static org.apache.jackrabbit.oak.plugins.lucene.LuceneIndexUtils.DEFAULT_INDEX_PATH;
-
 public class LuceneEditorTest {
 
     @Test
     public void testLucene() throws Exception {
-        LuceneIndexInfo indexInfo = new LuceneIndexInfo(DEFAULT_INDEX_NAME,
-                DEFAULT_INDEX_PATH);
+        IndexDefinition testID = new IndexDefinitionImpl(DEFAULT_INDEX_NAME,
+                LuceneIndexFactory.TYPE, DEFAULT_INDEX_HOME, false, null);
 
         KernelNodeStore store = new KernelNodeStore(new MicroKernelImpl());
-        store.setEditor(new LuceneEditor(indexInfo.getPath()));
+        store.setEditor(new LuceneEditor(testID));
         Root root = new RootImpl(store, "", new TestAcContext());
         Tree tree = root.getTree("/");
 
         tree.setProperty("foo", MemoryValueFactory.INSTANCE.createValue("bar"));
         root.commit(DefaultConflictHandler.OURS);
 
-        QueryIndex index = new LuceneIndex(store, indexInfo);
+        QueryIndex index = new LuceneIndex(store, testID);
         FilterImpl filter = new FilterImpl(null);
         filter.restrictPath("/", Filter.PathRestriction.EXACT);
-        filter.restrictProperty(
-                "foo",
-                Operator.EQUAL,
+        filter.restrictProperty("foo", Operator.EQUAL,
                 MemoryValueFactory.INSTANCE.createValue("bar"));
         Cursor cursor = index.query(filter, null, store.getRoot());
         assertTrue(cursor.next());
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/spi/query/IndexManagerTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/spi/query/IndexManagerTest.java
new file mode 100644
index 0000000000..5731a93a05
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/spi/query/IndexManagerTest.java
@@ -0,0 +1,183 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.spi.query;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+
+import org.apache.jackrabbit.mk.api.MicroKernel;
+import org.apache.jackrabbit.mk.core.MicroKernelImpl;
+import org.apache.jackrabbit.oak.AbstractOakTest;
+import org.apache.jackrabbit.oak.api.CommitFailedException;
+import org.apache.jackrabbit.oak.api.ContentRepository;
+import org.apache.jackrabbit.oak.api.ContentSession;
+import org.apache.jackrabbit.oak.api.CoreValueFactory;
+import org.apache.jackrabbit.oak.api.Root;
+import org.apache.jackrabbit.oak.api.Tree;
+import org.apache.jackrabbit.oak.core.ContentRepositoryImpl;
+import org.apache.jackrabbit.oak.core.DefaultConflictHandler;
+import org.apache.jackrabbit.oak.spi.commit.ValidatorProvider;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.apache.jackrabbit.oak.spi.state.NodeStore;
+import org.junit.Before;
+import org.junit.Test;
+
+public class IndexManagerTest extends AbstractOakTest {
+
+    protected ContentSession session;
+    private CoreValueFactory vf;
+    private final MicroKernel mk = new MicroKernelImpl();
+    private Root root;
+
+    @Override
+    protected ContentRepository createRepository() {
+        return new ContentRepositoryImpl(mk, null, (ValidatorProvider) null);
+    }
+
+    @Before
+    public void before() throws Exception {
+        super.before();
+        session = createAdminSession();
+        vf = session.getCoreValueFactory();
+        root = session.getCurrentRoot();
+
+    }
+
+    @Test
+    public void testNoDef() throws Exception {
+
+        // setup index definitions
+        String indexdef = "indexdefs" + System.currentTimeMillis();
+        root.getTree("/").addChild("test").addChild(indexdef);
+        root.commit(DefaultConflictHandler.OURS);
+
+        IndexManager im = new IndexManagerImpl("/test/" + indexdef, session, mk);
+        // setup index factory
+        im.registerIndexFactory(new TestIndexFactory());
+        im.init();
+
+        assertTrue(im.getIndexes().isEmpty());
+    }
+
+    @Test
+    public void testSimpleDef() throws Exception {
+
+        // setup index definitions
+        String indexdef = "indexdefs" + System.currentTimeMillis();
+
+        Tree test = root.getTree("/").addChild("test").addChild(indexdef);
+
+        Tree def = test.addChild("a");
+        def.setProperty("type", vf.createValue("custom"));
+        def.setProperty("other", vf.createValue("other-value"));
+        root.commit(DefaultConflictHandler.OURS);
+
+        IndexManager im = new IndexManagerImpl("/test/" + indexdef, session, mk);
+        // setup index factory
+        im.registerIndexFactory(new TestIndexFactory());
+        im.init();
+
+        assertEquals(1, im.getIndexes().size());
+        IndexDefinition id = im.getIndexes().iterator().next();
+
+        assertEquals("a", id.getName());
+        assertEquals("custom", id.getType());
+        assertNotNull(id.getProperties());
+        assertEquals("other-value", id.getProperties().get("other"));
+
+    }
+
+    @Test
+    public void testIllegalDef() throws Exception {
+        // setup index definitions
+        String indexdef = "indexdefs" + System.currentTimeMillis();
+
+        Tree test = root.getTree("/").addChild("test").addChild(indexdef);
+
+        Tree def1 = test.addChild("a");
+        def1.setProperty("type2", vf.createValue("custom"));
+        root.commit(DefaultConflictHandler.OURS);
+
+        IndexManager im = new IndexManagerImpl("/test/" + indexdef, session, mk);
+        // setup index factory
+        im.registerIndexFactory(new TestIndexFactory());
+        im.init();
+
+        assertTrue(im.getIndexes().isEmpty());
+    }
+
+    @Test
+    public void testUnknownDef() throws Exception {
+        // setup index definitions
+        String indexdef = "indexdefs" + System.currentTimeMillis();
+        Tree test = root.getTree("/").addChild("test").addChild(indexdef);
+
+        Tree def1 = test.addChild("a");
+        def1.setProperty("type", vf.createValue("custom"));
+        root.commit(DefaultConflictHandler.OURS);
+
+        IndexManager im = new IndexManagerImpl("/test/" + indexdef, session, mk);
+        im.init();
+
+        assertTrue(im.getIndexes().isEmpty());
+    }
+
+    /**
+     * Test IndexFactory, not supposed to do anything, its purpose is to just
+     * register a given index type
+     * 
+     */
+    private static class TestIndexFactory implements IndexFactory {
+
+        @Override
+        public Index createIndex(IndexDefinition indexDefinition) {
+            return new TestIndex();
+        }
+
+        @Override
+        public String[] getTypes() {
+            return new String[] { "custom" };
+        }
+
+        @Override
+        public void init(MicroKernel mk) {
+        }
+    }
+
+    private static class TestIndex implements Index {
+
+        @Override
+        public NodeState editCommit(NodeStore store, NodeState before,
+                NodeState after) throws CommitFailedException {
+            return null;
+        }
+
+        @Override
+        public IndexDefinition getDefinition() {
+            return new IndexDefinitionImpl("test", "custom", "/test", false,
+                    null);
+        }
+
+        @Override
+        public void close() throws IOException {
+        }
+
+    }
+}
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/queryTest.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/queryTest.txt
index b078df43d1..637b57f557 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/queryTest.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/queryTest.txt
@@ -31,7 +31,7 @@ nt:base as nt:base /* traverse "//*" */
 select * from [nt:base] where property([*], 'REFERENCE') = CAST('123' AS REFERENCE)
 /test/a
 
-commit /jcr:system/indexes + "prefix@ref:": {}
+commit /oak-index/indexes + "prefix@ref:": {}
 
 explain select * from [nt:base] where property([*], 'REFERENCE') = CAST('123' AS REFERENCE)
 nt:base as nt:base /* prefixIndex "ref:123" */
@@ -40,7 +40,7 @@ select * from [nt:base] where property([*], 'REFERENCE') = CAST('123' AS REFEREN
 /test/a
 
 commit / - "test"
-commit /jcr:system/indexes - "prefix@ref:"
+commit /oak-index/indexes - "prefix@ref:"
 
 # sql-1 query (nt:unstructured needs to be escaped in sql-2)
 
@@ -76,7 +76,7 @@ select * from [nt:base] as p inner join [nt:base] as p on ischildnode(p, p) wher
 java.lang.IllegalArgumentException: Two selectors with the same name: p
 
 commit / + "test": { "a": { "id": "10" }, "b": { "id" : "20" }}
-commit /jcr:system/indexes + "property@id,unique": {}
+commit /oak-index/indexes + "property@id,unique": {}
 
 # combining 'not' and 'and'
 
@@ -100,7 +100,7 @@ explain select * from [nt:base] where id > '10'
 nt:base as nt:base /* traverse "//*" */
 
 commit / - "test"
-commit /jcr:system/indexes - "property@id,unique"
+commit /oak-index/indexes - "property@id,unique"
 
 # fulltext search
 
@@ -143,8 +143,13 @@ select * from [nt:base] as b where localname(b) = 'resource'
 select * from [nt:base] as x where isdescendantnode(x, '/')
 /
 /jcr:system
-/jcr:system/indexes
-/jcr:system/indexes/:data
+/jcr:system/jcr:activities
+/jcr:system/jcr:nodeTypes
+/jcr:system/jcr:versionStorage
+/jcr:system/rep:privileges
+/oak-index
+/oak-index/indexes
+/oak-index/indexes/:data
 /test
 /test/jcr:resource
 /test/resource
@@ -165,6 +170,7 @@ select * from [nt:base] as p where p.[jcr:path] = '/parents'
 select * from [nt:base] as p inner join [nt:base] as p2 on ischildnode(p2, p) where p.[jcr:path] = '/'
 /, /children
 /, /jcr:system
+/, /oak-index
 /, /parents
 
 select * from [nt:base] as p inner join [nt:base] as p2 on isdescendantnode(p2, p) where p.[jcr:path] = '/parents'
@@ -222,8 +228,13 @@ commit / + "test2": { "id":"1", "x": "2" }
 select * from [nt:base]
 /
 /jcr:system
-/jcr:system/indexes
-/jcr:system/indexes/:data
+/jcr:system/jcr:activities
+/jcr:system/jcr:nodeTypes
+/jcr:system/jcr:versionStorage
+/jcr:system/rep:privileges
+/oak-index
+/oak-index/indexes
+/oak-index/indexes/:data
 /test
 /test/hello
 /test/world
@@ -242,16 +253,26 @@ select * from [nt:base] where id = '1' or x = '2'
 select * from [nt:base] where not (id = '1' or x = '2')
 /
 /jcr:system
-/jcr:system/indexes
-/jcr:system/indexes/:data
+/jcr:system/jcr:activities
+/jcr:system/jcr:nodeTypes
+/jcr:system/jcr:versionStorage
+/jcr:system/rep:privileges
+/oak-index
+/oak-index/indexes
+/oak-index/indexes/:data
 /test
 /test/hello
 
 select * from [nt:base] where x is null
 /
 /jcr:system
-/jcr:system/indexes
-/jcr:system/indexes/:data
+/jcr:system/jcr:activities
+/jcr:system/jcr:nodeTypes
+/jcr:system/jcr:versionStorage
+/jcr:system/rep:privileges
+/oak-index
+/oak-index/indexes
+/oak-index/indexes/:data
 /test
 
 commit / - "test"
@@ -273,6 +294,11 @@ null
 null
 null
 null
+null
+null
+null
+null
+null
 
 select * from [nt:base] where length(name) = 5
 /test
