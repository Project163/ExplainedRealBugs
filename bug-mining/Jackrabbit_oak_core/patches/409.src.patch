diff --git a/oak-core/pom.xml b/oak-core/pom.xml
index b1fbecb4ba..cbae344e0c 100644
--- a/oak-core/pom.xml
+++ b/oak-core/pom.xml
@@ -51,6 +51,7 @@
               org.apache.jackrabbit.oak.plugins.value,
               org.apache.jackrabbit.oak.plugins.commit,
               org.apache.jackrabbit.oak.plugins.index,
+              org.apache.jackrabbit.oak.plugins.index.aggregate,
               org.apache.jackrabbit.oak.plugins.index.nodetype,
               org.apache.jackrabbit.oak.plugins.index.property,
               org.apache.jackrabbit.oak.plugins.memory,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/AggregateIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/AggregateIndex.java
index f0d3d49aec..e4177a6d66 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/AggregateIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/AggregateIndex.java
@@ -16,26 +16,37 @@
  */
 package org.apache.jackrabbit.oak.plugins.index.aggregate;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import org.apache.jackrabbit.oak.query.index.FilterImpl;
+import org.apache.jackrabbit.oak.query.index.IndexRowImpl;
 import org.apache.jackrabbit.oak.spi.query.Cursor;
+import org.apache.jackrabbit.oak.spi.query.Cursors;
+import org.apache.jackrabbit.oak.spi.query.Cursors.AbstractCursor;
 import org.apache.jackrabbit.oak.spi.query.Filter;
+import org.apache.jackrabbit.oak.spi.query.IndexRow;
 import org.apache.jackrabbit.oak.spi.query.QueryIndex.FulltextQueryIndex;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterators;
+
 /**
  * A virtual full-text that can aggregate nodes based on aggregate definitions.
  * Internally, it uses another full-text index.
  */
 public class AggregateIndex implements FulltextQueryIndex {
-    
+
     private final FulltextQueryIndex baseIndex;
-    
+
     public AggregateIndex(FulltextQueryIndex baseIndex) {
         this.baseIndex = baseIndex;
     }
 
     @Override
     public double getCost(Filter filter, NodeState rootState) {
-        // TODO dummy implementation
         if (baseIndex == null) {
             return Double.POSITIVE_INFINITY;
         }
@@ -44,26 +55,99 @@ public class AggregateIndex implements FulltextQueryIndex {
 
     @Override
     public Cursor query(Filter filter, NodeState rootState) {
-        // TODO dummy implementation
-        return baseIndex.query(filter, rootState);
+        // pass-through impl
+        if (baseIndex.getNodeAggregator() == null) {
+            return baseIndex.query(filter, rootState);
+        }
+        return new AggregationCursor(baseIndex.query(
+                newAggregationFilter(filter), rootState),
+                baseIndex.getNodeAggregator(), rootState);
+    }
+
+    private static Filter newAggregationFilter(Filter filter) {
+        FilterImpl f = new FilterImpl(filter);
+        // disables node type checks for now
+        f.setMatchesAllTypes(true);
+        return f;
     }
 
     @Override
     public String getPlan(Filter filter, NodeState rootState) {
-        // TODO dummy implementation
         if (baseIndex == null) {
-            return "no plan";
+            return "aggregate no-index";
         }
         return "aggregate " + baseIndex.getPlan(filter, rootState);
     }
 
     @Override
     public String getIndexName() {
-        // TODO dummy implementation
         if (baseIndex == null) {
-            return "aggregat";
+            return "aggregate no-index";
+        }
+        return "aggregate " + baseIndex.getIndexName();
+    }
+
+    @Override
+    public NodeAggregator getNodeAggregator() {
+        return baseIndex.getNodeAggregator();
+    }
+
+    // ----- aggregation aware cursor
+
+    private static class AggregationCursor extends AbstractCursor {
+
+        private final Cursor cursor;
+        private final NodeAggregator aggregator;
+        private final NodeState rootState;
+
+        private boolean init;
+        private boolean closed;
+        private Iterator<String> aggregates = null;
+
+        private String item = null;
+
+        public AggregationCursor(Cursor cursor, NodeAggregator aggregator,
+                NodeState rootState) {
+            this.cursor = cursor;
+            this.aggregator = aggregator;
+            this.rootState = rootState;
+        }
+
+        @Override
+        public boolean hasNext() {
+            if (!closed && !init) {
+                fetchNext();
+                init = true;
+            }
+            return !closed;
+        }
+
+        private void fetchNext() {
+            if (aggregates != null && aggregates.hasNext()) {
+                item = aggregates.next();
+                init = true;
+                return;
+            }
+            aggregates = null;
+            if (cursor.hasNext()) {
+                IndexRow row = cursor.next();
+                String path = row.getPath();
+                aggregates = Iterators.concat(ImmutableSet.of(path).iterator(),
+                        aggregator.getParents(rootState, path));
+                fetchNext();
+                return;
+            }
+            closed = true;
+        }
+
+        @Override
+        public IndexRow next() {
+            if (hasNext() == false) {
+                throw new NoSuchElementException();
+            }
+            init = false;
+            return new IndexRowImpl(item);
         }
-        return "aggregate." + baseIndex.getIndexName();
     }
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/NodeAggregator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/NodeAggregator.java
new file mode 100644
index 0000000000..63a3cddbaf
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/NodeAggregator.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.index.aggregate;
+
+import java.util.Iterator;
+
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+
+public interface NodeAggregator {
+
+    Iterator<String> getParents(NodeState rootState, String path);
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/SimpleNodeAggregator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/SimpleNodeAggregator.java
new file mode 100644
index 0000000000..78760c44af
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/aggregate/SimpleNodeAggregator.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.index.aggregate;
+
+import static com.google.common.collect.Lists.newArrayList;
+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
+import static org.apache.jackrabbit.oak.api.Type.STRING;
+import static org.apache.jackrabbit.oak.commons.PathUtils.elements;
+import static org.apache.jackrabbit.oak.commons.PathUtils.getDepth;
+import static org.apache.jackrabbit.oak.commons.PathUtils.getName;
+import static org.apache.jackrabbit.oak.commons.PathUtils.getParentPath;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+
+import com.google.common.collect.Iterators;
+
+/**
+ * List based NodeAggregator
+ * 
+ */
+public class SimpleNodeAggregator implements NodeAggregator {
+
+    public static final String INCLUDE_ALL = "*";
+
+    private final List<ChildNameRule> aggregates = new ArrayList<ChildNameRule>();
+
+    @Override
+    public Iterator<String> getParents(NodeState root, String path) {
+        return getParents(root, path, true);
+    }
+
+    private Iterator<String> getParents(NodeState root, String path,
+            boolean acceptStarIncludes) {
+
+        int levelsUp = 0;
+        Set<String> primaryType = new HashSet<String>();
+        for (ChildNameRule r : aggregates) {
+            String name = getName(path);
+            for (String inc : r.includes) {
+                // check node name match
+                if (name.equals(getName(inc))) {
+                    levelsUp = 1;
+                    primaryType.add(r.primaryType);
+                    if (acceptStarIncludes) {
+                        break;
+                    }
+                }
+                if (acceptStarIncludes) {
+                    // check '*' rule, which could span over more than one level
+                    if (INCLUDE_ALL.equals(getName(inc))) {
+                        // basic approach to dealing with a '*' include
+                        levelsUp = Math.max(getDepth(inc), levelsUp);
+                        primaryType.add(r.primaryType);
+                    }
+                }
+            }
+        }
+        if (levelsUp > 0 && !primaryType.isEmpty()) {
+            List<String> parents = new ArrayList<String>();
+            levelsUp = Math.min(levelsUp, getDepth(path));
+            String parentPath = path;
+            for (int i = 0; i < levelsUp; i++) {
+                parentPath = getParentPath(parentPath);
+                if (isNodeType(root, parentPath, primaryType)) {
+                    parents.add(parentPath);
+                    parents.addAll(newArrayList(getParents(root, parentPath,
+                            false)));
+                    return parents.iterator();
+                }
+            }
+        }
+
+        return Iterators.emptyIterator();
+    }
+
+    private static boolean isNodeType(NodeState root, String path, Set<String> types) {
+        NodeState state = root;
+        for (String p : elements(path)) {
+            if (state.hasChildNode(p)) {
+                state = state.getChildNode(p);
+            } else {
+                return false;
+            }
+        }
+        PropertyState ps = state.getProperty(JCR_PRIMARYTYPE);
+        if (ps == null) {
+            return false;
+        }
+        return types.contains(ps.getValue(STRING));
+    }
+
+    // ----- builder methods
+
+    /**
+     * Include children with the provided name. '*' means include all children
+     * 
+     * Note: there is no support for property names yet
+     * 
+     */
+    public SimpleNodeAggregator newRuleWithName(String primaryType,
+            List<String> includes) {
+        aggregates.add(new ChildNameRule(primaryType, includes));
+        return this;
+    }
+
+    // ----- aggregation rules
+
+    private static interface Rule {
+
+    }
+
+    private static class ChildNameRule implements Rule {
+
+        private final String primaryType;
+        private final List<String> includes;
+
+        ChildNameRule(String primaryType, List<String> includes) {
+            this.primaryType = primaryType;
+            this.includes = includes;
+        }
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java
index 6455a79239..56417f6386 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java
@@ -331,6 +331,9 @@ public class SelectorImpl extends SourceImpl {
             // We store the search token (the full-text condition text) 
             // in this column (which is also weird), as this is needed for highlighting
             String searchToken = SimpleExcerptProvider.extractFulltext(query.getConstraint());
+            if (searchToken == null) {
+                return PropertyValues.newString(path);
+            }
             return PropertyValues.newString(searchToken);
         }
         return PropertyValues.create(t.getProperty(propertyName));
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java
index c66661f368..ebd4f977ee 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java
@@ -55,6 +55,12 @@ public class FilterImpl implements Filter {
      */
     private boolean alwaysFalse;
 
+    /**
+     * inherited from the selector, duplicated here so it can be over-written by
+     * other filters
+     */
+    private boolean matchesAllTypes;
+
     /**
      *  The path, or "/" (the root node, meaning no filter) if not set.
      */
@@ -98,8 +104,26 @@ public class FilterImpl implements Filter {
         this.selector = selector;
         this.queryStatement = queryStatement;
         this.rootTree = rootTree;
+        this.matchesAllTypes = selector != null ? selector.matchesAllTypes()
+                : false;
+    }
+
+    public FilterImpl(Filter filter) {
+        FilterImpl impl = (FilterImpl) filter;
+        this.alwaysFalse = impl.alwaysFalse;
+        this.distinct = impl.distinct;
+        this.fullTextConstraint = impl.fullTextConstraint;
+        this.matchesAllTypes = impl.matchesAllTypes;
+        this.path = impl.path;
+        this.pathRestriction = impl.pathRestriction;
+        this.propertyRestrictions.putAll(impl.propertyRestrictions);
+        this.queryStatement = impl.queryStatement;
+        this.rootTree = impl.rootTree;
+        this.selector = impl.selector;
+        this.matchesAllTypes = selector != null ? selector.matchesAllTypes()
+                : false;
     }
-    
+
     public void setPreparing(boolean preparing) {
         this.preparing = preparing;
     }
@@ -158,7 +182,7 @@ public class FilterImpl implements Filter {
 
     @Override
     public boolean matchesAllTypes() {
-        return selector.matchesAllTypes();
+        return matchesAllTypes;
     }
 
     @Override @Nonnull
@@ -481,4 +505,8 @@ public class FilterImpl implements Filter {
         return queryStatement;
     }
 
+    public void setMatchesAllTypes(boolean matchesAllTypes) {
+        this.matchesAllTypes = matchesAllTypes;
+    }
+
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java
index e60d917639..e8db18cc67 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java
@@ -18,6 +18,9 @@
  */
 package org.apache.jackrabbit.oak.spi.query;
 
+import javax.annotation.CheckForNull;
+
+import org.apache.jackrabbit.oak.plugins.index.aggregate.NodeAggregator;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
 /**
@@ -111,6 +114,14 @@ public interface QueryIndex {
      */
     public interface FulltextQueryIndex extends QueryIndex {
         // marker interface
+
+        /**
+         * Returns the NodeAggregator responsible for providing the aggregation
+         * settings or null if aggregation is not available/desired
+         * 
+         */
+        @CheckForNull
+        NodeAggregator getNodeAggregator();
     }
 
 //    /**
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/aggregate/SimpleNodeAggregatorTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/aggregate/SimpleNodeAggregatorTest.java
new file mode 100644
index 0000000000..650f6ca14a
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/aggregate/SimpleNodeAggregatorTest.java
@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.index.aggregate;
+
+import static com.google.common.collect.Lists.newArrayList;
+import static org.apache.jackrabbit.JcrConstants.JCR_CONTENT;
+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
+import static org.apache.jackrabbit.JcrConstants.NT_FILE;
+import static org.apache.jackrabbit.JcrConstants.NT_FOLDER;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.apache.jackrabbit.oak.plugins.index.aggregate.SimpleNodeAggregator.INCLUDE_ALL;
+
+import java.util.List;
+
+import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.junit.Test;
+
+public class SimpleNodeAggregatorTest {
+
+    @Test
+    public void testNodeName() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder file = builder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE);
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FILE, newArrayList(JCR_CONTENT));
+
+        String path = "/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertEquals(newArrayList("/file"), actual);
+
+    }
+
+    @Test
+    public void testNodeNameWrongParentType() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder file = builder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE + "_");
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FILE, newArrayList(JCR_CONTENT));
+
+        String path = "/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertTrue(actual.isEmpty());
+
+    }
+
+    @Test
+    public void testStarName() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder file = builder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE);
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FILE, newArrayList(INCLUDE_ALL));
+
+        String path = "/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertEquals(newArrayList("/file"), actual);
+
+    }
+
+    @Test
+    public void testStarNameMoreLevels() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder file = builder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE);
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FILE, newArrayList("*", "*/*", "*/*/*", "*/*/*/*"));
+
+        String path = "/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertEquals(newArrayList("/file"), actual);
+
+    }
+
+    @Test
+    public void testStarNameWrongParentType() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder file = builder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE + "_");
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FILE, newArrayList(INCLUDE_ALL));
+
+        String path = "/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertTrue(actual.isEmpty());
+
+    }
+
+    @Test
+    public void testCascadingStarName() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder folder = builder.child("folder");
+        folder.setProperty(JCR_PRIMARYTYPE, NT_FOLDER);
+
+        NodeBuilder file = folder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE);
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FOLDER, newArrayList("file")).newRuleWithName(NT_FILE,
+                newArrayList(INCLUDE_ALL));
+
+        String path = "/folder/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertEquals(newArrayList("/folder/file", "/folder"), actual);
+
+    }
+
+    @Test
+    public void testCascadingNodeName() {
+
+        NodeState root = new MemoryNodeStore().getRoot();
+        NodeBuilder builder = root.builder();
+
+        NodeBuilder folder = builder.child("folder");
+        folder.setProperty(JCR_PRIMARYTYPE, NT_FOLDER);
+
+        NodeBuilder file = folder.child("file");
+        file.setProperty(JCR_PRIMARYTYPE, NT_FILE);
+        file.child(JCR_CONTENT);
+
+        SimpleNodeAggregator agg = new SimpleNodeAggregator().newRuleWithName(
+                NT_FOLDER, newArrayList("file")).newRuleWithName(NT_FILE,
+                newArrayList(JCR_CONTENT));
+
+        String path = "/folder/file/jcr:content";
+        List<String> actual = newArrayList(agg.getParents(
+                builder.getNodeState(), path));
+
+        assertEquals(newArrayList("/folder/file", "/folder"), actual);
+
+    }
+
+}
