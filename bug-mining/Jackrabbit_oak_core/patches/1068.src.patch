diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java
index 899995a0ae..cc57477a22 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java
@@ -289,7 +289,8 @@ public class LastRevRecoveryAgent {
         // if found then lastRev needs to be fixed
         for (Revision rev : revs) {
             if (rev.compareRevisionTime(currentLastRev) > 0) {
-                if (doc.isCommitted(rev)) {
+                rev = doc.getCommitRevision(rev);
+                if (rev != null) {
                     return rev;
                 }
             } else {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
index 388cca2ec3..912237b92a 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
@@ -544,6 +544,26 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
         return false;
     }
 
+    /**
+     * Returns the commit revision for the change with the given revision.
+     *
+     * @param revision the revision of a change.
+     * @return the commit revision of the change or {@code null} if the change
+     *          is not committed or unknown.
+     */
+    @CheckForNull
+    public Revision getCommitRevision(@Nonnull Revision revision) {
+        NodeDocument commitRoot = getCommitRoot(checkNotNull(revision));
+        if (commitRoot == null) {
+            return null;
+        }
+        String value = commitRoot.getCommitValue(revision);
+        if (Utils.isCommitted(value)) {
+            return Utils.resolveCommitRevision(revision, value);
+        }
+        return null;
+    }
+
     /**
      * Returns <code>true</code> if this document contains an entry for the
      * given <code>revision</code> in the {@link #REVISIONS} map. Please note
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
index 94c876026f..fc17d94d5d 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
@@ -677,6 +677,52 @@ public class DocumentNodeStoreTest {
         store.dispose();
     }
 
+    // OAK-2308
+    @Test
+    public void recoverBranchCommit() throws Exception {
+        Clock clock = new Clock.Virtual();
+        clock.waitUntil(System.currentTimeMillis());
+
+        MemoryDocumentStore docStore = new MemoryDocumentStore();
+
+        DocumentNodeStore store1 = new DocumentMK.Builder()
+                .setDocumentStore(docStore)
+                .setAsyncDelay(0).clock(clock).getNodeStore();
+
+        NodeBuilder builder = store1.getRoot().builder();
+        builder.child("test");
+        merge(store1, builder);
+        // make sure all _lastRevs are written back
+        store1.runBackgroundOperations();
+
+        builder = store1.getRoot().builder();
+        NodeBuilder node = builder.getChildNode("test").child("node");
+        String id = Utils.getIdFromPath("/test/node");
+        int i = 0;
+        // force creation of a branch
+        while (docStore.find(NODES, id) == null) {
+            node.setProperty("foo", i++);
+        }
+        merge(store1, builder);
+
+        // wait until lease expires
+        clock.waitUntil(clock.getTime() + store1.getClusterInfo().getLeaseTime() + 1000);
+        // run recovery for this store
+        LastRevRecoveryAgent agent = store1.getLastRevRecoveryAgent();
+        assertTrue(agent.isRecoveryNeeded());
+        agent.recover(store1.getClusterId());
+
+        // start a second store
+        DocumentNodeStore store2 = new DocumentMK.Builder()
+                .setDocumentStore(docStore)
+                .setAsyncDelay(0).clock(clock).getNodeStore();
+        // must see /test/node
+        assertTrue(store2.getRoot().getChildNode("test").getChildNode("node").exists());
+
+        store2.dispose();
+        store1.dispose();
+    }
+
     private static void merge(NodeStore store, NodeBuilder root)
             throws CommitFailedException {
         store.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);
