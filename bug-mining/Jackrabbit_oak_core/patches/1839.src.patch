diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
index 44dbc4f700..e616f0183e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
@@ -321,16 +321,16 @@ public class UnionQueryImpl implements Query {
             leftIter = ((MeasuringIterator) leftRows).getDelegate();
             rightIter = ((MeasuringIterator) rightRows).getDelegate();
         }
-        // Since sorted by index use a merge iterator
-        if (isSortedByIndex()) {
-            it = FilterIterators
-                .newCombinedFilter(Iterators.mergeSorted(ImmutableList.of(leftIter, rightIter), orderBy), distinct,
-                    limit, offset, null, settings);
+        if (orderBy == null) {
+            it = Iterators.concat(leftIter, rightIter);
         } else {
-            it = FilterIterators
-            .newCombinedFilter(Iterators.concat(leftIter, rightIter), distinct, limit, offset, orderBy, settings);
+            // This would suggest either the sub queries are sorted by index or explicitly by QueryImpl (in case of traversing index)
+            // So use mergeSorted here.
+            it = Iterators.mergeSorted(ImmutableList.of(leftIter, rightIter), orderBy);
         }
 
+        it = FilterIterators.newCombinedFilter(it, distinct, limit, offset, null, settings);
+
         if (measure) {
             // return the measuring iterator for the union
             it = new MeasuringIterator(this, it) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/UnionQueryTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/UnionQueryTest.java
index e654535bff..760be14d92 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/UnionQueryTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/UnionQueryTest.java
@@ -17,8 +17,12 @@
 
 package org.apache.jackrabbit.oak.query;
 
+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
+import static org.apache.jackrabbit.oak.api.Type.NAME;
+import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;
+import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NODE_TYPE;
+import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.TYPE_PROPERTY_NAME;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
@@ -34,18 +38,41 @@ import org.apache.jackrabbit.oak.api.Result;
 import org.apache.jackrabbit.oak.api.ResultRow;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
+import org.apache.jackrabbit.oak.namepath.NamePathMapper;
+import org.apache.jackrabbit.oak.namepath.impl.GlobalNameMapper;
+import org.apache.jackrabbit.oak.namepath.impl.NamePathMapperImpl;
+import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;
+import org.apache.jackrabbit.oak.query.ast.ColumnImpl;
+import org.apache.jackrabbit.oak.query.ast.ConstraintImpl;
+import org.apache.jackrabbit.oak.query.ast.DescendantNodeImpl;
+import org.apache.jackrabbit.oak.query.ast.NodeTypeInfo;
+import org.apache.jackrabbit.oak.query.ast.NodeTypeInfoProvider;
+import org.apache.jackrabbit.oak.query.ast.Order;
+import org.apache.jackrabbit.oak.query.ast.OrderingImpl;
+import org.apache.jackrabbit.oak.query.ast.PropertyValueImpl;
+import org.apache.jackrabbit.oak.query.ast.SelectorImpl;
+import org.apache.jackrabbit.oak.query.ast.SourceImpl;
+import org.apache.jackrabbit.oak.query.stats.QueryStatsData;
 import org.apache.jackrabbit.oak.spi.security.OpenSecurityProvider;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.Mockito;
 
 public class UnionQueryTest extends AbstractQueryTest {
 
+    MemoryNodeStore store;
+    QueryEngineSettings qeSettings;
+
     @Override
     protected ContentRepository createRepository() {
-        return new Oak()
+        store = new MemoryNodeStore();
+        qeSettings = new QueryEngineSettings();
+
+        return new Oak(store)
                 .with(new OpenSecurityProvider())
                 .with(new InitialContent())
+                .with(qeSettings)
                 .createContentRepository();
     }
 
@@ -64,6 +91,9 @@ public class UnionQueryTest extends AbstractQueryTest {
         t = t.addChild("d");
         t = t.addChild("e");
 
+        Tree t2 = root.getTree("/").addChild("UnionQueryTest2");
+        Tree t3 = t2.addChild("a");
+
         root.commit();
     }
 
@@ -74,6 +104,109 @@ public class UnionQueryTest extends AbstractQueryTest {
         root.commit();
     }
 
+    @Test
+    public void testMergeSortedVsConcat() throws  Exception {
+        String left = "SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest2')";
+        String right = "SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest/a')";
+        String order = "ORDER BY [jcr:path]";
+        String union = String.format("%s UNION %s %s", left, right, order);
+        final int limit = 10;
+        final int offset = 0;
+        // Execute query with ORDER BY clause - This should use mergeSorted and the final result should be sorted across both the subqueries.
+        String[] expected = {
+                "/UnionQueryTest/a/b",
+                "/UnionQueryTest/a/b/c",
+                "/UnionQueryTest/a/b/c/d",
+                "/UnionQueryTest/a/b/c/d/e",
+                "/UnionQueryTest2/a"
+        };
+
+        Result result = qe.executeQuery(union, QueryEngineImpl.SQL2, limit, offset,
+                QueryEngine.NO_BINDINGS, QueryEngine.NO_MAPPINGS);
+        int i = 0;
+        for (ResultRow rr: result.getRows()) {
+            assertEquals(rr.getPath(), expected[i++]);
+
+        }
+
+        // Now we execute the same union query without the order by clause. Expectation is the subqueries results should simply be concatenated without
+        // sorting of the overall result
+        String[] expected2 = {
+                "/UnionQueryTest2/a",
+                "/UnionQueryTest/a/b",
+                "/UnionQueryTest/a/b/c",
+                "/UnionQueryTest/a/b/c/d",
+                "/UnionQueryTest/a/b/c/d/e"
+        };
+
+        union = String.format("%s UNION %s", left, right);
+
+        result = qe.executeQuery(union, QueryEngineImpl.SQL2, limit, offset,
+                QueryEngine.NO_BINDINGS, QueryEngine.NO_MAPPINGS);
+         i = 0;
+        for (ResultRow rr: result.getRows()) {
+            assertEquals(rr.getPath(), expected2[i++]);
+        }
+
+    }
+    // TODO - Write a similar test that might fail with guava's merge sort on some conditions
+    @Test
+    public void testSortWithOneSubquerySortedByIndexAndOtherNot() throws Exception {
+
+        String left  = "SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest2')";
+        String right  = "SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest/a')";
+
+        NodeTypeInfoProvider nodeTypes = new NodeStateNodeTypeInfoProvider(store.getRoot());
+        NodeTypeInfo type = nodeTypes.getNodeTypeInfo("nt:base");
+        SourceImpl sImpl = new SelectorImpl(type, "a");
+        SourceImpl sImpl2 = new SelectorImpl(type, "a");
+        SourceImpl sImpl3 = new SelectorImpl(type, "a");
+
+        QueryImpl qImplLeft = createQuery(left, new DescendantNodeImpl("a","/UnionQueryTest2"), sImpl);
+        qImplLeft.setExecutionContext(((QueryEngineImpl)root.getQueryEngine()).getExecutionContext());
+        QueryImpl qImplRight = createQuery(right, new DescendantNodeImpl("a","/UnionQueryTest/a"), sImpl2);
+        qImplRight.setExecutionContext(((QueryEngineImpl)root.getQueryEngine()).getExecutionContext());
+
+        PropertyValueImpl propValImpl = new PropertyValueImpl("a", "jcr:path");
+        propValImpl.bindSelector(sImpl);
+
+        PropertyValueImpl propValImpl2 = new PropertyValueImpl("a", "jcr:path");
+        propValImpl2.bindSelector(sImpl2);
+
+        PropertyValueImpl propValImpl3 = new PropertyValueImpl("a", "jcr:path");
+        propValImpl2.bindSelector(sImpl3);
+
+        /// One subquery sorted by index and the other not and orderBY != null in UnionQueryImpl
+        QueryImpl spyLeft = Mockito.spy(qImplLeft);
+        QueryImpl spyRight = Mockito.spy(qImplRight);
+        Mockito.doReturn(true).when(spyLeft).isSortedByIndex();
+        Mockito.doReturn(false).when(spyRight).isSortedByIndex();
+
+        spyLeft.setOrderings(new OrderingImpl[] {new OrderingImpl(propValImpl, Order.DESCENDING)});
+        spyRight.setOrderings(new OrderingImpl[] {new OrderingImpl(propValImpl2, Order.DESCENDING)});
+        UnionQueryImpl unionImpl = new UnionQueryImpl(true, spyLeft, spyRight, new QueryEngineSettings());
+        unionImpl.setOrderings(new OrderingImpl[] {new OrderingImpl(propValImpl3, Order.ASCENDING)});
+
+        unionImpl.init();
+
+        // Execute query with ORDER BY clause - This should use mergeSorted and the final result should be sorted across both the subqueries.
+        String[] expected = {
+                "/UnionQueryTest/a/b",
+                "/UnionQueryTest/a/b/c",
+                "/UnionQueryTest/a/b/c/d",
+                "/UnionQueryTest/a/b/c/d/e",
+                "/UnionQueryTest2/a"
+        };
+
+        Result result = unionImpl.executeQuery();
+
+        int i = 0;
+        for (ResultRow rr: result.getRows()) {
+            assertEquals(expected[i++], rr.getPath());
+        }
+
+    }
+
     @Test
     public void testOrderLimitOffset() throws Exception {
         String left = "SELECT [jcr:path] FROM [nt:base] AS a WHERE ISDESCENDANTNODE(a, '/UnionQueryTest')";
@@ -207,4 +340,12 @@ public class UnionQueryTest extends AbstractQueryTest {
             assertEquals(rr.getPath(), expected[i++]);
         }
     }
+
+    private QueryImpl createQuery (String statement, ConstraintImpl c, SourceImpl sImpl) throws Exception {
+
+        NamePathMapper namePathMapper = new NamePathMapperImpl(new GlobalNameMapper(root));
+        return new QueryImpl(statement, sImpl, c,
+                new ColumnImpl[]{new ColumnImpl("a", "jcr:path", "jcr:path")}, namePathMapper, qeSettings, new QueryStatsData("", "").new QueryExecutionStats());
+
+    }
 }
