diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java
index bf31922021..c4ea380410 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/commit/ChildOrderConflictHandler.java
@@ -45,7 +45,8 @@ public class ChildOrderConflictHandler extends ConflictHandlerWrapper {
         if (isChildOrderProperty(ours)) {
             // two sessions concurrently called orderBefore() on a Tree
             // that was previously unordered.
-            return Resolution.THEIRS;
+            merge(parent, ours, theirs);
+            return Resolution.MERGED;
         } else {
             return handler.addExistingProperty(parent, ours, theirs);
         }
@@ -75,11 +76,11 @@ public class ChildOrderConflictHandler extends ConflictHandlerWrapper {
     }
 
     private static void merge(NodeBuilder parent, PropertyState ours, PropertyState theirs) {
-        Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.STRINGS));
-        PropertyBuilder<String> merged = PropertyBuilder.array(Type.STRING).assignFrom(theirs);
+        Set<String> theirOrder = Sets.newHashSet(theirs.getValue(Type.NAMES));
+        PropertyBuilder<String> merged = PropertyBuilder.array(Type.NAME).assignFrom(theirs);
 
         // Append child node names from ours that are not in theirs
-        for (String ourChild : ours.getValue(Type.STRINGS)) {
+        for (String ourChild : ours.getValue(Type.NAMES)) {
             if (!theirOrder.contains(ourChild)) {
                 merged.addValue(ourChild);
             }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/api/TreeTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/api/TreeTest.java
index 9e6ee279d9..7a7b47fe60 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/api/TreeTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/api/TreeTest.java
@@ -23,8 +23,10 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+import java.util.List;
 import java.util.Set;
 
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import org.apache.jackrabbit.oak.NodeStoreFixture;
 import org.apache.jackrabbit.oak.Oak;
@@ -411,6 +413,49 @@ public class TreeTest extends OakBaseTest {
 
     }
 
+    @Test
+    public void concurrentAddChildMakeOrderable() throws Exception {
+        ContentSession s1 = repository.login(null, null);
+        try {
+            Root r1 = s1.getLatestRoot();
+            Tree t1 = r1.getTree("/");
+            t1.addChild("node1");
+            t1.addChild("node2");
+            r1.commit();
+            ContentSession s2 = repository.login(null, null);
+            try {
+                Root r2 = s2.getLatestRoot();
+                Tree t2 = r2.getTree("/");
+
+                t1 = r1.getTree("/");
+                // node3 from s1
+                t1.addChild("node3").orderBefore(null);
+                r1.commit();
+
+                // get current sequence of child names
+                List<String> names = Lists.newArrayList();
+                for (Tree t : r1.getTree("/").getChildren()) {
+                    names.add(t.getName());
+                }
+
+                // node4 from s2
+                t2.addChild("node4").orderBefore(null);
+                r2.commit();
+
+                names.add("node4");
+
+                t1 = s1.getLatestRoot().getTree("/");
+                assertSequence(
+                        t1.getChildren(), names.toArray(new String[names.size()]));
+            } finally {
+                s2.close();
+            }
+        } finally {
+            s1.close();
+        }
+
+    }
+
     @Test
     public void concurrentAddChild() throws Exception {
         ContentSession s1 = repository.login(null, null);
