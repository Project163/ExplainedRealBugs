diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
index 9138108130..5668d3cdde 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
@@ -16,7 +16,6 @@
  */
 package org.apache.jackrabbit.oak.plugins.identifier;
 
-import java.io.UnsupportedEncodingException;
 import java.text.ParseException;
 import java.util.Collections;
 import java.util.Map;
@@ -28,6 +27,7 @@ import javax.annotation.Nonnull;
 import javax.jcr.PropertyType;
 import javax.jcr.query.Query;
 
+import com.google.common.base.Charsets;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
@@ -70,12 +70,8 @@ public class IdentifierManager {
 
     @Nonnull
     public static String generateUUID(String hint) {
-        try {
-            UUID uuid = UUID.nameUUIDFromBytes(hint.getBytes("UTF-8"));
-            return uuid.toString();
-        } catch (UnsupportedEncodingException e) {
-            throw new RuntimeException("Unexpected error while creating uuid", e);
-        }
+        UUID uuid = UUID.nameUUIDFromBytes(hint.getBytes(Charsets.UTF_8));
+        return uuid.toString();
     }
 
     public static boolean isValidUUID(String uuid) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ArrayBasedBlob.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ArrayBasedBlob.java
index b6014e4ee2..e3abe0bdb0 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ArrayBasedBlob.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ArrayBasedBlob.java
@@ -20,10 +20,11 @@ package org.apache.jackrabbit.oak.plugins.memory;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 
 import javax.annotation.Nonnull;
 
+import com.google.common.base.Charsets;
+
 /**
  * This {@code Blob} implementations is based on an array of bytes.
  */
@@ -36,11 +37,7 @@ public class ArrayBasedBlob extends AbstractBlob {
 
     @Override
     public String toString() {
-        try {
-            return new String(value, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            return "<blob>";
-        }
+        return new String(value, Charsets.UTF_8);
     }
 
     @Nonnull
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java
index 32047bde68..617704544d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java
@@ -316,6 +316,16 @@ public final class PropertyStates {
         return new BinaryPropertyState(name, new ArrayBasedBlob(value));
     }
 
+    /**
+     * Create a {@code PropertyState} from an array of bytes.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#BINARY}
+     */
+    public static PropertyState binaryProperty(String name, String value) {
+        return new BinaryPropertyState(name, new StringBasedBlob(value));
+    }
+
     /**
      * Create a {@code PropertyState} from a {@link Blob}.
      * @param name  The name of the property state
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringBasedBlob.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringBasedBlob.java
index fecd93b84f..3d49bd62a2 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringBasedBlob.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringBasedBlob.java
@@ -20,10 +20,11 @@ package org.apache.jackrabbit.oak.plugins.memory;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 
 import javax.annotation.Nonnull;
 
+import com.google.common.base.Charsets;
+
 /**
  * This {@code Blob} implementations is based on a string.
  */
@@ -46,12 +47,7 @@ public class StringBasedBlob extends AbstractBlob {
     @Nonnull
     @Override
     public InputStream getNewStream() {
-        try {
-            return new ByteArrayInputStream(value.getBytes("UTF-8"));
-        }
-        catch (UnsupportedEncodingException e) {
-            throw new IllegalStateException("UTF-8 is not supported", e);
-        }
+        return new ByteArrayInputStream(value.getBytes(Charsets.UTF_8));
     }
 
     /**
@@ -60,11 +56,6 @@ public class StringBasedBlob extends AbstractBlob {
      */
     @Override
     public long length() {
-        try {
-            return value.getBytes("UTF-8").length;
-        }
-        catch (UnsupportedEncodingException e) {
-            throw new IllegalStateException("UTF-8 is not supported", e);
-        }
+        return value.getBytes(Charsets.UTF_8).length;
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/BinaryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/BinaryImpl.java
index 4fb2ccc0ff..8d8e8ead7c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/BinaryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/BinaryImpl.java
@@ -16,10 +16,8 @@
  */
 package org.apache.jackrabbit.oak.plugins.value;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 
 import javax.jcr.Binary;
 import javax.jcr.PropertyType;
@@ -41,21 +39,10 @@ class BinaryImpl implements Binary {
     }
 
     //-------------------------------------------------------------< Binary >---
+
     @Override
     public InputStream getStream() throws RepositoryException {
-        switch (value.getType()) {
-            case PropertyType.NAME:
-            case PropertyType.PATH:
-                // need to respect namespace remapping
-                try {
-                    final String strValue = value.getString();
-                    return new ByteArrayInputStream(strValue.getBytes("utf-8"));
-                } catch (UnsupportedEncodingException e) {
-                    throw new RepositoryException(e.getMessage());
-                }
-            default:
-                return value.getNewStream();
-        }
+        return value.getNewStream();
     }
 
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/Conversions.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/Conversions.java
index ff5aec0764..1326201c18 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/Conversions.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/Conversions.java
@@ -24,6 +24,7 @@ import java.math.BigDecimal;
 import java.util.Calendar;
 import java.util.TimeZone;
 
+import com.google.common.base.Charsets;
 import com.google.common.io.ByteStreams;
 import org.apache.jackrabbit.oak.api.Blob;
 import org.apache.jackrabbit.oak.plugins.memory.StringBasedBlob;
@@ -152,7 +153,7 @@ public final class Conversions {
                 try {
                     InputStream in = value.getNewStream();
                     try {
-                        return new String(ByteStreams.toByteArray(in), "UTF-8");
+                        return new String(ByteStreams.toByteArray(in), Charsets.UTF_8);
                     }
                     finally {
                         in.close();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
index 5fb5981d52..11c45cb0da 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
@@ -18,7 +18,6 @@ package org.apache.jackrabbit.oak.plugins.value;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.math.BigDecimal;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -115,7 +114,7 @@ public class ValueFactoryImpl implements ValueFactory {
     @Override
     public Value createValue(InputStream value) {
         try {
-            return createValueImpl(value);
+            return createBinaryValue(value);
         } catch (IOException e) {
             return new ErrorValue(e, PropertyType.BINARY);
         }
@@ -124,14 +123,12 @@ public class ValueFactoryImpl implements ValueFactory {
     @Override
     public Value createValue(Binary value) {
         try {
-            ValueImpl binaryValue = null;
             if (value instanceof BinaryImpl) {
-                binaryValue = ((BinaryImpl) value).getBinaryValue();
+                // No need to create the value again if we have it already underlying the binary
+                return ((BinaryImpl) value).getBinaryValue();
+            } else {
+                return createBinaryValue(value.getStream());
             }
-            // No need to create the value again if we have it already underlying the binary
-            return binaryValue == null
-                ? createValueImpl(value.getStream())
-                : binaryValue;
         } catch (RepositoryException e) {
             return new ErrorValue(e, PropertyType.BINARY);
         } catch (IOException e) {
@@ -151,8 +148,7 @@ public class ValueFactoryImpl implements ValueFactory {
 
     @Override
     public Value createValue(Calendar value) {
-        String dateStr = ISO8601.format(value);
-        return new ValueImpl(PropertyStates.dateProperty("", dateStr), namePathMapper);
+        return new ValueImpl(PropertyStates.dateProperty("", value), namePathMapper);
     }
 
     @Override
@@ -180,7 +176,7 @@ public class ValueFactoryImpl implements ValueFactory {
     @Override
     public Value createValue(String value, int type) throws ValueFormatException {
         if (value == null) {
-            throw new ValueFormatException();
+            throw new ValueFormatException("null");
         }
 
         try {
@@ -189,7 +185,7 @@ public class ValueFactoryImpl implements ValueFactory {
                 case PropertyType.STRING:
                     return createValue(value);
                 case PropertyType.BINARY:
-                    pv = PropertyStates.binaryProperty("", value.getBytes("UTF-8"));
+                    pv = PropertyStates.binaryProperty("", value);
                     break;
                 case PropertyType.LONG:
                     return createValue(Conversions.convert(value).toLong());
@@ -245,10 +241,6 @@ public class ValueFactoryImpl implements ValueFactory {
             }
 
             return new ValueImpl(pv, namePathMapper);
-        } catch (UnsupportedEncodingException e) {
-            throw new ValueFormatException("Encoding UTF-8 not supported (this should not happen!)", e);
-        } catch (IOException e) {
-            throw new ValueFormatException(e);
         } catch (NumberFormatException e) {
             throw new ValueFormatException("Invalid value " + value + " for type " + PropertyType.nameFromValue(type), e);
         } catch (URISyntaxException e) {
@@ -259,14 +251,14 @@ public class ValueFactoryImpl implements ValueFactory {
     @Override
     public Binary createBinary(InputStream stream) throws RepositoryException {
         try {
-            return new BinaryImpl(createValueImpl(stream));
+            return new BinaryImpl(createBinaryValue(stream));
         }
         catch (IOException e) {
             throw new RepositoryException(e);
         }
     }
 
-    private ValueImpl createValueImpl(InputStream value) throws IOException {
+    private ValueImpl createBinaryValue(InputStream value) throws IOException {
         Blob blob = contentSession.createBlob(value);
         return new ValueImpl(PropertyStates.binaryProperty("", blob), namePathMapper);
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java
index 36de938fba..33a355a596 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueImpl.java
@@ -17,11 +17,9 @@
 package org.apache.jackrabbit.oak.plugins.value;
 
 import java.io.ByteArrayInputStream;
-import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigDecimal;
 import java.util.Calendar;
-import java.util.TimeZone;
 
 import javax.jcr.Binary;
 import javax.jcr.PropertyType;
@@ -30,16 +28,14 @@ import javax.jcr.Value;
 import javax.jcr.ValueFormatException;
 
 import com.google.common.base.Charsets;
-import com.google.common.io.CharStreams;
-import com.google.common.io.InputSupplier;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
-import org.apache.jackrabbit.util.ISO8601;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
 
 /**
  * Implementation of {@link Value} based on {@code PropertyState}.
@@ -99,10 +95,13 @@ public class ValueImpl implements Value {
      */
     @Override
     public boolean getBoolean() throws RepositoryException {
-        if (getType() == PropertyType.STRING || getType() == PropertyType.BINARY || getType() == PropertyType.BOOLEAN) {
-            return propertyState.getValue(Type.BOOLEAN, index);
-        } else {
-            throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
+        switch (getType()) {
+            case PropertyType.STRING:
+            case PropertyType.BINARY:
+            case PropertyType.BOOLEAN:
+                return propertyState.getValue(Type.BOOLEAN, index);
+            default:
+                throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
         }
     }
 
@@ -111,21 +110,24 @@ public class ValueImpl implements Value {
      */
     @Override
     public Calendar getDate() throws RepositoryException {
-        Calendar cal;
-        switch (getType()) {
-            case PropertyType.DOUBLE:
-            case PropertyType.LONG:
-            case PropertyType.DECIMAL:
-                cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+00:00"));
-                cal.setTimeInMillis(getLong());
-                break;
-            default:
-                cal = ISO8601.parse(getString());
-                if (cal == null) {
-                    throw new ValueFormatException("Not a date string: " + getString());
-                }
+        try {
+            switch (getType()) {
+                case PropertyType.STRING:
+                case PropertyType.BINARY:
+                    String value = propertyState.getValue(Type.DATE, index);
+                    return Conversions.convert(value).toCalendar();
+                case PropertyType.LONG:
+                case PropertyType.DOUBLE:
+                case PropertyType.DATE:
+                case PropertyType.DECIMAL:
+                    return Conversions.convert(propertyState.getValue(Type.LONG, index)).toCalendar();
+                default:
+                    throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
+            }
+        }
+        catch (IllegalArgumentException e) {
+            throw new ValueFormatException("Error converting value to date", e);
         }
-        return cal;
     }
 
     /**
@@ -135,14 +137,19 @@ public class ValueImpl implements Value {
     public BigDecimal getDecimal() throws RepositoryException {
         try {
             switch (getType()) {
+                case PropertyType.STRING:
+                case PropertyType.BINARY:
+                case PropertyType.LONG:
+                case PropertyType.DOUBLE:
                 case PropertyType.DATE:
-                    Calendar cal = getDate();
-                    return BigDecimal.valueOf(cal.getTimeInMillis());
-                default:
+                case PropertyType.DECIMAL:
                     return propertyState.getValue(Type.DECIMAL, index);
+                default:
+                    throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
             }
-        } catch (NumberFormatException e) {
-            throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
+        }
+        catch (IllegalArgumentException e) {
+            throw new ValueFormatException("Error converting value to decimal", e);
         }
     }
 
@@ -153,14 +160,19 @@ public class ValueImpl implements Value {
     public double getDouble() throws RepositoryException {
         try {
             switch (getType()) {
+                case PropertyType.STRING:
+                case PropertyType.BINARY:
+                case PropertyType.LONG:
+                case PropertyType.DOUBLE:
                 case PropertyType.DATE:
-                    Calendar cal = getDate();
-                    return cal.getTimeInMillis();
-                default:
+                case PropertyType.DECIMAL:
                     return propertyState.getValue(Type.DOUBLE, index);
+                default:
+                    throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
             }
-        } catch (NumberFormatException e) {
-            throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
+        }
+        catch (IllegalArgumentException e) {
+            throw new ValueFormatException("Error converting value to double", e);
         }
     }
 
@@ -171,14 +183,19 @@ public class ValueImpl implements Value {
     public long getLong() throws RepositoryException {
         try {
             switch (getType()) {
+                case PropertyType.STRING:
+                case PropertyType.BINARY:
+                case PropertyType.LONG:
+                case PropertyType.DOUBLE:
                 case PropertyType.DATE:
-                    Calendar cal = getDate();
-                    return cal.getTimeInMillis();
-                default:
+                case PropertyType.DECIMAL:
                     return propertyState.getValue(Type.LONG, index);
+                default:
+                    throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
             }
-        } catch (NumberFormatException e) {
-            throw new ValueFormatException("Incompatible type " + PropertyType.nameFromValue(getType()));
+        }
+        catch (IllegalArgumentException e) {
+            throw new ValueFormatException("Error converting value to double", e);
         }
     }
 
@@ -187,6 +204,10 @@ public class ValueImpl implements Value {
      */
     @Override
     public String getString() throws RepositoryException {
+        checkState(getType() != PropertyType.BINARY || stream == null,
+                "getStream has previously been called on this Value instance. " +
+                "In this case a new Value instance must be acquired in order to successfully call this method.");
+
         switch (getType()) {
             case PropertyType.NAME:
                 return namePathMapper.getJcrName(propertyState.getValue(Type.STRING, index));
@@ -198,27 +219,6 @@ public class ValueImpl implements Value {
                 } else {
                     return namePathMapper.getJcrPath(s);
                 }
-            case PropertyType.BINARY:
-                if (stream != null) {
-                    throw new IllegalStateException("getStream has previously been called on this Value instance. " +
-                            "In this case a new Value instance must be acquired in order to successfully call this method.");
-                }
-                try {
-                    final InputStream is = propertyState.getValue(Type.BINARY, index).getNewStream();
-                    try {
-                        return CharStreams.toString(CharStreams.newReaderSupplier(
-                                new InputSupplier<InputStream>() {
-                                    @Override
-                                    public InputStream getInput() {
-                                        return is;
-                                    }
-                                }, Charsets.UTF_8));
-                    } finally {
-                        is.close();
-                    }
-                } catch (IOException e) {
-                    throw new RepositoryException("conversion from stream to string failed", e);
-                }
             default:
                 return propertyState.getValue(Type.STRING, index);
         }
@@ -239,10 +239,10 @@ public class ValueImpl implements Value {
         switch (getType()) {
             case PropertyType.NAME:
             case PropertyType.PATH:
-                return new ByteArrayInputStream(
-                        getString().getBytes(Charsets.UTF_8));
+                return new ByteArrayInputStream(getString().getBytes(Charsets.UTF_8));
+            default:
+                return propertyState.getValue(Type.BINARY, index).getNewStream();
         }
-        return propertyState.getValue(Type.BINARY, index).getNewStream();
     }
 
     long getStreamLength() {
@@ -299,6 +299,10 @@ public class ValueImpl implements Value {
                 return compare(p1.getValue(Type.BINARY, i1), p2.getValue(Type.BINARY, i2));
             case PropertyType.DOUBLE:
                 return compare(p1.getValue(Type.DOUBLE, i1), p2.getValue(Type.DOUBLE, i2));
+            case PropertyType.LONG:
+                return compare(p1.getValue(Type.LONG, i1), p2.getValue(Type.LONG, i2));
+            case PropertyType.DECIMAL:
+                return compare(p1.getValue(Type.DECIMAL, i1), p2.getValue(Type.DECIMAL, i2));
             case PropertyType.DATE:
                 return compareAsDate(p1.getValue(Type.STRING, i1), p2.getValue(Type.STRING, i2));
             default:
@@ -311,8 +315,8 @@ public class ValueImpl implements Value {
     }
 
     private static int compareAsDate(String p1, String p2) {
-        Calendar c1 = ISO8601.parse(p1);
-        Calendar c2 = ISO8601.parse(p2);
+        Calendar c1 = Conversions.convert(p1).toCalendar();
+        Calendar c2 = Conversions.convert(p1).toCalendar();
         return c1 != null && c2 != null
                 ? c1.compareTo(c2)
                 : p1.compareTo(p2);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/util/NodeUtil.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/util/NodeUtil.java
index c6957aa669..21b0ace87c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/util/NodeUtil.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/util/NodeUtil.java
@@ -36,7 +36,7 @@ import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.namepath.NameMapper;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
 import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
-import org.apache.jackrabbit.util.ISO8601;
+import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -185,7 +185,7 @@ public class NodeUtil {
     public void setDate(String name, long time) {
         Calendar cal = GregorianCalendar.getInstance();
         cal.setTimeInMillis(time);
-        tree.setProperty(name, ISO8601.format(cal), DATE);
+        tree.setProperty(name, Conversions.convert(cal).toDate(), DATE);
     }
 
     public long getLong(String name, long defaultValue) {
