diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/CommitFailedException.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/CommitFailedException.java
index 3b5bd9190a..19d83b6e6d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/CommitFailedException.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/CommitFailedException.java
@@ -65,7 +65,7 @@ public class CommitFailedException extends Exception {
             throw e;
         }
         else {
-            throw new RepositoryException(cause);
+            throw new RepositoryException(this);
         }
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java
index 63674597f4..7a091c1bb3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/TreeImpl.java
@@ -37,7 +37,7 @@ import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.core.RootImpl.PurgeListener;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryPropertyBuilder;
-import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
+import org.apache.jackrabbit.oak.plugins.memory.MultiStringPropertyState;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;
@@ -359,9 +359,7 @@ public class TreeImpl implements Tree, PurgeListener {
             tail = Iterables.skip(filtered, idx);
         }
         // concatenate head, this name and tail
-        parent.getNodeBuilder().setProperty(PropertyStates.stringProperty(
-                OAK_CHILD_ORDER,
-                Iterables.concat(head, Collections.singleton(getName()), tail))
+        parent.getNodeBuilder().setProperty(MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))
         );
         root.purge();
         return true;
@@ -574,9 +572,7 @@ public class TreeImpl implements Tree, PurgeListener {
         PropertyState childOrder = getNodeBuilder().getProperty(OAK_CHILD_ORDER);
         if (childOrder == null) {
             getNodeBuilder().setProperty(
-                    PropertyStates.stringProperty(
-                            OAK_CHILD_ORDER,
-                            getNodeBuilder().getChildNodeNames()));
+                    MultiStringPropertyState.stringProperty(OAK_CHILD_ORDER, getNodeBuilder().getChildNodeNames()));
         }
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
index 5668d3cdde..06043d6459 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
@@ -42,7 +42,7 @@ import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
-import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
+import org.apache.jackrabbit.oak.plugins.memory.StringPropertyState;
 import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -280,7 +280,7 @@ public class IdentifierManager {
 
     @CheckForNull
     private String resolveUUID(String uuid) {
-        return resolveUUID(PropertyStates.stringProperty("", uuid));
+        return resolveUUID(StringPropertyState.stringProperty("", uuid));
     }
 
     private String resolveUUID(PropertyState uuid) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinaryPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinaryPropertyState.java
index a6c14ed919..d0fef63208 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinaryPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinaryPropertyState.java
@@ -16,7 +16,10 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import javax.jcr.Value;
+
 import org.apache.jackrabbit.oak.api.Blob;
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
@@ -29,6 +32,46 @@ public class BinaryPropertyState extends SinglePropertyState<Blob> {
         this.value = value;
     }
 
+    /**
+     * Create a {@code PropertyState} from an array of bytes.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#BINARY}
+     */
+    public static PropertyState binaryProperty(String name, byte[] value) {
+        return new BinaryPropertyState(name, new ArrayBasedBlob(value));
+    }
+
+    /**
+     * Create a {@code PropertyState} from an array of bytes.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#BINARY}
+     */
+    public static PropertyState binaryProperty(String name, String value) {
+        return new BinaryPropertyState(name, new StringBasedBlob(value));
+    }
+
+    /**
+     * Create a {@code PropertyState} from a {@link Blob}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#BINARY}
+     */
+    public static PropertyState binaryProperty(String name, Blob value) {
+        return new BinaryPropertyState(name, value);
+    }
+
+    /**
+     * Create a {@code PropertyState} from a {@link javax.jcr.Value}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#BINARY}
+     */
+    public static PropertyState binaryProperty(String name, Value value) {
+        return new BinaryPropertyState(name, new ValueBasedBlob(value));
+    }
+
     @Override
     public Blob getValue() {
         return value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleanPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleanPropertyState.java
index 3563a92961..a240f99c06 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleanPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleanPropertyState.java
@@ -18,11 +18,12 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
-import static org.apache.jackrabbit.oak.api.Type.*;
+import static org.apache.jackrabbit.oak.api.Type.BOOLEAN;
 
 public class BooleanPropertyState extends SinglePropertyState<Boolean> {
     private final boolean value;
@@ -32,6 +33,16 @@ public class BooleanPropertyState extends SinglePropertyState<Boolean> {
         this.value = value;
     }
 
+    /**
+     * Create a {@code PropertyState} from a boolean.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#BOOLEAN}
+     */
+    public static PropertyState booleanProperty(String name, boolean value) {
+        return new BooleanPropertyState(name, value);
+    }
+
     @Override
     public Boolean getValue() {
         return value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalPropertyState.java
index 75cf000f22..84356e42a7 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalPropertyState.java
@@ -18,6 +18,7 @@ package org.apache.jackrabbit.oak.plugins.memory;
 
 import java.math.BigDecimal;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
@@ -32,6 +33,16 @@ public class DecimalPropertyState extends SinglePropertyState<BigDecimal> {
         this.value = value;
     }
 
+    /**
+     * Create a {@code PropertyState} from a decimal.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#DECIMAL}
+     */
+    public static PropertyState decimalProperty(String name, BigDecimal value) {
+        return new DecimalPropertyState(name, value);
+    }
+
     @Override
     public BigDecimal getValue() {
         return value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublePropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublePropertyState.java
index 412de37298..756ecfa890 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublePropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublePropertyState.java
@@ -18,6 +18,7 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
@@ -32,6 +33,16 @@ public class DoublePropertyState extends SinglePropertyState<Double> {
         this.value = value;
     }
 
+    /**
+     * Create a {@code PropertyState} from a double.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#DOUBLE}
+     */
+    public static PropertyState doubleProperty(String name, double value) {
+        return new DoublePropertyState(name, value);
+    }
+
     @Override
     public Double getValue() {
         return value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyPropertyState.java
index 276ef380af..0d76942b08 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/EmptyPropertyState.java
@@ -48,6 +48,24 @@ public abstract class EmptyPropertyState implements PropertyState {
         this.name = name;
     }
 
+    /**
+     * Create an empty {@code PropertyState}
+     * @param name  The name of the property state
+     * @param type  The type of the property state
+     * @return  The new property state
+     */
+    public static PropertyState emptyProperty(String name, final Type<?> type) {
+        if (!type.isArray()) {
+            throw new IllegalArgumentException("Not an array type:" + type);
+        }
+        return new EmptyPropertyState(name) {
+            @Override
+            public Type<?> getType() {
+                return type;
+            }
+        };
+    }
+
     @Nonnull
     @Override
     public String getName() {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericPropertyState.java
index 8a4fed7391..6fd3a9be0c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericPropertyState.java
@@ -16,11 +16,17 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static org.apache.jackrabbit.oak.api.Type.NAME;
+import static org.apache.jackrabbit.oak.api.Type.PATH;
+import static org.apache.jackrabbit.oak.api.Type.REFERENCE;
+import static org.apache.jackrabbit.oak.api.Type.URI;
+import static org.apache.jackrabbit.oak.api.Type.WEAKREFERENCE;
 
 public class GenericPropertyState extends SinglePropertyState<String> {
     private final String value;
@@ -36,6 +42,61 @@ public class GenericPropertyState extends SinglePropertyState<String> {
         this.type = type;
     }
 
+    /**
+     * Create a {@code PropertyState} from a name. No validation is performed
+     * on the string passed for {@code value}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#NAME}
+     */
+    public static PropertyState nameProperty(String name, String value) {
+        return new GenericPropertyState(name, value, NAME);
+    }
+
+    /**
+     * Create a {@code PropertyState} from a path. No validation is performed
+     * on the string passed for {@code value}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#PATH}
+     */
+    public static PropertyState pathProperty(String name, String value) {
+        return new GenericPropertyState(name, value, PATH);
+    }
+
+    /**
+     * Create a {@code PropertyState} from a reference. No validation is performed
+     * on the string passed for {@code value}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#REFERENCE}
+     */
+    public static PropertyState referenceProperty(String name, String value) {
+        return new GenericPropertyState(name, value, REFERENCE);
+    }
+
+    /**
+     * Create a {@code PropertyState} from a weak reference. No validation is performed
+     * on the string passed for {@code value}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#WEAKREFERENCE}
+     */
+    public static PropertyState weakreferenceProperty(String name, String value) {
+        return new GenericPropertyState(name, value, WEAKREFERENCE);
+    }
+
+    /**
+     * Create a {@code PropertyState} from a URI. No validation is performed
+     * on the string passed for {@code value}.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#URI}
+     */
+    public static PropertyState uriProperty(String name, String value) {
+        return new GenericPropertyState(name, value, URI);
+    }
+
     @Override
     public String getValue() {
         return value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericsPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericsPropertyState.java
deleted file mode 100644
index eda44eee80..0000000000
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/GenericsPropertyState.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.jackrabbit.oak.plugins.memory;
-
-import org.apache.jackrabbit.oak.api.Type;
-import org.apache.jackrabbit.oak.plugins.value.Conversions;
-import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
-
-import static com.google.common.base.Preconditions.checkArgument;
-
-public class GenericsPropertyState extends MultiPropertyState<String> {
-    private final Type<?> type;
-
-    /**
-     * @throws IllegalArgumentException if {@code type.isArray()} is {@code false}
-     */
-    public GenericsPropertyState(String name, Iterable<String> values, Type<?> type) {
-        super(name, values);
-        checkArgument(type.isArray());
-        this.type = type;
-    }
-
-    @Override
-    public Converter getConverter(String value) {
-        return Conversions.convert(value);
-    }
-
-    @Override
-    public Type<?> getType() {
-        return type;
-    }
-}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongPropertyState.java
index d749658d05..2187096ed7 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongPropertyState.java
@@ -20,6 +20,7 @@ package org.apache.jackrabbit.oak.plugins.memory;
 
 import java.util.Calendar;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
@@ -28,7 +29,7 @@ public class LongPropertyState extends SinglePropertyState<Long> {
     private final long value;
     private final Type<?> type;
 
-    private LongPropertyState(String name, long value, Type<?> type) {
+    public LongPropertyState(String name, long value, Type<?> type) {
         super(name);
         this.value = value;
         this.type = type;
@@ -40,7 +41,7 @@ public class LongPropertyState extends SinglePropertyState<Long> {
      * @param value  The value of the property state
      * @return  The new property state of type {@link Type#LONG}
      */
-    public static LongPropertyState createLongProperty(String name, long value) {
+    public static PropertyState createLongProperty(String name, long value) {
         return new LongPropertyState(name, value, Type.LONG);
     }
 
@@ -50,7 +51,7 @@ public class LongPropertyState extends SinglePropertyState<Long> {
      * @param value  The value of the property state
      * @return  The new property state of type {@link Type#DATE}
      */
-    public static LongPropertyState createDateProperty(String name, long value) {
+    public static PropertyState createDateProperty(String name, long value) {
         return new LongPropertyState(name, value, Type.DATE);
     }
 
@@ -60,7 +61,7 @@ public class LongPropertyState extends SinglePropertyState<Long> {
      * @param value  The value of the property state
      * @return  The new property state of type {@link Type#DATE}
      */
-    public static LongPropertyState createDateProperty(String name, Calendar value) {
+    public static PropertyState createDateProperty(String name, Calendar value) {
         return new LongPropertyState(name, Conversions.convert(value).toLong(), Type.DATE);
     }
 
@@ -71,7 +72,7 @@ public class LongPropertyState extends SinglePropertyState<Long> {
      * @return  The new property state of type {@link Type#DATE}
      * @throws IllegalArgumentException if {@code value} is not a parseable to a date.
      */
-    public static LongPropertyState createDateProperty(String name, String value) {
+    public static PropertyState createDateProperty(String name, String value) {
         return createDateProperty(name, Conversions.convert(value).toCalendar());
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java
index 3f551b7913..6af9e4ebb5 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilder.java
@@ -147,45 +147,45 @@ public class MemoryPropertyBuilder<T> implements PropertyBuilder<T> {
     public PropertyState getPropertyState(boolean asArray) {
         checkState(name != null, "Property has no name");
         if (values.isEmpty()) {
-            return PropertyStates.emptyProperty(name, Type.fromTag(type.tag(), true));
+            return EmptyPropertyState.emptyProperty(name, Type.fromTag(type.tag(), true));
         }
         else if (isArray() || asArray) {
             switch (type.tag()) {
                 case PropertyType.STRING:
-                    return PropertyStates.stringProperty(name, (Iterable<String>) values);
+                    return MultiStringPropertyState.stringProperty(name, (Iterable<String>) values);
                 case PropertyType.BINARY:
-                    return PropertyStates.binaryPropertyFromBlob(name, (Iterable<Blob>) values);
+                    return MultiBinaryPropertyState.binaryPropertyFromBlob(name, (Iterable<Blob>) values);
                 case PropertyType.LONG:
-                    return PropertyStates.longProperty(name, (Iterable<Long>) values);
+                    return MultiLongPropertyState.createLongProperty(name, (Iterable<Long>) values);
                 case PropertyType.DOUBLE:
-                    return PropertyStates.doubleProperty(name, (Iterable<Double>) values);
+                    return MultiDoublePropertyState.doubleProperty(name, (Iterable<Double>) values);
                 case PropertyType.DATE:
-                    return LongsPropertyState.createDatesProperty(name, (Iterable<String>) values);
+                    return MultiLongPropertyState.createDateProperty(name, (Iterable<String>) values);
                 case PropertyType.BOOLEAN:
-                    return PropertyStates.booleanProperty(name, (Iterable<Boolean>) values);
+                    return MultiBooleanPropertyState.booleanProperty(name, (Iterable<Boolean>) values);
                 case PropertyType.DECIMAL:
-                    return PropertyStates.decimalProperty(name, (Iterable<BigDecimal>) values);
+                    return MultiDecimalPropertyState.decimalProperty(name, (Iterable<BigDecimal>) values);
                 default:
-                    return new GenericsPropertyState(name, (Iterable<String>) values, Type.fromTag(type.tag(), true));
+                    return new MultiGenericPropertyState(name, (Iterable<String>) values, Type.fromTag(type.tag(), true));
             }
         }
         else {
             T value = values.get(0);
             switch (type.tag()) {
                 case PropertyType.STRING:
-                    return PropertyStates.stringProperty(name, (String) value);
+                    return StringPropertyState.stringProperty(name, (String) value);
                 case PropertyType.BINARY:
-                    return PropertyStates.binaryProperty(name, (Blob) value);
+                    return  BinaryPropertyState.binaryProperty(name, (Blob) value);
                 case PropertyType.LONG:
-                    return PropertyStates.longProperty(name, (Long) value);
+                    return LongPropertyState.createLongProperty(name, (Long) value);
                 case PropertyType.DOUBLE:
-                    return PropertyStates.doubleProperty(name, (Double) value);
+                    return DoublePropertyState.doubleProperty(name, (Double) value);
                 case PropertyType.DATE:
-                    return PropertyStates.dateProperty(name, (String) value);
+                    return LongPropertyState.createDateProperty(name, (String) value);
                 case PropertyType.BOOLEAN:
-                    return PropertyStates.booleanProperty(name, (Boolean) value);
+                    return BooleanPropertyState.booleanProperty(name, (Boolean) value);
                 case PropertyType.DECIMAL:
-                    return PropertyStates.decimalProperty(name, (BigDecimal) value);
+                    return DecimalPropertyState.decimalProperty(name, (BigDecimal) value);
                 default:
                     return new GenericPropertyState(name, (String) value, type);
             }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinariesPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiBinaryPropertyState.java
similarity index 51%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinariesPropertyState.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiBinaryPropertyState.java
index f74de25199..9342e1c59b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BinariesPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiBinaryPropertyState.java
@@ -16,18 +16,46 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import java.util.List;
+
+import com.google.common.collect.Lists;
 import org.apache.jackrabbit.oak.api.Blob;
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
 import static org.apache.jackrabbit.oak.api.Type.BINARIES;
 
-public class BinariesPropertyState extends MultiPropertyState<Blob> {
-    public BinariesPropertyState(String name, Iterable<Blob> values) {
+public class MultiBinaryPropertyState extends MultiPropertyState<Blob> {
+    public MultiBinaryPropertyState(String name, Iterable<Blob> values) {
         super(name, values);
     }
 
+    /**
+     * Create a multi valued {@code PropertyState} from a list of {@link Blob}.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#BINARIES}
+     */
+    public static PropertyState binaryPropertyFromBlob(String name, Iterable<Blob> values) {
+        return new MultiBinaryPropertyState(name, values);
+    }
+
+    /**
+     * Create a multi valued {@code PropertyState} from a list of byte arrays.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#BINARIES}
+     */
+    public static PropertyState binaryPropertyFromArray(String name, Iterable<byte[]> values) {
+        List<Blob> blobs = Lists.newArrayList();
+        for (byte[] data : values) {
+            blobs.add(new ArrayBasedBlob(data));
+        }
+        return new MultiBinaryPropertyState(name, blobs);
+    }
+
     @Override
     public Converter getConverter(Blob value) {
         return Conversions.convert(value);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleansPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiBooleanPropertyState.java
similarity index 67%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleansPropertyState.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiBooleanPropertyState.java
index 1507bcbe26..ecaa1211cf 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/BooleansPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiBooleanPropertyState.java
@@ -16,17 +16,28 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
 import static org.apache.jackrabbit.oak.api.Type.BOOLEANS;
 
-public class BooleansPropertyState extends MultiPropertyState<Boolean> {
-    public BooleansPropertyState(String name, Iterable<Boolean> values) {
+public class MultiBooleanPropertyState extends MultiPropertyState<Boolean> {
+    public MultiBooleanPropertyState(String name, Iterable<Boolean> values) {
         super(name, values);
     }
 
+    /**
+     * Create a multi valued {@code PropertyState} from a list of booleans.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#BOOLEANS}
+     */
+    public static PropertyState booleanProperty(String name, Iterable<Boolean> values) {
+        return new MultiBooleanPropertyState(name, values);
+    }
+
     @Override
     public Converter getConverter(Boolean value) {
         return Conversions.convert(value);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalsPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiDecimalPropertyState.java
similarity index 67%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalsPropertyState.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiDecimalPropertyState.java
index cf5c2b52c2..cb1da1b4c6 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DecimalsPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiDecimalPropertyState.java
@@ -18,17 +18,28 @@ package org.apache.jackrabbit.oak.plugins.memory;
 
 import java.math.BigDecimal;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
 import static org.apache.jackrabbit.oak.api.Type.DECIMALS;
 
-public class DecimalsPropertyState extends MultiPropertyState<BigDecimal> {
-    public DecimalsPropertyState(String name, Iterable<BigDecimal> values) {
+public class MultiDecimalPropertyState extends MultiPropertyState<BigDecimal> {
+    public MultiDecimalPropertyState(String name, Iterable<BigDecimal> values) {
         super(name, values);
     }
 
+    /**
+     * Create a multi valued {@code PropertyState} from a list of decimals.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#DECIMALS}
+     */
+    public static PropertyState decimalProperty(String name, Iterable<BigDecimal> values) {
+        return new MultiDecimalPropertyState(name, values);
+    }
+
     @Override
     public Converter getConverter(BigDecimal value) {
         return Conversions.convert(value);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublesPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiDoublePropertyState.java
similarity index 67%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublesPropertyState.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiDoublePropertyState.java
index 512537d343..8c6e4c29e9 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/DoublesPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiDoublePropertyState.java
@@ -18,17 +18,28 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
 import static org.apache.jackrabbit.oak.api.Type.DOUBLES;
 
-public class DoublesPropertyState extends MultiPropertyState<Double> {
-    public DoublesPropertyState(String name, Iterable<Double>values) {
+public class MultiDoublePropertyState extends MultiPropertyState<Double> {
+    public MultiDoublePropertyState(String name, Iterable<Double> values) {
         super(name, values);
     }
 
+    /**
+     * Create a multi valued {@code PropertyState} from a list of doubles.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#DOUBLES}
+     */
+    public static PropertyState doubleProperty(String name, Iterable<Double> values) {
+        return new MultiDoublePropertyState(name, values);
+    }
+
     @Override
     public Converter getConverter(Double value) {
         return Conversions.convert(value);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiGenericPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiGenericPropertyState.java
new file mode 100644
index 0000000000..fae45f15f5
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiGenericPropertyState.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.memory;
+
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.api.Type;
+import org.apache.jackrabbit.oak.plugins.value.Conversions;
+import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static org.apache.jackrabbit.oak.api.Type.NAMES;
+import static org.apache.jackrabbit.oak.api.Type.PATHS;
+import static org.apache.jackrabbit.oak.api.Type.REFERENCES;
+import static org.apache.jackrabbit.oak.api.Type.URIS;
+import static org.apache.jackrabbit.oak.api.Type.WEAKREFERENCES;
+
+public class MultiGenericPropertyState extends MultiPropertyState<String> {
+    private final Type<?> type;
+
+    /**
+     * @throws IllegalArgumentException if {@code type.isArray()} is {@code false}
+     */
+    public MultiGenericPropertyState(String name, Iterable<String> values, Type<?> type) {
+        super(name, values);
+        checkArgument(type.isArray());
+        this.type = type;
+    }
+
+    /**
+     * Create a multi valued {@code PropertyState} from a list of names.
+     * No validation is performed on the strings passed for {@code values}.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#NAMES}
+     */
+    public static PropertyState nameProperty(String name, Iterable<String> values) {
+        return new MultiGenericPropertyState(name, values, NAMES);
+    }
+
+    /**
+     * Create a multi valued {@code PropertyState} from a list of paths.
+     * No validation is performed on the strings passed for {@code values}.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#PATHS}
+     */
+    public static PropertyState pathProperty(String name, Iterable<String> values) {
+        return new MultiGenericPropertyState(name, values, PATHS);
+    }
+
+    /**
+     * Create a multi valued {@code PropertyState} from a list of references.
+     * No validation is performed on the strings passed for {@code values}.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#REFERENCES}
+     */
+    public static PropertyState referenceProperty(String name, Iterable<String> values) {
+        return new MultiGenericPropertyState(name, values, REFERENCES);
+    }
+
+    /**
+     * Create a multi valued {@code PropertyState} from a list of weak references.
+     * No validation is performed on the strings passed for {@code values}.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#WEAKREFERENCES}
+     */
+    public static PropertyState weakreferenceProperty(String name, Iterable<String> values) {
+        return new MultiGenericPropertyState(name, values, WEAKREFERENCES);
+    }
+
+    /**
+     * Create a multi valued {@code PropertyState} from a list of URIs.
+     * No validation is performed on the strings passed for {@code values}.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#URIS}
+     */
+    public static PropertyState uriProperty(String name, Iterable<String> values) {
+        return new MultiGenericPropertyState(name, values, URIS);
+    }
+
+    @Override
+    public Converter getConverter(String value) {
+        return Conversions.convert(value);
+    }
+
+    @Override
+    public Type<?> getType() {
+        return type;
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongsPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiLongPropertyState.java
similarity index 77%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongsPropertyState.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiLongPropertyState.java
index df29c25179..417cab97a3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/LongsPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiLongPropertyState.java
@@ -22,14 +22,15 @@ import java.util.Calendar;
 import java.util.List;
 
 import com.google.common.collect.Lists;
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
-public class LongsPropertyState extends MultiPropertyState<Long> {
+public class MultiLongPropertyState extends MultiPropertyState<Long> {
     private final Type<?> type;
 
-    private LongsPropertyState(String name, Iterable<Long> values, Type<?> type) {
+    public MultiLongPropertyState(String name, Iterable<Long> values, Type<?> type) {
         super(name, values);
         this.type = type;
     }
@@ -40,8 +41,8 @@ public class LongsPropertyState extends MultiPropertyState<Long> {
      * @param values  The values of the property state
      * @return  The new property state of type {@link Type#LONGS}
      */
-    public static LongsPropertyState createLongsProperty(String name, Iterable<Long> values) {
-        return new LongsPropertyState(name, Lists.newArrayList(values), Type.LONGS);
+    public static PropertyState createLongProperty(String name, Iterable<Long> values) {
+        return new MultiLongPropertyState(name, Lists.newArrayList(values), Type.LONGS);
     }
 
     /**
@@ -50,8 +51,8 @@ public class LongsPropertyState extends MultiPropertyState<Long> {
      * @param values  The values of the property state
      * @return  The new property state of type {@link Type#DATES}
      */
-    public static LongsPropertyState createDatesPropertyFromLong(String name, Iterable<Long> values) {
-        return new LongsPropertyState(name, Lists.newArrayList(values), Type.DATES);
+    public static PropertyState createDatePropertyFromLong(String name, Iterable<Long> values) {
+        return new MultiLongPropertyState(name, Lists.newArrayList(values), Type.DATES);
     }
 
     /**
@@ -60,12 +61,12 @@ public class LongsPropertyState extends MultiPropertyState<Long> {
      * @param values  The values of the property state
      * @return  The new property state of type {@link Type#DATES}
      */
-    public static LongsPropertyState createDatesPropertyFromCalendar(String name, Iterable<Calendar> values) {
+    public static PropertyState createDatePropertyFromCalendar(String name, Iterable<Calendar> values) {
         List<Long> dates = Lists.newArrayList();
         for (Calendar v : values) {
             dates.add(Conversions.convert(v).toLong());
         }
-        return new LongsPropertyState(name, dates, Type.DATES);
+        return new MultiLongPropertyState(name, dates, Type.DATES);
     }
 
     /**
@@ -75,12 +76,12 @@ public class LongsPropertyState extends MultiPropertyState<Long> {
      * @return  The new property state of type {@link Type#DATES}
      * @throws IllegalArgumentException if one of the {@code values} is not a parseable to a date.
      */
-    public static LongsPropertyState createDatesProperty(String name, Iterable<String> values) {
+    public static PropertyState createDateProperty(String name, Iterable<String> values) {
         List<Long> dates = Lists.newArrayList();
         for (String v : values) {
             dates.add(Conversions.convert(Conversions.convert(v).toCalendar()).toLong());
         }
-        return new LongsPropertyState(name, dates, Type.DATES);
+        return new MultiLongPropertyState(name, dates, Type.DATES);
     }
 
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringsPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiStringPropertyState.java
similarity index 67%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringsPropertyState.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiStringPropertyState.java
index dd9bd0ca60..902e4b248b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringsPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MultiStringPropertyState.java
@@ -18,15 +18,26 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
 
-public class StringsPropertyState extends MultiPropertyState<String> {
-    public StringsPropertyState(String name, Iterable<String> values) {
+public class MultiStringPropertyState extends MultiPropertyState<String> {
+    public MultiStringPropertyState(String name, Iterable<String> values) {
         super(name, values);
     }
 
+    /**
+     * Create a multi valued {@code PropertyState} from a list of strings.
+     * @param name  The name of the property state
+     * @param values  The values of the property state
+     * @return  The new property state of type {@link Type#STRINGS}
+     */
+    public static PropertyState stringProperty(String name, Iterable<String> values) {
+        return new MultiStringPropertyState(name, values);
+    }
+
     @Override
     public Converter getConverter(String value) {
         return Conversions.convert(value);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java
index 617704544d..8e55fa7b3d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/PropertyStates.java
@@ -19,7 +19,6 @@
 package org.apache.jackrabbit.oak.plugins.memory;
 
 import java.math.BigDecimal;
-import java.util.Calendar;
 import java.util.List;
 
 import javax.annotation.Nonnull;
@@ -38,17 +37,7 @@ import org.apache.jackrabbit.oak.kernel.KernelBlob;
 import org.apache.jackrabbit.oak.kernel.TypeCodes;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 
-import static org.apache.jackrabbit.oak.api.Type.NAME;
-import static org.apache.jackrabbit.oak.api.Type.NAMES;
-import static org.apache.jackrabbit.oak.api.Type.PATH;
-import static org.apache.jackrabbit.oak.api.Type.PATHS;
-import static org.apache.jackrabbit.oak.api.Type.REFERENCE;
-import static org.apache.jackrabbit.oak.api.Type.REFERENCES;
 import static org.apache.jackrabbit.oak.api.Type.STRINGS;
-import static org.apache.jackrabbit.oak.api.Type.URI;
-import static org.apache.jackrabbit.oak.api.Type.URIS;
-import static org.apache.jackrabbit.oak.api.Type.WEAKREFERENCE;
-import static org.apache.jackrabbit.oak.api.Type.WEAKREFERENCES;
 
 /**
  * Utility class for creating {@link PropertyState} instances.
@@ -70,19 +59,19 @@ public final class PropertyStates {
         int type = value.getType();
         switch (type) {
             case PropertyType.STRING:
-                return stringProperty(name, value.getString());
+                return StringPropertyState.stringProperty(name, value.getString());
             case PropertyType.BINARY:
-                return binaryProperty(name, value);
+                return BinaryPropertyState.binaryProperty(name, value);
             case PropertyType.LONG:
-                return longProperty(name, value.getLong());
+                return LongPropertyState.createLongProperty(name, value.getLong());
             case PropertyType.DOUBLE:
-                return doubleProperty(name, value.getDouble());
+                return DoublePropertyState.doubleProperty(name, value.getDouble());
             case PropertyType.DATE:
-                return dateProperty(name, value.getLong());
+                return LongPropertyState.createDateProperty(name, value.getLong());
             case PropertyType.BOOLEAN:
-                return booleanProperty(name, value.getBoolean());
+                return BooleanPropertyState.booleanProperty(name, value.getBoolean());
             case PropertyType.DECIMAL:
-                return decimalProperty(name, value.getDecimal());
+                return DecimalPropertyState.decimalProperty(name, value.getDecimal());
             default:
                 return new GenericPropertyState(name, value.getString(), Type.fromTag(type, false));
         }
@@ -103,7 +92,7 @@ public final class PropertyStates {
     public static PropertyState createProperty(String name, Iterable<Value> values) throws RepositoryException {
         Value first = Iterables.getFirst(values, null);
         if (first == null) {
-            return emptyProperty(name, STRINGS);
+            return EmptyPropertyState.emptyProperty(name, STRINGS);
         }
 
         int type = first.getType();
@@ -113,49 +102,49 @@ public final class PropertyStates {
                 for (Value value : values) {
                     strings.add(value.getString());
                 }
-                return stringProperty(name, strings);
+                return MultiStringPropertyState.stringProperty(name, strings);
             case PropertyType.BINARY:
                 List<Blob> blobs = Lists.newArrayList();
                 for (Value value : values) {
                     blobs.add(new ValueBasedBlob(value));
                 }
-                return binaryPropertyFromBlob(name, blobs);
+                return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);
             case PropertyType.LONG:
                 List<Long> longs = Lists.newArrayList();
                 for (Value value : values) {
                     longs.add(value.getLong());
                 }
-                return longProperty(name, longs);
+                return MultiLongPropertyState.createLongProperty(name, longs);
             case PropertyType.DOUBLE:
                 List<Double> doubles = Lists.newArrayList();
                 for (Value value : values) {
                     doubles.add(value.getDouble());
                 }
-                return doubleProperty(name, doubles);
+                return MultiDoublePropertyState.doubleProperty(name, doubles);
             case PropertyType.DATE:
                 List<Long> dates = Lists.newArrayList();
                 for (Value value : values) {
                     dates.add(value.getLong());
                 }
-                return datePropertyFromLong(name, dates);
+                return MultiLongPropertyState.createDatePropertyFromLong(name, dates);
             case PropertyType.BOOLEAN:
                 List<Boolean> booleans = Lists.newArrayList();
                 for (Value value : values) {
                     booleans.add(value.getBoolean());
                 }
-                return booleanProperty(name, booleans);
+                return MultiBooleanPropertyState.booleanProperty(name, booleans);
             case PropertyType.DECIMAL:
                 List<BigDecimal> decimals = Lists.newArrayList();
                 for (Value value : values) {
                     decimals.add(value.getDecimal());
                 }
-                return decimalProperty(name, decimals);
+                return MultiDecimalPropertyState.decimalProperty(name, decimals);
             default:
                 List<String> vals = Lists.newArrayList();
                 for (Value value : values) {
                     vals.add(value.getString());
                 }
-                return new GenericsPropertyState(name, vals, Type.fromTag(type, true));
+                return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));
         }
     }
 
@@ -170,19 +159,19 @@ public final class PropertyStates {
     public static PropertyState createProperty(String name, String value, int type) {
         switch (type) {
             case PropertyType.STRING:
-                return stringProperty(name, value);
+                return StringPropertyState.stringProperty(name, value);
             case PropertyType.BINARY:
-                return binaryProperty(name, Conversions.convert(value).toBinary());
+                return  BinaryPropertyState.binaryProperty(name, Conversions.convert(value).toBinary());
             case PropertyType.LONG:
-                return longProperty(name, Conversions.convert(value).toLong());
+                return LongPropertyState.createLongProperty(name, Conversions.convert(value).toLong());
             case PropertyType.DOUBLE:
-                return doubleProperty(name, Conversions.convert(value).toDouble());
+                return DoublePropertyState.doubleProperty(name, Conversions.convert(value).toDouble());
             case PropertyType.DATE:
-                return dateProperty(name, value);
+                return LongPropertyState.createDateProperty(name, value);
             case PropertyType.BOOLEAN:
-                return booleanProperty(name, Conversions.convert(value).toBoolean());
+                return BooleanPropertyState.booleanProperty(name, Conversions.convert(value).toBoolean());
             case PropertyType.DECIMAL:
-                return decimalProperty(name, Conversions.convert(value).toDecimal());
+                return DecimalPropertyState.decimalProperty(name, Conversions.convert(value).toDecimal());
             default:
                 return new GenericPropertyState(name, value, Type.fromTag(type, false));
         }
@@ -199,42 +188,54 @@ public final class PropertyStates {
     @Nonnull
     public static <T> PropertyState createProperty(String name, T value, Type<T> type) {
         switch (type.tag()) {
-            case PropertyType.STRING: return type.isArray()
-                ? stringProperty(name, (Iterable<String>) value)
-                : stringProperty(name, (String) value);
-            case PropertyType.BINARY: return type.isArray()
-                ? binaryPropertyFromBlob(name, (Iterable<Blob>) value)
-                : binaryProperty(name, (Blob) value);
-            case PropertyType.LONG: return type.isArray()
-                ? longProperty(name, (Iterable<Long>) value)
-                : longProperty(name, (Long) value);
-            case PropertyType.DOUBLE: return type.isArray()
-                ? doubleProperty(name, (Iterable<Double>) value)
-                : doubleProperty(name, (Double) value);
-            case PropertyType.DATE: return type.isArray()
-                ? dateProperty(name, (Iterable<String>) value)
-                : dateProperty(name, (String) value);
-            case PropertyType.BOOLEAN: return type.isArray()
-                ? booleanProperty(name, (Iterable<Boolean>) value)
-                : booleanProperty(name, (Boolean) value);
-            case PropertyType.NAME: return type.isArray()
-                ? nameProperty(name, (Iterable<String>) value)
-                : nameProperty(name, (String) value);
-            case PropertyType.PATH: return type.isArray()
-                ? pathProperty(name, (Iterable<String>) value)
-                : pathProperty(name, (String) value);
-            case PropertyType.REFERENCE: return type.isArray()
-                ? referenceProperty(name, (Iterable<String>) value)
-                : referenceProperty(name, (String) value);
-            case PropertyType.WEAKREFERENCE: return type.isArray()
-                ? weakreferenceProperty(name, (Iterable<String>) value)
-                : weakreferenceProperty(name, (String) value);
-            case PropertyType.URI: return type.isArray()
-                ? uriProperty(name, (Iterable<String>) value)
-                : uriProperty(name, (String) value);
-            case PropertyType.DECIMAL: return type.isArray()
-                ? decimalProperty(name, (Iterable<BigDecimal>) value)
-                : decimalProperty(name, (BigDecimal) value);
+            case PropertyType.STRING:
+                return type.isArray()
+                ? MultiStringPropertyState.stringProperty(name, (Iterable<String>) value)
+                : StringPropertyState.stringProperty(name, (String) value);
+            case PropertyType.BINARY:
+                return type.isArray()
+                ? MultiBinaryPropertyState.binaryPropertyFromBlob(name, (Iterable<Blob>) value)
+                : BinaryPropertyState.binaryProperty(name, (Blob) value);
+            case PropertyType.LONG:
+                return type.isArray()
+                ? MultiLongPropertyState.createLongProperty(name, (Iterable<Long>) value)
+                : LongPropertyState.createLongProperty(name, (Long) value);
+            case PropertyType.DOUBLE:
+                return type.isArray()
+                ? MultiDoublePropertyState.doubleProperty(name, (Iterable<Double>) value)
+                : DoublePropertyState.doubleProperty(name, (Double) value);
+            case PropertyType.DATE:
+                return type.isArray()
+                ? MultiLongPropertyState.createDateProperty(name, (Iterable<String>) value)
+                : LongPropertyState.createDateProperty(name, (String) value);
+            case PropertyType.BOOLEAN:
+                return type.isArray()
+                ? MultiBooleanPropertyState.booleanProperty(name, (Iterable<Boolean>) value)
+                : BooleanPropertyState.booleanProperty(name, (Boolean) value);
+            case PropertyType.NAME:
+                return type.isArray()
+                ? MultiGenericPropertyState.nameProperty(name, (Iterable<String>) value)
+                : GenericPropertyState.nameProperty(name, (String) value);
+            case PropertyType.PATH:
+                return type.isArray()
+                ? MultiGenericPropertyState.pathProperty(name, (Iterable<String>) value)
+                : GenericPropertyState.pathProperty(name, (String) value);
+            case PropertyType.REFERENCE:
+                return type.isArray()
+                ? MultiGenericPropertyState.referenceProperty(name, (Iterable<String>) value)
+                : GenericPropertyState.referenceProperty(name, (String) value);
+            case PropertyType.WEAKREFERENCE:
+                return type.isArray()
+                ? MultiGenericPropertyState.weakreferenceProperty(name, (Iterable<String>) value)
+                : GenericPropertyState.weakreferenceProperty(name, (String) value);
+            case PropertyType.URI:
+                return type.isArray()
+                ? MultiGenericPropertyState.uriProperty(name, (Iterable<String>) value)
+                : GenericPropertyState.uriProperty(name, (String) value);
+            case PropertyType.DECIMAL:
+                return type.isArray()
+                ? MultiDecimalPropertyState.decimalProperty(name, (Iterable<BigDecimal>) value)
+                : DecimalPropertyState.decimalProperty(name, (BigDecimal) value);
             default: throw new IllegalArgumentException("Invalid type: " + type);
         }
     }
@@ -250,392 +251,34 @@ public final class PropertyStates {
     @Nonnull
     public static <T> PropertyState createProperty(String name, T value) {
         if (value instanceof String) {
-            return stringProperty(name, (String) value);
+            return StringPropertyState.stringProperty(name, (String) value);
         }
         else if (value instanceof Blob) {
-            return binaryProperty(name, (Blob) value);
+            return  BinaryPropertyState.binaryProperty(name, (Blob) value);
         }
         else if (value instanceof byte[]) {
-            return binaryProperty(name, (byte[]) value);
+            return BinaryPropertyState.binaryProperty(name, (byte[]) value);
         }
         else if (value instanceof Long) {
-            return longProperty(name, (Long) value);
+            return LongPropertyState.createLongProperty(name, (Long) value);
         }
         else if (value instanceof Integer) {
-            return longProperty(name, (Integer) value);
+            return LongPropertyState.createLongProperty(name, (long) (Integer) value);
         }
         else if (value instanceof Double) {
-            return doubleProperty(name, (Double) value);
+            return DoublePropertyState.doubleProperty(name, (Double) value);
         }
         else if (value instanceof Boolean) {
-            return booleanProperty(name, (Boolean) value);
+            return BooleanPropertyState.booleanProperty(name, (Boolean) value);
         }
         else if (value instanceof BigDecimal) {
-            return decimalProperty(name, (BigDecimal) value);
+            return DecimalPropertyState.decimalProperty(name, (BigDecimal) value);
         }
         else {
             throw new IllegalArgumentException("Can't infer type of value of class '" + value.getClass() + '\'');
         }
     }
 
-    /**
-     * Create an empty {@code PropertyState}
-     * @param name  The name of the property state
-     * @param type  The type of the property state
-     * @return  The new property state
-     */
-    public static PropertyState emptyProperty(String name, final Type<?> type) {
-        if (!type.isArray()) {
-            throw new IllegalArgumentException("Not an array type:" + type);
-        }
-        return new EmptyPropertyState(name) {
-            @Override
-            public Type<?> getType() {
-                return type;
-            }
-        };
-    }
-
-    /**
-     * Create a {@code PropertyState} from a string.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#STRING}
-     */
-    public static PropertyState stringProperty(String name, String value) {
-        return new StringPropertyState(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from an array of bytes.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#BINARY}
-     */
-    public static PropertyState binaryProperty(String name, byte[] value) {
-        return new BinaryPropertyState(name, new ArrayBasedBlob(value));
-    }
-
-    /**
-     * Create a {@code PropertyState} from an array of bytes.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#BINARY}
-     */
-    public static PropertyState binaryProperty(String name, String value) {
-        return new BinaryPropertyState(name, new StringBasedBlob(value));
-    }
-
-    /**
-     * Create a {@code PropertyState} from a {@link Blob}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#BINARY}
-     */
-    public static PropertyState binaryProperty(String name, Blob value) {
-        return new BinaryPropertyState(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a {@link Value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#BINARY}
-     */
-    public static PropertyState binaryProperty(String name, Value value) {
-        return new BinaryPropertyState(name, new ValueBasedBlob(value));
-    }
-
-    /**
-     * Create a {@code PropertyState} from a long.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#LONG}
-     */
-    public static PropertyState longProperty(String name, long value) {
-        return LongPropertyState.createLongProperty(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a double.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#DOUBLE}
-     */
-    public static PropertyState doubleProperty(String name, double value) {
-        return new DoublePropertyState(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a date. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#DATE}
-     */
-    public static PropertyState dateProperty(String name, String value) {
-        return LongPropertyState.createDateProperty(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a date. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#DATE}
-     */
-    public static PropertyState dateProperty(String name, long value) {
-        return LongPropertyState.createDateProperty(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a date. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#DATE}
-     */
-    public static PropertyState dateProperty(String name, Calendar value) {
-        return LongPropertyState.createDateProperty(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a boolean.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#BOOLEAN}
-     */
-    public static PropertyState booleanProperty(String name, boolean value) {
-        return new BooleanPropertyState(name, value);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a name. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#NAME}
-     */
-    public static PropertyState nameProperty(String name, String value) {
-        return new GenericPropertyState(name, value, NAME);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a path. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#PATH}
-     */
-    public static PropertyState pathProperty(String name, String value) {
-        return new GenericPropertyState(name, value, PATH);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a reference. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#REFERENCE}
-     */
-    public static PropertyState referenceProperty(String name, String value) {
-        return new GenericPropertyState(name, value, REFERENCE);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a weak reference. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#WEAKREFERENCE}
-     */
-    public static PropertyState weakreferenceProperty(String name, String value) {
-        return new GenericPropertyState(name, value, WEAKREFERENCE);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a URI. No validation is performed
-     * on the string passed for {@code value}.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#URI}
-     */
-    public static PropertyState uriProperty(String name, String value) {
-        return new GenericPropertyState(name, value, URI);
-    }
-
-    /**
-     * Create a {@code PropertyState} from a decimal.
-     * @param name  The name of the property state
-     * @param value  The value of the property state
-     * @return  The new property state of type {@link Type#DECIMAL}
-     */
-    public static PropertyState decimalProperty(String name, BigDecimal value) {
-        return new DecimalPropertyState(name, value);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of strings.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#STRINGS}
-     */
-    public static PropertyState stringProperty(String name, Iterable<String> values) {
-        return new StringsPropertyState(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of {@link Blob}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#BINARIES}
-     */
-    public static PropertyState binaryPropertyFromBlob(String name, Iterable<Blob> values) {
-        return new BinariesPropertyState(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of byte arrays.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#BINARIES}
-     */
-    public static PropertyState binaryPropertyFromArray(String name, Iterable<byte[]> values) {
-        List<Blob> blobs = Lists.newArrayList();
-        for (byte[] data : values) {
-            blobs.add(new ArrayBasedBlob(data));
-        }
-        return new BinariesPropertyState(name, blobs);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of longs.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#LONGS}
-     */
-    public static PropertyState longProperty(String name, Iterable<Long> values) {
-        return LongsPropertyState.createLongsProperty(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of doubles.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#DOUBLES}
-     */
-    public static PropertyState doubleProperty(String name, Iterable<Double> values) {
-        return new DoublesPropertyState(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of dates.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#DATES}
-     */
-    public static PropertyState dateProperty(String name, Iterable<String> values) {
-        return LongsPropertyState.createDatesProperty(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of dates.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#DATES}
-     */
-    public static PropertyState datePropertyFromLong(String name, Iterable<Long> values) {
-        return LongsPropertyState.createDatesPropertyFromLong(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of dates.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#DATES}
-     */
-    public static PropertyState datePropertyFromCalendar(String name, Iterable<Calendar> values) {
-        return LongsPropertyState.createDatesPropertyFromCalendar(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of booleans.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#BOOLEANS}
-     */
-    public static PropertyState booleanProperty(String name, Iterable<Boolean> values) {
-        return new BooleansPropertyState(name, values);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of names.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#NAMES}
-     */
-    public static PropertyState nameProperty(String name, Iterable<String> values) {
-        return new GenericsPropertyState(name, values, NAMES);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of paths.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#PATHS}
-     */
-    public static PropertyState pathProperty(String name, Iterable<String> values) {
-        return new GenericsPropertyState(name, values, PATHS);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of references.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#REFERENCES}
-     */
-    public static PropertyState referenceProperty(String name, Iterable<String> values) {
-        return new GenericsPropertyState(name, values, REFERENCES);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of weak references.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#WEAKREFERENCES}
-     */
-    public static PropertyState weakreferenceProperty(String name, Iterable<String> values) {
-        return new GenericsPropertyState(name, values, WEAKREFERENCES);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of URIs.
-     * No validation is performed on the strings passed for {@code values}.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#URIS}
-     */
-    public static PropertyState uriProperty(String name, Iterable<String> values) {
-        return new GenericsPropertyState(name, values, URIS);
-    }
-
-    /**
-     * Create a multi valued {@code PropertyState} from a list of decimals.
-     * @param name  The name of the property state
-     * @param values  The values of the property state
-     * @return  The new property state of type {@link Type#DECIMALS}
-     */
-    public static PropertyState decimalProperty(String name, Iterable<BigDecimal> values) {
-        return new DecimalsPropertyState(name, values);
-    }
-
     /**
      * Read a {@code PropertyState} from a {@link JsopReader}
      * @param name  The name of the property state
@@ -648,21 +291,21 @@ public final class PropertyStates {
             String number = reader.getToken();
             return createProperty(name, number, PropertyType.LONG);
         } else if (reader.matches(JsopReader.TRUE)) {
-            return booleanProperty(name, true);
+            return BooleanPropertyState.booleanProperty(name, true);
         } else if (reader.matches(JsopReader.FALSE)) {
-            return booleanProperty(name, false);
+            return BooleanPropertyState.booleanProperty(name, false);
         } else if (reader.matches(JsopReader.STRING)) {
             String jsonString = reader.getToken();
             if (TypeCodes.startsWithCode(jsonString)) {
                 int type = TypeCodes.getTypeForCode(jsonString.substring(0, 3));
                 String value = jsonString.substring(4);
                 if (type == PropertyType.BINARY) {
-                    return binaryProperty(name, new KernelBlob(value, kernel));
+                    return  BinaryPropertyState.binaryProperty(name, new KernelBlob(value, kernel));
                 } else {
                     return createProperty(name, value, type);
                 }
             } else {
-                return stringProperty(name, jsonString);
+                return StringPropertyState.stringProperty(name, jsonString);
             }
         } else {
             throw new IllegalArgumentException("Unexpected token: " + reader.getToken());
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringPropertyState.java
index 78efe9fb2e..308b400a30 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/StringPropertyState.java
@@ -18,6 +18,7 @@
  */
 package org.apache.jackrabbit.oak.plugins.memory;
 
+import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.value.Conversions;
 import org.apache.jackrabbit.oak.plugins.value.Conversions.Converter;
@@ -32,6 +33,16 @@ public class StringPropertyState extends SinglePropertyState<String> {
         this.value = value;
     }
 
+    /**
+     * Create a {@code PropertyState} from a string.
+     * @param name  The name of the property state
+     * @param value  The value of the property state
+     * @return  The new property state of type {@link Type#STRING}
+     */
+    public static PropertyState stringProperty(String name, String value) {
+        return new StringPropertyState(name, value);
+    }
+
     @Override
     public String getValue() {
         return value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
index 11c45cb0da..a0614ab534 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
@@ -39,7 +39,13 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
 import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
-import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
+import org.apache.jackrabbit.oak.plugins.memory.BinaryPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.BooleanPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.DecimalPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.DoublePropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.GenericPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.LongPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.StringPropertyState;
 import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.apache.jackrabbit.util.ISO8601;
 import org.slf4j.Logger;
@@ -108,7 +114,7 @@ public class ValueFactoryImpl implements ValueFactory {
 
     @Override
     public Value createValue(String value) {
-        return new ValueImpl(PropertyStates.stringProperty("", value), namePathMapper);
+        return new ValueImpl(StringPropertyState.stringProperty("", value), namePathMapper);
     }
 
     @Override
@@ -138,22 +144,22 @@ public class ValueFactoryImpl implements ValueFactory {
 
     @Override
     public Value createValue(long value) {
-        return new ValueImpl(PropertyStates.longProperty("", value), namePathMapper);
+        return new ValueImpl(LongPropertyState.createLongProperty("", value), namePathMapper);
     }
 
     @Override
     public Value createValue(double value) {
-        return new ValueImpl(PropertyStates.doubleProperty("", value), namePathMapper);
+        return new ValueImpl(DoublePropertyState.doubleProperty("", value), namePathMapper);
     }
 
     @Override
     public Value createValue(Calendar value) {
-        return new ValueImpl(PropertyStates.dateProperty("", value), namePathMapper);
+        return new ValueImpl(LongPropertyState.createDateProperty("", value), namePathMapper);
     }
 
     @Override
     public Value createValue(boolean value) {
-        return new ValueImpl(PropertyStates.booleanProperty("", value), namePathMapper);
+        return new ValueImpl(BooleanPropertyState.booleanProperty("", value), namePathMapper);
     }
 
     @Override
@@ -164,13 +170,13 @@ public class ValueFactoryImpl implements ValueFactory {
     @Override
     public Value createValue(Node value, boolean weak) throws RepositoryException {
         return weak
-            ? new ValueImpl(PropertyStates.weakreferenceProperty("", value.getUUID()), namePathMapper)
-            : new ValueImpl(PropertyStates.referenceProperty("", value.getUUID()), namePathMapper);
+            ? new ValueImpl(GenericPropertyState.weakreferenceProperty("", value.getUUID()), namePathMapper)
+            : new ValueImpl(GenericPropertyState.referenceProperty("", value.getUUID()), namePathMapper);
     }
 
     @Override
     public Value createValue(BigDecimal value) {
-        return new ValueImpl(PropertyStates.decimalProperty("", value), namePathMapper);
+        return new ValueImpl(DecimalPropertyState.decimalProperty("", value), namePathMapper);
     }
 
     @Override
@@ -185,7 +191,7 @@ public class ValueFactoryImpl implements ValueFactory {
                 case PropertyType.STRING:
                     return createValue(value);
                 case PropertyType.BINARY:
-                    pv = PropertyStates.binaryProperty("", value);
+                    pv = BinaryPropertyState.binaryProperty("", value);
                     break;
                 case PropertyType.LONG:
                     return createValue(Conversions.convert(value).toLong());
@@ -195,7 +201,7 @@ public class ValueFactoryImpl implements ValueFactory {
                     if (ISO8601.parse(value) == null) {
                         throw new ValueFormatException("Invalid date " + value);
                     }
-                    pv = PropertyStates.dateProperty("", value);
+                    pv = LongPropertyState.createDateProperty("", value);
                     break;
                 case PropertyType.BOOLEAN:
                     return createValue(Conversions.convert(value).toBoolean());
@@ -204,7 +210,7 @@ public class ValueFactoryImpl implements ValueFactory {
                     if (oakName == null) {
                         throw new ValueFormatException("Invalid name: " + value);
                     }
-                    pv = PropertyStates.nameProperty("", oakName);
+                    pv = GenericPropertyState.nameProperty("", oakName);
                     break;
                 case PropertyType.PATH:
                     String oakValue = value;
@@ -216,23 +222,23 @@ public class ValueFactoryImpl implements ValueFactory {
                     if (oakValue == null) {
                         throw new ValueFormatException("Invalid path: " + value);
                     }
-                    pv = PropertyStates.pathProperty("", oakValue);
+                    pv = GenericPropertyState.pathProperty("", oakValue);
                     break;
                 case PropertyType.REFERENCE:
                     if (!IdentifierManager.isValidUUID(value)) {
                         throw new ValueFormatException("Invalid reference value " + value);
                     }
-                    pv = PropertyStates.referenceProperty("", value);
+                    pv = GenericPropertyState.referenceProperty("", value);
                     break;
                 case PropertyType.WEAKREFERENCE:
                     if (!IdentifierManager.isValidUUID(value)) {
                         throw new ValueFormatException("Invalid weak reference value " + value);
                     }
-                    pv = PropertyStates.weakreferenceProperty("", value);
+                    pv = GenericPropertyState.weakreferenceProperty("", value);
                     break;
                 case PropertyType.URI:
                     new URI(value);
-                    pv = PropertyStates.uriProperty("", value);
+                    pv = GenericPropertyState.uriProperty("", value);
                     break;
                 case PropertyType.DECIMAL:
                     return createValue(Conversions.convert(value).toDecimal());
@@ -260,7 +266,7 @@ public class ValueFactoryImpl implements ValueFactory {
 
     private ValueImpl createBinaryValue(InputStream value) throws IOException {
         Blob blob = contentSession.createBlob(value);
-        return new ValueImpl(PropertyStates.binaryProperty("", blob), namePathMapper);
+        return new ValueImpl(BinaryPropertyState.binaryProperty("", blob), namePathMapper);
     }
 
     //------------------------------------------------------------< ErrorValue >---
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java
index e39f4e8f1f..da8f6a4ec6 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java
@@ -30,7 +30,14 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
-import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
+import org.apache.jackrabbit.oak.plugins.memory.BinaryPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.BooleanPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.DecimalPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.DoublePropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.GenericPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.LongPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.MultiStringPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.StringPropertyState;
 
 /**
  * Utility class for creating {@link PropertyValue} instances.
@@ -61,69 +68,67 @@ public final class PropertyValues {
 
     @Nonnull
     public static PropertyValue newString(String value) {
-        return new PropertyStateValue(PropertyStates.stringProperty("", value));
+        return new PropertyStateValue(StringPropertyState.stringProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newString(Iterable<String> value) {
-        return new PropertyStateValue(PropertyStates.stringProperty("", value));
+        return new PropertyStateValue(MultiStringPropertyState.stringProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newLong(Long value) {
-        return new PropertyStateValue(PropertyStates.longProperty("", value));
+        return new PropertyStateValue(LongPropertyState.createLongProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newDouble(Double value) {
-        return new PropertyStateValue(PropertyStates.doubleProperty("", value));
+        return new PropertyStateValue(DoublePropertyState.doubleProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newDecimal(BigDecimal value) {
-        return new PropertyStateValue(PropertyStates.decimalProperty("", value));
+        return new PropertyStateValue(DecimalPropertyState.decimalProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newBoolean(boolean value) {
-        return new PropertyStateValue(PropertyStates.booleanProperty("", value));
+        return new PropertyStateValue(BooleanPropertyState.booleanProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newDate(String value) {
-        return new PropertyStateValue(PropertyStates.dateProperty("", value));
+        return new PropertyStateValue(LongPropertyState.createDateProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newName(String value) {
-        return new PropertyStateValue(PropertyStates.nameProperty("", value));
+        return new PropertyStateValue(GenericPropertyState.nameProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newPath(String value) {
-        return new PropertyStateValue(PropertyStates.pathProperty("", value));
+        return new PropertyStateValue(GenericPropertyState.pathProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newReference(String value) {
-        return new PropertyStateValue(PropertyStates.referenceProperty("",
-                value));
+        return new PropertyStateValue(GenericPropertyState.referenceProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newWeakReference(String value) {
-        return new PropertyStateValue(PropertyStates.weakreferenceProperty("",
-                value));
+        return new PropertyStateValue(GenericPropertyState.weakreferenceProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newUri(String value) {
-        return new PropertyStateValue(PropertyStates.uriProperty("", value));
+        return new PropertyStateValue(GenericPropertyState.uriProperty("", value));
     }
 
     @Nonnull
     public static PropertyValue newBinary(byte[] value) {
-        return new PropertyStateValue(PropertyStates.binaryProperty("", value));
+        return new PropertyStateValue(BinaryPropertyState.binaryProperty("", value));
     }
 
     // --
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/core/TreeImplTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/core/TreeImplTest.java
index 3bd655cad8..d3a3f36e9a 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/core/TreeImplTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/core/TreeImplTest.java
@@ -28,7 +28,7 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Tree.Status;
-import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
+import org.apache.jackrabbit.oak.plugins.memory.LongPropertyState;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -119,9 +119,9 @@ public class TreeImplTest {
         Tree tree = root.getTree("/");
 
         Set<PropertyState> expectedProperties = Sets.newHashSet(
-            PropertyStates.longProperty("a", 1),
-            PropertyStates.longProperty("b", 2),
-            PropertyStates.longProperty("c", 3));
+                LongPropertyState.createLongProperty("a", 1L),
+                LongPropertyState.createLongProperty("b", 2L),
+                LongPropertyState.createLongProperty("c", 3L));
 
         Iterable<? extends PropertyState> properties = tree.getProperties();
         for (PropertyState property : properties) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/kernel/JsopDiffTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/kernel/JsopDiffTest.java
index b3026c2d45..0a421ee25b 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/kernel/JsopDiffTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/kernel/JsopDiffTest.java
@@ -18,8 +18,11 @@ package org.apache.jackrabbit.oak.kernel;
 
 import com.google.common.collect.ImmutableMap;
 import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.BooleanPropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.DoublePropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.LongPropertyState;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeState;
-import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
+import org.apache.jackrabbit.oak.plugins.memory.StringPropertyState;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.junit.Test;
 
@@ -30,22 +33,22 @@ public class JsopDiffTest {
     @Test
     public void testPropertyChanges() {
         JsopDiff diff;
-        PropertyState before = PropertyStates.stringProperty("foo", "bar");
+        PropertyState before = StringPropertyState.stringProperty("foo", "bar");
 
         diff = new JsopDiff(null);
         diff.propertyAdded(before);
         assertEquals("^\"/foo\":\"bar\"", diff.toString());
 
         diff = new JsopDiff(null);
-        diff.propertyChanged(before, PropertyStates.longProperty("foo", 123L));
+        diff.propertyChanged(before, LongPropertyState.createLongProperty("foo", 123L));
         assertEquals("^\"/foo\":123", diff.toString());
 
         diff = new JsopDiff(null);
-        diff.propertyChanged(before, PropertyStates.doubleProperty("foo", 1.23));
+        diff.propertyChanged(before, DoublePropertyState.doubleProperty("foo", 1.23));
         assertEquals("^\"/foo\":\"dou:1.23\"", diff.toString()); // TODO: 1.23?
 
         diff = new JsopDiff(null);
-        diff.propertyChanged(before, PropertyStates.booleanProperty("foo", true));
+        diff.propertyChanged(before, BooleanPropertyState.booleanProperty("foo", true));
         assertEquals("^\"/foo\":true", diff.toString());
 
         diff = new JsopDiff(null);
@@ -59,7 +62,7 @@ public class JsopDiffTest {
         NodeState before = MemoryNodeState.EMPTY_NODE;
         NodeState after = new MemoryNodeState(
                 ImmutableMap.<String, PropertyState>of(
-                        "a", PropertyStates.longProperty("a", 1L)),
+                        "a", LongPropertyState.createLongProperty("a", 1L)),
                 ImmutableMap.of(
                         "x", MemoryNodeState.EMPTY_NODE));
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilderTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilderTest.java
index 50966c73ae..e31e497005 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilderTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryNodeBuilderTest.java
@@ -34,9 +34,9 @@ public class MemoryNodeBuilderTest {
 
     private static final NodeState BASE = new MemoryNodeState(
             ImmutableMap.<String, PropertyState>of(
-                    "a", PropertyStates.longProperty("a", 1L),
-                    "b", PropertyStates.longProperty("b", 2L),
-                    "c", PropertyStates.longProperty("c", 3L)),
+                    "a", LongPropertyState.createLongProperty("a", 1L),
+                    "b", LongPropertyState.createLongProperty("b", 2L),
+                    "c", LongPropertyState.createLongProperty("c", 3L)),
             ImmutableMap.of(
                     "x", MemoryNodeState.EMPTY_NODE,
                     "y", MemoryNodeState.EMPTY_NODE,
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilderTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilderTest.java
index 18602a0566..e259387062 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilderTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/memory/MemoryPropertyBuilderTest.java
@@ -31,10 +31,10 @@ public class MemoryPropertyBuilderTest {
     public void testStringProperty() {
         PropertyBuilder<String> builder = MemoryPropertyBuilder.create(Type.STRING);
         builder.setName("foo").setValue("bar");
-        assertEquals(PropertyStates.stringProperty("foo", "bar"),
+        assertEquals(StringPropertyState.stringProperty("foo", "bar"),
                 builder.getPropertyState());
 
-        assertEquals(PropertyStates.stringProperty("foo", Arrays.asList("bar")),
+        assertEquals(MultiStringPropertyState.stringProperty("foo", Arrays.asList("bar")),
                 builder.getPropertyState(true));
     }
 
@@ -42,10 +42,10 @@ public class MemoryPropertyBuilderTest {
     public void testLongProperty() {
         PropertyBuilder<Long> builder = MemoryPropertyBuilder.create(Type.LONG);
         builder.setName("foo").setValue(42L);
-        assertEquals(PropertyStates.longProperty("foo", 42L),
+        assertEquals(LongPropertyState.createLongProperty("foo", 42L),
                 builder.getPropertyState());
 
-        assertEquals(PropertyStates.longProperty("foo", Arrays.asList(42L)),
+        assertEquals(MultiLongPropertyState.createLongProperty("foo", Arrays.asList(42L)),
                 builder.getPropertyState(true));
     }
 
@@ -55,56 +55,56 @@ public class MemoryPropertyBuilderTest {
         builder.setName("foo")
                 .addValue("one")
                 .addValue("two");
-        assertEquals(PropertyStates.stringProperty("foo", Arrays.asList("one", "two")),
+        assertEquals(MultiStringPropertyState.stringProperty("foo", Arrays.asList("one", "two")),
                 builder.getPropertyState());
     }
 
     @Test
     public void testAssignFromLong() {
-        PropertyState source = PropertyStates.longProperty("foo", 42);
+        PropertyState source = LongPropertyState.createLongProperty("foo", 42L);
         PropertyBuilder<String> builder = MemoryPropertyBuilder.create(Type.STRING);
         builder.assignFrom(source);
-        assertEquals(PropertyStates.stringProperty("foo", "42"),
+        assertEquals(StringPropertyState.stringProperty("foo", "42"),
                 builder.getPropertyState());
     }
 
     @Test
     public void testAssignFromString() {
-        PropertyState source = PropertyStates.stringProperty("foo", "42");
+        PropertyState source = StringPropertyState.stringProperty("foo", "42");
         PropertyBuilder<Long> builder = MemoryPropertyBuilder.create(Type.LONG);
         builder.assignFrom(source);
-        assertEquals(PropertyStates.longProperty("foo", 42),
+        assertEquals(LongPropertyState.createLongProperty("foo", 42L),
                 builder.getPropertyState());
     }
 
     @Test(expected = NumberFormatException.class)
     public void testAssignFromStringNumberFormatException() {
-        PropertyState source = PropertyStates.stringProperty("foo", "bar");
+        PropertyState source = StringPropertyState.stringProperty("foo", "bar");
         PropertyBuilder<Long> builder = MemoryPropertyBuilder.create(Type.LONG);
         builder.assignFrom(source);
     }
 
     @Test
     public void testAssignFromLongs() {
-        PropertyState source = PropertyStates.longProperty("foo", Arrays.asList(1L, 2L, 3L));
+        PropertyState source = MultiLongPropertyState.createLongProperty("foo", Arrays.asList(1L, 2L, 3L));
         PropertyBuilder<String> builder = MemoryPropertyBuilder.create(Type.STRING);
         builder.assignFrom(source);
-        assertEquals(PropertyStates.stringProperty("foo", Arrays.asList("1", "2", "3")),
+        assertEquals(MultiStringPropertyState.stringProperty("foo", Arrays.asList("1", "2", "3")),
                 builder.getPropertyState());
     }
 
     @Test
     public void testAssignFromStrings() {
-        PropertyState source = PropertyStates.stringProperty("foo", Arrays.asList("1", "2", "3"));
+        PropertyState source = MultiStringPropertyState.stringProperty("foo", Arrays.asList("1", "2", "3"));
         PropertyBuilder<Long> builder = MemoryPropertyBuilder.create(Type.LONG);
         builder.assignFrom(source);
-        assertEquals(PropertyStates.longProperty("foo", Arrays.asList(1L, 2L, 3L)),
+        assertEquals(MultiLongPropertyState.createLongProperty("foo", Arrays.asList(1L, 2L, 3L)),
                 builder.getPropertyState());
     }
 
     @Test
     public void testAssignInvariant() {
-        PropertyState source = PropertyStates.stringProperty("source", Arrays.asList("1", "2", "3"));
+        PropertyState source = MultiStringPropertyState.stringProperty("source", Arrays.asList("1", "2", "3"));
         PropertyBuilder<String> builder = MemoryPropertyBuilder.create(Type.STRING);
         builder.assignFrom(source);
         assertEquals(source, builder.getPropertyState(true));
