diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java
index 4add07ba76..7a18b4ef22 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java
@@ -38,6 +38,8 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
 import com.google.common.base.Charsets;
 import com.google.common.collect.Sets;
 
+import static org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute;
+
 /**
  * Provides a QueryIndex that does lookups against a property index
  * 
@@ -168,7 +170,7 @@ public class PropertyIndex implements QueryIndex {
         @Override
         public IndexRow currentRow() {
             // TODO support jcr:score and possibly rep:exceprt
-            return new IndexRowImpl(path);
+            return new IndexRowImpl(isAbsolute(path) ? path : "/" + path);
         }
 
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexHook.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexHook.java
index fb705885e6..33b7e45e1f 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexHook.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexHook.java
@@ -57,7 +57,7 @@ public class PropertyIndexHook implements IndexHook {
             }
         }
 
-        return after;
+        return builder.getNodeState();
     }
 
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java
index 62d1c7ce3b..5ab840d5a3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java
@@ -20,6 +20,8 @@ import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFIN
 
 import java.util.Set;
 
+import javax.annotation.Nullable;
+
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.api.Type;
@@ -63,12 +65,8 @@ public class PropertyIndexLookup {
      * @param path lookup path
      */
     public boolean isIndexed(String name, String path) {
-        NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);
-        if (state != null) {
-            state = state.getChildNode(name);
-            if (state != null) {
-                return true;
-            }
+        if (getIndexDefinitionNode(name) != null) {
+            return true;
         }
 
         if (path.startsWith("/")) {
@@ -109,30 +107,36 @@ public class PropertyIndexLookup {
     public Set<String> find(String name, PropertyValue value) {
         Set<String> paths = Sets.newHashSet();
 
-        PropertyState property = null;
-        NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);
-        if (state != null) {
-            state = state.getChildNode(name);
-            if (state != null) {
-                state = state.getChildNode(":index");
-                if (state != null) {
-                    //TODO what happens when I search using an mvp?
-                    property = state.getProperty(PropertyIndex.encode(value).get(0));
+        PropertyState property;
+        NodeState state = getIndexDefinitionNode(name);
+        if (state != null && state.getChildNode(":index") != null) {
+            state = state.getChildNode(":index");
+            for (String p : PropertyIndex.encode(value)) {
+                property = state.getProperty(p);
+                if (property != null) {
+                    // We have an entry for this value, so use it
+                    for (String path : property.getValue(Type.STRINGS)) {
+                        paths.add(path);
+                    }
                 }
             }
-        }
-
-        if (property != null) {
-            // We have an index for this property, so use it
-            for (String path : property.getValue(Type.STRINGS)) {
-                paths.add(path);
-            }
         } else {
             // No index available, so first check this node for a match
             property = root.getProperty(name);
-            if (property != null){
-                if(PropertyValues.match(property, value)){
+            if (property != null) {
+                if (value.isArray()) {
+                    // let query engine handle multi-valued look ups
+                    // simply return all nodes that have this property
                     paths.add("");
+                } else {
+                    // does it match any of the values of this property?
+                    for (int i = 0; i < property.count(); i++) {
+                        if (property.getValue(value.getType(), i).equals(value.getValue(value.getType()))) {
+                            paths.add("");
+                            // no need to check for more matches in this property
+                            break;
+                        }
+                    }
                 }
             }
 
@@ -154,4 +158,22 @@ public class PropertyIndexLookup {
         return paths;
     }
 
+    @Nullable
+    private NodeState getIndexDefinitionNode(String name) {
+        NodeState state = root.getChildNode(INDEX_DEFINITIONS_NAME);
+        if (state != null) {
+            for (ChildNodeEntry entry : state.getChildNodeEntries()) {
+                PropertyState names = entry.getNodeState().getProperty("propertyNames");
+                if (names != null) {
+                    for (int i = 0; i < names.count(); i++) {
+                        if (name.equals(names.getValue(Type.STRING, i))) {
+                            return entry.getNodeState();
+                        }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
 }
\ No newline at end of file
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/InitialContent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/InitialContent.java
index 7fdf8d12d8..94de60b480 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/InitialContent.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/InitialContent.java
@@ -93,9 +93,12 @@ public class InitialContent implements RepositoryInitializer {
                 .setProperty("jcr:primaryType", "oak:queryIndexDefinition", Type.NAME)
                 .setProperty("type", "property")
                 .setProperty("propertyNames", "jcr:uuid")
+                .setProperty("reindex", true)
                 .setProperty("unique", true);
             index.child("primaryType")
                 .setProperty("jcr:primaryType", "oak:queryIndexDefinition", Type.NAME)
+                .setProperty("type", "property")
+                .setProperty("reindex", true)
                 .setProperty("propertyNames", "jcr:primaryType");
             // FIXME: user-mgt related unique properties (rep:authorizableId, rep:principalName) are implementation detail and not generic for repo
             // FIXME OAK-396: rep:principalName only needs to be unique if defined with user/group nodes -> add defining nt-info to uniqueness constraint otherwise ac-editing will fail.
@@ -103,11 +106,13 @@ public class InitialContent implements RepositoryInitializer {
                 .setProperty("jcr:primaryType", "oak:queryIndexDefinition", Type.NAME)
                 .setProperty("type", "property")
                 .setProperty("propertyNames", "rep:authorizableId")
+                .setProperty("reindex", true)
                 .setProperty("unique", true);
             index.child("principalName")
                 .setProperty("jcr:primaryType", "oak:queryIndexDefinition", Type.NAME)
                 .setProperty("type", "property")
                 .setProperty("propertyNames", "rep:principalName")
+                .setProperty("reindex", true)
                 .setProperty("unique", true);
         }
         try {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
index eedecfa122..d4a06cc497 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
@@ -37,7 +37,9 @@ public class PropertyIndexTest {
 
         // Add index definition
         NodeBuilder builder = root.builder();
-        builder.child("oak:index").child("foo");
+        builder.child("oak:index").child("foo")
+                .setProperty("jcr:primaryType", "oak:queryIndexDefinition", Type.NAME)
+                .setProperty("propertyNames", "foo");
         NodeState before = builder.getNodeState();
 
         // Add some content and process it through the property index hook
