diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/PropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/PropertyState.java
index 1ca0305ada..5ac32505de 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/PropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/PropertyState.java
@@ -17,6 +17,9 @@
 package org.apache.jackrabbit.oak.api;
 
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+import com.google.common.base.Function;
 
 /**
  * Immutable property state. A property consists of a name and a value.
@@ -116,4 +119,19 @@ public interface PropertyState {
      */
     int count();
 
+    /**
+     * Mapping from a PropertyState instance to its name.
+     */
+    Function<PropertyState, String> GET_NAME =
+            new Function<PropertyState, String>() {
+                @Override @Nullable
+                public String apply(@Nullable PropertyState input) {
+                    if (input != null) {
+                        return input.getName();
+                    } else {
+                        return null;
+                    }
+                }
+            };
+
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java
index c31adb853b..33c31c9e2e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java
@@ -17,16 +17,20 @@
 package org.apache.jackrabbit.oak.plugins.memory;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Predicates.notNull;
 import static com.google.common.collect.Collections2.filter;
 import static com.google.common.collect.Iterables.concat;
 import static com.google.common.collect.Iterables.filter;
 import static com.google.common.collect.Maps.filterValues;
+import static com.google.common.collect.Maps.newHashMap;
 import static java.util.Collections.emptyList;
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;
 import static org.apache.jackrabbit.oak.plugins.memory.MemoryChildNodeEntry.iterable;
 
 import java.util.Map;
+import java.util.Map.Entry;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -39,6 +43,7 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;
 
 import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 
@@ -47,12 +52,59 @@ import com.google.common.collect.Maps;
  */
 public class ModifiedNodeState extends AbstractNodeState {
 
-    static NodeState withProperties(
-            NodeState base, Map<String, ? extends PropertyState> properties) {
-        if (properties.isEmpty()) {
-            return base;
+    static long getPropertyCount(
+            NodeState base, Map<String, PropertyState> properties) {
+        long count = 0;
+        if (base.exists()) {
+            count = base.getPropertyCount();
+            for (Entry<String, PropertyState> entry : properties.entrySet()) {
+                if (base.hasProperty(entry.getKey())) {
+                    count--;
+                }
+                if (entry.getValue() != null) {
+                    count++;
+                }
+            }
+        }
+        return count;
+    }
+
+    static boolean hasProperty(
+            NodeState base, Map<String, PropertyState> properties,
+            String name) {
+        if (properties.containsKey(name)) {
+            return properties.get(name) != null;
         } else {
-            return new ModifiedNodeState(base, properties, ImmutableMap.<String, NodeState>of());
+            return base.hasProperty(name);
+        }
+    }
+
+    static PropertyState getProperty(
+            NodeState base, Map<String, PropertyState> properties,
+            String name) {
+        PropertyState property = properties.get(name);
+        if (property == null && !properties.containsKey(name)) {
+            property = base.getProperty(name);
+        }
+        return property;
+    }
+
+    static Iterable<? extends PropertyState> getProperties(
+            NodeState base, Map<String, PropertyState> properties,
+            boolean copy) {
+        if (!base.exists()) {
+            return emptyList();
+        } else if (properties.isEmpty()) {
+            return base.getProperties(); // shortcut
+        } else {
+            if (copy) {
+                properties = newHashMap(properties);
+            }
+            Predicate<PropertyState> predicate = Predicates.compose(
+                    not(in(properties.keySet())), PropertyState.GET_NAME);
+            return concat(
+                    filter(base.getProperties(), predicate),
+                    filter(properties.values(), notNull()));
         }
     }
 
@@ -67,7 +119,7 @@ public class ModifiedNodeState extends AbstractNodeState {
 
     static NodeState with(
             NodeState base,
-            Map<String, ? extends PropertyState> properties,
+            Map<String, PropertyState> properties,
             Map<String, ? extends NodeState> nodes) {
         if (properties.isEmpty() && nodes.isEmpty()) {
             return base;
@@ -103,7 +155,7 @@ public class ModifiedNodeState extends AbstractNodeState {
      * Set of added, modified or removed ({@code null} value)
      * property states.
      */
-    private final Map<String, ? extends PropertyState> properties;
+    private final Map<String, PropertyState> properties;
 
     /**
      * Set of added, modified or removed ({@code null} value)
@@ -111,13 +163,6 @@ public class ModifiedNodeState extends AbstractNodeState {
      */
     private final Map<String, ? extends NodeState> nodes;
 
-    private final Predicate<PropertyState> unmodifiedProperties = new Predicate<PropertyState>() {
-        @Override
-        public boolean apply(PropertyState input) {
-            return !properties.containsKey(input.getName());
-        }
-    };
-
     private final Predicate<ChildNodeEntry> unmodifiedNodes = new Predicate<ChildNodeEntry>() {
         @Override
         public boolean apply(ChildNodeEntry input) {
@@ -134,7 +179,7 @@ public class ModifiedNodeState extends AbstractNodeState {
 
     private ModifiedNodeState(
             @Nonnull NodeState base,
-            @Nonnull Map<String, ? extends PropertyState> properties,
+            @Nonnull Map<String, PropertyState> properties,
             @Nonnull Map<String, ? extends NodeState> nodes) {
         this.base = checkNotNull(base);
         this.properties = checkNotNull(properties);
@@ -160,47 +205,22 @@ public class ModifiedNodeState extends AbstractNodeState {
 
     @Override
     public long getPropertyCount() {
-        if (!exists()) {
-            return 0;
-        }
-        long count = base.getPropertyCount();
-
-        for (Map.Entry<String, ? extends PropertyState> entry : properties.entrySet()) {
-            if (base.hasProperty(entry.getKey())) {
-                count--;
-            }
-            if (entry.getValue() != null) {
-                count++;
-            }
-        }
+        return getPropertyCount(base, properties);
+    }
 
-        return count;
+    @Override
+    public boolean hasProperty(String name) {
+        return hasProperty(base, properties, name);
     }
 
     @Override
     public PropertyState getProperty(String name) {
-        PropertyState property = properties.get(name);
-        if (property != null) {
-            return property;
-        } else if (properties.containsKey(name)) {
-            return null; // removed
-        } else {
-            return base.getProperty(name);
-        }
+        return getProperty(base, properties, name);
     }
 
     @Override
     public Iterable<? extends PropertyState> getProperties() {
-        if (!exists()) {
-            return emptyList();
-        }
-        if (properties.isEmpty()) {
-            return base.getProperties(); // shortcut
-        } else {
-            return concat(
-                    filter(base.getProperties(), unmodifiedProperties),
-                    filter(properties.values(), notNull()));
-        }
+        return getProperties(base, properties, false);
     }
 
     @Override
@@ -378,4 +398,4 @@ public class ModifiedNodeState extends AbstractNodeState {
         }
     }
 
-}
\ No newline at end of file
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java
index ce61aec1db..81d5d33166 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java
@@ -25,7 +25,6 @@ import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;
 import static org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.with;
 import static org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.withNodes;
-import static org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.withProperties;
 
 import java.util.Iterator;
 import java.util.Map;
@@ -376,27 +375,22 @@ class MutableNodeState extends AbstractNodeState {
 
     @Override
     public long getPropertyCount() {
-        assert base != null;
-        return withProperties(base, properties).getPropertyCount();
+        return ModifiedNodeState.getPropertyCount(base, properties);
     }
 
     @Override
     public boolean hasProperty(String name) {
-        assert base != null;
-        return withProperties(base, properties).hasProperty(name);
+        return ModifiedNodeState.hasProperty(base, properties, name);
     }
 
     @Override
     public PropertyState getProperty(String name) {
-        assert base != null;
-        return withProperties(base, properties).getProperty(name);
+        return ModifiedNodeState.getProperty(base, properties, name);
     }
 
     @Override @Nonnull
     public Iterable<? extends PropertyState> getProperties() {
-        assert base != null;
-        Map<String, PropertyState> copy = newHashMap(properties);
-        return withProperties(base, copy).getProperties();
+        return ModifiedNodeState.getProperties(base, properties, true);
     }
 
     @Override
