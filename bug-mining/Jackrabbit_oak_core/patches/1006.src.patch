diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentNodeBuilder.java
new file mode 100644
index 0000000000..79b92dfcdd
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentNodeBuilder.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document;
+
+import javax.annotation.Nonnull;
+
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilder;
+import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+
+import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;
+import static org.apache.jackrabbit.oak.spi.state.AbstractNodeState.checkValidName;
+
+/**
+ * Abstract base class for {@link DocumentRootBuilder} and
+ * {@link DocumentNodeBuilder}.
+ */
+abstract class AbstractDocumentNodeBuilder extends MemoryNodeBuilder {
+
+    public AbstractDocumentNodeBuilder(@Nonnull NodeState base) {
+        super(base);
+    }
+
+    protected AbstractDocumentNodeBuilder(MemoryNodeBuilder parent,
+                                          String name) {
+        super(parent, name);
+    }
+
+    /**
+     * Sets the named subtree to the given state. To avoid running out
+     * of memory with large change-sets, the implementation recursively
+     * copies all properties and child nodes to this builder so that the
+     * purge mechanism has a chance to periodically flush partial changes
+     * to the underlying storage database.
+     *
+     * See also: OAK-1768
+     */
+    @Override
+    @Nonnull
+    public NodeBuilder setChildNode(String name, NodeState state) {
+        NodeBuilder builder = super.setChildNode(name, EMPTY_NODE);
+        for (PropertyState property : state.getProperties()) {
+            builder.setProperty(property);
+        }
+        for (ChildNodeEntry child : state.getChildNodeEntries()) {
+            builder.setChildNode(child.getName(), child.getNodeState());
+        }
+        return builder;
+    }
+
+    @Override
+    protected abstract DocumentNodeBuilder createChildBuilder(String name);
+
+    @Override
+    @Nonnull
+    public DocumentNodeBuilder getChildNode(String name) {
+        checkValidName(name);
+        return createChildBuilder(name);
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeBuilder.java
index 32bfc8f29b..06f740f401 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeBuilder.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeBuilder.java
@@ -33,7 +33,7 @@ import static org.apache.jackrabbit.oak.spi.state.AbstractNodeState.checkValidNa
 /**
  * A node builder implementation for DocumentMK.
  */
-class DocumentNodeBuilder extends MemoryNodeBuilder {
+class DocumentNodeBuilder extends AbstractDocumentNodeBuilder {
 
     private final DocumentRootBuilder root;
 
@@ -112,10 +112,21 @@ class DocumentNodeBuilder extends MemoryNodeBuilder {
         return root.createBlob(stream);
     }
 
-    private static void removeRecursive(NodeBuilder builder) {
+    @Override
+    public boolean remove() {
+        return removeRecursive(this);
+    }
+
+    //---------------------< internal >-----------------------------------------
+
+    private boolean removeInternal() {
+        return super.remove();
+    }
+
+    private static boolean removeRecursive(DocumentNodeBuilder builder) {
         for (String name : builder.getChildNodeNames()) {
             removeRecursive(builder.getChildNode(name));
         }
-        builder.remove();
+        return builder.removeInternal();
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentRootBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentRootBuilder.java
index 58b8f8a2e1..a80043207b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentRootBuilder.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentRootBuilder.java
@@ -35,7 +35,7 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
  * This implementation tracks the number of pending changes and purges them to
  * a private branch of the underlying store if a certain threshold is met.
  */
-class DocumentRootBuilder extends MemoryNodeBuilder {
+class DocumentRootBuilder extends AbstractDocumentNodeBuilder {
 
     /**
      * Number of content updates that need to happen before the updates
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/LargeTreeOperationTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/LargeTreeOperationTest.java
new file mode 100644
index 0000000000..7f82733507
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/LargeTreeOperationTest.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document;
+
+import org.apache.jackrabbit.oak.api.CommitFailedException;
+import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;
+import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
+import org.apache.jackrabbit.oak.spi.commit.EmptyHook;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests for OAK-1768.
+ */
+public class LargeTreeOperationTest {
+
+    @Test
+    public void removeLargeSubtree() throws CommitFailedException {
+        DocumentNodeStore ns = new DocumentMK.Builder()
+                .setUseSimpleRevision(true).getNodeStore();
+
+        NodeBuilder builder = ns.getRoot().builder();
+        NodeBuilder test = builder.child("test");
+        for (int i = 0; i < DocumentRootBuilder.UPDATE_LIMIT * 3; i++) {
+            test.child("child-" + i);
+        }
+        ns.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        builder = ns.getRoot().builder();
+        Revision r1 = ns.newRevision();
+        // must trigger branch commit
+        builder.getChildNode("test").remove();
+        Revision r2 = ns.newRevision();
+
+        assertTrue("remove of large subtree must trigger branch commits",
+                r2.getTimestamp() - r1.getTimestamp() > 1);
+
+        ns.dispose();
+    }
+
+    @Test
+    public void setLargeSubtreeOnRoot() throws CommitFailedException {
+        setLargeSubtree(new String[0]);
+    }
+
+    @Test
+    public void setLargeSubtree() throws CommitFailedException {
+        setLargeSubtree("child");
+    }
+
+    private void setLargeSubtree(String... path) throws CommitFailedException {
+        MemoryNodeStore memStore = new MemoryNodeStore();
+        NodeBuilder builder = memStore.getRoot().builder();
+        NodeBuilder test = builder.child("test");
+        for (int i = 0; i < DocumentRootBuilder.UPDATE_LIMIT * 3; i++) {
+            test.child("child-" + i);
+        }
+        memStore.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        DocumentNodeStore ns = new DocumentMK.Builder()
+                .setUseSimpleRevision(true).getNodeStore();
+
+        builder = ns.getRoot().builder();
+        for (String name : path) {
+            builder = builder.child(name);
+        }
+        Revision r1 = ns.newRevision();
+        // must trigger branch commit
+        builder.setChildNode("test", memStore.getRoot().getChildNode("test"));
+        Revision r2 = ns.newRevision();
+
+        assertTrue("setting a large subtree must trigger branch commits",
+                r2.getTimestamp() - r1.getTimestamp() > 1);
+
+        ns.dispose();
+    }
+}
