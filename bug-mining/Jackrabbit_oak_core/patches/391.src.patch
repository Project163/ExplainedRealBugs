diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java
index f735519c5d..2f08ea7d15 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java
@@ -22,7 +22,6 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.List;
-import java.util.Map;
 import java.util.UUID;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
@@ -181,11 +180,11 @@ public class ClusterNodeInfo {
     private static ClusterNodeInfo createInstance(DocumentStore store, String machineId, String instanceId) {
         long now = System.currentTimeMillis();
         // keys between "0" and "a" includes all possible numbers
-        List<Map<String, Object>> list = store.query(DocumentStore.Collection.CLUSTER_NODES,
+        List<Document> list = store.query(DocumentStore.Collection.CLUSTER_NODES,
                 "0", "a", Integer.MAX_VALUE);
         int clusterNodeId = 0;
         int maxId = 0;
-        for (Map<String, Object> doc : list) {
+        for (Document doc : list) {
             String key = "" + doc.get(ID_KEY);
             int id;
             try {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Document.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Document.java
new file mode 100644
index 0000000000..d59c7969b7
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Document.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.mongomk;
+
+import java.util.TreeMap;
+
+/**
+ * A document corresponds to a node stored in the MongoMK. A document contains
+ * all the revisions of a node stored in the {@link DocumentStore}.
+ */
+public class Document extends TreeMap<String, Object> {
+
+    private static final long serialVersionUID = -2428664083360273697L;
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java
index 732b77af38..cb11b866db 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java
@@ -69,30 +69,30 @@ public interface DocumentStore {
     /**
      * Get a document.
      * <p>
-     * The returned map is a clone (the caller can modify it without affecting
+     * The returned document is a clone (the caller can modify it without affecting
      * the stored version).
      * 
      * @param collection the collection
      * @param key the key
-     * @return the map, or null if not found
+     * @return the document, or null if not found
      */
     @CheckForNull
-    Map<String, Object> find(Collection collection, String key);
+    Document find(Collection collection, String key);
     
     /**
      * Get a document, ignoring the cache if the cached entry is older than the
      * specified time.
      * <p>
-     * The returned map is a clone (the caller can modify it without affecting
+     * The returned document is a clone (the caller can modify it without affecting
      * the stored version).
      * 
      * @param collection the collection
      * @param key the key
      * @param maxCacheAge the maximum age of the cached document
-     * @return the map, or null if not found
+     * @return the document, or null if not found
      */
     @CheckForNull
-    Map<String, Object> find(Collection collection, String key, int maxCacheAge);
+    Document find(Collection collection, String key, int maxCacheAge);
 
     /**
      * Get a list of documents where the key is greater than a start value and
@@ -105,8 +105,10 @@ public interface DocumentStore {
      * @return the list (possibly empty)
      */
     @Nonnull
-    List<Map<String, Object>> query(Collection collection, String fromKey, 
-            String toKey, int limit);
+    List<Document> query(Collection collection,
+                         String fromKey,
+                         String toKey,
+                         int limit);
     
     /**
      * Get a list of documents where the key is greater than a start value and
@@ -121,8 +123,12 @@ public interface DocumentStore {
      * @return the list (possibly empty)
      */
     @Nonnull
-    List<Map<String, Object>> query(Collection collection, String fromKey,
-            String toKey, String indexedProperty, long startValue, int limit);
+    List<Document> query(Collection collection,
+                         String fromKey,
+                         String toKey,
+                         String indexedProperty,
+                         long startValue,
+                         int limit);
 
     /**
      * Remove a document.
@@ -151,7 +157,7 @@ public interface DocumentStore {
      * @throws MicroKernelException if the operation failed.
      */    
     @Nonnull
-    Map<String, Object> createOrUpdate(Collection collection, UpdateOp update)
+    Document createOrUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException;
 
     /**
@@ -159,13 +165,14 @@ public interface DocumentStore {
      * {@link UpdateOp.Operation.Type#CONTAINS_MAP_ENTRY} and only updates the
      * document if the condition is <code>true</code>.
      *
+     *
      * @param collection the collection
      * @param update the update operation with the condition
      * @return the old document or <code>null</code> if the condition is not met.
      * @throws MicroKernelException if the operation failed.
      */
     @CheckForNull
-    Map<String, Object> findAndUpdate(Collection collection, UpdateOp update)
+    Document findAndUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException;
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java
index 82f4d20d24..ca38a43cf3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java
@@ -39,57 +39,64 @@ public class MemoryDocumentStore implements DocumentStore {
     /**
      * The 'nodes' collection.
      */
-    private ConcurrentSkipListMap<String, Map<String, Object>> nodes =
-            new ConcurrentSkipListMap<String, Map<String, Object>>();
+    private ConcurrentSkipListMap<String, Document> nodes =
+            new ConcurrentSkipListMap<String, Document>();
     
     /**
      * The 'clusterNodes' collection.
      */
-    private ConcurrentSkipListMap<String, Map<String, Object>> clusterNodes =
-            new ConcurrentSkipListMap<String, Map<String, Object>>();
+    private ConcurrentSkipListMap<String, Document> clusterNodes =
+            new ConcurrentSkipListMap<String, Document>();
 
     @Override
-    public Map<String, Object> find(Collection collection, String key, int maxCacheAge) {
+    public Document find(Collection collection, String key, int maxCacheAge) {
         return find(collection, key);
     }
     
     @Override
-    public Map<String, Object> find(Collection collection, String key) {
-        ConcurrentSkipListMap<String, Map<String, Object>> map = getMap(collection);
-        Map<String, Object> n = map.get(key);
-        if (n == null) {
+    public Document find(Collection collection, String key) {
+        ConcurrentSkipListMap<String, Document> map = getMap(collection);
+        Document doc = map.get(key);
+        if (doc == null) {
             return null;
         }
-        Map<String, Object> copy = Utils.newMap();
-        synchronized (n) {
-            Utils.deepCopyMap(n, copy);
+        Document copy = Utils.newDocument();
+        synchronized (doc) {
+            Utils.deepCopyMap(doc, copy);
         }
         return copy;
     }
     
     @Override
     @Nonnull
-    public List<Map<String, Object>> query(Collection collection, String fromKey, String toKey, int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                int limit) {
         return query(collection, fromKey, toKey, null, 0, limit);
     }
     
     @Override
     @Nonnull
-    public List<Map<String, Object>> query(Collection collection, String fromKey,
-            String toKey, String indexedProperty, long startValue, int limit) {
-        ConcurrentSkipListMap<String, Map<String, Object>> map = getMap(collection);
-        ConcurrentNavigableMap<String, Map<String, Object>> sub = map.subMap(fromKey, toKey);
-        ArrayList<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
-        for (Map<String, Object> n : sub.values()) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                String indexedProperty,
+                                long startValue,
+                                int limit) {
+        ConcurrentSkipListMap<String, Document> map = getMap(collection);
+        ConcurrentNavigableMap<String, Document> sub = map.subMap(fromKey, toKey);
+        ArrayList<Document> list = new ArrayList<Document>();
+        for (Document doc : sub.values()) {
             if (indexedProperty != null) {
-                Long value = (Long) n.get(indexedProperty);
+                Long value = (Long) doc.get(indexedProperty);
                 if (value < startValue) {
                     continue;
                 }
             }
-            Map<String, Object> copy = Utils.newMap();
-            synchronized (n) {
-                Utils.deepCopyMap(n, copy);
+            Document copy = Utils.newDocument();
+            synchronized (doc) {
+                Utils.deepCopyMap(doc, copy);
             }
             list.add(copy);
             if (list.size() >= limit) {
@@ -110,7 +117,7 @@ public class MemoryDocumentStore implements DocumentStore {
      * @param collection the collection
      * @return the map
      */
-    private ConcurrentSkipListMap<String, Map<String, Object>> getMap(Collection collection) {
+    private ConcurrentSkipListMap<String, Document> getMap(Collection collection) {
         switch (collection) {
         case NODES:
             return nodes;
@@ -122,58 +129,56 @@ public class MemoryDocumentStore implements DocumentStore {
     }
 
     @CheckForNull
-    private Map<String, Object> internalCreateOrUpdate(Collection collection,
+    private Document internalCreateOrUpdate(Collection collection,
                                                        UpdateOp update,
                                                        boolean checkConditions) {
-        ConcurrentSkipListMap<String, Map<String, Object>> map = getMap(collection);
-        Map<String, Object> n;
-        Map<String, Object> oldNode;
+        ConcurrentSkipListMap<String, Document> map = getMap(collection);
+        Document doc;
+        Document oldDoc;
 
         // get the node if it's there
-        oldNode = n = map.get(update.key);
+        oldDoc = doc = map.get(update.key);
 
-        if (n == null) {
+        if (doc == null) {
             if (!update.isNew) {
                 throw new MicroKernelException("Document does not exist: " + update.key);
             }
             // for a new node, add it (without synchronization)
-            n = Utils.newMap();
-            oldNode = map.putIfAbsent(update.key, n);
-            if (oldNode != null) {
+            doc = Utils.newDocument();
+            oldDoc = map.putIfAbsent(update.key, doc);
+            if (oldDoc != null) {
                 // somebody else added it at the same time
-                n = oldNode;
+                doc = oldDoc;
             }
         }
-        synchronized (n) {
-            if (checkConditions && !checkConditions(n, update)) {
+        synchronized (doc) {
+            if (checkConditions && !checkConditions(doc, update)) {
                 return null;
             }
-            if (oldNode != null) {
+            if (oldDoc != null) {
                 // clone the old node
                 // (document level operations are synchronized)
-                Map<String, Object> oldNode2 = Utils.newMap();
-                Utils.deepCopyMap(oldNode, oldNode2);
-                oldNode = oldNode2;
+                Document oldDoc2 = Utils.newDocument();
+                Utils.deepCopyMap(oldDoc, oldDoc2);
+                oldDoc = oldDoc2;
             }
             // to return the new document:
             // update the document
             // (document level operations are synchronized)
-            applyChanges(n, update);
+            applyChanges(doc, update);
         }
-        return oldNode;
+        return oldDoc;
     }
 
     @Nonnull
     @Override
-    public Map<String, Object> createOrUpdate(Collection collection,
-                                              UpdateOp update)
+    public Document createOrUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         return internalCreateOrUpdate(collection, update, false);
     }
 
     @Override
-    public Map<String, Object> findAndUpdate(Collection collection,
-                                             UpdateOp update)
+    public Document findAndUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         return internalCreateOrUpdate(collection, update, true);
     }
@@ -287,7 +292,7 @@ public class MemoryDocumentStore implements DocumentStore {
 
     @Override
     public boolean create(Collection collection, List<UpdateOp> updateOps) {
-        ConcurrentSkipListMap<String, Map<String, Object>> map = getMap(collection);
+        ConcurrentSkipListMap<String, Document> map = getMap(collection);
         for (UpdateOp op : updateOps) {
             if (map.containsKey(op.key)) {
                 return false;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java
index a5ca228d3f..1eab919ae1 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java
@@ -19,7 +19,6 @@ package org.apache.jackrabbit.oak.plugins.mongomk;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
@@ -122,12 +121,14 @@ public class MongoDocumentStore implements DocumentStore {
     }
 
     @Override
-    public Map<String, Object> find(Collection collection, String key) {
+    public Document find(Collection collection, String key) {
         return find(collection, key, Integer.MAX_VALUE);
     }
     
     @Override
-    public Map<String, Object> find(final Collection collection, final String key, int maxCacheAge) {
+    public Document find(final Collection collection,
+                         final String key,
+                         int maxCacheAge) {
         if (collection != Collection.NODES) {
             return findUncached(collection, key);
         }
@@ -140,8 +141,8 @@ public class MongoDocumentStore implements DocumentStore {
                 doc = nodesCache.get(key, new Callable<CachedDocument>() {
                     @Override
                     public CachedDocument call() throws Exception {
-                        Map<String, Object> map = findUncached(collection, key);
-                        return new CachedDocument(map);
+                        Document doc = findUncached(collection, key);
+                        return new CachedDocument(doc);
                     }
                 });
                 if (maxCacheAge == 0 || maxCacheAge == Integer.MAX_VALUE) {
@@ -159,7 +160,8 @@ public class MongoDocumentStore implements DocumentStore {
         }
     }
     
-    Map<String, Object> findUncached(Collection collection, String key) {
+    @CheckForNull
+    Document findUncached(Collection collection, String key) {
         DBCollection dbCollection = getDBCollection(collection);
         long start = start();
         try {
@@ -175,14 +177,21 @@ public class MongoDocumentStore implements DocumentStore {
     
     @Nonnull
     @Override
-    public List<Map<String, Object>> query(Collection collection,
-            String fromKey, String toKey, int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                int limit) {
         return query(collection, fromKey, toKey, null, 0, limit);
     }
-    
+
+    @Nonnull
     @Override
-    public List<Map<String, Object>> query(Collection collection,
-            String fromKey, String toKey, String indexedProperty, long startValue, int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                String indexedProperty,
+                                long startValue,
+                                int limit) {
         log("query", fromKey, toKey, limit);
         DBCollection dbCollection = getDBCollection(collection);
         QueryBuilder queryBuilder = QueryBuilder.start(UpdateOp.ID);
@@ -196,15 +205,15 @@ public class MongoDocumentStore implements DocumentStore {
         long start = start();
         try {
             DBCursor cursor = dbCollection.find(query);
-            List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
+            List<Document> list = new ArrayList<Document>();
             for (int i = 0; i < limit && cursor.hasNext(); i++) {
                 DBObject o = cursor.next();
-                Map<String, Object> map = convertFromDBObject(o);
+                Document doc = convertFromDBObject(o);
                 if (collection == Collection.NODES) {
-                    String key = (String) map.get(UpdateOp.ID);
-                    nodesCache.put(key, new CachedDocument(map));
+                    String key = (String) doc.get(UpdateOp.ID);
+                    nodesCache.put(key, new CachedDocument(doc));
                 }
-                list.add(map);
+                list.add(doc);
             }
             return list;
         } finally {
@@ -231,10 +240,10 @@ public class MongoDocumentStore implements DocumentStore {
     }
 
     @CheckForNull
-    private Map<String, Object> findAndModify(Collection collection,
-                                               UpdateOp updateOp,
-                                               boolean upsert,
-                                               boolean checkConditions) {
+    private Document findAndModify(Collection collection,
+                                   UpdateOp updateOp,
+                                   boolean upsert,
+                                   boolean checkConditions) {
         DBCollection dbCollection = getDBCollection(collection);
         QueryBuilder query = getByKeyQuery(updateOp.key);
 
@@ -305,18 +314,18 @@ public class MongoDocumentStore implements DocumentStore {
             if (checkConditions && oldNode == null) {
                 return null;
             }
-            Map<String, Object> map = convertFromDBObject(oldNode);
+            Document doc = convertFromDBObject(oldNode);
             
             // cache the new document
             if (collection == Collection.NODES) {
-                Map<String, Object> newMap = Utils.newMap();
-                Utils.deepCopyMap(map, newMap);
+                Document newDoc = Utils.newDocument();
+                Utils.deepCopyMap(doc, newDoc);
                 String key = updateOp.getKey();
-                MemoryDocumentStore.applyChanges(newMap, updateOp);
-                nodesCache.put(key, new CachedDocument(newMap));
+                MemoryDocumentStore.applyChanges(newDoc, updateOp);
+                nodesCache.put(key, new CachedDocument(newDoc));
             }
             
-            return map;
+            return doc;
         } catch (Exception e) {
             throw new MicroKernelException(e);
         } finally {
@@ -326,37 +335,35 @@ public class MongoDocumentStore implements DocumentStore {
 
     @Nonnull
     @Override
-    public Map<String, Object> createOrUpdate(Collection collection,
-                                              UpdateOp update)
+    public Document createOrUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         log("createOrUpdate", update);
-        Map<String, Object> map = findAndModify(collection, update, true, false);
-        log("createOrUpdate returns ", map);
-        return map;
+        Document doc = findAndModify(collection, update, true, false);
+        log("createOrUpdate returns ", doc);
+        return doc;
     }
 
     @Override
-    public Map<String, Object> findAndUpdate(Collection collection,
-                                             UpdateOp update)
+    public Document findAndUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         log("findAndUpdate", update);
-        Map<String, Object> map = findAndModify(collection, update, false, true);
-        log("findAndUpdate returns ", map);
-        return map;
+        Document doc = findAndModify(collection, update, false, true);
+        log("findAndUpdate returns ", doc);
+        return doc;
     }
 
     @Override
     public boolean create(Collection collection, List<UpdateOp> updateOps) {
         log("create", updateOps);       
-        ArrayList<Map<String, Object>> maps = new ArrayList<Map<String, Object>>();
+        List<Document> docs = new ArrayList<Document>();
         DBObject[] inserts = new DBObject[updateOps.size()];
 
         for (int i = 0; i < updateOps.size(); i++) {
             inserts[i] = new BasicDBObject();
             UpdateOp update = updateOps.get(i);
-            Map<String, Object> target = Utils.newMap();
+            Document target = Utils.newDocument();
             MemoryDocumentStore.applyChanges(target, update);
-            maps.add(target);
+            docs.add(target);
             for (Entry<String, Operation> entry : update.changes.entrySet()) {
                 String k = entry.getKey();
                 Operation op = entry.getValue();
@@ -392,9 +399,9 @@ public class MongoDocumentStore implements DocumentStore {
                     return false;
                 }
                 if (collection == Collection.NODES) {
-                    for (Map<String, Object> map : maps) {
-                        String id = (String) map.get(UpdateOp.ID);
-                        nodesCache.put(id, new CachedDocument(map));
+                    for (Document doc : docs) {
+                        String id = (String) doc.get(UpdateOp.ID);
+                        nodesCache.put(id, new CachedDocument(doc));
                     }
                 }
                 return true;
@@ -406,8 +413,8 @@ public class MongoDocumentStore implements DocumentStore {
         }        
     }
 
-    private static Map<String, Object> convertFromDBObject(DBObject n) {
-        Map<String, Object> copy = Utils.newMap();
+    private static Document convertFromDBObject(DBObject n) {
+        Document copy = Utils.newDocument();
         if (n != null) {
             for (String key : n.keySet()) {
                 Object o = n.get(key);
@@ -466,9 +473,9 @@ public class MongoDocumentStore implements DocumentStore {
     static class CachedDocument implements CacheValue {
         
         final long time = System.currentTimeMillis();
-        final Map<String, Object> value;
+        final Document value;
         
-        CachedDocument(Map<String, Object> value) {
+        CachedDocument(Document value) {
             this.value = value;
         }
         
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
index 602da86111..b23d030a68 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
@@ -660,20 +660,20 @@ public class MongoMK implements MicroKernel {
         // as the starting point
         String from = Utils.getKeyLowerLimit(path);
         String to = Utils.getKeyUpperLimit(path);
-        List<Map<String, Object>> list = store.query(DocumentStore.Collection.NODES, 
+        List<Document> list = store.query(DocumentStore.Collection.NODES,
                 from, to, limit);
         Children c = new Children();
         Set<Revision> validRevisions = new HashSet<Revision>();
         if (list.size() >= limit) {
             c.hasMore = true;
         }
-        for (Map<String, Object> e : list) {
+        for (Document doc : list) {
             // filter out deleted children
-            if (getLiveRevision(e, rev, validRevisions) == null) {
+            if (getLiveRevision(doc, rev, validRevisions) == null) {
                 continue;
             }
             // TODO put the whole node in the cache
-            String id = e.get(UpdateOp.ID).toString();
+            String id = doc.get(UpdateOp.ID).toString();
             String p = Utils.getPathFromId(id);
             c.children.add(p);
         }
@@ -917,10 +917,10 @@ public class MongoMK implements MicroKernel {
         long minValue = Commit.getModified(minTimestamp);
         String fromKey = Utils.getKeyLowerLimit(path);
         String toKey = Utils.getKeyUpperLimit(path);
-        List<Map<String, Object>> list = store.query(DocumentStore.Collection.NODES, fromKey, toKey, 
+        List<Document> list = store.query(DocumentStore.Collection.NODES, fromKey, toKey,
                 UpdateOp.MODIFIED, minValue, Integer.MAX_VALUE);
-        for (Map<String, Object> e : list) {
-            String id = e.get(UpdateOp.ID).toString();
+        for (Document doc : list) {
+            String id = doc.get(UpdateOp.ID).toString();
             String p = Utils.getPathFromId(id);
             Node fromNode = getNode(p, fromRev);
             Node toNode = getNode(p, toRev);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java
index 2be1851a31..ec1dfaec6b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java
@@ -17,12 +17,12 @@
 package org.apache.jackrabbit.oak.plugins.mongomk.util;
 
 import java.util.List;
-import java.util.Map;
 
 import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.mk.json.JsopBuilder;
+import org.apache.jackrabbit.oak.plugins.mongomk.Document;
 import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore;
 import org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp;
 import org.slf4j.Logger;
@@ -44,7 +44,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public Map<String, Object> find(Collection collection, String key) {
+    public Document find(Collection collection, String key) {
         try {
             logMethod("find", collection, key);
             return logResult(store.find(collection, key));
@@ -55,9 +55,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public Map<String, Object> find(Collection collection,
-                                    String key,
-                                    int maxCacheAge) {
+    public Document find(Collection collection, String key, int maxCacheAge) {
         try {
             logMethod("find", collection, key, maxCacheAge);
             return logResult(store.find(collection, key, maxCacheAge));
@@ -69,10 +67,10 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
 
     @Nonnull
     @Override
-    public List<Map<String, Object>> query(Collection collection,
-                                           String fromKey,
-                                           String toKey,
-                                           int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                int limit) {
         try {
             logMethod("query", collection, fromKey, toKey, limit);
             return logResult(store.query(collection, fromKey, toKey, limit));
@@ -84,8 +82,12 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     
     @Override
     @Nonnull
-    public List<Map<String, Object>> query(Collection collection, String fromKey,
-            String toKey, String indexedProperty, long startValue, int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                String indexedProperty,
+                                long startValue,
+                                int limit) {
         try {
             logMethod("query", collection, fromKey, toKey, indexedProperty, startValue, limit);
             return logResult(store.query(collection, fromKey, toKey, indexedProperty, startValue, limit));
@@ -119,8 +121,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
 
     @Nonnull
     @Override
-    public Map<String, Object> createOrUpdate(Collection collection,
-                                              UpdateOp update)
+    public Document createOrUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         try {
             logMethod("createOrUpdate", collection, update);
@@ -132,8 +133,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public Map<String, Object> findAndUpdate(Collection collection,
-                                             UpdateOp update)
+    public Document findAndUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         try {
             logMethod("findAndUpdate", collection, update);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java
index 25a3404378..5e76824337 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java
@@ -26,6 +26,7 @@ import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
+import org.apache.jackrabbit.oak.plugins.mongomk.Document;
 import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore;
 import org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp;
 
@@ -74,10 +75,10 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
     
     @Override
     @CheckForNull
-    public Map<String, Object> find(Collection collection, String key) {
+    public Document find(Collection collection, String key) {
         try {
             long start = now();
-            Map<String, Object> result = base.find(collection, key);
+            Document result = base.find(collection, key);
             updateAndLogTimes("find", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -87,10 +88,10 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @CheckForNull
-    public Map<String, Object> find(Collection collection, String key, int maxCacheAge) {
+    public Document find(Collection collection, String key, int maxCacheAge) {
         try {
             long start = now();
-            Map<String, Object> result = base.find(collection, key, maxCacheAge);
+            Document result = base.find(collection, key, maxCacheAge);
             updateAndLogTimes("find2", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -100,11 +101,13 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @Nonnull
-    public List<Map<String, Object>> query(Collection collection, String fromKey,
-            String toKey, int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                int limit) {
         try {
             long start = now();
-            List<Map<String, Object>> result = base.query(collection, fromKey, toKey, limit);
+            List<Document> result = base.query(collection, fromKey, toKey, limit);
             updateAndLogTimes("query", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -114,11 +117,15 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @Nonnull
-    public List<Map<String, Object>> query(Collection collection, String fromKey,
-            String toKey, String indexedProperty, long startValue, int limit) {
+    public List<Document> query(Collection collection,
+                                String fromKey,
+                                String toKey,
+                                String indexedProperty,
+                                long startValue,
+                                int limit) {
         try {
             long start = now();
-            List<Map<String, Object>> result = base.query(collection, fromKey, toKey, indexedProperty, startValue, limit);
+            List<Document> result = base.query(collection, fromKey, toKey, indexedProperty, startValue, limit);
             updateAndLogTimes("query2", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -151,11 +158,11 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @Nonnull
-    public Map<String, Object> createOrUpdate(Collection collection, UpdateOp update)
+    public Document createOrUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         try {
             long start = now();
-            Map<String, Object> result = base.createOrUpdate(collection, update);
+            Document result = base.createOrUpdate(collection, update);
             updateAndLogTimes("createOrUpdate", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -165,11 +172,11 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @CheckForNull
-    public Map<String, Object> findAndUpdate(Collection collection, UpdateOp update)
+    public Document findAndUpdate(Collection collection, UpdateOp update)
             throws MicroKernelException {
         try {
             long start = now();
-            Map<String, Object> result = base.findAndUpdate(collection, update);
+            Document result = base.findAndUpdate(collection, update);
             updateAndLogTimes("findAndUpdate", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -235,14 +242,14 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
         }
     }
     
-    private static int size(Map<String, Object> m) {
-        return Utils.estimateMemoryUsage(m);
+    private static int size(Document doc) {
+        return Utils.estimateMemoryUsage(doc);
     }
 
-    private static int size(List<Map<String, Object>> list) {
+    private static int size(List<Document> list) {
         int result = 0;
-        for (Map<String, Object> m : list) {
-            result += size(m);
+        for (Document doc : list) {
+            result += size(doc);
         }
         return result;
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java
index 319e35fbf8..26bfebd3ab 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java
@@ -28,6 +28,7 @@ import javax.annotation.Nullable;
 import com.mongodb.BasicDBObject;
 
 import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.plugins.mongomk.Document;
 import org.apache.jackrabbit.oak.plugins.mongomk.Revision;
 import org.bson.types.ObjectId;
 
@@ -59,6 +60,10 @@ public class Utils {
         return new HashSet<E>();
     }
 
+    public static Document newDocument() {
+        return new Document();
+    }
+
     @SuppressWarnings("unchecked")
     public static int estimateMemoryUsage(Map<String, Object> map) {
         if (map == null) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java
index cf18629530..4722c5309b 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java
@@ -188,7 +188,7 @@ public class MongoDocumentStoreTest {
             inserts.add(n.asOperation(true));
         }
         docStore.create(Collection.NODES, inserts);
-        List<Map<String, Object>> docs = docStore.query(Collection.NODES,
+        List<Document> docs = docStore.query(Collection.NODES,
                 Utils.getKeyLowerLimit("/"),  Utils.getKeyUpperLimit("/"),
                 MongoMK.MANY_CHILDREN_THRESHOLD);
         assertEquals(MongoMK.MANY_CHILDREN_THRESHOLD, docs.size());
