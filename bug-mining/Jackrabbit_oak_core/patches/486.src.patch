diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
index f8b840fdf5..51cce4d124 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
@@ -18,7 +18,6 @@ package org.apache.jackrabbit.oak.plugins.mongomk;
 
 import java.io.InputStream;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
@@ -250,11 +249,23 @@ public class MongoMK implements MicroKernel {
         long minValue = Commit.getModified(minTimestamp);
         String fromKey = Utils.getKeyLowerLimit(path);
         String toKey = Utils.getKeyUpperLimit(path);
-        List<NodeDocument> list = store.query(Collection.NODES, fromKey, toKey,
-                NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE);
-        for (NodeDocument doc : list) {
-            String id = doc.getId();
-            String p = Utils.getPathFromId(id);
+        Set<String> paths = new HashSet<String>();
+        for (NodeDocument doc : store.query(Collection.NODES, fromKey, toKey,
+                NodeDocument.MODIFIED, minValue, Integer.MAX_VALUE)) {
+            paths.add(Utils.getPathFromId(doc.getId()));
+        }
+        // also consider nodes with not yet stored modifications (OAK-1107)
+        Revision minRev = new Revision(minTimestamp, 0, nodeStore.getClusterId());
+        for (String p : nodeStore.getPendingModifications().getPaths(minRev)) {
+            if (PathUtils.denotesRoot(p)) {
+                continue;
+            }
+            String parent = PathUtils.getParentPath(p);
+            if (path.equals(parent)) {
+                paths.add(p);
+            }
+        }
+        for (String p : paths) {
             Node fromNode = nodeStore.getNode(p, fromRev);
             Node toNode = nodeStore.getNode(p, toRev);
             if (fromNode != null) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnsavedModifications.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnsavedModifications.java
index 8991932b74..94f7d61125 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnsavedModifications.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnsavedModifications.java
@@ -17,11 +17,17 @@
 package org.apache.jackrabbit.oak.plugins.mongomk;
 
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -95,4 +101,31 @@ class UnsavedModifications {
             other.put(entry.getKey(), mergeCommit);
         }
     }
+
+    /**
+     * Returns all paths of nodes with modifications at the start revision
+     * (inclusive) or later.
+     *
+     * @param start the start revision (inclusive).
+     * @return matching paths with pending modifications.
+     */
+    @Nonnull
+    public Iterable<String> getPaths(@Nonnull final Revision start) {
+        if (map.isEmpty()) {
+            return Collections.emptyList();
+        } else {
+            return Iterables.transform(Iterables.filter(map.entrySet(),
+                    new Predicate<Map.Entry<String, Revision>>() {
+                @Override
+                public boolean apply(Map.Entry<String, Revision> input) {
+                    return start.compareRevisionTime(input.getValue()) < 1;
+                }
+            }), new Function<Map.Entry<String, Revision>, String>() {
+                @Override
+                public String apply(Map.Entry<String, Revision> input) {
+                    return input.getKey();
+                }
+            });
+        }
+    }
 }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKDiffTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKDiffTest.java
index 3754ff1f54..4f58473241 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKDiffTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKDiffTest.java
@@ -250,14 +250,13 @@ public class MongoMKDiffTest extends AbstractMongoConnectionTest {
     }
 
     @Test
-    @Ignore
     public void diffForChangeBelowManyChildren() throws InterruptedException {
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < MongoMK.MANY_CHILDREN_THRESHOLD * 2; i++) {
             sb.append("+\"node-").append(i).append("\":{}");
         }
         mk.commit("/", sb.toString(), null, null);
-        // wait a while, _modified has 5 seconds granularity
+        // wait a while, _modified has 5 seconds resolution
         Thread.sleep(TimeUnit.SECONDS.toMillis(6));
         // create a base commit for the diff
         String base = mk.commit("/", "+\"foo\":{}", null, null);
