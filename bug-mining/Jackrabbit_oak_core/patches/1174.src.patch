diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
index 98f444ee9b..5c30e3a664 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
@@ -42,9 +42,12 @@ import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.annotation.CheckForNull;
@@ -74,6 +77,7 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.apache.jackrabbit.oak.stats.Clock;
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Test;
 
 public class DocumentNodeStoreTest {
@@ -1118,6 +1122,96 @@ public class DocumentNodeStoreTest {
         ns.dispose();
     }
 
+    // OAK-2642
+    @Ignore
+    @Test
+    public void dispose() throws CommitFailedException, InterruptedException {
+        final BlockingQueue<String> updates = new ArrayBlockingQueue<String>(1);
+        MemoryDocumentStore docStore = new MemoryDocumentStore() {
+            @Override
+            public <T extends Document> void update(Collection<T> collection,
+                                                    List<String> keys,
+                                                    UpdateOp updateOp) {
+                for (String k : keys) {
+                    try {
+                        updates.put(k);
+                    } catch (InterruptedException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+                super.update(collection, keys, updateOp);
+            }
+        };
+        final DocumentNodeStore store = new DocumentMK.Builder()
+                .setClusterId(1).setAsyncDelay(0)
+                .setDocumentStore(docStore).getNodeStore();
+        updates.clear();
+
+        NodeBuilder builder = store.getRoot().builder();
+        builder.child("test").child("node");
+        merge(store, builder);
+
+        builder = store.getRoot().builder();
+        builder.child("test").child("node").child("child-1");
+        merge(store, builder);
+
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                store.dispose();
+            }
+        });
+        t.start();
+
+        String p = updates.take();
+        assertEquals("2:/test/node", p);
+        // background ops in dispose is still in progress
+        assertTrue(t.isAlive());
+        // wait until next update comes in
+        for (;;) {
+            if (updates.peek() != null) {
+                break;
+            }
+        }
+
+        // add child-2 while dispose is in progress
+        try {
+            builder = store.getRoot().builder();
+            builder.child("test").child("node").child("child-2");
+            merge(store, builder);
+        } catch (Exception e) {
+            // ignore
+        }
+
+        // drain updates until dispose finished
+        while (t.isAlive()) {
+            updates.poll(10, TimeUnit.MILLISECONDS);
+        }
+
+        // start new store with clusterId 2
+        DocumentNodeStore store2 = new DocumentMK.Builder()
+                .setClusterId(2).setAsyncDelay(0)
+                .setDocumentStore(docStore).getNodeStore();
+
+        // perform recovery if needed
+        LastRevRecoveryAgent agent = new LastRevRecoveryAgent(store2);
+        if (agent.isRecoveryNeeded()) {
+            agent.recover(1);
+        }
+
+        builder = store2.getRoot().builder();
+        NodeBuilder test = builder.getChildNode("test");
+        assertTrue(test.exists());
+        NodeBuilder node = test.getChildNode("node");
+        assertTrue(node.exists());
+        if (!node.hasChildNode("child-2")) {
+            node.child("child-2");
+            merge(store2, builder);
+        }
+
+        store2.dispose();
+    }
+
     private void doSomeChange(NodeStore ns) throws CommitFailedException {
         NodeBuilder b = ns.getRoot().builder();
         b.setProperty("count", System.currentTimeMillis());
