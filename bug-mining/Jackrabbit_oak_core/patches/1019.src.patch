diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java
index c3bfcd4e74..af263b1662 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java
@@ -30,6 +30,7 @@ import org.apache.jackrabbit.oak.spi.state.AbstractNodeStoreBranch;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static org.apache.jackrabbit.oak.api.CommitFailedException.MERGE;
 import static org.apache.jackrabbit.oak.api.CommitFailedException.OAK;
 
@@ -46,7 +47,8 @@ class DocumentNodeStoreBranch
                             DocumentNodeState base,
                             ReadWriteLock mergeLock) {
         super(store, new ChangeDispatcher(store.getRoot()), mergeLock.readLock(),
-                base, null, getMaxBackoffMillis(store));
+                base, null, getMaxBackoffMillis(store),
+                getMaxBackoffMillis(store) * 3);
         this.mergeLock = mergeLock;
     }
 
@@ -147,11 +149,20 @@ class DocumentNodeStoreBranch
         }
         // retry with exclusive lock, blocking other
         // concurrent writes
-        mergeLock.writeLock().lock();
+        // do not wait forever
+        boolean acquired = false;
+        try {
+            acquired = mergeLock.writeLock()
+                    .tryLock(maxLockTryTimeMS, MILLISECONDS);
+        } catch (InterruptedException e) {
+            // ignore and proceed with shared lock used in base class
+        }
         try {
             return super.merge(hook, info);
         } finally {
-            mergeLock.writeLock().unlock();
+            if (acquired) {
+                mergeLock.writeLock().unlock();
+            }
         }
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java
index 94c5358cce..0244d2a7c0 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java
@@ -64,6 +64,11 @@ public abstract class AbstractNodeStoreBranch<S extends NodeStore, N extends Nod
 
     protected final long maximumBackoff;
 
+    /**
+     * The maximum time in milliseconds to wait for the merge lock.
+     */
+    protected final long maxLockTryTimeMS;
+
     /** Lock for coordinating concurrent merge operations */
     private final Lock mergeLock;
 
@@ -79,7 +84,8 @@ public abstract class AbstractNodeStoreBranch<S extends NodeStore, N extends Nod
                                    Lock mergeLock,
                                    N base) {
         this(kernelNodeStore, dispatcher, mergeLock, base, null,
-                MILLISECONDS.convert(10, SECONDS));
+                MILLISECONDS.convert(10, SECONDS),
+                Integer.MAX_VALUE); // default: wait 'forever'
     }
 
     public AbstractNodeStoreBranch(S kernelNodeStore,
@@ -87,7 +93,8 @@ public abstract class AbstractNodeStoreBranch<S extends NodeStore, N extends Nod
                                    Lock mergeLock,
                                    N base,
                                    N head,
-                                   long maximumBackoff) {
+                                   long maximumBackoff,
+                                   long maxLockTryTimeMS) {
         this.store = checkNotNull(kernelNodeStore);
         this.dispatcher = dispatcher;
         this.mergeLock = checkNotNull(mergeLock);
@@ -97,6 +104,7 @@ public abstract class AbstractNodeStoreBranch<S extends NodeStore, N extends Nod
             this.branchState = new Persisted(checkNotNull(base), head);
         }
         this.maximumBackoff = Math.max(maximumBackoff, MIN_BACKOFF);
+        this.maxLockTryTimeMS = maxLockTryTimeMS;
     }
 
     /**
@@ -305,19 +313,26 @@ public abstract class AbstractNodeStoreBranch<S extends NodeStore, N extends Nod
                             MERGE, 3, "Merge interrupted", e);
                 }
             }
-            mergeLock.lock();
             try {
-                return branchState.merge(checkNotNull(hook), checkNotNull(info));
-            } catch (CommitFailedException e) {
-                ex = e;
-                // only retry on merge failures. these may be caused by
-                // changes introduce by a commit hook and may be resolved
-                // by a rebase and running the hook again
-                if (!e.isOfType(MERGE)) {
-                    throw e;
+                boolean acquired = mergeLock.tryLock(maxLockTryTimeMS, MILLISECONDS);
+                try {
+                    return branchState.merge(checkNotNull(hook), checkNotNull(info));
+                } catch (CommitFailedException e) {
+                    ex = e;
+                    // only retry on merge failures. these may be caused by
+                    // changes introduce by a commit hook and may be resolved
+                    // by a rebase and running the hook again
+                    if (!e.isOfType(MERGE)) {
+                        throw e;
+                    }
+                } finally {
+                    if (acquired) {
+                        mergeLock.unlock();
+                    }
                 }
-            } finally {
-                mergeLock.unlock();
+            } catch (InterruptedException e) {
+                throw new CommitFailedException(OAK, 1,
+                        "Unable to acquire merge lock", e);
             }
         }
         // if we get here retrying failed
