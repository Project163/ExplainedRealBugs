diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterRevisionComparisonTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterRevisionComparisonTest.java
index 3076dbf411..ab3f5e1a41 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterRevisionComparisonTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterRevisionComparisonTest.java
@@ -19,7 +19,11 @@
 
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.List;
+
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore;
@@ -41,6 +45,7 @@ public class ClusterRevisionComparisonTest {
     private MemoryDocumentStore ds = new MemoryDocumentStore();
     private MemoryBlobStore bs = new MemoryBlobStore();
     private Clock clock = new Clock.Virtual();
+    private List<DocumentNodeStore> stores = Lists.newArrayList();
 
     @Before
     public void setUp(){
@@ -104,19 +109,66 @@ public class ClusterRevisionComparisonTest {
         c1ns1.compareAgainstBaseState(c1ns2, new ClusterTest.TrackingDiff());
     }
 
+    @Ignore("OAK-2144")
+    @Test
+    public void revisionComparisonTwoClusterNodes() throws Exception {
+        DocumentNodeStore c1 = createNS(1);
+        DocumentNodeStore c2 = createNS(2);
+
+        // 1. Create /a and make it visible to both cluster nodes
+        createNode(c1, "/a");
+        runBgOps(c1, c2);
+
+        // 2. Time T1. Create /a/c2 but do not push the changes yet rT1-C2
+        createNode(c2, "/a/c2");
+
+        // 3. Time T2. Create /a/c1
+        createNode(c1, "/a/c1");
+
+        // 4. Push changes on c2
+        runBgOps(c2);
+
+        // 5. Time T3. Read the changes /a/c2 by c2 created at T1.
+        // Now from C1 view rT1-C2 > rT2-C1 even though T1 < T2
+        runBgOps(c1);
+
+        DocumentNodeState c1ns1 = c1.getRoot();
+        NodeState a = c1ns1.getChildNode("a");
+        assertTrue("/a/c1 missing", a.hasChildNode("c1"));
+        assertTrue("/a/c2 missing", a.hasChildNode("c2"));
+
+        // 6. Purge revision comparator. Also purge entries from nodeCache
+        // such that later reads at rT1-C2 triggers read from underlying DocumentStore
+        c1.invalidateNodeCache("/a/c1" , ((DocumentNodeState)c1ns1.getChildNode("a")).getLastRevision());
+        c1.invalidateNodeCache("/a/c2" , ((DocumentNodeState)c1ns1.getChildNode("a")).getLastRevision());
+
+        //Revision comparator purge by moving in future
+        clock.waitUntil(clock.getTime() + DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS * 2);
+        runBgOps(c1);
+
+        assertTrue("/a/c1 disappeared", a.hasChildNode("c1"));
+        assertTrue("/a/c2 disappeared", a.hasChildNode("c2"));
+    }
+
     @After
     public void tearDown(){
+        for (DocumentNodeStore store : stores) {
+            store.dispose();
+        }
+        stores.clear();
         Revision.resetClockToDefault();
     }
 
     private DocumentNodeStore createNS(int clusterId){
-        return new DocumentMK.Builder()
+        DocumentNodeStore store = new DocumentMK.Builder()
                 .setDocumentStore(ds)
                 .setBlobStore(bs)
                 .setClusterId(clusterId)
                 .setAsyncDelay(0)
                 .open()
                 .getNodeStore();
+        stores.add(store);
+        return store;
     }
 
    private NodeState createNode(NodeStore ns, String path) throws CommitFailedException {
