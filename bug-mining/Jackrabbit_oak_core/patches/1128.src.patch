diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java
index 7b1bec62ac..259474ded0 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ValueMap.java
@@ -18,9 +18,12 @@ package org.apache.jackrabbit.oak.plugins.document;
 
 import java.util.AbstractMap;
 import java.util.AbstractSet;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
@@ -32,6 +35,7 @@ import org.apache.jackrabbit.oak.plugins.document.util.MergeSortedIterators;
 
 import com.google.common.base.Objects;
 import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
 
 /**
  * A value map contains the versioned values of a property. The key into this
@@ -61,9 +65,32 @@ class ValueMap {
                 if (map.isEmpty()) {
                     docs = doc.getPreviousDocs(property, null).iterator();
                 } else {
-                    docs = Iterators.concat(
-                            Iterators.singletonIterator(doc),
-                            doc.getPreviousDocs(property, null).iterator());
+                    // merge sort local map into maps of previous documents
+                    List<Iterator<NodeDocument>> iterators = 
+                            new ArrayList<Iterator<NodeDocument>>(2);
+                    iterators.add(Iterators.singletonIterator(doc));
+                    iterators.add(doc.getPreviousDocs(property, null).iterator());                            
+                    docs = Iterators.mergeSorted(iterators, new Comparator<NodeDocument>() {
+                                @Override
+                                public int compare(NodeDocument o1,
+                                                   NodeDocument o2) {
+                                    Revision r1 = getFirstRevision(o1);
+                                    Revision r2 = getFirstRevision(o2);
+                                    return c.compare(r1, r2);
+                                }
+                            
+                                private Revision getFirstRevision(NodeDocument d) {
+                                    Map<Revision, String> values;
+                                    if (Objects.equal(d.getId(), doc.getId())) {
+                                        // return local map for main document
+                                        values = d.getLocalMap(property);
+                                    } else {
+                                        values = d.getValueMap(property);
+                                    }
+                                    return values.keySet().iterator().next();
+                                }
+                        
+                            });
                 }
 
                 return new MergeSortedIterators<Map.Entry<Revision, String>>(
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java
index 48bed082ee..3cb3dc5093 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MergeSortedIterators.java
@@ -100,7 +100,9 @@ public abstract class MergeSortedIterators<T> implements Iterator<T> {
             PeekingIterator<T> pIt = Iterators.peekingIterator(it);
             if (!iterators.isEmpty()
                     &&  comparator.compare(pIt.peek(), lastPeek) < 0) {
-                throw new IllegalStateException(description() + " First element of next iterator must be greater than previous iterator");
+                throw new IllegalStateException(description() + 
+                        " First element of next iterator (" + pIt.peek() + ")" +
+                        " must be after previous iterator (" + lastPeek + ")");
             }
             lastPeek = pIt.peek();
             iterators.add(pIt);
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ValueMapTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ValueMapTest.java
index b8f6dd0fbd..d0815ed461 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ValueMapTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ValueMapTest.java
@@ -24,8 +24,12 @@ import java.util.Set;
 
 import org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
+import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
+import org.apache.jackrabbit.oak.spi.commit.EmptyHook;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.junit.Test;
 
+import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
@@ -138,4 +142,82 @@ public class ValueMapTest {
         }
         assertEquals(Arrays.asList(r51, r31, r22, r12), revs);
     }
+    
+    // OAK-2433
+    @Test
+    public void mergeSorted() throws Exception {
+        DocumentNodeStore store = new DocumentMK.Builder().setAsyncDelay(0).getNodeStore();
+        DocumentStore docStore = store.getDocumentStore();
+        String id = Utils.getIdFromPath("/");
+        
+        List<NodeBuilder> branches = Lists.newArrayList();
+        int i = 0;
+        while (docStore.find(NODES, id).getPreviousRanges().size() < 2) {
+            i++;
+            NodeBuilder builder = store.getRoot().builder();
+            builder.child("foo").setProperty("prop", i);
+            builder.child("bar").setProperty("prop", i);
+            if (i % 7 == 0) {
+                // every now and then create a branch
+                int numRevs = docStore.find(NODES, id).getLocalRevisions().size();
+                NodeBuilder child = builder.child("node" + i);
+                int p = 0;
+                while (numRevs == docStore.find(NODES, id).getLocalRevisions().size()) {
+                    child.setProperty("prop", p++);
+                }
+                branches.add(builder);
+            } else {
+                store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+            }
+            store.runBackgroundOperations();
+        }
+        
+        NodeDocument doc = docStore.find(NODES, id);
+        Iterators.size(doc.getValueMap(NodeDocument.REVISIONS).entrySet().iterator());
+
+        store.dispose();
+    }
+
+    // OAK-2433
+    @Test
+    public void mergeSorted1() throws Exception {
+        MemoryDocumentStore store = new MemoryDocumentStore();
+        
+        Revision r1 = new Revision(1, 0, 1); // prev2
+        Revision r2 = new Revision(2, 0, 1); // prev2
+        Revision r3 = new Revision(3, 0, 1); // root
+        Revision r4 = new Revision(4, 0, 1); // prev2
+        Revision r5 = new Revision(5, 0, 1); // prev1
+        Revision r6 = new Revision(6, 0, 1); // root
+        Revision r7 = new Revision(7, 0, 1); // prev1
+
+        Range range1 = new Range(r7, r5, 0);
+        Range range2 = new Range(r4, r1, 0);
+        
+        String prevId1 = Utils.getPreviousIdFor("/", range1.high, 0);
+        UpdateOp prevOp1 = new UpdateOp(prevId1, true);
+        prevOp1.set(Document.ID, prevId1);
+        NodeDocument.setRevision(prevOp1, r5, "c");
+        NodeDocument.setRevision(prevOp1, r7, "c");
+
+        String prevId2 = Utils.getPreviousIdFor("/", range2.high, 0);
+        UpdateOp prevOp2 = new UpdateOp(prevId2, true);
+        prevOp1.set(Document.ID, prevId2);
+        NodeDocument.setRevision(prevOp2, r1, "c");
+        NodeDocument.setRevision(prevOp2, r2, "c");
+        NodeDocument.setRevision(prevOp2, r4, "c");
+
+        String rootId = Utils.getIdFromPath("/");
+        UpdateOp op = new UpdateOp(rootId, true);
+        op.set(Document.ID, rootId);
+        NodeDocument.setRevision(op, r3, "c");
+        NodeDocument.setRevision(op, r6, "c");
+        NodeDocument.setPrevious(op, range1);
+        NodeDocument.setPrevious(op, range2);
+        
+        store.create(NODES, Lists.newArrayList(op, prevOp1, prevOp2));
+        
+        NodeDocument doc = store.find(NODES, rootId);
+        Iterators.size(doc.getValueMap(NodeDocument.REVISIONS).entrySet().iterator());
+    }
 }
