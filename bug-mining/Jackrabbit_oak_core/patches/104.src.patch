diff --git a/oak-core/pom.xml b/oak-core/pom.xml
index 95524c0a1b..aee58f6481 100644
--- a/oak-core/pom.xml
+++ b/oak-core/pom.xml
@@ -52,6 +52,7 @@
               org.apache.jackrabbit.oak.plugins.memory,
               org.apache.jackrabbit.oak.plugins.name,
               org.apache.jackrabbit.oak.plugins.nodetype,
+              org.apache.jackrabbit.oak.plugins.observation,
               org.apache.jackrabbit.oak.spi.query,
               org.apache.jackrabbit.oak.spi.commit,
               org.apache.jackrabbit.oak.spi.state,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Root.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Root.java
index af35977f1c..41da38cb9c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Root.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Root.java
@@ -120,13 +120,6 @@ public interface Root {
      */
     boolean hasPendingChanges();
 
-    /**
-     * Return a {@link ChangeExtractor} for this {@code Root}.
-     * @return a {@code ChangeExtractor}.
-     */
-    @Nonnull
-    ChangeExtractor getChangeExtractor();
-
     /**
      * Get the query engine.
      * 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java
index fec692629b..db8efa2710 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/RootImpl.java
@@ -26,7 +26,7 @@ import java.util.List;
 import javax.annotation.Nonnull;
 import javax.security.auth.Subject;
 
-import org.apache.jackrabbit.oak.api.ChangeExtractor;
+import org.apache.jackrabbit.oak.spi.observation.ChangeExtractor;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.SessionQueryEngine;
@@ -233,7 +233,6 @@ public class RootImpl implements Root {
         return !getBaseState().equals(rootTree.getNodeState());
     }
 
-    @Override
     @Nonnull
     public ChangeExtractor getChangeExtractor() {
         return new ChangeExtractor() {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeFilter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeFilter.java
new file mode 100644
index 0000000000..1630cc7b82
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeFilter.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+
+class ChangeFilter {
+    private final int eventTypes;
+    private final String path;
+    private final boolean deep;
+    private final String[] uuid;          // TODO implement filtering by uuid
+    private final String[] nodeTypeName;  // TODO implement filtering by nodeTypeName
+    private final boolean noLocal;        // TODO implement filtering by noLocal
+
+    public ChangeFilter(int eventTypes, String path, boolean deep, String[] uuid, String[] nodeTypeName,
+            boolean noLocal) {
+        this.eventTypes = eventTypes;
+        this.path = path;
+        this.deep = deep;
+        this.uuid = uuid;
+        this.nodeTypeName = nodeTypeName;
+        this.noLocal = noLocal;
+    }
+
+    public boolean include(int eventType) {
+        return (this.eventTypes & eventType) != 0;
+    }
+
+    public boolean include(String path) {
+        boolean equalPaths = this.path.equals(path);
+        if (!deep && !equalPaths) {
+            return false;
+        }
+        if (deep && !(PathUtils.isAncestor(this.path, path) || equalPaths)) {
+            return false;
+        }
+        return true;
+    }
+
+    public boolean include(int eventType, String path, NodeState associatedParentNode) {
+        return include(eventType) && include(path);
+    }
+
+    public boolean includeChildren(String path) {
+        return PathUtils.isAncestor(path, this.path) ||
+                path.equals(this.path) ||
+                deep && PathUtils.isAncestor(this.path, path);
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeProcessor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeProcessor.java
new file mode 100644
index 0000000000..0964b0ee9f
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeProcessor.java
@@ -0,0 +1,281 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.jcr.observation.Event;
+import javax.jcr.observation.EventListener;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterators;
+import org.apache.jackrabbit.commons.iterator.EventIteratorAdapter;
+import org.apache.jackrabbit.oak.spi.observation.ChangeExtractor;
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.namepath.NamePathMapper;
+import org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;
+import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;
+
+class ChangeProcessor implements Runnable {
+    private final ObservationManagerImpl observationManager;
+    private final NamePathMapper namePathMapper;
+    private final ChangeExtractor changeExtractor;
+    private final EventListener listener;
+    private final AtomicReference<ChangeFilter> filterRef;
+    private volatile boolean running;
+    private volatile boolean stopping;
+    private ScheduledFuture<?> future;
+
+    public ChangeProcessor(ObservationManagerImpl observationManager, EventListener listener, ChangeFilter filter) {
+        this.observationManager = observationManager;
+        this.namePathMapper = observationManager.getNamePathMapper();
+        this.changeExtractor = observationManager.getChangeExtractor();
+        this.listener = listener;
+        filterRef = new AtomicReference<ChangeFilter>(filter);
+    }
+
+    public void setFilter(ChangeFilter filter) {
+        filterRef.set(filter);
+    }
+
+    /**
+     * Stop this change processor if running. After returning from this methods no further
+     * events will be delivered.
+     * @throws IllegalStateException if not yet started or stopped already
+     */
+    public synchronized void stop() {
+        if (future == null) {
+            throw new IllegalStateException("Change processor not started");
+        }
+
+        try {
+            stopping = true;
+            future.cancel(true);
+            while (running) {
+                wait();
+            }
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
+        finally {
+            future = null;
+        }
+    }
+
+    /**
+     * Start the change processor on the passed {@code executor}.
+     * @param executor
+     * @throws IllegalStateException if started already
+     */
+    public synchronized void start(ScheduledExecutorService executor) {
+        if (future != null) {
+            throw new IllegalStateException("Change processor started already");
+        }
+        stopping = false;
+        future = executor.scheduleWithFixedDelay(this, 100, 1000, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void run() {
+        running = true;
+        try{
+            EventGeneratingNodeStateDiff diff = new EventGeneratingNodeStateDiff();
+            changeExtractor.getChanges(diff);
+            if (!stopping) {
+                diff.sendEvents();
+            }
+        } finally {
+            synchronized (this) {
+                running = false;
+                notifyAll();
+            }
+        }
+    }
+
+    //------------------------------------------------------------< private >---
+
+    private class EventGeneratingNodeStateDiff implements NodeStateDiff {
+        public static final int PURGE_LIMIT = 8192;
+
+        private final String path;
+        private final NodeState associatedParentNode;
+
+        private int childNodeCount;
+        private List<Iterator<Event>> events;
+
+        EventGeneratingNodeStateDiff(String path, List<Iterator<Event>> events, NodeState associatedParentNode) {
+            this.path = path;
+            this.associatedParentNode = associatedParentNode;
+            this.events = events;
+        }
+
+        public EventGeneratingNodeStateDiff() {
+            this("/", new ArrayList<Iterator<Event>>(PURGE_LIMIT), null);
+        }
+
+        public void sendEvents() {
+            Iterator<Event> eventIt = Iterators.concat(events.iterator());
+            if (eventIt.hasNext()) {
+                observationManager.setHasEvents();
+                listener.onEvent(new EventIteratorAdapter(eventIt) {
+                    @Override
+                    public boolean hasNext() {
+                        return !stopping && super.hasNext();
+                    }
+                });
+                events = new ArrayList<Iterator<Event>>(PURGE_LIMIT);
+            }
+        }
+
+        private String jcrPath() {
+            return namePathMapper.getJcrPath(path);
+        }
+
+        @Override
+        public void propertyAdded(PropertyState after) {
+            if (!stopping && filterRef.get().include(Event.PROPERTY_ADDED, jcrPath(), associatedParentNode)) {
+                Event event = generatePropertyEvent(Event.PROPERTY_ADDED, path, after);
+                events.add(Iterators.singletonIterator(event));
+            }
+        }
+
+        @Override
+        public void propertyChanged(PropertyState before, PropertyState after) {
+            if (!stopping && filterRef.get().include(Event.PROPERTY_CHANGED, jcrPath(), associatedParentNode)) {
+                Event event = generatePropertyEvent(Event.PROPERTY_CHANGED, path, after);
+                events.add(Iterators.singletonIterator(event));
+            }
+        }
+
+        @Override
+        public void propertyDeleted(PropertyState before) {
+            if (!stopping && filterRef.get().include(Event.PROPERTY_REMOVED, jcrPath(), associatedParentNode)) {
+                Event event = generatePropertyEvent(Event.PROPERTY_REMOVED, path, before);
+                events.add(Iterators.singletonIterator(event));
+            }
+        }
+
+        @Override
+        public void childNodeAdded(String name, NodeState after) {
+            if (NodeStateUtils.isHidden(name)) {
+                return;
+            }
+            if (!stopping && filterRef.get().includeChildren(jcrPath())) {
+                Iterator<Event> events = generateNodeEvents(Event.NODE_ADDED, path, name, after);
+                this.events.add(events);
+                if (++childNodeCount > PURGE_LIMIT) {
+                    sendEvents();
+                }
+            }
+        }
+
+        @Override
+        public void childNodeDeleted(String name, NodeState before) {
+            if (NodeStateUtils.isHidden(name)) {
+                return;
+            }
+            if (!stopping && filterRef.get().includeChildren(jcrPath())) {
+                Iterator<Event> events = generateNodeEvents(Event.NODE_REMOVED, path, name, before);
+                this.events.add(events);
+            }
+        }
+
+        @Override
+        public void childNodeChanged(String name, NodeState before, NodeState after) {
+            if (NodeStateUtils.isHidden(name)) {
+                return;
+            }
+            if (!stopping && filterRef.get().includeChildren(jcrPath())) {
+                EventGeneratingNodeStateDiff diff = new EventGeneratingNodeStateDiff(
+                        PathUtils.concat(path, name), events, after);
+                after.compareAgainstBaseState(before, diff);
+                if (events.size() > PURGE_LIMIT) {
+                    diff.sendEvents();
+                }
+            }
+        }
+
+        private Event generatePropertyEvent(int eventType, String parentPath, PropertyState property) {
+            String jcrPath = namePathMapper.getJcrPath(PathUtils.concat(parentPath, property.getName()));
+
+            // TODO support userId, identifier, info, date
+            return new EventImpl(eventType, jcrPath, null, null, null, 0);
+        }
+
+        private Iterator<Event> generateNodeEvents(int eventType, String parentPath, String name, NodeState node) {
+            ChangeFilter filter = filterRef.get();
+            final String path = PathUtils.concat(parentPath, name);
+            String jcrParentPath = namePathMapper.getJcrPath(parentPath);
+            String jcrPath = namePathMapper.getJcrPath(path);
+
+            Iterator<Event> nodeEvent;
+            if (filter.include(eventType, jcrParentPath, associatedParentNode)) {
+                // TODO support userId, identifier, info, date
+                Event event = new EventImpl(eventType, jcrPath, null, null, null, 0);
+                nodeEvent = Iterators.singletonIterator(event);
+            } else {
+                nodeEvent = Iterators.emptyIterator();
+            }
+
+            final int propertyEventType = eventType == Event.NODE_ADDED
+                    ? Event.PROPERTY_ADDED
+                    : Event.PROPERTY_REMOVED;
+
+            Iterator<Event> propertyEvents;
+            if (filter.include(propertyEventType, jcrPath, associatedParentNode)) {
+                propertyEvents = Iterators.transform(
+                        node.getProperties().iterator(),
+                        new Function<PropertyState, Event>() {
+                            @Override
+                            public Event apply(PropertyState property) {
+                                return generatePropertyEvent(propertyEventType, path, property);
+                            }
+                        });
+            } else {
+                propertyEvents = Iterators.emptyIterator();
+            }
+
+            Iterator<Event> childNodeEvents = filter.includeChildren(jcrPath)
+                    ? Iterators.concat(generateChildEvents(eventType, path, node))
+                    : Iterators.<Event>emptyIterator();
+
+            return Iterators.concat(nodeEvent, propertyEvents, childNodeEvents);
+        }
+
+        private Iterator<Iterator<Event>> generateChildEvents(final int eventType, final String parentPath, NodeState node) {
+            return Iterators.transform(
+                    node.getChildNodeEntries().iterator(),
+                    new Function<ChildNodeEntry, Iterator<Event>>() {
+                        @Override
+                        public Iterator<Event> apply(ChildNodeEntry entry) {
+                            return generateNodeEvents(eventType, parentPath, entry.getName(), entry.getNodeState());
+                        }
+                    });
+        }
+
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventImpl.java
new file mode 100644
index 0000000000..eeee5682a4
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventImpl.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import java.util.Collections;
+import java.util.Map;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.observation.Event;
+
+public class EventImpl implements Event {
+    private final int type;
+    private final String path;
+    private final String userID;
+    private final String identifier;
+    private final Map<?, ?> info;
+    private final long date;
+
+    public EventImpl(int type, String path, String userID, String identifier, Map<?, ?> info, long date) {
+        this.type = type;
+        this.path = path;
+        this.userID = userID;
+        this.identifier = identifier;
+        this.info = info == null ? Collections.emptyMap() : info;
+        this.date = date;
+    }
+
+    @Override
+    public int getType() {
+        return type;
+    }
+
+    @Override
+    public String getPath() throws RepositoryException {
+        return path;
+    }
+
+    @Override
+    public String getUserID() {
+        return userID;
+    }
+
+    @Override
+    public String getIdentifier() throws RepositoryException {
+        return identifier;
+    }
+
+    @Override
+    public Map<?, ?> getInfo() throws RepositoryException {
+        return info;
+    }
+
+    @Override
+    public String getUserData() throws RepositoryException {
+        throw new UnsupportedRepositoryOperationException("User data not supported");
+    }
+
+    @Override
+    public long getDate() throws RepositoryException {
+        return date;
+    }
+
+    @Override
+    public final boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (other == null || getClass() != other.getClass()) {
+            return false;
+        }
+
+        EventImpl that = (EventImpl) other;
+        return date == that.date && type == that.type &&
+                (identifier == null ? that.identifier == null : identifier.equals(that.identifier)) &&
+                (info == null ? that.info == null : info.equals(that.info)) &&
+                (path == null ? that.path == null : path.equals(that.path)) &&
+                (userID == null ? that.userID == null : userID.equals(that.userID));
+
+    }
+
+    @Override
+    public final int hashCode() {
+        int result = type;
+        result = 31 * result + (path == null ? 0 : path.hashCode());
+        result = 31 * result + (userID == null ? 0 : userID.hashCode());
+        result = 31 * result + (identifier == null ? 0 : identifier.hashCode());
+        result = 31 * result + (info == null ? 0 : info.hashCode());
+        result = 31 * result + (int) (date ^ (date >>> 32));
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "EventImpl{" +
+                "type=" + type +
+                ", path='" + path + '\'' +
+                ", userID='" + userID + '\'' +
+                ", identifier='" + identifier + '\'' +
+                ", info=" + info +
+                ", date=" + date +
+                '}';
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ObservationManagerImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ObservationManagerImpl.java
new file mode 100644
index 0000000000..82974dfe8d
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ObservationManagerImpl.java
@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.observation.EventJournal;
+import javax.jcr.observation.EventListener;
+import javax.jcr.observation.EventListenerIterator;
+import javax.jcr.observation.ObservationManager;
+
+import com.google.common.base.Preconditions;
+import org.apache.jackrabbit.commons.iterator.EventListenerIteratorAdapter;
+import org.apache.jackrabbit.oak.api.Root;
+import org.apache.jackrabbit.oak.core.RootImpl;
+import org.apache.jackrabbit.oak.namepath.NamePathMapper;
+import org.apache.jackrabbit.oak.spi.observation.ChangeExtractor;
+
+public class ObservationManagerImpl implements ObservationManager {
+    private final RootImpl root;
+    private final NamePathMapper namePathMapper;
+    private final ScheduledExecutorService executor;
+    private final Map<EventListener, ChangeProcessor> processors = new HashMap<EventListener, ChangeProcessor>();
+    private final AtomicBoolean hasEvents = new AtomicBoolean(false);
+
+    public ObservationManagerImpl(Root root, NamePathMapper namePathMapper, ScheduledExecutorService executor) {
+        Preconditions.checkArgument(root instanceof RootImpl, "root must be of actual type RootImpl");
+        this.root = ((RootImpl) root);
+        this.namePathMapper = namePathMapper;
+        this.executor = executor;
+    }
+
+    public synchronized void dispose() {
+        for (ChangeProcessor processor : processors.values()) {
+            processor.stop();
+        }
+        processors.clear();
+    }
+
+    /**
+     * Determine whether events have been generated since the time this method has been called.
+     * @return  {@code true} if this {@code ObservationManager} instance has generated events
+     *          since the last time this method has been called, {@code false} otherwise.
+     */
+    public boolean hasEvents() {
+        return hasEvents.getAndSet(false);
+    }
+
+    @Override
+    public synchronized void addEventListener(EventListener listener, int eventTypes, String absPath,
+            boolean isDeep, String[] uuid, String[] nodeTypeName, boolean noLocal) throws RepositoryException {
+        ChangeFilter filter = new ChangeFilter(eventTypes, absPath, isDeep, uuid, nodeTypeName, noLocal);
+        ChangeProcessor processor = processors.get(listener);
+        if (processor == null) {
+            processor = new ChangeProcessor(this, listener, filter);
+            processors.put(listener, processor);
+            processor.start(executor);
+        } else {
+            processor.setFilter(filter);
+        }
+    }
+
+    @Override
+    public synchronized void removeEventListener(EventListener listener) {
+        ChangeProcessor processor = processors.remove(listener);
+
+        if (processor != null) {
+            processor.stop();
+        }
+    }
+
+    @Override
+    public EventListenerIterator getRegisteredEventListeners() throws RepositoryException {
+        return new EventListenerIteratorAdapter(processors.keySet());
+    }
+
+    @Override
+    public void setUserData(String userData) throws RepositoryException {
+        throw new UnsupportedRepositoryOperationException("User data not supported");
+    }
+
+    @Override
+    public EventJournal getEventJournal() throws RepositoryException {
+        throw new UnsupportedRepositoryOperationException();
+    }
+
+    @Override
+    public EventJournal getEventJournal(int eventTypes, String absPath, boolean isDeep, String[] uuid, String[]
+            nodeTypeName) throws RepositoryException {
+        throw new UnsupportedRepositoryOperationException();
+    }
+
+    //------------------------------------------------------------< internal >---
+
+    NamePathMapper getNamePathMapper() {
+        return namePathMapper;
+    }
+
+    ChangeExtractor getChangeExtractor() {
+        return root.getChangeExtractor();
+    }
+
+    void setHasEvents() {
+        hasEvents.set(true);
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/ChangeExtractor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/observation/ChangeExtractor.java
similarity index 90%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/api/ChangeExtractor.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/spi/observation/ChangeExtractor.java
index 05b608da10..3ed65affd5 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/ChangeExtractor.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/observation/ChangeExtractor.java
@@ -16,13 +16,13 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.apache.jackrabbit.oak.api;
+package org.apache.jackrabbit.oak.spi.observation;
 
 import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;
 
 /**
  * An instance of {@code ChangeExtractor} can be used to follow changes
- * done to a {@link Root} instance.
+ * done to a {@link org.apache.jackrabbit.oak.api.Root} instance.
  */
 public interface ChangeExtractor {
 
