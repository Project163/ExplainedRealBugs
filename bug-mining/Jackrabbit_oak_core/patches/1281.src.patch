diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java
index 297c6abc96..2c8aeabf36 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeState.java
@@ -56,6 +56,7 @@ import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.estimateMemoryUsage;
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;
 
 /**
@@ -375,6 +376,8 @@ public class DocumentNodeState extends AbstractNodeState implements CacheValue {
         PropertyState prop = properties.get(propertyName);
         if (prop == null) {
             return null;
+        } else if (prop instanceof DocumentPropertyState) {
+            return ((DocumentPropertyState) prop).getValue();
         }
         JsopBuilder builder = new JsopBuilder();
         new JsonSerializer(builder, store.getBlobSerializer()).serialize(prop);
@@ -448,15 +451,14 @@ public class DocumentNodeState extends AbstractNodeState implements CacheValue {
 
     @Override
     public int getMemory() {
-        int size = 212 + path.length() * 2;
+        int size = 164 + estimateMemoryUsage(path);
         // rough approximation for properties
         for (Map.Entry<String, PropertyState> entry : properties.entrySet()) {
             // name
-            size += 48 + entry.getKey().length() * 2;
+            size += estimateMemoryUsage(entry.getKey());
             PropertyState propState = entry.getValue();
             if (propState.getType() != Type.BINARY
                     && propState.getType() != Type.BINARIES) {
-                // assume binaries go into blob store
                 for (int i = 0; i < propState.count(); i++) {
                     // size() returns length of string
                     // overhead:
@@ -464,6 +466,12 @@ public class DocumentNodeState extends AbstractNodeState implements CacheValue {
                     // - 48 bytes per string
                     size += 56 + propState.size(i) * 2;
                 }
+            } else {
+                // calculate size based on blobId value
+                // referencing the binary in the blob store
+                // double the size because the parsed PropertyState
+                // will have a similarly sized blobId as well
+                size += estimateMemoryUsage(getPropertyAsString(entry.getKey())) * 2;
             }
         }
         return size;
@@ -602,7 +610,7 @@ public class DocumentNodeState extends AbstractNodeState implements CacheValue {
                 if (!children.isEmpty()) {
                     size = 114;
                     for (String c : children) {
-                        size += c.length() * 2 + 56;
+                        size += estimateMemoryUsage(c) + 8;
                     }
                 }
                 cachedMemory = size;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentPropertyState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentPropertyState.java
index 59e80e18f6..11a721a41b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentPropertyState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentPropertyState.java
@@ -102,6 +102,17 @@ final class DocumentPropertyState implements PropertyState {
         return parsed().count();
     }
 
+    /**
+     * Returns the raw un-parsed value as passed to the constructor of this
+     * property state.
+     *
+     * @return the raw un-parsed value.
+     */
+    @Nonnull
+    String getValue() {
+        return value;
+    }
+
     //------------------------------------------------------------< Object >--
 
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
index 4577c4b998..c18d29b366 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
@@ -137,11 +137,11 @@ public class Utils {
             if (e.getKey() instanceof Revision) {
                 size += 32;
             } else {
-                size += 48 + e.getKey().toString().length() * 2;
+                size += estimateMemoryUsage(e.getKey().toString());
             }
             Object o = e.getValue();
             if (o instanceof String) {
-                size += 48 + ((String) o).length() * 2;
+                size += estimateMemoryUsage((String) o);
             } else if (o instanceof Long) {
                 size += 16;
             } else if (o instanceof Boolean) {
@@ -171,6 +171,16 @@ public class Utils {
         return size;
     }
 
+    /**
+     * Estimates the memory usage of the given string.
+     *
+     * @param s the string to estimate.
+     * @return the estimated memory usage.
+     */
+    public static int estimateMemoryUsage(String s) {
+        return 48 + s.length() * 2;
+    }
+
     /**
      * Generate a unique cluster id, similar to the machine id field in MongoDB ObjectId objects.
      *
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MeasureMemory.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MeasureMemory.java
index fbf657d4a8..6cd1082483 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MeasureMemory.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/MeasureMemory.java
@@ -24,8 +24,14 @@ import java.util.concurrent.Callable;
 
 import com.mongodb.BasicDBObject;
 
+import org.apache.jackrabbit.oak.api.Blob;
 import org.apache.jackrabbit.oak.plugins.document.util.RevisionsKey;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
+import org.apache.jackrabbit.oak.plugins.memory.BinaryPropertyState;
+import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
+import org.apache.jackrabbit.oak.spi.commit.EmptyHook;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.junit.Test;
 
 /**
@@ -41,6 +47,22 @@ public class MeasureMemory {
     static final DocumentNodeStore STORE = new DocumentMK.Builder()
             .setAsyncDelay(0).getNodeStore();
 
+    static final Blob BLOB;
+    static final String BLOB_VALUE;
+
+    static {
+        try {
+            BLOB = STORE.createBlob(new RandomStream(1024 * 1024, 42));
+            NodeBuilder builder = STORE.getRoot().builder();
+            builder.child("binary").setProperty(new BinaryPropertyState("b", BLOB));
+            STORE.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+            NodeState n = STORE.getRoot().getChildNode("binary");
+            BLOB_VALUE = ((DocumentNodeState) n).getPropertyAsString("b");
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
     @Test
     public void overhead() throws Exception {
         measureMemory(new Callable<Object[]>() {
@@ -128,6 +150,17 @@ public class MeasureMemory {
         });
     }
 
+    @Test
+    public void nodeWithBinaryProperty() throws Exception {
+        measureMemory(new Callable<Object[]>() {
+            @Override
+            public Object[] call() {
+                DocumentNodeState n = generateNodeWithBinaryProperties(3);
+                return new Object[]{n, n.getMemory() + OVERHEAD};
+            }
+        });
+    }
+
     @Test
     public void revisionsKey() throws Exception {
         measureMemory(new Callable<Object[]>() {
@@ -176,6 +209,14 @@ public class MeasureMemory {
         return n;
     }
 
+    static DocumentNodeState generateNodeWithBinaryProperties(int propertyCount) {
+        DocumentNodeState n = generateNode(0);
+        for (int i = 0; i < propertyCount; i++) {
+            n.setProperty("binary" + i, new String(BLOB_VALUE));
+        }
+        return n;
+    }
+
     static BasicDBObject generateBasicObject(int propertyCount) {
         BasicDBObject n = new BasicDBObject(new String("_id"), new String(
                 "/hello/world"));
