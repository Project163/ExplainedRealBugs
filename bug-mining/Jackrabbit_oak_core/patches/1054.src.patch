diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java
index cefe1fcd4d..5acebdae6e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java
@@ -300,10 +300,7 @@ public class ClusterNodeInfo {
     private static ClusterNodeInfo createInstance(DocumentStore store, String machineId,
             String instanceId) {
         long now = getCurrentTime();
-        // keys between "0" and "a" includes all possible numbers
-        List<ClusterNodeInfoDocument> list = store.query(Collection.CLUSTER_NODES,
-                ClusterNodeInfoDocument.MIN_ID_VALUE, ClusterNodeInfoDocument.MAX_ID_VALUE,
-                Integer.MAX_VALUE);
+        List<ClusterNodeInfoDocument> list = ClusterNodeInfoDocument.all(store);
         int clusterNodeId = 0;
         int maxId = 0;
         ClusterNodeState state = ClusterNodeState.NONE;
@@ -364,11 +361,13 @@ public class ClusterNodeInfo {
      * to ensure the same cluster id is not re-used by a different instance.
      * The lease is only renewed when half of the lease time passed. That is,
      * with a lease time of 60 seconds, the lease is renewed every 30 seconds.
+     *
+     * @return {@code true} if the lease was renewed; {@code false} otherwise.
      */
-    public void renewLease() {
+    public boolean renewLease() {
         long now = getCurrentTime();
         if (now + leaseTime / 2 < leaseEndTime) {
-            return;
+            return false;
         }
         UpdateOp update = new UpdateOp("" + id, true);
         leaseEndTime = now + leaseTime;
@@ -380,6 +379,7 @@ public class ClusterNodeInfo {
             readWriteMode = mode;
             store.setReadWriteMode(mode);
         }
+        return true;
     }
 
     public void setLeaseTime(long leaseTime) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfoDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfoDocument.java
index 89cf347b7f..969f437ac3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfoDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfoDocument.java
@@ -16,6 +16,8 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.List;
+
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState;
 import static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState;
@@ -29,13 +31,13 @@ public class ClusterNodeInfoDocument extends Document {
      * All ClusterNodeInfoDocument ID value would be greater than this value
      * It can be used as startKey in DocumentStore#query methods
      */
-    public static final String MIN_ID_VALUE = "0";
+    private static final String MIN_ID_VALUE = "0";
 
     /**
      * All ClusterNodeInfoDocument ID value would be less than this value
      * It can be used as endKey in DocumentStore#query methods
      */
-    public static final String MAX_ID_VALUE = "a";
+    private static final String MAX_ID_VALUE = "a";
 
     public long getLeaseEndTime(){
         return checkNotNull((Long) get(ClusterNodeInfo.LEASE_END_KEY), "Lease End Time not set");
@@ -49,6 +51,25 @@ public class ClusterNodeInfoDocument extends Document {
         return getRecoveryState() == RecoverLockState.ACQUIRED;
     }
 
+    public int getClusterId() {
+        return Integer.parseInt(getId());
+    }
+
+    /**
+     * Returns all cluster node info documents currently available in the given
+     * document store.
+     *
+     * @param store the document store.
+     * @return list of cluster node info documents.
+     */
+    public static List<ClusterNodeInfoDocument> all(DocumentStore store) {
+        // keys between "0" and "a" includes all possible numbers
+        return store.query(Collection.CLUSTER_NODES,
+                MIN_ID_VALUE, MAX_ID_VALUE, Integer.MAX_VALUE);
+    }
+
+    //-----------------------< internal >---------------------------------------
+
     private ClusterNodeState getState(){
         return ClusterNodeState.fromString((String) get(ClusterNodeInfo.STATE));
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
index 1edf848b34..c7084705b1 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
@@ -30,6 +30,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.lang.ref.WeakReference;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -37,6 +38,7 @@ import java.util.NavigableSet;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
@@ -174,6 +176,14 @@ public final class DocumentNodeStore
      */
     private final int clusterId;
 
+    /**
+     * Map of inactive cluster nodes and when the cluster node was last seen
+     * as inactive.
+     * Key: clusterId, value: timeInMillis
+     */
+    private final ConcurrentMap<Integer, Long> inactiveClusterNodes
+            = new ConcurrentHashMap<Integer, Long>();
+
     /**
      * The comparator for revisions.
      */
@@ -1434,11 +1444,42 @@ public final class DocumentNodeStore
         }
     }
 
-    void renewClusterIdLease() {
-        if (clusterNodeInfo == null) {
-            return;
+    /**
+     * Renews the cluster lease if necessary.
+     *
+     * @return {@code true} if the lease was renewed; {@code false} otherwise.
+     */
+    boolean renewClusterIdLease() {
+        return clusterNodeInfo != null && clusterNodeInfo.renewLease();
+    }
+
+    /**
+     * Updates the info about inactive cluster nodes in
+     * {@link #inactiveClusterNodes}.
+     */
+    void updateClusterState() {
+        long now = clock.getTime();
+        Set<Integer> inactive = Sets.newHashSet();
+        for (ClusterNodeInfoDocument doc : ClusterNodeInfoDocument.all(store)) {
+            int cId = doc.getClusterId();
+            if (cId != this.clusterId && !doc.isActive()) {
+                inactive.add(cId);
+            }
+        }
+        inactiveClusterNodes.keySet().retainAll(inactive);
+        for (Integer clusterId : inactive) {
+            inactiveClusterNodes.putIfAbsent(clusterId, now);
         }
-        clusterNodeInfo.renewLease();
+    }
+
+    /**
+     * Returns the cluster nodes currently known to be inactive.
+     *
+     * @return a map with the cluster id as key and the time in millis when it
+     *          was first seen inactive.
+     */
+    Map<Integer, Long> getInactiveClusterNodes() {
+        return new HashMap<Integer, Long>(inactiveClusterNodes);
     }
 
     /**
@@ -1603,8 +1644,8 @@ public final class DocumentNodeStore
 
     private void diffManyChildren(JsopWriter w, String path, Revision fromRev, Revision toRev) {
         long minTimestamp = Math.min(
-                revisionComparator.getMinimumTimestamp(fromRev),
-                revisionComparator.getMinimumTimestamp(toRev));
+                revisionComparator.getMinimumTimestamp(fromRev, inactiveClusterNodes),
+                revisionComparator.getMinimumTimestamp(toRev, inactiveClusterNodes));
         long minValue = NodeDocument.getModifiedInSecs(minTimestamp);
         String fromKey = Utils.getKeyLowerLimit(path);
         String toKey = Utils.getKeyUpperLimit(path);
@@ -1839,7 +1880,9 @@ public final class DocumentNodeStore
 
         @Override
         protected void execute(@Nonnull DocumentNodeStore nodeStore) {
-            nodeStore.renewClusterIdLease();
+            if (nodeStore.renewClusterIdLease()) {
+                nodeStore.updateClusterState();
+            }
         }
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java
index 85c4ace7c7..9efaa4a56b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MissingLastRevSeeker.java
@@ -48,8 +48,7 @@ public class MissingLastRevSeeker {
      * @return the clusters
      */
     public Iterable<ClusterNodeInfoDocument> getAllClusters() {
-        return store.query(Collection.CLUSTER_NODES, ClusterNodeInfoDocument.MIN_ID_VALUE,
-                ClusterNodeInfoDocument.MAX_ID_VALUE, Integer.MAX_VALUE);
+        return ClusterNodeInfoDocument.all(store);
     }
     
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java
index d2075308d2..a9cff7eaf8 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java
@@ -19,6 +19,7 @@ package org.apache.jackrabbit.oak.plugins.document;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
+import java.util.Map;
 import java.util.TreeSet;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
@@ -538,12 +539,14 @@ public class Revision {
 
         /**
          * Returns the minimum timestamp of the most recent revisions from all
-         * cluster nodes as seen from the given {@code revision}.
+         * active cluster nodes as seen from the given {@code revision}.
          *
          * @param revision a revision.
+         * @param inactive map of cluster nodes considered inactive.
          * @return the minimum timestamp.
          */
-        public long getMinimumTimestamp(@Nonnull Revision revision) {
+        public long getMinimumTimestamp(@Nonnull Revision revision,
+                                        @Nonnull Map<Integer, Long> inactive) {
             long timestamp = checkNotNull(revision).getTimestamp();
             Revision seenAt = getRevisionSeen(revision);
             if (seenAt == null) {
@@ -557,7 +560,17 @@ public class Revision {
                     range = list.get(i);
                     if (range.seenAt.compareRevisionTimeThenClusterId(seenAt) <= 0) {
                         // found newest range older or equal the given seenAt
-                        timestamp = Math.min(timestamp, range.revision.getTimestamp());
+                        // check if the cluster node is still active
+                        Long inactiveSince = inactive.get(range.revision.getClusterId());
+                        if (inactiveSince != null
+                                && revision.getTimestamp() > inactiveSince
+                                && range.revision.getTimestamp() < inactiveSince) {
+                            // ignore, because the revision is after the
+                            // cluster node became inactive and the most recent
+                            // range is before it became inactive
+                        } else {
+                            timestamp = Math.min(timestamp, range.revision.getTimestamp());
+                        }
                         break;
                     }
                 }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
index 49f07cffaf..3db5767c80 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
@@ -614,6 +614,31 @@ public class DocumentNodeStoreTest {
         assertTrue(diff.modified.contains("/test"));
         assertEquals(1, diff.added.size());
         assertTrue(diff.added.contains("/test/foo"));
+
+        ns1.dispose();
+        ns2.dispose();
+    }
+
+    @Test
+    public void updateClusterState() {
+        DocumentStore docStore = new MemoryDocumentStore();
+        DocumentNodeStore ns1 = new DocumentMK.Builder().setAsyncDelay(0)
+                .setDocumentStore(docStore).getNodeStore();
+        DocumentNodeStore ns2 = new DocumentMK.Builder().setAsyncDelay(0)
+                .setDocumentStore(docStore).getNodeStore();
+
+        assertEquals(0, ns1.getInactiveClusterNodes().size());
+        assertEquals(0, ns2.getInactiveClusterNodes().size());
+
+        ns1.dispose();
+
+        ns2.updateClusterState();
+
+        Map<Integer, Long> inactive = ns2.getInactiveClusterNodes();
+        assertEquals(1, inactive.size());
+        assertEquals(1, (int) inactive.keySet().iterator().next());
+
+        ns2.dispose();
     }
 
     private static class TestHook extends EditorHook {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java
index fc88f14c26..2f9c71a15f 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/RevisionTest.java
@@ -20,6 +20,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
@@ -33,6 +34,7 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.Uninterruptibles;
@@ -457,32 +459,41 @@ public class RevisionTest {
 
     @Test
     public void getMinimumTimestamp() {
+        Map<Integer, Long> inactive = Maps.newHashMap();
         RevisionComparator comp = new RevisionComparator(1);
 
         Revision r11 = new Revision(1, 0, 1);
         comp.add(r11, new Revision(1, 0, 0));
 
-        assertEquals(1, comp.getMinimumTimestamp(r11));
+        assertEquals(1, comp.getMinimumTimestamp(r11, inactive));
 
         Revision r21 = new Revision(1, 0, 2);
         comp.add(r21, new Revision(2, 0, 0));
 
-        assertEquals(1, comp.getMinimumTimestamp(r21));
+        assertEquals(1, comp.getMinimumTimestamp(r21, inactive));
 
         Revision r13 = new Revision(3, 0, 1);
         comp.add(r13, new Revision(3, 0, 0));
 
-        assertEquals(1, comp.getMinimumTimestamp(r13));
+        assertEquals(1, comp.getMinimumTimestamp(r13, inactive));
 
         Revision r24 = new Revision(4, 0, 2);
         comp.add(r24, new Revision(4, 0, 0));
 
-        assertEquals(3, comp.getMinimumTimestamp(r24));
+        assertEquals(3, comp.getMinimumTimestamp(r24, inactive));
 
         Revision r15 = new Revision(5, 0, 1);
         comp.add(r15, new Revision(5, 0, 0));
 
-        assertEquals(4, comp.getMinimumTimestamp(r15));
+        assertEquals(4, comp.getMinimumTimestamp(r15, inactive));
+
+        // simulate cluster node 2 is stopped
+        inactive.put(2, 6L);
+
+        Revision r17 = new Revision(7, 0, 1);
+        comp.add(r17, new Revision(7, 0, 0));
+
+        assertEquals(7, comp.getMinimumTimestamp(r17, inactive));
     }
 
 }
