diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java
index 510b2f5b73..6e7e940868 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java
@@ -18,10 +18,12 @@ package org.apache.jackrabbit.oak.plugins.document;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.filter;
 import static com.google.common.collect.Iterables.transform;
 
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
+import java.util.Collections;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.Set;
@@ -34,6 +36,7 @@ import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import com.google.common.base.Function;
+import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 
@@ -256,6 +259,36 @@ class Branch {
         return checkNotNull(rev).equals(commits.lastKey());
     }
 
+    /**
+     * Returns the modified paths since the base revision of this branch until
+     * the given branch revision {@code r} (inclusive).
+     *
+     * @param r a commit on this branch.
+     * @return modified paths until {@code r}.
+     * @throws IllegalArgumentException if r is not a branch revision.
+     */
+    Iterable<String> getModifiedPathsUntil(@Nonnull final Revision r) {
+        checkArgument(checkNotNull(r).isBranch(),
+                "Not a branch revision: %s", r);
+        if (!commits.containsKey(r)) {
+            return Collections.emptyList();
+        }
+        Iterable<Iterable<String>> paths = transform(filter(commits.entrySet(),
+                new Predicate<Map.Entry<Revision, BranchCommit>>() {
+            @Override
+            public boolean apply(Map.Entry<Revision, BranchCommit> input) {
+                return !input.getValue().isRebase()
+                        && input.getKey().compareRevisionTime(r) <= 0;
+            }
+        }), new Function<Map.Entry<Revision, BranchCommit>, Iterable<String>>() {
+            @Override
+            public Iterable<String> apply(Map.Entry<Revision, BranchCommit> input) {
+                return input.getValue().getModifiedPaths();
+            }
+        });
+        return Iterables.concat(paths);
+    }
+
     /**
      * Information about a commit within a branch.
      */
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
index 8511e3713b..3192f88302 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
@@ -2292,9 +2292,9 @@ public final class DocumentNodeStore
         addPathsForDiff(path, paths, getPendingModifications().getPaths(minRev));
         for (Revision r : new Revision[]{fromRev, toRev}) {
             if (r.isBranch()) {
-                BranchCommit c = getBranches().getBranchCommit(r);
-                if (c != null) {
-                    addPathsForDiff(path, paths, c.getModifiedPaths());
+                Branch b = branches.getBranch(r);
+                if (b != null) {
+                    addPathsForDiff(path, paths, b.getModifiedPathsUntil(r));
                 }
             }
         }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/BranchTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/BranchTest.java
new file mode 100644
index 0000000000..f85d22e784
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/BranchTest.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document;
+
+import com.google.common.collect.Sets;
+
+import org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class BranchTest {
+
+    @Test
+    public void getModifiedPathsUntil() {
+        UnmergedBranches branches = new UnmergedBranches(StableRevisionComparator.INSTANCE);
+
+        Revision base = Revision.newRevision(1);
+        Revision c1 = Revision.newRevision(1).asBranchRevision();
+        Branch b = branches.create(base, c1, null);
+
+        BranchCommit bc1 = b.getCommit(c1);
+        bc1.track("/foo");
+
+        Revision c2 = Revision.newRevision(1).asBranchRevision();
+        b.addCommit(c2);
+        BranchCommit bc2 = b.getCommit(c2);
+        bc2.track("/bar");
+
+        Revision c3 = Revision.newRevision(1).asBranchRevision();
+        b.rebase(c3, Revision.newRevision(1));
+
+        Revision c4 = Revision.newRevision(1).asBranchRevision();
+        b.addCommit(c4);
+        BranchCommit bc4 = b.getCommit(c4);
+        bc4.track("/baz");
+
+        Revision c5 = Revision.newRevision(1).asBranchRevision();
+
+        try {
+            b.getModifiedPathsUntil(Revision.newRevision(1));
+            fail("Must fail with IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // expected
+        }
+
+        assertModifiedPaths(b.getModifiedPathsUntil(c1), "/foo");
+        assertModifiedPaths(b.getModifiedPathsUntil(c2), "/foo", "/bar");
+        assertModifiedPaths(b.getModifiedPathsUntil(c3), "/foo", "/bar");
+        assertModifiedPaths(b.getModifiedPathsUntil(c4), "/foo", "/bar", "/baz");
+        assertModifiedPaths(b.getModifiedPathsUntil(c5));
+    }
+
+    private void assertModifiedPaths(Iterable<String> actual, String... expected) {
+        assertEquals(Sets.newHashSet(expected), Sets.newHashSet(actual));
+    }
+}
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
index 02b012487a..ed97e4cae5 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
@@ -98,7 +98,6 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.apache.jackrabbit.oak.stats.Clock;
 import org.junit.After;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.slf4j.Logger;
@@ -2364,7 +2363,6 @@ public class DocumentNodeStoreTest {
     }
 
     // OAK-3608
-    @Ignore("OAK-3608")
     @Test
     public void compareOnBranch() throws Exception {
         long modifiedResMillis = SECONDS.toMillis(MODIFIED_IN_SECS_RESOLUTION);
