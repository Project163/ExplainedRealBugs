diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java
index 97fa21eb74..b9cbc85bde 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java
@@ -16,7 +16,10 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
 
 import javax.annotation.CheckForNull;
 
@@ -35,6 +38,7 @@ import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.slf4j.Logger;
@@ -139,6 +143,74 @@ public class ClusterConflictTest {
         }
     }
 
+    // OAK-3859
+    @Ignore("OAK-3859")
+    @Test
+    public void mixedConflictAndCollision() throws Exception {
+        NodeBuilder b1 = ns1.getRoot().builder();
+        b1.child("test");
+        merge(ns1, b1);
+
+        ns1.runBackgroundOperations();
+        ns2.runBackgroundOperations();
+
+        AtomicLong counter = new AtomicLong();
+        final List<Exception> exceptions = Collections.synchronizedList(
+                new ArrayList<Exception>());
+        // the writers perform conflicting changes
+        List<Thread> writers = Lists.newArrayList();
+        writers.add(new Thread(new Writer(exceptions, ns1, counter)));
+        writers.add(new Thread(new Writer(exceptions, ns1, counter)));
+        for (Thread t : writers) {
+            t.start();
+        }
+
+        for (int i = 0; i < 10; i++) {
+            NodeBuilder b21 = ns2.getRoot().builder();
+            // this change does not conflict with changes on ns1 but
+            // will be considered a collision
+            b21.child("test").setProperty("q", 1);
+            merge(ns2, b21);
+        }
+
+        for (Thread t : writers) {
+            t.join(10000);
+        }
+
+        for (Exception e : exceptions) {
+            throw e;
+        }
+    }
+
+    private static class Writer implements Runnable {
+
+        private final List<Exception> exceptions;
+        private final NodeStore ns;
+        private final AtomicLong counter;
+
+        public Writer(List<Exception> exceptions,
+                      NodeStore ns,
+                      AtomicLong counter) {
+            this.exceptions = exceptions;
+            this.ns = ns;
+            this.counter = counter;
+        }
+
+        @Override
+        public void run() {
+            try {
+                for (int i = 0; i < 200; i++) {
+                    NodeBuilder b = ns.getRoot().builder();
+                    b.child("test").setProperty("p", counter.incrementAndGet());
+                    merge(ns, b);
+                }
+            } catch (CommitFailedException e) {
+                e.printStackTrace();
+                exceptions.add(e);
+            }
+        }
+    }
+
     private static class TestHook extends EditorHook {
 
         TestHook() {
