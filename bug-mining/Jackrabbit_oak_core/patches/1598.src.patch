diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
index 26ef91f226..55756167c0 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
@@ -392,14 +392,10 @@ public final class DocumentNodeStore
      * apply method will throw an IllegalArgumentException if the String is
      * malformed.
      */
-    private final Predicate<String> isBinary = new Predicate<String>() {
+    private final Function<String, Long> binarySize = new Function<String, Long>() {
         @Override
-        public boolean apply(@Nullable String input) {
-            if (input == null) {
-                return false;
-            }
-            return new DocumentPropertyState(DocumentNodeStore.this,
-                    "p", input).getType().tag() == PropertyType.BINARY;
+        public Long apply(@Nullable String input) {
+            return getBinarySize(input);
         }
     };
 
@@ -2065,7 +2061,7 @@ public final class DocumentNodeStore
             if (doc == null) {
                 continue;
             }
-            for (UpdateOp op : doc.split(this, head, isBinary)) {
+            for (UpdateOp op : doc.split(this, head, binarySize)) {
                 NodeDocument before = null;
                 if (!op.isNew() ||
                         !store.create(Collection.NODES, Collections.singletonList(op))) {
@@ -2110,6 +2106,33 @@ public final class DocumentNodeStore
 
     //-----------------------------< internal >---------------------------------
 
+    /**
+     * Returns the binary size of a property value represented as a JSON or
+     * {@code -1} if the property is not of type binary.
+     *
+     * @param json the property value.
+     * @return the size of the referenced binary value(s); otherwise {@code -1}.
+     */
+    private long getBinarySize(@Nullable String json) {
+        if (json == null) {
+            return -1;
+        }
+        PropertyState p = new DocumentPropertyState(
+                DocumentNodeStore.this, "p", json);
+        if (p.getType().tag() != PropertyType.BINARY) {
+            return -1;
+        }
+        long size = 0;
+        if (p.isArray()) {
+            for (int i = 0; i < p.count(); i++) {
+                size += p.size(i);
+            }
+        } else {
+            size = p.size();
+        }
+        return size;
+    }
+
     private JournalEntry newJournalEntry() {
         return new JournalEntry(store, true);
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
index 573030f2bc..48e56900a5 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
@@ -1205,17 +1205,16 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
      * @param context the revision context.
      * @param head    the head revision before this document was retrieved from
      *                the document store.
-     * @param isBinaryValue a predicate that returns {@code true} if the given
-     *                      String value is considered a binary; {@code false}
-     *                      otherwise.
+     * @param binarySize a function that returns the binary size of the given
+     *                   JSON property value String.
      * @return the split operations.
      */
     @Nonnull
     public Iterable<UpdateOp> split(@Nonnull RevisionContext context,
                                     @Nonnull RevisionVector head,
-                                    @Nonnull Predicate<String> isBinaryValue) {
+                                    @Nonnull Function<String, Long> binarySize) {
         return SplitOperations.forDocument(this, context, head,
-                isBinaryValue, NUM_REVS_THRESHOLD);
+                binarySize, NUM_REVS_THRESHOLD);
     }
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java
index ac86537fdf..149903c5a9 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/SplitOperations.java
@@ -35,6 +35,7 @@ import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.base.Supplier;
 import com.google.common.base.Suppliers;
@@ -44,6 +45,7 @@ import com.google.common.collect.Sets;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.any;
+import static com.google.common.collect.Iterables.transform;
 import static com.google.common.collect.Sets.filter;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD;
@@ -66,6 +68,13 @@ class SplitOperations {
 
     private static final Logger LOG = LoggerFactory.getLogger(SplitOperations.class);
     private static final int GARBAGE_LIMIT = Integer.getInteger("oak.documentMK.garbage.limit", 1000);
+    private static final Predicate<Long> BINARY_FOR_SPLIT_THRESHOLD = new Predicate<Long>() {
+        @Override
+        public boolean apply(Long input) {
+            // only force trigger split for binaries bigger than 4k
+            return input > 4096;
+        }
+    };
     private static final DocumentStore STORE = new MemoryDocumentStore();
 
     private final NodeDocument doc;
@@ -73,7 +82,7 @@ class SplitOperations {
     private final String id;
     private final Revision headRevision;
     private final RevisionContext context;
-    private final Predicate<String> isBinaryValue;
+    private final Function<String, Long> binarySize;
     private final int numRevsThreshold;
     private Revision high;
     private Revision low;
@@ -92,11 +101,11 @@ class SplitOperations {
     private SplitOperations(@Nonnull final NodeDocument doc,
                             @Nonnull final RevisionContext context,
                             @Nonnull final RevisionVector headRev,
-                            @Nonnull final Predicate<String> isBinaryValue,
+                            @Nonnull final Function<String, Long> binarySize,
                             int numRevsThreshold) {
         this.doc = checkNotNull(doc);
         this.context = checkNotNull(context);
-        this.isBinaryValue = checkNotNull(isBinaryValue);
+        this.binarySize = checkNotNull(binarySize);
         this.path = doc.getPath();
         this.id = doc.getId();
         this.headRevision = checkNotNull(headRev).getRevision(context.getClusterId());
@@ -123,9 +132,8 @@ class SplitOperations {
      * @param context the revision context.
      * @param headRevision the head revision before the document was retrieved
      *                     from the document store.
-     * @param isBinaryValue a predicate that returns {@code true} if the given
-     *                      String value is considered a binary; {@code false}
-     *                      otherwise.
+     * @param binarySize a function that returns the binary size of the given
+     *                   JSON property value String.
      * @param numRevsThreshold only split off at least this number of revisions.
      * @return list of update operations. An empty list indicates the document
      *          does not require a split.
@@ -136,14 +144,14 @@ class SplitOperations {
     static List<UpdateOp> forDocument(@Nonnull NodeDocument doc,
                                       @Nonnull RevisionContext context,
                                       @Nonnull RevisionVector headRevision,
-                                      @Nonnull Predicate<String> isBinaryValue,
+                                      @Nonnull Function<String, Long> binarySize,
                                       int numRevsThreshold) {
         if (doc.isSplitDocument()) {
             throw new IllegalArgumentException(
                     "Not a main document: " + doc.getId());
         }
         return new SplitOperations(doc, context, headRevision,
-                isBinaryValue, numRevsThreshold).create();
+                binarySize, numRevsThreshold).create();
 
     }
 
@@ -211,7 +219,7 @@ class SplitOperations {
                 Revision r = splitMap.lastKey();
                 splitMap.remove(r);
                 splitRevs.addAll(splitMap.keySet());
-                hasBinaryToSplit |= hasBinaryProperty(splitMap.values())
+                hasBinaryToSplit |= hasBinaryPropertyForSplit(splitMap.values())
                         && nodeExistsAtHeadRevision.get();
                 mostRecentRevs.add(r);
             }
@@ -225,8 +233,8 @@ class SplitOperations {
         }
     }
 
-    private boolean hasBinaryProperty(Iterable<String> values) {
-        return doc.hasBinary() && any(values, isBinaryValue);
+    private boolean hasBinaryPropertyForSplit(Iterable<String> values) {
+        return doc.hasBinary() && any(transform(values, binarySize), BINARY_FOR_SPLIT_THRESHOLD);
     }
 
     /**
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionWithSplitTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionWithSplitTest.java
index f5a1b107ee..dc3266cdbd 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionWithSplitTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionWithSplitTest.java
@@ -19,7 +19,6 @@ package org.apache.jackrabbit.oak.plugins.document;
 import java.util.Collections;
 import java.util.List;
 
-import com.google.common.base.Predicates;
 import com.mongodb.DB;
 
 import org.apache.jackrabbit.oak.api.CommitFailedException;
@@ -32,8 +31,8 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import static com.google.common.base.Predicates.alwaysFalse;
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
+import static org.apache.jackrabbit.oak.plugins.document.TestUtils.NO_BINARY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -94,7 +93,7 @@ public class CollisionWithSplitTest extends AbstractMongoConnectionTest {
         DocumentStore store = ns1.getDocumentStore();
         NodeDocument doc = Utils.getRootDocument(store);
         List<UpdateOp> ops = SplitOperations.forDocument(doc, ns1,
-                ns1.getHeadRevision(), Predicates.<String>alwaysFalse(), NUM_NODES);
+                ns1.getHeadRevision(), NO_BINARY, NUM_NODES);
         assertFalse(ops.isEmpty());
         for (UpdateOp op : ops) {
             if (!op.isNew() ||
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java
index 4b2a3a37b4..094820923e 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java
@@ -28,7 +28,6 @@ import java.util.TreeSet;
 import javax.annotation.Nonnull;
 
 import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 
@@ -57,6 +56,7 @@ import static org.apache.jackrabbit.oak.plugins.document.MongoBlobGCTest.randomS
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREV_SPLIT_FACTOR;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType;
+import static org.apache.jackrabbit.oak.plugins.document.TestUtils.NO_BINARY;
 import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation.Type.REMOVE_MAP_ENTRY;
 import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation.Type.SET_MAP_ENTRY;
 import static org.apache.jackrabbit.oak.plugins.memory.BinaryPropertyState.binaryProperty;
@@ -541,7 +541,7 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         assertNotNull(doc);
         List<UpdateOp> splitOps = Lists.newArrayList(doc.split(
                 mk.getNodeStore(), mk.getNodeStore().getHeadRevision(),
-                Predicates.<String>alwaysFalse()));
+                NO_BINARY));
         assertEquals(2, splitOps.size());
         // first update op is for the new intermediate doc
         op = splitOps.get(0);
@@ -598,7 +598,7 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         // the second most recent revision
         List<UpdateOp> splitOps = Lists.newArrayList(doc.split(
                 mk.getNodeStore(), mk.getNodeStore().getHeadRevision(),
-                Predicates.<String>alwaysFalse()));
+                NO_BINARY));
         assertEquals(2, splitOps.size());
         String prevId = Utils.getPreviousIdFor("/test", revs.get(revs.size() - 2), 0);
         assertEquals(prevId, splitOps.get(0).getId());
@@ -676,7 +676,7 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         doc.put(NodeDocument.SD_TYPE, NodeDocument.SplitDocType.DEFAULT.type);
         RevisionVector head = mk.getNodeStore().getHeadRevision();
         SplitOperations.forDocument(doc, DummyRevisionContext.INSTANCE, head,
-                Predicates.<String>alwaysFalse(), NUM_REVS_THRESHOLD);
+                NO_BINARY, NUM_REVS_THRESHOLD);
     }
 
     @Test
@@ -859,7 +859,7 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
                 RevisionVector head = ns.getHeadRevision();
                 NodeDocument doc = store.find(NODES, id);
                 List<UpdateOp> ops = SplitOperations.forDocument(doc, rc, head,
-                        Predicates.<String>alwaysFalse(), NUM_REVS_THRESHOLD);
+                        NO_BINARY, NUM_REVS_THRESHOLD);
                 Set<Revision> removed = Sets.newHashSet();
                 Set<Revision> added = Sets.newHashSet();
                 for (UpdateOp op : ops) {
@@ -905,7 +905,8 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         builder.child("foo");
         merge(ns, builder);
 
-        PropertyState binary = binaryProperty("p", "value".getBytes());
+        // use more than 4k of binary data (OAK-5205)
+        PropertyState binary = binaryProperty("p", randomBytes(5 * 1024));
 
         for (int i = 0; i < 10; i++) {
             builder = ns.getRoot().builder();
@@ -926,7 +927,8 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         DocumentStore store = mk.getDocumentStore();
         DocumentNodeStore ns = mk.getNodeStore();
         NodeBuilder builder = ns.getRoot().builder();
-        PropertyState binary = binaryProperty("p", "value".getBytes());
+        // use more than 4k of binary data (OAK-5205)
+        PropertyState binary = binaryProperty("p", randomBytes(5 * 1024));
         builder.child("foo").setProperty(binary);
         merge(ns, builder);
 
@@ -953,6 +955,30 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         assertEquals(1, prevDocs.size());
     }
 
+    // OAK-5205
+    @Test
+    public void noSplitForSmallBinary() throws Exception {
+        DocumentStore store = mk.getDocumentStore();
+        DocumentNodeStore ns = mk.getNodeStore();
+        NodeBuilder builder = ns.getRoot().builder();
+        builder.child("foo");
+        merge(ns, builder);
+
+        for (int i = 0; i < 10; i++) {
+            builder = ns.getRoot().builder();
+            builder.child("foo").setProperty(
+                    binaryProperty("p", ("value" + i).getBytes()));
+            merge(ns, builder);
+            ns.runBackgroundOperations();
+        }
+
+        NodeDocument foo = store.find(NODES, Utils.getIdFromPath("/foo"));
+        assertNotNull(foo);
+        List<NodeDocument> prevDocs = copyOf(foo.getAllPreviousDocs());
+        // must not create split documents for small binaries less 4k
+        assertEquals(0, prevDocs.size());
+    }
+
     private static class TestRevisionContext implements RevisionContext {
 
         private final RevisionContext rc;
@@ -1007,4 +1033,11 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
             }
         }
     }
+
+    private byte[] randomBytes(int num) {
+        Random random = new Random(42);
+        byte[] data = new byte[num];
+        random.nextBytes(data);
+        return data;
+    }
 }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/NodeDocumentTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/NodeDocumentTest.java
index 3247ac6d07..72f5e7fe9e 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/NodeDocumentTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/NodeDocumentTest.java
@@ -24,7 +24,6 @@ import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 
-import com.google.common.base.Predicates;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
@@ -44,6 +43,7 @@ import org.junit.Test;
 import static com.google.common.collect.Sets.newHashSet;
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS;
+import static org.apache.jackrabbit.oak.plugins.document.TestUtils.NO_BINARY;
 import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getRootDocument;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -71,7 +71,7 @@ public class NodeDocumentTest {
         }
         UpdateUtils.applyChanges(doc, op);
         RevisionVector head = DummyRevisionContext.INSTANCE.getHeadRevision();
-        doc.split(DummyRevisionContext.INSTANCE, head, Predicates.<String>alwaysFalse());
+        doc.split(DummyRevisionContext.INSTANCE, head, NO_BINARY);
     }
 
     @Test
@@ -205,7 +205,7 @@ public class NodeDocumentTest {
                 RevisionVector head = ns.getHeadRevision();
                 for (UpdateOp op : SplitOperations.forDocument(
                         getRootDocument(store), ns, head,
-                        Predicates.<String>alwaysFalse(), 2)) {
+                        NO_BINARY, 2)) {
                     store.createOrUpdate(NODES, op);
                 }
             }
@@ -321,7 +321,7 @@ public class NodeDocumentTest {
                 NodeDocument doc = ns.getDocumentStore().find(
                         NODES, Utils.getIdFromPath("/test"));
                 for (UpdateOp op : SplitOperations.forDocument(
-                        doc, ns, head, Predicates.<String>alwaysFalse(), 2)) {
+                        doc, ns, head, NO_BINARY, 2)) {
                     store.createOrUpdate(NODES, op);
                 }
             }
@@ -572,7 +572,7 @@ public class NodeDocumentTest {
         NodeDocument test = ns2.getDocumentStore().find(NODES, testId);
         assertNotNull(test);
         List<UpdateOp> ops = SplitOperations.forDocument(test, ns2,
-                ns2.getHeadRevision(), Predicates.<String>alwaysFalse(), 2);
+                ns2.getHeadRevision(), NO_BINARY, 2);
         assertEquals(2, ops.size());
         for (UpdateOp op : ops) {
             ns2.getDocumentStore().createOrUpdate(NODES, op);
@@ -588,7 +588,7 @@ public class NodeDocumentTest {
             merge(ns1, b1);
             test = ns1.getDocumentStore().find(NODES, testId);
             for (UpdateOp op : SplitOperations.forDocument(test, ns1,
-                    ns1.getHeadRevision(), Predicates.<String>alwaysFalse(), 3)) {
+                    ns1.getHeadRevision(), NO_BINARY, 3)) {
                 ns1.getDocumentStore().createOrUpdate(NODES, op);
             }
             headRevs.add(ns1.getHeadRevision());
@@ -710,7 +710,7 @@ public class NodeDocumentTest {
                 RevisionVector head = ns.getHeadRevision();
                 for (UpdateOp op : SplitOperations.forDocument(
                         getRootDocument(store), ns, head,
-                        Predicates.<String>alwaysFalse(), 2)) {
+                        NO_BINARY, 2)) {
                     store.createOrUpdate(NODES, op);
                 }
             }
@@ -736,7 +736,7 @@ public class NodeDocumentTest {
                 RevisionVector head = ns.getHeadRevision();
                 for (UpdateOp op : SplitOperations.forDocument(
                         getRootDocument(store), ns, head,
-                        Predicates.<String>alwaysFalse(), 2)) {
+                        NO_BINARY, 2)) {
                     store.createOrUpdate(NODES, op);
                 }
             }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/PreviousDocCacheTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/PreviousDocCacheTest.java
index a9438a70fc..712cf50214 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/PreviousDocCacheTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/PreviousDocCacheTest.java
@@ -16,7 +16,6 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
-import com.google.common.base.Predicates;
 import com.google.common.collect.Iterators;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.cache.CacheStats;
@@ -31,6 +30,7 @@ import java.util.Collections;
 import java.util.List;
 
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
+import static org.apache.jackrabbit.oak.plugins.document.TestUtils.NO_BINARY;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -106,7 +106,7 @@ public class PreviousDocCacheTest extends AbstractMongoConnectionTest {
         DocumentStore store = ns.getDocumentStore();
         NodeDocument doc = Utils.getRootDocument(store);
         List<UpdateOp> ops = SplitOperations.forDocument(doc,
-                ns, ns.getHeadRevision(), Predicates.<String>alwaysFalse(),
+                ns, ns.getHeadRevision(), NO_BINARY,
                 splitDocLimit/2);
         assertFalse(ops.isEmpty());
         for (UpdateOp op : ops) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/TestUtils.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/TestUtils.java
index 096e29626e..174a892ecd 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/TestUtils.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/TestUtils.java
@@ -20,6 +20,8 @@ import java.util.Map;
 
 import javax.annotation.Nullable;
 
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
 import com.google.common.base.Predicate;
 
 import org.apache.jackrabbit.oak.api.CommitFailedException;
@@ -30,6 +32,8 @@ import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 
+import static com.google.common.base.Functions.compose;
+import static com.google.common.base.Functions.constant;
 import static org.junit.Assert.fail;
 
 public class TestUtils {
@@ -41,6 +45,8 @@ public class TestUtils {
         }
     };
 
+    public static final Function<String, Long> NO_BINARY = compose(constant(-1L), Functions.<String>identity());
+
     /**
      * Returns {@code true} if the given {@code update} performs a
      * {@code _lastRev} update.
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollectorIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollectorIT.java
index e6faff2107..732c65d552 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollectorIT.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollectorIT.java
@@ -39,10 +39,10 @@ import static org.apache.jackrabbit.oak.commons.FixturesHelper.Fixture.DOCUMENT_
 import static org.apache.jackrabbit.oak.commons.FixturesHelper.Fixture.DOCUMENT_RDB;
 import static org.apache.jackrabbit.oak.commons.FixturesHelper.getFixtures;
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
-import static org.apache.jackrabbit.oak.plugins.document.Document.ID;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREV_SPLIT_FACTOR;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType;
+import static org.apache.jackrabbit.oak.plugins.document.TestUtils.NO_BINARY;
 import static org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector.VersionGCStats;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -54,7 +54,6 @@ import static org.junit.Assume.assumeTrue;
 
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
@@ -548,7 +547,7 @@ public class VersionGarbageCollectorIT {
             RevisionVector head = store.getHeadRevision();
             for (UpdateOp op : SplitOperations.forDocument(
                     ds.find(NODES, Utils.getIdFromPath("/foo")), store, head,
-                    Predicates.<String>alwaysFalse(), 2)) {
+                    NO_BINARY, 2)) {
                 ds.createOrUpdate(NODES, op);
             }
             clock.waitUntil(clock.getTime() + TimeUnit.MINUTES.toMillis(1));
