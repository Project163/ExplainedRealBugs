diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java
index c2f4d140f4..7dce8a1587 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidator.java
@@ -279,13 +279,23 @@ abstract class CacheInvalidator {
                 //key is referring to a split document
                 result.cacheSize++;
                 CachedNodeDocument doc = e.getValue();
+                String path;
                 if (doc == NodeDocument.NULL) {
-                    // we only need to process documents that exist
-                    continue;
+                    String id = e.getKey().toString();
+                    if (Utils.isIdFromLongPath(id)) {
+                        LOG.debug("Negative cache entry with long path {}. Invalidating", id);
+                        documentStore.invalidateCache(Collection.NODES, id);
+                        path = null;
+                    } else {
+                        path = Utils.getPathFromId(id);
+                    }
+                } else {
+                    path = doc.getPath();
                 }
-                String path = doc.getPath();
-                for (String name : PathUtils.elements(path)) {
-                    current = current.child(name);
+                if (path != null) {
+                    for (String name : PathUtils.elements(path)) {
+                        current = current.child(name);
+                    }
                 }
             }
             return root;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
index 9cc65dae34..f2ed6bda93 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java
@@ -260,12 +260,17 @@ public class Utils {
         }
         return true;
     }
+    
+    public static boolean isIdFromLongPath(String id) {
+        int index = id.indexOf(':');
+        return id.charAt(index + 1) == 'h';
+    }
 
     public static String getPathFromId(String id) {
-        int index = id.indexOf(':');
-        if (id.charAt(index + 1) == 'h') {
+        if (isIdFromLongPath(id)) {
             throw new IllegalArgumentException("Id is hashed: " + id);
         }
+        int index = id.indexOf(':');
         return id.substring(index + 1);
     }
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java
index e433ddd613..61535fecca 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheInvalidationIT.java
@@ -41,6 +41,8 @@ import org.junit.Test;
 
 import static org.apache.jackrabbit.oak.plugins.document.mongo.CacheInvalidator.InvalidationResult;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public class CacheInvalidationIT extends AbstractMongoConnectionTest {
 
@@ -134,6 +136,43 @@ public class CacheInvalidationIT extends AbstractMongoConnectionTest {
         assertEquals(4, result.cacheEntriesProcessedCount);
     }
 
+    @Test
+    public void testCacheInvalidationHierarchicalNotExist()
+            throws CommitFailedException {
+
+        NodeBuilder b2 = getRoot(c2).builder();
+        // we create x/other, so that x is known to have a child node
+        b2.child("x").child("other");
+        b2.child("y");
+        c2.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        c2.runBackgroundOperations();
+        c1.runBackgroundOperations();
+
+        // we check for the existence of "x/futureX", which
+        // should create a negative entry in the cache
+        NodeState x = getRoot(c1).getChildNode("x");
+        assertTrue(x.exists());
+        assertFalse(x.getChildNode("futureX").exists());
+        // we don't check for the existence of "y/futureY"
+        NodeState y = getRoot(c1).getChildNode("y");
+        assertTrue(y.exists());
+
+        // now we add both "futureX" and "futureY"
+        // in the other cluster node
+        b2.child("x").child("futureX").setProperty("z", "1");
+        c2.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        b2.child("y").child("futureY").setProperty("z", "2");
+        c2.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        
+        c2.runBackgroundOperations();
+        c1.runBackgroundOperations();
+
+        // both nodes should now be visible
+        assertTrue(getRoot(c1).getChildNode("y").getChildNode("futureY").exists());
+        assertTrue(getRoot(c1).getChildNode("x").getChildNode("futureX").exists());
+
+    }
+
     @Test
     public void testCacheInvalidationLinear() throws CommitFailedException {
         final int totalPaths = createScenario();
