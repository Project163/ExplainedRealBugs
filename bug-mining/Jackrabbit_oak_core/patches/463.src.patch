diff --git a/oak-core/pom.xml b/oak-core/pom.xml
index edc4d814c2..7d20df3998 100644
--- a/oak-core/pom.xml
+++ b/oak-core/pom.xml
@@ -44,12 +44,12 @@
             <Export-Package>
               org.apache.jackrabbit.oak,
               org.apache.jackrabbit.oak.api,
-              org.apache.jackrabbit.oak.core,
               org.apache.jackrabbit.oak.kernel,
               org.apache.jackrabbit.oak.util,
               org.apache.jackrabbit.oak.namepath,
               org.apache.jackrabbit.oak.plugins.value,
               org.apache.jackrabbit.oak.plugins.commit,
+              org.apache.jackrabbit.oak.plugins.identifier,
               org.apache.jackrabbit.oak.plugins.index,
               org.apache.jackrabbit.oak.plugins.index.aggregate,
               org.apache.jackrabbit.oak.plugins.index.nodetype,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Tree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Tree.java
index 37dc0d7589..ace2233a6d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Tree.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/api/Tree.java
@@ -116,7 +116,7 @@ public interface Tree {
     String getName();
 
     /**
-     * @return {@code true} if this is the root
+     * @return {@code true} iff this is the root
      */
     boolean isRoot();
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractTree.java
index 2753499170..8a91c63552 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractTree.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/AbstractTree.java
@@ -19,31 +19,28 @@
 
 package org.apache.jackrabbit.oak.core;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Iterables.filter;
-import static com.google.common.collect.Iterables.size;
-import static com.google.common.collect.Iterables.transform;
-import static org.apache.jackrabbit.oak.api.Tree.Status.EXISTING;
-import static org.apache.jackrabbit.oak.api.Tree.Status.MODIFIED;
-import static org.apache.jackrabbit.oak.api.Tree.Status.NEW;
-import static org.apache.jackrabbit.oak.api.Type.STRING;
-import static org.apache.jackrabbit.oak.spi.state.NodeStateUtils.isHidden;
-
 import java.util.Iterator;
-
 import javax.annotation.Nonnull;
 
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
-import org.apache.jackrabbit.JcrConstants;
 import org.apache.jackrabbit.mk.api.MicroKernel;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Tree;
-import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.plugins.index.IndexConstants;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.filter;
+import static com.google.common.collect.Iterables.size;
+import static com.google.common.collect.Iterables.transform;
+import static org.apache.jackrabbit.oak.api.Tree.Status.EXISTING;
+import static org.apache.jackrabbit.oak.api.Tree.Status.MODIFIED;
+import static org.apache.jackrabbit.oak.api.Tree.Status.NEW;
+import static org.apache.jackrabbit.oak.api.Type.STRING;
+import static org.apache.jackrabbit.oak.spi.state.NodeStateUtils.isHidden;
+
 /**
  * {@code AbstractTree} provides default implementations for most
  * read methods of {@code Tree}. Furthermore it handles the
@@ -268,27 +265,4 @@ public abstract class AbstractTree implements Tree {
                     }
                 });
     }
-
-    //------------------------------------------------------------< internal >---
-
-    /**
-     * The identifier of a tree is the value of its {@code jcr:uuid} property.
-     * If no such property exists the identifier is a slash ({@code/}) if the
-     * tree is the root. Otherwise the identifier is the tree's {@code name} appended
-     * to its parent's identifier separated by a slash ({@code/}).
-     * @return  the identifier of this tree
-     */
-    @Nonnull
-    String getIdentifier() {
-        PropertyState property = nodeBuilder.getProperty(JcrConstants.JCR_UUID);
-        if (property != null) {
-            return property.getValue(STRING);
-        } else if (isRoot()) {
-            return "/";
-        } else {
-            return PathUtils.concat(getParent().getIdentifier(), getName());
-        }
-    }
-
-
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ImmutableTree.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ImmutableTree.java
index 9249034f11..7daddac7ab 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ImmutableTree.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/ImmutableTree.java
@@ -16,8 +16,6 @@
  */
 package org.apache.jackrabbit.oak.core;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 
@@ -29,6 +27,8 @@ import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.ReadOnlyBuilder;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * Immutable implementation of the {@code Tree} interface in order to provide
  * the much feature rich API functionality for a given {@code NodeState}.
@@ -60,8 +60,7 @@ import org.apache.jackrabbit.oak.spi.state.ReadOnlyBuilder;
  *     <li>{@link ParentProvider#ROOT_PROVIDER}: the default parent provider for
  *     the root tree. All children will get {@link DefaultParentProvider}</li>
  *     <li>{@link ParentProvider#UNSUPPORTED}: throws {@code UnsupportedOperationException}
- *     upon hierarchy related methods like {@link #getParent()}, {@link #getPath()} and
- *     {@link #getIdentifier()}</li>
+ *     upon hierarchy related methods like {@link #getParent()}, {@link #getPath()}</li>
  * </ul>
  *
  * <h3>TreeTypeProvider</h3>
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java
index c92f5c8297..1f20a43718 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImpl.java
@@ -23,7 +23,7 @@ import javax.jcr.RepositoryException;
 
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.namepath.JcrPathParser.Listener;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/IdentifierManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
similarity index 96%
rename from oak-core/src/main/java/org/apache/jackrabbit/oak/core/IdentifierManager.java
rename to oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
index 2b16951bdf..cd7abab5cb 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/IdentifierManager.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManager.java
@@ -14,17 +14,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.jackrabbit.oak.core;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static org.apache.jackrabbit.oak.api.Type.STRING;
+package org.apache.jackrabbit.oak.plugins.identifier;
 
 import java.text.ParseException;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
-
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 import javax.jcr.PropertyType;
@@ -51,6 +47,9 @@ import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static org.apache.jackrabbit.oak.api.Type.STRING;
+
 /**
  * TODO document
  */
@@ -94,10 +93,14 @@ public class IdentifierManager {
      */
     @Nonnull
     public static String getIdentifier(Tree tree) {
-        if (tree instanceof AbstractTree) {
-            return ((AbstractTree) tree).getIdentifier();
+        PropertyState property = tree.getProperty(JcrConstants.JCR_UUID);
+        if (property != null) {
+            return property.getValue(STRING);
+        } else if (tree.isRoot()) {
+            return "/";
         } else {
-            return tree.getPath();
+            String parentId = getIdentifier(tree.getParent());
+            return PathUtils.concat(parentId, tree.getName());
         }
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/NodeTypeImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/NodeTypeImpl.java
index 5649809d77..d21eb83d2c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/NodeTypeImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/NodeTypeImpl.java
@@ -61,7 +61,7 @@ import org.apache.jackrabbit.commons.iterator.NodeTypeIteratorAdapter;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.namepath.JcrNameParser;
 import org.apache.jackrabbit.oak.namepath.JcrPathParser;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/TypeEditor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/TypeEditor.java
index f42a235cce..19c23a2087 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/TypeEditor.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/TypeEditor.java
@@ -44,7 +44,7 @@ import static org.apache.jackrabbit.JcrConstants.MIX_REFERENCEABLE;
 import static org.apache.jackrabbit.oak.api.Type.NAME;
 import static org.apache.jackrabbit.oak.api.Type.STRING;
 import static org.apache.jackrabbit.oak.api.Type.STRINGS;
-import static org.apache.jackrabbit.oak.core.IdentifierManager.isValidUUID;
+import static org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.isValidUUID;
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_ABSTRACT;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeProcessor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeProcessor.java
new file mode 100644
index 0000000000..d82f7df6bf
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/ChangeProcessor.java
@@ -0,0 +1,388 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.annotation.Nonnull;
+import javax.jcr.observation.Event;
+import javax.jcr.observation.EventListener;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
+import org.apache.jackrabbit.api.jmx.EventListenerMBean;
+import org.apache.jackrabbit.commons.iterator.EventIteratorAdapter;
+import org.apache.jackrabbit.commons.observation.ListenerTracker;
+import org.apache.jackrabbit.oak.api.ContentSession;
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.api.Tree;
+import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.core.ImmutableRoot;
+import org.apache.jackrabbit.oak.core.ImmutableTree;
+import org.apache.jackrabbit.oak.namepath.NamePathMapper;
+import org.apache.jackrabbit.oak.plugins.observation.ChangeDispatcher.ChangeSet;
+import org.apache.jackrabbit.oak.plugins.observation.ChangeDispatcher.Listener;
+import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.apache.jackrabbit.oak.spi.state.RecursingNodeStateDiff;
+import org.apache.jackrabbit.oak.spi.state.VisibleDiff;
+import org.apache.jackrabbit.oak.spi.whiteboard.Registration;
+import org.apache.jackrabbit.oak.spi.whiteboard.Whiteboard;
+import org.apache.jackrabbit.oak.spi.whiteboard.WhiteboardUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterators.emptyIterator;
+import static com.google.common.collect.Iterators.singletonIterator;
+import static com.google.common.collect.Iterators.transform;
+import static javax.jcr.observation.Event.NODE_ADDED;
+import static javax.jcr.observation.Event.NODE_REMOVED;
+import static javax.jcr.observation.Event.PROPERTY_ADDED;
+import static javax.jcr.observation.Event.PROPERTY_REMOVED;
+import static org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier;
+
+/**
+ * A {@code ChangeProcessor} generates observation {@link javax.jcr.observation.Event}s
+ * based on a {@link EventFilter} and delivers them to an {@link javax.jcr.observation.EventListener}.
+ * <p>
+ * After instantiation a {@code ChangeProcessor} must be started in order for its
+ * {@link #run()} methods to be regularly executed and stopped in order to not
+ * execute its run method anymore.
+ */
+public class ChangeProcessor implements Runnable {
+
+    private static final Logger log =
+            LoggerFactory.getLogger(ChangeProcessor.class);
+
+    private final ContentSession contentSession;
+    private final NamePathMapper namePathMapper;
+    private final AtomicReference<EventFilter> filterRef;
+    private final AtomicReference<String> userDataRef = new AtomicReference<String>(null);
+
+    private final ListenerTracker tracker;
+    private final EventListener listener;
+
+    private volatile Thread running = null;
+    private volatile boolean stopping = false;
+    private Runnable deferredUnregister;
+
+    private Registration runnable;
+    private Registration mbean;
+    private Listener changeListener;
+
+    public ChangeProcessor(
+            ContentSession contentSession, NamePathMapper namePathMapper,
+            ListenerTracker tracker, EventFilter filter) {
+        checkArgument(contentSession instanceof Observable);
+        this.contentSession = contentSession;
+        this.namePathMapper = namePathMapper;
+        this.tracker = tracker;
+        this.listener = tracker.getTrackedListener();
+        filterRef = new AtomicReference<EventFilter>(filter);
+    }
+
+    /**
+     * Set the filter for the events this change processor will generate.
+     * @param filter
+     */
+    public void setFilter(EventFilter filter) {
+        filterRef.set(filter);
+    }
+
+    /**
+     * Set the user data to return with {@link javax.jcr.observation.Event#getUserData()}.
+     * @param userData
+     */
+    public void setUserData(String userData) {
+        userDataRef.set(userData);
+    }
+
+    /**
+     * Start this change processor
+     * @param whiteboard  the whiteboard instance to used for scheduling individual
+     *                    runs of this change processor.
+     * @throws IllegalStateException if started already
+     */
+    public synchronized void start(Whiteboard whiteboard) {
+        checkState(runnable == null, "Change processor started already");
+
+        stopping = false;
+        changeListener = ((Observable) contentSession).newListener();
+        runnable = WhiteboardUtils.scheduleWithFixedDelay(whiteboard, this, 1);
+        mbean = WhiteboardUtils.registerMBean(
+                whiteboard, EventListenerMBean.class, tracker.getListenerMBean(),
+                "EventListener", tracker.toString());
+    }
+
+    /**
+     * Stop this change processor if running. After returning from this methods no further
+     * events will be delivered.
+     * @throws IllegalStateException if not yet started or stopped already
+     */
+    public void stop() {
+        stopping = true; // do this outside synchronization
+
+        if (running == Thread.currentThread()) {
+            // Defer stopping from event listener, defer unregistering until
+            // event listener is done
+            deferredUnregister = new Runnable() {
+                @Override
+                public void run() {
+                    unregister();
+                }
+            };
+        } else {
+            // Otherwise wait for the event listener to terminate and unregister immediately
+            synchronized (this) {
+                try {
+                    while (running != null) {
+                        wait();
+                    }
+                    unregister();
+                }
+                catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+        }
+    }
+
+    private void unregister() {
+        checkState(runnable != null, "Change processor not started");
+        mbean.unregister();
+        runnable.unregister();
+        changeListener.dispose();
+    }
+
+    @Override
+    public void run() {
+        // guarantee that only one thread is processing changes at a time
+        synchronized (this) {
+            if (running != null) {
+                return;
+            } else {
+                running = Thread.currentThread();
+            }
+        }
+
+        try {
+            ChangeSet changes = changeListener.getChanges();
+            while (!stopping && changes != null) {
+                EventFilter filter = filterRef.get();
+                if (!(filter.excludeLocal() && changes.isLocal(contentSession))) {
+                    String path = namePathMapper.getOakPath(filter.getPath());
+                    ImmutableTree beforeTree = getTree(changes.getBeforeState(), path);
+                    ImmutableTree afterTree = getTree(changes.getAfterState(), path);
+                    EventGeneratingNodeStateDiff diff = new EventGeneratingNodeStateDiff(changes, beforeTree, afterTree);
+                    SecureNodeStateDiff.compare(VisibleDiff.wrap(diff), beforeTree, afterTree);
+                    if (!stopping) {
+                        diff.sendEvents();
+                    }
+                }
+                changes = changeListener.getChanges();
+            }
+        } catch (Exception e) {
+            log.debug("Error while dispatching observation events", e);
+        } finally {
+            running = null;
+            synchronized (this) { notifyAll(); }
+            if (deferredUnregister != null) {
+                deferredUnregister.run();
+            }
+        }
+    }
+
+    private static ImmutableTree getTree(NodeState beforeState, String path) {
+        return new ImmutableRoot(beforeState).getTree(path);
+    }
+
+    //------------------------------------------------------------< private >---
+
+    private class EventGeneratingNodeStateDiff extends RecursingNodeStateDiff {
+        public static final int EVENT_LIMIT = 8192;
+
+        private final ChangeSet changes;
+        private final Tree beforeTree;
+        private final Tree afterTree;
+
+        private List<Iterator<Event>> events;
+        private int eventCount;
+
+        EventGeneratingNodeStateDiff(ChangeSet changes, Tree beforeTree, Tree afterTree, List<Iterator<Event>> events) {
+            this.changes = changes;
+            this.beforeTree = beforeTree;
+            this.afterTree = afterTree;
+            this.events = events;
+        }
+
+        public EventGeneratingNodeStateDiff(ChangeSet changes, Tree beforeTree, Tree afterTree) {
+            this(changes, beforeTree, afterTree, Lists.<Iterator<Event>>newArrayList());
+        }
+
+        public void sendEvents() {
+            Iterator<Event> eventIt = Iterators.concat(events.iterator());
+            if (eventIt.hasNext()) {
+                try {
+                    listener.onEvent(new EventIteratorAdapter(eventIt) {
+                        @Override
+                        public boolean hasNext() {
+                            return !stopping && super.hasNext();
+                        }
+                    });
+                }
+                catch (Exception e) {
+                    log.warn("Unhandled exception in observation listener: " + listener, e);
+                }
+                events = new ArrayList<Iterator<Event>>(EVENT_LIMIT);
+            }
+        }
+
+        @Override
+        public boolean propertyAdded(PropertyState after) {
+            if (filterRef.get().include(PROPERTY_ADDED, afterTree)) {
+                Event event = generatePropertyEvent(PROPERTY_ADDED, afterTree, after);
+                events.add(singletonIterator(event));
+            }
+            return !stopping;
+        }
+
+        @Override
+        public boolean propertyChanged(PropertyState before, PropertyState after) {
+            if (filterRef.get().include(Event.PROPERTY_CHANGED, afterTree)) {
+                Event event = generatePropertyEvent(Event.PROPERTY_CHANGED, afterTree, after);
+                events.add(singletonIterator(event));
+            }
+            return !stopping;
+        }
+
+        @Override
+        public boolean propertyDeleted(PropertyState before) {
+            if (filterRef.get().include(PROPERTY_REMOVED, afterTree)) {
+                Event event = generatePropertyEvent(PROPERTY_REMOVED, beforeTree, before);
+                events.add(singletonIterator(event));
+            }
+            return !stopping;
+        }
+
+        @Override
+        public boolean childNodeAdded(String name, NodeState after) {
+            if (filterRef.get().includeChildren(afterTree.getPath())) {
+                Iterator<Event> events = generateNodeEvents(
+                        NODE_ADDED, afterTree.getChild(name));
+                this.events.add(events);
+                if (++eventCount > EVENT_LIMIT) {
+                    sendEvents();
+                }
+            }
+            return !stopping;
+        }
+
+        @Override
+        public boolean childNodeDeleted(String name, NodeState before) {
+            if (filterRef.get().includeChildren(beforeTree.getPath())) {
+                Iterator<Event> events = generateNodeEvents(
+                        NODE_REMOVED, beforeTree.getChild(name));
+                this.events.add(events);
+            }
+            return !stopping;
+        }
+
+        @Override
+        public boolean childNodeChanged(String name, NodeState before, NodeState after) {
+            return !stopping;
+        }
+
+        @Nonnull
+        @Override
+        public RecursingNodeStateDiff createChildDiff(String name, NodeState before, NodeState after) {
+            if (filterRef.get().includeChildren(afterTree.getPath())) {
+                EventGeneratingNodeStateDiff diff = new EventGeneratingNodeStateDiff(
+                        changes, beforeTree.getChild(name), afterTree.getChild(name), events);
+                return VisibleDiff.wrap(diff);
+            } else {
+                return RecursingNodeStateDiff.EMPTY;
+            }
+        }
+
+        private EventImpl createEvent(int eventType, String path, String id) {
+            // TODO support info
+            return new EventImpl(
+                    eventType, namePathMapper.getJcrPath(path), changes.getUserId(),
+                    id, null, changes.getDate(), userDataRef.get(),
+                    changes.isExternal());
+        }
+
+        private Event generatePropertyEvent(int eventType, Tree parent, PropertyState property) {
+            String path = PathUtils.concat(parent.getPath(), property.getName());
+            return createEvent(eventType, path, getIdentifier(parent));
+        }
+
+        private Iterator<Event> generateNodeEvents(int eventType, final Tree tree) {
+            EventFilter filter = filterRef.get();
+            Iterator<Event> nodeEvent;
+            if (filter.include(eventType, tree.isRoot() ? null : tree.getParent())) {
+                Event event = createEvent(eventType, tree.getPath(), getIdentifier(tree));
+                nodeEvent = singletonIterator(event);
+            } else {
+                nodeEvent = emptyIterator();
+            }
+
+            final int propertyEventType = eventType == NODE_ADDED
+                    ? PROPERTY_ADDED
+                    : PROPERTY_REMOVED;
+
+            Iterator<Event> propertyEvents;
+            if (filter.include(propertyEventType, tree)) {
+                propertyEvents = transform(
+                        tree.getProperties().iterator(),
+                        new Function<PropertyState, Event>() {
+                            @Override
+                            public Event apply(PropertyState property) {
+                                return generatePropertyEvent(propertyEventType, tree, property);
+                            }
+                        });
+            } else {
+                propertyEvents = emptyIterator();
+            }
+
+            Iterator<Event> childNodeEvents = filter.includeChildren(tree.getPath())
+                    ? Iterators.concat(generateChildEvents(eventType, tree))
+                    : Iterators.<Event>emptyIterator();
+
+            return Iterators.concat(nodeEvent, propertyEvents, childNodeEvents);
+        }
+
+        private Iterator<Iterator<Event>> generateChildEvents(final int eventType, final Tree tree) {
+            return transform(
+                    tree.getChildren().iterator(),
+                    new Function<Tree, Iterator<Event>>() {
+                        @Override
+                        public Iterator<Event> apply(Tree child) {
+                            return generateNodeEvents(eventType, child);
+                        }
+                    });
+        }
+
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventFilter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventFilter.java
new file mode 100644
index 0000000000..aabfb15036
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventFilter.java
@@ -0,0 +1,186 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import java.util.Arrays;
+import javax.annotation.CheckForNull;
+import javax.jcr.RepositoryException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+
+import org.apache.jackrabbit.JcrConstants;
+import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.api.Tree;
+import org.apache.jackrabbit.oak.api.Type;
+import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager;
+
+import static com.google.common.base.Objects.toStringHelper;
+
+/**
+ * Filter for filtering observation events according to a certain criterion.
+ */
+public class EventFilter {
+    private final ReadOnlyNodeTypeManager ntMgr;
+    private final int eventTypes;
+    private final String path;
+    private final boolean deep;
+    private final String[] uuids;
+    private final String[] nodeTypeOakName;
+    private final boolean noLocal;
+
+    /**
+     * Create a new instance of a filter for a certain criterion
+     *
+     * @param ntMgr
+     * @param eventTypes  event types to include encoded as a bit mask
+     * @param path        path to include
+     * @param deep        {@code true} if descendants of {@code path} should be included. {@code false} otherwise.
+     * @param uuids       uuids to include
+     * @param nodeTypeName  node type names to include
+     * @param noLocal       exclude session local events if {@code true}. Include otherwise.
+     * @throws NoSuchNodeTypeException  if any of the node types in {@code nodeTypeName} does not exist
+     * @throws RepositoryException      if an error occurs while reading from the node type manager.
+     * @see javax.jcr.observation.ObservationManager#addEventListener(javax.jcr.observation.EventListener,
+     * int, String, boolean, String[], String[], boolean)
+     */
+    public EventFilter(ReadOnlyNodeTypeManager ntMgr, int eventTypes, String path, boolean deep, String[] uuids,
+            String[] nodeTypeName, boolean noLocal) {
+        this.ntMgr = ntMgr;
+        this.eventTypes = eventTypes;
+        this.path = path;
+        this.deep = deep;
+        this.uuids = uuids;
+        this.nodeTypeOakName = nodeTypeName;
+        this.noLocal = noLocal;
+    }
+
+    /**
+     * Match an event against this filter.
+     * @param eventType  type of the event
+     * @param associatedParent  associated parent node of the event
+     * @return  {@code true} if the filter matches this event. {@code false} otherwise.
+     */
+    public boolean include(int eventType, @CheckForNull Tree associatedParent) {
+        return includeByEvent(eventType)
+            && associatedParent != null
+            && includeByPath(associatedParent.getPath())
+            && includeByType(associatedParent)
+            && includeByUuid(associatedParent);
+    }
+
+    /**
+     * Determine whether the children of a {@code path} would be matched by this filter
+     * @param path  path whose children to test
+     * @return  {@code true} if the children of {@code path} could be matched by this filter
+     */
+    public boolean includeChildren(String path) {
+        return PathUtils.isAncestor(path, this.path) ||
+                path.equals((this.path)) ||
+                deep && PathUtils.isAncestor(this.path, path);
+    }
+
+    /**
+     * @return  the no local flag of this filter
+     */
+    public boolean excludeLocal() {
+        return noLocal;
+    }
+
+    /**
+     * @return  path of this filter
+     */
+    public String getPath() {
+        return path;
+    }
+
+    @Override
+    public String toString() {
+        return toStringHelper(this)
+                .add("types", eventTypes)
+                .add("path", path)
+                .add("deep", deep)
+                .add("uuids", Arrays.toString(uuids))
+                .add("node types", Arrays.toString(nodeTypeOakName))
+                .add("noLocal", noLocal)
+            .toString();
+    }
+
+    //-----------------------------< internal >---------------------------------
+
+    private boolean includeByEvent(int eventType) {
+        return (this.eventTypes & eventType) != 0;
+    }
+
+    private boolean includeByPath(String path) {
+        boolean equalPaths = this.path.equals(path);
+        if (!deep && !equalPaths) {
+            return false;
+        }
+
+        if (deep && !(PathUtils.isAncestor(this.path, path) || equalPaths)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Checks whether to include an event based on the type of the associated
+     * parent node and the node type filter.
+     *
+     * @param associatedParent the associated parent node of the event.
+     * @return whether to include the event based on the type of the associated
+     *         parent node.
+     */
+    private boolean includeByType(Tree associatedParent) {
+        if (nodeTypeOakName == null) {
+            return true;
+        } else {
+            for (String oakName : nodeTypeOakName) {
+                if (ntMgr.isNodeType(associatedParent, oakName)) {
+                    return true;
+                }
+            }
+            // filter has node types set but none matched
+            return false;
+        }
+    }
+
+    private boolean includeByUuid(Tree associatedParent) {
+        if (uuids == null) {
+            return true;
+        }
+        if (uuids.length == 0) {
+            return false;
+        }
+
+        PropertyState uuidProperty = associatedParent.getProperty(JcrConstants.JCR_UUID);
+        if (uuidProperty == null) {
+            return false;
+        }
+
+        String parentUuid = uuidProperty.getValue(Type.STRING);
+        for (String uuid : uuids) {
+            if (parentUuid.equals(uuid)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventImpl.java
new file mode 100644
index 0000000000..37625ee917
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/EventImpl.java
@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.jackrabbit.oak.plugins.observation;
+
+import java.util.Collections;
+import java.util.Map;
+
+import javax.jcr.RepositoryException;
+
+import org.apache.jackrabbit.api.observation.JackrabbitEvent;
+
+/**
+ * TODO document
+ */
+class EventImpl implements JackrabbitEvent {
+
+    private final int type;
+    private final String jcrPath;
+    private final String userID;
+    private final String identifier;
+    private final Map<?, ?> info;
+    private final long date;
+    private final String userData;
+    private final boolean external;
+
+    EventImpl(
+            int type, String jcrPath, String userID, String identifier,
+            Map<?, ?> info, long date, String userData, boolean external) {
+        this.type = type;
+        this.jcrPath = jcrPath;
+        this.userID = userID;
+        this.identifier = identifier;
+        this.info = info == null ? Collections.emptyMap() : info;
+        this.date = date;
+        this.userData = userData;
+        this.external = external;
+    }
+
+    @Override
+    public int getType() {
+        return type;
+    }
+
+    @Override
+    public String getPath() throws RepositoryException {
+        return jcrPath;
+    }
+
+    @Override
+    public String getUserID() {
+        return userID;
+    }
+
+    @Override
+    public String getIdentifier() {
+        return identifier;
+    }
+
+    @Override
+    public Map<?, ?> getInfo() {
+        return info;
+    }
+
+    @Override
+    public String getUserData() {
+        return userData;
+    }
+
+    @Override
+    public long getDate() {
+        return date;
+    }
+
+    @Override
+    public synchronized boolean isExternal() {
+        return external;
+    }
+
+    @Override
+    public final boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (other == null || getClass() != other.getClass()) {
+            return false;
+        }
+
+        EventImpl that = (EventImpl) other;
+        return date == that.date && type == that.type &&
+                (identifier == null ? that.identifier == null : identifier.equals(that.identifier)) &&
+                (info == null ? that.info == null : info.equals(that.info)) &&
+                (jcrPath == null ? that.jcrPath == null : jcrPath.equals(that.jcrPath)) &&
+                (userID == null ? that.userID == null : userID.equals(that.userID)) &&
+                (userData == null ? that.userData == null : userData.equals(that.userData)) &&
+                external == that.external;
+
+    }
+
+    @Override
+    public final int hashCode() {
+        int result = type;
+        result = 31 * result + (jcrPath == null ? 0 : jcrPath.hashCode());
+        result = 31 * result + (userID == null ? 0 : userID.hashCode());
+        result = 31 * result + (identifier == null ? 0 : identifier.hashCode());
+        result = 31 * result + (info == null ? 0 : info.hashCode());
+        result = 31 * result + (int) (date ^ (date >>> 32));
+        result = 31 * result + (userData == null ? 0 :  userData.hashCode());
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "EventImpl{" +
+                "type=" + type +
+                ", jcrPath='" + jcrPath + '\'' +
+                ", userID='" + userID + '\'' +
+                ", identifier='" + identifier + '\'' +
+                ", info=" + info +
+                ", date=" + date +
+                ", userData=" + userData +
+                ", external=" + external +
+                '}';
+    }
+
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
index 203cc8d123..8805ab51df 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/value/ValueFactoryImpl.java
@@ -27,7 +27,6 @@ import javax.jcr.Binary;
 import javax.jcr.Node;
 import javax.jcr.PropertyType;
 import javax.jcr.RepositoryException;
-import javax.jcr.UnsupportedRepositoryOperationException;
 import javax.jcr.Value;
 import javax.jcr.ValueFactory;
 import javax.jcr.ValueFormatException;
@@ -41,7 +40,7 @@ import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.namepath.JcrNameParser;
 import org.apache.jackrabbit.oak.namepath.JcrPathParser;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.plugins.memory.BinaryPropertyState;
 import org.apache.jackrabbit.oak.plugins.memory.BooleanPropertyState;
 import org.apache.jackrabbit.oak.plugins.memory.DecimalPropertyState;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadOnlyVersionManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadOnlyVersionManager.java
index 32937cd31d..22efdf9076 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadOnlyVersionManager.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadOnlyVersionManager.java
@@ -31,7 +31,7 @@ import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager;
 import org.apache.jackrabbit.oak.util.TreeUtil;
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadWriteVersionManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadWriteVersionManager.java
index eeb189fd0a..f84cb37d50 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadWriteVersionManager.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/ReadWriteVersionManager.java
@@ -18,51 +18,49 @@
  */
 package org.apache.jackrabbit.oak.plugins.version;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static org.apache.jackrabbit.JcrConstants.JCR_BASEVERSION;
-import static org.apache.jackrabbit.JcrConstants.JCR_CREATED;
-import static org.apache.jackrabbit.JcrConstants.JCR_ISCHECKEDOUT;
-import static org.apache.jackrabbit.JcrConstants.JCR_PREDECESSORS;
-import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
-import static org.apache.jackrabbit.JcrConstants.JCR_ROOTVERSION;
-import static org.apache.jackrabbit.JcrConstants.JCR_SUCCESSORS;
-import static org.apache.jackrabbit.JcrConstants.JCR_UUID;
-import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONABLEUUID;
-import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONHISTORY;
-import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONLABELS;
-import static org.apache.jackrabbit.JcrConstants.NT_VERSION;
-import static org.apache.jackrabbit.JcrConstants.NT_VERSIONHISTORY;
-import static org.apache.jackrabbit.JcrConstants.NT_VERSIONLABELS;
-import static org.apache.jackrabbit.oak.plugins.version.Utils.uuidFromNode;
-import static org.apache.jackrabbit.oak.plugins.version.VersionConstants.REP_VERSIONSTORAGE;
-import static org.apache.jackrabbit.oak.plugins.version.VersionConstants.VERSION_STORE_PATH;
-
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import javax.jcr.RepositoryException;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Sets;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
 import org.apache.jackrabbit.oak.core.ImmutableRoot;
 import org.apache.jackrabbit.oak.core.ImmutableTree;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Sets;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static org.apache.jackrabbit.JcrConstants.JCR_BASEVERSION;
+import static org.apache.jackrabbit.JcrConstants.JCR_CREATED;
+import static org.apache.jackrabbit.JcrConstants.JCR_ISCHECKEDOUT;
+import static org.apache.jackrabbit.JcrConstants.JCR_PREDECESSORS;
+import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
+import static org.apache.jackrabbit.JcrConstants.JCR_ROOTVERSION;
+import static org.apache.jackrabbit.JcrConstants.JCR_SUCCESSORS;
+import static org.apache.jackrabbit.JcrConstants.JCR_UUID;
+import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONABLEUUID;
+import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONHISTORY;
+import static org.apache.jackrabbit.JcrConstants.JCR_VERSIONLABELS;
+import static org.apache.jackrabbit.JcrConstants.NT_VERSION;
+import static org.apache.jackrabbit.JcrConstants.NT_VERSIONHISTORY;
+import static org.apache.jackrabbit.JcrConstants.NT_VERSIONLABELS;
+import static org.apache.jackrabbit.oak.plugins.version.Utils.uuidFromNode;
+import static org.apache.jackrabbit.oak.plugins.version.VersionConstants.REP_VERSIONSTORAGE;
+import static org.apache.jackrabbit.oak.plugins.version.VersionConstants.VERSION_STORE_PATH;
 
 /**
  * TODO document
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionableState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionableState.java
index 46f1f9583d..458d788e48 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionableState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionableState.java
@@ -60,7 +60,7 @@ import com.google.common.collect.Lists;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.core.ImmutableTree;
 import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeBuilder;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java
index c1006067a0..4208ba7327 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImpl.java
@@ -45,7 +45,7 @@ import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
 import org.apache.jackrabbit.oak.plugins.name.NamespaceConstants;
 import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;
@@ -61,7 +61,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static org.apache.jackrabbit.oak.api.Type.STRING;
-import static org.apache.jackrabbit.oak.core.IdentifierManager.getIdentifier;
+import static org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier;
 
 /**
  * Default implementation of the {@code TokenProvider} interface that keeps login
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionProviderImpl.java
index f9aa672b9c..9fd081631e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionProviderImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionProviderImpl.java
@@ -29,7 +29,7 @@ import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.core.ImmutableRoot;
 import org.apache.jackrabbit.oak.core.ImmutableTree;
 import org.apache.jackrabbit.oak.core.TreeTypeProvider;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/AuthorizableBaseProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/AuthorizableBaseProvider.java
index 989bcfb5cb..222e453cba 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/AuthorizableBaseProvider.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/AuthorizableBaseProvider.java
@@ -16,21 +16,21 @@
  */
 package org.apache.jackrabbit.oak.security.user;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static org.apache.jackrabbit.oak.core.IdentifierManager.generateUUID;
-import static org.apache.jackrabbit.oak.core.IdentifierManager.getIdentifier;
-
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;
 import org.apache.jackrabbit.oak.spi.security.user.AuthorizableType;
 import org.apache.jackrabbit.oak.spi.security.user.UserConstants;
 import org.apache.jackrabbit.oak.spi.security.user.util.UserUtil;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.generateUUID;
+import static org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier;
+
 /**
  * Base class for {@link UserProvider} and {@link MembershipProvider}.
  */
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserImporter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserImporter.java
index 4684c6c7d4..4da4e9fd2d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserImporter.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/user/UserImporter.java
@@ -16,9 +16,6 @@
  */
 package org.apache.jackrabbit.oak.security.user;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static org.apache.jackrabbit.oak.api.Type.STRINGS;
-
 import java.security.Principal;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -28,7 +25,6 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import javax.jcr.ImportUUIDBehavior;
@@ -49,8 +45,8 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;
 import org.apache.jackrabbit.oak.spi.security.SecurityProvider;
 import org.apache.jackrabbit.oak.spi.security.principal.PrincipalImpl;
@@ -66,6 +62,9 @@ import org.apache.jackrabbit.oak.util.TreeUtil;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static org.apache.jackrabbit.oak.api.Type.STRINGS;
+
 /**
  * {@code UserImporter} implements both {@code ode>ProtectedPropertyImporter}
  * and {@code ProtectedNodeImporter} and provides import facilities for protected
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/util/TreeUtil.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/util/TreeUtil.java
index 18a785518b..473c72dc87 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/util/TreeUtil.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/util/TreeUtil.java
@@ -62,7 +62,7 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
 import org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants;
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImplTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImplTest.java
index a7c3000db5..f0865a490c 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImplTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/namepath/NamePathMapperImplTest.java
@@ -28,7 +28,7 @@ import java.util.Map;
 import javax.jcr.RepositoryException;
 
 import com.google.common.collect.ImmutableMap;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.junit.Test;
 
 public class NamePathMapperImplTest {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/core/IdentifierManagerTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManagerTest.java
similarity index 96%
rename from oak-core/src/test/java/org/apache/jackrabbit/oak/core/IdentifierManagerTest.java
rename to oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManagerTest.java
index 6ac35f99b7..25b79e603d 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/core/IdentifierManagerTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/identifier/IdentifierManagerTest.java
@@ -16,9 +16,9 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.apache.jackrabbit.oak.core;
+package org.apache.jackrabbit.oak.plugins.identifier;
 
-import static org.apache.jackrabbit.oak.core.IdentifierManager.getIdentifier;
+import static org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
@@ -30,6 +30,7 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
 import org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent;
 import org.apache.jackrabbit.oak.spi.security.OpenSecurityProvider;
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImplTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImplTest.java
index fe07614a43..b13c9c12a9 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImplTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authentication/token/TokenProviderImplTest.java
@@ -32,7 +32,7 @@ import org.apache.jackrabbit.api.security.authentication.token.TokenCredentials;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.api.Type;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.spi.security.authentication.ImpersonationCredentials;
 import org.apache.jackrabbit.oak.spi.security.authentication.token.TokenInfo;
 import org.apache.jackrabbit.oak.spi.security.authentication.token.TokenProvider;
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/evaluation/JcrUUIDTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/evaluation/JcrUUIDTest.java
index 0f2afd527c..f97ba6080c 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/evaluation/JcrUUIDTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/evaluation/JcrUUIDTest.java
@@ -23,7 +23,7 @@ import org.apache.jackrabbit.oak.Oak;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
-import org.apache.jackrabbit.oak.core.IdentifierManager;
+import org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager;
 import org.apache.jackrabbit.oak.plugins.nodetype.RegistrationEditorProvider;
 import org.apache.jackrabbit.oak.plugins.nodetype.TypeEditorProvider;
 import org.apache.jackrabbit.oak.plugins.nodetype.write.ReadWriteNodeTypeManager;
