diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java
index 0fc604b271..3e2cbbb77e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java
@@ -63,7 +63,8 @@ public class SQL2Parser {
     private static final Logger LOG = LoggerFactory.getLogger(SQL2Parser.class);
 
     // Character types, used during the tokenizer phase
-    private static final int CHAR_END = -1, CHAR_VALUE = 2, CHAR_QUOTED = 3;
+    private static final int CHAR_END = -1, CHAR_IGNORE = 0;
+    private static final int CHAR_VALUE = 2, CHAR_QUOTED = 3;
     private static final int CHAR_NAME = 4, CHAR_SPECIAL_1 = 5, CHAR_SPECIAL_2 = 6;
     private static final int CHAR_STRING = 7, CHAR_DECIMAL = 8, CHAR_BRACKETED = 9;
 
@@ -155,7 +156,6 @@ public class SQL2Parser {
             read("BY");
             orderings = parseOrder();
         }
-        parseComment();
         if (!currentToken.isEmpty()) {
             throw getSyntaxError("<end>");
         }
@@ -920,18 +920,6 @@ public class SQL2Parser {
         }
     }
 
-    private void parseComment() throws ParseException {
-        if (readIf("/") && readIf("*")) {
-            //skip to the end directly
-            parseIndex = characterTypes.length - 3;
-            read();
-            boolean endComment = readIf("*") && readIf("/");
-            if (!endComment) {
-                throw getSyntaxError("end of comment");
-            }
-        }
-    }
-
     private boolean readIf(String token) throws ParseException {
         if (isToken(token)) {
             read();
@@ -987,7 +975,6 @@ public class SQL2Parser {
             char c = command[i];
             int type = 0;
             switch (c) {
-            case '/':
             case '-':
             case '(':
             case ')':
@@ -1013,6 +1000,21 @@ public class SQL2Parser {
             case '.':
                 type = CHAR_DECIMAL;
                 break;
+            case '/':
+                if (command[i + 1] != '*') {
+                    type = CHAR_SPECIAL_1;
+                    break;
+                }
+                types[i] = type = CHAR_IGNORE;                
+                startLoop = i;
+                i += 2;
+                checkRunOver(i, len, startLoop);
+                while (command[i] != '*' || command[i + 1] != '/') {
+                    i++;
+                    checkRunOver(i, len, startLoop);
+                }
+                i++;          
+                break;
             case '[':
                 types[i] = type = CHAR_BRACKETED;
                 startLoop = i;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java
index 9763c13173..6e614b5a08 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/xpath/Statement.java
@@ -183,7 +183,9 @@ public class Statement {
         // leave original xpath string as a comment
         if (xpathQuery != null) {
             buff.append(" /* xpath: ");
-            buff.append(xpathQuery);
+            // the xpath query may not contain the "end comment" marker
+            String xpathEscaped = xpathQuery.replaceAll("\\*\\/", "* /");
+            buff.append(xpathEscaped);
             buff.append(" */");
         }
         
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java
index 76ec4ad8bf..741f30834f 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/SQL2ParserTest.java
@@ -41,6 +41,9 @@ public class SQL2ParserTest {
     public void testIgnoreSqlComment() throws ParseException {
         p.parse("select * from [nt:unstructured] /* sql comment */");
         p.parse("select [jcr:path], [jcr:score], * from [nt:base] as a /* xpath: //* */");
+        p.parse("/* begin query */ select [jcr:path] /* this is the path */, " + 
+                "[jcr:score] /* the score */, * /* everything*/ " + 
+                "from [nt:base] /* all node types */ as a /* an identifier */");
     }
 
     @Test(expected = ParseException.class)
