diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPattern.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPattern.java
index 0d5d1abd9a..9354b29491 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPattern.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPattern.java
@@ -48,12 +48,25 @@ import static com.google.common.base.Preconditions.checkNotNull;
  * </p>
  *
  * <p>
+ * Examples without wildcard char:
+ * <pre>
+ * NodePath = "/foo"
+ * Restriction   |   Matches
+ * -----------------------------------------------------------------------------
+ * /cat          |   the node /foo/cat and all it's children
+ * /cat/         |   the descendants of the node /foo/cat
+ * cat           |   the node /foocat and all it's children
+ * cat/          |   all descendants of the node /foocat
+ * </pre>
+ * </p>
+ *
+ * <p>
  * Examples including wildcard char:
  * <pre>
  * NodePath = "/foo"
  * Restriction   |   Matches
  * -----------------------------------------------------------------------------
- * &#42;         |   all siblings of foo and foo's and the siblings' descendants
+ * &#42;         |   foo, all siblings of foo and their descendants
  * /&#42;cat     |   all children of /foo whose path ends with "cat"
  * /&#42;/cat    |   all non-direct descendants of /foo named "cat"
  * /cat&#42;     |   all descendant path of /foo that have the direct foo-descendant segment starting with "cat"
@@ -61,7 +74,8 @@ import static com.google.common.base.Preconditions.checkNotNull;
  * &#42;/cat     |   all descendants of /foo and foo's siblings that have a name segment "cat"
  * cat/&#42;     |   all descendants of '/foocat'
  * /cat/&#42;    |   all descendants of '/foo/cat'
- * &#42;cat/&#42;    |   all descendants of /foo that have an intermediate segment ending with 'cat'
+ * &#42;cat/&#42;    |   all siblings and descendants of foo that have an intermediate segment ending with 'cat'
+ * /&#42;cat/&#42;   |   all descendants of /foo that have an intermediate segment ending with 'cat'
  * </pre>
  * </p>
  */
@@ -79,7 +93,7 @@ final class GlobPattern implements RestrictionPattern {
         this.path = checkNotNull(path);
         this.restriction = restriction;
 
-        if (restriction.length() > 0) {
+        if (!restriction.isEmpty()) {
             StringBuilder b = new StringBuilder(path);
             b.append(restriction);
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPatternTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPatternTest.java
index 9b59c7529b..9319f22237 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPatternTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/security/authorization/restriction/GlobPatternTest.java
@@ -201,7 +201,7 @@ public class GlobPatternTest {
             assertMatch(gp, testPath, tests.get(testPath));
         }
 
-        // restriction "*e/*" matches all descendants of /foo that have an intermediate segment ending with 'e'
+        // restriction "*cat/*" matches all siblings and descendants of /foo that have an intermediate segment ending with 'cat'
         gp = GlobPattern.create("/a/b/c", "*e/*");
         tests = new HashMap<String,Boolean>();
         // matching
@@ -210,6 +210,7 @@ public class GlobPatternTest {
         tests.put("/a/b/c/d/e/f", true);
         tests.put("/a/b/ced/d/e/f", true);
         // not-matching
+        tests.put("/a/b/cde", false);      // sibling ending with e
         tests.put("/a/b/ce/", false);      // ignore trailing / in test path
         tests.put("/a/b/c/d/e/", false);   // ignore trailing / in test path
         tests.put("/a/b/c/d", false);      // missing *e/*
@@ -221,6 +222,28 @@ public class GlobPatternTest {
             assertMatch(gp, testPath, tests.get(testPath));
         }
 
+        //  restriction /*cat/*  matches all descendants of /foo that have an intermediate segment ending with 'cat'
+        gp = GlobPattern.create("/a/b/c", "/*e/*");
+        tests = new HashMap<String,Boolean>();
+        // matching
+        tests.put("/a/b/c/d/e/f", true);
+        tests.put("/a/b/c/de/f", true);
+        // not-matching
+        tests.put("/a/b/cde", false);      // sibling ending with e
+        tests.put("/a/b/ced/d/e/f", false);// sibling containing intermediate segment
+        tests.put("/a/b/cde/d/e/f", false);// sibling containing intermediate segment
+        tests.put("/a/b/ce/", false);      // ignore trailing / in test path
+        tests.put("/a/b/c/d/e/", false);   // ignore trailing / in test path
+        tests.put("/a/b/c/d/e", false);    // no intermediate segment
+        tests.put("/a/b/c/d", false);      // missing *e/*
+        tests.put("/a/b/c/d/e", false);    // missing /*
+        tests.put("/a/b/c/d/f/f", false);  // missing *e
+        tests.put("/a/b/c/ed/f/f", false); // missing e/
+
+        for (String testPath : tests.keySet()) {
+            assertMatch(gp, testPath, tests.get(testPath));
+        }
+
         //  restriction /*cat  matches all children of /a/b/c whose path ends with "cat"
         gp = GlobPattern.create("/a/b/c", "/*cat");
         tests = new HashMap<String,Boolean>();
@@ -331,6 +354,42 @@ public class GlobPatternTest {
         }
     }
 
+    @Test
+    public void testPathRestriction() {
+        GlobPattern gp = GlobPattern.create("/a/b/c", "d");
+        Map<String,Boolean> tests = new HashMap<String,Boolean>();
+        tests.put("/", false);
+        tests.put("/a", false);
+        tests.put("/a/b/c", false);
+        tests.put("/a/b/c/d", false);
+        tests.put("/a/b/c/d/e/f", false);
+        tests.put("/a/b/cd", true);
+        tests.put("/a/b/cd/e", true);
+        tests.put("/a/b/cd/e/f", true);
+        tests.put("/a/b/cde", false);
+
+        for (String toTest : tests.keySet()) {
+            assertTrue(gp + " : " + toTest, tests.get(toTest) == gp.matches(toTest));
+        }
+
+        gp = GlobPattern.create("/a/b/c", "/d");
+
+        tests = new HashMap<String,Boolean>();
+        tests.put("/", false);
+        tests.put("/a", false);
+        tests.put("/a/b/c", false);
+        tests.put("/a/b/c/d", true);
+        tests.put("/a/b/c/d/e/f", true);
+        tests.put("/a/b/cd", false);
+        tests.put("/a/b/cd/e", false);
+        tests.put("/a/b/cd/e/f", false);
+        tests.put("/a/b/cde", false);
+
+        for (String toTest : tests.keySet()) {
+            assertTrue(gp + " : " + toTest, tests.get(toTest) == gp.matches(toTest));
+        }
+    }
+
     @Test
     public void testMaxOccurrences() {
         GlobPattern gp = GlobPattern.create("/", "1*/2*/3*/4*/5*/6*/7*/8*/9*/10*/11*/12*/13*/14*/15*/16*/17*/18*/19*/20*/21*");
