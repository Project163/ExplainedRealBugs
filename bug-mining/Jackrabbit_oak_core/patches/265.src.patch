diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java
index e764684a06..28d509c739 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/QueryIndex.java
@@ -18,6 +18,8 @@
  */
 package org.apache.jackrabbit.oak.spi.query;
 
+import java.util.List;
+
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 
 /**
@@ -40,7 +42,7 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
  * even thought it will be set in the filter.
  */
 public interface QueryIndex {
-
+    
     /**
      * Estimate the cost to query with the given filter. The returned
      * cost is a value between 1 (very fast; lookup of a unique node) and the
@@ -77,4 +79,109 @@ public interface QueryIndex {
      */
     String getIndexName();
 
+//    /**
+//     * Return the possible index plans for the given filter and sort order.
+//     * Please note this method is supposed to run quickly. That means it should
+//     * usually not read any data from the storage.
+//     *
+//     * @param filter the filter
+//     * @param sortOrder the sort order or null if no sorting is required
+//     * @param rootState root state of the current repository snapshot
+//     * @return the list of index plans (null if none)
+//     */
+//    List<IndexPlan> getPlans(Filter filter, List<Order> sortOrder, NodeState rootState);
+//    
+//    /**
+//     * Get the query plan description (for logging purposes).
+//     *
+//     * @param plan the index plan
+//     * @return the query plan description
+//     */
+//    String getPlanDescription(IndexPlan plan);
+//    
+//    /**
+//     * Start a query. The filter and sort order of the index plan is to be used.
+//     *
+//     * @param plan the index plan to use
+//     * @param rootState root state of the current repository snapshot
+//     * @return a cursor to iterate over the result
+//     */
+//    Cursor query(IndexPlan plan, NodeState rootState);
+//    
+//    /**
+//     * An index plan.
+//     */
+//    public static class IndexPlan {
+//        
+//        /**
+//         * The cost to execute the query once. The returned value should
+//         * approximately match the number of disk read operations plus the
+//         * number of network roundtrips.
+//         */
+//        double costPerExecution;
+//        
+//        /**
+//         * The cost to read one entry from the cursor. The returned value should
+//         * approximately match the number of disk read operations plus the
+//         * number of network roundtrips.
+//         */
+//        double costPerEntry;
+//        
+//        /**
+//         * The estimated number of entries. This value does not have to be
+//         * accurate.
+//         */
+//        long estimatedEntryCount;
+//        
+//        /**
+//         * The filter to use.
+//         */
+//        Filter filter;
+//        
+//        /**
+//         * Whether transient (unsaved) changes are included.
+//         */
+//        boolean includeTransient;
+//
+//        /**
+//         * Whether the index is not always up-to-date.
+//         */
+//        boolean isDelayed;
+//        
+//        /**
+//         * Whether the fulltext part of the filter is evaluated (possibly with
+//         * an extended syntax). If set, the fulltext part of the filter is not
+//         * evaluated any more within the query engine.
+//         */
+//        boolean isFulltextIndex;
+//        
+//        /**
+//         * Whether the cursor is able to read all properties from a node.
+//         */
+//        boolean includesNodeData;
+//        
+//        /**
+//         * The sort order of the returned entries, or null if unsorted.
+//         */
+//        List<Order> sortOrder;
+//        
+//    }
+//    
+//    /**
+//     * A sort order entry.
+//     */
+//    static class Order {
+//        
+//        /**
+//         * The property name on where to sort.
+//         */
+//        String propertyName;
+//
+//        /**
+//         * True for descending, false for ascending.
+//         */
+//        boolean descending;
+//        
+//    }
+
 }
