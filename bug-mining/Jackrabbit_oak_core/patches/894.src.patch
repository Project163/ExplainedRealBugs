diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
index b49f72ef81..043339237e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
@@ -1205,7 +1205,7 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
 
     public static void setModified(@Nonnull UpdateOp op,
                                    @Nonnull Revision revision) {
-        checkNotNull(op).max(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
+        checkNotNull(op).set(MODIFIED_IN_SECS, getModifiedInSecs(checkNotNull(revision).getTimestamp()));
     }
 
     public static void setRevision(@Nonnull UpdateOp op,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
index 0517fe1cc7..56b0698468 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
@@ -131,7 +131,9 @@ public final class UpdateOp {
      * @param value the value
      */
     void setMapEntry(@Nonnull String property, @Nonnull Revision revision, Object value) {
-        Operation op = new Operation(Operation.Type.SET_MAP_ENTRY, value);
+        Operation op = new Operation();
+        op.type = Operation.Type.SET_MAP_ENTRY;
+        op.value = value;
         changes.put(new Key(property, checkNotNull(revision)), op);
     }
 
@@ -143,7 +145,8 @@ public final class UpdateOp {
      * @param revision the revision
      */
     public void removeMapEntry(@Nonnull String property, @Nonnull Revision revision) {
-        Operation op = new Operation(Operation.Type.REMOVE_MAP_ENTRY, null);
+        Operation op = new Operation();
+        op.type = Operation.Type.REMOVE_MAP_ENTRY;
         changes.put(new Key(property, checkNotNull(revision)), op);
     }
 
@@ -154,23 +157,9 @@ public final class UpdateOp {
      * @param value the value
      */
     void set(String property, Object value) {
-        Operation op = new Operation(Operation.Type.SET, value);
-        changes.put(new Key(property, null), op);
-    }
-
-    /**
-     * Set the property to the given value if the new value is higher than the
-     * existing value. The property is also set to the given value if the
-     * property does not yet exist.
-     * <p>
-     * The result of a max operation with different types of values is
-     * undefined.
-     *
-     * @param property the name of the property to set.
-     * @param value the new value for the property.
-     */
-    <T> void max(String property, Comparable<T> value) {
-        Operation op = new Operation(Operation.Type.MAX, value);
+        Operation op = new Operation();
+        op.type = Operation.Type.SET;
+        op.value = value;
         changes.put(new Key(property, null), op);
     }
 
@@ -198,7 +187,9 @@ public final class UpdateOp {
         if (isNew) {
             throw new IllegalStateException("Cannot use containsMapEntry() on new document");
         }
-        Operation op = new Operation(Operation.Type.CONTAINS_MAP_ENTRY, exists);
+        Operation op = new Operation();
+        op.type = Operation.Type.CONTAINS_MAP_ENTRY;
+        op.value = exists;
         changes.put(new Key(property, checkNotNull(revision)), op);
     }
 
@@ -209,7 +200,9 @@ public final class UpdateOp {
      * @param value the increment
      */
     public void increment(@Nonnull String property, long value) {
-        Operation op = new Operation(Operation.Type.INCREMENT, value);
+        Operation op = new Operation();
+        op.type = Operation.Type.INCREMENT;
+        op.value = value;
         changes.put(new Key(property, null), op);
     }
 
@@ -245,14 +238,6 @@ public final class UpdateOp {
              */
             SET,
 
-            /**
-             * Set the value if the new value is higher than the existing value.
-             * The new value is also considered higher, when there is no
-             * existing value.
-             * The sub-key is not used.
-             */
-            MAX,
-
             /**
              * Increment the Long value with the provided Long value.
              * The sub-key is not used.
@@ -282,17 +267,12 @@ public final class UpdateOp {
         /**
          * The operation type.
          */
-        public final Type type;
+        public Type type;
 
         /**
          * The value, if any.
          */
-        public final Object value;
-
-        Operation(Type type, Object value) {
-            this.type = checkNotNull(type);
-            this.value = value;
-        }
+        public Object value;
 
         @Override
         public String toString() {
@@ -303,16 +283,18 @@ public final class UpdateOp {
             Operation reverse = null;
             switch (type) {
             case INCREMENT:
-                reverse = new Operation(Type.INCREMENT, -(Long) value);
+                reverse = new Operation();
+                reverse.type = Type.INCREMENT;
+                reverse.value = -(Long) value;
                 break;
             case SET:
-            case MAX:
             case REMOVE_MAP_ENTRY:
             case CONTAINS_MAP_ENTRY:
                 // nothing to do
                 break;
             case SET_MAP_ENTRY:
-                reverse = new Operation(Type.REMOVE_MAP_ENTRY, null);
+                reverse = new Operation();
+                reverse.type = Type.REMOVE_MAP_ENTRY;
                 break;
             }
             return reverse;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java
index 240665d422..b8015ff100 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateUtils.java
@@ -44,9 +44,7 @@ public class UpdateUtils {
      * @param comparator
      *            the revision comparator.
      */
-    public static void applyChanges(@Nonnull Document doc,
-                                    @Nonnull UpdateOp update,
-                                    @Nonnull Comparator<Revision> comparator) {
+    public static void applyChanges(@Nonnull Document doc, @Nonnull UpdateOp update, @Nonnull Comparator<Revision> comparator) {
         for (Entry<Key, Operation> e : checkNotNull(update).getChanges().entrySet()) {
             Key k = e.getKey();
             Operation op = e.getValue();
@@ -55,15 +53,6 @@ public class UpdateUtils {
                     doc.put(k.toString(), op.value);
                     break;
                 }
-                case MAX: {
-                    Comparable newValue = (Comparable) op.value;
-                    Object old = doc.get(k.toString());
-                    //noinspection unchecked
-                    if (old == null || newValue.compareTo(old) > 0) {
-                        doc.put(k.toString(), op.value);
-                    }
-                    break;
-                }
                 case INCREMENT: {
                     Object old = doc.get(k.toString());
                     Long x = (Long) op.value;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
index 99db8d134c..0266e388a1 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
@@ -570,7 +570,6 @@ public class MongoDocumentStore implements CachingDocumentStore {
                 Operation op = entry.getValue();
                 switch (op.type) {
                     case SET:
-                    case MAX:
                     case INCREMENT: {
                         inserts[i].put(k.toString(), op.value);
                         break;
@@ -966,7 +965,6 @@ public class MongoDocumentStore implements CachingDocumentStore {
     @Nonnull
     private static DBObject createUpdate(UpdateOp updateOp) {
         BasicDBObject setUpdates = new BasicDBObject();
-        BasicDBObject maxUpdates = new BasicDBObject();
         BasicDBObject incUpdates = new BasicDBObject();
         BasicDBObject unsetUpdates = new BasicDBObject();
 
@@ -982,19 +980,18 @@ public class MongoDocumentStore implements CachingDocumentStore {
             }
             Operation op = entry.getValue();
             switch (op.type) {
-                case SET:
-                case SET_MAP_ENTRY: {
+                case SET: {
                     setUpdates.append(k.toString(), op.value);
                     break;
                 }
-                case MAX: {
-                    maxUpdates.append(k.toString(), op.value);
-                    break;
-                }
                 case INCREMENT: {
                     incUpdates.append(k.toString(), op.value);
                     break;
                 }
+                case SET_MAP_ENTRY: {
+                    setUpdates.append(k.toString(), op.value);
+                    break;
+                }
                 case REMOVE_MAP_ENTRY: {
                     unsetUpdates.append(k.toString(), "1");
                     break;
@@ -1006,9 +1003,6 @@ public class MongoDocumentStore implements CachingDocumentStore {
         if (!setUpdates.isEmpty()) {
             update.append("$set", setUpdates);
         }
-        if (!maxUpdates.isEmpty()) {
-            update.append("$max", maxUpdates);
-        }
         if (!incUpdates.isEmpty()) {
             update.append("$inc", incUpdates);
         }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentStoreTest.java
index 05e0b2acea..c959b946c5 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AbstractDocumentStoreTest.java
@@ -34,19 +34,17 @@ public abstract class AbstractDocumentStoreTest {
 
     protected String dsname;
     protected DocumentStore ds;
-    protected DocumentStoreFixture dsf;
     protected List<String> removeMe = new ArrayList<String>();
 
     static final Logger LOG = LoggerFactory.getLogger(AbstractDocumentStoreTest.class);
 
     public AbstractDocumentStoreTest(DocumentStoreFixture dsf) {
-        this.dsf = dsf;
         this.ds = dsf.createDocumentStore();
         this.dsname = dsf.getName();
     }
 
     @After
-    public void cleanUp() throws Exception {
+    public void cleanUp() {
         if (!removeMe.isEmpty()) {
             long start = System.nanoTime();
             try {
@@ -67,7 +65,6 @@ public abstract class AbstractDocumentStoreTest {
                 LOG.info(removeMe.size() + " documents removed in " + elapsed + "ms (" + rate + "/ms)");
             }
         }
-        dsf.dispose();
     }
 
     @Parameterized.Parameters
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreIT.java
deleted file mode 100644
index daa15c8eb5..0000000000
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreIT.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jackrabbit.oak.plugins.document;
-
-import org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper;
-import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
-import org.apache.jackrabbit.oak.spi.commit.EmptyHook;
-import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
-import org.apache.jackrabbit.oak.stats.Clock;
-import org.junit.After;
-import org.junit.Test;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS_RESOLUTION;
-import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath;
-import static org.junit.Assert.assertEquals;
-
-/**
- * Tests DocumentNodeStore on various DocumentStore back-ends.
- */
-public class DocumentNodeStoreIT extends AbstractDocumentStoreTest {
-
-
-    public DocumentNodeStoreIT(DocumentStoreFixture dsf) {
-        super(dsf);
-    }
-
-    @After
-    public void tearDown() {
-        Revision.resetClockToDefault();
-    }
-
-
-    @Test
-    public void modifiedResetWithDiff() throws Exception {
-        Clock clock = new Clock.Virtual();
-        clock.waitUntil(System.currentTimeMillis());
-        Revision.setClock(clock);
-        DocumentStore docStore = new TimingDocumentStoreWrapper(ds) {
-            @Override
-            public void dispose() {
-                // do not dispose yet
-            }
-        };
-        DocumentNodeStore ns1 = new DocumentMK.Builder()
-                .setDocumentStore(docStore).setClusterId(1)
-                .setAsyncDelay(0).clock(clock)
-                        // use a no-op diff cache to simulate a cache miss
-                        // when the diff is made later in the test
-                .setDiffCache(AmnesiaDiffCache.INSTANCE)
-                .getNodeStore();
-        NodeBuilder builder1 = ns1.getRoot().builder();
-        builder1.child("node");
-        removeMe.add(getIdFromPath("/node"));
-        for (int i = 0; i < DocumentMK.MANY_CHILDREN_THRESHOLD; i++) {
-            builder1.child("node-" + i);
-            removeMe.add(getIdFromPath("/node/node-" + i));
-        }
-        ns1.merge(builder1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
-        // make sure commit is visible to other node store instance
-        ns1.runBackgroundOperations();
-
-        DocumentNodeStore ns2 = new DocumentMK.Builder()
-                .setDocumentStore(docStore).setClusterId(2)
-                .setAsyncDelay(0).clock(clock).getNodeStore();
-
-        NodeBuilder builder2 = ns2.getRoot().builder();
-        builder2.child("node").child("child-a");
-        removeMe.add(getIdFromPath("/node/child-a"));
-        ns2.merge(builder2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
-
-        // wait at least _modified resolution. in reality the wait may
-        // not be necessary. e.g. when the clock passes the resolution boundary
-        // exactly at this time
-        clock.waitUntil(System.currentTimeMillis() +
-                SECONDS.toMillis(MODIFIED_IN_SECS_RESOLUTION + 1));
-
-        builder1 = ns1.getRoot().builder();
-        builder1.child("node").child("child-b");
-        removeMe.add(getIdFromPath("/node/child-b"));
-        ns1.merge(builder1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
-        // remember root for diff
-        DocumentNodeState root1 = ns1.getRoot();
-
-        builder1 = root1.builder();
-        builder1.child("node").child("child-c");
-        removeMe.add(getIdFromPath("/node/child-c"));
-        ns1.merge(builder1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
-        // remember root for diff
-        DocumentNodeState root2 = ns1.getRoot();
-
-        ns1.runBackgroundOperations();
-        ns2.runBackgroundOperations();
-
-        String diff = ns1.diffChildren(root2, root1);
-        // must report /node as changed
-        assertEquals("^\"node\":{}", diff.trim());
-
-        ns1.dispose();
-        ns2.dispose();
-    }
-}
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
index 86d6251f35..05877c1c28 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
@@ -51,6 +51,7 @@ import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.stats.Clock;
 import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import com.google.common.collect.Iterables;
@@ -418,6 +419,7 @@ public class DocumentNodeStoreTest {
         ns.dispose();
     }
 
+    @Ignore("OAK-1822")
     @Test
     public void modifiedReset() throws Exception {
         Clock clock = new Clock.Virtual();
@@ -467,6 +469,66 @@ public class DocumentNodeStoreTest {
         ns2.dispose();
     }
 
+    @Ignore("OAK-1822")
+    @Test
+    public void modifiedResetWithDiff() throws Exception {
+        Clock clock = new Clock.Virtual();
+        clock.waitUntil(System.currentTimeMillis());
+        Revision.setClock(clock);
+        MemoryDocumentStore docStore = new MemoryDocumentStore();
+        DocumentNodeStore ns1 = new DocumentMK.Builder()
+                .setDocumentStore(docStore).setClusterId(1)
+                .setAsyncDelay(0).clock(clock)
+                // use a no-op diff cache to simulate a cache miss
+                // when the diff is made later in the test
+                .setDiffCache(AmnesiaDiffCache.INSTANCE)
+                .getNodeStore();
+        NodeBuilder builder1 = ns1.getRoot().builder();
+        builder1.child("node");
+        for (int i = 0; i < DocumentMK.MANY_CHILDREN_THRESHOLD; i++) {
+            builder1.child("node-" + i);
+        }
+        ns1.merge(builder1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        // make sure commit is visible to other node store instance
+        ns1.runBackgroundOperations();
+
+        DocumentNodeStore ns2 = new DocumentMK.Builder()
+                .setDocumentStore(docStore).setClusterId(2)
+                .setAsyncDelay(0).clock(clock).getNodeStore();
+
+        NodeBuilder builder2 = ns2.getRoot().builder();
+        builder2.child("node").child("child-a");
+        ns2.merge(builder2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        // wait at least _modified resolution. in reality the wait may
+        // not be necessary. e.g. when the clock passes the resolution boundary
+        // exactly at this time
+        clock.waitUntil(System.currentTimeMillis() +
+                SECONDS.toMillis(MODIFIED_IN_SECS_RESOLUTION + 1));
+
+        builder1 = ns1.getRoot().builder();
+        builder1.child("node").child("child-b");
+        ns1.merge(builder1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        // remember root for diff
+        DocumentNodeState root1 = ns1.getRoot();
+
+        builder1 = root1.builder();
+        builder1.child("node").child("child-c");
+        ns1.merge(builder1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        // remember root for diff
+        DocumentNodeState root2 = ns1.getRoot();
+
+        ns1.runBackgroundOperations();
+        ns2.runBackgroundOperations();
+
+        String diff = ns1.diffChildren(root2, root1);
+        // must report /node as changed
+        assertEquals("^\"node\":{}", diff);
+
+        ns1.dispose();
+        ns2.dispose();
+    }
+
     private static class TestHook extends EditorHook {
 
         TestHook(final String prefix) {
