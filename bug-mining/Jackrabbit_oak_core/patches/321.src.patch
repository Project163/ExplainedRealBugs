diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/EffectiveType.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/EffectiveType.java
index 571d86e748..2cccf973fd 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/EffectiveType.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/EffectiveType.java
@@ -28,12 +28,10 @@ import static org.apache.jackrabbit.JcrConstants.JCR_MANDATORY;
 import static org.apache.jackrabbit.JcrConstants.JCR_MIXINTYPES;
 import static org.apache.jackrabbit.JcrConstants.JCR_NODETYPENAME;
 import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
-import static org.apache.jackrabbit.JcrConstants.JCR_SAMENAMESIBLINGS;
 import static org.apache.jackrabbit.JcrConstants.JCR_UUID;
 import static org.apache.jackrabbit.oak.api.CommitFailedException.CONSTRAINT;
 import static org.apache.jackrabbit.oak.api.Type.UNDEFINED;
 import static org.apache.jackrabbit.oak.api.Type.UNDEFINEDS;
-import static org.apache.jackrabbit.oak.commons.PathUtils.dropIndexFromName;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.JCR_IS_ABSTRACT;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.OAK_MANDATORY_CHILD_NODES;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.OAK_MANDATORY_PROPERTIES;
@@ -189,20 +187,18 @@ class EffectiveType {
      *         {@code false} otherwise
      */
     boolean isValidChildNode(String nameWithIndex, EffectiveType effective) {
-        String name = dropIndexFromName(nameWithIndex);
-        boolean sns = !name.equals(nameWithIndex);
+        String nodeName = getNameWithoutIndex(nameWithIndex);
         Set<String> typeNames = effective.getTypeNames();
 
         // Find matching named child node definition
         for (NodeState type : types) {
             NodeState definitions = type
                     .getChildNode(OAK_NAMED_CHILD_NODE_DEFINITIONS)
-                    .getChildNode(name);
+                    .getChildNode(nodeName);
 
             for (String typeName : typeNames) {
                 NodeState definition = definitions.getChildNode(typeName);
-                if (definition.exists()
-                        && sns == definition.getBoolean(JCR_SAMENAMESIBLINGS)) {
+                if (definition.exists()) {
                     return true;
                 }
             }
@@ -227,8 +223,7 @@ class EffectiveType {
                     type.getChildNode(OAK_RESIDUAL_CHILD_NODE_DEFINITIONS);
             for (String typeName : typeNames) {
                 NodeState definition = residual.getChildNode(typeName);
-                if (definition.exists()
-                        && sns == definition.getBoolean(JCR_SAMENAMESIBLINGS)) {
+                if (definition.exists()) {
                     return true;
                 }
             }
@@ -245,8 +240,7 @@ class EffectiveType {
      */
     @CheckForNull
     String getDefaultType(String nameWithIndex) {
-        String name = dropIndexFromName(nameWithIndex);
-        boolean sns = !name.equals(nameWithIndex);
+        String name = getNameWithoutIndex(nameWithIndex);
 
         for (NodeState type : types) {
             NodeState named = type
@@ -260,8 +254,7 @@ class EffectiveType {
                     residual.getChildNodeEntries())) {
                 NodeState definition = entry.getNodeState();
                 String defaultType = definition.getName(JCR_DEFAULTPRIMARYTYPE);
-                if (defaultType != null
-                        && sns == definition.getBoolean(JCR_SAMENAMESIBLINGS)) {
+                if (defaultType != null) {
                     return defaultType;
                 }
             }
@@ -348,6 +341,22 @@ class EffectiveType {
         return names.toString();
     }
 
+    //-----------------------------------------------------------< private >--
+
+    private static String getNameWithoutIndex(String name) {
+        int n = name.length();
+        if (n > 3 && name.charAt(n - 1) == ']') {
+            int i = n - 2;
+            while (i > 1 && Character.isDigit(name.charAt(i))) {
+                i--;
+            }
+            if (name.charAt(i) == '[') {
+                return name.substring(0, i);
+            }
+        }
+        return name;
+    }
+
     private boolean nameSetContains(String set, String name) {
         for (NodeState type : types) {
             if (contains(type.getNames(set), name)) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/ReadOnlyNodeTypeManager.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/ReadOnlyNodeTypeManager.java
index 64715be053..9d2c402502 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/ReadOnlyNodeTypeManager.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/nodetype/ReadOnlyNodeTypeManager.java
@@ -21,7 +21,6 @@ import static com.google.common.collect.Iterables.contains;
 import static org.apache.jackrabbit.JcrConstants.JCR_MIXINTYPES;
 import static org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE;
 import static org.apache.jackrabbit.oak.api.Type.STRING;
-import static org.apache.jackrabbit.oak.commons.PathUtils.dropIndexFromName;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.NODE_TYPES_PATH;
 import static org.apache.jackrabbit.oak.plugins.nodetype.NodeTypeConstants.OAK_SUPERTYPES;
 
@@ -391,7 +390,7 @@ public abstract class ReadOnlyNodeTypeManager implements NodeTypeManager, Effect
         checkNotNull(parent);
         checkNotNull(targetNode);
 
-        String name = dropIndexFromName(targetNode.getName());
+        String name = targetNode.getName();
         EffectiveNodeType eff = getEffectiveNodeType(parent);
         return eff.getNodeDefinition(name, getEffectiveNodeType(targetNode));
     }
