diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
index b285dbefd5..3965746390 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
@@ -190,4 +190,21 @@ public interface Query {
      */
     void setQueryOptions(QueryOptions options);
 
+    /**
+     * Whether the query is potentially slow.
+     * Only supported for prepared queries.
+     * 
+     * @return true if traversal is the only option
+     */
+    boolean isPotentiallySlow();
+
+    /**
+     * Verify the query is not potentially slow. Only supported for prepared
+     * queries.
+     * 
+     * @throws IllegalArgumentException if potentially slow, and configured to
+     *             fail in this case
+     */
+    void verifyNotPotentiallySlow();
+
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
index 5844b238a8..53f96f23f1 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
@@ -292,6 +292,7 @@ public abstract class QueryEngineImpl implements QueryEngine {
             // we only have the original query so we prepare and return it.
             result = queries.iterator().next();
             result.prepare();
+            result.verifyNotPotentiallySlow();
             LOG.debug("No alternatives found. Query: {}", result);
         } else {
             double bestCost = Double.POSITIVE_INFINITY;
@@ -300,8 +301,12 @@ public abstract class QueryEngineImpl implements QueryEngine {
             // it's the default behaviour. That way, we always log the cost and
             // can more easily analyze problems. The querySelectionMode flag can
             // be used to override the cheapest.
+            boolean isPotentiallySlow = true;
             for (Query q : checkNotNull(queries)) {
                 q.prepare();
+                if (!q.isPotentiallySlow()) {
+                    isPotentiallySlow = false;
+                }
                 double cost = q.getEstimatedCost();
                 LOG.debug("cost: {} for query {}", cost, q);
                 if (q.containsUnfilteredFullTextCondition()) {
@@ -329,6 +334,9 @@ public abstract class QueryEngineImpl implements QueryEngine {
             case CHEAPEST:
             default:
             }
+            if (isPotentiallySlow) {
+                result.verifyNotPotentiallySlow();
+            }
         }
         
         return result;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java
index f643ad6918..b2565109fd 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryImpl.java
@@ -203,6 +203,8 @@ public class QueryImpl implements Query {
 
     private boolean isInternal;
 
+    private boolean potentiallySlowTraversalQuery;
+
     QueryImpl(String statement, SourceImpl source, ConstraintImpl constraint,
         ColumnImpl[] columns, NamePathMapper mapper, QueryEngineSettings settings) {
         this.statement = statement;
@@ -644,6 +646,11 @@ public class QueryImpl implements Query {
         // use a greedy algorithm
         SourceImpl result = null;
         Set<SourceImpl> available = new HashSet<SourceImpl>();
+        // the query is only slow if all possible join orders are slow
+        // (in theory, due to using the greedy algorithm, a query might be considered
+        // slow even thought there is a plan that doesn't need to use traversal, but
+        // only for 3-way and higher joins, and only if traversal is considered very fast)
+        boolean isPotentiallySlowJoin = true;
         while (sources.size() > 0) {
             int bestIndex = 0;
             double bestCost = Double.POSITIVE_INFINITY;
@@ -663,12 +670,16 @@ public class QueryImpl implements Query {
                     bestIndex = i;
                     best = test;
                 }
+                if (!potentiallySlowTraversalQuery) {
+                    isPotentiallySlowJoin = false;
+                }
                 test.unprepare();
             }
             available.add(sources.remove(bestIndex));
             result = best;
             best.prepare(bestPlan);
         }
+        potentiallySlowTraversalQuery = isPotentiallySlowJoin;
         estimatedCost = result.prepare().getEstimatedCost();
         source = result;
         isSortedByIndex = canSortByIndex();
@@ -1035,7 +1046,7 @@ public class QueryImpl implements Query {
                 bestPlan = indexPlan;
             }
         }
-        boolean potentiallySlowTraversalQuery = bestIndex == null;
+        potentiallySlowTraversalQuery = bestIndex == null;
         if (traversalEnabled) {
             TraversingIndex traversal = new TraversingIndex();
             double cost = traversal.getCost(filter, rootState);
@@ -1051,6 +1062,17 @@ public class QueryImpl implements Query {
                 }
             }
         }
+        return new SelectorExecutionPlan(filter.getSelector(), bestIndex, 
+                bestPlan, bestCost);
+    }
+
+    @Override
+    public boolean isPotentiallySlow() {
+        return potentiallySlowTraversalQuery;
+    }
+    
+    @Override
+    public void verifyNotPotentiallySlow() {
         if (potentiallySlowTraversalQuery) {
             QueryOptions.Traversal traversal = queryOptions.traversal;
             if (traversal == Traversal.DEFAULT) {
@@ -1078,7 +1100,6 @@ public class QueryImpl implements Query {
                 throw new IllegalArgumentException(message);
             }
         }
-        return new SelectorExecutionPlan(filter.getSelector(), bestIndex, bestPlan, bestCost);
     }
     
     private List<OrderEntry> getSortOrder(FilterImpl filter) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
index 940a7b0c3e..858f1f5b05 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/UnionQueryImpl.java
@@ -396,4 +396,16 @@ public class UnionQueryImpl implements Query {
                 right.containsUnfilteredFullTextCondition();
     }
 
+    @Override
+    public boolean isPotentiallySlow() {
+        return left.isPotentiallySlow() || 
+                right.isPotentiallySlow();
+    }
+
+    @Override
+    public void verifyNotPotentiallySlow() {
+        left.verifyNotPotentiallySlow();
+        right.verifyNotPotentiallySlow();
+    }
+
 }
