diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/NodeObserver.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/NodeObserver.java
index fe6817987f..914fc58747 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/NodeObserver.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/NodeObserver.java
@@ -20,6 +20,7 @@
 package org.apache.jackrabbit.oak.plugins.observation;
 
 import static java.util.Collections.addAll;
+import static org.apache.jackrabbit.oak.plugins.observation.filter.VisibleFilter.VISIBLE_FILTER;
 
 import java.util.Map;
 import java.util.Set;
@@ -36,7 +37,6 @@ import org.apache.jackrabbit.oak.core.ImmutableRoot;
 import org.apache.jackrabbit.oak.namepath.GlobalNameMapper;
 import org.apache.jackrabbit.oak.namepath.NamePathMapper;
 import org.apache.jackrabbit.oak.namepath.NamePathMapperImpl;
-import org.apache.jackrabbit.oak.plugins.observation.filter.VisibleFilter;
 import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
 import org.apache.jackrabbit.oak.spi.commit.Observer;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
@@ -135,7 +135,7 @@ public abstract class NodeObserver implements Observer {
             NodeState before = previousRoot;
             NodeState after = root;
             EventHandler handler = new FilteredHandler(
-                    new VisibleFilter(),
+                    VISIBLE_FILTER,
                     new NodeEventHandler("/", info, namePathMapper, oakPropertyNames));
 
             String oakPath = namePathMapper.getOakPath(path);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/ACFilter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/ACFilter.java
index b067aede60..7e2eed3916 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/ACFilter.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/ACFilter.java
@@ -24,7 +24,6 @@ import static com.google.common.base.Preconditions.checkNotNull;
 import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.oak.api.PropertyState;
-import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.plugins.tree.ImmutableTree;
 import org.apache.jackrabbit.oak.spi.security.authorization.permission.PermissionProvider;
 import org.apache.jackrabbit.oak.spi.security.authorization.permission.TreePermission;
@@ -47,23 +46,11 @@ public class ACFilter implements EventFilter {
      * @param before  before state
      * @param after  after state
      * @param permissionProvider  permission provider for access control evaluation
-     * @param basePath  base path from the root the the passed node states
      */
     public ACFilter(@Nonnull NodeState before, @Nonnull NodeState after,
-            @Nonnull PermissionProvider permissionProvider, @Nonnull String basePath) {
-        this(getTreePermission(permissionProvider, after.exists() ? after : before, basePath));
-    }
-
-    private static TreePermission getTreePermission(PermissionProvider permissionProvider,
-            NodeState root, String basePath) {
-        TreePermission treePermission = permissionProvider.getTreePermission(
-                new ImmutableTree(root), TreePermission.EMPTY);
-
-        for (String name : PathUtils.elements(basePath)) {
-            root = root.getChildNode(name);
-            treePermission = treePermission.getChildPermission(name, root);
-        }
-        return treePermission;
+            @Nonnull PermissionProvider permissionProvider) {
+        this(permissionProvider.getTreePermission(
+                new ImmutableTree(after.exists() ? after : before), TreePermission.EMPTY));
     }
 
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilder.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilder.java
index 67fc1c7b40..7651bdf6f2 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilder.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilder.java
@@ -21,6 +21,7 @@ package org.apache.jackrabbit.oak.plugins.observation.filter;
 
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Lists.newArrayList;
 import static javax.jcr.observation.Event.NODE_ADDED;
 import static javax.jcr.observation.Event.NODE_MOVED;
 import static javax.jcr.observation.Event.NODE_REMOVED;
@@ -28,6 +29,7 @@ import static javax.jcr.observation.Event.PERSIST;
 import static javax.jcr.observation.Event.PROPERTY_ADDED;
 import static javax.jcr.observation.Event.PROPERTY_CHANGED;
 import static javax.jcr.observation.Event.PROPERTY_REMOVED;
+import static org.apache.jackrabbit.oak.commons.PathUtils.isAncestor;
 
 import java.util.List;
 
@@ -36,9 +38,8 @@ import javax.annotation.Nonnull;
 
 import com.google.common.base.Objects;
 import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
+import com.google.common.collect.ImmutableList;
 import org.apache.jackrabbit.oak.api.PropertyState;
-import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.plugins.nodetype.TypePredicate;
 import org.apache.jackrabbit.oak.plugins.observation.filter.UniversalFilter.Selector;
 import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
@@ -55,12 +56,47 @@ public final class FilterBuilder {
     private boolean includeSessionLocal;
     private boolean includeClusterExternal;
     private boolean includeClusterLocal = true;
-    private String basePath = "/";
+    private final List<String> subTrees = newArrayList();
     private Condition condition = includeAll();
 
     public interface Condition {
         @Nonnull
-        EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after, String basePath);
+        EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after);
+    }
+
+    /**
+     * Adds a path to the set of paths whose subtrees include all events of
+     * this filter. Does nothing if the paths is already covered by an
+     * path added earlier.
+     * <p>
+     * This is used for optimisation in order to restrict traversal to
+     * these sub trees.
+     *
+     * @param absPath  absolute path
+     * @return  this instance
+     */
+    @Nonnull
+    public FilterBuilder addSubTree(@Nonnull String absPath) {
+        if (absPath.endsWith("/")) {
+            absPath = absPath.substring(0, absPath.length() - 1);
+        }
+        for (String path : subTrees) {
+            if (path.equals(absPath) || isAncestor(path, absPath)) {
+                return this;
+            }
+        }
+        subTrees.add(checkNotNull(absPath));
+        return this;
+    }
+
+    /**
+     * A set of paths whose subtrees include all events of this filter.
+     * @return  list of paths
+     * @see #addSubTree(String)
+     */
+    @Nonnull
+    private Iterable<String> getSubTrees() {
+        return subTrees.isEmpty() ? ImmutableList.of("/") : subTrees;
     }
 
     /**
@@ -99,24 +135,6 @@ public final class FilterBuilder {
         return this;
     }
 
-    /**
-     * The base determines a subtree which contains all filter results.
-     * In the most simple case where a filter should include all events
-     * at a given path that path is at time same time the base path.
-     * <p>
-     * The base path is used for optimising the filter implementation by
-     * upfront exclusion of all parts of the content tree that are out
-     * side of the sub tree designated by the base path.
-     *
-     * @param absPath  absolute path
-     * @return  this instance
-     */
-    @Nonnull
-    public FilterBuilder basePath(@Nonnull String absPath) {
-        this.basePath = checkNotNull(absPath);
-        return this;
-    }
-
     /**
      * Set the condition of this filter. Conditions are obtained from
      * the various methods on this instance that return a {@code Condition}
@@ -301,6 +319,26 @@ public final class FilterBuilder {
         return new AllCondition(checkNotNull(conditions));
     }
 
+    /**
+     * A compound condition that holds when any of its constituents hold.
+     * @param conditions conditions of which any must hold in order for this condition to hold
+     * @return  any condition
+     */
+    @Nonnull
+    public Condition any(@Nonnull Iterable<Condition> conditions) {
+        return new AnyCondition(checkNotNull(conditions));
+    }
+
+    /**
+     * A compound condition that holds when all of its constituents hold.
+     * @param conditions conditions of which all must hold in order for this condition to hold
+     * @return  any condition
+     */
+    @Nonnull
+    public Condition all(@Nonnull Iterable<Condition> conditions) {
+        return new AllCondition(checkNotNull(conditions));
+    }
+
     /**
      * Create a {@code FilterProvider} reflecting the current state of this builder.
      * @return  filter provider of the current state of this builder
@@ -311,7 +349,7 @@ public final class FilterBuilder {
             final boolean includeSessionLocal = FilterBuilder.this.includeSessionLocal;
             final boolean includeClusterExternal = FilterBuilder.this.includeClusterExternal;
             final boolean includeClusterLocal = FilterBuilder.this.includeClusterLocal;
-            final String basePath = FilterBuilder.this.basePath;
+            final Iterable<String> subTrees = FilterBuilder.this.getSubTrees();
             final Condition condition = FilterBuilder.this.condition;
 
             @Override
@@ -324,13 +362,13 @@ public final class FilterBuilder {
             @Nonnull
             @Override
             public EventFilter getFilter(@Nonnull NodeState before, @Nonnull NodeState after) {
-                return condition.createFilter(checkNotNull(before), checkNotNull(after), basePath);
+                return condition.createFilter(checkNotNull(before), checkNotNull(after));
             }
 
             @Nonnull
             @Override
-            public String getPath() {
-                return basePath;
+            public Iterable<String> getSubTrees() {
+                return subTrees;
             }
 
             private boolean isLocal(String sessionId, CommitInfo info) {
@@ -345,13 +383,6 @@ public final class FilterBuilder {
 
     //------------------------------------------------------------< Conditions >---
 
-    private static NodeState getChildNode(NodeState node, String path) {
-        for (String name : PathUtils.elements(path)) {
-            node = node.getChildNode(name);
-        }
-        return node;
-    }
-
     private static class ConstantCondition implements Condition {
         public static final ConstantCondition INCLUDE_ALL = new ConstantCondition(true);
         public static final ConstantCondition EXCLUDE_ALL = new ConstantCondition(false);
@@ -363,7 +394,7 @@ public final class FilterBuilder {
         }
 
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
+        public EventFilter createFilter(NodeState before, NodeState after) {
             return value ? Filters.includeAll() : Filters.excludeAll();
         }
     }
@@ -376,8 +407,8 @@ public final class FilterBuilder {
         }
 
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
-            return new ACFilter(before, after, permissionProvider, basePath);
+        public EventFilter createFilter(NodeState before, NodeState after) {
+            return new ACFilter(before, after, permissionProvider);
         }
     }
 
@@ -389,7 +420,7 @@ public final class FilterBuilder {
         }
 
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
+        public EventFilter createFilter(NodeState before, NodeState after) {
             return new GlobbingPathFilter(pathGlob);
         }
     }
@@ -402,7 +433,7 @@ public final class FilterBuilder {
         }
 
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
+        public EventFilter createFilter(NodeState before, NodeState after) {
             return new EventTypeFilter(eventTypes);
         }
     }
@@ -417,13 +448,10 @@ public final class FilterBuilder {
         }
 
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
+        public EventFilter createFilter(NodeState before, NodeState after) {
             TypePredicate predicate = new TypePredicate(
                     after.exists() ? after : before, ntNames);
-            return new UniversalFilter(
-                    getChildNode(before, basePath),
-                    getChildNode(after, basePath),
-                    selector, predicate);
+            return new UniversalFilter(before, after, selector, predicate);
         }
     }
 
@@ -438,19 +466,15 @@ public final class FilterBuilder {
 
         @Nonnull
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
-            return new UniversalFilter(
-                    getChildNode(before, basePath),
-                    getChildNode(after, basePath),
-                    selector, predicate);
+        public EventFilter createFilter(NodeState before, NodeState after) {
+            return new UniversalFilter(before, after, selector, predicate);
         }
     }
 
     protected static class AddSubtreeTreeCondition implements Condition {
         @Nonnull
         @Override
-        public EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after,
-                String basePath) {
+        public EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after) {
             return AddSubtreeFilter.getInstance();
         }
     }
@@ -458,8 +482,7 @@ public final class FilterBuilder {
     protected static class DeleteSubtreeTreeCondition implements Condition {
         @Nonnull
         @Override
-        public EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after,
-                String basePath) {
+        public EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after) {
             return DeleteSubtreeFilter.getInstance();
         }
     }
@@ -467,27 +490,30 @@ public final class FilterBuilder {
     protected static class MoveCondition implements Condition {
         @Nonnull
         @Override
-        public EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after,
-                String basePath) {
+        public EventFilter createFilter(@Nonnull NodeState before, @Nonnull NodeState after) {
             return new MoveFilter();
         }
     }
 
     private static class AnyCondition implements Condition {
-        private final Condition[] conditions;
+        private final Iterable<Condition> conditions;
 
-        public AnyCondition(Condition... conditions) {
+        public AnyCondition(Iterable<Condition> conditions) {
             this.conditions = conditions;
         }
 
+        public AnyCondition(Condition... conditions) {
+            this(newArrayList(conditions));
+        }
+
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
-            List<EventFilter> filters = Lists.newArrayList();
+        public EventFilter createFilter(NodeState before, NodeState after) {
+            List<EventFilter> filters = newArrayList();
             for (Condition condition : conditions) {
                 if (condition == ConstantCondition.INCLUDE_ALL) {
                     return ConstantFilter.INCLUDE_ALL;
                 } else if (condition != ConstantCondition.EXCLUDE_ALL) {
-                    filters.add(condition.createFilter(before, after, basePath));
+                    filters.add(condition.createFilter(before, after));
                 }
             }
             return filters.isEmpty()
@@ -497,20 +523,24 @@ public final class FilterBuilder {
     }
 
     private static class AllCondition implements Condition {
-        private final Condition[] conditions;
+        private final Iterable<Condition> conditions;
 
-        public AllCondition(Condition... conditions) {
+        public AllCondition(Iterable<Condition> conditions) {
             this.conditions = conditions;
         }
 
+        public AllCondition(Condition... conditions) {
+            this(newArrayList(conditions));
+        }
+
         @Override
-        public EventFilter createFilter(NodeState before, NodeState after, String basePath) {
-            List<EventFilter> filters = Lists.newArrayList();
+        public EventFilter createFilter(NodeState before, NodeState after) {
+            List<EventFilter> filters = newArrayList();
             for (Condition condition : conditions) {
                 if (condition == ConstantCondition.EXCLUDE_ALL) {
                     return ConstantFilter.EXCLUDE_ALL;
                 } else if (condition != ConstantCondition.INCLUDE_ALL) {
-                    filters.add(condition.createFilter(before, after, basePath));
+                    filters.add(condition.createFilter(before, after));
                 }
             }
             return filters.isEmpty()
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterProvider.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterProvider.java
index 864996b575..8dcdb115f3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterProvider.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterProvider.java
@@ -35,11 +35,10 @@ public interface FilterProvider {
      * Filter whole commits. Only commits for which this method returns
      * {@code true} will be further processed to create individual events.
      *
-     * @param sessionId  id of the filtering (this) session
-     * @param info       commit info of the commit or {@code null} if not available
-     * @return           {@code true} if observation events should be created from this
-     *                   commit, {@code false} otherwise.
-     *
+     * @param sessionId id of the filtering (this) session
+     * @param info      commit info of the commit or {@code null} if not available
+     * @return {@code true} if observation events should be created from this
+     * commit, {@code false} otherwise.
      * @see org.apache.jackrabbit.oak.spi.commit.Observer
      */
     boolean includeCommit(@Nonnull String sessionId, @CheckForNull CommitInfo info);
@@ -48,18 +47,19 @@ public interface FilterProvider {
      * Factory method for creating a {@code Filter} for the passed before and after
      * states.
      *
-     * @param before  before state
-     * @param after   after state
+     * @param before before state
+     * @param after  after state
      * @return new {@code Filter} instance
      */
     @Nonnull
     EventFilter getFilter(@Nonnull NodeState before, @Nonnull NodeState after);
 
+
     /**
-     * Path of the subtree to which the the filter returned by
-     * {@link #getFilter(NodeState, NodeState)} applies.
-     * @return path to which the filter applies.
+     * A set of paths whose subtrees include all events of this filter.
+     * @return  list of paths
+     * @see org.apache.jackrabbit.oak.plugins.observation.filter.FilterBuilder#addSubTree(String)
      */
     @Nonnull
-    String getPath();
+    Iterable<String> getSubTrees();
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/VisibleFilter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/VisibleFilter.java
index 692f11b45a..dc3a7e9ef5 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/VisibleFilter.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/observation/filter/VisibleFilter.java
@@ -27,6 +27,9 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
  * Event filter that hides all non-visible content.
  */
 public class VisibleFilter implements EventFilter {
+    public static VisibleFilter VISIBLE_FILTER = new VisibleFilter();
+
+    private VisibleFilter() {}
 
     private static boolean isVisible(String name) {
         return !name.startsWith(":");
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilderTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilderTest.java
index 764a6b9f58..b587578cf0 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilderTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/observation/filter/FilterBuilderTest.java
@@ -34,14 +34,14 @@ public class FilterBuilderTest {
                 builder.path("path"),
                 builder.excludeAll(),
                 builder.path("path"));
-        assertEquals(ConstantFilter.EXCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE, "/"));
+        assertEquals(ConstantFilter.EXCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE));
     }
 
     @Test
     public void emptyAllShortcuts() {
         FilterBuilder builder = new FilterBuilder();
         Condition condition = builder.all();
-        assertEquals(ConstantFilter.INCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE, "/"));
+        assertEquals(ConstantFilter.INCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE));
     }
 
     @Test
@@ -51,14 +51,14 @@ public class FilterBuilderTest {
                 builder.path("path"),
                 builder.includeAll(),
                 builder.path("path"));
-        assertEquals(ConstantFilter.INCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE, "/"));
+        assertEquals(ConstantFilter.INCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE));
     }
 
     @Test
     public void emptyAnyShortcuts() {
         FilterBuilder builder = new FilterBuilder();
         Condition condition = builder.any();
-        assertEquals(ConstantFilter.EXCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE, "/"));
+        assertEquals(ConstantFilter.EXCLUDE_ALL, condition.createFilter(EMPTY_NODE, EMPTY_NODE));
     }
 
 }
