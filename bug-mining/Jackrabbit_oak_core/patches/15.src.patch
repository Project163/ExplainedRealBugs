diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueFactoryImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueFactoryImpl.java
index 1ba3c3514d..9314c43fce 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueFactoryImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueFactoryImpl.java
@@ -77,7 +77,6 @@ public class CoreValueFactoryImpl implements CoreValueFactory {
 
     @Override
     public CoreValue createValue(String value, int type) {
-        // TODO check again...
         if (type == PropertyType.BINARY) {
             BinaryValue bv = new BinaryValue(value, mk);
             return new CoreValueImpl(bv);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueImpl.java
index bd00d9232b..3e6b68f6ba 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/core/CoreValueImpl.java
@@ -75,13 +75,25 @@ class CoreValueImpl implements CoreValue {
             case PropertyType.WEAKREFERENCE:
             case PropertyType.URI:
                 this.value = value;
-                this.type = type;
                 break;
-
+            case PropertyType.BOOLEAN:
+                this.value = Boolean.parseBoolean(value);
+                break;
+            case PropertyType.DOUBLE:
+                this.value = Double.parseDouble(value);
+                break;
+            case PropertyType.DECIMAL:
+                this.value = new BigDecimal(value);
+                break;
+            case PropertyType.LONG:
+                this.value = Long.parseLong(value);
+                break;
             default:
+                // undefined property type or binary.
+                // NOTE: binary must be constructed using BinaryValue -> see CoreValueFactory
                 throw new IllegalArgumentException("Illegal type " + PropertyType.nameFromValue(type));
         }
-
+        this.type = type;
     }
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeState.java
index c12ea5e4ed..634209e21d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelNodeState.java
@@ -24,6 +24,7 @@ import org.apache.jackrabbit.mk.json.JsopTokenizer;
 import org.apache.jackrabbit.oak.api.CoreValue;
 import org.apache.jackrabbit.oak.api.CoreValueFactory;
 import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.util.CoreValueUtil;
 
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -95,9 +96,9 @@ class KernelNodeState extends AbstractNodeState {
                     }
                     childNodes.put(name, new KernelNodeState(kernel, valueFactory, childPath, revision));
                 } else if (reader.matches('[')) {
-                    properties.put(name, new KernelPropertyState(name, readArray(reader)));
+                    properties.put(name, new KernelPropertyState(name, CoreValueUtil.listFromJsopReader(reader, valueFactory)));
                 } else {
-                    CoreValue cv = readValue(reader);
+                    CoreValue cv = CoreValueUtil.fromJsopReader(reader, valueFactory);
                     properties.put(name, new KernelPropertyState(name, cv));
                 }
             } while (reader.matches(','));
@@ -219,34 +220,9 @@ class KernelNodeState extends AbstractNodeState {
     private List<CoreValue> readArray(JsopReader reader) {
         List<CoreValue> values = new ArrayList<CoreValue>();
         while (!reader.matches(']')) {
-            values.add(readValue(reader));
+            values.add(CoreValueUtil.fromJsopReader(reader, valueFactory));
             reader.matches(',');
         }
         return values;
     }
-
-    private CoreValue readValue(JsopReader reader) {
-        CoreValue value;
-        // TODO properly handle property types not covered by JSON: Binary, double, decimal, date, name, path, (weak)ref, uri
-        if (reader.matches(JsopTokenizer.NUMBER)) {
-            String number = reader.getToken();
-            // TODO: property deal with different number types (double, BigDecimal)
-            if (number.indexOf('.') > -1) {
-                value = valueFactory.createValue(Double.valueOf(number));
-            } else {
-                value = valueFactory.createValue(Long.valueOf(number));
-            }
-        } else if (reader.matches(JsopTokenizer.TRUE)) {
-            value = valueFactory.createValue(true);
-        } else if (reader.matches(JsopTokenizer.FALSE)) {
-            value = valueFactory.createValue(false);
-        } else if (reader.matches(JsopTokenizer.STRING)) {
-            // TODO: deal with other property types
-            value = valueFactory.createValue(reader.getToken());
-        }  else {
-            throw new IllegalArgumentException("Unexpected token: " + reader.getToken());
-        }
-        return value;
-    }
-
 }
\ No newline at end of file
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRoot.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRoot.java
index ec7356bfe8..b7eca7f992 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRoot.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/kernel/KernelRoot.java
@@ -19,14 +19,13 @@
 package org.apache.jackrabbit.oak.kernel;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
-import org.apache.jackrabbit.mk.json.JsonBuilder;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.CoreValue;
 import org.apache.jackrabbit.oak.api.Root;
 import org.apache.jackrabbit.oak.api.Tree;
 import org.apache.jackrabbit.oak.kernel.KernelTree.Listener;
+import org.apache.jackrabbit.oak.util.CoreValueUtil;
 
-import javax.jcr.PropertyType;
 import java.util.List;
 
 import static org.apache.jackrabbit.mk.util.PathUtils.elements;
@@ -160,33 +159,6 @@ public class KernelRoot implements Root {
         return path.isEmpty() ? name : path + '/' + name;
     }
 
-    private static String encode(CoreValue value) {
-        switch (value.getType()) {
-            // TODO: deal with all property types.
-            case PropertyType.BOOLEAN: return JsonBuilder.encode(value.getBoolean());
-            case PropertyType.LONG:    return JsonBuilder.encode(value.getLong());
-            case PropertyType.DOUBLE:  return JsonBuilder.encode(value.getDouble());
-            case PropertyType.BINARY:  return null; // TODO implement encoding of binaries
-            case PropertyType.STRING:  return JsonBuilder.encode(value.getString());
-            default: return JsonBuilder.encode(value.getString());
-            //case NULL:    return "null"; // TODO
-        }
-    }
-
-    private static String encode(Iterable<CoreValue> values) {
-        StringBuilder sb = new StringBuilder();
-        sb.append('[');
-        for (CoreValue cv : values) {
-            sb.append(encode(cv));
-            sb.append(',');
-        }
-        if (sb.length() > 1) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        sb.append(']');
-        return sb.toString();
-    }
-
     /**
      * This {@code Listener} implementation records all changes to
      * a associated tree as JSOP.
@@ -206,12 +178,12 @@ public class KernelRoot implements Root {
 
         @Override
         public void setProperty(KernelTree tree, String name, CoreValue value) {
-            jsop.append("^\"").append(path(tree, name)).append("\":").append(encode(value));
+            jsop.append("^\"").append(path(tree, name)).append("\":").append(CoreValueUtil.toJsonValue(value));
         }
 
         @Override
         public void setProperty(KernelTree tree, String name, List<CoreValue> values) {
-            jsop.append("^\"").append(path(tree, name)).append("\":").append(encode(values));
+            jsop.append("^\"").append(path(tree, name)).append("\":").append(CoreValueUtil.toJsonArray(values));
         }
 
         @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/util/CoreValueUtil.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/util/CoreValueUtil.java
new file mode 100644
index 0000000000..a71f3491ba
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/util/CoreValueUtil.java
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.util;
+
+import org.apache.jackrabbit.mk.json.JsonBuilder;
+import org.apache.jackrabbit.mk.json.JsopReader;
+import org.apache.jackrabbit.mk.json.JsopTokenizer;
+import org.apache.jackrabbit.oak.api.CoreValue;
+import org.apache.jackrabbit.oak.api.CoreValueFactory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.jcr.PropertyType;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * CoreValueUtil...
+ *
+ * TODO: review if this should be added to CoreValue/*Factory interfaces
+ */
+public class CoreValueUtil {
+
+    /**
+     * logger instance
+     */
+    private static final Logger log = LoggerFactory.getLogger(CoreValueUtil.class);
+
+    private static final Map<Integer, String> TYPE2HINT = new HashMap<Integer, String>();
+    private static final Map<String, Integer> HINT2TYPE = new HashMap<String, Integer>();
+    static {
+        for (int type = PropertyType.UNDEFINED; type <= PropertyType.DECIMAL; type++) {
+            String hint = PropertyType.nameFromValue(type).substring(0,3).toLowerCase();
+            TYPE2HINT.put(type, hint);
+            HINT2TYPE.put(hint, type);
+        }
+    }
+
+    public static String toJsonValue(CoreValue value) {
+        String jsonString;
+        switch (value.getType()) {
+            case PropertyType.BOOLEAN:
+                jsonString = JsonBuilder.encode(value.getBoolean());
+                break;
+            case PropertyType.LONG:
+                jsonString = JsonBuilder.encode(value.getLong());
+                break;
+            case PropertyType.STRING:
+                String str = value.getString();
+                if (startsWithHint(str)) {
+                    jsonString = buildJsonStringWithType(value);
+                } else {
+                    jsonString = JsonBuilder.encode(value.getString());
+                }
+                break;
+            default:
+                // any other type
+                jsonString = buildJsonStringWithType(value);
+        }
+        return jsonString;
+    }
+
+    public static String toJsonArray(Iterable<CoreValue> values) {
+        StringBuilder sb = new StringBuilder();
+        sb.append('[');
+        for (CoreValue cv : values) {
+            sb.append(toJsonValue(cv));
+            sb.append(',');
+        }
+        if (sb.length() > 1) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        sb.append(']');
+        return sb.toString();
+    }
+
+    public static CoreValue fromJsopReader(JsopReader reader, CoreValueFactory valueFactory) {
+        CoreValue value;
+        if (reader.matches(JsopTokenizer.NUMBER)) {
+            String number = reader.getToken();
+            value = fromJsonString(number, JsopTokenizer.NUMBER, valueFactory);
+        } else if (reader.matches(JsopTokenizer.TRUE)) {
+            value = valueFactory.createValue(true);
+        } else if (reader.matches(JsopTokenizer.FALSE)) {
+            value = valueFactory.createValue(false);
+        } else if (reader.matches(JsopTokenizer.STRING)) {
+            String strValue = reader.getToken();
+            value = fromJsonString(strValue, JsopTokenizer.STRING, valueFactory);
+        }  else {
+            throw new IllegalArgumentException("Unexpected token: " + reader.getToken());
+        }
+        return value;
+    }
+
+    public static List<CoreValue> listFromJsopReader(JsopReader reader, CoreValueFactory valueFactory) {
+        if (!reader.matches('[')) {
+            List<CoreValue> values = new ArrayList<CoreValue>();
+            while (!reader.matches(']')) {
+                values.add(fromJsopReader(reader, valueFactory));
+                reader.matches(',');
+            }
+            return values;
+        } else {
+            throw new IllegalArgumentException("Unexpected token: " + reader.getToken());
+        }
+    }
+
+    // TODO remove again
+    public static CoreValue fromJsonString(String jsonString, int jsopType, CoreValueFactory valueFactory) {
+        CoreValue value;
+        switch (jsopType) {
+            case JsopTokenizer.NUMBER:
+                value = valueFactory.createValue(Long.valueOf(jsonString));
+                break;
+            case JsopTokenizer.FALSE:
+                value = valueFactory.createValue(false);
+                break;
+            case JsopTokenizer.TRUE:
+                value = valueFactory.createValue(true);
+                break;
+            case JsopTokenizer.STRING:
+                if (startsWithHint(jsonString)) {
+                    int type = HINT2TYPE.get(jsonString.substring(0,3));
+                    value = valueFactory.createValue(jsonString.substring(4), type);
+                } else {
+                    value = valueFactory.createValue(jsonString);
+                }
+                break;
+            default:
+                throw new IllegalArgumentException("Invalid jsop type: " + jsopType);
+        }
+        return value;
+    }
+
+
+    private static String buildJsonStringWithType(CoreValue value) {
+        StringBuilder sb = new StringBuilder();
+        sb.append(TYPE2HINT.get(value.getType()));
+        sb.append(':');
+        sb.append(value.getString());
+        return JsonBuilder.encode(sb.toString());
+    }
+
+    private static boolean startsWithHint(String jsonString) {
+        return jsonString.length() >= 4 && jsonString.charAt(3) == ':';
+    }
+}
\ No newline at end of file
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/util/CoreValueUtilTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/util/CoreValueUtilTest.java
new file mode 100644
index 0000000000..565743f541
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/util/CoreValueUtilTest.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.util;
+
+import org.apache.jackrabbit.mk.api.MicroKernel;
+import org.apache.jackrabbit.mk.json.JsopTokenizer;
+import org.apache.jackrabbit.mk.simple.SimpleKernelImpl;
+import org.apache.jackrabbit.oak.api.CoreValue;
+import org.apache.jackrabbit.oak.api.CoreValueFactory;
+import org.apache.jackrabbit.oak.core.CoreValueFactoryImpl;
+import org.junit.Before;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.jcr.PropertyType;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * CoreValueUtilTest...
+ */
+public class CoreValueUtilTest {
+
+    /**
+     * logger instance
+     */
+    private static final Logger log = LoggerFactory.getLogger(CoreValueUtilTest.class);
+
+    // TODO: use regular oak-repo setup
+    private MicroKernel microKernel;
+    private CoreValueFactory valueFactory;
+
+    private Map<CoreValue, String> map;
+
+    @Before
+    public void setUp() throws IOException {
+        microKernel = new SimpleKernelImpl("mem:" + getClass().getName());
+        valueFactory = new CoreValueFactoryImpl(microKernel);
+
+        map = new HashMap<CoreValue, String>();
+        map.put(valueFactory.createValue("abc"), "\"abc\"");
+        map.put(valueFactory.createValue("a:bc"), "\"a:bc\"");
+        map.put(valueFactory.createValue("a:bc"), "\"a:bc\"");
+        map.put(valueFactory.createValue("boo:abc"), "\"str:boo:abc\"");
+        map.put(valueFactory.createValue("str:abc"), "\"str:str:abc\"");
+        map.put(valueFactory.createValue("str:"), "\"str:str:\"");
+
+        map.put(valueFactory.createValue(true), "true");
+        map.put(valueFactory.createValue(false), "false");
+
+        map.put(valueFactory.createValue(12345), "12345");
+        map.put(valueFactory.createValue(1.23), "\"dou:1.23\"");
+        BigDecimal bd = new BigDecimal("12345678901234567890");
+        map.put(valueFactory.createValue(bd), "\"dec:" + bd.toString() + '\"');
+
+        map.put(valueFactory.createValue("2012-05-01T12:00.000:00GMT", PropertyType.DATE), "\"dat:2012-05-01T12:00.000:00GMT\"");
+
+        map.put(valueFactory.createValue("jcr:primaryType", PropertyType.NAME), "\"nam:jcr:primaryType\"");
+        map.put(valueFactory.createValue("/jcr:system", PropertyType.PATH), "\"pat:/jcr:system\"");
+
+        map.put(valueFactory.createValue("http://jackrabbit.apache.org", PropertyType.URI), "\"uri:http://jackrabbit.apache.org\"");
+
+        String uuid = UUID.randomUUID().toString();
+        map.put(valueFactory.createValue(uuid, PropertyType.REFERENCE), "\"ref:" +uuid+ '\"');
+        map.put(valueFactory.createValue(uuid, PropertyType.WEAKREFERENCE), "\"wea:" +uuid+ '\"');
+
+        CoreValue binary = valueFactory.createValue(new ByteArrayInputStream("123".getBytes()));
+        map.put(binary, "\"bin:"+ binary.getString()+ '\"');
+    }
+
+    @Test
+    public void testToJsonValue() throws IOException {
+        for (CoreValue v : map.keySet()) {
+            String json = map.get(v);
+            assertEquals(json, CoreValueUtil.toJsonValue(v));
+        }
+    }
+
+    @Test
+    public void testFromJsonValue() throws IOException {
+        for (CoreValue v : map.keySet()) {
+            String json = map.get(v);
+            int jsopType;
+            if (v.getType() == PropertyType.BOOLEAN) {
+                jsopType = (v.getBoolean()) ? JsopTokenizer.TRUE : JsopTokenizer.FALSE;
+            } else if (v.getType() == PropertyType.LONG) {
+                jsopType = JsopTokenizer.NUMBER;
+            } else {
+                jsopType = JsopTokenizer.STRING;
+                // remove quotes
+                json = json.substring(1, json.length()-1);
+            }
+            assertEquals(v, CoreValueUtil.fromJsonString(json, jsopType, valueFactory));
+        }
+    }
+}
\ No newline at end of file
