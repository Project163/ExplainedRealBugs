diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentSerializer.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentSerializer.java
index b67490ac06..1582ee6a26 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentSerializer.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentSerializer.java
@@ -146,7 +146,9 @@ public class RDBDocumentSerializer {
     public <T extends Document> T fromRow(@Nonnull Collection<T> collection, @Nonnull RDBRow row) throws DocumentStoreException {
         T doc = collection.newDocument(store);
         doc.put(ID, row.getId());
-        doc.put(MODIFIED, row.getModified());
+        if (row.getModified() != 0) {
+            doc.put(MODIFIED, row.getModified());
+        }
         doc.put(MODCOUNT, row.getModcount());
         if (RDBDocumentStore.USECMODCOUNT) {
             doc.put(CMODCOUNT, row.getCollisionsModcount());
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java
index 90e82958d3..837ba39cea 100755
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/rdb/RDBDocumentStore.java
@@ -1419,14 +1419,21 @@ public class RDBDocumentStore implements DocumentStore {
                 } else {
                     // we got a document from the cache, thus collection is NODES
                     // and a tracker is present
-                    Lock lock = locks.acquire(row.getId());
-                    try {
-                        if (!tracker.mightBeenAffected(row.getId())) {
-                            // otherwise mark it as fresh
-                            ((NodeDocument) doc).markUpToDate(now);
+                    long lastmodified = modifiedOf(doc);
+                    if (lastmodified == row.getModified() && lastmodified >= 1) {
+                        Lock lock = locks.acquire(row.getId());
+                        try {
+                            if (!tracker.mightBeenAffected(row.getId())) {
+                                // otherwise mark it as fresh
+                                ((NodeDocument) doc).markUpToDate(now);
+                            }
+                        } finally {
+                            lock.unlock();
                         }
-                    } finally {
-                        lock.unlock();
+                    }
+                    else {
+                        // we need a fresh document instance
+                        doc = convertFromDBObject(collection, row);
                     }
                 }
                 result.add(doc);
@@ -1466,9 +1473,10 @@ public class RDBDocumentStore implements DocumentStore {
         final Stopwatch watch = startWatch();
         boolean docFound = true;
         try {
-            long lastmodcount = -1;
+            long lastmodcount = -1, lastmodified = -1;
             if (cachedDoc != null) {
                 lastmodcount = modcountOf(cachedDoc);
+                lastmodified = modifiedOf(cachedDoc);
             }
             connection = this.ch.getROConnection();
             RDBRow row = db.read(connection, tmd, id, lastmodcount);
@@ -1477,11 +1485,18 @@ public class RDBDocumentStore implements DocumentStore {
                 docFound = false;
                 return null;
             } else {
-                if (lastmodcount == row.getModcount()) {
+                if (lastmodcount == row.getModcount() && lastmodified == row.getModified() && lastmodified >= 1) {
                     // we can re-use the cached document
                     cachedDoc.markUpToDate(System.currentTimeMillis());
                     return castAsT(cachedDoc);
                 } else {
+                    // workaround: need to re-read if data is not present
+                    // that would be the case if the modcount did match but the modified time did not
+                    // see OAK-4509
+                    if (row.getData() == null) {
+                        row = db.read(connection, tmd, id, -1);
+                        connection.commit();
+                    }
                     return convertFromDBObject(collection, row);
                 }
             }
@@ -1812,6 +1827,11 @@ public class RDBDocumentStore implements DocumentStore {
         return n != null ? n : -1;
     }
 
+    private static long modifiedOf(@Nonnull Document doc) {
+        Object l = doc.get(NodeDocument.MODIFIED_IN_SECS);
+        return (l instanceof Long) ? ((Long)l).longValue() : -1;
+    }
+
     @Nonnull
     protected <T extends Document> T convertFromDBObject(@Nonnull Collection<T> collection, @Nonnull RDBRow row) {
         // this method is present here in order to facilitate unit testing for OAK-3566
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ResurrectNodeAfterRevisionGCTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ResurrectNodeAfterRevisionGCTest.java
index c284d144dc..516b190627 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ResurrectNodeAfterRevisionGCTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ResurrectNodeAfterRevisionGCTest.java
@@ -38,7 +38,6 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assume.assumeFalse;
 
 public class ResurrectNodeAfterRevisionGCTest
         extends AbstractMultiDocumentStoreTest {
@@ -49,7 +48,6 @@ public class ResurrectNodeAfterRevisionGCTest
 
     public ResurrectNodeAfterRevisionGCTest(DocumentStoreFixture dsf) {
         super(dsf);
-        assumeFalse(dsf instanceof DocumentStoreFixture.RDBFixture);
     }
 
     @Before
