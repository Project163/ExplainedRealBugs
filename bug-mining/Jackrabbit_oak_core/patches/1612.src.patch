diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionEditor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionEditor.java
index 3469418f8d..933318fa2a 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionEditor.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/version/VersionEditor.java
@@ -27,12 +27,15 @@ import static org.apache.jackrabbit.oak.plugins.version.VersionConstants.RESTORE
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import javax.jcr.nodetype.NodeDefinition;
+import javax.jcr.version.OnParentVersionAction;
 
 import org.apache.jackrabbit.JcrConstants;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.lock.LockConstants;
+import org.apache.jackrabbit.oak.plugins.tree.TreeFactory;
 import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
 import org.apache.jackrabbit.oak.spi.commit.Editor;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
@@ -85,10 +88,10 @@ class VersionEditor implements Editor {
             // deleted or versionable -> check if it was checked in
             // a node cannot be modified if it was checked in
             // unless it has a new identifier
-            isReadOnly = wasCheckedIn() && !hasNewIdentifier();
+            isReadOnly = wasCheckedIn() && !hasNewIdentifier() && !isIgnoreOnOPV();
         } else {
             // otherwise inherit from parent
-            isReadOnly = parent != null && parent.isReadOnly;
+            isReadOnly = parent != null && parent.isReadOnly && !isIgnoreOnOPV();
         }
     }
 
@@ -108,7 +111,7 @@ class VersionEditor implements Editor {
             vMgr.restore(node, after.getValue(Type.REFERENCE), null);
             return;
         }
-        if (!isReadOnly) {
+        if (!isReadOnly || getOPV(after) == OnParentVersionAction.IGNORE) {
             return;
         }
         // JCR allows to put a lock on a checked in node.
@@ -124,7 +127,7 @@ class VersionEditor implements Editor {
     public void propertyChanged(PropertyState before, PropertyState after)
             throws CommitFailedException {
         if (!isVersionable()) {
-            if (!isVersionProperty(after) && isReadOnly) {
+            if (!isVersionProperty(after) && isReadOnly && getOPV(after) != OnParentVersionAction.IGNORE) {
                 throwCheckedIn("Cannot change property " + after.getName()
                         + " on checked in node");
             }
@@ -146,7 +149,7 @@ class VersionEditor implements Editor {
             vMgr.restore(node, baseVersion, null);
         } else if (isVersionProperty(after)) {
             throwProtected(after.getName());
-        } else if (isReadOnly) {
+        } else if (isReadOnly && getOPV(after) != OnParentVersionAction.IGNORE) {
             throwCheckedIn("Cannot change property " + after.getName()
                     + " on checked in node");
         }
@@ -156,7 +159,7 @@ class VersionEditor implements Editor {
     public void propertyDeleted(PropertyState before)
             throws CommitFailedException {
         if (isReadOnly) {
-            if (!isVersionProperty(before) && !isLockProperty(before)) {
+            if (!isVersionProperty(before) && !isLockProperty(before) && getOPV(before) != OnParentVersionAction.IGNORE) {
                 throwCheckedIn("Cannot delete property on checked in node");
             }
         }
@@ -253,4 +256,27 @@ class VersionEditor implements Editor {
         throw new CommitFailedException(CommitFailedException.CONSTRAINT, 100,
                 "Property is protected: " + name);
     }
+
+    private boolean isIgnoreOnOPV() throws CommitFailedException {
+        if (this.parent != null) {
+            try {
+                NodeDefinition definition = this.vMgr.getNodeTypeManager().getDefinition(TreeFactory.createTree(parent.node), this.name);
+                return definition.getOnParentVersion() == OnParentVersionAction.IGNORE;
+            } catch (Exception e) {
+                throw new CommitFailedException(CommitFailedException.VERSION,
+                        VersionExceptionCode.UNEXPECTED_REPOSITORY_EXCEPTION.ordinal(), e.getMessage());
+            }
+        }
+        return false;
+    }
+
+    private int getOPV(PropertyState property) throws CommitFailedException {
+        try {
+            return this.vMgr.getNodeTypeManager().getDefinition(TreeFactory.createReadOnlyTree(this.node.getNodeState()),
+                    property, false).getOnParentVersion();
+        } catch (Exception e) {
+            throw new CommitFailedException(CommitFailedException.VERSION,
+                    VersionExceptionCode.UNEXPECTED_REPOSITORY_EXCEPTION.ordinal(), e.getMessage());
+        }
+    }
 }
