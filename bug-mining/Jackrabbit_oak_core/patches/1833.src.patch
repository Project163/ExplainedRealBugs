diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java
index 0ab5829096..fa95310a6b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java
@@ -277,8 +277,18 @@ public class IndexUpdate implements Editor, PathSource {
                     continue;
                 }
 
-                Editor editor = rootState.provider.getIndexEditor(type, definition, rootState.root,
-                        rootState.newCallback(indexPath, shouldReindex, getEstimatedCount(definition)));
+                Editor editor = null;
+                try {
+                    editor = rootState.provider.getIndexEditor(type, definition, rootState.root,
+                            rootState.newCallback(indexPath, shouldReindex, getEstimatedCount(definition)));
+                } catch (IllegalStateException e) {
+                    // This will be caught here in case there is any config related error in the index definition
+                    // where multiple values are assigned to a property that is supposed to be single valued
+                    // We log an error message here and continue - this way the bad index defintion is ignored and doesn't block the async index update
+                    log.error("Unable to get Index Editor for index at {} . Please correct the index definition " +
+                            "and reindex after correction. Additional Info : {}", indexPath, e.getMessage(), e);
+                    continue;
+                }
                 if (editor == null) {
                     // if this isn't an async cycle AND definition has "async" property
                     // (and implicitly isIncluded method allows async def in non-async cycle only for nrt/sync defs)
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java
index 90be3b8bb8..a453bc4339 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java
@@ -61,6 +61,7 @@ import org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexLookup;
 import org.apache.jackrabbit.oak.plugins.index.reference.ReferenceEditorProvider;
 import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;
+import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
 import org.apache.jackrabbit.oak.plugins.memory.PropertyValues;
 import org.apache.jackrabbit.oak.query.NodeStateNodeTypeInfoProvider;
 import org.apache.jackrabbit.oak.query.QueryEngineSettings;
@@ -72,13 +73,16 @@ import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
 import org.apache.jackrabbit.oak.spi.commit.Editor;
 import org.apache.jackrabbit.oak.spi.commit.EditorHook;
 import org.apache.jackrabbit.oak.spi.commit.EditorProvider;
+import org.apache.jackrabbit.oak.spi.filter.PathFilter;
 import org.apache.jackrabbit.oak.spi.query.Filter;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStateUtils;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.apache.jackrabbit.util.ISO8601;
+import org.hamcrest.core.IsCollectionContaining;
 import org.jetbrains.annotations.NotNull;
+import org.junit.Assert;
 import org.junit.Test;
 
 import com.google.common.collect.ImmutableSet;
@@ -1008,6 +1012,71 @@ public class IndexUpdateTest {
         customLogs.finished();
 
     }
+    
+     /*
+     Given 2 index defintions - one with a config error and another ok , the content under second should get indexed
+     while the first with error gets ignored with an error message logged.
+      */
+     @Test
+     public void testConfigErrorInIndexDefintion() throws Exception{
+         LogCustomizer customLogs = LogCustomizer.forLogger(IndexUpdate.class.getName()).enable(Level.ERROR).create();
+         builder.child("testRoot").setProperty("foo", "abc");
+         //Create 2 index def - one with config related error and one without
+ 
+         NodeBuilder index1 = createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME),
+                 "rootIndex1", true, false, ImmutableSet.of("foo"), null);
+ 
+         index1.setProperty(PropertyStates.createProperty(
+                 PathFilter.PROP_INCLUDED_PATHS, ImmutableSet.of("/test/a/b"), Type.STRINGS));
+         index1.setProperty(PropertyStates.createProperty(
+                 PathFilter.PROP_EXCLUDED_PATHS, ImmutableSet.of("/test/a"), Type.STRINGS));
+ 
+         createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME),
+                 "rootIndex2", true, false, ImmutableSet.of("foo2"), null);
+ 
+         NodeState before = builder.getNodeState();
+ 
+         // Add some content and process it through the property index hook (for index1)
+         builder.child("test").child("a").setProperty("foo", "abc");
+         builder.child("test").child("a").child("b").setProperty("foo", "abc");
+         //Now for  for index2
+         builder.child("test").child("b").setProperty("foo2","abc");
+         builder.child("test").child("a").child("b").setProperty("foo2", "abc");
+ 
+         NodeState after = builder.getNodeState();
+         NodeState indexed;
+         try{
+             customLogs.starting();
+             String expectedLogMessage = "Unable to get Index Editor for index at /oak:index/rootIndex1 . " +
+                     "Please correct the index definition and reindex after correction. " +
+                     "Additional Info : No valid include provided. Includes [/test/a/b], Excludes [/test/a]";
+             indexed = HOOK.processCommit(before, after, CommitInfo.EMPTY);
+             Assert.assertThat(customLogs.getLogs(), IsCollectionContaining.hasItems(expectedLogMessage));
+         } finally {
+             customLogs.finished();
+         }
+ 
+         // Now check that the index content nodes doesn't exists and the reindex flag is still set(Since it got skipped)
+         NodeState ns = checkPathExists(indexed, INDEX_DEFINITIONS_NAME,
+                 "rootIndex1");
+         assertFalse(ns.getChildNode(INDEX_CONTENT_NODE_NAME).exists());
+         PropertyState ps = ns.getProperty(REINDEX_PROPERTY_NAME);
+         assertNotNull(ps);
+         assertTrue(ps.getValue(Type.BOOLEAN));
+ 
+         //Now check everything is fine with index2 - indexed data node exists and reindex flag is false
+         NodeState ns2 = checkPathExists(indexed, INDEX_DEFINITIONS_NAME,
+                 "rootIndex2");
+         checkPathExists(ns2,INDEX_CONTENT_NODE_NAME);
+         PropertyState ps2 = ns2.getProperty(REINDEX_PROPERTY_NAME);
+         assertNotNull(ps2);
+         assertFalse(ps2.getValue(Type.BOOLEAN));
+ 
+         // next, lookup should work for the index def  2 which did not have any config errors
+         PropertyIndexLookup lookup = new PropertyIndexLookup(indexed);
+         assertEquals(ImmutableSet.of("test/b","test/a/b"), find(lookup, "foo2", "abc"));
+ 
+    }    
 
     private static void markCorrupt(NodeBuilder builder, String indexName) {
         builder.getChildNode(INDEX_DEFINITIONS_NAME).getChildNode(indexName)
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
index e1cb839e1b..ad5833edad 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
@@ -45,7 +45,9 @@ import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
+import org.apache.jackrabbit.oak.commons.junit.LogCustomizer;
 import org.apache.jackrabbit.oak.plugins.index.IndexConstants;
+import org.apache.jackrabbit.oak.plugins.index.IndexUpdate;
 import org.apache.jackrabbit.oak.plugins.index.IndexUpdateProvider;
 import org.apache.jackrabbit.oak.plugins.index.property.strategy.ContentMirrorStoreStrategy;
 import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;
@@ -71,6 +73,8 @@ import org.apache.jackrabbit.oak.spi.mount.Mounts;
 import org.apache.jackrabbit.oak.spi.query.Filter;
 import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
+import org.hamcrest.core.IsCollectionContaining;
+import org.junit.Assert;
 import org.junit.Test;
 import org.slf4j.LoggerFactory;
 
@@ -847,6 +851,7 @@ public class PropertyIndexTest {
 
     @Test
     public void testPathExcludeInclude() throws Exception{
+        LogCustomizer customLogs = LogCustomizer.forLogger(IndexUpdate.class.getName()).enable(Level.ERROR).create();
         NodeState root = INITIAL_CONTENT;
 
         // Add index definition
@@ -863,9 +868,18 @@ public class PropertyIndexTest {
         NodeState after = builder.getNodeState();
 
         try {
+            customLogs.starting();
+            String expectedLogMessage = "Unable to get Index Editor for index at /oak:index/foo . " +
+                    "Please correct the index definition and reindex after correction. " +
+                    "Additional Info : No valid include provided. Includes [/test/a/b], Excludes [/test/a]";
             HOOK.processCommit(before, after, CommitInfo.EMPTY);
-            assertTrue(false);
-        } catch (IllegalStateException expected) {}
+            Assert.assertThat(customLogs.getLogs(), IsCollectionContaining.hasItems(expectedLogMessage));
+        } catch (IllegalStateException unexpected) {
+                // IllegalStateException not expected here now <OAK-8328>
+                assertTrue(false);            
+        } finally {
+            customLogs.finished();
+        }
     }
 
     @Test
