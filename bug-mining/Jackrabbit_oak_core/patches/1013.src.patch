diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java
index 84ac11a4bb..62811a07a3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentWriter.java
@@ -46,6 +46,7 @@ import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -191,6 +192,8 @@ public class SegmentWriter {
                     refcount * 16 + rootcount * 3 + blobrefcount * 2 + length,
                     16);
 
+            checkState(length <= buffer.length);
+
             int pos = refcount * 16;
             if (pos + length <= buffer.length) {
                 // the whole segment fits to the space *after* the referenced
@@ -291,14 +294,23 @@ public class SegmentWriter {
             refcount -= idcount;
 
             Set<SegmentId> segmentIds = newIdentityHashSet();
+            
+            // The set of old record ids in this segment
+            // that were previously root record ids, but will no longer be,
+            // because the record to be written references them.
+            // This needs to be a set, because the list of ids can
+            // potentially reference the same record multiple times
+            Set<RecordId> notRoots = new HashSet<RecordId>();
             for (RecordId recordId : ids) {
                 SegmentId segmentId = recordId.getSegmentId();
                 if (segmentId != segment.getSegmentId()) {
                     segmentIds.add(segmentId);
                 } else if (roots.containsKey(recordId)) {
-                    rootcount--;
+                    notRoots.add(recordId);
                 }
             }
+            rootcount -= notRoots.size();
+
             if (!segmentIds.isEmpty()) {
                 for (int refid = 1; refid < refcount; refid++) {
                     segmentIds.remove(segment.getRefId(refid));
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStoreTest.java
index 2908dc2de1..fbbb513be6 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStoreTest.java
@@ -43,7 +43,6 @@ import org.apache.jackrabbit.oak.plugins.segment.SegmentNodeBuilder;
 import org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState;
 import org.apache.jackrabbit.oak.plugins.segment.SegmentWriter;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 public class FileStoreTest {
@@ -222,32 +221,37 @@ public class FileStoreTest {
                 newArrayList(newTreeSet(files.keySet())));
     }
 
-    @Ignore("OAK-2049")
     @Test  // See OAK-2049
     public void segmentOverflow() throws IOException {
-        FileStore store = new FileStore(directory, 1, false);
-        SegmentWriter writer = store.getTracker().getWriter();
-        // writer.length == 32  (from the root node)
-
-        // adding 15 strings with 16516 bytes each
-        for (int k = 0; k < 15; k++) {
-            // 16516 = (Segment.MEDIUM_LIMIT - 1 + 2 + 3)
-            // 1 byte per char, 2 byte to store the length and 3 bytes for the
-            // alignment to the integer boundary
-            writer.writeString(Strings.repeat("abcdefghijklmno".substring(k, k + 1),
-                    Segment.MEDIUM_LIMIT - 1));
+        for (int n = 1; n < 255; n++) {  // 255 = ListRecord.LEVEL_SIZE
+            FileStore store = new FileStore(directory, 1, false);
+            SegmentWriter writer = store.getTracker().getWriter();
+            // writer.length == 32  (from the root node)
+
+            // adding 15 strings with 16516 bytes each
+            for (int k = 0; k < 15; k++) {
+                // 16516 = (Segment.MEDIUM_LIMIT - 1 + 2 + 3)
+                // 1 byte per char, 2 byte to store the length and 3 bytes for the
+                // alignment to the integer boundary
+                writer.writeString(Strings.repeat("abcdefghijklmno".substring(k, k + 1),
+                        Segment.MEDIUM_LIMIT - 1));
+            }
+
+            // adding 14280 bytes. 1 byte per char, and 2 bytes to store the length
+            RecordId x = writer.writeString(Strings.repeat("x", 14278));
+            // writer.length == 262052
+
+            // Adding 765 bytes (255 recordIds)
+            // This should cause the current segment to flush
+            List<RecordId> list = Collections.nCopies(n, x);
+            writer.writeList(list);
+
+            writer.flush();
+
+            // Don't close the store in a finally clause as if a failure happens
+            // this will also fail an cover up the earlier exception
+            store.close();
         }
-
-        // adding 14280 bytes. 1 byte per char, and 2 bytes to store the length
-        RecordId x = writer.writeString(Strings.repeat("x", 14278));
-        // writer.length == 262052
-
-        // Adding 765 bytes (255 recordIds)
-        // This should cause the current segment to flush
-        List<RecordId> list = Collections.nCopies(255, x);  // 255 = ListRecord.LEVEL_SIZE
-        writer.writeList(list);
-
-        writer.flush();
     }
 
 }
