diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Branch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Branch.java
index bb8ea99a91..6dd49a7d82 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Branch.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Branch.java
@@ -41,20 +41,31 @@ class Branch {
      */
     private final Revision base;
 
+    /**
+     * Create a new branch instance with an initial set of commits and a given
+     * base revision.
+     *
+     * @param commits the initial branch commits.
+     * @param base the base commit.
+     * @param comparator the revision comparator.
+     * @throws IllegalArgumentException if base is a branch revision.
+     */
     Branch(@Nonnull SortedSet<Revision> commits,
            @Nonnull Revision base,
            @Nonnull Revision.RevisionComparator comparator) {
-        this.base = checkNotNull(base);
+        checkArgument(!checkNotNull(base).isBranch(), "base is not a trunk revision: %s", base);
+        this.base = base;
         this.commits = new TreeMap<Revision, BranchCommit>(
                 checkNotNull(comparator));
         for (Revision r : commits) {
-            this.commits.put(r, new BranchCommit(base));
+            this.commits.put(r.asBranchRevision(), new BranchCommit(base));
         }
     }
 
     /**
      * @return the initial base of this branch.
      */
+    @Nonnull
     Revision getBase() {
         return base;
     }
@@ -67,8 +78,9 @@ class Branch {
      * @throws IllegalArgumentException if <code>r</code> is not a commit of
      *                                  this branch.
      */
-    synchronized Revision getBase(Revision r) {
-        BranchCommit c = commits.get(r);
+    @Nonnull
+    synchronized Revision getBase(@Nonnull Revision r) {
+        BranchCommit c = commits.get(checkNotNull(r).asBranchRevision());
         if (c == null) {
             throw new IllegalArgumentException(
                     "Revision " + r + " is not a commit in this branch");
@@ -81,8 +93,12 @@ class Branch {
      *
      * @param head the new head of the branch.
      * @param base rebase to this revision.
+     * @throws IllegalArgumentException if head is a trunk revision or base is a
+     *                                  branch revision.
      */
-    synchronized void rebase(Revision head, Revision base) {
+    synchronized void rebase(@Nonnull Revision head, @Nonnull Revision base) {
+        checkArgument(checkNotNull(head).isBranch(), "Not a branch revision: %s", head);
+        checkArgument(!checkNotNull(base).isBranch(), "Not a trunk revision: %s", base);
         Revision last = commits.lastKey();
         checkArgument(commits.comparator().compare(head, last) > 0);
         commits.put(head, new BranchCommit(base));
@@ -92,8 +108,10 @@ class Branch {
      * Adds a new commit with revision <code>r</code> to this branch.
      *
      * @param r the revision of the branch commit to add.
+     * @throws IllegalArgumentException if r is not a branch revision.
      */
     synchronized void addCommit(@Nonnull Revision r) {
+        checkArgument(checkNotNull(r).isBranch(), "Not a branch revision: %s", r);
         Revision last = commits.lastKey();
         checkArgument(commits.comparator().compare(r, last) > 0);
         commits.put(r, new BranchCommit(commits.get(last).getBase()));
@@ -124,7 +142,7 @@ class Branch {
      *         revision; <code>false</code> otherwise.
      */
     synchronized boolean containsCommit(@Nonnull Revision r) {
-        return commits.containsKey(r);
+        return commits.containsKey(checkNotNull(r).asBranchRevision());
     }
 
     /**
@@ -132,8 +150,10 @@ class Branch {
      * if there is no such commit.
      *
      * @param r the revision of the commit to remove.
+     * @throws IllegalArgumentException if r is not a branch revision.
      */
     public synchronized void removeCommit(@Nonnull Revision r) {
+        checkArgument(checkNotNull(r).isBranch(), "Not a branch revision: %s", r);
         commits.remove(r);
     }
 
@@ -142,11 +162,12 @@ class Branch {
      *
      * @param r a branch commit revision.
      * @return the unsaved modification for the given branch commit.
-     * @throws IllegalArgumentException if there is no commit with the given
-     *                                  revision.
+     * @throws IllegalArgumentException r is not a branch revision or if there
+     *                                  is no commit with the given revision.
      */
     @Nonnull
     public synchronized UnsavedModifications getModifications(@Nonnull Revision r) {
+        checkArgument(checkNotNull(r).isBranch(), "Not a branch revision: %s", r);
         BranchCommit c = commits.get(r);
         if (c == null) {
             throw new IllegalArgumentException(
@@ -182,6 +203,7 @@ class Branch {
     @CheckForNull
     public synchronized Revision getUnsavedLastRevision(String path,
                                                         Revision readRevision) {
+        readRevision = readRevision.asBranchRevision();
         for (Revision r : commits.descendingKeySet()) {
             if (readRevision.compareRevisionTime(r) < 0) {
                 continue;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
index 23f6d831d0..f23e3d9cd1 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
@@ -658,8 +658,6 @@ public class MongoMK implements MicroKernel, RevisionContext {
         if (path == null || path.equals("")) {
             path = "/";
         }
-        fromRevisionId = stripBranchRevMarker(fromRevisionId);
-        toRevisionId = stripBranchRevMarker(toRevisionId);
         Revision fromRev = Revision.fromString(fromRevisionId);
         Revision toRev = Revision.fromString(toRevisionId);
         Node from = getNode(path, fromRev);
@@ -779,7 +777,7 @@ public class MongoMK implements MicroKernel, RevisionContext {
             throw new MicroKernelException("Path is not absolute: " + path);
         }
         revisionId = revisionId != null ? revisionId : headRevision.toString();
-        Revision rev = Revision.fromString(stripBranchRevMarker(revisionId));
+        Revision rev = Revision.fromString(revisionId);
         Node n = getNode(path, rev);
         return n != null;
     }
@@ -799,7 +797,6 @@ public class MongoMK implements MicroKernel, RevisionContext {
             throw new MicroKernelException("Only depth 0 is supported, depth is " + depth);
         }
         revisionId = revisionId != null ? revisionId : headRevision.toString();
-        revisionId = stripBranchRevMarker(revisionId);
         Revision rev = Revision.fromString(revisionId);
         Node n = getNode(path, rev);
         if (n == null) {
@@ -850,7 +847,7 @@ public class MongoMK implements MicroKernel, RevisionContext {
             baseRev = headRevision;
             baseRevId = baseRev.toString();
         } else {
-            baseRev = Revision.fromString(stripBranchRevMarker(baseRevId));
+            baseRev = Revision.fromString(baseRevId);
         }
         JsopReader t = new JsopTokenizer(json);
         Revision rev = newRevision();
@@ -923,11 +920,13 @@ public class MongoMK implements MicroKernel, RevisionContext {
                 throw new MicroKernelException("token: " + (char) t.getTokenType());
             }
         }
-        if (baseRevId.startsWith("b")) {
+        if (baseRev.isBranch()) {
+            rev = rev.asBranchRevision();
             // remember branch commit
             Branch b = branches.getBranch(baseRev);
             if (b == null) {
-                b = branches.create(baseRev, rev);
+                // baseRev is marker for new branch
+                b = branches.create(baseRev.asTrunkRevision(), rev);
             } else {
                 b.addCommit(rev);
             }
@@ -945,11 +944,12 @@ public class MongoMK implements MicroKernel, RevisionContext {
                 }
             }
 
-            return "b" + rev.toString();
+            return rev.toString();
+        } else {
+            commit.apply();
+            headRevision = commit.getRevision();
+            return rev.toString();
         }
-        commit.apply();
-        headRevision = commit.getRevision();
-        return rev.toString();
     }
 
     //------------------------< RevisionContext >-------------------------------
@@ -1073,13 +1073,6 @@ public class MongoMK implements MicroKernel, RevisionContext {
         nodeCache.invalidate(path + "@" + rev);
     }
 
-    private static String stripBranchRevMarker(String revisionId) {
-        if (revisionId.startsWith("b")) {
-            return revisionId.substring(1);
-        }
-        return revisionId;
-    }
-    
     public static void parseAddNode(Commit commit, JsopReader t, String path) {
         Node n = new Node(path, commit.getRevision());
         if (!t.matches('}')) {
@@ -1104,27 +1097,28 @@ public class MongoMK implements MicroKernel, RevisionContext {
     public String branch(@Nullable String trunkRevisionId) throws MicroKernelException {
         // nothing is written when the branch is created, the returned
         // revision simply acts as a reference to the branch base revision
-        String revisionId = trunkRevisionId != null ? trunkRevisionId : headRevision.toString();
-        return "b" + revisionId;
+        Revision revision = trunkRevisionId != null
+                ? Revision.fromString(trunkRevisionId) : headRevision;
+        return revision.asBranchRevision().toString();
     }
 
     @Override
     public synchronized String merge(String branchRevisionId, String message)
             throws MicroKernelException {
         // TODO improve implementation if needed
-        if (!branchRevisionId.startsWith("b")) {
+        Revision revision = Revision.fromString(branchRevisionId);
+        if (!revision.isBranch()) {
             throw new MicroKernelException("Not a branch: " + branchRevisionId);
         }
 
-        String revisionId = stripBranchRevMarker(branchRevisionId);
         // make branch commits visible
         UpdateOp op = new UpdateOp(Utils.getIdFromPath("/"), false);
-        Revision revision = Revision.fromString(revisionId);
         Branch b = branches.getBranch(revision);
         Revision mergeCommit = newRevision();
         NodeDocument.setModified(op, mergeCommit);
         if (b != null) {
             for (Revision rev : b.getCommits()) {
+                rev = rev.asTrunkRevision();
                 NodeDocument.setRevision(op, rev, "c-" + mergeCommit.toString());
                 op.containsMapEntry(NodeDocument.COLLISIONS, rev.toString(), false);
             }
@@ -1148,23 +1142,23 @@ public class MongoMK implements MicroKernel, RevisionContext {
                          @Nullable String newBaseRevisionId)
             throws MicroKernelException {
         // TODO conflict handling
-        Revision r = Revision.fromString(stripBranchRevMarker(branchRevisionId));
+        Revision r = Revision.fromString(branchRevisionId);
         Revision base = newBaseRevisionId != null ?
                 Revision.fromString(newBaseRevisionId) :
                 headRevision;
         Branch b = branches.getBranch(r);
         if (b == null) {
             // empty branch
-            return "b" + base.toString();
+            return base.asBranchRevision().toString();
         }
         if (b.getBase().equals(base)) {
             return branchRevisionId;
         }
         // add a pseudo commit to make sure current head of branch
         // has a higher revision than base of branch
-        Revision head = newRevision();
+        Revision head = newRevision().asBranchRevision();
         b.rebase(head, base);
-        return "b" + head.toString();
+        return head.toString();
     }
 
     @Override
@@ -1226,7 +1220,8 @@ public class MongoMK implements MicroKernel, RevisionContext {
             ArrayList<String> removed) {
         UnsavedModifications unsaved = unsavedLastRevisions;
         if (isBranchCommit) {
-            unsaved = branches.getBranch(rev).getModifications(rev);
+            Revision branchRev = rev.asBranchRevision();
+            unsaved = branches.getBranch(branchRev).getModifications(branchRev);
         }
         // track unsaved modifications of nodes that were not
         // written in the commit (implicitly modified parent)
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java
index f0ed137ff8..c815e5a951 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java
@@ -338,37 +338,7 @@ public class NodeDocument extends Document {
         if (validRevisions.contains(rev)) {
             return true;
         }
-        if (containsRevision(rev)) {
-            if (isCommitted(context, rev, readRevision)) {
-                validRevisions.add(rev);
-                return true;
-            } else {
-                // rev is in revisions map of this node, but not committed
-                // no need to check _commitRoot field
-                return false;
-            }
-        }
-        // check commit root
-        @SuppressWarnings("unchecked")
-        Map<String, Integer> commitRoot = (Map<String, Integer>) get(COMMIT_ROOT);
-        String commitRootPath = null;
-        if (commitRoot != null) {
-            Integer depth = commitRoot.get(rev.toString());
-            if (depth != null) {
-                String p = Utils.getPathFromId(getId());
-                commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);
-            }
-        }
-        if (commitRootPath == null) {
-            // shouldn't happen, either node is commit root for a revision
-            // or has a reference to the commit root
-            log.warn("Node {} does not have commit root reference for revision {}",
-                    getId(), rev);
-            return false;
-        }
-        // get root of commit
-        NodeDocument doc = store.find(Collection.NODES,
-                Utils.getIdFromPath(commitRootPath));
+        NodeDocument doc = getCommitRoot(rev);
         if (doc == null) {
             return false;
         }
@@ -760,6 +730,40 @@ public class NodeDocument extends Document {
 
     //----------------------------< internal >----------------------------------
 
+    /**
+     * Returns the commit root document for the given revision. This may either
+     * be this document or another one.
+     *
+     * @param rev a revision.
+     * @return the commit root or <code>null</code> if there is none.
+     */
+    @CheckForNull
+    private NodeDocument getCommitRoot(@Nonnull Revision rev) {
+        if (containsRevision(rev)) {
+            return this;
+        }
+        // check commit root
+        @SuppressWarnings("unchecked")
+        Map<String, Integer> commitRoot = (Map<String, Integer>) get(COMMIT_ROOT);
+        String commitRootPath = null;
+        if (commitRoot != null) {
+            Integer depth = commitRoot.get(rev.toString());
+            if (depth != null) {
+                String p = Utils.getPathFromId(getId());
+                commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);
+            }
+        }
+        if (commitRootPath == null) {
+            // shouldn't happen, either node is commit root for a revision
+            // or has a reference to the commit root
+            log.warn("Node {} does not have commit root reference for revision {}",
+                    getId(), rev);
+            return null;
+        }
+        // get root of commit
+        return store.find(Collection.NODES, Utils.getIdFromPath(commitRootPath));
+    }
+
     /**
      * Checks that revision x is newer than another revision.
      *
@@ -787,40 +791,59 @@ public class NodeDocument extends Document {
     private boolean isCommitted(@Nonnull RevisionContext context,
                                 @Nonnull Revision revision,
                                 @Nonnull Revision readRevision) {
-        if (revision.equals(readRevision)) {
+        if (revision.equalsIgnoreBranch(readRevision)) {
             return true;
         }
-        String r = revision.toString();
-        String value = getRevisionsMap().get(r);
-        if (value == null) {
-            // check previous
-            for (NodeDocument prev : getPreviousDocs(revision)) {
-                value = prev.getRevisionsMap().get(r);
-                if (value != null) {
-                    break;
-                }
-            }
-        }
+        String value = getCommitValue(revision);
         if (value == null) {
             return false;
         }
         if (Utils.isCommitted(value)) {
-            // resolve commit revision
-            revision = Utils.resolveCommitRevision(revision, value);
-            if (context.getBranches().getBranch(readRevision) == null) {
+            if (context.getBranches().getBranch(readRevision) == null
+                    && !readRevision.isBranch()) {
+                // resolve commit revision
+                revision = Utils.resolveCommitRevision(revision, value);
                 // readRevision is not from a branch
                 // compare resolved revision as is
                 return !isRevisionNewer(context, revision, readRevision);
+            } else {
+                // on same merged branch?
+                if (value.equals(getCommitValue(readRevision.asTrunkRevision()))) {
+                    // compare unresolved revision
+                    return !isRevisionNewer(context, revision, readRevision);
+                }
             }
         } else {
-            // branch commit
+            // branch commit (not merged)
             if (Revision.fromString(value).getClusterId() != context.getClusterId()) {
                 // this is an unmerged branch commit from another cluster node,
                 // hence never visible to us
                 return false;
             }
         }
-        return includeRevision(context, revision, readRevision);
+        return includeRevision(context, Utils.resolveCommitRevision(revision, value), readRevision);
+    }
+
+    /**
+     * Returns the commit value for the given <code>revision</code>.
+     *
+     * @param revision a revision.
+     * @return the commit value or <code>null</code> if the revision is unknown.
+     */
+    @CheckForNull
+    private String getCommitValue(Revision revision) {
+        String r = revision.toString();
+        String value = getRevisionsMap().get(r);
+        if (value == null) {
+            // check previous
+            for (NodeDocument prev : getPreviousDocs(revision)) {
+                value = prev.getRevisionsMap().get(r);
+                if (value != null) {
+                    break;
+                }
+            }
+        }
+        return value;
     }
 
     private static boolean includeRevision(RevisionContext context,
@@ -833,7 +856,8 @@ public class NodeDocument extends Document {
             if (b.containsCommit(requestRevision)) {
                 // in same branch, include if the same revision or
                 // requestRevision is newer
-                return x.equals(requestRevision) || isRevisionNewer(context, requestRevision, x);
+                return x.equalsIgnoreBranch(requestRevision)
+                        || isRevisionNewer(context, requestRevision, x);
             }
             // not part of branch identified by requestedRevision
             return false;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Revision.java
index c6239d8799..69c05ad57c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Revision.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Revision.java
@@ -51,6 +51,11 @@ public class Revision {
      * The cluster id (the MongoDB machine id).
      */
     private int clusterId;
+
+    /**
+     * Whether this is a branch revision.
+     */
+    private final boolean branch;
     
     /**
      * The string representation.
@@ -58,11 +63,16 @@ public class Revision {
     private String string;
     
     public Revision(long timestamp, int counter, int clusterId) {
+        this(timestamp, counter, clusterId, false);
+    }
+    
+    public Revision(long timestamp, int counter, int clusterId, boolean branch) {
         this.timestamp = timestamp;
         this.counter = counter;
         this.clusterId = clusterId;
+        this.branch = branch;
     }
-    
+
     /**
      * Compare the time part of two revisions. If they contain the same time,
      * the counter is compared.
@@ -128,6 +138,11 @@ public class Revision {
     }
     
     public static Revision fromString(String rev) {
+        boolean isBranch = false;
+        if (rev.startsWith("b")) {
+            isBranch = true;
+            rev = rev.substring(1);
+        }
         if (!rev.startsWith("r")) {
             throw new IllegalArgumentException(rev);
         }
@@ -145,14 +160,15 @@ public class Revision {
         int c = Integer.parseInt(t, 16);
         t = rev.substring(idxClusterId + 1);
         int clusterId = Integer.parseInt(t, 16);
-        Revision r = new Revision(timestamp, c, clusterId);
+        Revision r = new Revision(timestamp, c, clusterId, isBranch);
         return r;
     }
     
     @Override
     public String toString() {
         if (string == null) {
-            string = new StringBuilder("r").
+            string = new StringBuilder(branch ? "b" : "").
+                append('r').
                 append(Long.toHexString(timestamp)).
                 append('-').
                 append(Integer.toHexString(counter)).
@@ -175,7 +191,43 @@ public class Revision {
     public int getCounter() {
         return counter;
     }
-    
+
+    /**
+     * @return <code>true</code> if this is a branch revision, otherwise
+     *         <code>false</code>.
+     */
+    public boolean isBranch() {
+        return branch;
+    }
+
+    /**
+     * Returns a revision with the same timestamp, counter and clusterId as this
+     * revision and the branch flag set to <code>true</code>.
+     *
+     * @return branch revision with this timestamp, counter and clusterId.
+     */
+    public Revision asBranchRevision() {
+        if (isBranch()) {
+            return this;
+        } else {
+            return new Revision(timestamp, counter, clusterId, true);
+        }
+    }
+
+    /**
+     * Returns a revision with the same timestamp, counter and clusterId as this
+     * revision and the branch flag set to <code>false</code>.
+     *
+     * @return trunkrevision with this timestamp, counter and clusterId.
+     */
+    public Revision asTrunkRevision() {
+        if (!isBranch()) {
+            return this;
+        } else {
+            return new Revision(timestamp, counter, clusterId);
+        }
+    }
+
     @Override
     public int hashCode() {
         return (int) (timestamp >>> 32) ^ (int) timestamp ^ counter ^ clusterId;
@@ -193,7 +245,19 @@ public class Revision {
         Revision r = (Revision) other;
         return r.timestamp == this.timestamp && 
                 r.counter == this.counter && 
-                r.clusterId == this.clusterId;
+                r.clusterId == this.clusterId &&
+                r.branch == this.branch;
+    }
+
+    public boolean equalsIgnoreBranch(Revision other) {
+        if (this == other) {
+            return true;
+        } else if (other == null) {
+            return false;
+        }
+        return other.timestamp == this.timestamp &&
+                other.counter == this.counter &&
+                other.clusterId == this.clusterId;
     }
 
     public int getClusterId() {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java
index 40a622f61f..86522e01e8 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java
@@ -28,6 +28,7 @@ import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.oak.plugins.mongomk.util.Utils;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -67,15 +68,18 @@ class UnmergedBranches {
             throw new IllegalStateException("already initialized");
         }
         NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath("/"));
+        if (doc == null) {
+            return;
+        }
         SortedMap<Revision, Revision> revisions = doc.getUncommittedRevisions(context);
         while (!revisions.isEmpty()) {
             SortedSet<Revision> commits = new TreeSet<Revision>(comparator);
             Revision head = revisions.lastKey();
             commits.add(head);
-            Revision base = revisions.remove(head);
+            Revision base = revisions.remove(head).asTrunkRevision();
             while (revisions.containsKey(base)) {
                 commits.add(base);
-                base = revisions.remove(base);
+                base = revisions.remove(base).asTrunkRevision();
             }
             branches.add(new Branch(commits, base, comparator));
         }
@@ -87,12 +91,17 @@ class UnmergedBranches {
      * @param base the base revision of the branch.
      * @param initial the initial commit to the branch.
      * @return the branch.
+     * @throws IllegalArgumentException if
      */
     @Nonnull
     Branch create(@Nonnull Revision base, @Nonnull Revision initial) {
+        checkArgument(!checkNotNull(base).isBranch(),
+                "base is not a trunk revision: %s", base);
+        checkArgument(checkNotNull(initial).isBranch(),
+                "initial is not a branch revision: %s", initial);
         SortedSet<Revision> commits = new TreeSet<Revision>(comparator);
-        commits.add(checkNotNull(initial));
-        Branch b = new Branch(commits, checkNotNull(base), comparator);
+        commits.add(initial);
+        Branch b = new Branch(commits, base, comparator);
         synchronized (branches) {
             branches.add(b);
         }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKBranchMergeTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKBranchMergeTest.java
index 56ca5bfaf2..48e8e3a6c9 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKBranchMergeTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMKBranchMergeTest.java
@@ -441,14 +441,18 @@ public class MongoMKBranchMergeTest extends BaseMongoMKTest {
         }
     }
 
-    @Ignore("OAK-992")
     @Test
     public void branchReadAfterMerge() {
         String branchRev = mk.branch(null);
-        branchRev = mk.commit("/", "+\"foo\":{}", branchRev, null);
-        branchRev = mk.commit("/", "+\"bar\":{}", branchRev, null);
-        mk.merge(branchRev, null);
-        assertNodesExist(branchRev, "/foo");
+        String branchRev1 = mk.commit("/", "+\"foo\":{}", branchRev, null);
+        String branchRev2 = mk.commit("/", "+\"bar\":{}", branchRev1, null);
+        mk.merge(branchRev2, null);
+
+        assertNodesExist(branchRev2, "/foo");
+        assertNodesExist(branchRev2, "/bar");
+
+        assertNodesExist(branchRev1, "/foo");
+        assertNodesNotExist(branchRev1, "/bar");
     }
 
     //--------------------------< internal >------------------------------------
