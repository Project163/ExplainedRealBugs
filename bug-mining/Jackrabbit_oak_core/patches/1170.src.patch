diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreService.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreService.java
index 8e95ee1d53..b30173bfbe 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreService.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreService.java
@@ -574,7 +574,11 @@ public class DocumentNodeStoreService {
         RevisionGC revisionGC = new RevisionGC(new Runnable() {
             @Override
             public void run() {
-                store.getVersionGarbageCollector().gc(versionGcMaxAgeInSecs, TimeUnit.SECONDS);
+                try {
+                    store.getVersionGarbageCollector().gc(versionGcMaxAgeInSecs, TimeUnit.SECONDS);
+                } catch (IOException e) {
+                    log.warn("Error occurred while executing the Version Garbage Collector", e);
+                }
             }
         }, executor);
         registrations.add(registerMBean(whiteboard, RevisionGCMBean.class, revisionGC,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java
index 2b1b7f0e7b..822e50f256 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java
@@ -19,9 +19,9 @@
 
 package org.apache.jackrabbit.oak.plugins.document;
 
-import java.util.ArrayList;
-import java.util.Collections;
+import java.io.IOException;
 import java.util.EnumSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
@@ -31,18 +31,23 @@ import com.google.common.base.StandardSystemProperty;
 import com.google.common.base.Stopwatch;
 import com.google.common.collect.ImmutableList;
 
+import org.apache.jackrabbit.oak.commons.sort.StringSort;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static com.google.common.collect.Iterators.partition;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.COMMIT_ROOT_ONLY;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.DEFAULT_LEAF;
 
 public class VersionGarbageCollector {
+    //Kept less than MongoDocumentStore.IN_CLAUSE_BATCH_SIZE to avoid re-partitioning
+    private static final int DELETE_BATCH_SIZE = 450;
     private final DocumentNodeStore nodeStore;
     private final VersionGCSupport versionStore;
+    private int overflowToDiskThreshold = 100000;
 
-    private final Logger log = LoggerFactory.getLogger(getClass());
+    private static final Logger log = LoggerFactory.getLogger(VersionGarbageCollector.class);
 
     /**
      * Split document types which can be safely garbage collected
@@ -56,7 +61,7 @@ public class VersionGarbageCollector {
         this.versionStore = gcSupport;
     }
 
-    public VersionGCStats gc(long maxRevisionAge, TimeUnit unit) {
+    public VersionGCStats gc(long maxRevisionAge, TimeUnit unit) throws IOException {
         long maxRevisionAgeInMillis = unit.toMillis(maxRevisionAge);
         Stopwatch sw = Stopwatch.createStarted();
         VersionGCStats stats = new VersionGCStats();
@@ -85,41 +90,60 @@ public class VersionGarbageCollector {
         return stats;
     }
 
+    public void setOverflowToDiskThreshold(int overflowToDiskThreshold) {
+        this.overflowToDiskThreshold = overflowToDiskThreshold;
+    }
+
     private void collectSplitDocuments(VersionGCStats stats, long oldestRevTimeStamp) {
         versionStore.deleteSplitDocuments(GC_TYPES, oldestRevTimeStamp, stats);
     }
 
-    private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp) {
-        List<String> docIdsToDelete = new ArrayList<String>();
-        Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);
+    private void collectDeletedDocuments(VersionGCStats stats, Revision headRevision, long oldestRevTimeStamp)
+            throws IOException {
+        StringSort docIdsToDelete = new StringSort(overflowToDiskThreshold, NodeDocumentIdComparator.INSTANCE);
         try {
-            for (NodeDocument doc : itr) {
-                //Check if node is actually deleted at current revision
-                //As node is not modified since oldestRevTimeStamp then
-                //this node has not be revived again in past maxRevisionAge
-                //So deleting it is safe
-                if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {
-                    docIdsToDelete.add(doc.getId());
-                    //Collect id of all previous docs also
-                    for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {
-                        docIdsToDelete.add(prevDoc.getId());
+            Iterable<NodeDocument> itr = versionStore.getPossiblyDeletedDocs(oldestRevTimeStamp);
+            try {
+                for (NodeDocument doc : itr) {
+                    //Check if node is actually deleted at current revision
+                    //As node is not modified since oldestRevTimeStamp then
+                    //this node has not be revived again in past maxRevisionAge
+                    //So deleting it is safe
+                    if (doc.getNodeAtRevision(nodeStore, headRevision, null) == null) {
+                        docIdsToDelete.add(doc.getId());
+                        //Collect id of all previous docs also
+                        for (NodeDocument prevDoc : ImmutableList.copyOf(doc.getAllPreviousDocs())) {
+                            docIdsToDelete.add(prevDoc.getId());
+                        }
                     }
                 }
+            } finally {
+                Utils.closeIfCloseable(itr);
+            }
+
+            if (docIdsToDelete.isEmpty()){
+                return;
             }
-        } finally {
-            Utils.closeIfCloseable(itr);
-        }
 
-        Collections.sort(docIdsToDelete, NodeDocumentIdComparator.INSTANCE);
+            docIdsToDelete.sort();
+            log.info("Proceeding to delete [{}] documents", docIdsToDelete.getSize());
 
-        if(log.isDebugEnabled()) {
-            StringBuilder sb = new StringBuilder("Deleted document with following ids were deleted as part of GC \n");
-            Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete);
-            log.debug(sb.toString());
+            if (log.isDebugEnabled() && docIdsToDelete.getSize() < 1000) {
+                StringBuilder sb = new StringBuilder("Deleted document with following ids were deleted as part of GC \n");
+                Joiner.on(StandardSystemProperty.LINE_SEPARATOR.value()).appendTo(sb, docIdsToDelete.getIds());
+                log.debug(sb.toString());
+            }
+
+            Iterator<List<String>> idListItr = partition(docIdsToDelete.getIds(), DELETE_BATCH_SIZE);
+            while (idListItr.hasNext()) {
+                nodeStore.getDocumentStore().remove(Collection.NODES, idListItr.next());
+            }
+
+            nodeStore.invalidateDocChildrenCache();
+            stats.deletedDocGCCount += docIdsToDelete.getSize();
+        } finally {
+            docIdsToDelete.close();
         }
-        nodeStore.getDocumentStore().remove(Collection.NODES, docIdsToDelete);
-        nodeStore.invalidateDocChildrenCache();
-        stats.deletedDocGCCount += docIdsToDelete.size();
     }
 
     public static class VersionGCStats {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java
index 052525b13a..443feed49a 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java
@@ -36,6 +36,7 @@ import org.junit.Before;
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.HOURS;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
@@ -104,6 +105,53 @@ public class VersionGCDeletionTest {
         assertNull(ts.find(Collection.NODES, "1:/x"));
     }
 
+    @Test
+    public void deleteLargeNumber() throws Exception{
+        int noOfDocsToDelete = 10000;
+        DocumentStore ts = new MemoryDocumentStore();
+        store = new DocumentMK.Builder()
+                .clock(clock)
+                .setDocumentStore(new MemoryDocumentStore())
+                .setAsyncDelay(0)
+                .getNodeStore();
+
+        //Baseline the clock
+        clock.waitUntil(Revision.getCurrentTimestamp());
+
+        NodeBuilder b1 = store.getRoot().builder();
+        NodeBuilder xb = b1.child("x");
+        for (int i = 0; i < noOfDocsToDelete; i++){
+            xb.child("a"+i).child("b"+i);
+        }
+        store.merge(b1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        long maxAge = 1; //hours
+        long delta = TimeUnit.MINUTES.toMillis(10);
+
+        //Remove x/y
+        NodeBuilder b2 = store.getRoot().builder();
+        b2.child("x").remove();
+        store.merge(b2, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        store.runBackgroundOperations();
+
+        //3. Check that deleted doc does get collected post maxAge
+        clock.waitUntil(clock.getTime() + HOURS.toMillis(maxAge*2) + delta);
+        VersionGarbageCollector gc = store.getVersionGarbageCollector();
+        gc.setOverflowToDiskThreshold(100);
+
+        VersionGarbageCollector.VersionGCStats stats = gc.gc(maxAge * 2, HOURS);
+        assertEquals(noOfDocsToDelete * 2 + 1, stats.deletedDocGCCount);
+
+
+        assertNull(ts.find(Collection.NODES, "1:/x"));
+
+        for (int i = 0; i < noOfDocsToDelete; i++){
+            assertNull(ts.find(Collection.NODES, "2:/a"+i+"/b"+i));
+            assertNull(ts.find(Collection.NODES, "1:/a"+i));
+        }
+    }
+
     private static class TestDocumentStore extends MemoryDocumentStore {
         boolean throwException;
         @Override
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCWithSplitTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCWithSplitTest.java
index e586961b4a..8642f60184 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCWithSplitTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCWithSplitTest.java
@@ -137,7 +137,11 @@ public class VersionGCWithSplitTest {
         Thread t = new Thread(new Runnable() {
             @Override
             public void run() {
-                stats.set(gc.gc(1, HOURS));
+                try {
+                    stats.set(gc.gc(1, HOURS));
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
             }
         });
 
