diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java
index f0ea78cf9f..0d518b3e62 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfo.java
@@ -166,7 +166,7 @@ public class ClusterNodeInfo {
             update.set(INSTANCE_ID_KEY, clusterNode.instanceId);
             update.set(LEASE_END_KEY, System.currentTimeMillis() + clusterNode.leaseTime);
             update.set(INFO_KEY, clusterNode.toString());
-            boolean success = store.create(DocumentStore.Collection.CLUSTER_NODES, Collections.singletonList(update));
+            boolean success = store.create(Collection.CLUSTER_NODES, Collections.singletonList(update));
             if (success) {
                 return clusterNode;
             }
@@ -177,7 +177,7 @@ public class ClusterNodeInfo {
     private static ClusterNodeInfo createInstance(DocumentStore store, String machineId, String instanceId) {
         long now = System.currentTimeMillis();
         // keys between "0" and "a" includes all possible numbers
-        List<Document> list = store.query(DocumentStore.Collection.CLUSTER_NODES,
+        List<ClusterNodeInfoDocument> list = store.query(Collection.CLUSTER_NODES,
                 "0", "a", Integer.MAX_VALUE);
         int clusterNodeId = 0;
         int maxId = 0;
@@ -199,7 +199,7 @@ public class ClusterNodeInfo {
             String iId = "" + doc.get(INSTANCE_ID_KEY);
             if (machineId.startsWith(RANDOM_PREFIX)) {
                 // remove expired entries with random keys
-                store.remove(DocumentStore.Collection.CLUSTER_NODES, key);
+                store.remove(Collection.CLUSTER_NODES, key);
                 continue;
             }
             if (!mId.equals(machineId) || 
@@ -208,7 +208,7 @@ public class ClusterNodeInfo {
                 continue;
             }
             // remove expired matching entries
-            store.remove(DocumentStore.Collection.CLUSTER_NODES, key);
+            store.remove(Collection.CLUSTER_NODES, key);
             if (clusterNodeId == 0 || id < clusterNodeId) {
                 // if there are multiple, use the smallest value
                 clusterNodeId = id;
@@ -234,7 +234,7 @@ public class ClusterNodeInfo {
         UpdateOp update = new UpdateOp(null, "" + id, true);
         leaseEndTime = now + leaseTime;
         update.set(LEASE_END_KEY, leaseEndTime);
-        store.createOrUpdate(DocumentStore.Collection.CLUSTER_NODES, update);
+        store.createOrUpdate(Collection.CLUSTER_NODES, update);
     }
     
     public void setLeaseTime(long leaseTime) {
@@ -248,7 +248,7 @@ public class ClusterNodeInfo {
     public void dispose() {
         UpdateOp update = new UpdateOp(null, "" + id, true);
         update.set(LEASE_END_KEY, null);
-        store.createOrUpdate(DocumentStore.Collection.CLUSTER_NODES, update);
+        store.createOrUpdate(Collection.CLUSTER_NODES, update);
     }
     
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfoDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfoDocument.java
new file mode 100644
index 0000000000..54acb5e9e8
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/ClusterNodeInfoDocument.java
@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.mongomk;
+
+/**
+ * A document storing cluster node info. See also {@link ClusterNodeInfo}.
+ */
+public class ClusterNodeInfoDocument extends Document {
+
+    private static final long serialVersionUID = 4392051250296984718L;
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collection.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collection.java
new file mode 100644
index 0000000000..c22a8b2540
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collection.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.mongomk;
+
+import javax.annotation.Nonnull;
+
+/**
+ * The collection types.
+ */
+public abstract class Collection<T extends Document> {
+
+    /**
+     * The 'nodes' collection. It contains all the node data, with one document
+     * per node, and the path as the primary key. Each document possibly
+     * contains multiple revisions.
+     * <p>
+     * Key: the path, value: the node data (possibly multiple revisions)
+     * <p>
+     * Old revisions are removed after some time, either by the process that
+     * removed or updated the node, lazily when reading, or in a background
+     * process.
+     */
+    public static final Collection<NodeDocument> NODES =
+            new Collection<NodeDocument>("nodes") {
+                @Override
+                public NodeDocument newDocument() {
+                    return new NodeDocument();
+                }
+            };
+
+    /**
+     * The 'clusterNodes' collection contains the list of currently running
+     * cluster nodes. The key is the clusterNodeId (0, 1, 2,...).
+     */
+    public static final Collection<ClusterNodeInfoDocument> CLUSTER_NODES =
+            new Collection<ClusterNodeInfoDocument>("clusterNodes") {
+                @Override
+                public ClusterNodeInfoDocument newDocument() {
+                    return new ClusterNodeInfoDocument();
+                }
+            };
+
+    private final String name;
+
+    public Collection(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    /**
+     * @return a new document for this collection.
+     */
+    @Nonnull
+    public abstract T newDocument();
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collision.java
index ce148d31be..c802b3d086 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collision.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Collision.java
@@ -46,12 +46,12 @@ class Collision {
 
     private static final Logger LOG = LoggerFactory.getLogger(Collision.class);
 
-    private final Document document;
+    private final NodeDocument document;
     private final String theirRev;
     private final UpdateOp ourOp;
     private final String ourRev;
 
-    Collision(@Nonnull Document document,
+    Collision(@Nonnull NodeDocument document,
               @Nonnull Revision theirRev,
               @Nonnull UpdateOp ourOp,
               @Nonnull Revision ourRev) {
@@ -75,7 +75,7 @@ class Collision {
             return;
         }
         // their commit wins, we have to mark ourRev
-        Document newDoc = Utils.newDocument();
+        NodeDocument newDoc = Collection.NODES.newDocument();
         Utils.deepCopyMap(document, newDoc);
         MemoryDocumentStore.applyChanges(newDoc, ourOp);
         if (!markCommitRoot(newDoc, ourRev, store)) {
@@ -96,7 +96,7 @@ class Collision {
      * @return <code>true</code> if the commit for the given revision was marked
      *         successfully; <code>false</code> otherwise.
      */
-    private static boolean markCommitRoot(@Nonnull Document document,
+    private static boolean markCommitRoot(@Nonnull NodeDocument document,
                                           @Nonnull String revision,
                                           @Nonnull DocumentStore store) {
         String p = Utils.getPathFromId(document.getId());
@@ -131,13 +131,13 @@ class Collision {
         // at this point we have a commitRootPath
         UpdateOp op = new UpdateOp(commitRootPath,
                 Utils.getIdFromPath(commitRootPath), false);
-        document = store.find(DocumentStore.Collection.NODES, op.getKey());
+        document = store.find(Collection.NODES, op.getKey());
         // check commit status of revision
         if (isCommitted(revision, document)) {
             return false;
         }
         op.setMapEntry(UpdateOp.COLLISIONS, revision, true);
-        document = store.createOrUpdate(DocumentStore.Collection.NODES, op);
+        document = store.createOrUpdate(Collection.NODES, op);
         // check again on old document right before our update was applied
         if (isCommitted(revision, document)) {
             return false;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Commit.java
index f5b6eee399..e1a1bb79e3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Commit.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/Commit.java
@@ -27,7 +27,6 @@ import java.util.concurrent.atomic.AtomicReference;
 import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.mk.json.JsopStream;
 import org.apache.jackrabbit.mk.json.JsopWriter;
-import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore.Collection;
 import org.apache.jackrabbit.oak.plugins.mongomk.util.Utils;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.slf4j.Logger;
@@ -283,7 +282,7 @@ public class Commit {
      * @param op the operation
      */
     public void createOrUpdateNode(DocumentStore store, UpdateOp op) {
-        Document doc = store.createOrUpdate(Collection.NODES, op);
+        NodeDocument doc = store.createOrUpdate(Collection.NODES, op);
         if (baseRevision != null) {
             final AtomicReference<List<Revision>> collisions = new AtomicReference<List<Revision>>();
             Revision newestRev = mk.getNewestRevision(doc, revision,
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java
index cb11b866db..1fd9101f1b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/DocumentStore.java
@@ -29,43 +29,6 @@ import org.apache.jackrabbit.mk.api.MicroKernelException;
  */
 public interface DocumentStore {
 
-    /**
-     * The list of collections.
-     */
-    enum Collection { 
-        
-        /**
-         * The 'nodes' collection. It contains all the node data, with one document
-         * per node, and the path as the primary key. Each document possibly
-         * contains multiple revisions.
-         * <p>
-         * Key: the path, value: the node data (possibly multiple revisions)
-         * <p>
-         * Old revisions are removed after some time, either by the process that
-         * removed or updated the node, lazily when reading, or in a background
-         * process.
-         */
-        NODES("nodes"), 
-        
-        /**
-         * The 'clusterNodes' collection contains the list of currently running
-         * cluster nodes. The key is the clusterNodeId (0, 1, 2,...).
-         */
-        CLUSTER_NODES("clusterNodes");
-            
-        final String name;
-        
-        Collection(String name) {
-            this.name = name;
-        }
-        
-        @Override
-        public String toString() {
-            return name;
-        }
-        
-    }
-
     /**
      * Get a document.
      * <p>
@@ -77,7 +40,7 @@ public interface DocumentStore {
      * @return the document, or null if not found
      */
     @CheckForNull
-    Document find(Collection collection, String key);
+    <T extends Document> T find(Collection<T> collection, String key);
     
     /**
      * Get a document, ignoring the cache if the cached entry is older than the
@@ -92,7 +55,7 @@ public interface DocumentStore {
      * @return the document, or null if not found
      */
     @CheckForNull
-    Document find(Collection collection, String key, int maxCacheAge);
+    <T extends Document> T find(Collection<T> collection, String key, int maxCacheAge);
 
     /**
      * Get a list of documents where the key is greater than a start value and
@@ -105,10 +68,10 @@ public interface DocumentStore {
      * @return the list (possibly empty)
      */
     @Nonnull
-    List<Document> query(Collection collection,
-                         String fromKey,
-                         String toKey,
-                         int limit);
+    <T extends Document> List<T> query(Collection<T> collection,
+                                       String fromKey,
+                                       String toKey,
+                                       int limit);
     
     /**
      * Get a list of documents where the key is greater than a start value and
@@ -123,12 +86,12 @@ public interface DocumentStore {
      * @return the list (possibly empty)
      */
     @Nonnull
-    List<Document> query(Collection collection,
-                         String fromKey,
-                         String toKey,
-                         String indexedProperty,
-                         long startValue,
-                         int limit);
+    <T extends Document> List<T> query(Collection<T> collection,
+                                       String fromKey,
+                                       String toKey,
+                                       String indexedProperty,
+                                       long startValue,
+                                       int limit);
 
     /**
      * Remove a document.
@@ -136,7 +99,7 @@ public interface DocumentStore {
      * @param collection the collection
      * @param key the key
      */
-    void remove(Collection collection, String key);
+    <T extends Document> void remove(Collection<T> collection, String key);
 
     /**
      * Try to create a list of documents.
@@ -145,7 +108,7 @@ public interface DocumentStore {
      * @param updateOps the list of documents to add
      * @return true if this worked (if none of the documents already existed)
      */
-    boolean create(Collection collection, List<UpdateOp> updateOps);
+    <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps);
     
     /**
      * Create or update a document. For MongoDb, this is using "findAndModify" with
@@ -157,7 +120,7 @@ public interface DocumentStore {
      * @throws MicroKernelException if the operation failed.
      */    
     @Nonnull
-    Document createOrUpdate(Collection collection, UpdateOp update)
+    <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException;
 
     /**
@@ -172,7 +135,7 @@ public interface DocumentStore {
      * @throws MicroKernelException if the operation failed.
      */
     @CheckForNull
-    Document findAndUpdate(Collection collection, UpdateOp update)
+    <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException;
 
     /**
@@ -186,7 +149,7 @@ public interface DocumentStore {
      * @param collection the collection
      * @param key the key
      */
-    void invalidateCache(Collection collection, String key);
+    <T extends Document> void invalidateCache(Collection<T> collection, String key);
 
     /**
      * Dispose this instance.
@@ -200,6 +163,6 @@ public interface DocumentStore {
      * @param key the key
      * @return true if yes
      */
-    boolean isCached(Collection collection, String key);
+    <T extends Document> boolean isCached(Collection<T> collection, String key);
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java
index ca38a43cf3..57486a956d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MemoryDocumentStore.java
@@ -39,8 +39,8 @@ public class MemoryDocumentStore implements DocumentStore {
     /**
      * The 'nodes' collection.
      */
-    private ConcurrentSkipListMap<String, Document> nodes =
-            new ConcurrentSkipListMap<String, Document>();
+    private ConcurrentSkipListMap<String, NodeDocument> nodes =
+            new ConcurrentSkipListMap<String, NodeDocument>();
     
     /**
      * The 'clusterNodes' collection.
@@ -49,18 +49,18 @@ public class MemoryDocumentStore implements DocumentStore {
             new ConcurrentSkipListMap<String, Document>();
 
     @Override
-    public Document find(Collection collection, String key, int maxCacheAge) {
+    public <T extends Document> T find(Collection<T> collection, String key, int maxCacheAge) {
         return find(collection, key);
     }
     
     @Override
-    public Document find(Collection collection, String key) {
-        ConcurrentSkipListMap<String, Document> map = getMap(collection);
+    public <T extends Document> T find(Collection<T> collection, String key) {
+        ConcurrentSkipListMap<String, T> map = getMap(collection);
         Document doc = map.get(key);
         if (doc == null) {
             return null;
         }
-        Document copy = Utils.newDocument();
+        T copy = collection.newDocument();
         synchronized (doc) {
             Utils.deepCopyMap(doc, copy);
         }
@@ -69,7 +69,7 @@ public class MemoryDocumentStore implements DocumentStore {
     
     @Override
     @Nonnull
-    public List<Document> query(Collection collection,
+    public <T extends Document> List<T> query(Collection<T> collection,
                                 String fromKey,
                                 String toKey,
                                 int limit) {
@@ -78,15 +78,15 @@ public class MemoryDocumentStore implements DocumentStore {
     
     @Override
     @Nonnull
-    public List<Document> query(Collection collection,
+    public <T extends Document> List<T> query(Collection<T> collection,
                                 String fromKey,
                                 String toKey,
                                 String indexedProperty,
                                 long startValue,
                                 int limit) {
-        ConcurrentSkipListMap<String, Document> map = getMap(collection);
-        ConcurrentNavigableMap<String, Document> sub = map.subMap(fromKey, toKey);
-        ArrayList<Document> list = new ArrayList<Document>();
+        ConcurrentSkipListMap<String, T> map = getMap(collection);
+        ConcurrentNavigableMap<String, T> sub = map.subMap(fromKey, toKey);
+        ArrayList<T> list = new ArrayList<T>();
         for (Document doc : sub.values()) {
             if (indexedProperty != null) {
                 Long value = (Long) doc.get(indexedProperty);
@@ -94,7 +94,7 @@ public class MemoryDocumentStore implements DocumentStore {
                     continue;
                 }
             }
-            Document copy = Utils.newDocument();
+            T copy = collection.newDocument();
             synchronized (doc) {
                 Utils.deepCopyMap(doc, copy);
             }
@@ -117,24 +117,25 @@ public class MemoryDocumentStore implements DocumentStore {
      * @param collection the collection
      * @return the map
      */
-    private ConcurrentSkipListMap<String, Document> getMap(Collection collection) {
-        switch (collection) {
-        case NODES:
-            return nodes;
-        case CLUSTER_NODES:
-            return clusterNodes;
-        default:
-            throw new IllegalArgumentException(collection.name());
+    @SuppressWarnings("unchecked")
+    private <T extends Document> ConcurrentSkipListMap<String, T> getMap(Collection<T> collection) {
+        if (collection == Collection.NODES) {
+            return (ConcurrentSkipListMap<String, T>) nodes;
+        } else if (collection == Collection.CLUSTER_NODES) {
+            return (ConcurrentSkipListMap<String, T>) clusterNodes;
+        } else {
+            throw new IllegalArgumentException(
+                    "Unknown collection: " + collection.toString());
         }
     }
 
     @CheckForNull
-    private Document internalCreateOrUpdate(Collection collection,
-                                                       UpdateOp update,
-                                                       boolean checkConditions) {
-        ConcurrentSkipListMap<String, Document> map = getMap(collection);
-        Document doc;
-        Document oldDoc;
+    private <T extends Document> T internalCreateOrUpdate(Collection<T> collection,
+                                                          UpdateOp update,
+                                                          boolean checkConditions) {
+        ConcurrentSkipListMap<String, T> map = getMap(collection);
+        T doc;
+        T oldDoc;
 
         // get the node if it's there
         oldDoc = doc = map.get(update.key);
@@ -144,7 +145,7 @@ public class MemoryDocumentStore implements DocumentStore {
                 throw new MicroKernelException("Document does not exist: " + update.key);
             }
             // for a new node, add it (without synchronization)
-            doc = Utils.newDocument();
+            doc = collection.newDocument();
             oldDoc = map.putIfAbsent(update.key, doc);
             if (oldDoc != null) {
                 // somebody else added it at the same time
@@ -158,7 +159,7 @@ public class MemoryDocumentStore implements DocumentStore {
             if (oldDoc != null) {
                 // clone the old node
                 // (document level operations are synchronized)
-                Document oldDoc2 = Utils.newDocument();
+                T oldDoc2 = collection.newDocument();
                 Utils.deepCopyMap(oldDoc, oldDoc2);
                 oldDoc = oldDoc2;
             }
@@ -172,13 +173,13 @@ public class MemoryDocumentStore implements DocumentStore {
 
     @Nonnull
     @Override
-    public Document createOrUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         return internalCreateOrUpdate(collection, update, false);
     }
 
     @Override
-    public Document findAndUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         return internalCreateOrUpdate(collection, update, true);
     }
@@ -291,8 +292,8 @@ public class MemoryDocumentStore implements DocumentStore {
     }
 
     @Override
-    public boolean create(Collection collection, List<UpdateOp> updateOps) {
-        ConcurrentSkipListMap<String, Document> map = getMap(collection);
+    public <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {
+        ConcurrentSkipListMap<String, T> map = getMap(collection);
         for (UpdateOp op : updateOps) {
             if (map.containsKey(op.key)) {
                 return false;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java
index 30d14a8bd5..141fe41985 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStore.java
@@ -30,7 +30,6 @@ import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp.Operation;
 import org.apache.jackrabbit.oak.plugins.mongomk.util.Utils;
 import org.apache.jackrabbit.oak.cache.CacheStats;
-import org.apache.jackrabbit.oak.cache.CacheValue;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -62,7 +61,7 @@ public class MongoDocumentStore implements DocumentStore {
      */
     private long timeSum;
     
-    private final Cache<String, CachedDocument> nodesCache;
+    private final Cache<String, NodeDocument> nodesCache;
     private final CacheStats cacheStats;
 
     public MongoDocumentStore(DB db, MongoMK.Builder builder) {
@@ -121,47 +120,47 @@ public class MongoDocumentStore implements DocumentStore {
     }
 
     @Override
-    public Document find(Collection collection, String key) {
+    public <T extends Document> T find(Collection<T> collection, String key) {
         return find(collection, key, Integer.MAX_VALUE);
     }
     
     @Override
-    public Document find(final Collection collection,
-                         final String key,
-                         int maxCacheAge) {
+    public <T extends Document> T find(final Collection<T> collection,
+                                       final String key,
+                                       int maxCacheAge) {
         if (collection != Collection.NODES) {
             return findUncached(collection, key);
         }
         try {
-            CachedDocument doc;
+            NodeDocument doc;
             if (maxCacheAge == 0) {
                 nodesCache.invalidate(key);
             }
             while (true) {
-                doc = nodesCache.get(key, new Callable<CachedDocument>() {
+                doc = nodesCache.get(key, new Callable<NodeDocument>() {
                     @Override
-                    public CachedDocument call() throws Exception {
-                        Document doc = findUncached(collection, key);
-                        return new CachedDocument(doc);
+                    public NodeDocument call() throws Exception {
+                        return (NodeDocument) findUncached(collection, key);
                     }
                 });
                 if (maxCacheAge == 0 || maxCacheAge == Integer.MAX_VALUE) {
                     break;
                 }
-                if (System.currentTimeMillis() - doc.time < maxCacheAge) {
+                if (System.currentTimeMillis() - doc.getCreated() < maxCacheAge) {
                     break;
                 }
                 // too old: invalidate, try again
                 nodesCache.invalidate(key);
             }
-            return doc.value;
+            //noinspection unchecked
+            return (T) doc;
         } catch (ExecutionException e) {
             throw new IllegalStateException("Failed to load document with " + key, e);
         }
     }
     
     @CheckForNull
-    Document findUncached(Collection collection, String key) {
+    <T extends Document> T findUncached(Collection<T> collection, String key) {
         DBCollection dbCollection = getDBCollection(collection);
         long start = start();
         try {
@@ -169,7 +168,7 @@ public class MongoDocumentStore implements DocumentStore {
             if (doc == null) {
                 return null;
             }
-            return convertFromDBObject(doc);
+            return convertFromDBObject(collection, doc);
         } finally {
             end("findUncached", start);
         }
@@ -177,7 +176,7 @@ public class MongoDocumentStore implements DocumentStore {
     
     @Nonnull
     @Override
-    public List<Document> query(Collection collection,
+    public <T extends Document> List<T> query(Collection<T> collection,
                                 String fromKey,
                                 String toKey,
                                 int limit) {
@@ -186,12 +185,12 @@ public class MongoDocumentStore implements DocumentStore {
 
     @Nonnull
     @Override
-    public List<Document> query(Collection collection,
-                                String fromKey,
-                                String toKey,
-                                String indexedProperty,
-                                long startValue,
-                                int limit) {
+    public <T extends Document> List<T> query(Collection<T> collection,
+                                              String fromKey,
+                                              String toKey,
+                                              String indexedProperty,
+                                              long startValue,
+                                              int limit) {
         log("query", fromKey, toKey, limit);
         DBCollection dbCollection = getDBCollection(collection);
         QueryBuilder queryBuilder = QueryBuilder.start(Document.ID);
@@ -205,12 +204,12 @@ public class MongoDocumentStore implements DocumentStore {
         long start = start();
         try {
             DBCursor cursor = dbCollection.find(query);
-            List<Document> list = new ArrayList<Document>();
+            List<T> list = new ArrayList<T>();
             for (int i = 0; i < limit && cursor.hasNext(); i++) {
                 DBObject o = cursor.next();
-                Document doc = convertFromDBObject(o);
+                T doc = convertFromDBObject(collection, o);
                 if (collection == Collection.NODES) {
-                    nodesCache.put(doc.getId(), new CachedDocument(doc));
+                    nodesCache.put(doc.getId(), (NodeDocument) doc);
                 }
                 list.add(doc);
             }
@@ -239,10 +238,10 @@ public class MongoDocumentStore implements DocumentStore {
     }
 
     @CheckForNull
-    private Document findAndModify(Collection collection,
-                                   UpdateOp updateOp,
-                                   boolean upsert,
-                                   boolean checkConditions) {
+    private <T extends Document> T findAndModify(Collection<T> collection,
+                                                 UpdateOp updateOp,
+                                                 boolean upsert,
+                                                 boolean checkConditions) {
         DBCollection dbCollection = getDBCollection(collection);
         QueryBuilder query = getByKeyQuery(updateOp.key);
 
@@ -313,15 +312,15 @@ public class MongoDocumentStore implements DocumentStore {
             if (checkConditions && oldNode == null) {
                 return null;
             }
-            Document doc = convertFromDBObject(oldNode);
+            T doc = convertFromDBObject(collection, oldNode);
             
             // cache the new document
             if (collection == Collection.NODES) {
-                Document newDoc = Utils.newDocument();
+                T newDoc = collection.newDocument();
                 Utils.deepCopyMap(doc, newDoc);
                 String key = updateOp.getKey();
                 MemoryDocumentStore.applyChanges(newDoc, updateOp);
-                nodesCache.put(key, new CachedDocument(newDoc));
+                nodesCache.put(key, (NodeDocument) newDoc);
             }
             
             return doc;
@@ -334,33 +333,33 @@ public class MongoDocumentStore implements DocumentStore {
 
     @Nonnull
     @Override
-    public Document createOrUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         log("createOrUpdate", update);
-        Document doc = findAndModify(collection, update, true, false);
+        T doc = findAndModify(collection, update, true, false);
         log("createOrUpdate returns ", doc);
         return doc;
     }
 
     @Override
-    public Document findAndUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         log("findAndUpdate", update);
-        Document doc = findAndModify(collection, update, false, true);
+        T doc = findAndModify(collection, update, false, true);
         log("findAndUpdate returns ", doc);
         return doc;
     }
 
     @Override
-    public boolean create(Collection collection, List<UpdateOp> updateOps) {
+    public <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {
         log("create", updateOps);       
-        List<Document> docs = new ArrayList<Document>();
+        List<T> docs = new ArrayList<T>();
         DBObject[] inserts = new DBObject[updateOps.size()];
 
         for (int i = 0; i < updateOps.size(); i++) {
             inserts[i] = new BasicDBObject();
             UpdateOp update = updateOps.get(i);
-            Document target = Utils.newDocument();
+            T target = collection.newDocument();
             MemoryDocumentStore.applyChanges(target, update);
             docs.add(target);
             for (Entry<String, Operation> entry : update.changes.entrySet()) {
@@ -398,8 +397,8 @@ public class MongoDocumentStore implements DocumentStore {
                     return false;
                 }
                 if (collection == Collection.NODES) {
-                    for (Document doc : docs) {
-                        nodesCache.put(doc.getId(), new CachedDocument(doc));
+                    for (T doc : docs) {
+                        nodesCache.put(doc.getId(), (NodeDocument) doc);
                     }
                 }
                 return true;
@@ -411,8 +410,9 @@ public class MongoDocumentStore implements DocumentStore {
         }        
     }
 
-    private static Document convertFromDBObject(DBObject n) {
-        Document copy = Utils.newDocument();
+    private static <T extends Document> T convertFromDBObject(Collection<T> collection,
+                                                              DBObject n) {
+        T copy = collection.newDocument();
         if (n != null) {
             for (String key : n.keySet()) {
                 Object o = n.get(key);
@@ -429,13 +429,13 @@ public class MongoDocumentStore implements DocumentStore {
     }
 
     private DBCollection getDBCollection(Collection collection) {
-        switch (collection) {
-            case NODES:
-                return nodes;
-            case CLUSTER_NODES:
-                return clusterNodes;
-            default:
-                throw new IllegalArgumentException(collection.name());
+        if (collection == Collection.NODES) {
+            return nodes;
+        } else if (collection == Collection.CLUSTER_NODES) {
+            return clusterNodes;
+        } else {
+            throw new IllegalArgumentException(
+                    "Unknown collection: " + collection.toString());
         }
     }
 
@@ -465,25 +465,6 @@ public class MongoDocumentStore implements DocumentStore {
         }
     }
     
-    /**
-     * A cache entry.
-     */
-    static class CachedDocument implements CacheValue {
-        
-        final long time = System.currentTimeMillis();
-        final Document value;
-        
-        CachedDocument(Document value) {
-            this.value = value;
-        }
-        
-        @Override
-        public int getMemory() {
-            return Utils.estimateMemoryUsage(value);
-        }
-        
-    }
-
     @Override
     public boolean isCached(Collection collection, String key) {
         if (collection != Collection.NODES) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
index 25c3c965ec..3037d1071b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoMK.java
@@ -53,7 +53,6 @@ import org.apache.jackrabbit.oak.cache.CacheStats;
 import org.apache.jackrabbit.oak.cache.CacheValue;
 import org.apache.jackrabbit.oak.cache.EmpiricalWeigher;
 import org.apache.jackrabbit.oak.commons.PathUtils;
-import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore.Collection;
 import org.apache.jackrabbit.oak.plugins.mongomk.Node.Children;
 import org.apache.jackrabbit.oak.plugins.mongomk.Revision.RevisionComparator;
 import org.apache.jackrabbit.oak.plugins.mongomk.blob.MongoBlobStore;
@@ -338,7 +337,7 @@ public class MongoMK implements MicroKernel {
     
     void backgroundRead() {
         String id = Utils.getIdFromPath("/");
-        Map<String, Object> map = store.find(DocumentStore.Collection.NODES, id, asyncDelay);
+        Map<String, Object> map = store.find(Collection.NODES, id, asyncDelay);
         @SuppressWarnings("unchecked")
         Map<String, String> lastRevMap = (Map<String, String>) map.get(UpdateOp.LAST_REV);
         
@@ -409,7 +408,7 @@ public class MongoMK implements MicroKernel {
             }
             Commit commit = new Commit(this, null, r);
             commit.touchNode(p);
-            store.createOrUpdate(DocumentStore.Collection.NODES, commit.getUpdateOperationForNode(p));
+            store.createOrUpdate(Collection.NODES, commit.getUpdateOperationForNode(p));
             unsavedLastRevisions.remove(p);
         }
     }
@@ -559,7 +558,7 @@ public class MongoMK implements MicroKernel {
             return false;
         }
         // get root of commit
-        doc = store.find(DocumentStore.Collection.NODES,
+        doc = store.find(Collection.NODES,
                 Utils.getIdFromPath(commitRootPath));
         if (doc == null) {
             return false;
@@ -660,14 +659,14 @@ public class MongoMK implements MicroKernel {
         // as the starting point
         String from = Utils.getKeyLowerLimit(path);
         String to = Utils.getKeyUpperLimit(path);
-        List<Document> list = store.query(DocumentStore.Collection.NODES,
+        List<NodeDocument> list = store.query(Collection.NODES,
                 from, to, limit);
         Children c = new Children();
         Set<Revision> validRevisions = new HashSet<Revision>();
         if (list.size() >= limit) {
             c.hasMore = true;
         }
-        for (Document doc : list) {
+        for (NodeDocument doc : list) {
             // filter out deleted children
             if (getLiveRevision(doc, rev, validRevisions) == null) {
                 continue;
@@ -681,7 +680,7 @@ public class MongoMK implements MicroKernel {
 
     private Node readNode(String path, Revision readRevision) {
         String id = Utils.getIdFromPath(path);
-        Document doc = store.find(DocumentStore.Collection.NODES, id);
+        Document doc = store.find(Collection.NODES, id);
         if (doc == null) {
             return null;
         }
@@ -916,9 +915,9 @@ public class MongoMK implements MicroKernel {
         long minValue = Commit.getModified(minTimestamp);
         String fromKey = Utils.getKeyLowerLimit(path);
         String toKey = Utils.getKeyUpperLimit(path);
-        List<Document> list = store.query(DocumentStore.Collection.NODES, fromKey, toKey,
+        List<NodeDocument> list = store.query(Collection.NODES, fromKey, toKey,
                 UpdateOp.MODIFIED, minValue, Integer.MAX_VALUE);
-        for (Document doc : list) {
+        for (NodeDocument doc : list) {
             String id = doc.getId();
             String p = Utils.getPathFromId(id);
             Node fromNode = getNode(p, fromRev);
@@ -1454,7 +1453,7 @@ public class MongoMK implements MicroKernel {
                 op.setMapEntry(UpdateOp.REVISIONS, rev.toString(), "c-" + mergeCommit.toString());
                 op.containsMapEntry(UpdateOp.COLLISIONS, rev.toString(), false);
             }
-            if (store.findAndUpdate(DocumentStore.Collection.NODES, op) != null) {
+            if (store.findAndUpdate(Collection.NODES, op) != null) {
                 // remove from branchCommits map after successful update
                 b.applyTo(unsavedLastRevisions, mergeCommit);
                 branches.remove(b);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java
new file mode 100644
index 0000000000..b89771fd94
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/NodeDocument.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.mongomk;
+
+import org.apache.jackrabbit.oak.cache.CacheValue;
+import org.apache.jackrabbit.oak.plugins.mongomk.util.Utils;
+
+/**
+ * A document storing data about a node.
+ */
+public class NodeDocument extends Document implements CacheValue {
+
+    private static final long serialVersionUID = 6713219541688419314L;
+
+    private final long time = System.currentTimeMillis();
+
+    public final long getCreated() {
+        return time;
+    }
+
+    @Override
+    public int getMemory() {
+        return Utils.estimateMemoryUsage(this);
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java
index 57d482b513..6d917a2b30 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/UnmergedBranches.java
@@ -68,10 +68,9 @@ class UnmergedBranches {
         if (!initialized.compareAndSet(false, true)) {
             throw new IllegalStateException("already initialized");
         }
-        Map<String, Object> nodeMap = store.find(
-                DocumentStore.Collection.NODES, Utils.getIdFromPath("/"));
+        NodeDocument doc = store.find(Collection.NODES, Utils.getIdFromPath("/"));
         @SuppressWarnings("unchecked")
-        Map<String, String> valueMap = (Map<String, String>) nodeMap.get(UpdateOp.REVISIONS);
+        Map<String, String> valueMap = (Map<String, String>) doc.get(UpdateOp.REVISIONS);
         if (valueMap != null) {
             SortedMap<Revision, Revision> tmp =
                     new TreeMap<Revision, Revision>(comparator);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java
index ec1dfaec6b..e215ddba63 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/LoggingDocumentStoreWrapper.java
@@ -22,6 +22,7 @@ import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.mk.json.JsopBuilder;
+import org.apache.jackrabbit.oak.plugins.mongomk.Collection;
 import org.apache.jackrabbit.oak.plugins.mongomk.Document;
 import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore;
 import org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp;
@@ -44,7 +45,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public Document find(Collection collection, String key) {
+    public <T extends Document> T find(Collection<T> collection, String key) {
         try {
             logMethod("find", collection, key);
             return logResult(store.find(collection, key));
@@ -55,7 +56,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public Document find(Collection collection, String key, int maxCacheAge) {
+    public <T extends Document> T find(Collection<T> collection, String key, int maxCacheAge) {
         try {
             logMethod("find", collection, key, maxCacheAge);
             return logResult(store.find(collection, key, maxCacheAge));
@@ -67,7 +68,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
 
     @Nonnull
     @Override
-    public List<Document> query(Collection collection,
+    public <T extends Document> List<T> query(Collection<T> collection,
                                 String fromKey,
                                 String toKey,
                                 int limit) {
@@ -82,7 +83,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     
     @Override
     @Nonnull
-    public List<Document> query(Collection collection,
+    public <T extends Document> List<T> query(Collection<T> collection,
                                 String fromKey,
                                 String toKey,
                                 String indexedProperty,
@@ -109,7 +110,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public boolean create(Collection collection, List<UpdateOp> updateOps) {
+    public <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {
         try {
             logMethod("create", collection, updateOps);
             return logResult(store.create(collection, updateOps));
@@ -121,7 +122,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
 
     @Nonnull
     @Override
-    public Document createOrUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         try {
             logMethod("createOrUpdate", collection, update);
@@ -133,7 +134,7 @@ public class LoggingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public Document findAndUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         try {
             logMethod("findAndUpdate", collection, update);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java
index 5e76824337..088356e933 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/TimingDocumentStoreWrapper.java
@@ -26,6 +26,7 @@ import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
+import org.apache.jackrabbit.oak.plugins.mongomk.Collection;
 import org.apache.jackrabbit.oak.plugins.mongomk.Document;
 import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore;
 import org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp;
@@ -75,10 +76,10 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
     
     @Override
     @CheckForNull
-    public Document find(Collection collection, String key) {
+    public <T extends Document> T find(Collection<T> collection, String key) {
         try {
             long start = now();
-            Document result = base.find(collection, key);
+            T result = base.find(collection, key);
             updateAndLogTimes("find", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -88,10 +89,10 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @CheckForNull
-    public Document find(Collection collection, String key, int maxCacheAge) {
+    public <T extends Document> T find(Collection<T> collection, String key, int maxCacheAge) {
         try {
             long start = now();
-            Document result = base.find(collection, key, maxCacheAge);
+            T result = base.find(collection, key, maxCacheAge);
             updateAndLogTimes("find2", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -101,13 +102,13 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @Nonnull
-    public List<Document> query(Collection collection,
-                                String fromKey,
-                                String toKey,
-                                int limit) {
+    public <T extends Document> List<T> query(Collection<T> collection,
+                                                String fromKey,
+                                                String toKey,
+                                                int limit) {
         try {
             long start = now();
-            List<Document> result = base.query(collection, fromKey, toKey, limit);
+            List<T> result = base.query(collection, fromKey, toKey, limit);
             updateAndLogTimes("query", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -117,15 +118,15 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @Nonnull
-    public List<Document> query(Collection collection,
-                                String fromKey,
-                                String toKey,
-                                String indexedProperty,
-                                long startValue,
-                                int limit) {
+    public <T extends Document> List<T> query(Collection<T> collection,
+                                              String fromKey,
+                                              String toKey,
+                                              String indexedProperty,
+                                              long startValue,
+                                              int limit) {
         try {
             long start = now();
-            List<Document> result = base.query(collection, fromKey, toKey, indexedProperty, startValue, limit);
+            List<T> result = base.query(collection, fromKey, toKey, indexedProperty, startValue, limit);
             updateAndLogTimes("query2", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -145,7 +146,7 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
     }
 
     @Override
-    public boolean create(Collection collection, List<UpdateOp> updateOps) {
+    public <T extends Document> boolean create(Collection<T> collection, List<UpdateOp> updateOps) {
         try {
             long start = now();
             boolean result = base.create(collection, updateOps);
@@ -158,11 +159,11 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @Nonnull
-    public Document createOrUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T createOrUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         try {
             long start = now();
-            Document result = base.createOrUpdate(collection, update);
+            T result = base.createOrUpdate(collection, update);
             updateAndLogTimes("createOrUpdate", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -172,11 +173,11 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
 
     @Override
     @CheckForNull
-    public Document findAndUpdate(Collection collection, UpdateOp update)
+    public <T extends Document> T findAndUpdate(Collection<T> collection, UpdateOp update)
             throws MicroKernelException {
         try {
             long start = now();
-            Document result = base.findAndUpdate(collection, update);
+            T result = base.findAndUpdate(collection, update);
             updateAndLogTimes("findAndUpdate", start, 0, size(result));
             return result;
         } catch (Exception e) {
@@ -242,13 +243,13 @@ public class TimingDocumentStoreWrapper implements DocumentStore {
         }
     }
     
-    private static int size(Document doc) {
+    private static <T extends Document> int size(T doc) {
         return Utils.estimateMemoryUsage(doc);
     }
 
-    private static int size(List<Document> list) {
+    private static <T extends Document> int size(List<T> list) {
         int result = 0;
-        for (Document doc : list) {
+        for (T doc : list) {
             result += size(doc);
         }
         return result;
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java
index 26bfebd3ab..319e35fbf8 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/mongomk/util/Utils.java
@@ -28,7 +28,6 @@ import javax.annotation.Nullable;
 import com.mongodb.BasicDBObject;
 
 import org.apache.jackrabbit.oak.commons.PathUtils;
-import org.apache.jackrabbit.oak.plugins.mongomk.Document;
 import org.apache.jackrabbit.oak.plugins.mongomk.Revision;
 import org.bson.types.ObjectId;
 
@@ -60,10 +59,6 @@ public class Utils {
         return new HashSet<E>();
     }
 
-    public static Document newDocument() {
-        return new Document();
-    }
-
     @SuppressWarnings("unchecked")
     public static int estimateMemoryUsage(Map<String, Object> map) {
         if (map == null) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDbTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDbTest.java
index 982827b9e9..4779dc60c3 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDbTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDbTest.java
@@ -16,7 +16,6 @@
  */
 package org.apache.jackrabbit.oak.plugins.mongomk;
 
-import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore.Collection;
 import org.junit.Ignore;
 import org.junit.Test;
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java
index db0bb56705..8b08f6f9b7 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/MongoDocumentStoreTest.java
@@ -16,7 +16,6 @@
  */
 package org.apache.jackrabbit.oak.plugins.mongomk;
 
-import static org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore.Collection;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -188,7 +187,7 @@ public class MongoDocumentStoreTest {
             inserts.add(n.asOperation(true));
         }
         docStore.create(Collection.NODES, inserts);
-        List<Document> docs = docStore.query(Collection.NODES,
+        List<NodeDocument> docs = docStore.query(Collection.NODES,
                 Utils.getKeyLowerLimit("/"),  Utils.getKeyUpperLimit("/"),
                 MongoMK.MANY_CHILDREN_THRESHOLD);
         assertEquals(MongoMK.MANY_CHILDREN_THRESHOLD, docs.size());
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/SimpleTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/SimpleTest.java
index d700955ecb..05ae37a95d 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/SimpleTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/mongomk/SimpleTest.java
@@ -27,7 +27,6 @@ import java.util.Random;
 
 import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.mk.json.JsopBuilder;
-import org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore.Collection;
 import org.apache.jackrabbit.oak.plugins.mongomk.Node.Children;
 import org.apache.jackrabbit.oak.plugins.mongomk.util.Utils;
 import org.junit.Test;
