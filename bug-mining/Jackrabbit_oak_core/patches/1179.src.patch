diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/stats/ClockTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/stats/ClockTest.java
index 3baa965555..f3acf6c454 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/stats/ClockTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/stats/ClockTest.java
@@ -17,8 +17,6 @@
 package org.apache.jackrabbit.oak.stats;
 
 import static junit.framework.Assert.assertTrue;
-import static org.apache.jackrabbit.oak.commons.CIHelper.buildBotWin7Trunk;
-import static org.junit.Assume.assumeTrue;
 
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
@@ -46,51 +44,49 @@ public class ClockTest {
     }
 
     @Test
-    public void testClockDrift() throws InterruptedException {
-        // FIXME OAK-1904 temporary hack to disable this test on Apache buildbot
-        assumeTrue(!buildBotWin7Trunk());
-        ScheduledExecutorService executor =
-                Executors.newSingleThreadScheduledExecutor();
-
-        try {
-            Clock[] clocks = new Clock[] {
-                    Clock.SIMPLE,
-                    Clock.ACCURATE,
-                    new Clock.Fast(executor)
-            };
-
-            for (Clock clock : clocks) {
-                long drift = clock.getTime() - System.currentTimeMillis();
-
-                // Set the drift limit to twice as high as granularity,
-                // plus 3ms for Thread.sleep() inaccuracy in the fast clock
-                final long granularity = getGranularity(clock);
-                final long limit = (2 * granularity) / 1000 + 3;
-                assertTrue(
-                        clock + " unexpected drift: " + drift + "ms (estimated limit was " +
-                                limit + "ms, measured granularity was " + (granularity / 1000f) + "ms)",
-                        Math.abs(drift) <= limit);
-            }
-
-            Thread.sleep(100);
+    public void testClockDriftSimple() throws InterruptedException {
+        testClockDrift(Clock.SIMPLE);
+    }
 
-            for (Clock clock : clocks) {
-                long drift = clock.getTime() - System.currentTimeMillis();
+    @Test
+    public void testClockDriftAccurate() throws InterruptedException {
+        testClockDrift(Clock.SIMPLE);
+    }
 
-                // Set the drift limit to twice as high as granularity,
-                // plus 3ms for Thread.sleep() inaccuracy in the fast clock
-                final long granularity = getGranularity(clock);
-                final long limit = (2 * granularity) / 1000 + 3;
-                assertTrue(
-                        clock + " unexpected drift ater 100ms: " + drift + "ms (estimated limit was " +
-                                limit + "ms, measured granularity was " + (granularity / 1000f) + "ms)",
-                        Math.abs(drift) <= limit);
-            }
+    @Test
+    public void testClockDriftFast() throws InterruptedException {
+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
+        try {
+            testClockDrift(new Clock.Fast(executor));
         } finally {
             executor.shutdown();
         }
     }
 
+    private void testClockDrift(Clock clock) throws InterruptedException {
+
+        long drift = clock.getTime() - System.currentTimeMillis();
+
+        // Set the drift limit to twice as high as granularity,
+        // plus 3ms for Thread.sleep() inaccuracy in the fast clock
+        long granularity = getGranularity(clock);
+        long limit = (2 * granularity) / 1000 + 3;
+        assertTrue(clock + " unexpected drift: " + drift + "ms (estimated limit was " + limit + "ms, measured granularity was "
+                + (granularity / 1000f) + "ms)", Math.abs(drift) <= limit);
+
+        long waittime = 100;
+        Thread.sleep(waittime);
+
+        drift = clock.getTime() - System.currentTimeMillis();
+
+        // Set the drift limit to twice as high as granularity,
+        // plus 3ms for Thread.sleep() inaccuracy in the fast clock
+        granularity = getGranularity(clock);
+        limit = (2 * granularity) / 1000 + 3;
+        assertTrue(clock + " unexpected drift after " + waittime + "ms: " + drift + "ms (estimated limit was " + limit
+                + "ms, measured granularity was " + (granularity / 1000f) + "ms)", Math.abs(drift) <= limit);
+    }
+
     private static long getGranularity(Clock clock) {
         return clock instanceof Fast
             ? FAST_CLOCK_GRANULARITY
@@ -98,29 +94,34 @@ public class ClockTest {
     }
 
     @Test
-    public void testClockIncreasing() throws InterruptedException {
-        ScheduledExecutorService executor =
-                Executors.newSingleThreadScheduledExecutor();
+    public void testClockIncreasingSimple() throws InterruptedException {
+        testClockIncreasing(Clock.SIMPLE);
+    }
+
+    @Test
+    public void testClockIncreasingAccurate() throws InterruptedException {
+        testClockIncreasing(Clock.SIMPLE);
+    }
+
+    @Test
+    public void testClockIncreasingFast() throws InterruptedException {
+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
         try {
-            Clock[] clocks = new Clock[] {
-                    Clock.SIMPLE,
-                    Clock.ACCURATE,
-                    new Clock.Fast(executor)
-            };
-
-            long[] time = new long[clocks.length];
-            for (int i = 0; i < 10; i++) {
-                for (int j = 0; j < clocks.length; j++) {
-                    long now = clocks[j].getTimeIncreasing();
-                    assertTrue(time[j] < now);
-                    time[j] = now;
-                }
-            }
+            testClockIncreasing(new Clock.Fast(executor));
         } finally {
             executor.shutdown();
         }
     }
 
+    private void testClockIncreasing(Clock clock) throws InterruptedException {
+        long time = 0;
+        for (int i = 0; i < 10; i++) {
+            long now = clock.getTimeIncreasing();
+            assertTrue(time < now);
+            time = now;
+        }
+    }
+
     /**
      * On some systems (for instance Windows), the granularity of {@code System.currentTimeMillis} depends
      * on system-wide settings that can change depending on what applications are running
