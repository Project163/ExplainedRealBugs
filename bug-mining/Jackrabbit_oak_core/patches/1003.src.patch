diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
index ebd0250642..b770c82b6d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
@@ -81,6 +81,7 @@ import com.mongodb.QueryBuilder;
 import com.mongodb.WriteConcern;
 import com.mongodb.WriteResult;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
@@ -303,7 +304,8 @@ public class MongoDocumentStore implements CachingDocumentStore {
                                        boolean preferCached,
                                        final int maxCacheAge) {
         if (collection != Collection.NODES) {
-            return findUncached(collection, key, DocumentReadPreference.PRIMARY);
+            return findUncachedWithRetry(collection, key,
+                    DocumentReadPreference.PRIMARY, 2);
         }
         CacheValue cacheKey = new StringValue(key);
         NodeDocument doc;
@@ -331,7 +333,9 @@ public class MongoDocumentStore implements CachingDocumentStore {
                     doc = nodesCache.get(cacheKey, new Callable<NodeDocument>() {
                         @Override
                         public NodeDocument call() throws Exception {
-                            NodeDocument doc = (NodeDocument) findUncached(collection, key, getReadPreference(maxCacheAge));
+                            NodeDocument doc = (NodeDocument) findUncachedWithRetry(
+                                    collection, key,
+                                    getReadPreference(maxCacheAge), 2);
                             if (doc == null) {
                                 doc = NodeDocument.NULL;
                             }
@@ -363,8 +367,45 @@ public class MongoDocumentStore implements CachingDocumentStore {
         throw new DocumentStoreException("Failed to load document with " + key, t);
     }
 
+    /**
+     * Finds a document and performs a number of retries if the read fails with
+     * an exception.
+     *
+     * @param collection the collection to read from.
+     * @param key the key of the document to find.
+     * @param docReadPref the read preference.
+     * @param retries the number of retries. Must not be negative.
+     * @param <T> the document type of the given collection.
+     * @return the document or {@code null} if the document doesn't exist.
+     */
+    @CheckForNull
+    private <T extends Document> T findUncachedWithRetry(
+            Collection<T> collection, String key,
+            DocumentReadPreference docReadPref,
+            int retries) {
+        checkArgument(retries >= 0, "retries must not be negative");
+        int numAttempts = retries + 1;
+        MongoException ex = null;
+        for (int i = 0; i < numAttempts; i++) {
+            if (i > 0) {
+                LOG.warn("Retrying read of " + key);
+            }
+            try {
+                return findUncached(collection, key, docReadPref);
+            } catch (MongoException e) {
+                ex = e;
+            }
+        }
+        if (ex != null) {
+            throw ex;
+        } else {
+            // impossible to get here
+            throw new IllegalStateException();
+        }
+    }
+
     @CheckForNull
-    private <T extends Document> T findUncached(Collection<T> collection, String key, DocumentReadPreference docReadPref) {
+    protected <T extends Document> T findUncached(Collection<T> collection, String key, DocumentReadPreference docReadPref) {
         DBCollection dbCollection = getDBCollection(collection);
         long start = start();
         try {
@@ -763,13 +804,16 @@ public class MongoDocumentStore implements CachingDocumentStore {
                     return ReadPreference.primary();
                 }
 
-                //Default to primary preferred such that in case primary is being elected
-                //we can still read from secondary
-                //TODO REVIEW Would that be safe
-                ReadPreference readPreference = ReadPreference.primaryPreferred();
+                // read from primary unless parent has not been modified
+                // within replication lag period
+                ReadPreference readPreference = ReadPreference.primary();
                 if (parentId != null) {
                     long replicationSafeLimit = getTime() - maxReplicationLagMillis;
                     NodeDocument cachedDoc = (NodeDocument) getIfCached(collection, parentId);
+                    // FIXME: this is not quite accurate, because ancestors
+                    // are updated in a background thread (_lastRev). We
+                    // will need to revise this for low maxReplicationLagMillis
+                    // values
                     if (cachedDoc != null && !cachedDoc.hasBeenModifiedSince(replicationSafeLimit)) {
 
                         //If parent has been modified loooong time back then there children
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/ReadPreferenceIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/ReadPreferenceIT.java
index 9b938c3172..ef2bfd6518 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/ReadPreferenceIT.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/ReadPreferenceIT.java
@@ -115,8 +115,8 @@ public class ReadPreferenceIT {
         assertEquals(ReadPreference.secondary(),
                 mongoDS.getMongoReadPreference(NODES,"foo", DocumentReadPreference.PREFER_SECONDARY));
 
-        //for case where parent age cannot be determined the preference should be primaryPreferred
-        assertEquals(ReadPreference.primaryPreferred(),
+        //for case where parent age cannot be determined the preference should be primary
+        assertEquals(ReadPreference.primary(),
                 mongoDS.getMongoReadPreference(NODES,"foo", DocumentReadPreference.PREFER_SECONDARY_IF_OLD_ENOUGH));
 
         //For collection other than NODES always primary
@@ -139,8 +139,8 @@ public class ReadPreferenceIT {
         String parentId = Utils.getParentId(id);
         mongoDS.invalidateCache(NODES,id);
 
-        //For modifiedTime < replicationLag primary should be preferred
-        assertEquals(ReadPreference.primaryPreferred(),
+        //For modifiedTime < replicationLag primary must be used
+        assertEquals(ReadPreference.primary(),
                 mongoDS.getMongoReadPreference(NODES,parentId, DocumentReadPreference.PREFER_SECONDARY_IF_OLD_ENOUGH));
 
         //Going into future to make parent /x old enough
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/RetryReadIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/RetryReadIT.java
new file mode 100644
index 0000000000..27434555d5
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/RetryReadIT.java
@@ -0,0 +1,92 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document.mongo;
+
+import org.apache.jackrabbit.oak.plugins.document.AbstractMongoConnectionTest;
+import org.apache.jackrabbit.oak.plugins.document.Collection;
+import org.apache.jackrabbit.oak.plugins.document.Document;
+import org.apache.jackrabbit.oak.plugins.document.DocumentMK;
+import org.apache.jackrabbit.oak.plugins.document.DocumentStoreException;
+import org.apache.jackrabbit.oak.plugins.document.MongoUtils;
+import org.apache.jackrabbit.oak.plugins.document.NodeDocument;
+import org.apache.jackrabbit.oak.plugins.document.util.Utils;
+import org.junit.Test;
+
+import com.mongodb.DB;
+import com.mongodb.MongoException;
+
+import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests retry logic in MongoDocumentStore (OAK-1641).
+ */
+public class RetryReadIT extends AbstractMongoConnectionTest {
+
+    private TestStore store;
+
+    @Override
+    public void setUpConnection() throws Exception {
+        mongoConnection = MongoUtils.getConnection();
+        MongoUtils.dropCollections(mongoConnection.getDB());
+        DocumentMK.Builder builder = new DocumentMK.Builder();
+        builder.clock(getTestClock());
+        store = new TestStore(mongoConnection.getDB(), builder);
+        mk = builder.setDocumentStore(store).open();
+    }
+
+    @Test
+    public void retry() {
+        // must survive two consecutive failures. -> 2 retries
+        store.failRead = 2;
+        NodeDocument doc = store.find(NODES, Utils.getIdFromPath("/foo"));
+        assertNull(doc);
+        // previous result is cached and will not fail
+        store.failRead = 3;
+        doc = store.find(NODES, Utils.getIdFromPath("/foo"));
+        assertNull(doc);
+        // must fail with three consecutive failures on unknown path
+        try {
+            store.find(NODES, Utils.getIdFromPath("/bar"));
+            fail("must fail with DocumentStoreException");
+        } catch (DocumentStoreException e) {
+            // expected
+        }
+    }
+
+    private static class TestStore extends MongoDocumentStore {
+
+        private int failRead = 0;
+
+        public TestStore(DB db, DocumentMK.Builder builder) {
+            super(db, builder);
+        }
+
+        @Override
+        protected <T extends Document> T findUncached(Collection<T> collection,
+                                                      String key,
+                                                      DocumentReadPreference docReadPref) {
+            if (failRead > 0) {
+                failRead--;
+                throw new MongoException("read failed");
+            }
+            return super.findUncached(collection, key, docReadPref);
+        }
+    }
+
+}
