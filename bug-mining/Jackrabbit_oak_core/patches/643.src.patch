diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java
index 33561315b1..431d1f3b02 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/cache/CacheLIRS.java
@@ -154,11 +154,6 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
         }
     }
 
-    private Entry<K, V> find(Object key) {
-        int hash = getHash(key);
-        return getSegment(hash).find(key, hash);
-    }
-
     /**
      * Check whether there is a resident entry for the given key. This
      * method does not adjust the internal state of the cache.
@@ -179,7 +174,8 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
      * @return the value, or null if there is no resident entry
      */
     public V peek(K key) {
-        Entry<K, V> e = find(key);
+        int hash = getHash(key);
+        Entry<K, V> e = getSegment(hash).find(key, hash);
         return e == null ? null : e.value;
     }
 
@@ -459,7 +455,10 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
     public synchronized Set<Map.Entry<K, V>> entrySet() {
         HashMap<K, V> map = new HashMap<K, V>();
         for (K k : keySet()) {
-            map.put(k,  find(k).value);
+            V v = peek(k);
+            if (v != null) {
+                map.put(k,  v);
+            }
         }
         return map.entrySet();
     }
@@ -467,7 +466,7 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
     protected Collection<V> values() {
         ArrayList<V> list = new ArrayList<V>();
         for (K k : keySet()) {
-            V v = find(k).value;
+            V v = peek(k);
             if (v != null) {
                 list.add(v);
             }
@@ -478,7 +477,7 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
     boolean containsValue(Object value) {
         for (Segment<K, V> s : segments) {
             for (K k : s.keySet()) {
-                V v = find(k).value;
+                V v = peek(k);
                 if (v != null && v.equals(value)) {
                     return true;
                 }
@@ -860,6 +859,9 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
         synchronized V get(K key, int hash, CacheLoader<K, V> loader) throws ExecutionException {
             V value = get(key, hash);
             if (value == null) {
+                if (loader == null) {
+                    return null;
+                }
                 long start = System.nanoTime();
                 try {
                     value = loader.load(key);
@@ -1394,7 +1396,7 @@ public class CacheLIRS<K, V> implements LoadingCache<K, V> {
             @SuppressWarnings("unchecked")
             @Override
             public V get(Object key) {
-                return CacheLIRS.this.getUnchecked((K) key);
+                return CacheLIRS.this.peek((K) key);
             }
 
             @Override
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/cache/ConcurrentTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/cache/ConcurrentTest.java
new file mode 100644
index 0000000000..b6ac4f5369
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/cache/ConcurrentTest.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.jackrabbit.oak.cache;
+
+import java.util.Random;
+import java.util.concurrent.ConcurrentMap;
+
+import org.junit.Test;
+
+/**
+ * Tests the LIRS cache by concurrently reading and writing.
+ */
+public class ConcurrentTest {
+
+    @Test
+    public void testRandomOperations() throws Exception {
+        Random r = new Random(1);
+        final CacheLIRS<Integer, Integer> cache = new CacheLIRS.Builder().
+                maximumWeight(100).build();
+        final Exception[] ex = new Exception[1];
+        int size = 3;
+        Thread[] threads = new Thread[size];
+        for (int i = 0; i < size; i++) {
+            Thread t = new Thread() {
+                @Override
+                public void run() {
+                    try {
+                        cache.cleanUp();
+                        cache.containsKey(1);
+                        cache.containsValue(1);
+                        cache.entrySet();
+                        cache.getMaxMemory();
+                        cache.getIfPresent(1);
+                        cache.getAverageMemory();
+                        cache.getMemory(1);
+                        cache.getUsedMemory();
+                        cache.invalidate(1);
+                        cache.invalidateAll();
+                        cache.isEmpty();
+                        cache.keySet();
+                        cache.peek(1);
+                        cache.put(1, 10);
+                        cache.refresh(1);
+                        cache.remove(1);
+                        cache.setAverageMemory(10);
+                        cache.setMaxMemory(10);
+                        cache.size();
+                        cache.stats();
+                        ConcurrentMap<Integer, Integer> map = cache.asMap();
+                        map.size();
+                        map.isEmpty();
+                        map.containsKey(1);
+                        map.containsValue(1);
+                        map.get(1);
+                        map.put(1, 10);
+                        map.remove(1);
+                        map.clear();
+                        map.keySet();
+                        map.values();
+                        map.entrySet();
+                        map.putIfAbsent(1, 10);
+                        map.remove(1);
+                        map.remove(1, 10);
+                        map.replace(1, 10, 100);
+                        map.replace(1, 10);
+                        cache.get(1);
+                        cache.getUnchecked(1);
+                    } catch (Exception e) {
+                        ex[0] = e;
+                    }
+                }
+            };
+            t.start();
+            threads[i] = t;
+        }
+        try {
+            long start = System.currentTimeMillis();
+            while (System.currentTimeMillis() < start + 100) {
+                for (int i = 0; i < 100000 && ex[0] == null; i++) {
+                    cache.put(r.nextInt(1000), r.nextInt(10000));
+                }
+            }
+        } finally {
+            for (Thread t : threads) {
+                t.join();
+            }
+        }
+        if (ex[0] != null) {
+            throw ex[0];
+        }
+    }
+    
+}
