diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java
index 33c31c9e2e..a65df495e6 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/ModifiedNodeState.java
@@ -44,7 +44,6 @@ import org.apache.jackrabbit.oak.spi.state.NodeStateDiff;
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
 
 /**
@@ -108,15 +107,40 @@ public class ModifiedNodeState extends AbstractNodeState {
         }
     }
 
-    static NodeState withNodes(
+    static long getChildNodeCount(
             NodeState base, Map<String, ? extends NodeState> nodes) {
-        if (nodes.isEmpty()) {
-            return base;
-        } else {
-            return new ModifiedNodeState(base, ImmutableMap.<String, PropertyState>of(), nodes);
+        long count = 0;
+        if (base.exists()) {
+            count = base.getChildNodeCount();
+            for (Map.Entry<String, ? extends NodeState> entry
+                    : nodes.entrySet()) {
+                if (base.getChildNode(entry.getKey()).exists()) {
+                    count--;
+                }
+                if (entry.getValue() != null && entry.getValue().exists()) {
+                    count++;
+                }
+            }
         }
+        return count;
     }
 
+    static Iterable<String> getChildNodeNames(
+            NodeState base, Map<String, ? extends NodeState> nodes,
+            boolean copy) {
+        if (!base.exists()) {
+            return emptyList();
+        } else if (nodes.isEmpty()) {
+            return base.getChildNodeNames(); // shortcut
+        } else {
+            if (copy) {
+                nodes = newHashMap(nodes);
+            }
+            return concat(
+                    filter(base.getChildNodeNames(), not(in(nodes.keySet()))),
+                    filterValues(nodes, notNull()).keySet());
+        }
+    }
     static NodeState with(
             NodeState base,
             Map<String, PropertyState> properties,
@@ -225,21 +249,7 @@ public class ModifiedNodeState extends AbstractNodeState {
 
     @Override
     public long getChildNodeCount() {
-        if (!exists()) {
-            return 0;
-        }
-        long count = base.getChildNodeCount();
-
-        for (Map.Entry<String, ? extends NodeState> entry : nodes.entrySet()) {
-            if (base.getChildNode(entry.getKey()).exists()) {
-                count--;
-            }
-            if (entry.getValue() != null && entry.getValue().exists()) {
-                count++;
-            }
-        }
-
-        return count;
+        return getChildNodeCount(base, nodes);
     }
 
     @Override
@@ -257,11 +267,7 @@ public class ModifiedNodeState extends AbstractNodeState {
 
     @Override
     public Iterable<String> getChildNodeNames() {
-        if (!exists()) {
-            return emptyList();
-        } else {
-            return super.getChildNodeNames();
-        }
+        return getChildNodeNames(base, nodes, false);
     }
 
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java
index 81d5d33166..48f60e7ab9 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/memory/MutableNodeState.java
@@ -24,7 +24,6 @@ import static com.google.common.collect.Maps.newHashMap;
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;
 import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE;
 import static org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.with;
-import static org.apache.jackrabbit.oak.plugins.memory.ModifiedNodeState.withNodes;
 
 import java.util.Iterator;
 import java.util.Map;
@@ -396,7 +395,7 @@ class MutableNodeState extends AbstractNodeState {
     @Override
     public long getChildNodeCount() {
         assert base != null;
-        return withNodes(base, nodes).getChildNodeCount();
+        return ModifiedNodeState.getChildNodeCount(base, nodes);
     }
 
     @Override
@@ -404,7 +403,14 @@ class MutableNodeState extends AbstractNodeState {
         assert base != null;
         checkNotNull(name);
         // checkArgument(!name.isEmpty()); TODO: should be caught earlier
-        return withNodes(base, nodes).hasChildNode(name);
+        NodeState child = nodes.get(name);
+        if (child != null) {
+            return child.exists();
+        } else if (nodes.containsKey(name)) {
+            return false;
+        } else {
+            return base.hasChildNode(name);
+        }
     }
 
     @Override
@@ -415,8 +421,7 @@ class MutableNodeState extends AbstractNodeState {
     @Override @Nonnull
     public Iterable<String> getChildNodeNames() {
         assert base != null;
-        Map<String, MutableNodeState> copy = newHashMap(nodes);
-        return withNodes(base, copy).getChildNodeNames();
+        return ModifiedNodeState.getChildNodeNames(base, nodes, true);
     }
 
     @Override @Nonnull
