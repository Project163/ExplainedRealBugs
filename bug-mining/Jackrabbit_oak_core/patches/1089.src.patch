diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DiffCache.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DiffCache.java
index baf625831c..23479a7960 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DiffCache.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DiffCache.java
@@ -18,6 +18,7 @@ package org.apache.jackrabbit.oak.plugins.document;
 
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 
 /**
  * A cache for child node diffs.
@@ -38,12 +39,14 @@ public interface DiffCache {
      * @param from the from revision.
      * @param to the to revision.
      * @param path the path of the parent node.
-     * @return the diff or {@code null} if unknown.
+     * @param loader an optional loader for the cache entry.
+     * @return the diff or {@code null} if unknown and no loader was passed.
      */
     @CheckForNull
     String getChanges(@Nonnull Revision from,
-                             @Nonnull Revision to,
-                             @Nonnull String path);
+                      @Nonnull Revision to,
+                      @Nonnull String path,
+                      @Nullable Loader loader);
 
     /**
      * Starts a new cache entry for the diff cache. Actual changes are added
@@ -55,7 +58,7 @@ public interface DiffCache {
      */
     @Nonnull
     Entry newEntry(@Nonnull Revision from,
-                          @Nonnull Revision to);
+                   @Nonnull Revision to);
 
     public interface Entry {
 
@@ -66,7 +69,7 @@ public interface DiffCache {
          * @param changes the child node changes.
          */
         void append(@Nonnull String path,
-                           @Nonnull String changes);
+                    @Nonnull String changes);
 
         /**
          * Called when all changes have been appended and the entry is ready
@@ -74,4 +77,9 @@ public interface DiffCache {
          */
         void done();
     }
+
+    public interface Loader {
+
+        String call();
+    }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
index 17c2e18818..2876ecd111 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
@@ -1213,12 +1213,14 @@ public final class DocumentNodeStore
         if (node.hasNoChildren() && base.hasNoChildren()) {
             return "";
         }
-        String diff = diffCache.getChanges(base.getLastRevision(),
-                node.getLastRevision(), node.getPath());
-        if (diff == null) {
-            diff = diffImpl(base, node);
-        }
-        return diff;
+        return diffCache.getChanges(base.getLastRevision(),
+                node.getLastRevision(), node.getPath(),
+                new DiffCache.Loader() {
+                    @Override
+                    public String call() {
+                        return diffImpl(base, node);
+                    }
+                });
     }
 
     String diff(@Nonnull final String fromRevisionId,
@@ -1232,17 +1234,20 @@ public final class DocumentNodeStore
         final DocumentNodeState from = getNode(path, fromRev);
         final DocumentNodeState to = getNode(path, toRev);
         if (from == null || to == null) {
-            // TODO implement correct behavior if the node does't/didn't exist
+            // TODO implement correct behavior if the node doesn't/didn't exist
             String msg = String.format("Diff is only supported if the node exists in both cases. " +
                     "Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s",
                     path, fromRev, from != null, toRev, to != null);
             throw new DocumentStoreException(msg);
         }
-        String compactDiff = diffCache.getChanges(fromRev, toRev, path);
-        if (compactDiff == null) {
-            // calculate the diff
-            compactDiff = diffImpl(from, to);
-        }
+        String compactDiff = diffCache.getChanges(fromRev, toRev, path,
+                new DiffCache.Loader() {
+            @Override
+            public String call() {
+                // calculate the diff
+                return diffImpl(from, to);
+            }
+        });
         JsopWriter writer = new JsopStream();
         diffProperties(from, to, writer);
         JsopTokenizer t = new JsopTokenizer(compactDiff);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MemoryDiffCache.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MemoryDiffCache.java
index 40f8e9d3b2..09154bb6b3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MemoryDiffCache.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MemoryDiffCache.java
@@ -16,8 +16,12 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 
 import org.apache.jackrabbit.oak.cache.CacheStats;
 import org.apache.jackrabbit.oak.plugins.document.util.StringValue;
@@ -50,9 +54,25 @@ class MemoryDiffCache implements DiffCache {
     @Override
     public String getChanges(@Nonnull Revision from,
                              @Nonnull Revision to,
-                             @Nonnull String path) {
+                             @Nonnull String path,
+                             final @Nullable Loader loader) {
         PathRev key = diffCacheKey(path, from, to);
-        StringValue diff = diffCache.getIfPresent(key);
+        StringValue diff;
+        if (loader == null) {
+            diff = diffCache.getIfPresent(key);
+        } else {
+            try {
+                diff = diffCache.get(key, new Callable<StringValue>() {
+                    @Override
+                    public StringValue call() throws Exception {
+                        return new StringValue(loader.call());
+                    }
+                });
+            } catch (ExecutionException e) {
+                // try again with loader directly
+                diff = new StringValue(loader.call());
+            }
+        }
         return diff != null ? diff.toString() : null;
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MongoDiffCache.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MongoDiffCache.java
index df2dd01033..f43777e5cb 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MongoDiffCache.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/MongoDiffCache.java
@@ -21,6 +21,7 @@ import java.util.concurrent.locks.Lock;
 
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -77,59 +78,18 @@ public class MongoDiffCache extends MemoryDiffCache {
     @Override
     public String getChanges(@Nonnull Revision from,
                              @Nonnull Revision to,
-                             @Nonnull String path) {
+                             @Nonnull String path,
+                             @Nullable Loader loader) {
         Lock lock = locks.get(from);
         lock.lock();
         try {
-            // first try to serve from cache
-            String diff = super.getChanges(from, to, path);
-            if (diff != null) {
-                return diff;
-            }
-            if (from.getClusterId() != to.getClusterId()) {
-                return null;
-            }
-            // check blacklist
-            if (blacklist.getIfPresent(from + "/" + to) != null) {
-                return null;
-            }
-            Revision id = to;
-            Diff d = null;
-            int numCommits = 0;
-            for (;;) {
-                // grab from mongo
-                DBObject obj = changes.findOne(new BasicDBObject("_id", id.toString()));
-                if (obj == null) {
-                    return null;
-                }
-                numCommits++;
-                if (numCommits > 32) {
-                    // do not merge more than 32 commits
-                    blacklist.put(from + "/" + to, "");
-                    return null;
-                }
-                if (d == null) {
-                    d = new Diff(obj);
-                } else {
-                    d.mergeBeforeDiff(new Diff(obj));
-                }
-
-                // the from revision of the current diff
-                id = Revision.fromString((String) obj.get("_b"));
-                if (from.equals(id)) {
-                    // diff is complete
-                    LOG.debug("Built diff from {} commits", numCommits);
-                    // apply to diff cache and serve later requests from cache
-                    d.applyToEntry(super.newEntry(from, to)).done();
-                    // return changes
-                    return d.getChanges(path);
-                }
-
-                if (StableRevisionComparator.INSTANCE.compare(id, from) < 0) {
-                    break;
-                }
+            String changes = getChangesInternal(from, to, path);
+            if (changes == null && loader != null) {
+                changes = loader.call();
+                // put into memory cache
+                super.newEntry(from, to).append(path, changes);
             }
-            return null;
+            return changes;
         } finally {
             lock.unlock();
         }
@@ -161,6 +121,60 @@ public class MongoDiffCache extends MemoryDiffCache {
         };
     }
 
+    private String getChangesInternal(@Nonnull Revision from,
+                                      @Nonnull Revision to,
+                                      @Nonnull String path) {
+        // first try to serve from cache
+        String diff = super.getChanges(from, to, path, null);
+        if (diff != null) {
+            return diff;
+        }
+        if (from.getClusterId() != to.getClusterId()) {
+            return null;
+        }
+        // check blacklist
+        if (blacklist.getIfPresent(from + "/" + to) != null) {
+            return null;
+        }
+        Revision id = to;
+        Diff d = null;
+        int numCommits = 0;
+        for (;;) {
+            // grab from mongo
+            DBObject obj = changes.findOne(new BasicDBObject("_id", id.toString()));
+            if (obj == null) {
+                return null;
+            }
+            numCommits++;
+            if (numCommits > 32) {
+                // do not merge more than 32 commits
+                blacklist.put(from + "/" + to, "");
+                return null;
+            }
+            if (d == null) {
+                d = new Diff(obj);
+            } else {
+                d.mergeBeforeDiff(new Diff(obj));
+            }
+
+            // the from revision of the current diff
+            id = Revision.fromString((String) obj.get("_b"));
+            if (from.equals(id)) {
+                // diff is complete
+                LOG.debug("Built diff from {} commits", numCommits);
+                // apply to diff cache and serve later requests from cache
+                d.applyToEntry(super.newEntry(from, to)).done();
+                // return changes
+                return d.getChanges(path);
+            }
+
+            if (StableRevisionComparator.INSTANCE.compare(id, from) < 0) {
+                break;
+            }
+        }
+        return null;
+    }
+
     static class Diff {
 
         private final DBObject doc;
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AmnesiaDiffCache.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AmnesiaDiffCache.java
index d2d51158cb..7fe0d06ef5 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AmnesiaDiffCache.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/AmnesiaDiffCache.java
@@ -17,6 +17,7 @@
 package org.apache.jackrabbit.oak.plugins.document;
 
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 
 /**
  * A diff cache implementation, which immediately forgets the diff.
@@ -32,7 +33,11 @@ class AmnesiaDiffCache implements DiffCache {
     @Override
     public String getChanges(@Nonnull Revision from,
                              @Nonnull Revision to,
-                             @Nonnull String path) {
+                             @Nonnull String path,
+                             @Nullable Loader loader) {
+        if (loader != null) {
+            return loader.call();
+        }
         return null;
     }
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
index ceb6b4f318..8152025953 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreTest.java
@@ -25,6 +25,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -55,6 +56,7 @@ import org.junit.After;
 import org.junit.Test;
 
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -789,6 +791,73 @@ public class DocumentNodeStoreTest {
         ns2.dispose();
     }
 
+    // OAK-1782
+    @Test
+    public void diffOnce() throws Exception {
+        final AtomicInteger numQueries = new AtomicInteger();
+        MemoryDocumentStore store = new MemoryDocumentStore() {
+            @Nonnull
+            @Override
+            public <T extends Document> List<T> query(Collection<T> collection,
+                                                      String fromKey,
+                                                      String toKey,
+                                                      String indexedProperty,
+                                                      long startValue,
+                                                      int limit) {
+                numQueries.getAndIncrement();
+                return super.query(collection, fromKey, toKey,
+                        indexedProperty, startValue, limit);
+            }
+        };
+        final DocumentNodeStore ns = new DocumentMK.Builder()
+                .setDocumentStore(store).getNodeStore();
+        NodeBuilder builder = ns.getRoot().builder();
+        // make sure we have enough children to trigger diffManyChildren
+        for (int i = 0; i < DocumentMK.MANY_CHILDREN_THRESHOLD * 2; i++) {
+            builder.child("node-" + i);
+        }
+        merge(ns, builder);
+
+        final Revision head = ns.getHeadRevision();
+        final Revision to = new Revision(
+                head.getTimestamp() + 1000, 0, head.getClusterId());
+        int numReaders = 10;
+        final CountDownLatch ready = new CountDownLatch(numReaders);
+        final CountDownLatch go = new CountDownLatch(1);
+        List<Thread> readers = Lists.newArrayList();
+        for (int i = 0; i < numReaders; i++) {
+            Thread t = new Thread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        ready.countDown();
+                        go.await();
+                        ns.diff(head.toString(), to.toString(), "/");
+                    } catch (InterruptedException e) {
+                        // ignore
+                    }
+                }
+            });
+            readers.add(t);
+            t.start();
+        }
+
+        ready.await();
+        numQueries.set(0);
+        go.countDown();
+
+        for (Thread t : readers) {
+            t.join();
+        }
+
+        // must not perform more than two queries
+        // 1) query the first 50 children to find out there are many
+        // 2) query for the changed children between the two revisions
+        assertTrue(numQueries.get() <= 2);
+
+        store.dispose();
+    }
+
     private static void merge(NodeStore store, NodeBuilder root)
             throws CommitFailedException {
         store.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);
