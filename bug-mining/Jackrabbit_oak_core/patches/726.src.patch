diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
index 49c9d01f32..48f3bfb11c 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
@@ -362,9 +362,7 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
      */
     @CheckForNull
     public String getCommitRootPath(Revision revision) {
-        // check local map first
-        Map<Revision, String> local = getLocalCommitRoot();
-        String depth = local.get(revision);
+        String depth = getCommitRootDepth(revision);
         if (depth != null) {
             if (depth.equals("0")) {
                 return "/";
@@ -373,13 +371,6 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
             return PathUtils.getAncestorPath(p,
                     PathUtils.getDepth(p) - Integer.parseInt(depth));
         }
-        // check previous
-        for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {
-            String path = prev.getCommitRootPath(revision);
-            if (path != null) {
-                return path;
-            }
-        }
         return null;
     }
 
@@ -967,6 +958,31 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
         return store.find(Collection.NODES, Utils.getIdFromPath(commitRootPath));
     }
 
+    /**
+     * Returns the commit root depth for the given revision. This method also
+     * takes previous documents into account.
+     *
+     * @param revision get the commit root depth for this revision.
+     * @return the depth or <code>null</code> if there is no commit root entry
+     *         for the given revision on this document or previous documents.
+     */
+    @CheckForNull
+    private String getCommitRootDepth(@Nonnull Revision revision) {
+        // check local map first
+        Map<Revision, String> local = getLocalCommitRoot();
+        String depth = local.get(revision);
+        if (depth == null) {
+            // check previous
+            for (NodeDocument prev : getPreviousDocs(COMMIT_ROOT, revision)) {
+                depth = prev.getCommitRootDepth(revision);
+                if (depth != null) {
+                    break;
+                }
+            }
+        }
+        return depth;
+    }
+
     /**
      * Checks that revision x is newer than another revision.
      *
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java
index 51231a63c5..ed0fb7a97c 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentSplitTest.java
@@ -277,6 +277,27 @@ public class DocumentSplitTest extends BaseDocumentMKTest {
         }
     }
 
+    @Test
+    public void commitRootInPrevious() {
+        DocumentStore store = mk.getDocumentStore();
+        DocumentNodeStore ns = mk.getNodeStore();
+        mk.commit("/", "+\"test\":{\"node\":{}}", null, null);
+        mk.commit("/test", "+\"foo\":{}+\"bar\":{}", null, null);
+        mk.commit("/test", "^\"foo/prop\":0^\"bar/prop\":0", null, null);
+        NodeDocument doc = store.find(NODES, Utils.getIdFromPath("/test/foo"));
+        assertNotNull(doc);
+        String rev = null;
+        for (int i = 0; i < NodeDocument.NUM_REVS_THRESHOLD; i++) {
+            rev = mk.commit("/test/foo", "^\"prop\":" + i, null, null);
+        }
+        ns.runBackgroundOperations();
+        doc = store.find(NODES, Utils.getIdFromPath("/test/foo"));
+        assertNotNull(doc);
+        DocumentNodeState node = doc.getNodeAtRevision(ns,
+                Revision.fromString(rev), null);
+        assertNotNull(node);
+    }
+
     private void syncMKs(List<DocumentMK> mks, int idx) {
         mks.get(idx).runBackgroundOperations();
         for (int i = 0; i < mks.size(); i++) {
