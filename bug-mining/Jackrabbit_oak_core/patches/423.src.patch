diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java
index 4316b2896b..91e50acbe3 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/SQL2Parser.java
@@ -19,6 +19,15 @@ package org.apache.jackrabbit.oak.query;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Maps.newHashMap;
 
+import java.math.BigDecimal;
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.jcr.PropertyType;
+
 import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.commons.PathUtils;
@@ -39,18 +48,9 @@ import org.apache.jackrabbit.oak.query.ast.SourceImpl;
 import org.apache.jackrabbit.oak.query.ast.StaticOperandImpl;
 import org.apache.jackrabbit.oak.spi.query.PropertyValues;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
-import org.apache.jackrabbit.util.ISO9075;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.jcr.PropertyType;
-import java.math.BigDecimal;
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
 /**
  * The SQL2 parser can convert a JCR-SQL2 query to a query. The 'old' SQL query
  * language (here named SQL-1) is also supported.
@@ -506,7 +506,7 @@ public class SQL2Parser {
     }
 
     private String readPath() throws ParseException {
-        return ISO9075.decode(readName());
+        return readName();
     }
 
     private DynamicOperandImpl parseDynamicOperand() throws ParseException {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java
index 3a11e3cea5..9af414faca 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/XPathToSQL2Converter.java
@@ -393,8 +393,11 @@ public class XPathToSQL2Converter {
         if (currentSelector.nodeName != null) {
             Function f = new Function("name");
             f.params.add(new SelectorExpr(currentSelector));
+            String n = currentSelector.nodeName;
+            // encode again, because it will be decoded again
+            n = ISO9075.encode(n);
             Condition c = new Condition(f, "=", 
-                    Literal.newString(currentSelector.nodeName), 
+                    Literal.newString(n), 
                     Expression.PRECEDENCE_CONDITION);
             condition = add(condition, c);
         }
@@ -1148,6 +1151,16 @@ public class XPathToSQL2Converter {
         String getColumnAliasName() {
             return toString();
         }
+        
+        /**
+         * Whether the result of this expression is a name. Names are subject to
+         * ISO9075 encoding.
+         * 
+         * @return whether this expression is a name.
+         */
+        boolean isName() {
+            return false;
+        }
 
     }
 
@@ -1175,21 +1188,23 @@ public class XPathToSQL2Converter {
     static class Literal extends Expression {
 
         final String value;
+        final String rawText;
 
-        Literal(String value) {
+        Literal(String value, String rawText) {
             this.value = value;
+            this.rawText = rawText;
         }
 
         public static Expression newBoolean(boolean value) {
-            return new Literal(String.valueOf(value));
+            return new Literal(String.valueOf(value), String.valueOf(value));
         }
 
         static Literal newNumber(String s) {
-            return new Literal(s);
+            return new Literal(s, s);
         }
 
         static Literal newString(String s) {
-            return new Literal(SQL2Parser.escapeStringLiteral(s));
+            return new Literal(SQL2Parser.escapeStringLiteral(s), s);
         }
 
         @Override
@@ -1265,25 +1280,50 @@ public class XPathToSQL2Converter {
 
         @Override
         public String toString() {
-            StringBuilder buff = new StringBuilder();
-            if (left != null) {
+            String leftExpr;
+            boolean leftExprIsName;
+            if (left == null) {
+                leftExprIsName = false;
+                leftExpr = "";
+            } else {
+                leftExprIsName = left.isName();
+                leftExpr = left.toString();
                 if (left.getPrecedence() < precedence) {
-                    buff.append('(').append(left.toString()).append(')');
-                } else {
-                    buff.append(left.toString());
+                    leftExpr = "(" + leftExpr + ")";
                 }
-                buff.append(' ');
             }
-            buff.append(operator);
-            if (right != null) {
-                buff.append(' ');
-                if (right.getPrecedence() < precedence) {
-                    buff.append('(').append(right.toString()).append(')');
+            boolean impossible = false;
+            String rightExpr;
+            if (right == null) {
+                rightExpr = "";
+            } else {
+                if (leftExprIsName && !"like".equals(operator)) {
+                    // need to de-escape _x0020_ and so on
+                    if (!(right instanceof Literal)) {
+                        throw new IllegalArgumentException(
+                                "Can only compare a name against a string literal, not " + right);
+                    }
+                    Literal l = (Literal) right;
+                    String raw = l.rawText;
+                    String decoded = ISO9075.decode(raw);
+                    String encoded = ISO9075.encode(decoded);
+                    rightExpr = SQL2Parser.escapeStringLiteral(decoded);
+                    if (!encoded.toUpperCase().equals(raw.toUpperCase())) {
+                        // nothing can potentially match
+                        impossible = true;
+                    }
                 } else {
-                    buff.append(right.toString());
+                    rightExpr = right.toString();
+                }
+                if (right.getPrecedence() < precedence) {
+                    rightExpr = "(" + right + ")";
                 }
             }
-            return buff.toString();
+            if (impossible) {
+                // a condition that can not possibly be true
+                return "upper(" + leftExpr + ") = 'never matches'";
+            }
+            return (leftExpr + " " + operator + " " + rightExpr).trim();
         }
 
         @Override
@@ -1323,6 +1363,14 @@ public class XPathToSQL2Converter {
         boolean isCondition() {
             return name.equals("contains") || name.equals("not");
         }
+        
+        @Override
+        boolean isName() {
+            if ("upper".equals(name) || "lower".equals(name)) {
+                return params.get(0).isName();
+            }
+            return "name".equals(name);
+        }
 
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeLocalNameImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeLocalNameImpl.java
index c6cbc8721d..4e6ac36e4e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeLocalNameImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeLocalNameImpl.java
@@ -28,7 +28,6 @@ import org.apache.jackrabbit.oak.api.PropertyValue;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.query.index.FilterImpl;
 import org.apache.jackrabbit.oak.spi.query.PropertyValues;
-import org.apache.jackrabbit.util.ISO9075;
 
 /**
  * The function "localname(..)".
@@ -69,8 +68,6 @@ public class NodeLocalNameImpl extends DynamicOperandImpl {
     @Override
     public PropertyValue currentProperty() {
         String name = PathUtils.getName(selector.currentPath());
-        // Name escaping (convert space to _x0020_)
-        name = ISO9075.encode(name);
         int colon = name.indexOf(':');
         // TODO LOCALNAME: evaluation of local name might not be correct
         String localName = colon < 0 ? name : name.substring(colon + 1);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeNameImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeNameImpl.java
index 873b8f82a2..da547c0d74 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeNameImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/NodeNameImpl.java
@@ -76,8 +76,7 @@ public class NodeNameImpl extends DynamicOperandImpl {
     @Override
     public PropertyValue currentProperty() {
         String path = selector.currentPath();
-        // Name escaping (convert space to _x0020_)
-        String name = ISO9075.encode(PathUtils.getName(path));
+        String name = PathUtils.getName(path);
         return PropertyValues.newName(name);
     }
 
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt
index ee8f945ecb..a5bd198ff7 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2.txt
@@ -136,6 +136,11 @@ select [jcr:path] from [nt:base] as a where issamenode(a, '/')
 commit / + "test": { "My Documents": { "x" : {}}}
 
 select [jcr:path] from [nt:base] where name() = 'My_x0020_Documents'
+
+select [jcr:path] from [nt:base] where name() like '%My Documents%'
+/test/My Documents
+
+select [jcr:path] from [nt:base] where name() = 'My Documents'
 /test/My Documents
 
 commit / - "test"
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt
index 06262f6790..552125a885 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/xpath.txt
@@ -23,6 +23,35 @@
 # * new tests are typically be added on top, after the syntax docs
 # * use ascii character only
 
+# xpath name escaping
+
+xpath2sql //My_x0020_Documents
+select [jcr:path], [jcr:score], * from [nt:base] as a where name(a) = 'My Documents' /* xpath: //My_x0020_Documents */
+
+xpath2sql //*[fn:name() = 'My Documents']
+select [jcr:path], [jcr:score], * from [nt:base] as a where upper(name(a)) = 'never matches' /* xpath: //*[fn:name() = 'My Documents'] */
+
+xpath2sql //*[fn:name() = 'My_x0020_Documents']
+select [jcr:path], [jcr:score], * from [nt:base] as a where name(a) = 'My Documents' /* xpath: //*[fn:name() = 'My_x0020_Documents'] */
+
+xpath2sql //*[fn:name() <> 'My_x0020_Documents']
+select [jcr:path], [jcr:score], * from [nt:base] as a where name(a) <> 'My Documents' /* xpath: //*[fn:name() <> 'My_x0020_Documents'] */
+
+xpath2sql //*[fn:upper-case(fn:name()) > 'MY_x0020_DOCS']
+select [jcr:path], [jcr:score], * from [nt:base] as a where upper(name(a)) > 'MY DOCS' /* xpath: //*[fn:upper-case(fn:name()) > 'MY_x0020_DOCS'] */
+
+xpath2sql //*[fn:lower-case(fn:name()) < 'my_x0020_docs']
+select [jcr:path], [jcr:score], * from [nt:base] as a where lower(name(a)) < 'my docs' /* xpath: //*[fn:lower-case(fn:name()) < 'my_x0020_docs'] */
+
+xpath2sql //*[fn:lower-case(fn:upper-case(fn:name())) >= 'my_x0020_docs']
+select [jcr:path], [jcr:score], * from [nt:base] as a where lower(upper(name(a))) >= 'my docs' /* xpath: //*[fn:lower-case(fn:upper-case(fn:name())) >= 'my_x0020_docs'] */
+
+xpath2sql //*[fn:upper-case(fn:lower-case(fn:name())) <= 'MY_x0020_DOCS']
+select [jcr:path], [jcr:score], * from [nt:base] as a where upper(lower(name(a))) <= 'MY DOCS' /* xpath: //*[fn:upper-case(fn:lower-case(fn:name())) <= 'MY_x0020_DOCS'] */
+
+xpath2sql //*[jcr:like(fn:name(), '%My Documents%')]
+select [jcr:path], [jcr:score], * from [nt:base] as a where name(a) like '%My Documents%' /* xpath: //*[jcr:like(fn:name(), '%My Documents%')] */
+
 # jackrabbit test queries
 
 xpath2sql /*[jcr:contains(., 'hello')]/rep:excerpt(.)
