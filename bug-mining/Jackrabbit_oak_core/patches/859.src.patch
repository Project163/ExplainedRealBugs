diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java
index 894e2fde77..c179e9ff3d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java
@@ -81,7 +81,7 @@ class Collision {
         document.deepCopy(newDoc);
         UpdateUtils.applyChanges(newDoc, ourOp, context.getRevisionComparator());
         if (!markCommitRoot(newDoc, ourRev, store)) {
-            throw new MicroKernelException("Unable to annotate our revision "
+            throw new IllegalStateException("Unable to annotate our revision "
                     + "with collision marker. Our revision: " + ourRev
                     + ", document:\n" + newDoc.format());
         }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
index 5d7b137e2a..33da14aa62 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
@@ -275,6 +275,8 @@ public class Commit {
             }
         }
         int commitRootDepth = PathUtils.getDepth(commitRootPath);
+        // check if there are real changes on the commit root
+        boolean commitRootHasChanges = operations.containsKey(commitRootPath);
         // create a "root of the commit" if there is none
         UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);
         for (String p : operations.keySet()) {
@@ -283,7 +285,10 @@ public class Commit {
                 NodeDocument.setDeleted(op, revision, false);
             }
             if (op == commitRoot) {
-                // apply at the end
+                if (!op.isNew() && commitRootHasChanges) {
+                    // commit root already exists and this is an update
+                    changedNodes.add(op);
+                }
             } else {
                 NodeDocument.setCommitRoot(op, revision, commitRootDepth);
                 if (op.isNew()) {
@@ -327,11 +332,10 @@ public class Commit {
                 }
             }
             for (UpdateOp op : changedNodes) {
-                // set commit root on changed nodes unless it's the
-                // commit root itself
-                if (op != commitRoot) {
-                    NodeDocument.setCommitRoot(op, revision, commitRootDepth);
-                }
+                // set commit root on changed nodes. this may even apply
+                // to the commit root. the _commitRoot entry is removed
+                // again when the _revisions entry is set at the end
+                NodeDocument.setCommitRoot(op, revision, commitRootDepth);
                 opLog.add(op);
                 createOrUpdateNode(store, op);
             }
@@ -340,7 +344,12 @@ public class Commit {
             // first to check if there was a conflict, and only then to commit
             // the revision, with the revision property set)
             if (changedNodes.size() > 0 || !commitRoot.isNew()) {
+                // set revision to committed
                 NodeDocument.setRevision(commitRoot, revision, commitValue);
+                if (commitRootHasChanges) {
+                    // remove previously added commit root
+                    NodeDocument.removeCommitRoot(commitRoot, revision);
+                }
                 opLog.add(commitRoot);
                 if (baseBranchRevision == null) {
                     // create a clone of the commitRoot in order
@@ -554,7 +563,7 @@ public class Commit {
             // or document did not exist before
             return false;
         }
-        return doc.isConflicting(op, baseRevision, nodeStore);
+        return doc.isConflicting(op, baseRevision, revision, nodeStore);
     }
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
index 920cb9c5a6..bb5984c169 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
@@ -814,17 +814,22 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
      *
      * @param op the update operation.
      * @param baseRevision the base revision for the update operation.
+     * @param commitRevision the commit revision of the update operation.
      * @param context the revision context.
      * @return <code>true</code> if conflicting, <code>false</code> otherwise.
      */
-    public boolean isConflicting(@Nonnull UpdateOp op,
+    boolean isConflicting(@Nonnull UpdateOp op,
                                  @Nonnull Revision baseRevision,
+                                 @Nonnull Revision commitRevision,
                                  @Nonnull RevisionContext context) {
         // did existence of node change after baseRevision?
         // only check local deleted map, which contains the most
         // recent values
         Map<Revision, String> deleted = getLocalDeleted();
         for (Map.Entry<Revision, String> entry : deleted.entrySet()) {
+            if (entry.getKey().equals(commitRevision)) {
+                continue;
+            }
             if (isRevisionNewer(context, entry.getKey(), baseRevision)) {
                 return true;
             }
@@ -845,6 +850,9 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
             }
             // was this property touched after baseRevision?
             for (Revision rev : getValueMap(name).keySet()) {
+                if (rev.equals(commitRevision)) {
+                    continue;
+                }
                 if (isRevisionNewer(context, rev, baseRevision)) {
                     return true;
                 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java
index 6a60e100b9..ae2a226441 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/state/AbstractNodeStoreBranch.java
@@ -32,6 +32,7 @@ import static org.apache.jackrabbit.oak.commons.PathUtils.getParentPath;
 
 import javax.annotation.Nonnull;
 
+import org.apache.jackrabbit.mk.api.MicroKernelException;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher;
@@ -500,9 +501,12 @@ public abstract class AbstractNodeStoreBranch<S extends NodeStore, N extends Nod
                     dispatcher.contentChanged(newHead, info);
                     branchState = new Merged(base);
                     return newHead;
-                } catch (Exception e) {
+                } catch (MicroKernelException e) {
                     throw new CommitFailedException(MERGE, 1,
                             "Failed to merge changes to the underlying store", e);
+                } catch (Exception e) {
+                    throw new CommitFailedException(OAK, 1,
+                            "Failed to merge changes to the underlying store", e);
                 }
             } finally {
                 dispatcher.contentChanged(getRoot(), null);
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ConcurrentPropertyUpdateTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ConcurrentPropertyUpdateTest.java
new file mode 100644
index 0000000000..ea3e0a6c5d
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ConcurrentPropertyUpdateTest.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document;
+
+import com.google.common.collect.Lists;
+import org.apache.jackrabbit.mk.api.MicroKernelException;
+import org.apache.jackrabbit.oak.api.CommitFailedException;
+import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;
+import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;
+import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;
+import org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore;
+import org.apache.jackrabbit.oak.spi.commit.CommitHook;
+import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
+import org.apache.jackrabbit.oak.spi.commit.CompositeHook;
+import org.apache.jackrabbit.oak.spi.commit.EditorHook;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
+import org.junit.After;
+import org.junit.Test;
+
+import javax.jcr.InvalidItemStateException;
+import javax.jcr.RepositoryException;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+/**
+ * Test for OAK-1751.
+ */
+public class ConcurrentPropertyUpdateTest extends BaseDocumentMKTest {
+
+    private static final int NUM_THREADS = 2;
+
+    private static final CommitHook HOOK = new CompositeHook(
+            new ConflictHook(new AnnotatingConflictHandler()),
+            new EditorHook(new ConflictValidatorProvider()));
+
+    private ExecutorService service = Executors.newFixedThreadPool(NUM_THREADS);
+
+    @After
+    public void dispose() {
+        service.shutdown();
+    }
+
+    @Override
+    public void initDocumentMK() {
+        mk = new DocumentMK.Builder().setDocumentStore(new MemoryDocumentStore() {
+            @Override
+            public <T extends Document> T findAndUpdate(Collection<T> collection,
+                                                        UpdateOp update)
+                    throws MicroKernelException {
+                try {
+                    Thread.sleep((long) (Math.random() * 10f));
+                } catch (InterruptedException e) {
+                    // ignore
+                }
+                return super.findAndUpdate(collection, update);
+            }
+        }).open();
+    }
+
+    @Test
+    public void concurrentUpdates() throws Exception {
+        final DocumentNodeStore store = mk.getNodeStore();
+        NodeBuilder builder = store.getRoot().builder();
+        builder.child("test").setProperty("prop", System.currentTimeMillis());
+        store.merge(builder, HOOK, CommitInfo.EMPTY);
+        List<Callable<Object>> tasks = Lists.newArrayList();
+        for (int i = 0; i < NUM_THREADS; i++) {
+            tasks.add(new Callable<Object>() {
+                @Override
+                public Object call() throws Exception {
+                    for (int i = 0; i < 100; i++) {
+                        try {
+                            NodeBuilder builder = store.getRoot().builder();
+                            builder.getChildNode("test").setProperty(
+                                    "prop", Math.random());
+                            store.merge(builder, HOOK, CommitInfo.EMPTY);
+                        } catch (CommitFailedException e) {
+                            // merge must either succeed or fail
+                            // with an InvalidItemStateException
+                            RepositoryException ex = e.asRepositoryException();
+                            if (!(ex instanceof InvalidItemStateException)) {
+                                throw e;
+                            }
+                        }
+                    }
+                    return null;
+                }
+            });
+        }
+        List<Future<Object>> results = service.invokeAll(tasks);
+        for (Future<Object> r : results) {
+            r.get();
+        }
+    }
+}
