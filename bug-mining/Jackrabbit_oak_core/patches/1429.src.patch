diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java
index 869840aa7c..2b3b585b90 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Collision.java
@@ -16,13 +16,18 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.Map;
+
 import javax.annotation.Nonnull;
 
+import org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;
+import org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName;
 
 /**
  * A <code>Collision</code> happens when a commit modifies a node, which was
@@ -65,6 +70,8 @@ class Collision {
      * @param store the document store.
      * @return the revision that was marked. Either our or their.
      * @throws DocumentStoreException if the mark operation fails.
+     * @throws IllegalStateException if neither their nor our revision can be
+     *              marked because both are already committed.
      */
     @Nonnull
     Revision mark(DocumentStore store) throws DocumentStoreException {
@@ -84,6 +91,38 @@ class Collision {
         return ourRev;
     }
 
+    /**
+     * Returns {@code true} if this is a conflicting collision, {@code false}
+     * otherwise.
+     *
+     * @return {@code true} if this is a conflicting collision, {@code false}
+     *              otherwise.
+     * @throws DocumentStoreException
+     */
+    boolean isConflicting() throws DocumentStoreException {
+        // did their revision create or delete the node?
+        if (document.getDeleted().containsKey(theirRev)) {
+            return true;
+        }
+
+        for (Map.Entry<Key, Operation> entry : ourOp.getChanges().entrySet()) {
+            String name = entry.getKey().getName();
+            if (NodeDocument.isDeletedEntry(name)) {
+                // always conflicts because existence changed
+                return true;
+            }
+            if (isPropertyName(name)) {
+                if (document.getValueMap(name).containsKey(theirRev)) {
+                    // concurrent change on the property
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    //--------------------------< internal >------------------------------------
+
     /**
      * Marks the commit root of the change to the given <code>document</code> in
      * <code>revision</code>.
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
index a9211633f8..3d854d9434 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Commit.java
@@ -517,17 +517,18 @@ public class Commit {
                         nodeStore, base, revision, getBranch(), collisions);
             }
             String conflictMessage = null;
-            Revision conflictRevision = newestRev;
+            Set<Revision> conflictRevisions = Sets.newHashSet();
             if (newestRev == null) {
                 if ((op.isDelete() || !op.isNew())
                         && !allowConcurrentAddRemove(before, op)) {
                     conflictMessage = "The node " +
                             op.getId() + " does not exist or is already deleted";
                     if (before != null && !before.getLocalDeleted().isEmpty()) {
-                        conflictRevision = before.getLocalDeleted().firstKey();
+                        conflictRevisions.add(before.getLocalDeleted().firstKey());
                     }
                 }
             } else {
+                conflictRevisions.add(newestRev);
                 if (op.isNew() && !allowConcurrentAddRemove(before, op)) {
                     conflictMessage = "The node " +
                             op.getId() + " was already added in revision\n" +
@@ -541,15 +542,16 @@ public class Commit {
                             baseRevision;
                 }
             }
-            if (conflictMessage == null) {
+            if (conflictMessage == null && before != null) {
                 // the modification was successful
                 // -> check for collisions and conflict (concurrent updates
                 // on a node are possible if property updates do not overlap)
                 // TODO: unify above conflict detection and isConflicting()
-                if (!collisions.isEmpty() && isConflicting(before, op)) {
-                    for (Revision r : collisions) {
+                boolean allowConflictingDeleteChange = allowConcurrentAddRemove(before, op);
+                for (Revision r : collisions) {
+                    Collision c = new Collision(before, r, op, revision);
+                    if (c.isConflicting() && !allowConflictingDeleteChange) {
                         // mark collisions on commit root
-                        Collision c = new Collision(before, r, op, revision);
                         if (c.mark(store).equals(revision)) {
                             // our revision was marked
                             if (baseRevision.isBranch()) {
@@ -562,7 +564,7 @@ public class Commit {
                                         formatConflictRevision(r) +
                                         ", which was applied after the base revision\n" +
                                         baseRevision;
-                                conflictRevision = r;
+                                conflictRevisions.add(r);
                             }
                         }
                     }
@@ -574,7 +576,7 @@ public class Commit {
                     LOG.debug(conflictMessage  + "; document:\n" +
                             (before == null ? "" : before.format()));
                 }
-                throw new ConflictException(conflictMessage, conflictRevision);
+                throw new ConflictException(conflictMessage, conflictRevisions);
             }
         }
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
index 977f500164..efe3e21193 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java
@@ -803,7 +803,7 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
                 // of the branch if this is for a commit on a branch
                 if (branch != null && !branch.containsCommit(r)) {
                     // change does not belong to the branch
-                    if (branch.getBase().isRevisionNewer(r)) {
+                    if (branch.getBase(changeRev).isRevisionNewer(r)) {
                         // and happened after the base of the branch
                         collisions.add(r);
                     }
@@ -2065,7 +2065,7 @@ public final class NodeDocument extends Document implements CachedNodeDocument{
     }
 
     @Nonnull
-    private Map<Revision, String> getDeleted() {
+    Map<Revision, String> getDeleted() {
         return ValueMap.create(this, DELETED);
     }
     
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java
index b9cbc85bde..1bb4da7276 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/ClusterConflictTest.java
@@ -38,7 +38,6 @@ import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.slf4j.Logger;
@@ -144,7 +143,6 @@ public class ClusterConflictTest {
     }
 
     // OAK-3859
-    @Ignore("OAK-3859")
     @Test
     public void mixedConflictAndCollision() throws Exception {
         NodeBuilder b1 = ns1.getRoot().builder();
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionTest.java
index 34d840d437..88cb80f4c7 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/CollisionTest.java
@@ -18,6 +18,13 @@ package org.apache.jackrabbit.oak.plugins.document;
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import javax.annotation.Nonnull;
+
+import org.apache.jackrabbit.oak.api.CommitFailedException;
+import org.apache.jackrabbit.oak.plugins.document.util.Utils;
+import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
+import org.apache.jackrabbit.oak.spi.commit.EmptyHook;
+import org.apache.jackrabbit.oak.spi.state.NodeBuilder;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -25,6 +32,9 @@ import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
 import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS;
 import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 
 public class CollisionTest {
 
@@ -71,6 +81,92 @@ public class CollisionTest {
         ns2.dispose();
     }
 
+    @Test
+    public void isConflicting() throws CommitFailedException {
+        DocumentNodeStore ns = builderProvider.newBuilder()
+                .setAsyncDelay(0).getNodeStore();
+        DocumentStore store = ns.getDocumentStore();
+        String id = Utils.getIdFromPath("/test");
+
+        NodeBuilder b = ns.getRoot().builder();
+        b.child("test").setProperty("p", "a");
+        // test:{p:"a"}
+        Revision r1 = merge(ns, b).getRevision(ns.getClusterId());
+        assertNotNull(r1);
+
+        NodeDocument doc = getDocument(store, id);
+        // concurrent create
+        Revision c = ns.newRevision();
+        UpdateOp op = new UpdateOp(id, true);
+        NodeDocument.setDeleted(op, c, false);
+        Collision col = new Collision(doc, r1, op, c);
+        assertTrue(col.isConflicting());
+        // concurrent change
+        op = new UpdateOp(id, false);
+        op.setMapEntry("p", c, "b");
+        col = new Collision(doc, r1, op, c);
+        assertTrue(col.isConflicting());
+
+        b = ns.getRoot().builder();
+        b.child("test").setProperty("p", "b");
+        // test:{p:"b"}
+        Revision r2 = merge(ns, b).getRevision(ns.getClusterId());
+        assertNotNull(r2);
+
+        doc = getDocument(store, id);
+        // concurrent delete
+        c = ns.newRevision();
+        op = new UpdateOp(id, false);
+        op.setDelete(true);
+        NodeDocument.setDeleted(op, c, true);
+        col = new Collision(doc, r2, op, c);
+        assertTrue(col.isConflicting());
+        // concurrent conflicting property set
+        op = new UpdateOp(id, false);
+        op.setMapEntry("p", c, "c");
+        col = new Collision(doc, r2, op, c);
+        assertTrue(col.isConflicting());
+        // concurrent non-conflicting property set
+        op = new UpdateOp(id, false);
+        op.setMapEntry("q", c, "a");
+        col = new Collision(doc, r2, op, c);
+        assertFalse(col.isConflicting());
+
+        b = ns.getRoot().builder();
+        b.child("test").remove();
+        // test (removed)
+        Revision r3 = merge(ns, b).getRevision(ns.getClusterId());
+        assertNotNull(r3);
+
+        doc = getDocument(store, id);
+        // concurrent delete
+        c = ns.newRevision();
+        op = new UpdateOp(id, false);
+        op.setDelete(true);
+        NodeDocument.setDeleted(op, c, true);
+        col = new Collision(doc, r3, op, c);
+        assertTrue(col.isConflicting());
+        // concurrent conflicting property set
+        op = new UpdateOp(id, false);
+        op.setMapEntry("p", c, "d");
+        col = new Collision(doc, r3, op, c);
+        assertTrue(col.isConflicting());
+    }
+
+    @Nonnull
+    private static RevisionVector merge(DocumentNodeStore ns, NodeBuilder nb)
+            throws CommitFailedException {
+        ns.merge(nb, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+        return ns.getHeadRevision();
+    }
+
+    @Nonnull
+    private static NodeDocument getDocument(DocumentStore store, String id) {
+        NodeDocument doc = store.find(NODES, id);
+        assertNotNull(doc);
+        return doc;
+    }
+
     private void createCollision(DocumentMK mk) throws Exception {
         String nodeName = "test-" + COUNTER.getAndIncrement();
         // create branch
