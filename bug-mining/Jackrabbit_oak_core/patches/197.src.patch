diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
index 57bf0d1672..002bad8e36 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/Query.java
@@ -308,7 +308,7 @@ public class Query {
         prepare();
         Iterator<ResultRowImpl> it;
         if (explain) {
-            String plan = source.getPlan(rootState);
+            String plan = getPlan();
             columns = new ColumnImpl[] { new ColumnImpl("explain", "plan", "plan")};
             ResultRowImpl r = new ResultRowImpl(this,
                     new String[0], 
@@ -317,7 +317,7 @@ public class Query {
             it = Arrays.asList(r).iterator();
         } else {
             if (LOG.isDebugEnabled()) {
-                LOG.debug("plan: " + source.getPlan(rootState));
+                LOG.debug("plan: " + getPlan());
             }
             if (orderings == null) {
                 // can apply limit and offset directly
@@ -437,6 +437,15 @@ public class Query {
         }
         return comp;
     }
+    
+    /**
+     * Get the query plan. The query must already be prepared.
+     * 
+     * @return the query plan
+     */
+    private String getPlan() {
+        return source.getPlan(rootState);
+    }
 
     void prepare() {
         if (prepared) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
index a7569bce82..2a79d6779e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/QueryEngineImpl.java
@@ -176,11 +176,14 @@ public abstract class QueryEngineImpl implements QueryEngine {
                 best = index;
             }
         }
-        if (best == null) {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("no indexes found - using TraversingIndex; indexProvider: " + indexProvider);
-            }
-            best = new TraversingIndex();
+        QueryIndex index = new TraversingIndex();
+        double cost = index.getCost(filter, rootState);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("cost for " + index.getIndexName() + " is " + cost);
+        }
+        if (cost < bestCost) {
+            bestCost = cost;
+            best = index;
         }
         return best;
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java
index 829196abc5..6213557f38 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ChildNodeJoinConditionImpl.java
@@ -66,12 +66,22 @@ public class ChildNodeJoinConditionImpl extends JoinConditionImpl {
     public void restrict(FilterImpl f) {
         if (f.getSelector() == parentSelector) {
             String c = childSelector.currentPath();
+            if (c == null && f.isPreparing() && childSelector.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                c = KNOWN_PATH;
+            }
             if (c != null) {
                 f.restrictPath(PathUtils.getParentPath(c), Filter.PathRestriction.EXACT);
             }
         }
         if (f.getSelector() == childSelector) {
             String p = parentSelector.currentPath();
+            if (p == null && f.isPreparing() && parentSelector.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                p = KNOWN_PATH;
+            }
             if (p != null) {
                 f.restrictPath(p, Filter.PathRestriction.DIRECT_CHILDREN);
             }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java
index 1552155cf1..8e5f945dcb 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/DescendantNodeJoinConditionImpl.java
@@ -66,12 +66,22 @@ public class DescendantNodeJoinConditionImpl extends JoinConditionImpl {
     public void restrict(FilterImpl f) {
         if (f.getSelector() == ancestorSelector) {
             String d = descendantSelector.currentPath();
+            if (d == null && f.isPreparing() && descendantSelector.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                d = KNOWN_PATH;
+            }
             if (d != null) {
                 f.restrictPath(PathUtils.getParentPath(d), Filter.PathRestriction.PARENT);
             }
         }
         if (f.getSelector() == descendantSelector) {
             String a = ancestorSelector.currentPath();
+            if (a == null && f.isPreparing() && ancestorSelector.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                a = KNOWN_PATH;
+            }
             if (a != null) {
                 f.restrictPath(a, Filter.PathRestriction.DIRECT_CHILDREN);
             }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java
index dae131d44a..01d1ce29d4 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/EquiJoinConditionImpl.java
@@ -97,21 +97,35 @@ public class EquiJoinConditionImpl extends JoinConditionImpl {
     public void restrict(FilterImpl f) {
         if (f.getSelector() == selector1) {
             PropertyValue p2 = selector2.currentProperty(property2Name);
+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                p2 = PropertyValues.newString(KNOWN_VALUE);
+            }
             if (p2 != null) {
-                if (!p2.isArray()) {
+                if (p2.isArray()) {
                     // TODO support join on multi-valued properties
-                    f.restrictProperty(property1Name, Operator.EQUAL, p2);
+                    p2 = null;
                 }
             }
+            // always set the condition, even if unkown ( -> is not null)
+            f.restrictProperty(property1Name, Operator.EQUAL, p2);
         }
         if (f.getSelector() == selector2) {
             PropertyValue p1 = selector1.currentProperty(property1Name);
+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                p1 = PropertyValues.newString(KNOWN_VALUE);
+            }
             if (p1 != null) {
-                if (!p1.isArray()) {
+                if (p1.isArray()) {
                     // TODO support join on multi-valued properties
-                    f.restrictProperty(property2Name, Operator.EQUAL, p1);
+                    p1 = null;
                 }
             }
+            // always set the condition, even if unkown ( -> is not null)
+            f.restrictProperty(property2Name, Operator.EQUAL, p1);
         }
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java
index b3e2fd54d4..f5c82986d4 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinConditionImpl.java
@@ -19,11 +19,36 @@ import org.apache.jackrabbit.oak.query.index.FilterImpl;
  * The base class for join conditions.
  */
 public abstract class JoinConditionImpl extends AstElement {
+    
+    /**
+     * A path with 6 elements, which is the expected average for a join.
+     */
+    protected static final String KNOWN_PATH = "/path/from/the/join/selector";
 
-    public abstract boolean evaluate();
+    protected static final String KNOWN_VALUE = "valueFromTheJoinSelector";
 
+    /**
+     * Evaluate the result using the currently set values.
+     * 
+     * @return true if the constraint matches
+     */
+    public abstract boolean evaluate();
+    
+    /**
+     * Apply the condition to the filter, further restricting the filter if
+     * possible. This may also verify the data types are compatible, and that
+     * paths are valid.
+     * 
+     * @param f the filter
+     */
     public abstract void restrict(FilterImpl f);
 
-    public abstract void restrictPushDown(SelectorImpl selectorImpl);
+    /**
+     * Push as much of the condition down to this selector, further restricting
+     * the selector condition if possible.
+     * 
+     * @param s the selector
+     */
+    public abstract void restrictPushDown(SelectorImpl s);
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java
index 6e4e408ea6..a5ab71f54d 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/JoinImpl.java
@@ -60,8 +60,15 @@ public class JoinImpl extends SourceImpl {
 
     @Override
     public String getPlan(NodeState rootState) {
-        return left.getPlan(rootState) + ' ' + joinType +
-                " " + right.getPlan(rootState) + " on " + joinCondition;
+        StringBuilder buff = new StringBuilder();
+        buff.append(left.getPlan(rootState)).
+            append(' ').
+            append(joinType).
+            append(' ').
+            append(right.getPlan(rootState)).
+            append(" on ").
+            append(joinCondition);
+        return buff.toString();
     }
 
     @Override
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java
index 187a795efb..7ab0cbee9b 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SameNodeJoinConditionImpl.java
@@ -81,6 +81,11 @@ public class SameNodeJoinConditionImpl extends JoinConditionImpl {
     public void restrict(FilterImpl f) {
         if (f.getSelector() == selector1) {
             String p2 = selector2.currentPath();
+            if (p2 == null && f.isPreparing() && selector2.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                p2 = KNOWN_PATH;
+            }
             if (p2 != null) {
                 if (selector2Path.equals(".")) {
                     f.restrictPath(p2, Filter.PathRestriction.EXACT);
@@ -93,6 +98,11 @@ public class SameNodeJoinConditionImpl extends JoinConditionImpl {
         }
         if (f.getSelector() == selector2) {
             String p1 = selector1.currentPath();
+            if (p1 == null && f.isPreparing() && selector1.isPrepared()) {
+                // during the prepare phase, if the selector is already
+                // prepared, then we would know the value
+                p1 = KNOWN_PATH;
+            }
             if (p1 != null) {
                 if (selector2Path.equals(".")) {
                     f.restrictPath(p1, Filter.PathRestriction.EXACT);
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java
index ecf1e5b705..3e779ff094 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SelectorImpl.java
@@ -95,6 +95,9 @@ public class SelectorImpl extends SourceImpl {
         return quote(nodeTypeName) + " as " + quote(selectorName);
     }
 
+    public boolean isPrepared() {
+        return index != null;
+    }
 
     @Override
     public void prepare() {
@@ -106,19 +109,19 @@ public class SelectorImpl extends SourceImpl {
                 c.restrictPushDown(this);
             }
         }
-        index = query.getBestIndex(createFilter());
+        index = query.getBestIndex(createFilter(true));
     }
 
     @Override
     public void execute(NodeState rootState) {
-        cursor = index.query(createFilter(), rootState);
+        cursor = index.query(createFilter(false), rootState);
     }
 
     @Override
     public String getPlan(NodeState rootState) {
         StringBuilder buff = new StringBuilder();
         buff.append(toString());
-        buff.append(" /* ").append(index.getPlan(createFilter(), rootState));
+        buff.append(" /* ").append(index.getPlan(createFilter(true), rootState));
         if (selectorCondition != null) {
             buff.append(" where ").append(selectorCondition);
         }
@@ -126,8 +129,15 @@ public class SelectorImpl extends SourceImpl {
         return buff.toString();
     }
 
-    private Filter createFilter() {
+    /**
+     * Create the filter condition for planning or execution.
+     * 
+     * @param preparing whether a filter for the prepare phase should be made 
+     * @return the filter
+     */
+    private Filter createFilter(boolean preparing) {
         FilterImpl f = new FilterImpl(this, query.getStatement());
+        f.setPreparing(preparing);
         validateNodeType(nodeTypeName);
         f.setNodeType(nodeTypeName);
         if (joinCondition != null) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java
index 9bf1ef2d6a..dc1d8e9f3f 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/SourceImpl.java
@@ -141,8 +141,8 @@ public abstract class SourceImpl extends AstElement {
     public abstract String getPlan(NodeState rootState);
 
     /**
-     * Prepare executing the query. This method will decide which index to use.
-     *
+     * Prepare executing the query (recursively). This method will decide which
+     * index to use.
      */
     public abstract void prepare();
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java
index f540e187f0..767ea3e5ac 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java
@@ -75,6 +75,11 @@ public class FilterImpl implements Filter {
      * Only return distinct values.
      */
     private boolean distinct;
+    
+    /**
+     * Set during the prepare phase of a query.
+     */
+    private boolean preparing;
 
     // TODO support "order by"
 
@@ -82,6 +87,14 @@ public class FilterImpl implements Filter {
         this.selector = selector;
         this.queryStatement = queryStatement;
     }
+    
+    public void setPreparing(boolean preparing) {
+        this.preparing = preparing;
+    }
+    
+    public boolean isPreparing() {
+        return preparing;
+    }
 
     /**
      * Get the path.
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/JsopUtil.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/JsopUtil.java
index d1a41cad7a..b37d27ee3d 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/query/JsopUtil.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/query/JsopUtil.java
@@ -176,9 +176,9 @@ public class JsopUtil {
                     String value = TypeCodes.decodeName(split, jsonString);
                     if (type == PropertyType.BINARY) {
                         throw new UnsupportedOperationException();
-                    } else if(type == PropertyType.DOUBLE) {
+                    } else if (type == PropertyType.DOUBLE) {
                         values.add(Conversions.convert(value).toDouble());
-                    } else if(type == PropertyType.DECIMAL) {
+                    } else if (type == PropertyType.DECIMAL) {
                         values.add(Conversions.convert(value).toDecimal());
                     } else {
                         values.add(value);
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt
index 6bbe0583ef..25a10afed2 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_explain.txt
@@ -34,7 +34,7 @@ explain select * from [nt:base] where property(id, 'REFERENCE') = CAST('123' AS
 [nt:base] as [nt:base] /* traverse "//*" where property([nt:base].[id], 'reference') = cast('123' as reference) */
 
 explain select b.[jcr:path] as [jcr:path], b.[jcr:score] as [jcr:score], b.* from [nt:base] as a inner join [nt:base] as b on ischildnode(a, b) where name(a) = 'yes' and isdescendantnode(a, '/test') and b.[x] is not null
-[nt:base] as [a] /* traverse "/test//*" where (name([a]) = cast('yes' as string)) and (isdescendantnode([a], [/test])) */ inner join [nt:base] as [b] /* traverse "//*" where [b].[x] is not null */ on ischildnode([a], [b])
+[nt:base] as [a] /* traverse "/test//*" where (name([a]) = cast('yes' as string)) and (isdescendantnode([a], [/test])) */ inner join [nt:base] as [b] /* traverse "/path/from/the/join" where [b].[x] is not null */ on ischildnode([a], [b])
 
 select * from [nt:base] where property([*], 'REFERENCE') = CAST('123' AS REFERENCE)
 /test/a
@@ -105,7 +105,7 @@ explain select * from [nt:base] as p inner join [nt:base] as c on p.id = c.p
 [nt:base] as [p] /* traverse "//*" where [p].[id] is not null */ inner join [nt:base] as [c] /* traverse "//*" where [c].[p] is not null */ on [p].[id] = [c].[p]
 
 explain select * from [nt:base] as p inner join [nt:base] as p2 on issamenode(p2, p) where p.[jcr:path] = '/parents'
-[nt:base] as [p] /* traverse "//*" where [p].[jcr:path] = cast('/parents' as string) */ inner join [nt:base] as [p2] /* traverse "//*" */ on issamenode([p2], [p], [.])
+[nt:base] as [p] /* traverse "//*" where [p].[jcr:path] = cast('/parents' as string) */ inner join [nt:base] as [p2] /* traverse "/path/from/the/join/selector" */ on issamenode([p2], [p], [.])
 
 explain select * from [nt:base] as p inner join [nt:base] as c on p.id = c.p
 [nt:base] as [p] /* traverse "//*" where [p].[id] is not null */ inner join [nt:base] as [c] /* traverse "//*" where [c].[p] is not null */ on [p].[id] = [c].[p]
diff --git a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
index 94c2e10830..1248119e3b 100644
--- a/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
+++ b/oak-core/src/test/resources/org/apache/jackrabbit/oak/query/sql2_index.txt
@@ -31,6 +31,12 @@ explain select * from [nt:base] where [jcr:uuid] = '123'
 explain select * from [nt:base] where [jcr:uuid] is not null
 [nt:base] as [nt:base] /* p2 jcr:uuid where [nt:base].[jcr:uuid] is not null */
 
+explain select * from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where a.[jcr:uuid] is not null and b.[jcr:uuid] is not null
+[nt:base] as [a] /* p2 jcr:uuid where [a].[jcr:uuid] is not null */ inner join [nt:base] as [b] /* p2 jcr:uuid where [b].[jcr:uuid] is not null */ on isdescendantnode([b], [a])
+
+explain select * from [nt:base] as a inner join [nt:base] as b on isdescendantnode(b, a) where a.[jcr:uuid] is not null and b.[x] is not null
+[nt:base] as [a] /* p2 jcr:uuid where [a].[jcr:uuid] is not null */ inner join [nt:base] as [b] /* traverse "/path/from/the/join/selector/*" where [b].[x] is not null */ on isdescendantnode([b], [a])
+
 commit / + "test": { "jcr:uuid": "xyz", "a": { "jcr:uuid": "123" } }
 
 select * from [nt:base] where [jcr:uuid] is not null
