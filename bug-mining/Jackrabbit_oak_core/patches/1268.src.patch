diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java
index 8007dfcca9..392b866dc8 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java
@@ -277,6 +277,9 @@ public class AsyncIndexUpdate implements Runnable {
             return;
         }
 
+        // start collecting runtime statistics
+        preAsyncRunStatsStats(indexStats);
+
         // find the last indexed state, and check if there are recent changes
         NodeState before;
         String beforeCheckpoint = async.getString(name);
@@ -292,6 +295,7 @@ public class AsyncIndexUpdate implements Runnable {
                 log.debug(
                         "[{}] No changes since last checkpoint; skipping the index update",
                         name);
+                postAsyncRunStatsStatus(indexStats);
                 return;
             } else {
                 before = state;
@@ -312,12 +316,15 @@ public class AsyncIndexUpdate implements Runnable {
             log.debug(
                     "[{}] Unable to retrieve newly created checkpoint {}, skipping the index update",
                     name, afterCheckpoint);
+            //Do not update the status as technically the run is not complete
             return;
         }
 
         String checkpointToRelease = afterCheckpoint;
+        boolean updatePostRunStatus = false;
         try {
-            updateIndex(before, beforeCheckpoint, after, afterCheckpoint, afterTime);
+            updatePostRunStatus = updateIndex(before, beforeCheckpoint,
+                    after, afterCheckpoint, afterTime);
 
             // the update succeeded, i.e. it no longer fails
             if (failing) {
@@ -354,18 +361,20 @@ public class AsyncIndexUpdate implements Runnable {
                             checkpointToRelease);
                 }
             }
+
+            if (updatePostRunStatus) {
+                postAsyncRunStatsStatus(indexStats);
+            }
         }
     }
 
-    private void updateIndex(
+    private boolean updateIndex(
             NodeState before, String beforeCheckpoint,
             NodeState after, String afterCheckpoint, String afterTime)
             throws CommitFailedException {
         Stopwatch watch = Stopwatch.createStarted();
+        boolean updatePostRunStatus = true;
         boolean progressLogged = false;
-        // start collecting runtime statistics
-        preAsyncRunStatsStats(indexStats);
-
         // create an update callback for tracking index updates
         // and maintaining the update lease
         AsyncUpdateCallback callback =
@@ -389,7 +398,6 @@ public class AsyncIndexUpdate implements Runnable {
 
             builder.child(ASYNC).setProperty(name, afterCheckpoint);
             builder.child(ASYNC).setProperty(PropertyStates.createProperty(lastIndexedTo, afterTime, Type.DATE));
-            boolean updatePostRunStatus = true;
             if (callback.isDirty() || before == MISSING_NODE) {
                 if (switchOnSync) {
                     reindexedDefinitions.addAll(indexUpdate
@@ -419,9 +427,6 @@ public class AsyncIndexUpdate implements Runnable {
                 updatePostRunStatus = true;
             }
             mergeWithConcurrencyCheck(builder, beforeCheckpoint, callback.lease);
-            if (updatePostRunStatus) {
-                postAsyncRunStatsStatus(indexStats);
-            }
             if (indexUpdate.isReindexingPerformed()) {
                 log.info("[{}] Reindexing completed for indexes: {} in {}",
                         name, indexUpdate.getReindexStats(), watch);
@@ -440,6 +445,8 @@ public class AsyncIndexUpdate implements Runnable {
                 log.debug(msg, name, watch, callback.updates);
             }
         }
+
+        return updatePostRunStatus;
     }
 
     private void mergeWithConcurrencyCheck(
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java
index 203824cc31..42d0491eb0 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java
@@ -38,6 +38,7 @@ import java.util.concurrent.Semaphore;
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import javax.management.openmbean.CompositeData;
 
 import ch.qos.logback.classic.Level;
 import org.apache.jackrabbit.oak.api.CommitFailedException;
@@ -807,6 +808,71 @@ public class AsyncIndexUpdateTest {
 
     }
 
+    @Test
+    public void testAsyncExecutionStats() throws Exception {
+        final Set<String> knownCheckpoints = Sets.newHashSet();
+        MemoryNodeStore store = new MemoryNodeStore(){
+            @Override
+            public synchronized NodeState retrieve(@Nonnull String checkpoint) {
+                if (!knownCheckpoints.isEmpty() && !knownCheckpoints.contains(checkpoint)){
+                    return null;
+                }
+                return super.retrieve(checkpoint);
+            }
+        };
+        IndexEditorProvider provider = new PropertyIndexEditorProvider();
+
+        NodeBuilder builder = store.getRoot().builder();
+        createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME),
+                "rootIndex", true, false, ImmutableSet.of("foo"), null)
+                .setProperty(ASYNC_PROPERTY_NAME, "async");
+        builder.child("testRoot").setProperty("foo", "abc");
+
+        // merge it back in
+        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        AsyncIndexUpdate async = new AsyncIndexUpdate("async", store, provider);
+        runOneCycle(async);
+        assertEquals(1, lastExecutionStats(async.getIndexStats().getExecutionCount()));
+
+        //Run a cycle so that change of reindex flag gets indexed
+        runOneCycle(async);
+        assertEquals(1, lastExecutionStats(async.getIndexStats().getExecutionCount()));
+
+        //Now run so that it results in an empty cycle
+        runOneCycle(async);
+        assertEquals(1, lastExecutionStats(async.getIndexStats().getExecutionCount()));
+
+        //Do some updates and counter should increase
+        builder = store.getRoot().builder();
+        builder.child("testRoot2").setProperty("foo", "abc");
+        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        runOneCycle(async);
+        assertEquals(1, lastExecutionStats(async.getIndexStats().getExecutionCount()));
+
+        //Do some updates but disable checkpoints. Counter should not increase
+        builder = store.getRoot().builder();
+        builder.child("testRoot3").setProperty("foo", "abc");
+        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        //Disable new checkpoint retrieval
+        knownCheckpoints.addAll(store.listCheckpoints());
+        runOneCycle(async);
+        assertEquals(0, lastExecutionStats(async.getIndexStats().getExecutionCount()));
+    }
+
+
+    private static long lastExecutionStats(CompositeData cd){
+        //Last stat is the last entry in the array
+        return ((long[]) cd.get("per second"))[59];
+    }
+
+    private static void runOneCycle(AsyncIndexUpdate async){
+        async.run();
+        async.getIndexStats().run();
+    }
+
     @Test
     public void checkpointStability() throws Exception{
         NodeStore store = new MemoryNodeStore();
