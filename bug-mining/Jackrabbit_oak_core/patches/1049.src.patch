diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java
index 76b8d6821f..256516f850 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdate.java
@@ -39,6 +39,7 @@ import org.apache.jackrabbit.oak.api.jmx.IndexStatsMBean;
 import org.apache.jackrabbit.oak.plugins.commit.AnnotatingConflictHandler;
 import org.apache.jackrabbit.oak.plugins.commit.ConflictHook;
 import org.apache.jackrabbit.oak.plugins.commit.ConflictValidatorProvider;
+import org.apache.jackrabbit.oak.plugins.index.IndexUpdate.MissingIndexProviderStrategy;
 import org.apache.jackrabbit.oak.plugins.memory.PropertyStates;
 import org.apache.jackrabbit.oak.spi.commit.CommitHook;
 import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
@@ -121,6 +122,8 @@ public class AsyncIndexUpdate implements Runnable {
      */
     private final Set<String> reindexedDefinitions = new HashSet<String>();
 
+    private final MissingIndexProviderStrategy missingStrategy = new DefaultMissingIndexProviderStrategy();
+
     public AsyncIndexUpdate(@Nonnull String name, @Nonnull NodeStore store,
             @Nonnull IndexEditorProvider provider, boolean switchOnSync) {
         this.name = checkNotNull(name);
@@ -341,7 +344,8 @@ public class AsyncIndexUpdate implements Runnable {
             NodeBuilder builder = store.getRoot().builder();
 
             IndexUpdate indexUpdate =
-                    new IndexUpdate(provider, name, after, builder, callback);
+                    new IndexUpdate(provider, name, after, builder, callback)
+                    .withMissingProviderStrategy(missingStrategy);
             CommitFailedException exception =
                     EditorDiff.process(VisibleEditor.wrap(indexUpdate), before, after);
             if (exception != null) {
@@ -578,4 +582,24 @@ public class AsyncIndexUpdate implements Runnable {
         return name.charAt(0) == ':';
     }
 
+    static class DefaultMissingIndexProviderStrategy extends
+            MissingIndexProviderStrategy {
+
+        private final Set<String> ignore = Sets.newHashSet("disabled");
+
+        @Override
+        public void onMissingIndex(String type, NodeBuilder definition)
+                throws CommitFailedException {
+            if (ignore.contains(type)) {
+                return;
+            }
+            throw new CommitFailedException("Async", 2,
+                    "Missing index provider detected");
+        }
+    }
+
+    public boolean isFailing() {
+        return failing;
+    }
+
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java
index 47cdfd18fc..ae17c42068 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java
@@ -52,6 +52,7 @@ import org.slf4j.LoggerFactory;
 import com.google.common.base.Objects;
 
 public class IndexUpdate implements Editor {
+
     private final Logger log = LoggerFactory.getLogger(getClass());
 
     private final IndexEditorProvider provider;
@@ -86,6 +87,8 @@ public class IndexUpdate implements Editor {
      */
     private final IndexUpdateCallback updateCallback;
 
+    private MissingIndexProviderStrategy missingProvider = new MissingIndexProviderStrategy();
+
     public IndexUpdate(
             IndexEditorProvider provider, String async,
             NodeState root, NodeBuilder builder,
@@ -154,12 +157,15 @@ public class IndexUpdate implements Editor {
             NodeBuilder definition = definitions.getChildNode(name);
             if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {
                 String type = definition.getString(TYPE_PROPERTY_NAME);
+                if (type == null) {
+                    // probably not an index def
+                    continue;
+                }
                 boolean shouldReindex = shouldReindex(definition,
                         before, name);
                 Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);
                 if (editor == null) {
-                    // trigger reindexing when an indexer becomes available
-                    definition.setProperty(REINDEX_PROPERTY_NAME, true);
+                    missingProvider.onMissingIndex(type, definition);
                 } else if (shouldReindex) {
                     if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME)
                             && definition.getString(ASYNC_PROPERTY_NAME) == null) {
@@ -272,4 +278,18 @@ public class IndexUpdate implements Editor {
         return reindex.keySet();
     }
 
+    public static class MissingIndexProviderStrategy {
+        public void onMissingIndex(String type, NodeBuilder definition)
+                throws CommitFailedException {
+            // trigger reindexing when an indexer becomes available
+            definition.setProperty(REINDEX_PROPERTY_NAME, true);
+        }
+    }
+
+    public IndexUpdate withMissingProviderStrategy(
+            MissingIndexProviderStrategy missingProvider) {
+        this.missingProvider = missingProvider;
+        return this;
+    }
+
 }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java
index 0558ac1759..1e2391bb98 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/AsyncIndexUpdateTest.java
@@ -20,6 +20,7 @@ import static com.google.common.collect.Sets.newHashSet;
 import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;
 import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_CONTENT_NODE_NAME;
 import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_DEFINITIONS_NAME;
+import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_PROPERTY_NAME;
 import static org.apache.jackrabbit.oak.plugins.index.IndexUtils.createIndexDefinition;
 import static org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider.TYPE;
 import static org.junit.Assert.assertEquals;
@@ -27,6 +28,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
@@ -36,12 +38,9 @@ import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-
 import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
+import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider;
 import org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexLookup;
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;
@@ -57,6 +56,10 @@ import org.apache.jackrabbit.oak.spi.state.NodeState;
 import org.apache.jackrabbit.oak.spi.state.NodeStore;
 import org.junit.Test;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+
 public class AsyncIndexUpdateTest {
 
     // TODO test index config deletes
@@ -553,6 +556,61 @@ public class AsyncIndexUpdateTest {
                 store.listCheckpoints().size() == 0);
     }
 
+    /**
+     * OAK-2203 Test reindex behavior on an async index when the index provider is missing
+     * for a given type
+     */
+    @Test
+    public void testReindexMissingProvider() throws Exception {
+        MemoryNodeStore store = new MemoryNodeStore();
+        IndexEditorProvider provider = new PropertyIndexEditorProvider();
+
+        NodeBuilder builder = store.getRoot().builder();
+        createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME),
+                "rootIndex", true, false, ImmutableSet.of("foo"), null)
+                .setProperty(ASYNC_PROPERTY_NAME, "asyncMissing");
+
+        builder.child("testRoot").setProperty("foo", "abc");
+
+        // merge it back in
+        store.merge(builder, EmptyHook.INSTANCE, CommitInfo.EMPTY);
+
+        AsyncIndexUpdate async = new AsyncIndexUpdate("asyncMissing", store,
+                provider);
+        //first run, creates a checkpoint and a ref to it as the last indexed state
+        async.run();
+        assertFalse(async.isFailing());
+        assertTrue("Expecting one checkpoint",
+                store.listCheckpoints().size() == 1);
+        String firstCp = store.listCheckpoints().iterator().next();
+        assertEquals(
+                firstCp,
+                store.getRoot().getChildNode(AsyncIndexUpdate.ASYNC)
+                        .getString("asyncMissing"));
+
+        // second run, simulate an index going away
+        provider = CompositeIndexEditorProvider
+                .compose(new ArrayList<IndexEditorProvider>());
+        async = new AsyncIndexUpdate("asyncMissing", store, provider);
+        async.run();
+        assertTrue(async.isFailing());
+        // don't set reindex=true but skip the update
+        PropertyState reindex = store.getRoot()
+                .getChildNode(INDEX_DEFINITIONS_NAME).getChildNode("rootIndex")
+                .getProperty(REINDEX_PROPERTY_NAME);
+        assertTrue(reindex == null || !reindex.getValue(Type.BOOLEAN));
+
+        assertTrue("Expecting one checkpoint",
+                store.listCheckpoints().size() == 1);
+        String secondCp = store.listCheckpoints().iterator().next();
+        assertTrue("Store should not create a new checkpoint",
+                secondCp.equals(firstCp));
+        assertEquals(
+                firstCp,
+                store.getRoot().getChildNode(AsyncIndexUpdate.ASYNC)
+                        .getString("asyncMissing"));
+    }
+
     private static class FaultyIndexEditorProvder implements
             IndexEditorProvider {
 
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java
index 88b478c73d..c4d8fc4d56 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdateTest.java
@@ -35,6 +35,7 @@ import static org.junit.Assert.assertTrue;
 
 import java.util.Set;
 
+import org.apache.jackrabbit.oak.api.CommitFailedException;
 import org.apache.jackrabbit.oak.api.PropertyState;
 import org.apache.jackrabbit.oak.api.Type;
 import org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider;
@@ -45,6 +46,7 @@ import org.apache.jackrabbit.oak.query.QueryEngineSettings;
 import org.apache.jackrabbit.oak.query.ast.SelectorImpl;
 import org.apache.jackrabbit.oak.query.index.FilterImpl;
 import org.apache.jackrabbit.oak.spi.commit.CommitInfo;
+import org.apache.jackrabbit.oak.spi.commit.Editor;
 import org.apache.jackrabbit.oak.spi.commit.EditorHook;
 import org.apache.jackrabbit.oak.spi.query.Filter;
 import org.apache.jackrabbit.oak.spi.query.PropertyValues;
@@ -357,6 +359,46 @@ public class IndexUpdateTest {
         "abc"));
     }
 
+    /**
+     * OAK-2203 Test reindex behavior on a sync index when the index provider is missing
+     * for a given type
+     */
+    @Test
+    public void testReindexSyncMissingProvider() throws Exception {
+        EditorHook hook = new EditorHook(new IndexUpdateProvider(
+                emptyProvider()));
+        NodeState before = builder.getNodeState();
+
+        createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME),
+                "rootIndex", true, false, ImmutableSet.of("foo"), null);
+        builder.child(INDEX_DEFINITIONS_NAME).child("azerty");
+        builder.child("testRoot").setProperty("foo", "abc");
+        NodeState after = builder.getNodeState();
+
+        NodeState indexed = hook.processCommit(before, after, CommitInfo.EMPTY);
+        NodeState rootIndex = checkPathExists(indexed, INDEX_DEFINITIONS_NAME,
+                "rootIndex");
+        PropertyState ps = rootIndex.getProperty(REINDEX_PROPERTY_NAME);
+        assertNotNull(ps);
+        assertTrue(ps.getValue(Type.BOOLEAN));
+
+        NodeState azerty = checkPathExists(indexed, INDEX_DEFINITIONS_NAME,
+                "azerty");
+        assertNull("Node should be ignored by reindexer",
+                azerty.getProperty(REINDEX_PROPERTY_NAME));
+    }
+
+    private static IndexEditorProvider emptyProvider() {
+        return new IndexEditorProvider() {
+            @Override
+            public Editor getIndexEditor(String type, NodeBuilder definition,
+                    NodeState root, IndexUpdateCallback callback)
+                    throws CommitFailedException {
+                return null;
+            }
+        };
+    }
+
     private Set<String> find(PropertyIndexLookup lookup, String name,
             String value) {
         NodeState system = root.getChildNode(JCR_SYSTEM);
