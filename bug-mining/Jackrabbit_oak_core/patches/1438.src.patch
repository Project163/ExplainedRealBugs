diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentMKResetTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentMKResetTest.java
index 208c20dd61..18321ce46b 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentMKResetTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/DocumentMKResetTest.java
@@ -16,8 +16,17 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.util.Map;
+
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
+import static org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS;
+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -121,4 +130,83 @@ public class DocumentMKResetTest extends BaseDocumentMKTest {
         assertPropExists(rev, "/foo", "p1");
         assertPropExists(rev, "/foo", "p2");
     }
+
+    @Ignore
+    @Test
+    public void resetToBaseOfBranch() {
+        addNodes(null, "/foo");
+        String b0 = mk.branch(null);
+        String b1 = addNodes(b0, "/foo/bar");
+        String b2 = mk.reset(b1, b0);
+        mk.merge(b2, null);
+        assertNodesNotExist(null, "/foo/bar");
+    }
+
+    @Ignore
+    @Test
+    public void resetRemovesCommitRootOnParent() {
+        DocumentStore store = mk.getDocumentStore();
+
+        addNodes(null, "/foo");
+        String b0 = mk.branch(null);
+        String b1 = addNodes(b0, "/foo/bar");
+
+        NodeDocument foo = store.find(NODES, getIdFromPath("/foo"));
+        assertNotNull(foo);
+        assertTrue(foo.getLocalCommitRoot().containsKey(
+                Revision.fromString(b1).asTrunkRevision()));
+
+        addNodes(null, "/foo/bar");
+
+        mk.reset(b1, b0);
+
+        // reset must also remove _commitRoot entry on parent document
+        foo = store.find(NODES, getIdFromPath("/foo"));
+        assertNotNull(foo);
+        assertFalse(foo.getLocalCommitRoot().containsKey(
+                Revision.fromString(b1).asTrunkRevision()));
+    }
+
+    @Ignore
+    @Test
+    public void resetMultipleCommits() {
+        DocumentStore store = mk.getDocumentStore();
+
+        addNodes(null, "/foo");
+        String b0 = mk.branch(null);
+        String b1 = mk.commit("", "^\"/foo/p1\":1", b0, null);
+        String b2 = mk.commit("", "^\"/foo/p2\":1", b1, null);
+        String b3 = mk.commit("", "^\"/foo/p3\":1", b2, null);
+        // will mark conflict on b2 and b3
+        mk.commit("", "^\"/foo/p2\":1^\"/foo/p3\":1", null, null);
+
+        // check collision markers
+        NodeDocument rootDoc = store.find(NODES, getIdFromPath("/"));
+        assertNotNull(rootDoc);
+        Map<Revision, String> collisions = rootDoc.getValueMap(COLLISIONS);
+        assertEquals(2, collisions.size());
+        assertTrue(collisions.containsKey(Revision.fromString(b2).asTrunkRevision()));
+        assertTrue(collisions.containsKey(Revision.fromString(b3).asTrunkRevision()));
+
+        try {
+            mk.merge(b3, null);
+            fail("merge with conflict must fail");
+        } catch (DocumentStoreException e) {
+            // expected
+        }
+        String b4 = mk.reset(b3, b1);
+        String b5 = mk.commit("", "^\"/foo/p4\":1", b4, null);
+
+        rootDoc = store.find(NODES, getIdFromPath("/"));
+        assertNotNull(rootDoc);
+        collisions = rootDoc.getValueMap(COLLISIONS);
+        assertEquals(0, collisions.size());
+
+        String rev = mk.merge(b5, null);
+
+        assertPropExists(rev, "/foo", "p1");
+        assertPropExists(rev, "/foo", "p2");
+        assertPropExists(rev, "/foo", "p3");
+        assertPropExists(rev, "/foo", "p4");
+    }
 }
