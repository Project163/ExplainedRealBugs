diff --git a/oak-core/pom.xml b/oak-core/pom.xml
index 3f53a8cbf4..61cd6af40b 100644
--- a/oak-core/pom.xml
+++ b/oak-core/pom.xml
@@ -39,6 +39,8 @@
         <configuration>
           <instructions>
             <Embed-Dependency>
+              <!-- OAK-1768 TODO: embedded as short term workaround -->
+              mapdb,
               <!-- OAK-1708 TODO: temporary workaround for embedding code for DocumentNodeStoreService-->
               commons-dbcp,commons-pool,h2,json-simple,
               <!-- OAK-1708 TODO: note these below will only embedded when build with the respective profiles from oak-parent -->
@@ -258,6 +260,13 @@
       <optional>true</optional>
     </dependency>
 
+    <!-- OAK-1768 added as short term workaround -->
+    <dependency>
+      <groupId>org.mapdb</groupId>
+      <artifactId>mapdb</artifactId>
+      <version>1.0.6</version>
+    </dependency>
+
     <!-- JCR and Jackrabbit dependencies -->
     <dependency>
       <groupId>javax.jcr</groupId>
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java
index 9068de8007..1fe443e18e 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Branch.java
@@ -20,18 +20,19 @@ import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.transform;
 
+import java.util.Map;
 import java.util.NavigableMap;
-import java.util.Set;
 import java.util.SortedSet;
 import java.util.concurrent.ConcurrentSkipListMap;
 
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 
+import org.apache.jackrabbit.oak.plugins.document.util.MapFactory;
+
 import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 
 /**
  * Contains commit information about a branch and its base revision.
@@ -48,6 +49,8 @@ class Branch {
      */
     private final Revision base;
 
+    private MapFactory mapFactory;
+
     /**
      * Create a new branch instance with an initial set of commits and a given
      * base revision.
@@ -223,10 +226,26 @@ class Branch {
         return checkNotNull(rev).equals(commits.lastKey());
     }
 
+    /**
+     * Releases resources held by this branch.
+     */
+    public void dispose() {
+        if (mapFactory != null) {
+            mapFactory.dispose();
+        }
+    }
+
+    private MapFactory getMapFactory() {
+        if (mapFactory == null) {
+            mapFactory = MapFactory.createFactory();
+        }
+        return mapFactory;
+    }
+
     /**
      * Information about a commit within a branch.
      */
-    abstract static class BranchCommit implements LastRevTracker {
+    abstract class BranchCommit implements LastRevTracker {
 
         protected final Revision base;
         protected final Revision commit;
@@ -250,40 +269,50 @@ class Branch {
     /**
      * Implements a regular branch commit.
      */
-    private static class BranchCommitImpl extends BranchCommit {
+    private class BranchCommitImpl extends BranchCommit {
 
-        private final Set<String> modifications = Sets.newHashSet();
+        private Map<String, Revision> modifications;
 
         BranchCommitImpl(Revision base, Revision commit) {
             super(base, commit);
+            if (mapFactory == null) {
+                modifications = Maps.newConcurrentMap();
+            } else {
+                modifications = mapFactory.create();
+            }
         }
 
         @Override
         void applyTo(UnsavedModifications trunk, Revision commit) {
-            for (String p : modifications) {
+            for (String p : modifications.keySet()) {
                 trunk.put(p, commit);
             }
         }
 
         @Override
         boolean isModified(String path) { // TODO: rather pass NodeDocument?
-            return modifications.contains(path);
+            return modifications.containsKey(path);
         }
 
         @Override
         Iterable<String> getModifiedPaths() {
-            return modifications;
+            return modifications.keySet();
         }
 
         //------------------< LastRevTracker >----------------------------------
 
         @Override
         public void track(String path) {
-            modifications.add(path);
+            if (mapFactory == null && modifications.size() >= 1000) {
+                Map<String, Revision> tmp = getMapFactory().create();
+                tmp.putAll(modifications);
+                modifications = tmp;
+            }
+            modifications.put(path, commit);
         }
     }
 
-    static class RebaseCommit extends BranchCommit {
+    class RebaseCommit extends BranchCommit {
 
         private final NavigableMap<Revision, BranchCommit> previous;
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
index 51542f74e4..2828f36f44 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
@@ -19,7 +19,6 @@ package org.apache.jackrabbit.oak.plugins.document;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.apache.jackrabbit.oak.api.CommitFailedException.MERGE;
-import static org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
 import static org.apache.jackrabbit.oak.plugins.document.DocumentMK.FAST_DIFF;
 import static org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;
@@ -74,6 +73,7 @@ import org.apache.jackrabbit.oak.cache.CacheStats;
 import org.apache.jackrabbit.oak.cache.CacheValue;
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.kernel.BlobSerializer;
+import org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;
 import org.apache.jackrabbit.oak.plugins.document.util.LoggingDocumentStoreWrapper;
 import org.apache.jackrabbit.oak.plugins.document.util.StringValue;
 import org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper;
@@ -448,6 +448,8 @@ public final class DocumentNodeStore
                 clusterNodeInfo.dispose();
             }
             store.dispose();
+            unsavedLastRevisions.close();
+
             LOG.info("Disposed DocumentNodeStore with clusterNodeId: {}", clusterId);
 
             if (blobStore instanceof Closeable) {
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java
index 1ae370cd5d..ad9ab09c79 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/LastRevRecoveryAgent.java
@@ -23,20 +23,20 @@ import static com.google.common.collect.ImmutableList.of;
 import static com.google.common.collect.Iterables.filter;
 import static com.google.common.collect.Iterables.mergeSorted;
 
+import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.concurrent.locks.ReentrantLock;
 
 import javax.annotation.CheckForNull;
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
+import com.google.common.io.Closer;
 
 import org.apache.jackrabbit.oak.commons.PathUtils;
 import org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore;
 import org.apache.jackrabbit.oak.plugins.document.mongo.MongoMissingLastRevSeeker;
-import org.apache.jackrabbit.oak.plugins.document.util.MapFactory;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -136,85 +136,97 @@ public class LastRevRecoveryAgent {
      */
     public int recover(Iterator<NodeDocument> suspects,
                        int clusterId, boolean dryRun) {
-        UnsavedModifications unsaved = new UnsavedModifications();
-        UnsavedModifications unsavedParents = new UnsavedModifications();
-
-        //Map of known last rev of checked paths
-        Map<String, Revision> knownLastRevs = MapFactory.getInstance().create();
-
-        long count = 0;
-        while (suspects.hasNext()) {
-            NodeDocument doc = suspects.next();
-            count++;
-            if (count % 100000 == 0) {
-                log.info("Scanned {} suspects so far...", count);
-            }
+        Closer closer = Closer.create();
+        try {
+            UnsavedModifications unsaved = new UnsavedModifications();
+            closer.register(unsaved);
+            UnsavedModifications unsavedParents = new UnsavedModifications();
+            closer.register(unsavedParents);
+
+            //Map of known last rev of checked paths
+            UnsavedModifications knownLastRevs = new UnsavedModifications();
+            closer.register(knownLastRevs);
+
+            long count = 0;
+            while (suspects.hasNext()) {
+                NodeDocument doc = suspects.next();
+                count++;
+                if (count % 100000 == 0) {
+                    log.info("Scanned {} suspects so far...", count);
+                }
 
-            Revision currentLastRev = doc.getLastRev().get(clusterId);
-            if (currentLastRev != null) {
-                knownLastRevs.put(doc.getPath(), currentLastRev);
-            }
-            Revision lostLastRev = determineMissedLastRev(doc, clusterId);
+                Revision currentLastRev = doc.getLastRev().get(clusterId);
+                if (currentLastRev != null) {
+                    knownLastRevs.put(doc.getPath(), currentLastRev);
+                }
+                Revision lostLastRev = determineMissedLastRev(doc, clusterId);
 
-            //1. Update lastRev for this doc
-            if (lostLastRev != null) {
-                unsaved.put(doc.getPath(), lostLastRev);
-            }
+                //1. Update lastRev for this doc
+                if (lostLastRev != null) {
+                    unsaved.put(doc.getPath(), lostLastRev);
+                }
 
-            Revision lastRevForParents = lostLastRev != null ? lostLastRev : currentLastRev;
-
-            //If both currentLastRev and lostLastRev are null it means
-            //that no change is done by suspect cluster on this document
-            //so nothing needs to be updated. Probably it was only changed by
-            //other cluster nodes. If this node is parent of any child node which
-            //has been modified by cluster then that node roll up would
-            //add this node path to unsaved
-
-            //2. Update lastRev for parent paths aka rollup
-            if (lastRevForParents != null) {
-                String path = doc.getPath();
-                while (true) {
-                    if (PathUtils.denotesRoot(path)) {
-                        break;
+                Revision lastRevForParents = lostLastRev != null ? lostLastRev : currentLastRev;
+
+                //If both currentLastRev and lostLastRev are null it means
+                //that no change is done by suspect cluster on this document
+                //so nothing needs to be updated. Probably it was only changed by
+                //other cluster nodes. If this node is parent of any child node which
+                //has been modified by cluster then that node roll up would
+                //add this node path to unsaved
+
+                //2. Update lastRev for parent paths aka rollup
+                if (lastRevForParents != null) {
+                    String path = doc.getPath();
+                    while (true) {
+                        if (PathUtils.denotesRoot(path)) {
+                            break;
+                        }
+                        path = PathUtils.getParentPath(path);
+                        unsavedParents.put(path, lastRevForParents);
                     }
-                    path = PathUtils.getParentPath(path);
-                    unsavedParents.put(path, lastRevForParents);
                 }
             }
-        }
 
-        for (String parentPath : unsavedParents.getPaths()) {
-            Revision calcLastRev = unsavedParents.get(parentPath);
-            Revision knownLastRev = knownLastRevs.get(parentPath);
+            for (String parentPath : unsavedParents.getPaths()) {
+                Revision calcLastRev = unsavedParents.get(parentPath);
+                Revision knownLastRev = knownLastRevs.get(parentPath);
 
-            //Copy the calcLastRev of parent only if they have changed
-            //In many case it might happen that parent have consistent lastRev
-            //This check ensures that unnecessary updates are not made
-            if (knownLastRev == null
-                    || calcLastRev.compareRevisionTime(knownLastRev) > 0) {
-                unsaved.put(parentPath, calcLastRev);
+                //Copy the calcLastRev of parent only if they have changed
+                //In many case it might happen that parent have consistent lastRev
+                //This check ensures that unnecessary updates are not made
+                if (knownLastRev == null
+                        || calcLastRev.compareRevisionTime(knownLastRev) > 0) {
+                    unsaved.put(parentPath, calcLastRev);
+                }
             }
-        }
 
-        //Note the size before persist as persist operation
-        //would empty the internal state
-        int size = unsaved.getPaths().size();
-        String updates = unsaved.toString();
+            //Note the size before persist as persist operation
+            //would empty the internal state
+            int size = unsaved.getPaths().size();
+            String updates = unsaved.toString();
 
-        if (dryRun) {
-            log.info("Dry run of lastRev recovery identified [{}] documents for " +
-                    "cluster node [{}]: {}", size, clusterId, updates);
-        } else {
-            //UnsavedModifications is designed to be used in concurrent
-            //access mode. For recovery case there is no concurrent access
-            //involve so just pass a new lock instance
-            unsaved.persist(nodeStore, new ReentrantLock());
+            if (dryRun) {
+                log.info("Dry run of lastRev recovery identified [{}] documents for " +
+                        "cluster node [{}]: {}", size, clusterId, updates);
+            } else {
+                //UnsavedModifications is designed to be used in concurrent
+                //access mode. For recovery case there is no concurrent access
+                //involve so just pass a new lock instance
+                unsaved.persist(nodeStore, new ReentrantLock());
 
-            log.info("Updated lastRev of [{}] documents while performing lastRev recovery for " +
-                    "cluster node [{}]: {}", size, clusterId, updates);
-        }
+                log.info("Updated lastRev of [{}] documents while performing lastRev recovery for " +
+                        "cluster node [{}]: {}", size, clusterId, updates);
+            }
 
-        return size;
+            return size;
+        } finally {
+            try {
+                closer.close();
+            } catch (IOException e) {
+                log.warn("Error closing UnsavedModifications", e);
+            }
+        }
     }
 
     /**
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/PathComparator.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/PathComparator.java
index 3aaad4447b..09988d0235 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/PathComparator.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/PathComparator.java
@@ -18,6 +18,7 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.io.Serializable;
 import java.util.Comparator;
 
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
@@ -26,9 +27,11 @@ import org.apache.jackrabbit.oak.plugins.document.util.Utils;
  * Implements a comparator, which sorts path string according to 1) their
  * depth (highest first) and 2) the path string itself.
  */
-class PathComparator implements Comparator<String> {
+public class PathComparator implements Comparator<String>, Serializable {
 
-    static final Comparator<String> INSTANCE = new PathComparator();
+    private static final long serialVersionUID = -1523171906146067782L;
+
+    public static final Comparator<String> INSTANCE = new PathComparator();
 
     private PathComparator() {
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java
index 27ee963eb2..69ed7767bb 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnmergedBranches.java
@@ -16,10 +16,6 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;
-
 import java.util.Comparator;
 import java.util.List;
 import java.util.SortedSet;
@@ -30,10 +26,14 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
 
+import org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+
 /**
  * <code>UnmergedBranches</code> contains all un-merged branches of a DocumentMK
  * instance.
@@ -144,5 +144,6 @@ class UnmergedBranches {
      */
     void remove(Branch b) {
         branches.remove(b);
+        b.dispose();
     }
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java
index 6c8dff708c..444620ea1a 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UnsavedModifications.java
@@ -16,6 +16,7 @@
  */
 package org.apache.jackrabbit.oak.plugins.document;
 
+import java.io.Closeable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -33,7 +34,9 @@ import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
 import com.google.common.collect.Maps;
+import com.google.common.collect.PeekingIterator;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
@@ -42,14 +45,25 @@ import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
  * Keeps track of when nodes where last modified. To be persisted later by
  * a background thread.
  */
-class UnsavedModifications {
+class UnsavedModifications implements Closeable {
+
+    /**
+     * Keep at most this number of entries in memory when modifications are
+     * persisted, otherwise use the MapFactory potentially backed by MapDB.
+     */
+    static final int IN_MEMORY_SIZE_LIMIT = 100000;
 
     /**
      * The maximum number of document to update at once in a multi update.
      */
     static final int BACKGROUND_MULTI_UPDATE_LIMIT = 10000;
 
-    private final ConcurrentMap<String, Revision> map = MapFactory.getInstance().create();
+    /**
+     * The map factory for this instance.
+     */
+    private final MapFactory mapFactory = MapFactory.createFactory();
+
+    private final ConcurrentMap<String, Revision> map = mapFactory.create();
 
     /**
      * Puts a revision for the given path. The revision for the given path is
@@ -132,7 +146,7 @@ class UnsavedModifications {
      */
     public void persist(@Nonnull DocumentNodeStore store,
                         @Nonnull Lock lock) {
-        if (map.isEmpty()) {
+        if (map.size() == 0) {
             return;
         }
         checkNotNull(store);
@@ -140,63 +154,79 @@ class UnsavedModifications {
 
         // get a copy of the map while holding the lock
         lock.lock();
+        MapFactory tmpFactory = null;
         Map<String, Revision> pending;
         try {
-            pending = Maps.newHashMap(map);
+            if (map.size() > IN_MEMORY_SIZE_LIMIT) {
+                tmpFactory = MapFactory.createFactory();
+                pending = tmpFactory.create(PathComparator.INSTANCE);
+            } else {
+                pending = Maps.newTreeMap(PathComparator.INSTANCE);
+            }
+            pending.putAll(map);
         } finally {
             lock.unlock();
         }
-        ArrayList<String> paths = new ArrayList<String>(pending.keySet());
-        // sort by depth (high depth first), then path
-        Collections.sort(paths, PathComparator.INSTANCE);
-
-        UpdateOp updateOp = null;
-        Revision lastRev = null;
-        ArrayList<String> pathList = new ArrayList<String>();
-        for (int i = 0; i < paths.size();) {
-            String p = paths.get(i);
-            Revision r = pending.get(p);
-            if (r == null) {
-                i++;
-                continue;
-            }
-            int size = pathList.size();
-            if (updateOp == null) {
-                // create UpdateOp
-                Commit commit = new Commit(store, null, r);
-                updateOp = commit.getUpdateOperationForNode(p);
-                NodeDocument.setLastRev(updateOp, r);
-                lastRev = r;
-                pathList.add(p);
-                i++;
-            } else if (r.equals(lastRev)) {
-                // use multi update when possible
-                pathList.add(p);
-                i++;
-            }
-            // call update if any of the following is true:
-            // - this is the second-to-last or last path (update last path, the
-            //   root document, individually)
-            // - revision is not equal to last revision (size of ids didn't change)
-            // - the update limit is reached
-            if (i + 2 > paths.size()
-                    || size == pathList.size()
-                    || pathList.size() >= BACKGROUND_MULTI_UPDATE_LIMIT) {
-                List<String> ids = new ArrayList<String>();
-                for (String path : pathList) {
-                    ids.add(Utils.getIdFromPath(path));
+        try {
+            UpdateOp updateOp = null;
+            Revision lastRev = null;
+            PeekingIterator<String> paths = Iterators.peekingIterator(
+                    pending.keySet().iterator());
+            int i = 0;
+            ArrayList<String> pathList = new ArrayList<String>();
+            while (paths.hasNext()) {
+                String p = paths.peek();
+                Revision r = pending.get(p);
+
+                int size = pathList.size();
+                if (updateOp == null) {
+                    // create UpdateOp
+                    Commit commit = new Commit(store, null, r);
+                    updateOp = commit.getUpdateOperationForNode(p);
+                    NodeDocument.setLastRev(updateOp, r);
+                    lastRev = r;
+                    pathList.add(p);
+                    paths.next();
+                    i++;
+                } else if (r.equals(lastRev)) {
+                    // use multi update when possible
+                    pathList.add(p);
+                    paths.next();
+                    i++;
                 }
-                store.getDocumentStore().update(NODES, ids, updateOp);
-                for (String path : pathList) {
-                    map.remove(path, lastRev);
+                // call update if any of the following is true:
+                // - this is the second-to-last or last path (update last path, the
+                //   root document, individually)
+                // - revision is not equal to last revision (size of ids didn't change)
+                // - the update limit is reached
+                if (i + 2 > pending.size()
+                        || size == pathList.size()
+                        || pathList.size() >= BACKGROUND_MULTI_UPDATE_LIMIT) {
+                    List<String> ids = new ArrayList<String>();
+                    for (String path : pathList) {
+                        ids.add(Utils.getIdFromPath(path));
+                    }
+                    store.getDocumentStore().update(NODES, ids, updateOp);
+                    for (String path : pathList) {
+                        map.remove(path, lastRev);
+                    }
+                    pathList.clear();
+                    updateOp = null;
+                    lastRev = null;
                 }
-                pathList.clear();
-                updateOp = null;
-                lastRev = null;
+            }
+        } finally {
+            if (tmpFactory != null) {
+                tmpFactory.dispose();
             }
         }
     }
 
+    @Override
+    public void close() {
+        mapFactory.dispose();
+    }
+
     @Override
     public String toString() {
         return map.toString();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapDBMapFactory.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapDBMapFactory.java
new file mode 100644
index 0000000000..138da9faa8
--- /dev/null
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapDBMapFactory.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document.util;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Comparator;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.jackrabbit.oak.plugins.document.Revision;
+import org.mapdb.BTreeKeySerializer;
+import org.mapdb.BTreeMap;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
+import org.mapdb.Serializer;
+
+/**
+ * A MapFactory backed by MapDB, which stores the map in a temporary file.
+ */
+public class MapDBMapFactory extends MapFactory {
+
+    private final AtomicInteger counter = new AtomicInteger();
+    private final DB db;
+
+    public MapDBMapFactory() {
+        this.db = DBMaker.newTempFileDB()
+                .deleteFilesAfterClose()
+                .closeOnJvmShutdown()
+                .transactionDisable()
+                .asyncWriteEnable()
+                .make();
+    }
+
+    @Override
+    public BTreeMap<String, Revision> create() {
+        return db.createTreeMap(String.valueOf(counter.incrementAndGet()))
+                .valueSerializer(new RevisionSerializer())
+                .counterEnable()
+                .makeStringMap();
+    }
+
+    @Override
+    public synchronized BTreeMap<String, Revision> create(
+            Comparator<String> comparator) {
+        return db.createTreeMap(String.valueOf(counter.incrementAndGet()))
+                .valueSerializer(new RevisionSerializer())
+                .keySerializer(new CustomKeySerializer(comparator))
+                .counterEnable()
+                .make();
+    }
+
+    @Override
+    public void dispose() {
+        db.close();
+    }
+
+    private static class CustomKeySerializer extends BTreeKeySerializer<String>
+            implements Serializable {
+
+        private static final long serialVersionUID = -95963379229842881L;
+
+        private final Comparator<String> comparator;
+
+        CustomKeySerializer(Comparator<String> comparator) {
+            this.comparator = comparator;
+        }
+
+        @Override
+        public void serialize(DataOutput out, int start, int end, Object[] keys)
+                throws IOException {
+            BTreeKeySerializer.STRING.serialize(out, start, end, keys);
+        }
+
+        @Override
+        public Object[] deserialize(DataInput in, int start, int end, int size)
+                throws IOException {
+            return BTreeKeySerializer.STRING.deserialize(in, start, end, size);
+        }
+
+        @Override
+        public Comparator<String> getComparator() {
+            return comparator;
+        }
+    }
+
+    private static class RevisionSerializer implements Serializer<Revision>,
+            Serializable {
+        private static final long serialVersionUID = 8648365575103098316L;
+        private int size = 8 + 4 + 4 + 1;
+        public void serialize(DataOutput o, Revision r) throws IOException {
+            o.writeLong(r.getTimestamp());
+            o.writeInt(r.getCounter());
+            o.writeInt(r.getClusterId());
+            o.writeBoolean(r.isBranch());
+
+        }
+
+        public Revision deserialize(DataInput i, int available) throws IOException {
+            return new Revision(
+                    i.readLong(), //timestamp
+                    i.readInt(),  //counter
+                    i.readInt(),  //clusterId
+                    i.readBoolean()); //branch
+        }
+
+        public int fixedSize() {
+            return size;
+        }
+    }
+}
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapFactory.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapFactory.java
index bdae982297..2a3f9046b9 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapFactory.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/MapFactory.java
@@ -19,25 +19,45 @@
 
 package org.apache.jackrabbit.oak.plugins.document.util;
 
+import java.util.Comparator;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentSkipListMap;
 
 import org.apache.jackrabbit.oak.plugins.document.Revision;
 
 /**
- * Experimental extension point for OAK-1772 to try out alternative approaches for persisting in memory state
- * Not part of API
+ * Experimental extension point for OAK-1772 to try out alternative approaches
+ * for persisting in memory state. Not part of API.
  */
 public abstract class MapFactory {
+
+    private static final boolean USE_MEMORY_MAP_FACTORY
+            = Boolean.getBoolean("oak.useMemoryMapFactory");
+
     private static MapFactory DEFAULT = new MapFactory() {
         @Override
         public ConcurrentMap<String, Revision> create() {
             return new ConcurrentHashMap<String, Revision>();
         }
+
+        @Override
+        public ConcurrentMap<String, Revision> create(Comparator<String> comparator) {
+            return new ConcurrentSkipListMap<String, Revision>(comparator);
+        }
+
+        @Override
+        public void dispose() {
+            // nothing to do
+        }
     };
 
     public abstract ConcurrentMap<String, Revision> create();
 
+    public abstract ConcurrentMap<String, Revision> create(Comparator<String> comparator);
+
+    public abstract void dispose();
+
     private static MapFactory instance = DEFAULT;
 
     public static MapFactory getInstance(){
@@ -47,4 +67,12 @@ public abstract class MapFactory {
     public static void setInstance(MapFactory instance) {
         MapFactory.instance = instance;
     }
+
+    public static MapFactory createFactory() {
+        if (USE_MEMORY_MAP_FACTORY) {
+            return MapFactory.getInstance();
+        } else {
+            return new MapDBMapFactory();
+        }
+    }
 }
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/util/MapDBMapFactoryTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/util/MapDBMapFactoryTest.java
new file mode 100644
index 0000000000..500bb4daf6
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/util/MapDBMapFactoryTest.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document.util;
+
+import java.util.List;
+import java.util.Map;
+
+import org.apache.jackrabbit.oak.plugins.document.PathComparator;
+import org.apache.jackrabbit.oak.plugins.document.Revision;
+import org.junit.Test;
+
+import com.google.common.collect.Lists;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * <code>MapDBMapFactoryTest</code>...
+ */
+public class MapDBMapFactoryTest {
+
+    @Test
+    public void comparator() {
+        MapFactory factory = new MapDBMapFactory();
+
+        Revision r = new Revision(1, 0, 1);
+        Map<String, Revision> map = factory.create(PathComparator.INSTANCE);
+
+        map.put("/", r);
+        map.put("/foo", r);
+        map.put("/foo/bar", r);
+        map.put("/foo/baz", r);
+        map.put("/foo/bar/qux", r);
+        map.put("/bar/baz", r);
+        map.put("/qux", r);
+
+        List<String> expected = Lists.newArrayList(
+                "/foo/bar/qux",
+                "/bar/baz",
+                "/foo/bar",
+                "/foo/baz",
+                "/foo",
+                "/qux",
+                "/");
+        List<String> actual = Lists.newArrayList(map.keySet());
+
+        assertEquals(expected, actual);
+
+        factory.dispose();
+    }
+}
