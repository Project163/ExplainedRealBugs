diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
index 0196878119..b29165cf67 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/UpdateOp.java
@@ -49,7 +49,7 @@ public final class UpdateOp {
      * @param id the primary key
      * @param isNew whether this is a new document
      */
-    UpdateOp(String id, boolean isNew) {
+    public UpdateOp(String id, boolean isNew) {
         this(id, isNew, false, new HashMap<Key, Operation>(), null);
     }
 
@@ -176,7 +176,7 @@ public final class UpdateOp {
      * @param property the property name
      * @param value the value
      */
-    void set(String property, Object value) {
+    public void set(String property, Object value) {
         Operation op = new Operation(Operation.Type.SET, value);
         changes.put(new Key(property, null), op);
     }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
index 91f663005c..50112cc6ce 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoDocumentStore.java
@@ -1135,6 +1135,10 @@ public class MongoDocumentStore implements DocumentStore {
         return nodesCache.getIfPresent(new StringValue(id));
     }
 
+    protected Cache<CacheValue, NodeDocument> getNodeDocumentCache() {
+        return nodesCache;
+    }
+
     private static void log(String message, Object... args) {
         if (LOG.isDebugEnabled()) {
             String argList = Arrays.toString(args);
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheConsistencyIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheConsistencyIT.java
new file mode 100644
index 0000000000..514649319b
--- /dev/null
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/mongo/CacheConsistencyIT.java
@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.oak.plugins.document.mongo;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import com.google.common.cache.Cache;
+import com.google.common.collect.Lists;
+import com.mongodb.DB;
+
+import org.apache.jackrabbit.oak.cache.CacheValue;
+import org.apache.jackrabbit.oak.plugins.document.AbstractMongoConnectionTest;
+import org.apache.jackrabbit.oak.plugins.document.DocumentMK;
+import org.apache.jackrabbit.oak.plugins.document.MongoUtils;
+import org.apache.jackrabbit.oak.plugins.document.NodeDocument;
+import org.apache.jackrabbit.oak.plugins.document.UpdateOp;
+import org.apache.jackrabbit.oak.plugins.document.util.StringValue;
+import org.apache.jackrabbit.oak.plugins.document.util.Utils;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.apache.jackrabbit.oak.plugins.document.Collection.NODES;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test for OAK-3103
+ */
+@Ignore
+public class CacheConsistencyIT extends AbstractMongoConnectionTest {
+
+    private MongoDocumentStore store;
+
+    @Before
+    @Override
+    public void setUpConnection() throws Exception {
+        mongoConnection = MongoUtils.getConnection();
+        DB db = mongoConnection.getDB();
+        MongoUtils.dropCollections(db);
+        DocumentMK.Builder builder = new DocumentMK.Builder()
+                .clock(getTestClock()).setAsyncDelay(0);
+        store = new MongoDocumentStore(db, builder);
+        mk = builder.setDocumentStore(store).open();
+    }
+
+    @Test
+    public void evictWhileUpdateLoop() throws Throwable {
+        for (int i = 0; i < 10; i++) {
+            runTest();
+            tearDownConnection();
+            setUpConnection();
+        }
+    }
+
+    private void runTest() throws Throwable {
+        addNodes(null, "/test", "/test/foo");
+
+        final List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<Throwable>());
+        Thread t1 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                String id = Utils.getIdFromPath("/test/foo");
+                List<String> ids = Lists.newArrayList();
+                ids.add(id);
+                long v = 0;
+                while (exceptions.isEmpty()) {
+                    try {
+                        UpdateOp op = new UpdateOp(ids.get(0), false);
+                        op.set("p", ++v);
+                        store.update(NODES, ids, op);
+                        NodeDocument doc = store.find(NODES, id);
+                        Object p = doc.get("p");
+                        assertEquals(v, ((Long) p).longValue());
+                    } catch (Throwable e) {
+                        exceptions.add(e);
+                    }
+                }
+            }
+        }, "update");
+        t1.start();
+
+        Thread t2 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                String id = Utils.getIdFromPath("/test/foo");
+                long v = 0;
+                while (exceptions.isEmpty()) {
+                    try {
+                        UpdateOp op = new UpdateOp(id, false);
+                        op.set("q", ++v);
+                        NodeDocument old = store.findAndUpdate(NODES, op);
+                        Object q = old.get("q");
+                        if (q != null) {
+                            assertEquals(v - 1, ((Long) q).longValue());
+                        }
+                    } catch (Throwable e) {
+                        exceptions.add(e);
+                    }
+                }
+            }
+        }, "findAndUpdate");
+        t2.start();
+
+        Thread t3 = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                String id = Utils.getIdFromPath("/test/foo");
+                long p = 0;
+                long q = 0;
+                while (exceptions.isEmpty()) {
+                    try {
+                        NodeDocument doc = store.find(NODES, id);
+                        if (doc != null) {
+                            Object value = doc.get("p");
+                            if (value != null) {
+                                assertTrue((Long) value >= p);
+                                p = (Long) value;
+                            }
+                            value = doc.get("q");
+                            if (value != null) {
+                                assertTrue("previous: " + q + ", now: " + value, (Long) value >= q);
+                                q = (Long) value;
+                            }
+                        }
+                    } catch (Throwable e) {
+                        exceptions.add(e);
+                    }
+                }
+            }
+        }, "reader");
+        t3.start();
+
+        Cache<CacheValue, NodeDocument> cache = store.getNodeDocumentCache();
+
+        // run for at most five seconds
+        long end = System.currentTimeMillis() + 1000;
+        String id = Utils.getIdFromPath("/test/foo");
+        CacheValue key = new StringValue(id);
+        while (t1.isAlive() && t2.isAlive() && t3.isAlive()
+                && System.currentTimeMillis() < end) {
+            if (cache.getIfPresent(key) != null) {
+                Thread.sleep(0, (int) (Math.random() * 100));
+                // simulate eviction
+                cache.invalidate(key);
+            }
+        }
+        for (Throwable e : exceptions) {
+            throw e;
+        }
+        exceptions.add(new Exception("end"));
+        t1.join();
+        t2.join();
+        t3.join();
+    }
+
+}
