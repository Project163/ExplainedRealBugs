diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexEditor.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexEditor.java
index 768b8b8c27..2a217245ad 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexEditor.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexEditor.java
@@ -29,6 +29,7 @@ import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.DECLARING_N
 import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_CONTENT_NODE_NAME;
 import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.PROPERTY_NAMES;
 import static org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexUtil.encode;
+import static org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.EMPTY_NODE;
 
 import java.util.Collections;
 import java.util.Iterator;
@@ -44,6 +45,7 @@ import org.apache.jackrabbit.oak.plugins.index.IndexConstants;
 import org.apache.jackrabbit.oak.plugins.index.IndexEditor;
 import org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback;
 import org.apache.jackrabbit.oak.plugins.index.property.strategy.IndexStoreStrategy;
+import org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState;
 import org.apache.jackrabbit.oak.plugins.memory.PropertyValues;
 import org.apache.jackrabbit.oak.plugins.nodetype.TypePredicate;
 import org.apache.jackrabbit.oak.spi.commit.Editor;
@@ -291,10 +293,17 @@ class PropertyIndexEditor implements IndexEditor {
                 String properties = definition.getString(PROPERTY_NAMES);
                 boolean uniqueIndex = keysToCheckForUniqueness != null;
                 for (IndexStoreStrategy strategy : getStrategies(uniqueIndex)) {
-                    Supplier<NodeBuilder> index = memoize(() -> definition.child(strategy.getIndexNodeName()));
+                    String indexNodeName = strategy.getIndexNodeName();
+                    Supplier<NodeBuilder> index = memoize(() -> definition.child(indexNodeName));
                     if (uniqueIndex) {
+                        Supplier<NodeBuilder> roBuilder;
+                        if (definition.hasChildNode(indexNodeName)) {
+                            roBuilder = index;
+                        } else {
+                            roBuilder = () -> EMPTY_NODE.builder();
+                        }
                         keysToCheckForUniqueness.addAll(getExistingKeys(
-                                afterKeys, index, strategy));
+                                afterKeys, roBuilder, strategy));
                     }
                     strategy.update(index, getPath(), properties, definition,
                             beforeKeys, afterKeys);
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
index f6b9104cee..5a5ac0b8d8 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexTest.java
@@ -993,6 +993,47 @@ public class PropertyIndexTest {
         assertTrue(getNode(indexed, pathInIndex(defMount, "/oak:index/foo", "/content", "abc")).exists());
     }
 
+    @Test
+    public void mountWithCommitInWritableMountForUniqueIndex() throws Exception{
+        NodeState root = INITIAL_CONTENT;
+
+        // Add index definition
+        NodeBuilder builder = root.builder();
+        NodeBuilder index = createIndexDefinition(builder.child(INDEX_DEFINITIONS_NAME), "foo",
+                true, true, ImmutableSet.of("foo"), null);
+        index.setProperty("entryCount", -1);
+        NodeState before = builder.getNodeState();
+
+        // Add some content and process it through the property index hook
+        builder.child("content").setProperty("foo", "abc");
+        NodeState after = builder.getNodeState();
+
+        MountInfoProvider mip = Mounts.newBuilder()
+                .readOnlyMount("foo",  "/readOnly")
+                .build();
+
+        CompositeHook hook = new CompositeHook(
+                new EditorHook(new IndexUpdateProvider(new PropertyIndexEditorProvider().with(mip))),
+                new EditorHook(new ValidatorProvider(){
+                    protected Validator getRootValidator(NodeState before, NodeState after, CommitInfo info) {
+                        return new PrivateStoreValidator("/", mip);
+                    }
+                })
+        );
+
+        NodeState indexed = hook.processCommit(before, after, CommitInfo.EMPTY);
+
+        Mount defMount = mip.getDefaultMount();
+        NodeState indexedState = getNode(indexed, "/oak:index/foo/" + getNodeForMount(defMount) + "/abc");
+        assertTrue(indexedState.exists());
+        Iterable<String> values = indexedState.getStrings("entry");
+        assertEquals(1, Iterables.size(values));
+        assertEquals("/content", Iterables.getFirst(values, null));
+
+        Mount roMount = mip.getMountByName("foo");
+        assertFalse(getNode(indexed, "/oak:index/foo/" + getNodeForMount(roMount)).exists());
+    }
+
     @Test(expected = CommitFailedException.class)
     public void mountAndUniqueIndexes() throws Exception {
         NodeState root = INITIAL_CONTENT;
