diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java
index 01919947e4..f5e6a1c574 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStore.java
@@ -35,6 +35,7 @@ import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
 import javax.annotation.CheckForNull;
@@ -106,6 +107,13 @@ public class SegmentNodeStore implements NodeStore, Observable {
         this.maximumBackoff = max;
     }
 
+    /**
+     * Execute the passed callable with trying to acquire this store's commit lock.
+     * @param c  callable to execute
+     * @return  {@code false} if the store's commit lock cannot be acquired, the result
+     *          of {@code c.call()} otherwise.
+     * @throws Exception
+     */
     boolean locked(Callable<Boolean> c) throws Exception {
         if (commitSemaphore.tryAcquire()) {
             try {
@@ -117,6 +125,26 @@ public class SegmentNodeStore implements NodeStore, Observable {
         return false;
     }
 
+    /**
+     * Execute the passed callable with trying to acquire this store's commit lock.
+     * @param timeout the maximum time to wait for the store's commit lock
+     * @param unit the time unit of the {@code timeout} argument
+     * @param c  callable to execute
+     * @return  {@code false} if the store's commit lock cannot be acquired, the result
+     *          of {@code c.call()} otherwise.
+     * @throws Exception
+     */
+    boolean locked(Callable<Boolean> c, long timeout, TimeUnit unit) throws Exception {
+        if (commitSemaphore.tryAcquire(timeout, unit)) {
+            try {
+                return c.call();
+            } finally {
+                commitSemaphore.release();
+            }
+        }
+        return false;
+    }
+
     /**
      * Refreshes the head state. Should only be called while holding a
      * permit from the {@link #commitSemaphore}.
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStoreService.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStoreService.java
index 0bcdd87ed8..52824b1f40 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStoreService.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/SegmentNodeStoreService.java
@@ -18,12 +18,16 @@ package org.apache.jackrabbit.oak.plugins.segment;
 
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Collections.emptyMap;
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.apache.jackrabbit.oak.commons.PropertiesUtil.toBoolean;
+import static org.apache.jackrabbit.oak.commons.PropertiesUtil.toInteger;
 import static org.apache.jackrabbit.oak.commons.PropertiesUtil.toLong;
 import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.CLEANUP_DEFAULT;
 import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.CLONE_BINARIES_DEFAULT;
+import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.FORCE_AFTER_FAIL_DEFAULT;
 import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.MEMORY_THRESHOLD_DEFAULT;
 import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.PAUSE_DEFAULT;
+import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.RETRY_COUNT_DEFAULT;
 import static org.apache.jackrabbit.oak.plugins.segment.compaction.CompactionStrategy.TIMESTAMP_DEFAULT;
 import static org.apache.jackrabbit.oak.spi.whiteboard.WhiteboardUtils.registerMBean;
 import static org.apache.jackrabbit.oak.spi.whiteboard.WhiteboardUtils.scheduleWithFixedDelay;
@@ -172,6 +176,32 @@ public class SegmentNodeStoreService extends ProxyNodeStore
     )
     public static final String PAUSE_COMPACTION = "pauseCompaction";
 
+    @Property(
+            intValue = RETRY_COUNT_DEFAULT,
+            label = "Compaction Retries",
+            description = "Number of tries to compact concurrent commits on top of already " +
+                    "compacted commits"
+    )
+    public static final String COMPACTION_RETRY_COUNT = "compaction.retryCount";
+
+    @Property(
+            boolValue = FORCE_AFTER_FAIL_DEFAULT,
+            label = "Force Compaction",
+            description = "Whether or not to force compact concurrent commits on top of already " +
+                    " compacted commits after the maximum number of retries has been reached. " +
+                    "Force committing tries to exclusively write lock the node store."
+    )
+    public static String COMPACTION_FORCE_AFTER_FAIL = "compaction.forceAfterFail";
+
+    public static final int COMPACTION_LOCK_WAIT_TIME_DEFAULT = 60;
+    @Property(
+            intValue = COMPACTION_LOCK_WAIT_TIME_DEFAULT,
+            label = "Compaction Lock Wait Time",
+            description = "Number of seconds to wait for the lock for committing compacted changes " +
+                    "respectively to wait for the exclusive write lock for force committing."
+    )
+    public static final String COMPACTION_LOCK_WAIT_TIME = "compaction.lockWaitTime";
+
     @Property(
             boolValue = false,
             label = "Standby Mode",
@@ -285,6 +315,12 @@ public class SegmentNodeStoreService extends ProxyNodeStore
                 CLONE_BINARIES_DEFAULT);
         long cleanupTs = toLong(lookup(context, COMPACTION_CLEANUP_TIMESTAMP),
                 TIMESTAMP_DEFAULT);
+        int retryCount = toInteger(lookup(context, COMPACTION_RETRY_COUNT),
+                RETRY_COUNT_DEFAULT);
+        boolean forceCommit = toBoolean(lookup(context, COMPACTION_FORCE_AFTER_FAIL),
+                FORCE_AFTER_FAIL_DEFAULT);
+        final int lockWaitTime = toInteger(lookup(context, COMPACTION_LOCK_WAIT_TIME),
+                COMPACTION_LOCK_WAIT_TIME_DEFAULT);
         String cleanup = lookup(context, COMPACTION_CLEANUP);
         if (cleanup == null) {
             cleanup = CLEANUP_DEFAULT.toString();
@@ -302,9 +338,11 @@ public class SegmentNodeStoreService extends ProxyNodeStore
             public boolean compacted(Callable<Boolean> setHead) throws Exception {
                 // Need to guard against concurrent commits to avoid
                 // mixed segments. See OAK-2192.
-                return delegate.locked(setHead);
+                return delegate.locked(setHead, lockWaitTime, SECONDS);
             }
         };
+        compactionStrategy.setRetryCount(retryCount);
+        compactionStrategy.setForceAfterFail(forceCommit);
 
         OsgiWhiteboard whiteboard = new OsgiWhiteboard(context.getBundleContext());
         gcMonitor = new GCMonitorTracker();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategy.java
index 09a9aa2c15..e388a431cf 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategy.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategy.java
@@ -76,6 +76,16 @@ public abstract class CompactionStrategy {
 
     public static final byte MEMORY_THRESHOLD_DEFAULT = 5;
 
+    /**
+     * Default value for {@link #getRetryCount()}
+     */
+    public static final int RETRY_COUNT_DEFAULT = 5;
+
+    /**
+     * Default value for {@link #getForceAfterFail()}
+     */
+    public static final boolean FORCE_AFTER_FAIL_DEFAULT = true;
+
     /**
      * No compaction at all
      */
@@ -104,6 +114,10 @@ public abstract class CompactionStrategy {
 
     private byte memoryThreshold = MEMORY_THRESHOLD_DEFAULT;
 
+    private int retryCount = RETRY_COUNT_DEFAULT;
+
+    private boolean forceAfterFail = FORCE_AFTER_FAIL_DEFAULT;
+
     private CompactionMap compactionMap;
 
     private long compactionStart = currentTimeMillis();
@@ -191,6 +205,44 @@ public abstract class CompactionStrategy {
         this.memoryThreshold = memoryThreshold;
     }
 
+    /**
+     * Get whether or not to force compact concurrent commits on top of already
+     * compacted commits after the maximum number of retries has been reached.
+     * Force committing tries to exclusively write lock the node store.
+     * @return  {@code true} if force commit is on, {@code false} otherwise
+     */
+    public boolean getForceAfterFail() {
+        return forceAfterFail;
+    }
+
+    /**
+     * Set whether or not to force compact concurrent commits on top of already
+     * compacted commits after the maximum number of retries has been reached.
+     * Force committing tries to exclusively write lock the node store.
+     * @param forceAfterFail
+     */
+    public void setForceAfterFail(boolean forceAfterFail) {
+        this.forceAfterFail = forceAfterFail;
+    }
+
+    /**
+     * Get the number of tries to compact concurrent commits on top of already
+     * compacted commits
+     * @return  retry count
+     */
+    public int getRetryCount() {
+        return retryCount;
+    }
+
+    /**
+     * Set the number of tries to compact concurrent commits on top of already
+     * compacted commits
+     * @param retryCount
+     */
+    public void setRetryCount(int retryCount) {
+        this.retryCount = retryCount;
+    }
+
     public abstract boolean compacted(@Nonnull Callable<Boolean> setHead) throws Exception;
 
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategyMBean.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategyMBean.java
index 011ce29d36..b8d0722063 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategyMBean.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/CompactionStrategyMBean.java
@@ -43,5 +43,35 @@ public interface CompactionStrategyMBean {
 
     void setMemoryThreshold(byte memory);
 
+    /**
+     * Get whether or not to force compact concurrent commits on top of already
+     * compacted commits after the maximum number of retries has been reached.
+     * Force committing tries to exclusively write lock the node store.
+     * @return  {@code true} if force commit is on, {@code false} otherwise
+     */
+    boolean getForceAfterFail();
+
+    /**
+     * Set whether or not to force compact concurrent commits on top of already
+     * compacted commits after the maximum number of retries has been reached.
+     * Force committing tries to exclusively write lock the node store.
+     * @param forceAfterFail
+     */
+    void setForceAfterFail(boolean forceAfterFail);
+
+    /**
+     * Get the number of tries to compact concurrent commits on top of already
+     * compacted commits
+     * @return  retry count
+     */
+    int getRetryCount();
+
+    /**
+     * Set the number of tries to compact concurrent commits on top of already
+     * compacted commits
+     * @param retryCount
+     */
+    void setRetryCount(int retryCount);
+
     String getCompactionMapStats();
 }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/DefaultCompactionStrategyMBean.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/DefaultCompactionStrategyMBean.java
index 5f52f09c94..fd099ee9c7 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/DefaultCompactionStrategyMBean.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/compaction/DefaultCompactionStrategyMBean.java
@@ -84,6 +84,26 @@ public class DefaultCompactionStrategyMBean
         strategy.setMemoryThreshold(memory);
     }
 
+    @Override
+    public boolean getForceAfterFail() {
+        return strategy.getForceAfterFail();
+    }
+
+    @Override
+    public void setForceAfterFail(boolean forceAfterFail) {
+        strategy.setForceAfterFail(forceAfterFail);
+    }
+
+    @Override
+    public int getRetryCount() {
+        return strategy.getRetryCount();
+    }
+
+    @Override
+    public void setRetryCount(int retryCount) {
+        strategy.setRetryCount(retryCount);
+    }
+
     @Override
     public String getCompactionMapStats() {
         CompactionMap cm = strategy.getCompactionMap();
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java
index db1c721154..3bb95a5079 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/segment/file/FileStore.java
@@ -706,21 +706,47 @@ public class FileStore implements SegmentStore {
 
         Callable<Boolean> setHead = new SetHead(before, after, compactor);
         try {
-            while(!compactionStrategy.compacted(setHead)) {
+            int cycles = 0;
+            boolean success = false;
+            while(cycles++ < compactionStrategy.getRetryCount()
+                    && !(success = compactionStrategy.compacted(setHead))) {
                 // Some other concurrent changes have been made.
                 // Rebase (and compact) those changes on top of the
                 // compacted state before retrying to set the head.
+                gcMonitor.info("TarMK compaction detected concurrent commits while compacting. " +
+                        "Compacting these commits. Cycle {}", cycles);
                 SegmentNodeState head = getHead();
                 after = compactor.compact(after, head);
                 setHead = new SetHead(head, after, compactor);
             }
-            gcMonitor.info("TarMK compaction completed in {}ms",
-                    System.currentTimeMillis() - start);
+            if (!success) {
+                gcMonitor.info("TarMK compaction gave up compacting concurrent commits after " +
+                        "{} cycles.", cycles - 1);
+                if (compactionStrategy.getForceAfterFail()) {
+                    gcMonitor.info("TarMK compaction force compacting remaining commits");
+                    if (!forceCompact(after, compactor)) {
+                        gcMonitor.warn("TarMK compaction failed to force compact remaining commits. " +
+                                "Most likely compaction didn't get exclusive access to the store.");
+                    }
+                }
+            }
+
+            gcMonitor.info("TarMK compaction completed after {} cycles in {}ms",
+                    cycles - 1, System.currentTimeMillis() - start);
         } catch (Exception e) {
             gcMonitor.error("Error while running TarMK compaction", e);
         }
     }
 
+    private boolean forceCompact(final SegmentNodeState before, final Compactor compactor) throws Exception {
+        return compactionStrategy.compacted(new Callable<Boolean>() {
+            @Override
+            public Boolean call() throws Exception {
+                return new SetHead(getHead(), compactor.compact(before, getHead()), compactor).call();
+            }
+        });
+    }
+
     public synchronized Iterable<SegmentId> getSegmentIds() {
         List<SegmentId> ids = newArrayList();
         for (UUID uuid : writer.getUUIDs()) {
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionIT.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionIT.java
index 55c83e99bc..5713e04855 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionIT.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionIT.java
@@ -118,7 +118,7 @@ public class SegmentCompactionIT {
             false, false, CLEAN_OLD, 60000, MEMORY_THRESHOLD_DEFAULT) {
         @Override
         public boolean compacted(@Nonnull Callable<Boolean> setHead) throws Exception {
-            return nodeStore.locked(setHead);
+            return nodeStore.locked(setHead, lockWaitTime, SECONDS);
         }
     };
 
@@ -128,6 +128,7 @@ public class SegmentCompactionIT {
     private Registration mBeanRegistration;
 
     private volatile ListenableFuture<?> compactor = immediateCancelledFuture();
+    private volatile int lockWaitTime = 60;
     private volatile int maxReaders = 10;
     private volatile int maxWriters = 10;
     private volatile long maxStoreSize = 200000000000L;
@@ -623,6 +624,16 @@ public class SegmentCompactionIT {
             return valueOf(new Date(gcMonitor.getLastCompacted()));
         }
 
+        @Override
+        public void setLockWaitTime(int seconds) {
+            lockWaitTime = seconds;
+        }
+
+        @Override
+        public int getLockWaitTime() {
+            return lockWaitTime;
+        }
+
         @Override
         public void setMaxReaders(int count) {
             checkArgument(count >= 0);
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionMBean.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionMBean.java
index 951e46537a..6059188ac0 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionMBean.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/segment/SegmentCompactionMBean.java
@@ -46,6 +46,20 @@ public interface SegmentCompactionMBean {
      */
     String getLastCompaction();
 
+    /**
+     * Time to wait for the commit lock for committing the compacted head.
+     * @param seconds  number of seconds to wait
+     * @see SegmentNodeStore#locked(java.util.concurrent.Callable, long, java.util.concurrent.TimeUnit)
+     */
+    void setLockWaitTime(int seconds);
+
+    /**
+     * Time to wait for the commit lock for committing the compacted head.
+     * @return  number of seconds
+     * @see SegmentNodeStore#locked(java.util.concurrent.Callable, long, java.util.concurrent.TimeUnit)
+     */
+    int getLockWaitTime();
+
     /**
      * Set the maximal number of concurrent readers
      * @param count
