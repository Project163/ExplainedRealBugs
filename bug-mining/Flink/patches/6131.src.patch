diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
index d4f56f2b416..030e87dd938 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
@@ -75,6 +75,7 @@ import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.ExecutorUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.Reference;
+import org.apache.flink.util.ShutdownHookUtil;
 import org.apache.flink.util.StringUtils;
 import org.apache.flink.util.TaskManagerExceptionUtils;
 import org.apache.flink.util.concurrent.ExecutorThreadFactory;
@@ -84,6 +85,8 @@ import org.apache.flink.util.function.FunctionUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.concurrent.GuardedBy;
+
 import java.io.IOException;
 import java.lang.reflect.UndeclaredThrowableException;
 import java.net.InetAddress;
@@ -112,33 +115,49 @@ public class TaskManagerRunner implements FatalErrorHandler {
     private static final int SUCCESS_EXIT_CODE = 0;
     @VisibleForTesting static final int FAILURE_EXIT_CODE = 1;
 
+    private final Thread shutdownHook;
+
     private final Object lock = new Object();
 
     private final Configuration configuration;
 
-    private final DeterminismEnvelope<ResourceID> resourceId;
-
     private final Time timeout;
 
-    private final RpcService rpcService;
+    private final PluginManager pluginManager;
 
-    private final HighAvailabilityServices highAvailabilityServices;
+    private final TaskExecutorServiceFactory taskExecutorServiceFactory;
 
-    private final MetricRegistryImpl metricRegistry;
+    private final CompletableFuture<Result> terminationFuture;
 
-    private final BlobCacheService blobCacheService;
+    @GuardedBy("lock")
+    private DeterminismEnvelope<ResourceID> resourceId;
 
     /** Executor used to run future callbacks. */
-    private final ExecutorService executor;
+    @GuardedBy("lock")
+    private ExecutorService executor;
 
-    private final TaskExecutorService taskExecutorService;
+    @GuardedBy("lock")
+    private RpcSystem rpcSystem;
 
-    private final DeterminismEnvelope<WorkingDirectory> workingDirectory;
+    @GuardedBy("lock")
+    private RpcService rpcService;
 
-    private final CompletableFuture<Result> terminationFuture;
+    @GuardedBy("lock")
+    private HighAvailabilityServices highAvailabilityServices;
+
+    @GuardedBy("lock")
+    private MetricRegistryImpl metricRegistry;
+
+    @GuardedBy("lock")
+    private BlobCacheService blobCacheService;
 
-    private final RpcSystem rpcSystem;
+    @GuardedBy("lock")
+    private DeterminismEnvelope<WorkingDirectory> workingDirectory;
 
+    @GuardedBy("lock")
+    private TaskExecutorService taskExecutorService;
+
+    @GuardedBy("lock")
     private boolean shutdown;
 
     public TaskManagerRunner(
@@ -147,84 +166,100 @@ public class TaskManagerRunner implements FatalErrorHandler {
             TaskExecutorServiceFactory taskExecutorServiceFactory)
             throws Exception {
         this.configuration = checkNotNull(configuration);
-
-        rpcSystem = RpcSystem.load(configuration);
+        this.pluginManager = checkNotNull(pluginManager);
+        this.taskExecutorServiceFactory = checkNotNull(taskExecutorServiceFactory);
 
         timeout = Time.fromDuration(configuration.get(AkkaOptions.ASK_TIMEOUT_DURATION));
 
-        this.executor =
-                java.util.concurrent.Executors.newScheduledThreadPool(
-                        Hardware.getNumberCPUCores(),
-                        new ExecutorThreadFactory("taskmanager-future"));
+        this.terminationFuture = new CompletableFuture<>();
+        this.shutdown = false;
 
-        highAvailabilityServices =
-                HighAvailabilityServicesUtils.createHighAvailabilityServices(
-                        configuration,
-                        executor,
-                        AddressResolution.NO_ADDRESS_RESOLUTION,
-                        rpcSystem,
-                        this);
+        this.shutdownHook =
+                ShutdownHookUtil.addShutdownHook(
+                        () -> this.closeAsync(Result.JVM_SHUTDOWN).join(),
+                        getClass().getSimpleName(),
+                        LOG);
+    }
 
-        JMXService.startInstance(configuration.getString(JMXServerOptions.JMX_SERVER_PORT));
+    private void startTaskManagerRunnerServices() throws Exception {
+        synchronized (lock) {
+            rpcSystem = RpcSystem.load(configuration);
 
-        rpcService = createRpcService(configuration, highAvailabilityServices, rpcSystem);
+            this.executor =
+                    Executors.newScheduledThreadPool(
+                            Hardware.getNumberCPUCores(),
+                            new ExecutorThreadFactory("taskmanager-future"));
 
-        this.resourceId =
-                getTaskManagerResourceID(
-                        configuration, rpcService.getAddress(), rpcService.getPort());
+            highAvailabilityServices =
+                    HighAvailabilityServicesUtils.createHighAvailabilityServices(
+                            configuration,
+                            executor,
+                            AddressResolution.NO_ADDRESS_RESOLUTION,
+                            rpcSystem,
+                            this);
 
-        this.workingDirectory =
-                ClusterEntrypointUtils.createTaskManagerWorkingDirectory(configuration, resourceId);
+            JMXService.startInstance(configuration.getString(JMXServerOptions.JMX_SERVER_PORT));
 
-        LOG.info("Using working directory: {}", workingDirectory);
+            rpcService = createRpcService(configuration, highAvailabilityServices, rpcSystem);
 
-        HeartbeatServices heartbeatServices = HeartbeatServices.fromConfiguration(configuration);
+            this.resourceId =
+                    getTaskManagerResourceID(
+                            configuration, rpcService.getAddress(), rpcService.getPort());
 
-        metricRegistry =
-                new MetricRegistryImpl(
-                        MetricRegistryConfiguration.fromConfiguration(
-                                configuration,
-                                rpcSystem.getMaximumMessageSizeInBytes(configuration)),
-                        ReporterSetup.fromConfiguration(configuration, pluginManager));
+            this.workingDirectory =
+                    ClusterEntrypointUtils.createTaskManagerWorkingDirectory(
+                            configuration, resourceId);
 
-        final RpcService metricQueryServiceRpcService =
-                MetricUtils.startRemoteMetricsRpcService(
-                        configuration, rpcService.getAddress(), rpcSystem);
-        metricRegistry.startQueryService(metricQueryServiceRpcService, resourceId.unwrap());
+            LOG.info("Using working directory: {}", workingDirectory);
 
-        blobCacheService =
-                BlobUtils.createBlobCacheService(
-                        configuration,
-                        Reference.borrowed(workingDirectory.unwrap().getBlobStorageDirectory()),
-                        highAvailabilityServices.createBlobStore(),
-                        null);
-
-        final ExternalResourceInfoProvider externalResourceInfoProvider =
-                ExternalResourceUtils.createStaticExternalResourceInfoProviderFromConfig(
-                        configuration, pluginManager);
-
-        taskExecutorService =
-                taskExecutorServiceFactory.createTaskExecutor(
-                        this.configuration,
-                        this.resourceId.unwrap(),
-                        rpcService,
-                        highAvailabilityServices,
-                        heartbeatServices,
-                        metricRegistry,
-                        blobCacheService,
-                        false,
-                        externalResourceInfoProvider,
-                        workingDirectory.unwrap(),
-                        this);
+            HeartbeatServices heartbeatServices =
+                    HeartbeatServices.fromConfiguration(configuration);
 
-        this.terminationFuture = new CompletableFuture<>();
-        this.shutdown = false;
-        handleUnexpectedTaskExecutorServiceTermination();
+            metricRegistry =
+                    new MetricRegistryImpl(
+                            MetricRegistryConfiguration.fromConfiguration(
+                                    configuration,
+                                    rpcSystem.getMaximumMessageSizeInBytes(configuration)),
+                            ReporterSetup.fromConfiguration(configuration, pluginManager));
+
+            final RpcService metricQueryServiceRpcService =
+                    MetricUtils.startRemoteMetricsRpcService(
+                            configuration, rpcService.getAddress(), rpcSystem);
+            metricRegistry.startQueryService(metricQueryServiceRpcService, resourceId.unwrap());
 
-        MemoryLogger.startIfConfigured(
-                LOG, configuration, terminationFuture.thenAccept(ignored -> {}));
+            blobCacheService =
+                    BlobUtils.createBlobCacheService(
+                            configuration,
+                            Reference.borrowed(workingDirectory.unwrap().getBlobStorageDirectory()),
+                            highAvailabilityServices.createBlobStore(),
+                            null);
+
+            final ExternalResourceInfoProvider externalResourceInfoProvider =
+                    ExternalResourceUtils.createStaticExternalResourceInfoProviderFromConfig(
+                            configuration, pluginManager);
+
+            taskExecutorService =
+                    taskExecutorServiceFactory.createTaskExecutor(
+                            this.configuration,
+                            this.resourceId.unwrap(),
+                            rpcService,
+                            highAvailabilityServices,
+                            heartbeatServices,
+                            metricRegistry,
+                            blobCacheService,
+                            false,
+                            externalResourceInfoProvider,
+                            workingDirectory.unwrap(),
+                            this);
+
+            handleUnexpectedTaskExecutorServiceTermination();
+
+            MemoryLogger.startIfConfigured(
+                    LOG, configuration, terminationFuture.thenAccept(ignored -> {}));
+        }
     }
 
+    @GuardedBy("lock")
     private void handleUnexpectedTaskExecutorServiceTermination() {
         taskExecutorService
                 .getTerminationFuture()
@@ -246,7 +281,10 @@ public class TaskManagerRunner implements FatalErrorHandler {
     // --------------------------------------------------------------------------------------------
 
     public void start() throws Exception {
-        taskExecutorService.start();
+        synchronized (lock) {
+            startTaskManagerRunnerServices();
+            taskExecutorService.start();
+        }
     }
 
     public void close() throws Exception {
@@ -263,42 +301,57 @@ public class TaskManagerRunner implements FatalErrorHandler {
 
     private CompletableFuture<Result> closeAsync(Result terminationResult) {
         synchronized (lock) {
-            if (!shutdown) {
-                shutdown = true;
+            // remove shutdown hook to prevent resource leaks
+            ShutdownHookUtil.removeShutdownHook(shutdownHook, this.getClass().getSimpleName(), LOG);
 
-                final CompletableFuture<Void> taskManagerTerminationFuture =
-                        taskExecutorService.closeAsync();
+            if (shutdown) {
+                return terminationFuture;
+            }
 
-                final CompletableFuture<Void> serviceTerminationFuture =
-                        FutureUtils.composeAfterwards(
-                                taskManagerTerminationFuture, this::shutDownServices);
+            final CompletableFuture<Void> taskManagerTerminationFuture;
+            if (taskExecutorService != null) {
+                taskManagerTerminationFuture = taskExecutorService.closeAsync();
+            } else {
+                taskManagerTerminationFuture = FutureUtils.completedVoidFuture();
+            }
 
-                final CompletableFuture<Void> workingDirCleanupFuture =
-                        FutureUtils.runAfterwards(
-                                serviceTerminationFuture,
-                                () -> deleteWorkingDir(terminationResult));
+            final CompletableFuture<Void> serviceTerminationFuture =
+                    FutureUtils.composeAfterwards(
+                            taskManagerTerminationFuture, this::shutDownServices);
 
-                final CompletableFuture<Void> rpcSystemClassLoaderCloseFuture =
-                        FutureUtils.runAfterwards(workingDirCleanupFuture, rpcSystem::close);
+            final CompletableFuture<Void> workingDirCleanupFuture =
+                    FutureUtils.runAfterwards(
+                            serviceTerminationFuture, () -> deleteWorkingDir(terminationResult));
 
-                rpcSystemClassLoaderCloseFuture.whenComplete(
-                        (Void ignored, Throwable throwable) -> {
-                            if (throwable != null) {
-                                terminationFuture.completeExceptionally(throwable);
-                            } else {
-                                terminationFuture.complete(terminationResult);
-                            }
-                        });
+            final CompletableFuture<Void> rpcSystemClassLoaderCloseFuture;
+
+            if (rpcSystem != null) {
+                rpcSystemClassLoaderCloseFuture =
+                        FutureUtils.runAfterwards(workingDirCleanupFuture, rpcSystem::close);
+            } else {
+                rpcSystemClassLoaderCloseFuture = FutureUtils.completedVoidFuture();
             }
-        }
 
-        return terminationFuture;
+            rpcSystemClassLoaderCloseFuture.whenComplete(
+                    (Void ignored, Throwable throwable) -> {
+                        if (throwable != null) {
+                            terminationFuture.completeExceptionally(throwable);
+                        } else {
+                            terminationFuture.complete(terminationResult);
+                        }
+                    });
+
+            shutdown = true;
+            return terminationFuture;
+        }
     }
 
     private void deleteWorkingDir(Result terminationResult) throws IOException {
-        if (workingDirectory != null) {
-            if (!workingDirectory.isDeterministic() || terminationResult == Result.SUCCESS) {
-                workingDirectory.unwrap().delete();
+        synchronized (lock) {
+            if (workingDirectory != null) {
+                if (!workingDirectory.isDeterministic() || terminationResult == Result.SUCCESS) {
+                    workingDirectory.unwrap().delete();
+                }
             }
         }
     }
@@ -314,29 +367,39 @@ public class TaskManagerRunner implements FatalErrorHandler {
                 exception = ExceptionUtils.firstOrSuppressed(e, exception);
             }
 
-            try {
-                blobCacheService.close();
-            } catch (Exception e) {
-                exception = ExceptionUtils.firstOrSuppressed(e, exception);
+            if (blobCacheService != null) {
+                try {
+                    blobCacheService.close();
+                } catch (Exception e) {
+                    exception = ExceptionUtils.firstOrSuppressed(e, exception);
+                }
             }
 
-            try {
-                metricRegistry.shutdown();
-            } catch (Exception e) {
-                exception = ExceptionUtils.firstOrSuppressed(e, exception);
+            if (metricRegistry != null) {
+                try {
+                    metricRegistry.shutdown();
+                } catch (Exception e) {
+                    exception = ExceptionUtils.firstOrSuppressed(e, exception);
+                }
             }
 
-            try {
-                highAvailabilityServices.close();
-            } catch (Exception e) {
-                exception = ExceptionUtils.firstOrSuppressed(e, exception);
+            if (highAvailabilityServices != null) {
+                try {
+                    highAvailabilityServices.close();
+                } catch (Exception e) {
+                    exception = ExceptionUtils.firstOrSuppressed(e, exception);
+                }
             }
 
-            terminationFutures.add(rpcService.stopService());
+            if (rpcService != null) {
+                terminationFutures.add(rpcService.stopService());
+            }
 
-            terminationFutures.add(
-                    ExecutorUtils.nonBlockingShutdown(
-                            timeout.toMilliseconds(), TimeUnit.MILLISECONDS, executor));
+            if (executor != null) {
+                terminationFutures.add(
+                        ExecutorUtils.nonBlockingShutdown(
+                                timeout.toMilliseconds(), TimeUnit.MILLISECONDS, executor));
+            }
 
             if (exception != null) {
                 terminationFutures.add(FutureUtils.completedExceptionally(exception));
@@ -721,6 +784,7 @@ public class TaskManagerRunner implements FatalErrorHandler {
 
     public enum Result {
         SUCCESS(SUCCESS_EXIT_CODE),
+        JVM_SHUTDOWN(FAILURE_EXIT_CODE),
         FAILURE(FAILURE_EXIT_CODE);
 
         private final int exitCode;
