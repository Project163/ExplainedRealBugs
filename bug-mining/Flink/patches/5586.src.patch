diff --git a/flink-tests/src/test/java/org/apache/flink/test/streaming/api/FileReadingWatermarkITCase.java b/flink-tests/src/test/java/org/apache/flink/test/streaming/api/FileReadingWatermarkITCase.java
index c574464934e..d7c5eacb0d8 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/streaming/api/FileReadingWatermarkITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/streaming/api/FileReadingWatermarkITCase.java
@@ -19,23 +19,27 @@ package org.apache.flink.test.streaming.api;
 
 import org.apache.flink.api.common.JobExecutionResult;
 import org.apache.flink.api.common.accumulators.IntCounter;
+import org.apache.flink.api.common.accumulators.LongCounter;
 import org.apache.flink.api.common.eventtime.Watermark;
+import org.apache.flink.api.java.tuple.Tuple3;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
 import org.apache.flink.streaming.api.functions.sink.RichSinkFunction;
 import org.apache.flink.streaming.api.functions.sink.SinkFunction;
 import org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor;
 import org.apache.flink.streaming.api.windowing.time.Time;
+import org.apache.flink.util.Preconditions;
 
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.util.UUID;
 
 import static org.apache.flink.util.Preconditions.checkState;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
 
 /**
  * Tests that watermarks are emitted while file is being read, particularly the last split.
@@ -44,10 +48,13 @@ import static org.junit.Assert.assertTrue;
  */
 public class FileReadingWatermarkITCase {
     private static final String NUM_WATERMARKS_ACC_NAME = "numWatermarks";
-    private static final int FILE_SIZE_LINES = 100_000;
+    private static final String RUNTIME_ACC_NAME = "runtime";
+    private static final int FILE_SIZE_LINES = 5_000_000;
     private static final int WATERMARK_INTERVAL_MILLIS = 10;
     private static final int MIN_EXPECTED_WATERMARKS = 5;
 
+    @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();
+
     @Test
     public void testWatermarkEmissionWithChaining() throws Exception {
         StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironment(1);
@@ -55,26 +62,40 @@ public class FileReadingWatermarkITCase {
 
         checkState(env.isChainingEnabled());
 
-        env.readTextFile(getSourceFile().getAbsolutePath())
+        Tuple3<File, String, String> sourceFileAndFirstLastLines = getSourceFile(FILE_SIZE_LINES);
+        env.readTextFile(sourceFileAndFirstLastLines.f0.getAbsolutePath())
                 .assignTimestampsAndWatermarks(getExtractorAssigner())
-                .addSink(getWatermarkCounter());
+                .addSink(
+                        getWatermarkCounter(
+                                sourceFileAndFirstLastLines.f1, sourceFileAndFirstLastLines.f2));
 
         JobExecutionResult result = env.execute();
 
         int actual = result.getAccumulatorResult(NUM_WATERMARKS_ACC_NAME);
-
-        assertTrue("too few watermarks emitted: " + actual, actual >= MIN_EXPECTED_WATERMARKS);
+        long expected =
+                result.<Long>getAccumulatorResult(RUNTIME_ACC_NAME) / WATERMARK_INTERVAL_MILLIS;
+        checkState(expected > MIN_EXPECTED_WATERMARKS);
+
+        assertEquals(
+                "too few watermarks emitted in "
+                        + result.<Long>getAccumulatorResult(RUNTIME_ACC_NAME)
+                        + " ms",
+                expected,
+                actual,
+                .5 * expected);
     }
 
-    private File getSourceFile() throws IOException {
-        File file = File.createTempFile(UUID.randomUUID().toString(), null);
+    private Tuple3<File, String, String> getSourceFile(int numLines) throws IOException {
+        Preconditions.checkArgument(numLines > 0);
+        File file = temporaryFolder.newFile();
+        String first = "0", last = null;
         try (PrintWriter printWriter = new PrintWriter(file)) {
-            for (int i = 0; i < FILE_SIZE_LINES; i++) {
+            for (int i = 0; i < numLines; i++) {
                 printWriter.println(i);
+                last = Integer.toString(i);
             }
         }
-        file.deleteOnExit();
-        return file;
+        return Tuple3.of(file, first, last);
     }
 
     private static BoundedOutOfOrdernessTimestampExtractor<String> getExtractorAssigner() {
@@ -88,27 +109,33 @@ public class FileReadingWatermarkITCase {
         };
     }
 
-    private static SinkFunction<String> getWatermarkCounter() {
+    private static SinkFunction<String> getWatermarkCounter(
+            final String firstElement, final String lastElement) {
         return new RichSinkFunction<String>() {
+            private long start;
             private final IntCounter numWatermarks = new IntCounter();
+            private final LongCounter runtime = new LongCounter();
             private long lastWatermark = -1;
 
             @Override
             public void open(Configuration parameters) throws Exception {
                 super.open(parameters);
                 getRuntimeContext().addAccumulator(NUM_WATERMARKS_ACC_NAME, numWatermarks);
+                getRuntimeContext().addAccumulator(RUNTIME_ACC_NAME, runtime);
             }
 
             @Override
-            public void close() throws Exception {
-                super.close();
+            public void invoke(String value, SinkFunction.Context context) {
+                if (value.equals(firstElement)) {
+                    start = System.nanoTime();
+                }
+                if (value.equals(lastElement)) {
+                    runtime.add((System.nanoTime() - start) / 1_000_000);
+                }
             }
 
             @Override
-            public void invoke(String value, SinkFunction.Context context) {}
-
-            @Override
-            public void writeWatermark(Watermark watermark) throws Exception {
+            public void writeWatermark(Watermark watermark) {
                 if (watermark.getTimestamp() != lastWatermark) {
                     lastWatermark = watermark.getTimestamp();
                     numWatermarks.add(1);
