diff --git a/flink-state-backends/flink-statebackend-common/src/main/java/org/apache/flink/state/common/PeriodicMaterializationManager.java b/flink-state-backends/flink-statebackend-common/src/main/java/org/apache/flink/state/common/PeriodicMaterializationManager.java
index 77f121fbb34..96926e98841 100644
--- a/flink-state-backends/flink-statebackend-common/src/main/java/org/apache/flink/state/common/PeriodicMaterializationManager.java
+++ b/flink-state-backends/flink-statebackend-common/src/main/java/org/apache/flink/state/common/PeriodicMaterializationManager.java
@@ -74,6 +74,20 @@ public class PeriodicMaterializationManager implements Closeable {
                 long materializationID,
                 SequenceNumber upTo)
                 throws Exception;
+
+        MaterializationTarget NO_OP =
+                new MaterializationTarget() {
+                    @Override
+                    public Optional<MaterializationRunnable> initMaterialization() {
+                        return Optional.empty();
+                    }
+
+                    @Override
+                    public void handleMaterializationResult(
+                            SnapshotResult<KeyedStateHandle> materializedSnapshot,
+                            long materializationID,
+                            SequenceNumber upTo) {}
+                };
     }
 
     private static final Logger LOG = LoggerFactory.getLogger(PeriodicMaterializationManager.class);
@@ -118,6 +132,32 @@ public class PeriodicMaterializationManager implements Closeable {
             long periodicMaterializeDelay,
             int allowedNumberOfFailures,
             String operatorSubtaskId) {
+        this(
+                mailboxExecutor,
+                asyncOperationsThreadPool,
+                subtaskName,
+                asyncExceptionHandler,
+                target,
+                metricGroup,
+                periodicMaterializeDelay,
+                allowedNumberOfFailures,
+                operatorSubtaskId,
+                Executors.newSingleThreadScheduledExecutor(
+                        new ExecutorThreadFactory(
+                                "periodic-materialization-scheduler-" + subtaskName)));
+    }
+
+    PeriodicMaterializationManager(
+            MailboxExecutor mailboxExecutor,
+            ExecutorService asyncOperationsThreadPool,
+            String subtaskName,
+            AsyncExceptionHandler asyncExceptionHandler,
+            MaterializationTarget target,
+            ChangelogMaterializationMetricGroup metricGroup,
+            long periodicMaterializeDelay,
+            int allowedNumberOfFailures,
+            String operatorSubtaskId,
+            ScheduledExecutorService periodicExecutor) {
         this.mailboxExecutor = checkNotNull(mailboxExecutor);
         this.asyncOperationsThreadPool = checkNotNull(asyncOperationsThreadPool);
         this.subtaskName = checkNotNull(subtaskName);
@@ -129,10 +169,7 @@ public class PeriodicMaterializationManager implements Closeable {
         this.allowedNumberOfFailures = allowedNumberOfFailures;
         this.numberOfConsecutiveFailures = new AtomicInteger(0);
 
-        this.periodicExecutor =
-                Executors.newSingleThreadScheduledExecutor(
-                        new ExecutorThreadFactory(
-                                "periodic-materialization-scheduler-" + subtaskName));
+        this.periodicExecutor = periodicExecutor;
 
         this.initialDelay =
                 // randomize initial delay to avoid thundering herd problem
@@ -147,7 +184,7 @@ public class PeriodicMaterializationManager implements Closeable {
 
             LOG.info("Task {} starts periodic materialization", subtaskName);
 
-            scheduleNextMaterialization(periodicMaterializeDelay + initialDelay);
+            scheduleNextMaterialization(initialDelay);
         }
     }
 
diff --git a/flink-state-backends/flink-statebackend-common/src/test/java/org/apache/flink/state/common/PeriodicMaterializationManagerTest.java b/flink-state-backends/flink-statebackend-common/src/test/java/org/apache/flink/state/common/PeriodicMaterializationManagerTest.java
new file mode 100644
index 00000000000..089d37d459d
--- /dev/null
+++ b/flink-state-backends/flink-statebackend-common/src/test/java/org/apache/flink/state/common/PeriodicMaterializationManagerTest.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.state.common;
+
+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutorService;
+import org.apache.flink.runtime.mailbox.SyncMailboxExecutor;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
+import org.apache.flink.state.common.PeriodicMaterializationManager.MaterializationTarget;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.Test;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.apache.flink.shaded.guava30.com.google.common.collect.Iterators.getOnlyElement;
+import static org.apache.flink.util.concurrent.Executors.newDirectExecutorService;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.lessThanOrEqualTo;
+
+/** {@link PeriodicMaterializationManager} test. */
+public class PeriodicMaterializationManagerTest extends TestLogger {
+
+    @Test
+    public void testInitialDelay() {
+        ManuallyTriggeredScheduledExecutorService scheduledExecutorService =
+                new ManuallyTriggeredScheduledExecutorService();
+        long periodicMaterializeDelay = 10_000L;
+
+        try (PeriodicMaterializationManager test =
+                new PeriodicMaterializationManager(
+                        new SyncMailboxExecutor(),
+                        newDirectExecutorService(),
+                        "test",
+                        (message, exception) -> {},
+                        MaterializationTarget.NO_OP,
+                        new ChangelogMaterializationMetricGroup(
+                                UnregisteredMetricGroups.createUnregisteredOperatorMetricGroup()),
+                        periodicMaterializeDelay,
+                        0,
+                        "subtask-0",
+                        scheduledExecutorService)) {
+            test.start();
+
+            assertThat(
+                    String.format(
+                            "task for initial materialization should be scheduled with a 0..%d delay",
+                            periodicMaterializeDelay),
+                    getOnlyElement(scheduledExecutorService.getAllScheduledTasks().iterator())
+                            .getDelay(MILLISECONDS),
+                    lessThanOrEqualTo(periodicMaterializeDelay));
+        }
+    }
+}
