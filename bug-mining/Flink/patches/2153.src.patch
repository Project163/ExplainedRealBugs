diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java
index 9f5a40c2cdc..07a53fb8f34 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java
@@ -136,7 +136,6 @@ class PipelinedSubpartition extends ResultSubpartition {
 				buffer.recycle();
 			}
 
-			// Get the view...
 			view = readView;
 			readView = null;
 
@@ -146,7 +145,6 @@ class PipelinedSubpartition extends ResultSubpartition {
 
 		LOG.debug("Released {}.", this);
 
-		// Release all resources of the view
 		if (view != null) {
 			view.releaseAllResources();
 		}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java
index 9047e5150f5..827a577384c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartition.java
@@ -152,6 +152,7 @@ class SpillableSubpartition extends ResultSubpartition {
 
 	@Override
 	public synchronized void release() throws IOException {
+		// view reference accessible outside the lock, but assigned inside the locked scope
 		final ResultSubpartitionView view;
 
 		synchronized (buffers) {
@@ -159,16 +160,18 @@ class SpillableSubpartition extends ResultSubpartition {
 				return;
 			}
 
+			// Release all available buffers
+			for (Buffer buffer : buffers) {
+				buffer.recycle();
+			}
+			buffers.clear();
+
 			view = readView;
 
 			// No consumer yet, we are responsible to clean everything up. If
 			// one is available, the view is responsible is to clean up (see
 			// below).
 			if (view == null) {
-				for (Buffer buffer : buffers) {
-					buffer.recycle();
-				}
-				buffers.clear();
 
 				// TODO This can block until all buffers are written out to
 				// disk if a spill is in-progress before deleting the file.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java
index 2527273b1b5..a16e59a881a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionView.java
@@ -169,6 +169,13 @@ class SpillableSubpartitionView implements ResultSubpartitionView {
 			if (spilled != null) {
 				spilled.releaseAllResources();
 			}
+			// we are never giving this buffer out in getNextBuffer(), so we need to clean it up
+			synchronized (buffers) {
+				if (nextBuffer != null) {
+					nextBuffer.recycle();
+					nextBuffer = null;
+				}
+			}
 		}
 	}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionTest.java
index 9edba35acd6..8b1e8d26f97 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionTest.java
@@ -19,9 +19,11 @@
 package org.apache.flink.runtime.io.network.partition;
 
 import org.apache.flink.core.memory.MemorySegment;
+import org.apache.flink.core.memory.MemorySegmentFactory;
 import org.apache.flink.runtime.event.AbstractEvent;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.buffer.BufferProvider;
+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;
 import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
 import org.apache.flink.runtime.io.network.util.TestConsumerCallback;
@@ -29,7 +31,9 @@ import org.apache.flink.runtime.io.network.util.TestPooledBufferProvider;
 import org.apache.flink.runtime.io.network.util.TestProducerSource;
 import org.apache.flink.runtime.io.network.util.TestSubpartitionConsumer;
 import org.apache.flink.runtime.io.network.util.TestSubpartitionProducer;
+
 import org.junit.AfterClass;
+import org.junit.Assert;
 import org.junit.Test;
 
 import java.util.concurrent.ExecutorService;
@@ -259,4 +263,72 @@ public class PipelinedSubpartitionTest extends SubpartitionTestBase {
 		producerResult.get();
 		consumerResult.get();
 	}
+
+
+	/**
+	 * Tests cleanup of {@link PipelinedSubpartition#release()} with no read view attached.
+	 */
+	@Test
+	public void testCleanupReleasedPartitionNoView() throws Exception {
+		testCleanupReleasedPartition(false);
+	}
+
+	/**
+	 * Tests cleanup of {@link PipelinedSubpartition#release()} with a read view attached.
+	 */
+	@Test
+	public void testCleanupReleasedPartitionWithView() throws Exception {
+		testCleanupReleasedPartition(true);
+	}
+
+	/**
+	 * Tests cleanup of {@link PipelinedSubpartition#release()}.
+	 *
+	 * @param createView
+	 * 		whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)
+	 */
+	private void testCleanupReleasedPartition(boolean createView) throws Exception {
+		PipelinedSubpartition partition = createSubpartition();
+
+		Buffer buffer1 = new Buffer(MemorySegmentFactory.allocateUnpooledSegment(4096),
+			FreeingBufferRecycler.INSTANCE);
+		Buffer buffer2 = new Buffer(MemorySegmentFactory.allocateUnpooledSegment(4096),
+			FreeingBufferRecycler.INSTANCE);
+		boolean buffer1Recycled;
+		boolean buffer2Recycled;
+		try {
+			partition.add(buffer1);
+			partition.add(buffer2);
+			// create the read view first
+			ResultSubpartitionView view = null;
+			if (createView) {
+				view = partition.createReadView(numBuffers -> {});
+			}
+
+			partition.release();
+
+			assertTrue(partition.isReleased());
+			if (createView) {
+				assertTrue(view.isReleased());
+			}
+			assertTrue(buffer1.isRecycled());
+		} finally {
+			buffer1Recycled = buffer1.isRecycled();
+			if (!buffer1Recycled) {
+				buffer1.recycle();
+			}
+			buffer2Recycled = buffer2.isRecycled();
+			if (!buffer2Recycled) {
+				buffer2.recycle();
+			}
+		}
+		if (!buffer1Recycled) {
+			Assert.fail("buffer 1 not recycled");
+		}
+		if (!buffer2Recycled) {
+			Assert.fail("buffer 2 not recycled");
+		}
+		assertEquals(2, partition.getTotalNumberOfBuffers());
+		assertEquals(2 * 4096, partition.getTotalNumberOfBytes());
+	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionTest.java
index 924a2a0d589..db94c81b5d5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/SpillableSubpartitionTest.java
@@ -594,6 +594,105 @@ public class SpillableSubpartitionTest extends SubpartitionTestBase {
 		assertEquals(0, partition.getTotalNumberOfBytes());
 	}
 
+	/**
+	 * Tests cleanup of {@link SpillableSubpartition#release()} with a spillable partition and no
+	 * read view attached.
+	 */
+	@Test
+	public void testCleanupReleasedSpillablePartitionNoView() throws Exception {
+		testCleanupReleasedPartition(false, false);
+	}
+
+	/**
+	 * Tests cleanup of {@link SpillableSubpartition#release()} with a spillable partition and a
+	 * read view attached - [FLINK-8371].
+	 */
+	@Test
+	public void testCleanupReleasedSpillablePartitionWithView() throws Exception {
+		testCleanupReleasedPartition(false, true);
+	}
+
+	/**
+	 * Tests cleanup of {@link SpillableSubpartition#release()} with a spilled partition and no
+	 * read view attached.
+	 */
+	@Test
+	public void testCleanupReleasedSpilledPartitionNoView() throws Exception {
+		testCleanupReleasedPartition(true, false);
+	}
+
+	/**
+	 * Tests cleanup of {@link SpillableSubpartition#release()} with a spilled partition and a
+	 * read view attached.
+	 */
+	@Test
+	public void testCleanupReleasedSpilledPartitionWithView() throws Exception {
+		testCleanupReleasedPartition(true, true);
+	}
+
+	/**
+	 * Tests cleanup of {@link SpillableSubpartition#release()}.
+	 *
+	 * @param spilled
+	 * 		whether the partition should be spilled to disk (<tt>true</tt>) or not (<tt>false</tt>,
+	 * 		spillable)
+	 * @param createView
+	 * 		whether the partition should have a view attached to it (<tt>true</tt>) or not (<tt>false</tt>)
+	 */
+	private void testCleanupReleasedPartition(boolean spilled, boolean createView) throws Exception {
+		SpillableSubpartition partition = createSubpartition();
+
+		Buffer buffer1 = new Buffer(MemorySegmentFactory.allocateUnpooledSegment(4096),
+			FreeingBufferRecycler.INSTANCE);
+		Buffer buffer2 = new Buffer(MemorySegmentFactory.allocateUnpooledSegment(4096),
+			FreeingBufferRecycler.INSTANCE);
+		boolean buffer1Recycled;
+		boolean buffer2Recycled;
+		try {
+			partition.add(buffer1);
+			partition.add(buffer2);
+			// create the read view before spilling
+			// (tests both code paths since this view may then contain the spilled view)
+			ResultSubpartitionView view = null;
+			if (createView) {
+				partition.finish();
+				view = partition.createReadView(numBuffers -> {});
+			}
+			if (spilled) {
+				// note: in case we create a view, one buffer will already reside in the view and
+				//       one EndOfPartitionEvent will be added instead (so overall the number of
+				//       buffers to spill is the same
+				assertEquals(2, partition.releaseMemory());
+			}
+
+			partition.release();
+
+			assertTrue(partition.isReleased());
+			if (createView) {
+				assertTrue(view.isReleased());
+			}
+			assertTrue(buffer1.isRecycled());
+		} finally {
+			buffer1Recycled = buffer1.isRecycled();
+			if (!buffer1Recycled) {
+				buffer1.recycle();
+			}
+			buffer2Recycled = buffer2.isRecycled();
+			if (!buffer2Recycled) {
+				buffer2.recycle();
+			}
+		}
+		if (!buffer1Recycled) {
+			Assert.fail("buffer 1 not recycled");
+		}
+		if (!buffer2Recycled) {
+			Assert.fail("buffer 2 not recycled");
+		}
+		// note: in case we create a view, there will be an additional EndOfPartitionEvent
+		assertEquals(createView ? 3 : 2, partition.getTotalNumberOfBuffers());
+		assertEquals((createView ? 4 : 0) + 2 * 4096, partition.getTotalNumberOfBytes());
+	}
+
 	private static class AwaitableBufferAvailablityListener implements BufferAvailabilityListener {
 
 		private long numNotifiedBuffers;
