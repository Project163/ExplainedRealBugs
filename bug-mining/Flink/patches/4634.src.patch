diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
index b338f4203af..c4b96926c4b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
@@ -402,7 +402,9 @@ public class CheckpointCoordinator {
 				// clear queued requests and in-flight checkpoints
 				abortPendingAndQueuedCheckpoints(reason);
 
-				completedCheckpointStore.shutdown(jobStatus);
+				completedCheckpointStore.shutdown(jobStatus, checkpointsCleaner, () -> {
+					// don't schedule anything on shutdown
+				});
 				checkpointIdCounter.shutdown(jobStatus);
 			}
 		}
@@ -676,9 +678,7 @@ public class CheckpointCoordinator {
 			props,
 			checkpointStorageLocation,
 			executor,
-			onCompletionPromise,
-			checkpointsCleaner,
-			this::scheduleTriggerRequest);
+			onCompletionPromise);
 
 		if (statsTracker != null) {
 			PendingCheckpointStats callback = statsTracker.reportPendingCheckpoint(
@@ -1071,7 +1071,7 @@ public class CheckpointCoordinator {
 
 		try {
 			try {
-				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint(checkpointsCleaner::cleanCheckpoint);
+				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint(checkpointsCleaner, this::scheduleTriggerRequest);
 				failureManager.handleCheckpointSuccess(pendingCheckpoint.getCheckpointId());
 			}
 			catch (Exception e1) {
@@ -1091,7 +1091,7 @@ public class CheckpointCoordinator {
 			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null);
 
 			try {
-				completedCheckpointStore.addCheckpoint(completedCheckpoint);
+				completedCheckpointStore.addCheckpoint(completedCheckpoint, checkpointsCleaner, this::scheduleTriggerRequest);
 			} catch (Exception exception) {
 				// we failed to store the completed checkpoint. Let's clean up
 				executor.execute(new Runnable() {
@@ -1409,9 +1409,9 @@ public class CheckpointCoordinator {
 
 		// Load the savepoint as a checkpoint into the system
 		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(
-				job, tasks, checkpointLocation, userClassLoader, allowNonRestored, checkpointsCleaner::cleanCheckpoint, this::scheduleTriggerRequest);
+				job, tasks, checkpointLocation, userClassLoader, allowNonRestored);
 
-		completedCheckpointStore.addCheckpoint(savepoint);
+		completedCheckpointStore.addCheckpoint(savepoint, checkpointsCleaner, this::scheduleTriggerRequest);
 
 		// Reset the checkpoint ID counter
 		long nextCheckpointId = savepoint.getCheckpointID() + 1;
@@ -1675,7 +1675,10 @@ public class CheckpointCoordinator {
 			try {
 				// release resource here
 				pendingCheckpoint.abort(
-					exception.getCheckpointFailureReason(), exception.getCause());
+					exception.getCheckpointFailureReason(),
+					exception.getCause(),
+					checkpointsCleaner,
+					this::scheduleTriggerRequest);
 
 				if (pendingCheckpoint.getProps().isSavepoint() &&
 					pendingCheckpoint.getProps().isSynchronous()) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
index 00393afa3d8..23df6942466 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
@@ -118,9 +118,7 @@ public class Checkpoints {
 			Map<JobVertexID, ExecutionJobVertex> tasks,
 			CompletedCheckpointStorageLocation location,
 			ClassLoader classLoader,
-			boolean allowNonRestoredState,
-			CheckpointsCleaningRunner cleanCallback,
-			SerializableRunnable checkpointCleaningFinishedCallback) throws IOException {
+			boolean allowNonRestoredState) throws IOException {
 
 		checkNotNull(jobId, "jobId");
 		checkNotNull(tasks, "tasks");
@@ -198,9 +196,7 @@ public class Checkpoints {
 				operatorStates,
 				checkpointMetadata.getMasterStates(),
 				props,
-				location,
-				cleanCallback,
-				checkpointCleaningFinishedCallback);
+				location);
 	}
 
 	private static void throwNonRestoredStateException(String checkpointPointer, OperatorID operatorId) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaningRunner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaningRunner.java
deleted file mode 100644
index ebcd48717c0..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaningRunner.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.checkpoint;
-
-import java.io.Serializable;
-import java.util.concurrent.Executor;
-
-/**
- * Interface that allows to run a checkpoint cleaning task and a post checkpoint cleaning task on an {@link Executor}.
- */
-@FunctionalInterface
-public interface CheckpointsCleaningRunner extends Serializable {
-	void accept(Runnable cleanAction, Runnable postCleanAction, Executor executor);
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
index 5a03e563de6..d79cab42646 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
@@ -27,7 +27,6 @@ import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.StateUtil;
 import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.util.ExceptionUtils;
-import org.apache.flink.util.function.ThrowingConsumer;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -41,7 +40,6 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Executor;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -110,11 +108,6 @@ public class CompletedCheckpoint implements Serializable {
 	@Nullable
 	private transient volatile CompletedCheckpointStats.DiscardCallback discardCallback;
 
-	private final CheckpointsCleaningRunner cleanupCallback;
-
-	private final SerializableRunnable cleanupFinishedCallback;
-
-
 	// ------------------------------------------------------------------------
 
 	public CompletedCheckpoint(
@@ -125,9 +118,7 @@ public class CompletedCheckpoint implements Serializable {
 			Map<OperatorID, OperatorState> operatorStates,
 			@Nullable Collection<MasterState> masterHookStates,
 			CheckpointProperties props,
-			CompletedCheckpointStorageLocation storageLocation,
-			CheckpointsCleaningRunner cleanupCallback,
-			SerializableRunnable cleanupFinishedCallback) {
+			CompletedCheckpointStorageLocation storageLocation) {
 
 		checkArgument(checkpointID >= 0);
 		checkArgument(timestamp >= 0);
@@ -149,8 +140,6 @@ public class CompletedCheckpoint implements Serializable {
 		this.storageLocation = checkNotNull(storageLocation);
 		this.metadataHandle = storageLocation.getMetadataHandle();
 		this.externalPointer = storageLocation.getExternalPointer();
-		this.cleanupCallback = cleanupCallback;
-		this.cleanupFinishedCallback = cleanupFinishedCallback;
 	}
 
 	// ------------------------------------------------------------------------
@@ -221,21 +210,6 @@ public class CompletedCheckpoint implements Serializable {
 	//  Discard and Dispose
 	// ------------------------------------------------------------------------
 
-	/**
-	 * Asynchronously call a discard on the ioExecutor
-	 * (FixedThreadPool of configurable size of default 4*CPU cores)
-	 * and count the number of checkpoints that are waiting to clean.
-	 */
-	void asyncDiscardCheckpointAndCountCheckpoint(ThrowingConsumer<CompletedCheckpoint, Exception> discardCallback, Executor executor){
-		cleanupCallback.accept(() -> {
-			try {
-				discardCallback.accept(this);
-			} catch (Exception e) {
-				LOG.warn("Could not discard completed checkpoint {}.", checkpointID, e);
-			}
-		}, cleanupFinishedCallback, executor);
-	}
-
 	public void discardOnFailedStoring() throws Exception {
 		doDiscard();
 	}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStore.java
index cc8bb81c5cd..03175f9742c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStore.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.JobStatus;
 
 import org.slf4j.Logger;
@@ -47,7 +48,7 @@ public interface CompletedCheckpointStore {
 	 * <p>Only a bounded number of checkpoints is kept. When exceeding the maximum number of
 	 * retained checkpoints, the oldest one will be discarded.
 	 */
-	void addCheckpoint(CompletedCheckpoint checkpoint) throws Exception;
+	void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception;
 
 	/**
 	 * Returns the latest {@link CompletedCheckpoint} instance or <code>null</code> if none was
@@ -84,7 +85,7 @@ public interface CompletedCheckpointStore {
 	 *
 	 * @param jobStatus Job state on shut down
 	 */
-	void shutdown(JobStatus jobStatus) throws Exception;
+	void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception;
 
 	/**
 	 * Returns all {@link CompletedCheckpoint} instances.
@@ -113,10 +114,12 @@ public interface CompletedCheckpointStore {
 	 */
 	boolean requiresExternalizedCheckpoints();
 
-	static CompletedCheckpointStore storeFor(CompletedCheckpoint... checkpoints) throws Exception {
+	@VisibleForTesting
+	static CompletedCheckpointStore storeFor(Runnable postCleanupAction, CompletedCheckpoint... checkpoints) throws Exception {
 		StandaloneCompletedCheckpointStore store = new StandaloneCompletedCheckpointStore(checkpoints.length);
+		CheckpointsCleaner checkpointsCleaner = new CheckpointsCleaner();
 		for (final CompletedCheckpoint checkpoint : checkpoints) {
-			store.addCheckpoint(checkpoint);
+			store.addCheckpoint(checkpoint, checkpointsCleaner, postCleanupAction);
 		}
 		return store;
 	}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
index 9590156a6a3..a6c04f17fee 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
@@ -125,9 +125,6 @@ public class PendingCheckpoint {
 
 	private CheckpointException failureCause;
 
-	private final SerializableRunnable cleanupFinishedCallback;
-	private final CheckpointsCleaner checkpointsCleaner;
-
 	// --------------------------------------------------------------------------------------------
 
 	public PendingCheckpoint(
@@ -140,10 +137,7 @@ public class PendingCheckpoint {
 			CheckpointProperties props,
 			CheckpointStorageLocation targetLocation,
 			Executor executor,
-			CompletableFuture<CompletedCheckpoint> onCompletionPromise,
-			CheckpointsCleaner checkpointsCleaner,
-			SerializableRunnable cleanupFinishedCallback
-		) {
+			CompletableFuture<CompletedCheckpoint> onCompletionPromise) {
 
 		checkArgument(verticesToConfirm.size() > 0,
 				"Checkpoint needs at least one vertex that commits the checkpoint");
@@ -164,8 +158,6 @@ public class PendingCheckpoint {
 				? Collections.emptySet() : new HashSet<>(operatorCoordinatorsToConfirm);
 		this.acknowledgedTasks = new HashSet<>(verticesToConfirm.size());
 		this.onCompletionPromise = checkNotNull(onCompletionPromise);
-		this.cleanupFinishedCallback = cleanupFinishedCallback;
-		this.checkpointsCleaner = checkpointsCleaner;
 	}
 
 	// --------------------------------------------------------------------------------------------
@@ -299,7 +291,7 @@ public class PendingCheckpoint {
 		return onCompletionPromise;
 	}
 
-	public CompletedCheckpoint finalizeCheckpoint(CheckpointsCleaningRunner cleanCallback) throws IOException {
+	public CompletedCheckpoint finalizeCheckpoint(CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws IOException {
 
 		synchronized (lock) {
 			checkState(!isDiscarded(), "checkpoint is discarded");
@@ -324,9 +316,7 @@ public class PendingCheckpoint {
 						operatorStates,
 						masterStates,
 						props,
-						finalizedLocation,
-						cleanCallback,
-						cleanupFinishedCallback);
+						finalizedLocation);
 
 				onCompletionPromise.complete(completed);
 
@@ -341,7 +331,7 @@ public class PendingCheckpoint {
 				}
 
 				// mark this pending checkpoint as disposed, but do NOT drop the state
-				dispose(false);
+				dispose(false, checkpointsCleaner, postCleanup);
 
 				return completed;
 			}
@@ -500,24 +490,17 @@ public class PendingCheckpoint {
 	/**
 	 * Aborts a checkpoint with reason and cause.
 	 */
-	public void abort(CheckpointFailureReason reason, @Nullable Throwable cause) {
+	public void abort(CheckpointFailureReason reason, @Nullable Throwable cause, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) {
 		try {
 			failureCause = new CheckpointException(reason, cause);
 			onCompletionPromise.completeExceptionally(failureCause);
 			reportFailedCheckpoint(failureCause);
 			assertAbortSubsumedForced(reason);
 		} finally {
-			dispose(true);
+			dispose(true, checkpointsCleaner, postCleanup);
 		}
 	}
 
-	/**
-	 * Aborts a checkpoint with reason and cause.
-	 */
-	public void abort(CheckpointFailureReason reason) {
-		abort(reason, null);
-	}
-
 	private void assertAbortSubsumedForced(CheckpointFailureReason reason) {
 		if (props.isSavepoint() && reason == CheckpointFailureReason.CHECKPOINT_SUBSUMED) {
 			throw new IllegalStateException("Bug: savepoints must never be subsumed, " +
@@ -525,7 +508,7 @@ public class PendingCheckpoint {
 		}
 	}
 
-	private void dispose(boolean releaseState) {
+	private void dispose(boolean releaseState, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) {
 
 		synchronized (lock) {
 			try {
@@ -545,7 +528,7 @@ public class PendingCheckpoint {
 							operatorStates.clear();
 						}
 					};
-					checkpointsCleaner.cleanCheckpoint(cleanAction, cleanupFinishedCallback, executor);
+					checkpointsCleaner.cleanCheckpoint(cleanAction, postCleanup, executor);
 				}
 			} finally {
 				discarded = true;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SerializableRunnable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SerializableRunnable.java
deleted file mode 100644
index 80ac966128a..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SerializableRunnable.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.checkpoint;
-
-import java.io.Serializable;
-
-/**
- * Serializable version of the Runnable.
- */
-public interface SerializableRunnable extends Serializable, Runnable {
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStore.java
index ddaf9095f80..e73e62dbcfd 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStore.java
@@ -62,7 +62,7 @@ public class StandaloneCompletedCheckpointStore implements CompletedCheckpointSt
 	}
 
 	@Override
-	public void addCheckpoint(CompletedCheckpoint checkpoint) throws Exception {
+	public void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 
 		checkpoints.addLast(checkpoint);
 
@@ -92,7 +92,7 @@ public class StandaloneCompletedCheckpointStore implements CompletedCheckpointSt
 	}
 
 	@Override
-	public void shutdown(JobStatus jobStatus) throws Exception {
+	public void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 		try {
 			LOG.info("Shutting down");
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
index 10123b32f12..7fcc1d44c29 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
@@ -207,7 +207,7 @@ public class ZooKeeperCompletedCheckpointStore implements CompletedCheckpointSto
 	 * @param checkpoint Completed checkpoint to add.
 	 */
 	@Override
-	public void addCheckpoint(final CompletedCheckpoint checkpoint) throws Exception {
+	public void addCheckpoint(final CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 		checkNotNull(checkpoint, "Checkpoint");
 
 		final String path = checkpointIdToPath(checkpoint.getCheckpointID());
@@ -220,18 +220,26 @@ public class ZooKeeperCompletedCheckpointStore implements CompletedCheckpointSto
 		// Everything worked, let's remove a previous checkpoint if necessary.
 		while (completedCheckpoints.size() > maxNumberOfCheckpointsToRetain) {
 			final CompletedCheckpoint completedCheckpoint = completedCheckpoints.removeFirst();
-			tryRemoveCompletedCheckpoint(completedCheckpoint, CompletedCheckpoint::discardOnSubsume);
+			tryRemoveCompletedCheckpoint(completedCheckpoint, CompletedCheckpoint::discardOnSubsume, checkpointsCleaner, postCleanup);
 		}
 
 		LOG.debug("Added {} to {}.", checkpoint, path);
 	}
 
-	private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ThrowingConsumer<CompletedCheckpoint, Exception> discardCallback) {
+	private void tryRemoveCompletedCheckpoint(
+			CompletedCheckpoint completedCheckpoint,
+			ThrowingConsumer<CompletedCheckpoint, Exception> discardCallback,
+			CheckpointsCleaner checkpointsCleaner,
+			Runnable postCleanup) {
 		try {
 			if (tryRemove(completedCheckpoint.getCheckpointID())) {
-				// async exec on the ioExecutor (FixedThreadPool of configurable size or default 4*CPU cores)
-				// of CompletedCheckpoint.discardOnSubsume()
-				completedCheckpoint.asyncDiscardCheckpointAndCountCheckpoint(discardCallback, executor);
+				checkpointsCleaner.cleanCheckpoint(() -> {
+					try {
+						discardCallback.accept(completedCheckpoint);
+					} catch (Exception e) {
+						LOG.warn("Could not discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), e);
+					}
+				}, postCleanup, executor);
 			}
 		} catch (Exception e) {
 			LOG.warn("Failed to subsume the old checkpoint", e);
@@ -254,14 +262,16 @@ public class ZooKeeperCompletedCheckpointStore implements CompletedCheckpointSto
 	}
 
 	@Override
-	public void shutdown(JobStatus jobStatus) throws Exception {
+	public void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 		if (jobStatus.isGloballyTerminalState()) {
 			LOG.info("Shutting down");
 
 			for (CompletedCheckpoint checkpoint : completedCheckpoints) {
 				tryRemoveCompletedCheckpoint(
 					checkpoint,
-					completedCheckpoint -> completedCheckpoint.discardOnShutdown(jobStatus));
+					completedCheckpoint -> completedCheckpoint.discardOnShutdown(jobStatus),
+					checkpointsCleaner,
+					postCleanup);
 			}
 
 			completedCheckpoints.clear();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java
index 3514f5c8250..323f6a2726d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java
@@ -141,7 +141,7 @@ public class CheckpointCoordinatorFailureTest extends TestLogger {
 		}
 
 		@Override
-		public void addCheckpoint(CompletedCheckpoint checkpoint) throws Exception {
+		public void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 			throw new Exception("The failing completed checkpoint store failed again... :-(");
 		}
 
@@ -151,7 +151,7 @@ public class CheckpointCoordinatorFailureTest extends TestLogger {
 		}
 
 		@Override
-		public void shutdown(JobStatus jobStatus) throws Exception {
+		public void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 			throw new UnsupportedOperationException("Not implemented.");
 		}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java
index 5abe6df0bfe..3a8b512db15 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java
@@ -33,7 +33,6 @@ import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.memory.MemoryStateBackend;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.junit.Test;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
@@ -270,9 +269,8 @@ public class CheckpointCoordinatorMasterHooksTest {
 				Collections.<OperatorID, OperatorState>emptyMap(),
 				masterHookStates,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation(),
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+				new TestCompletedCheckpointStorageLocation()
+		);
 		final ExecutionAttemptID execId = new ExecutionAttemptID();
 		final ExecutionVertex ackVertex = mockExecutionVertex(execId);
 		final CheckpointCoordinator cc = instantiateCheckpointCoordinator(jid, ackVertex);
@@ -281,7 +279,8 @@ public class CheckpointCoordinatorMasterHooksTest {
 		cc.addMasterHook(statelessHook);
 		cc.addMasterHook(statefulHook2);
 
-		cc.getCheckpointStore().addCheckpoint(checkpoint);
+		cc.getCheckpointStore().addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 		cc.restoreLatestCheckpointedStateToAll(
 				Collections.emptySet(),
 				false);
@@ -323,9 +322,8 @@ public class CheckpointCoordinatorMasterHooksTest {
 				Collections.<OperatorID, OperatorState>emptyMap(),
 				masterHookStates,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation(),
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+				new TestCompletedCheckpointStorageLocation()
+		);
 
 		final ExecutionAttemptID execId = new ExecutionAttemptID();
 		final ExecutionVertex ackVertex = mockExecutionVertex(execId);
@@ -334,7 +332,8 @@ public class CheckpointCoordinatorMasterHooksTest {
 		cc.addMasterHook(statefulHook);
 		cc.addMasterHook(statelessHook);
 
-		cc.getCheckpointStore().addCheckpoint(checkpoint);
+		cc.getCheckpointStore().addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 
 		// since we have unmatched state, this should fail
 		try {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java
index fb43c008428..225ffea29fc 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java
@@ -23,7 +23,6 @@ import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTestingUtils.CheckpointCoordinatorBuilder;
-import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
 import org.apache.flink.runtime.executiongraph.Execution;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
@@ -42,7 +41,6 @@ import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.testutils.RecoverableCompletedCheckpointStore;
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.SerializableObject;
 import org.apache.flink.util.TestLogger;
 
@@ -198,7 +196,8 @@ public class CheckpointCoordinatorRestoringTest extends TestLogger {
 		assertEquals(1, completedCheckpoints.size());
 
 		// shutdown the store
-		store.shutdown(JobStatus.SUSPENDED);
+		store.shutdown(JobStatus.SUSPENDED, new CheckpointsCleaner(), () -> {
+		});
 
 		// restore the store
 		Set<ExecutionJobVertex> tasks = new HashSet<>();
@@ -805,15 +804,15 @@ public class CheckpointCoordinatorRestoringTest extends TestLogger {
 			operatorStates,
 			Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		// set up the coordinator and validate the initial state
 		CheckpointCoordinator coord =
 			new CheckpointCoordinatorBuilder()
 				.setTasks(newJobVertex1.getTaskVertices())
-				.setCompletedCheckpointStore(CompletedCheckpointStore.storeFor(completedCheckpoint))
+				.setCompletedCheckpointStore(CompletedCheckpointStore.storeFor(() -> {
+				}, completedCheckpoint))
 				.setTimer(manuallyTriggeredScheduledExecutor)
 				.build();
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
index a3207bbe088..5e5b457cec1 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
@@ -58,7 +58,6 @@ import org.apache.flink.runtime.state.memory.MemoryStateBackend;
 import org.apache.flink.runtime.state.memory.NonPersistentMetadataCheckpointStorageLocation;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 import org.apache.flink.runtime.testutils.RecoverableCompletedCheckpointStore;
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.TestLogger;
 
@@ -1998,9 +1997,9 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		store.addCheckpoint(new CompletedCheckpoint(new JobID(), 0, 0, 0,
 			Collections.<OperatorID, OperatorState>emptyMap(), Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback()));
+			new TestCompletedCheckpointStorageLocation()
+		), new CheckpointsCleaner(), () -> {
+		});
 
 		CheckpointStatsTracker tracker = mock(CheckpointStatsTracker.class);
 		checkpointCoordinator.setCheckpointStatsTracker(tracker);
@@ -2116,7 +2115,8 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		}
 
 		// shutdown the store
-		store.shutdown(JobStatus.SUSPENDED);
+		store.shutdown(JobStatus.SUSPENDED, new CheckpointsCleaner(), () -> {
+		});
 
 		// restore the store
 		Set<ExecutionJobVertex> tasks = new HashSet<>();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java
index b813d3456c3..e07cae24eec 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java
@@ -21,7 +21,6 @@ package org.apache.flink.runtime.checkpoint;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
-import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
@@ -31,7 +30,6 @@ import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.junit.Test;
 
 import java.io.ByteArrayOutputStream;
@@ -71,7 +69,7 @@ public class CheckpointMetadataLoadingTest {
 		final CompletedCheckpointStorageLocation testSavepoint = createSavepointWithOperatorSubtaskState(checkpointId, operatorId, parallelism);
 		final Map<JobVertexID, ExecutionJobVertex> tasks = createTasks(operatorId, parallelism, parallelism);
 
-		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(jobId, tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(jobId, tasks, testSavepoint, cl, false);
 
 		assertEquals(jobId, loaded.getJobId());
 		assertEquals(checkpointId, loaded.getCheckpointID());
@@ -89,7 +87,7 @@ public class CheckpointMetadataLoadingTest {
 		final Map<JobVertexID, ExecutionJobVertex> tasks = createTasks(operatorId, parallelism, parallelism + 1);
 
 		try {
-			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false);
 				fail("Did not throw expected Exception");
 		} catch (IllegalStateException expected) {
 			assertTrue(expected.getMessage().contains("Max parallelism mismatch"));
@@ -108,7 +106,7 @@ public class CheckpointMetadataLoadingTest {
 		final Map<JobVertexID, ExecutionJobVertex> tasks = Collections.emptyMap();
 
 		try {
-			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false);
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException expected) {
 			assertTrue(expected.getMessage().contains("allowNonRestoredState"));
@@ -126,7 +124,7 @@ public class CheckpointMetadataLoadingTest {
 		final CompletedCheckpointStorageLocation testSavepoint = createSavepointWithOperatorSubtaskState(242L, operatorId, parallelism);
 		final Map<JobVertexID, ExecutionJobVertex> tasks = Collections.emptyMap();
 
-		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, true, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, true);
 
 		assertTrue(loaded.getOperatorStates().isEmpty());
 	}
@@ -147,7 +145,7 @@ public class CheckpointMetadataLoadingTest {
 		final Map<JobVertexID, ExecutionJobVertex> tasks = Collections.emptyMap();
 
 		try {
-			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false);
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException expected) {
 			assertTrue(expected.getMessage().contains("allowNonRestoredState"));
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java
index f74e3c39a36..89676fc654d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java
@@ -21,7 +21,6 @@ package org.apache.flink.runtime.checkpoint;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTestingUtils.CheckpointCoordinatorBuilder;
-import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.executiongraph.Execution;
@@ -34,7 +33,6 @@ import org.apache.flink.runtime.messages.checkpoint.AcknowledgeCheckpoint;
 import org.apache.flink.runtime.state.KeyGroupRange;
 import org.apache.flink.runtime.state.KeyedStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.SerializableObject;
 
 import org.hamcrest.BaseMatcher;
@@ -240,11 +238,11 @@ public class CheckpointStateRestoreTest {
 			new HashMap<>(checkpointTaskStates),
 			Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
-		coord.getCheckpointStore().addCheckpoint(checkpoint);
+		coord.getCheckpointStore().addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 
 		assertTrue(coord.restoreLatestCheckpointedStateToAll(tasks, false));
 		assertTrue(coord.restoreLatestCheckpointedStateToAll(tasks, true));
@@ -269,11 +267,11 @@ public class CheckpointStateRestoreTest {
 			new HashMap<>(checkpointTaskStates),
 			Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
-		coord.getCheckpointStore().addCheckpoint(checkpoint);
+		coord.getCheckpointStore().addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 
 		// (i) Allow non restored state (should succeed)
 		final boolean restored = coord.restoreLatestCheckpointedStateToAll(tasks, true);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java
index eee285fd4fd..7afe4f1bb91 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java
@@ -25,7 +25,6 @@ import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.Assert;
@@ -83,11 +82,13 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 				createCheckpoint(0, sharedStateRegistry), createCheckpoint(1, sharedStateRegistry) };
 
 		// Add and get latest
-		checkpoints.addCheckpoint(expected[0]);
+		checkpoints.addCheckpoint(expected[0], new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(1, checkpoints.getNumberOfRetainedCheckpoints());
 		verifyCheckpoint(expected[0], checkpoints.getLatestCheckpoint(false));
 
-		checkpoints.addCheckpoint(expected[1]);
+		checkpoints.addCheckpoint(expected[1], new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(2, checkpoints.getNumberOfRetainedCheckpoints());
 		verifyCheckpoint(expected[1], checkpoints.getLatestCheckpoint(false));
 	}
@@ -107,11 +108,13 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 		};
 
 		// Add checkpoints
-		checkpoints.addCheckpoint(expected[0]);
+		checkpoints.addCheckpoint(expected[0], new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(1, checkpoints.getNumberOfRetainedCheckpoints());
 
 		for (int i = 1; i < expected.length; i++) {
-			checkpoints.addCheckpoint(expected[i]);
+			checkpoints.addCheckpoint(expected[i], new CheckpointsCleaner(), () -> {
+			});
 
 			// The ZooKeeper implementation discards asynchronously
 			expected[i - 1].awaitDiscard();
@@ -151,7 +154,8 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 		};
 
 		for (TestCompletedCheckpoint checkpoint : expected) {
-			checkpoints.addCheckpoint(checkpoint);
+			checkpoints.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+			});
 		}
 
 		List<CompletedCheckpoint> actual = checkpoints.getAllCheckpoints();
@@ -177,10 +181,12 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 		};
 
 		for (TestCompletedCheckpoint checkpoint : expected) {
-			checkpoints.addCheckpoint(checkpoint);
+			checkpoints.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+			});
 		}
 
-		checkpoints.shutdown(JobStatus.FINISHED);
+		checkpoints.shutdown(JobStatus.FINISHED, new CheckpointsCleaner(), () -> {
+		});
 
 		// Empty state
 		assertNull(checkpoints.getLatestCheckpoint(false));
@@ -219,7 +225,7 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 
 		operatorState.registerSharedStates(sharedStateRegistry);
 
-		return new TestCompletedCheckpoint(new JobID(), id, 0, operatorGroupState, props, new CheckpointsCleaner()::cleanCheckpoint);
+		return new TestCompletedCheckpoint(new JobID(), id, 0, operatorGroupState, props);
 	}
 
 	protected void verifyCheckpointRegistered(Collection<OperatorState> operatorStates, SharedStateRegistry registry) {
@@ -266,10 +272,9 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 				long checkpointId,
 				long timestamp,
 				Map<OperatorID, OperatorState> operatorGroupState,
-				CheckpointProperties props,
-				CheckpointsCleaningRunner checkpointsCleaningRunner) {
+				CheckpointProperties props) {
 
-			super(jobId, checkpointId, timestamp, Long.MAX_VALUE, operatorGroupState, null, props, new TestCompletedCheckpointStorageLocation(), checkpointsCleaningRunner, new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			super(jobId, checkpointId, timestamp, Long.MAX_VALUE, operatorGroupState, null, props, new TestCompletedCheckpointStorageLocation());
 		}
 
 		@Override
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java
index 7cdf39940a3..ad6c93e8ab6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java
@@ -18,19 +18,15 @@
 
 package org.apache.flink.runtime.checkpoint;
 
-import java.io.Serializable;
-import java.util.function.Consumer;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.core.testutils.CommonTestUtils;
-import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.testutils.EmptyStreamStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -64,18 +60,16 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			new JobID(), 1, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -98,18 +92,16 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			new JobID(), 1, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -136,18 +128,16 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			jobID, 1, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -171,18 +161,16 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			jobID2, 0, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -204,9 +192,8 @@ public class CompletedCheckpointTest {
 				operatorStates,
 				Collections.emptyList(),
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-				new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+				new TestCompletedCheckpointStorageLocation()
+		);
 
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 		checkpoint.registerSharedStatesAfterRestored(sharedStateRegistry);
@@ -233,9 +220,8 @@ public class CompletedCheckpointTest {
 				operatorStates,
 				Collections.emptyList(),
 				props,
-				location,
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+				location
+		);
 
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 		checkpoint.registerSharedStatesAfterRestored(sharedStateRegistry);
@@ -275,9 +261,8 @@ public class CompletedCheckpointTest {
 					new HashMap<>(operatorStates),
 					Collections.emptyList(),
 					retainProps,
-					retainedLocation,
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+					retainedLocation
+			);
 
 			checkpoint.discardOnShutdown(status);
 
@@ -298,9 +283,8 @@ public class CompletedCheckpointTest {
 					new HashMap<>(operatorStates),
 					Collections.emptyList(),
 					discardProps,
-					discardLocation,
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+					discardLocation
+			);
 
 			checkpoint.discardOnShutdown(status);
 
@@ -323,9 +307,8 @@ public class CompletedCheckpointTest {
 			Collections.emptyMap(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new TestCompletedCheckpointStorageLocation()
+		);
 
 		CompletedCheckpointStats.DiscardCallback callback = mock(CompletedCheckpointStats.DiscardCallback.class);
 		completed.setDiscardCallback(callback);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
index f60737b0b95..a38eb65d210 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
@@ -21,7 +21,6 @@ package org.apache.flink.runtime.checkpoint;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;
-import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.executiongraph.Execution;
 import org.apache.flink.runtime.executiongraph.ExecutionGraph;
@@ -220,7 +219,7 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 		}
 
 		@Override
-		public void addCheckpoint(CompletedCheckpoint checkpoint) {
+		public void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) {
 			throw new UnsupportedOperationException("Not implemented.");
 		}
 
@@ -230,7 +229,7 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 		}
 
 		@Override
-		public void shutdown(JobStatus jobStatus) {
+		public void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) {
 			shutdownStatus.complete(jobStatus);
 		}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
index eff89e4965a..b4ec5f7ca62 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
@@ -40,7 +40,6 @@ import org.apache.flink.runtime.state.TestingStreamStateHandle;
 import org.apache.flink.runtime.state.filesystem.FsCheckpointStorageLocation;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.hamcrest.Matchers;
 import org.junit.Assert;
 import org.junit.Rule;
@@ -113,7 +112,7 @@ public class PendingCheckpointTest {
 		assertFalse(pending.canBeSubsumed());
 
 		try {
-			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED);
+			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED, null, new CheckpointsCleaner(), () -> {});
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException ignored) {
 			// Expected
@@ -133,7 +132,7 @@ public class PendingCheckpointTest {
 		assertFalse(pending.canBeSubsumed());
 
 		try {
-			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED);
+			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED, null, new CheckpointsCleaner(), () -> {});
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException ignored) {
 			// Expected
@@ -153,7 +152,7 @@ public class PendingCheckpointTest {
 		CompletableFuture<CompletedCheckpoint> future = pending.getCompletionFuture();
 
 		assertFalse(future.isDone());
-		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 		assertTrue(future.isDone());
 
 		// Abort expired
@@ -161,7 +160,7 @@ public class PendingCheckpointTest {
 		future = pending.getCompletionFuture();
 
 		assertFalse(future.isDone());
-		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 		assertTrue(future.isDone());
 
 		// Abort subsumed
@@ -169,7 +168,7 @@ public class PendingCheckpointTest {
 		future = pending.getCompletionFuture();
 
 		assertFalse(future.isDone());
-		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 		assertTrue(future.isDone());
 
 		// Finalize (all ACK'd)
@@ -179,7 +178,8 @@ public class PendingCheckpointTest {
 		assertFalse(future.isDone());
 		pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics());
 		assertTrue(pending.areTasksFullyAcknowledged());
-		pending.finalizeCheckpoint(new CheckpointsUtils.NoOpCleanCheckpointCallback());
+		pending.finalizeCheckpoint(new CheckpointsCleaner(), () -> {
+		});
 		assertTrue(future.isDone());
 
 		// Finalize (missing ACKs)
@@ -188,7 +188,8 @@ public class PendingCheckpointTest {
 
 		assertFalse(future.isDone());
 		try {
-			pending.finalizeCheckpoint(new CheckpointsUtils.NoOpCleanCheckpointCallback());
+			pending.finalizeCheckpoint(new CheckpointsCleaner(), () -> {
+			});
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException ignored) {
 			// Expected
@@ -210,7 +211,7 @@ public class PendingCheckpointTest {
 		PendingCheckpoint pending = createPendingCheckpoint(props, executor);
 		setTaskState(pending, state);
 
-		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 		// execute asynchronous discard operation
 		executor.runQueuedCommands();
 		verify(state, times(1)).discardState();
@@ -221,7 +222,8 @@ public class PendingCheckpointTest {
 		pending = createPendingCheckpoint(props, executor);
 		setTaskState(pending, state);
 
-		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, new Exception("Expected Test Exception"));
+		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, new Exception("Expected Test Exception"), new CheckpointsCleaner(), () -> {
+		});
 		// execute asynchronous discard operation
 		executor.runQueuedCommands();
 		verify(state, times(1)).discardState();
@@ -232,7 +234,7 @@ public class PendingCheckpointTest {
 		pending = createPendingCheckpoint(props, executor);
 		setTaskState(pending, state);
 
-		pending.abort(CheckpointFailureReason.CHECKPOINT_EXPIRED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_EXPIRED, null, new CheckpointsCleaner(), () -> {});
 		// execute asynchronous discard operation
 		executor.runQueuedCommands();
 		verify(state, times(1)).discardState();
@@ -243,7 +245,7 @@ public class PendingCheckpointTest {
 		pending = createPendingCheckpoint(props, executor);
 		setTaskState(pending, state);
 
-		pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED, null, new CheckpointsCleaner(), () -> {});
 		// execute asynchronous discard operation
 		executor.runQueuedCommands();
 		verify(state, times(1)).discardState();
@@ -264,7 +266,8 @@ public class PendingCheckpointTest {
 			pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics());
 			verify(callback, times(1)).reportSubtaskStats(nullable(JobVertexID.class), any(SubtaskStateStats.class));
 
-			pending.finalizeCheckpoint(new CheckpointsUtils.NoOpCleanCheckpointCallback());
+			pending.finalizeCheckpoint(new CheckpointsCleaner(), () -> {
+			});
 			verify(callback, times(1)).reportCompletedCheckpoint(any(String.class));
 		}
 
@@ -275,7 +278,7 @@ public class PendingCheckpointTest {
 					CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
 			pending.setStatsCallback(callback);
 
-			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED);
+			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED, null, new CheckpointsCleaner(), () -> {});
 			verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class));
 		}
 
@@ -286,7 +289,7 @@ public class PendingCheckpointTest {
 					CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
 			pending.setStatsCallback(callback);
 
-			pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+			pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 			verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class));
 		}
 
@@ -297,7 +300,8 @@ public class PendingCheckpointTest {
 					CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
 			pending.setStatsCallback(callback);
 
-			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED, new Exception("Expected test error"));
+			pending.abort(CheckpointFailureReason.CHECKPOINT_SUBSUMED, new Exception("Expected test error"), new CheckpointsCleaner(), () -> {
+			});
 			verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class));
 		}
 
@@ -308,7 +312,7 @@ public class PendingCheckpointTest {
 					CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION));
 			pending.setStatsCallback(callback);
 
-			pending.abort(CheckpointFailureReason.CHECKPOINT_EXPIRED);
+			pending.abort(CheckpointFailureReason.CHECKPOINT_EXPIRED, null, new CheckpointsCleaner(), () -> {});
 			verify(callback, times(1)).reportFailedCheckpoint(anyLong(), any(Exception.class));
 		}
 	}
@@ -346,7 +350,7 @@ public class PendingCheckpointTest {
 		final CheckpointProperties props = new CheckpointProperties(false, CheckpointType.CHECKPOINT, true, true, true, true, true);
 
 		PendingCheckpoint aborted = createPendingCheckpoint(props);
-		aborted.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+		aborted.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 		assertTrue(aborted.isDiscarded());
 		assertFalse(aborted.setCancellerHandle(mock(ScheduledFuture.class)));
 
@@ -354,7 +358,7 @@ public class PendingCheckpointTest {
 		ScheduledFuture<?> canceller = mock(ScheduledFuture.class);
 
 		assertTrue(pending.setCancellerHandle(canceller));
-		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED);
+		pending.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {});
 		verify(canceller).cancel(false);
 	}
 
@@ -488,7 +492,7 @@ public class PendingCheckpointTest {
 		final TestingStreamStateHandle handle2 = new TestingStreamStateHandle();
 		final PendingCheckpoint checkpoint = createPendingCheckpointWithAcknowledgedCoordinators(handle1, handle2);
 
-		checkpoint.abort(CheckpointFailureReason.CHECKPOINT_EXPIRED);
+		checkpoint.abort(CheckpointFailureReason.CHECKPOINT_EXPIRED, null, new CheckpointsCleaner(), () -> {});
 
 		assertTrue(handle1.isDisposed());
 		assertTrue(handle2.isDisposed());
@@ -561,9 +565,7 @@ public class PendingCheckpointTest {
 			props,
 			location,
 			executor,
-			new CompletableFuture<>(),
-			new CheckpointsCleaner(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new CompletableFuture<>());
 	}
 
 	@SuppressWarnings("unchecked")
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java
index be39b2811ad..b53d9129689 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java
@@ -62,11 +62,13 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 		TestCompletedCheckpoint checkpoint = createCheckpoint(0, sharedStateRegistry);
 		Collection<OperatorState> operatorStates = checkpoint.getOperatorStates().values();
 
-		store.addCheckpoint(checkpoint);
+		store.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(1, store.getNumberOfRetainedCheckpoints());
 		verifyCheckpointRegistered(operatorStates, sharedStateRegistry);
 
-		store.shutdown(JobStatus.FINISHED);
+		store.shutdown(JobStatus.FINISHED, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(0, store.getNumberOfRetainedCheckpoints());
 		assertTrue(checkpoint.isDiscarded());
 		verifyCheckpointDiscarded(operatorStates);
@@ -83,11 +85,13 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 		TestCompletedCheckpoint checkpoint = createCheckpoint(0, sharedStateRegistry);
 		Collection<OperatorState> taskStates = checkpoint.getOperatorStates().values();
 
-		store.addCheckpoint(checkpoint);
+		store.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(1, store.getNumberOfRetainedCheckpoints());
 		verifyCheckpointRegistered(taskStates, sharedStateRegistry);
 
-		store.shutdown(JobStatus.SUSPENDED);
+		store.shutdown(JobStatus.SUSPENDED, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(0, store.getNumberOfRetainedCheckpoints());
 		assertTrue(checkpoint.isDiscarded());
 		verifyCheckpointDiscarded(taskStates);
@@ -110,7 +114,8 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 			doThrow(new IOException()).when(checkpointToAdd).discardOnSubsume();
 
 			try {
-				store.addCheckpoint(checkpointToAdd);
+				store.addCheckpoint(checkpointToAdd, new CheckpointsCleaner(), () -> {
+				});
 
 				// The checkpoint should be in the store if we successfully add it into the store.
 				List<CompletedCheckpoint> addedCheckpoints = store.getAllCheckpoints();
@@ -127,9 +132,12 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 	public void testPreferCheckpointWithoutSavepoint() throws Exception {
 		StandaloneCompletedCheckpointStore store = new StandaloneCompletedCheckpointStore(5);
 		JobID jobId = new JobID();
-		store.addCheckpoint(checkpoint(jobId, 1L));
-		store.addCheckpoint(checkpoint(jobId, 2L));
-		store.addCheckpoint(checkpoint(jobId, 3L));
+		store.addCheckpoint(checkpoint(jobId, 1L), new CheckpointsCleaner(), () -> {
+		});
+		store.addCheckpoint(checkpoint(jobId, 2L), new CheckpointsCleaner(), () -> {
+		});
+		store.addCheckpoint(checkpoint(jobId, 3L), new CheckpointsCleaner(), () -> {
+		});
 
 		CompletedCheckpoint latestCheckpoint = store.getLatestCheckpoint(true);
 
@@ -140,9 +148,12 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 	public void testPreferCheckpointWithSavepoint() throws Exception {
 		StandaloneCompletedCheckpointStore store = new StandaloneCompletedCheckpointStore(5);
 		JobID jobId = new JobID();
-		store.addCheckpoint(checkpoint(jobId, 1L));
-		store.addCheckpoint(savepoint(jobId, 2L));
-		store.addCheckpoint(savepoint(jobId, 3L));
+		store.addCheckpoint(checkpoint(jobId, 1L), new CheckpointsCleaner(), () -> {
+		});
+		store.addCheckpoint(savepoint(jobId, 2L), new CheckpointsCleaner(), () -> {
+		});
+		store.addCheckpoint(savepoint(jobId, 3L), new CheckpointsCleaner(), () -> {
+		});
 
 		CompletedCheckpoint latestCheckpoint = store.getLatestCheckpoint(true);
 
@@ -153,8 +164,10 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 	public void testPreferCheckpointWithOnlySavepoint() throws Exception {
 		StandaloneCompletedCheckpointStore store = new StandaloneCompletedCheckpointStore(5);
 		JobID jobId = new JobID();
-		store.addCheckpoint(savepoint(jobId, 1L));
-		store.addCheckpoint(savepoint(jobId, 2L));
+		store.addCheckpoint(savepoint(jobId, 1L), new CheckpointsCleaner(), () -> {
+		});
+		store.addCheckpoint(savepoint(jobId, 2L), new CheckpointsCleaner(), () -> {
+		});
 
 		CompletedCheckpoint latestCheckpoint = store.getLatestCheckpoint(true);
 
@@ -167,8 +180,8 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 			checkpointId,
 			checkpointId,
 			Collections.emptyMap(),
-			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new CheckpointsCleaner()::cleanCheckpoint);
+			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE)
+		);
 	}
 
 	private static CompletedCheckpoint savepoint(JobID jobId, long checkpointId) {
@@ -177,7 +190,7 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 			checkpointId,
 			checkpointId,
 			Collections.emptyMap(),
-			CheckpointProperties.forSavepoint(true),
-			new CheckpointsCleaner()::cleanCheckpoint);
+			CheckpointProperties.forSavepoint(true)
+		);
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java
index d94255963d6..4a49dee30c2 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java
@@ -108,9 +108,12 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		};
 
 		// Add multiple checkpoints
-		checkpoints.addCheckpoint(expected[0]);
-		checkpoints.addCheckpoint(expected[1]);
-		checkpoints.addCheckpoint(expected[2]);
+		checkpoints.addCheckpoint(expected[0], new CheckpointsCleaner(), () -> {
+		});
+		checkpoints.addCheckpoint(expected[1], new CheckpointsCleaner(), () -> {
+		});
+		checkpoints.addCheckpoint(expected[2], new CheckpointsCleaner(), () -> {
+		});
 
 		verifyCheckpointRegistered(expected[0].getOperatorStates().values(), sharedStateRegistry);
 		verifyCheckpointRegistered(expected[1].getOperatorStates().values(), sharedStateRegistry);
@@ -134,7 +137,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		expectedCheckpoints.add(expected[2]);
 		expectedCheckpoints.add(createCheckpoint(3, sharedStateRegistry));
 
-		checkpoints.addCheckpoint(expectedCheckpoints.get(2));
+		checkpoints.addCheckpoint(expectedCheckpoints.get(2), new CheckpointsCleaner(), () -> {
+		});
 
 		List<CompletedCheckpoint> actualCheckpoints = checkpoints.getAllCheckpoints();
 
@@ -156,11 +160,13 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		CompletedCheckpointStore store = createCompletedCheckpoints(1);
 		TestCompletedCheckpoint checkpoint = createCheckpoint(0, sharedStateRegistry);
 
-		store.addCheckpoint(checkpoint);
+		store.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(1, store.getNumberOfRetainedCheckpoints());
 		assertNotNull(client.checkExists().forPath(CHECKPOINT_PATH + ZooKeeperCompletedCheckpointStore.checkpointIdToPath(checkpoint.getCheckpointID())));
 
-		store.shutdown(JobStatus.FINISHED);
+		store.shutdown(JobStatus.FINISHED, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(0, store.getNumberOfRetainedCheckpoints());
 		assertNull(client.checkExists().forPath(CHECKPOINT_PATH + ZooKeeperCompletedCheckpointStore.checkpointIdToPath(checkpoint.getCheckpointID())));
 
@@ -183,11 +189,13 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		CompletedCheckpointStore store = createCompletedCheckpoints(1);
 		TestCompletedCheckpoint checkpoint = createCheckpoint(0, sharedStateRegistry);
 
-		store.addCheckpoint(checkpoint);
+		store.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+		});
 		assertEquals(1, store.getNumberOfRetainedCheckpoints());
 		assertNotNull(client.checkExists().forPath(CHECKPOINT_PATH + ZooKeeperCompletedCheckpointStore.checkpointIdToPath(checkpoint.getCheckpointID())));
 
-		store.shutdown(JobStatus.SUSPENDED);
+		store.shutdown(JobStatus.SUSPENDED, new CheckpointsCleaner(), () -> {
+		});
 
 		assertEquals(0, store.getNumberOfRetainedCheckpoints());
 
@@ -222,7 +230,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		checkpoints.add(createCheckpoint(11, sharedStateRegistry));
 
 		for (CompletedCheckpoint checkpoint : checkpoints) {
-			checkpointStore.addCheckpoint(checkpoint);
+			checkpointStore.addCheckpoint(checkpoint, new CheckpointsCleaner(), () -> {
+			});
 		}
 
 		sharedStateRegistry.close();
@@ -252,7 +261,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		TestCompletedCheckpoint completedCheckpoint = createCheckpoint(1, sharedStateRegistry);
 
 		// complete the first checkpoint
-		zkCheckpointStore1.addCheckpoint(completedCheckpoint);
+		zkCheckpointStore1.addCheckpoint(completedCheckpoint, new CheckpointsCleaner(), () -> {
+		});
 
 		// recover the checkpoint by a different checkpoint store
 		sharedStateRegistry.close();
@@ -269,7 +279,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		// complete another checkpoint --> this should remove the first checkpoint from the store
 		// because the number of retained checkpoints == 1
 		TestCompletedCheckpoint completedCheckpoint2 = createCheckpoint(2, sharedStateRegistry);
-		zkCheckpointStore1.addCheckpoint(completedCheckpoint2);
+		zkCheckpointStore1.addCheckpoint(completedCheckpoint2, new CheckpointsCleaner(), () -> {
+		});
 
 		List<CompletedCheckpoint> allCheckpoints = zkCheckpointStore1.getAllCheckpoints();
 
@@ -285,7 +296,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		TestCompletedCheckpoint completedCheckpoint3 = createCheckpoint(3, sharedStateRegistry);
 
 		// this should release the last lock on completedCheckpoint and thus discard it
-		zkCheckpointStore2.addCheckpoint(completedCheckpoint3);
+		zkCheckpointStore2.addCheckpoint(completedCheckpoint3, new CheckpointsCleaner(), () -> {
+		});
 
 		// the checkpoint should be discarded eventually because there is no lock on it anymore
 		recoveredTestCheckpoint.awaitDiscard();
@@ -313,9 +325,10 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		for (int i = 1; i <= nbCheckpointsToInject; i++) {
 			// add checkpoints to clean, the ManuallyTriggeredScheduledExecutor.execute() just queues the runnables but does not execute them.
 			TestCompletedCheckpoint completedCheckpoint = new TestCompletedCheckpoint(new JobID(), i,
-				i, Collections.emptyMap(), CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-				checkpointsCleaner::cleanCheckpoint);
-			checkpointStore.addCheckpoint(completedCheckpoint);
+				i, Collections.emptyMap(), CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE)
+			);
+			checkpointStore.addCheckpoint(completedCheckpoint, checkpointsCleaner, () -> {
+			});
 		}
 
 		int nbCheckpointsSubmittedForCleaning = nbCheckpointsToInject - maxCheckpointsToRetain;
@@ -333,7 +346,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		assertTrue(checkpointsCleaner.getNumberOfCheckpointsToClean() < nbCheckpointsSubmittedForCleaning);
 		// checkpointing is resumed because checkpointsCleaner.getNumberOfCheckpointsToClean() <= maxCleaningCheckpoints
 		assertTrue(checkpointRequestDecider.chooseRequestToExecute(regularCheckpoint(), false, 0).isPresent());
-		checkpointStore.shutdown(JobStatus.FINISHED);
+		checkpointStore.shutdown(JobStatus.FINISHED, checkpointsCleaner, () -> {
+		});
 	}
 
 	static class HeapRetrievableStateHandle<T extends Serializable> implements RetrievableStateHandle<T> {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java
index 5355d05c369..8e2a0151e89 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java
@@ -23,7 +23,6 @@ import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;
 import org.apache.flink.util.TestLogger;
@@ -98,9 +97,8 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation(),
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback()));
+				new TestCompletedCheckpointStorageLocation()
+			));
 
 		final RetrievableStateHandle<CompletedCheckpoint> retrievableStateHandle2 = mock(RetrievableStateHandle.class);
 		when(retrievableStateHandle2.retrieveState()).then(
@@ -112,9 +110,8 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation(),
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback())));
+				new TestCompletedCheckpointStorageLocation()
+			)));
 
 		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, "/foobar1"));
 		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, "/failing1"));
@@ -226,9 +223,8 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation(),
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback()));
+				new TestCompletedCheckpointStorageLocation()
+			));
 
 		final RetrievableStateHandle<CompletedCheckpoint> retrievableStateHandle2 = mock(RetrievableStateHandle.class);
 		when(retrievableStateHandle2.retrieveState()).then(
@@ -240,9 +236,8 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forSavepoint(true),
-				new TestCompletedCheckpointStorageLocation(),
-				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback())));
+				new TestCompletedCheckpointStorageLocation()
+			)));
 
 		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, "/foobar1"));
 		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, "/failing1"));
@@ -363,7 +358,8 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 			doReturn(Collections.emptyMap()).when(checkpointToAdd).getOperatorStates();
 
 			try {
-				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd);
+				zooKeeperCompletedCheckpointStore.addCheckpoint(checkpointToAdd, new CheckpointsCleaner(), () -> {
+				});
 
 				// The checkpoint should be in the store if we successfully add it into the store.
 				List<CompletedCheckpoint> addedCheckpoints = zooKeeperCompletedCheckpointStore.getAllCheckpoints();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java
index f18c2dd1938..a691279b639 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreTest.java
@@ -73,11 +73,13 @@ public class ZooKeeperCompletedCheckpointStoreTest extends TestLogger {
 		try {
 			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
 
-			checkpointStore.addCheckpoint(checkpoint1);
+			checkpointStore.addCheckpoint(checkpoint1, new CheckpointsCleaner(), () -> {
+			});
 			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
 
 			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint2 = CompletedCheckpointStoreTest.createCheckpoint(1, sharedStateRegistry);
-			checkpointStore.addCheckpoint(checkpoint2);
+			checkpointStore.addCheckpoint(checkpoint2, new CheckpointsCleaner(), () -> {
+			});
 			final List<CompletedCheckpoint> allCheckpoints = checkpointStore.getAllCheckpoints();
 			assertThat(allCheckpoints, Matchers.contains(checkpoint2));
 			assertThat(allCheckpoints, Matchers.not(Matchers.contains(checkpoint1)));
@@ -105,10 +107,12 @@ public class ZooKeeperCompletedCheckpointStoreTest extends TestLogger {
 		try {
 			final CompletedCheckpointStoreTest.TestCompletedCheckpoint checkpoint1 = CompletedCheckpointStoreTest.createCheckpoint(0, sharedStateRegistry);
 
-			checkpointStore.addCheckpoint(checkpoint1);
+			checkpointStore.addCheckpoint(checkpoint1, new CheckpointsCleaner(), () -> {
+			});
 			assertThat(checkpointStore.getAllCheckpoints(), Matchers.contains(checkpoint1));
 
-			checkpointStore.shutdown(JobStatus.FINISHED);
+			checkpointStore.shutdown(JobStatus.FINISHED, new CheckpointsCleaner(), () -> {
+			});
 
 			// verify that the checkpoint is discarded
 			CompletedCheckpointStoreTest.verifyCheckpointDiscarded(checkpoint1);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
index 5956d12d0ab..795839e95ca 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
@@ -41,6 +41,7 @@ import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.checkpoint.CheckpointProperties;
 import org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy;
 import org.apache.flink.runtime.checkpoint.Checkpoints;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.OperatorState;
 import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
@@ -127,7 +128,6 @@ import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;
 import org.apache.flink.runtime.testtasks.BlockingNoOpInvokable;
 import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
-import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.testutils.ClassLoaderUtils;
 import org.apache.flink.util.ExceptionUtils;
@@ -828,12 +828,12 @@ public class JobMasterTest extends TestLogger {
 			Collections.emptyMap(),
 			null,
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new DummyCheckpointStorageLocation(),
-			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
-			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+			new DummyCheckpointStorageLocation()
+		);
 
 		final StandaloneCompletedCheckpointStore completedCheckpointStore = new StandaloneCompletedCheckpointStore(1);
-		completedCheckpointStore.addCheckpoint(completedCheckpoint);
+		completedCheckpointStore.addCheckpoint(completedCheckpoint, new CheckpointsCleaner(), () -> {
+		});
 		final TestingCheckpointRecoveryFactory testingCheckpointRecoveryFactory = new TestingCheckpointRecoveryFactory(completedCheckpointStore, new StandaloneCheckpointIDCounter());
 		haServices.setCheckpointRecoveryFactory(testingCheckpointRecoveryFactory);
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/RecoverableCompletedCheckpointStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/RecoverableCompletedCheckpointStore.java
index bc3ab295424..ba2dec0cc2e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/RecoverableCompletedCheckpointStore.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/RecoverableCompletedCheckpointStore.java
@@ -19,6 +19,7 @@
 package org.apache.flink.runtime.testutils;
 
 import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
 import org.apache.flink.util.Preconditions;
@@ -60,7 +61,7 @@ public class RecoverableCompletedCheckpointStore implements CompletedCheckpointS
 	}
 
 	@Override
-	public void addCheckpoint(CompletedCheckpoint checkpoint) throws Exception {
+	public void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 
 		checkpoints.addLast(checkpoint);
 
@@ -75,7 +76,7 @@ public class RecoverableCompletedCheckpointStore implements CompletedCheckpointS
 	}
 
 	@Override
-	public void shutdown(JobStatus jobStatus) throws Exception {
+	public void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 		if (jobStatus.isGloballyTerminalState()) {
 			checkpoints.clear();
 			suspended.clear();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/CheckpointsUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/CheckpointsUtils.java
deleted file mode 100644
index a476c9dc821..00000000000
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/util/CheckpointsUtils.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.util;
-
-import java.util.concurrent.Executor;
-import org.apache.flink.runtime.checkpoint.CheckpointsCleaningRunner;
-import org.apache.flink.runtime.checkpoint.SerializableRunnable;
-
-public class CheckpointsUtils {
-	public static class NoOpCheckpointCleaningFinishedCallback implements SerializableRunnable {
-
-		@Override public void run() {
-		}
-	}
-
-	public static class NoOpCleanCheckpointCallback implements CheckpointsCleaningRunner {
-
-		@Override public void accept(Runnable cleanAction, Runnable postCleanAction,
-			Executor executor) {
-
-		}
-	}
-}
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/NotifyCheckpointAbortedITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/NotifyCheckpointAbortedITCase.java
index a0c0c753fe4..a850dc317c5 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/NotifyCheckpointAbortedITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/NotifyCheckpointAbortedITCase.java
@@ -36,6 +36,7 @@ import org.apache.flink.core.fs.Path;
 import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.StandaloneCheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.StandaloneCompletedCheckpointStore;
@@ -421,9 +422,9 @@ public class NotifyCheckpointAbortedITCase extends TestLogger {
 		}
 
 		@Override
-		public void addCheckpoint(CompletedCheckpoint checkpoint) throws Exception {
+		public void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
 			if (abortCheckpointLatch.isTriggered()) {
-				super.addCheckpoint(checkpoint);
+				super.addCheckpoint(checkpoint, checkpointsCleaner, postCleanup);
 			} else {
 				// tell main thread that all checkpoints on task side have been finished.
 				addCheckpointLatch.trigger();
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RegionFailoverITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RegionFailoverITCase.java
index 3459e54f92b..976b8957f70 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RegionFailoverITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RegionFailoverITCase.java
@@ -32,6 +32,7 @@ import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.StandaloneCheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.StandaloneCompletedCheckpointStore;
@@ -427,8 +428,8 @@ public class RegionFailoverITCase extends TestLogger {
 		}
 
 		@Override
-		public void addCheckpoint(CompletedCheckpoint checkpoint) throws Exception {
-			super.addCheckpoint(checkpoint);
+		public void addCheckpoint(CompletedCheckpoint checkpoint, CheckpointsCleaner checkpointsCleaner, Runnable postCleanup) throws Exception {
+			super.addCheckpoint(checkpoint, checkpointsCleaner, postCleanup);
 			// we record the information when adding completed checkpoint instead of 'notifyCheckpointComplete' invoked
 			// on task side to avoid race condition. See FLINK-13601.
 			lastCompletedCheckpointId.set(checkpoint.getCheckpointID());
