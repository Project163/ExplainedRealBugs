diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/calcite/PreValidateReWriter.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/calcite/PreValidateReWriter.scala
index 1ba6643dc29..985f252e406 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/calcite/PreValidateReWriter.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/calcite/PreValidateReWriter.scala
@@ -234,13 +234,16 @@ object PreValidateReWriter {
 
     call.getKind match {
       case SqlKind.SELECT =>
-        rewriteSelect(
-          validator,
-          call.asInstanceOf[SqlSelect],
-          targetRowType,
-          assignedFields,
-          targetPosition)
+        val sqlSelect = call.asInstanceOf[SqlSelect]
+
+        if (targetPosition.nonEmpty && sqlSelect.getSelectList.size() != targetPosition.size()) {
+          throw newValidationError(call, RESOURCE.columnCountMismatch())
+        }
+        rewriteSelect(validator, sqlSelect, targetRowType, assignedFields, targetPosition)
       case SqlKind.VALUES =>
+        if (targetPosition.nonEmpty && call.operandCount() != targetPosition.size()) {
+          throw newValidationError(call, RESOURCE.columnCountMismatch())
+        }
         rewriteValues(call, targetRowType, assignedFields, targetPosition)
       case kind if SqlKind.SET_QUERY.contains(kind) =>
         call.getOperandList.zipWithIndex.foreach {
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/calcite/FlinkCalciteSqlValidatorTest.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/calcite/FlinkCalciteSqlValidatorTest.java
index 60b15ed5ef3..6485217dc26 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/calcite/FlinkCalciteSqlValidatorTest.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/calcite/FlinkCalciteSqlValidatorTest.java
@@ -33,7 +33,13 @@ class FlinkCalciteSqlValidatorTest {
     private final PlannerMocks plannerMocks =
             PlannerMocks.create()
                     .registerTemporaryTable(
-                            "t1", Schema.newBuilder().column("a", DataTypes.INT()).build());
+                            "t1", Schema.newBuilder().column("a", DataTypes.INT()).build())
+                    .registerTemporaryTable(
+                            "t2",
+                            Schema.newBuilder()
+                                    .column("a", DataTypes.INT())
+                                    .column("b", DataTypes.INT())
+                                    .build());
 
     @Test
     void testUpsertInto() {
@@ -43,6 +49,20 @@ class FlinkCalciteSqlValidatorTest {
                         "UPSERT INTO statement is not supported. Please use INSERT INTO instead.");
     }
 
+    @Test
+    void testInsertInto1() {
+        assertThatThrownBy(() -> plannerMocks.getParser().parse("INSERT INTO t2 (a,b) VALUES(1)"))
+                .isInstanceOf(ValidationException.class)
+                .hasMessageContaining(" Number of columns must match number of query columns");
+    }
+
+    @Test
+    void testInsertInto2() {
+        assertThatThrownBy(() -> plannerMocks.getParser().parse("INSERT INTO t2 (a,b) SELECT 1"))
+                .isInstanceOf(ValidationException.class)
+                .hasMessageContaining(" Number of columns must match number of query columns");
+    }
+
     @Test
     void testExplainUpsertInto() {
         assertThatThrownBy(() -> plannerMocks.getParser().parse("EXPLAIN UPSERT INTO t1 VALUES(1)"))
