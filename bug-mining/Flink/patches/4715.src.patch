diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java
index 4d42721530f..fdf27c4a110 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java
@@ -948,7 +948,7 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution
 	 */
 	@Override
 	public void fail(Throwable t) {
-		processFail(t, false);
+		processFail(t, true);
 	}
 
 	/**
@@ -1080,7 +1080,7 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution
 	 * @param t The exception that caused the task to fail.
 	 */
 	void markFailed(Throwable t) {
-		processFail(t, true);
+		processFail(t, false);
 	}
 
 	/**
@@ -1093,7 +1093,7 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution
 	}
 
 	void markFailed(Throwable t, Map<String, Accumulator<?, ?>> userAccumulators, IOMetrics metrics, boolean fromSchedulerNg) {
-		processFail(t, true, userAccumulators, metrics, false, fromSchedulerNg);
+		processFail(t, false, userAccumulators, metrics, false, fromSchedulerNg);
 	}
 
 	@VisibleForTesting
@@ -1248,13 +1248,35 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution
 		return getVertex().isLegacyScheduling();
 	}
 
-	private void processFail(Throwable t, boolean isCallback) {
-		processFail(t, isCallback, null, null, true, false);
+	private void processFail(Throwable t, boolean cancelTask) {
+		processFail(t, cancelTask, null, null, true, false);
 	}
 
+	/**
+	 * Process a execution failure. The failure can be fired by JobManager or reported by
+	 * TaskManager. If it is fired by JobManager and the execution is already deployed, it
+	 * needs to send a PRC call to remove the task from TaskManager. It also needs to release
+	 * the produced partitions if it fails before deployed (because the partitions are possibly
+	 * already created in external shuffle service) or JobManager proactively fails it (in case
+	 * that it finishes in TaskManager when JobManager tries to fail it). The failure will be
+	 * notified to SchedulerNG if it is from within the ExecutionGraph. This is to trigger the
+	 * failure handling of SchedulerNG to recover this failed execution.
+	 *
+	 * @param t Failure cause
+	 * @param cancelTask Indicating whether to send a PRC call to remove task from TaskManager.
+	 *                   True if the failure is fired by JobManager and the execution is already
+	 *                   deployed. Otherwise it should be false.
+	 * @param userAccumulators User accumulators
+	 * @param metrics IO metrics
+	 * @param releasePartitions Indicating whether to release result partitions produced by this
+	 *                          execution. False if the task is FAILED in TaskManager, otherwise
+	 *                          true.
+	 * @param fromSchedulerNg Indicating whether the failure is from the SchedulerNg. It should
+	 *                        be false if it is from within the ExecutionGraph.
+	 */
 	private void processFail(
 			Throwable t,
-			boolean isCallback,
+			boolean cancelTask,
 			Map<String, Accumulator<?, ?>> userAccumulators,
 			IOMetrics metrics,
 			boolean releasePartitions,
@@ -1290,7 +1312,7 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution
 			// always set to false, isCallback to true and fromSchedulerNg set to true.
 			// Because the original value of releasePartitions and isCallback will be lost,
 			// we may need to invoke partition release and remote canceling here.
-			maybeReleasePartitionsAndSendCancelRpcCall(current, isCallback, releasePartitions);
+			maybeReleasePartitionsAndSendCancelRpcCall(current, cancelTask, releasePartitions);
 
 			return;
 		}
@@ -1306,18 +1328,18 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution
 		vertex.getExecutionGraph().deregisterExecution(this);
 
 		if (isLegacyScheduling()) {
-			maybeReleasePartitionsAndSendCancelRpcCall(current, isCallback, releasePartitions);
+			maybeReleasePartitionsAndSendCancelRpcCall(current, cancelTask, releasePartitions);
 		}
 	}
 
 	private void maybeReleasePartitionsAndSendCancelRpcCall(
 			final ExecutionState stateBeforeFailed,
-			final boolean isCallback,
+			final boolean cancelTask,
 			final boolean releasePartitions) {
 
 		handlePartitionCleanup(releasePartitions, releasePartitions);
 
-		if (!isCallback && (stateBeforeFailed == RUNNING || stateBeforeFailed == DEPLOYING)) {
+		if (cancelTask && (stateBeforeFailed == RUNNING || stateBeforeFailed == DEPLOYING)) {
 			if (LOG.isDebugEnabled()) {
 				LOG.debug("Sending out cancel request, to remove task execution from TaskManager.");
 			}
