diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/FileUploadHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/FileUploadHandler.java
index a957b636da7..d6287507697 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/FileUploadHandler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/FileUploadHandler.java
@@ -41,6 +41,7 @@ import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.multipart.Http
 import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
 import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.multipart.InterfaceHttpData;
 import org.apache.flink.shaded.netty4.io.netty.util.AttributeKey;
+import org.apache.flink.shaded.netty4.io.netty.util.ReferenceCountUtil;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -80,7 +81,7 @@ public class FileUploadHandler extends SimpleChannelInboundHandler<HttpObject> {
 	private Path currentUploadDir;
 
 	public FileUploadHandler(final Path uploadDir) {
-		super(false);
+		super(true);
 		DiskFileUpload.baseDirectory = uploadDir.normalize().toAbsolutePath().toString();
 		this.uploadDir = requireNonNull(uploadDir);
 	}
@@ -93,14 +94,17 @@ public class FileUploadHandler extends SimpleChannelInboundHandler<HttpObject> {
 				LOG.trace("Received request. URL:{} Method:{}", httpRequest.getUri(), httpRequest.getMethod());
 				if (httpRequest.getMethod().equals(HttpMethod.POST)) {
 					if (HttpPostRequestDecoder.isMultipart(httpRequest)) {
+						checkState(currentHttpPostRequestDecoder == null);
+						checkState(currentHttpRequest == null);
+						checkState(currentUploadDir == null);
 						currentHttpPostRequestDecoder = new HttpPostRequestDecoder(DATA_FACTORY, httpRequest);
-						currentHttpRequest = httpRequest;
+						currentHttpRequest = ReferenceCountUtil.retain(httpRequest);
 						currentUploadDir = Files.createDirectory(uploadDir.resolve(UUID.randomUUID().toString()));
 					} else {
-						ctx.fireChannelRead(msg);
+						ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
 					}
 				} else {
-					ctx.fireChannelRead(msg);
+					ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
 				}
 			} else if (msg instanceof HttpContent && currentHttpPostRequestDecoder != null) {
 				// make sure that we still have a upload dir in case that it got deleted in the meanwhile
@@ -135,12 +139,12 @@ public class FileUploadHandler extends SimpleChannelInboundHandler<HttpObject> {
 					if (currentJsonPayload != null) {
 						ctx.fireChannelRead(httpContent.replace(Unpooled.wrappedBuffer(currentJsonPayload)));
 					} else {
-						ctx.fireChannelRead(httpContent);
+						ctx.fireChannelRead(ReferenceCountUtil.retain(httpContent));
 					}
 					reset();
 				}
 			} else {
-				ctx.fireChannelRead(msg);
+				ctx.fireChannelRead(ReferenceCountUtil.retain(msg));
 			}
 		} catch (Exception e) {
 			handleError(ctx, "File upload failed.", HttpResponseStatus.INTERNAL_SERVER_ERROR, e);
@@ -159,6 +163,7 @@ public class FileUploadHandler extends SimpleChannelInboundHandler<HttpObject> {
 			responseStatus,
 			Collections.emptyMap()
 		);
+		ReferenceCountUtil.release(tmpRequest);
 	}
 
 	private void deleteUploadedFiles() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyLeakDetectionResource.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyLeakDetectionResource.java
new file mode 100644
index 00000000000..027f454d2fe
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyLeakDetectionResource.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.io.network.netty;
+
+import org.apache.flink.shaded.netty4.io.netty.util.ResourceLeakDetector;
+import org.apache.flink.shaded.netty4.io.netty.util.ResourceLeakDetectorFactory;
+
+import org.junit.rules.ExternalResource;
+
+import javax.annotation.concurrent.GuardedBy;
+
+import static org.junit.Assert.fail;
+
+/**
+ * JUnit resource to fail with an assertion when Netty detects a resource leak (only with
+ * <tt>ERROR</tt> logging enabled for
+ * <tt>org.apache.flink.shaded.netty4.io.netty.util.ResourceLeakDetector</tt>).
+ *
+ * <p>This should be used in a class rule:
+ * <pre>{@code
+ * @literal @ClassRule
+ *  public static final NettyLeakDetectionResource LEAK_DETECTION = new NettyLeakDetectionResource();
+ * }</pre>
+ */
+public class NettyLeakDetectionResource extends ExternalResource {
+	@GuardedBy("refCountLock")
+	private static ResourceLeakDetectorFactory previousLeakDetector;
+
+	@GuardedBy("refCountLock")
+	private static ResourceLeakDetector.Level previousLeakDetectorLevel;
+
+	private static final Object refCountLock = new Object();
+	private static int refCount = 0;
+
+	@Override
+	protected void before() {
+		synchronized (refCountLock) {
+			if (refCount == 0) {
+				previousLeakDetector = ResourceLeakDetectorFactory.instance();
+				previousLeakDetectorLevel = ResourceLeakDetector.getLevel();
+
+				++refCount;
+				ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);
+				ResourceLeakDetectorFactory
+					.setResourceLeakDetectorFactory(new FailingResourceLeakDetectorFactory());
+			}
+		}
+	}
+
+	@Override
+	protected synchronized void after() {
+		synchronized (refCountLock) {
+			--refCount;
+			if (refCount == 0) {
+				ResourceLeakDetectorFactory.setResourceLeakDetectorFactory(previousLeakDetector);
+				ResourceLeakDetector.setLevel(previousLeakDetectorLevel);
+			}
+		}
+	}
+
+	private static class FailingResourceLeakDetectorFactory extends ResourceLeakDetectorFactory {
+		public <T> ResourceLeakDetector<T> newResourceLeakDetector(
+			Class<T> resource, int samplingInterval, long maxActive) {
+			return new FailingResourceLeakDetector<T>(resource, samplingInterval, maxActive);
+		}
+	}
+
+	private static class FailingResourceLeakDetector<T> extends ResourceLeakDetector<T> {
+		FailingResourceLeakDetector(Class<?> resourceType, int samplingInterval, long maxActive) {
+			super(resourceType, samplingInterval, maxActive);
+		}
+
+		@Override
+		protected void reportTracedLeak(String resourceType, String records) {
+			super.reportTracedLeak(resourceType, records);
+			fail(String.format("LEAK: %s.release() was not called before it's garbage-collected.%s",
+				resourceType, records));
+		}
+
+		@Override
+		protected void reportUntracedLeak(String resourceType) {
+			super.reportUntracedLeak(resourceType);
+			fail(String.format("LEAK: %s.release() was not called before it's garbage-collected.",
+				resourceType));
+		}
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/FileUploadHandlerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/FileUploadHandlerTest.java
index 6818406b708..858c6620b3c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/FileUploadHandlerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/FileUploadHandlerTest.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.rest;
 
+import org.apache.flink.runtime.io.network.netty.NettyLeakDetectionResource;
 import org.apache.flink.runtime.rest.util.RestMapperUtils;
 import org.apache.flink.util.TestLogger;
 
@@ -50,6 +51,9 @@ public class FileUploadHandlerTest extends TestLogger {
 
 	private static final ObjectMapper OBJECT_MAPPER = RestMapperUtils.getStrictObjectMapper();
 
+	@ClassRule
+	public static final NettyLeakDetectionResource LEAK_DETECTION = new NettyLeakDetectionResource();
+
 	@After
 	public void reset() {
 		MULTIPART_UPLOAD_RESOURCE.resetState();
diff --git a/flink-runtime/src/test/resources/log4j-test.properties b/flink-runtime/src/test/resources/log4j-test.properties
index d7ef9d46e5c..2778b7fd9c5 100644
--- a/flink-runtime/src/test/resources/log4j-test.properties
+++ b/flink-runtime/src/test/resources/log4j-test.properties
@@ -28,3 +28,5 @@ log4j.appender.testlogger.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n
 
 # Suppress the irrelevant (wrong) warnings from the Netty channel handler
 log4j.logger.org.apache.flink.shaded.akka.org.jboss.netty.channel.DefaultChannelPipeline=ERROR, testlogger
+# Resource leak detector only works with logging enabled at error level
+log4j.logger.org.apache.flink.shaded.netty4.io.netty.util.ResourceLeakDetector=ERROR, testlogger
