diff --git a/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java b/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java
index 09216420e1d..7466e325480 100644
--- a/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java
+++ b/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java
@@ -100,6 +100,7 @@ import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.function.CheckedSupplier;
 
 import org.apache.flink.shaded.netty4.io.netty.channel.ConnectTimeoutException;
+import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpResponseStatus;
 
 import akka.actor.AddressFromURIString;
 
@@ -274,7 +275,9 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 		final JobMessageParameters  params = new JobMessageParameters();
 		params.jobPathParameter.resolve(jobId);
 
-		CompletableFuture<JobDetailsInfo> responseFuture = sendRequest(detailsHeaders, params);
+		CompletableFuture<JobDetailsInfo> responseFuture = sendRequest(
+			detailsHeaders,
+			params);
 
 		return responseFuture.thenApply(JobDetailsInfo::getJobStatus);
 	}
@@ -293,11 +296,9 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 			() -> {
 				final JobMessageParameters messageParameters = new JobMessageParameters();
 				messageParameters.jobPathParameter.resolve(jobId);
-				return sendRetryableRequest(
+				return sendRequest(
 					JobExecutionResultHeaders.getInstance(),
-					messageParameters,
-					EmptyRequestBody.getInstance(),
-					isConnectionProblemException().or(isHttpStatusUnsuccessfulException()));
+					messageParameters);
 			});
 	}
 
@@ -313,8 +314,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 		jobGraph.setAllowQueuedScheduling(true);
 
 		log.info("Requesting blob server port.");
-		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(
-			BlobServerPortHeaders.getInstance());
+		CompletableFuture<BlobServerPortResponseBody> portFuture = sendRequest(BlobServerPortHeaders.getInstance());
 
 		CompletableFuture<JobGraph> jobUploadFuture = portFuture.thenCombine(
 			getDispatcherAddress(),
@@ -366,8 +366,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 		params.terminationModeQueryParameter.resolve(Collections.singletonList(TerminationModeQueryParameter.TerminationMode.STOP));
 		CompletableFuture<EmptyResponseBody> responseFuture = sendRequest(
 			JobTerminationHeaders.getInstance(),
-			params
-		);
+			params);
 		responseFuture.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
 	}
 
@@ -378,8 +377,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 		params.terminationModeQueryParameter.resolve(Collections.singletonList(TerminationModeQueryParameter.TerminationMode.CANCEL));
 		CompletableFuture<EmptyResponseBody> responseFuture = sendRequest(
 			JobTerminationHeaders.getInstance(),
-			params
-		);
+			params);
 		responseFuture.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
 	}
 
@@ -391,7 +389,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 	@Override
 	public CompletableFuture<String> triggerSavepoint(
 			final JobID jobId,
-			final @Nullable String savepointDirectory) throws FlinkException {
+			final @Nullable String savepointDirectory) {
 		return triggerSavepoint(jobId, savepointDirectory, false);
 	}
 
@@ -429,8 +427,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 
 		CompletableFuture<JobAccumulatorsInfo> responseFuture = sendRequest(
 			accumulatorsHeaders,
-			accMsgParams
-		);
+			accMsgParams);
 
 		Map<String, OptionalFailure<Object>> result = Collections.emptyMap();
 
@@ -463,16 +460,14 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 				savepointStatusHeaders.getUnresolvedMessageParameters();
 			savepointStatusMessageParameters.jobIdPathParameter.resolve(jobId);
 			savepointStatusMessageParameters.triggerIdPathParameter.resolve(triggerID);
-			return sendRetryableRequest(
+			return sendRequest(
 				savepointStatusHeaders,
-				savepointStatusMessageParameters,
-				EmptyRequestBody.getInstance(),
-				isConnectionProblemException());
+				savepointStatusMessageParameters);
 		});
 	}
 
 	@Override
-	public CompletableFuture<Collection<JobStatusMessage>> listJobs() throws Exception {
+	public CompletableFuture<Collection<JobStatusMessage>> listJobs() {
 		return sendRequest(JobsOverviewHeaders.getInstance())
 			.thenApply(
 				(multipleJobsDetails) -> multipleJobsDetails
@@ -508,8 +503,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 
 		final CompletableFuture<TriggerResponse> rescalingTriggerResponseFuture = sendRequest(
 			rescalingTriggerHeaders,
-			rescalingTriggerMessageParameters,
-			EmptyRequestBody.getInstance());
+			rescalingTriggerMessageParameters);
 
 		final CompletableFuture<AsynchronousOperationInfo> rescalingOperationFuture = rescalingTriggerResponseFuture.thenCompose(
 			(TriggerResponse triggerResponse) -> {
@@ -521,11 +515,9 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 				rescalingStatusMessageParameters.triggerIdPathParameter.resolve(triggerId);
 
 				return pollResourceAsync(
-					() -> sendRetryableRequest(
+					() -> sendRequest(
 						rescalingStatusHeaders,
-						rescalingStatusMessageParameters,
-						EmptyRequestBody.getInstance(),
-						isConnectionProblemException()));
+						rescalingStatusMessageParameters));
 			});
 
 		return rescalingOperationFuture.thenApply(
@@ -544,7 +536,6 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 
 		final CompletableFuture<TriggerResponse> savepointDisposalTriggerFuture = sendRequest(
 			SavepointDisposalTriggerHeaders.getInstance(),
-			EmptyMessageParameters.getInstance(),
 			savepointDisposalRequest);
 
 		final CompletableFuture<AsynchronousOperationInfo> savepointDisposalFuture = savepointDisposalTriggerFuture.thenCompose(
@@ -555,11 +546,9 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 				savepointDisposalStatusMessageParameters.triggerIdPathParameter.resolve(triggerId);
 
 				return pollResourceAsync(
-					() -> sendRetryableRequest(
+					() -> sendRequest(
 						savepointDisposalStatusHeaders,
-						savepointDisposalStatusMessageParameters,
-						EmptyRequestBody.getInstance(),
-						isConnectionProblemException()));
+						savepointDisposalStatusMessageParameters));
 			});
 
 		return savepointDisposalFuture.thenApply(
@@ -575,11 +564,7 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 	@Override
 	public void shutDownCluster() {
 		try {
-			sendRetryableRequest(
-				ShutdownHeaders.getInstance(),
-				EmptyMessageParameters.getInstance(),
-				EmptyRequestBody.getInstance(),
-				isConnectionProblemException()).get();
+			sendRequest(ShutdownHeaders.getInstance()).get();
 		} catch (InterruptedException e) {
 			Thread.currentThread().interrupt();
 		} catch (ExecutionException e) {
@@ -681,24 +666,20 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 		return sendRequest(messageHeaders, EmptyMessageParameters.getInstance(), request);
 	}
 
-	private <M extends MessageHeaders<EmptyRequestBody, P, EmptyMessageParameters>, P extends ResponseBody> CompletableFuture<P>
+	@VisibleForTesting
+	<M extends MessageHeaders<EmptyRequestBody, P, EmptyMessageParameters>, P extends ResponseBody> CompletableFuture<P>
 			sendRequest(M messageHeaders) {
 		return sendRequest(messageHeaders, EmptyMessageParameters.getInstance(), EmptyRequestBody.getInstance());
 	}
 
 	private <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P>
 			sendRequest(M messageHeaders, U messageParameters, R request) {
-		return getWebMonitorBaseUrl().thenCompose(webMonitorBaseUrl -> {
-			try {
-				return restClient.sendRequest(webMonitorBaseUrl.getHost(), webMonitorBaseUrl.getPort(), messageHeaders, messageParameters, request);
-			} catch (IOException e) {
-				throw new CompletionException(e);
-			}
-		});
+		return sendRetriableRequest(
+			messageHeaders, messageParameters, request, isConnectionProblemOrServiceUnavailable());
 	}
 
 	private <M extends MessageHeaders<R, P, U>, U extends MessageParameters, R extends RequestBody, P extends ResponseBody> CompletableFuture<P>
-			sendRetryableRequest(M messageHeaders, U messageParameters, R request, Predicate<Throwable> retryPredicate) {
+			sendRetriableRequest(M messageHeaders, U messageParameters, R request, Predicate<Throwable> retryPredicate) {
 		return retry(() -> getWebMonitorBaseUrl().thenCompose(webMonitorBaseUrl -> {
 			try {
 				return restClient.sendRequest(webMonitorBaseUrl.getHost(), webMonitorBaseUrl.getPort(), messageHeaders, messageParameters, request);
@@ -719,6 +700,10 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 			new ScheduledExecutorServiceAdapter(retryExecutorService));
 	}
 
+	private static Predicate<Throwable> isConnectionProblemOrServiceUnavailable() {
+		return isConnectionProblemException().or(isServiceUnavailable());
+	}
+
 	private static Predicate<Throwable> isConnectionProblemException() {
 		return (throwable) ->
 			ExceptionUtils.findThrowable(throwable, java.net.ConnectException.class).isPresent() ||
@@ -727,13 +712,17 @@ public class RestClusterClient<T> extends ClusterClient<T> implements NewCluster
 				ExceptionUtils.findThrowable(throwable, IOException.class).isPresent();
 	}
 
-	private static Predicate<Throwable> isHttpStatusUnsuccessfulException() {
+	private static Predicate<Throwable> isServiceUnavailable() {
+		return httpExceptionCodePredicate(code -> code == HttpResponseStatus.SERVICE_UNAVAILABLE.code());
+	}
+
+	private static Predicate<Throwable> httpExceptionCodePredicate(Predicate<Integer> statusCodePredicate) {
 		return (throwable) -> ExceptionUtils.findThrowable(throwable, RestClientException.class)
-				.map(restClientException -> {
-					final int code = restClientException.getHttpResponseStatus().code();
-					return code < 200 || code > 299;
-				})
-				.orElse(false);
+			.map(restClientException -> {
+				final int code = restClientException.getHttpResponseStatus().code();
+				return statusCodePredicate.test(code);
+			})
+			.orElse(false);
 	}
 
 	@VisibleForTesting
diff --git a/flink-clients/src/test/java/org/apache/flink/client/program/rest/RestClusterClientTest.java b/flink-clients/src/test/java/org/apache/flink/client/program/rest/RestClusterClientTest.java
index df0ce239311..f025d67bf11 100644
--- a/flink-clients/src/test/java/org/apache/flink/client/program/rest/RestClusterClientTest.java
+++ b/flink-clients/src/test/java/org/apache/flink/client/program/rest/RestClusterClientTest.java
@@ -40,6 +40,7 @@ import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.messages.webmonitor.JobDetails;
 import org.apache.flink.runtime.messages.webmonitor.MultipleJobsDetails;
+import org.apache.flink.runtime.rest.HttpMethodWrapper;
 import org.apache.flink.runtime.rest.RestClient;
 import org.apache.flink.runtime.rest.RestClientConfiguration;
 import org.apache.flink.runtime.rest.RestServerEndpoint;
@@ -369,7 +370,7 @@ public class RestClusterClientTest extends TestLogger {
 	public void testSubmitJobAndWaitForExecutionResult() throws Exception {
 		final TestJobExecutionResultHandler testJobExecutionResultHandler =
 			new TestJobExecutionResultHandler(
-				new RestHandlerException("should trigger retry", HttpResponseStatus.NOT_FOUND),
+				new RestHandlerException("should trigger retry", HttpResponseStatus.SERVICE_UNAVAILABLE),
 				JobExecutionResultResponseBody.inProgress(),
 				JobExecutionResultResponseBody.created(new JobResult.Builder()
 					.jobId(jobId)
@@ -709,6 +710,104 @@ public class RestClusterClientTest extends TestLogger {
 		assertThat(webMonitorBaseUrl.getPort(), equalTo(manualPort));
 	}
 
+	/**
+	 * Tests that the send operation is being retried.
+	 */
+	@Test
+	public void testRetriableSendOperationIfConnectionErrorOrServiceUnavailable() throws Exception {
+		final PingRestHandler pingRestHandler = new PingRestHandler(
+			FutureUtils.completedExceptionally(new RestHandlerException("test exception", HttpResponseStatus.SERVICE_UNAVAILABLE)),
+			CompletableFuture.completedFuture(EmptyResponseBody.getInstance()));
+
+		try (final TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(pingRestHandler)) {
+			final AtomicBoolean firstPollFailed = new AtomicBoolean();
+			failHttpRequest = (messageHeaders, messageParameters, requestBody) ->
+				messageHeaders instanceof PingRestHandlerHeaders && !firstPollFailed.getAndSet(true);
+
+			restClusterClient.sendRequest(PingRestHandlerHeaders.INSTANCE).get();
+		}
+	}
+
+	/**
+	 * Tests that the send operation is not being retried when receiving a NOT_FOUND return code.
+	 */
+	@Test
+	public void testSendIsNotRetriableIfHttpNotFound() throws Exception {
+		final String exceptionMessage = "test exception";
+		final PingRestHandler pingRestHandler = new PingRestHandler(
+			FutureUtils.completedExceptionally(new RestHandlerException(exceptionMessage, HttpResponseStatus.NOT_FOUND)));
+
+		try (final TestRestServerEndpoint restServerEndpoint = createRestServerEndpoint(pingRestHandler)) {
+			try {
+				restClusterClient.sendRequest(PingRestHandlerHeaders.INSTANCE).get();
+				fail("The rest request should have failed.");
+			}  catch (Exception e) {
+				assertThat(ExceptionUtils.findThrowableWithMessage(e, exceptionMessage).isPresent(), is(true));
+			}
+		}
+	}
+
+	private class PingRestHandler extends TestHandler<EmptyRequestBody, EmptyResponseBody, EmptyMessageParameters> {
+
+		private final Queue<CompletableFuture<EmptyResponseBody>> responseQueue;
+
+		private PingRestHandler(CompletableFuture<EmptyResponseBody> ... responses) {
+			super(PingRestHandlerHeaders.INSTANCE);
+			responseQueue = new ArrayDeque<>(Arrays.asList(responses));
+		}
+
+		@Override
+		protected CompletableFuture<EmptyResponseBody> handleRequest(@Nonnull HandlerRequest<EmptyRequestBody, EmptyMessageParameters> request, @Nonnull DispatcherGateway gateway) throws RestHandlerException {
+			final CompletableFuture<EmptyResponseBody> result = responseQueue.poll();
+
+			if (result != null) {
+				return result;
+			} else {
+				return CompletableFuture.completedFuture(EmptyResponseBody.getInstance());
+			}
+		}
+	}
+
+	private static final class PingRestHandlerHeaders implements MessageHeaders<EmptyRequestBody, EmptyResponseBody, EmptyMessageParameters> {
+
+		static final PingRestHandlerHeaders INSTANCE = new PingRestHandlerHeaders();
+
+		@Override
+		public Class<EmptyResponseBody> getResponseClass() {
+			return EmptyResponseBody.class;
+		}
+
+		@Override
+		public HttpResponseStatus getResponseStatusCode() {
+			return HttpResponseStatus.OK;
+		}
+
+		@Override
+		public String getDescription() {
+			return "foobar";
+		}
+
+		@Override
+		public Class<EmptyRequestBody> getRequestClass() {
+			return EmptyRequestBody.class;
+		}
+
+		@Override
+		public EmptyMessageParameters getUnresolvedMessageParameters() {
+			return EmptyMessageParameters.getInstance();
+		}
+
+		@Override
+		public HttpMethodWrapper getHttpMethod() {
+			return HttpMethodWrapper.GET;
+		}
+
+		@Override
+		public String getTargetRestEndpointURL() {
+			return "/foobar";
+		}
+	}
+
 	private class TestAccumulatorHandler extends TestHandler<EmptyRequestBody, JobAccumulatorsInfo, JobAccumulatorsMessageParameters> {
 
 		public TestAccumulatorHandler() {
