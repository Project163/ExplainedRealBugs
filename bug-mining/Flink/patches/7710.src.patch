diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java
index 915f4512d71..659e6b11209 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java
@@ -678,7 +678,8 @@ public final class TestValuesTableFactory
                             lookupThreshold,
                             enableAggregatePushDown,
                             customShuffleIsDeterministic,
-                            customShuffleEmptyPartitioner);
+                            customShuffleEmptyPartitioner,
+                            context.getPrimaryKeyIndexes());
                 } else {
                     return new TestValuesScanLookupTableSource(
                             context.getCatalogTable().getResolvedSchema().toPhysicalRowDataType(),
@@ -704,7 +705,8 @@ public final class TestValuesTableFactory
                             cache,
                             reloadTrigger,
                             lookupThreshold,
-                            enableAggregatePushDown);
+                            enableAggregatePushDown,
+                            context.getPrimaryKeyIndexes());
                 }
             }
         } else {
@@ -1736,6 +1738,8 @@ public final class TestValuesTableFactory
 
         protected final DataType originType;
 
+        protected final int[] primaryKeyIndices;
+
         private TestValuesScanLookupTableSource(
                 DataType originType,
                 DataType producedDataType,
@@ -1760,7 +1764,8 @@ public final class TestValuesTableFactory
                 @Nullable LookupCache cache,
                 @Nullable CacheReloadTrigger reloadTrigger,
                 int lookupThreshold,
-                boolean enableAggregatePushDown) {
+                boolean enableAggregatePushDown,
+                int[] primaryKeyIndices) {
             super(
                     producedDataType,
                     changelogMode,
@@ -1786,6 +1791,7 @@ public final class TestValuesTableFactory
             this.cache = cache;
             this.reloadTrigger = reloadTrigger;
             this.lookupThreshold = lookupThreshold;
+            this.primaryKeyIndices = primaryKeyIndices;
         }
 
         @SuppressWarnings({"unchecked", "rawtypes"})
@@ -1833,6 +1839,9 @@ public final class TestValuesTableFactory
                 throw new UnsupportedOperationException(
                         "nestedProjectionSupported is unsupported for lookup source currently.");
             }
+
+            data = deduplicateDataByPk(data);
+
             DataStructureConverter converter = context.createDataStructureConverter(originType);
             RowType originRowType =
                     RowType.of(
@@ -1883,6 +1892,33 @@ public final class TestValuesTableFactory
             }
         }
 
+        private List<Row> deduplicateDataByPk(List<Row> data) {
+            if (primaryKeyIndices.length == 0) {
+                return data;
+            }
+            // <pk, data>
+            LinkedHashMap<Row, Row> pkMap = new LinkedHashMap<>();
+            for (Row row : data) {
+                Row pk = extractPk(row);
+                RowKind originalRowKind = row.getKind();
+                if (originalRowKind == RowKind.INSERT || originalRowKind == RowKind.UPDATE_AFTER) {
+                    row.setKind(RowKind.INSERT);
+                    pkMap.put(pk, row);
+                } else {
+                    pkMap.remove(pk);
+                }
+            }
+            return new ArrayList<>(pkMap.values());
+        }
+
+        private Row extractPk(Row row) {
+            Object[] pk = new Object[primaryKeyIndices.length];
+            for (int i = 0; i < primaryKeyIndices.length; i++) {
+                pk[i] = row.getField(primaryKeyIndices[i]);
+            }
+            return Row.of(pk);
+        }
+
         /** Does not support nested projection. */
         private Optional<GeneratedProjection> genProjection(
                 RowType originRowType, RowType producedRowType) {
@@ -1970,7 +2006,8 @@ public final class TestValuesTableFactory
                     cache,
                     reloadTrigger,
                     lookupThreshold,
-                    enableAggregatePushDown);
+                    enableAggregatePushDown,
+                    primaryKeyIndices);
         }
     }
 
@@ -2011,7 +2048,8 @@ public final class TestValuesTableFactory
                 int lookupThreshold,
                 boolean enableAggregatePushDown,
                 boolean customShuffleIsDeterministic,
-                boolean customShuffleEmptyPartitioner) {
+                boolean customShuffleEmptyPartitioner,
+                int[] primaryKeyIndices) {
             super(
                     originType,
                     producedDataType,
@@ -2036,7 +2074,8 @@ public final class TestValuesTableFactory
                     cache,
                     reloadTrigger,
                     lookupThreshold,
-                    enableAggregatePushDown);
+                    enableAggregatePushDown,
+                    primaryKeyIndices);
             this.customShuffleIsDeterministic = customShuffleIsDeterministic;
             this.customShuffleEmptyPartitioner = customShuffleEmptyPartitioner;
         }
@@ -2069,7 +2108,8 @@ public final class TestValuesTableFactory
                     lookupThreshold,
                     enableAggregatePushDown,
                     customShuffleIsDeterministic,
-                    customShuffleEmptyPartitioner);
+                    customShuffleEmptyPartitioner,
+                    primaryKeyIndices);
         }
 
         @Override
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala
index f7c491a09e5..07f1fb69a33 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala
@@ -25,6 +25,7 @@ import org.apache.flink.table.connector.source.lookup.LookupOptions.{LookupCache
 import org.apache.flink.table.data.GenericRowData
 import org.apache.flink.table.data.binary.BinaryStringData
 import org.apache.flink.table.planner.factories.TestValuesTableFactory
+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow
 import org.apache.flink.table.planner.plan.utils.SingleSubTaskBoundTableFunction
 import org.apache.flink.table.planner.runtime.utils.{StreamingTestBase, TestingAppendSink, TestingRetractSink}
 import org.apache.flink.table.planner.runtime.utils.UserDefinedFunctionTestUtils.TestAddWithOpen
@@ -34,6 +35,7 @@ import org.apache.flink.testutils.junit.extensions.parameterized.{ParameterizedT
 import org.apache.flink.types.Row
 
 import org.assertj.core.api.Assertions.assertThat
+import org.assertj.core.api.Assumptions.assumeThat
 import org.assertj.core.api.IterableAssert.assertThatIterable
 import org.junit.jupiter.api.{AfterEach, BeforeEach, TestTemplate}
 import org.junit.jupiter.api.extension.ExtendWith
@@ -941,6 +943,40 @@ class LookupJoinITCase(cacheType: LookupCacheType) extends StreamingTestBase {
     val expected = Seq("3,Fabian")
     assertThat(sink.getAppendResults.sorted).isEqualTo(expected.sorted)
   }
+
+  @TestTemplate
+  def testJoinTemporalTableWithLatestData(): Unit = {
+    assumeThat(cacheType.equals(LookupCacheType.NONE)).isTrue
+    val dimData = List(
+      changelogRow("+I", Int.box(12), "DimJulia"),
+      changelogRow("+I", Int.box(15), "DimHello"),
+      changelogRow("+U", Int.box(15), "DimFabian"),
+      changelogRow("-D", Int.box(15), "DimFabian"),
+      changelogRow("+I", Int.box(11), "DimHelloWorld1"),
+      changelogRow("+U", Int.box(11), "DimHelloWorld2")
+    )
+
+    tEnv.executeSql(s"""
+                       |CREATE TABLE dim_with_pk (
+                       |  `len` INT PRIMARY KEY NOT ENFORCED,
+                       |  `comment` STRING
+                       |) WITH (
+                       |  'connector' = 'values',
+                       |  'data-id' = '${TestValuesTableFactory.registerData(dimData)}'
+                       |)
+                       |""".stripMargin)
+    val sql =
+      """
+        |SELECT dim_with_pk.* FROM src JOIN dim_with_pk
+        |FOR SYSTEM_TIME AS OF src.proctime ON src.len = dim_with_pk.len
+        |""".stripMargin
+
+    val sink = new TestingAppendSink
+    tEnv.sqlQuery(sql).toDataStream.addSink(sink)
+    env.execute()
+    val expected = Seq("12,DimJulia", "11,DimHelloWorld2", "12,DimJulia")
+    assertThat(sink.getAppendResults.sorted).isEqualTo(expected.sorted)
+  }
 }
 
 object LookupJoinITCase {
