diff --git a/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriter.java b/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriter.java
index 14ac74f0d7b..6d34690c578 100644
--- a/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriter.java
+++ b/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriter.java
@@ -271,7 +271,8 @@ public abstract class AsyncSinkWriter<InputT, RequestEntryT extends Serializable
                                     throw exception;
                                 },
                                 "A fatal exception occurred in the sink that cannot be recovered from or should not be retried.");
-        initialize(states);
+
+        initializeState(states);
     }
 
     private void registerCallback() {
@@ -429,17 +430,13 @@ public abstract class AsyncSinkWriter<InputT, RequestEntryT extends Serializable
         return Collections.singletonList(new BufferedRequestState<>((bufferedRequestEntries)));
     }
 
-    protected void initialize(Collection<BufferedRequestState<RequestEntryT>> states) {
-        if (states.isEmpty()) {
-            return;
-        }
-
-        if (states.size() > 1) {
-            throw new IllegalStateException(
-                    "Writer failed to initialize due to multiple initial states.");
+    private void initializeState(Collection<BufferedRequestState<RequestEntryT>> states) {
+        for (BufferedRequestState<RequestEntryT> state : states) {
+            initializeState(state);
         }
+    }
 
-        BufferedRequestState<RequestEntryT> state = states.iterator().next();
+    private void initializeState(BufferedRequestState<RequestEntryT> state) {
         this.bufferedRequestEntries.addAll(state.getBufferedRequestEntries());
 
         for (RequestEntryWrapper<RequestEntryT> wrapper : bufferedRequestEntries) {
@@ -451,7 +448,7 @@ public abstract class AsyncSinkWriter<InputT, RequestEntryT extends Serializable
             }
         }
 
-        this.bufferedRequestEntriesTotalSizeInBytes = state.getStateSize();
+        this.bufferedRequestEntriesTotalSizeInBytes += state.getStateSize();
     }
 
     @Override
diff --git a/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriterTest.java b/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriterTest.java
index bd3c068067e..904743dc74b 100644
--- a/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriterTest.java
+++ b/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/sink/writer/AsyncSinkWriterTest.java
@@ -38,6 +38,7 @@ import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.connector.base.sink.writer.AsyncSinkWriterTestUtils.assertThatBufferStatesAreEqual;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -604,6 +605,39 @@ public class AsyncSinkWriterTest {
                         "State contains record of size 100 which exceeds sink maximum record size 15.");
     }
 
+    @Test
+    public void testRestoreFromMultipleStates() throws IOException {
+        List<BufferedRequestState<Integer>> states =
+                Arrays.asList(
+                        new BufferedRequestState<>(
+                                Arrays.asList(
+                                        new RequestEntryWrapper<>(1, 1),
+                                        new RequestEntryWrapper<>(2, 1),
+                                        new RequestEntryWrapper<>(3, 1))),
+                        new BufferedRequestState<>(
+                                Arrays.asList(
+                                        new RequestEntryWrapper<>(4, 1),
+                                        new RequestEntryWrapper<>(5, 1))),
+                        new BufferedRequestState<>(
+                                Collections.singletonList(new RequestEntryWrapper<>(6, 1))));
+
+        AsyncSinkWriterImpl sink =
+                new AsyncSinkWriterImplBuilder().context(sinkInitContext).buildWithState(states);
+
+        List<BufferedRequestState<Integer>> bufferedRequestStates = sink.snapshotState(1);
+        // After snapshotting state, all entries are merged into a single BufferedRequestState
+        assertThat(bufferedRequestStates).hasSize(1);
+
+        BufferedRequestState<Integer> snapshotState = bufferedRequestStates.get(0);
+        assertThat(snapshotState.getBufferedRequestEntries()).hasSize(6);
+        assertThat(snapshotState.getStateSize()).isEqualTo(6);
+        assertThat(
+                        snapshotState.getBufferedRequestEntries().stream()
+                                .map(RequestEntryWrapper::getRequestEntry)
+                                .collect(Collectors.toList()))
+                .containsExactlyInAnyOrder(1, 2, 3, 4, 5, 6);
+    }
+
     @Test
     public void testThatOneAndOnlyOneCallbackIsEverRegistered() throws Exception {
         AsyncSinkWriterImpl sink =
