diff --git a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
index 8bf286722f2..a2664f9e04e 100644
--- a/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
+++ b/flink-core/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
@@ -893,7 +893,7 @@ public class TypeExtractor {
 			// build the entire type hierarchy for the pojo
 			getTypeHierarchy(inputTypeHierarchy, inType, Object.class);
 			// determine a field containing the type variable
-			List<Field> fields = getAllDeclaredFields(typeToClass(inType));
+			List<Field> fields = getAllDeclaredFields(typeToClass(inType), false);
 			for (Field field : fields) {
 				Type fieldType = field.getGenericType();
 				if (fieldType instanceof TypeVariable && sameTypeVars(returnTypeVar, materializeTypeVariable(inputTypeHierarchy, (TypeVariable<?>) fieldType))) {
@@ -1738,7 +1738,7 @@ public class TypeExtractor {
 			getTypeHierarchy(typeHierarchy, clazz, Object.class);
 		}
 		
-		List<Field> fields = getAllDeclaredFields(clazz);
+		List<Field> fields = getAllDeclaredFields(clazz, false);
 		if (fields.size() == 0) {
 			LOG.info("No fields detected for " + clazz + ". Cannot be used as a PojoType. Will be handled as GenericType");
 			return new GenericTypeInfo<OUT>(clazz);
@@ -1803,12 +1803,17 @@ public class TypeExtractor {
 	}
 
 	/**
-	 * recursively determine all declared fields
+	 * Recursively determine all declared fields
 	 * This is required because class.getFields() is not returning fields defined
 	 * in parent classes.
+	 *
+	 * @param clazz class to be analyzed
+	 * @param ignoreDuplicates if true, in case of duplicate field names only the lowest one
+	 *                            in a hierarchy will be returned; throws an exception otherwise
+	 * @return list of fields
 	 */
 	@PublicEvolving
-	public static List<Field> getAllDeclaredFields(Class<?> clazz) {
+	public static List<Field> getAllDeclaredFields(Class<?> clazz, boolean ignoreDuplicates) {
 		List<Field> result = new ArrayList<Field>();
 		while (clazz != null) {
 			Field[] fields = clazz.getDeclaredFields();
@@ -1817,8 +1822,12 @@ public class TypeExtractor {
 					continue; // we have no use for transient or static fields
 				}
 				if(hasFieldWithSameName(field.getName(), result)) {
-					throw new RuntimeException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."
+					if (ignoreDuplicates) {
+						continue;
+					} else {
+						throw new InvalidTypesException("The field "+field+" is already contained in the hierarchy of the "+clazz+"."
 							+ "Please use unique field names through your classes hierarchy");
+					}
 				}
 				result.add(field);
 			}
@@ -1829,7 +1838,7 @@ public class TypeExtractor {
 
 	@PublicEvolving
 	public static Field getDeclaredField(Class<?> clazz, String name) {
-		for (Field field : getAllDeclaredFields(clazz)) {
+		for (Field field : getAllDeclaredFields(clazz, true)) {
 			if (field.getName().equals(name)) {
 				return field;
 			}
diff --git a/flink-core/src/test/java/org/apache/flink/api/java/typeutils/PojoTypeExtractionTest.java b/flink-core/src/test/java/org/apache/flink/api/java/typeutils/PojoTypeExtractionTest.java
index 2ca50814cf6..ba09786ee36 100644
--- a/flink-core/src/test/java/org/apache/flink/api/java/typeutils/PojoTypeExtractionTest.java
+++ b/flink-core/src/test/java/org/apache/flink/api/java/typeutils/PojoTypeExtractionTest.java
@@ -52,9 +52,10 @@ public class PojoTypeExtractionTest {
 		private int count; // duplicate
 	}
 
-	@Test(expected=RuntimeException.class)
+	@Test
 	public void testDuplicateFieldException() {
-		TypeExtractor.createTypeInfo(HasDuplicateField.class);
+		TypeInformation<?> ti = TypeExtractor.createTypeInfo(HasDuplicateField.class);
+		Assert.assertTrue(ti instanceof GenericTypeInfo<?>);
 	}
 
 	// test with correct pojo types
