diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/AbstractDispatcherLeaderProcess.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/AbstractDispatcherLeaderProcess.java
new file mode 100644
index 00000000000..8bfa964f8e3
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/AbstractDispatcherLeaderProcess.java
@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.runtime.webmonitor.RestfulGateway;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+abstract class AbstractDispatcherLeaderProcess implements DispatcherLeaderProcess {
+
+	protected final Logger log = LoggerFactory.getLogger(getClass());
+
+	private final Object lock = new Object();
+
+	private final UUID leaderSessionId;
+
+	private final FatalErrorHandler fatalErrorHandler;
+
+	private final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture;
+
+	private final CompletableFuture<String> confirmLeaderSessionFuture;
+
+	private final CompletableFuture<Void> terminationFuture;
+
+	private State state;
+
+	AbstractDispatcherLeaderProcess(UUID leaderSessionId, FatalErrorHandler fatalErrorHandler) {
+		this.leaderSessionId = leaderSessionId;
+		this.fatalErrorHandler = fatalErrorHandler;
+
+		this.dispatcherGatewayFuture = new CompletableFuture<>();
+		this.confirmLeaderSessionFuture = dispatcherGatewayFuture.thenApply(RestfulGateway::getAddress);
+		this.terminationFuture = new CompletableFuture<>();
+
+		this.state = State.CREATED;
+	}
+
+	@VisibleForTesting
+	State getState() {
+		synchronized (lock) {
+			return state;
+		}
+	}
+
+	@Override
+	public final void start() {
+		runIfStateIs(
+			State.CREATED,
+			this::startInternal);
+	}
+
+	private void startInternal() {
+		log.info("Start {}.", getClass().getSimpleName());
+		state = State.RUNNING;
+		onStart();
+	}
+
+	@Override
+	public final UUID getLeaderSessionId() {
+		return leaderSessionId;
+	}
+
+	@Override
+	public final CompletableFuture<DispatcherGateway> getDispatcherGateway() {
+		return dispatcherGatewayFuture;
+	}
+
+	@Override
+	public final CompletableFuture<String> getConfirmLeaderSessionFuture() {
+		return confirmLeaderSessionFuture;
+	}
+
+	@Override
+	public final CompletableFuture<Void> closeAsync() {
+		runIfStateIsNot(
+			State.STOPPED,
+			this::closeInternal);
+
+		return terminationFuture;
+	}
+
+	private void closeInternal() {
+		FutureUtils.forward(
+			onClose(),
+			terminationFuture);
+
+		state = State.STOPPED;
+	}
+
+	protected abstract void onStart();
+
+	protected CompletableFuture<Void> onClose() {
+		return FutureUtils.completedVoidFuture();
+	}
+
+	protected void completeDispatcherGatewayFuture(DispatcherGateway dispatcherGateway) {
+		dispatcherGatewayFuture.complete(dispatcherGateway);
+	}
+
+	final <V> Optional<V> supplyUnsynchronizedIfRunning(Supplier<V> supplier) {
+		synchronized (lock) {
+			if (state != State.RUNNING) {
+				return Optional.empty();
+			}
+		}
+
+		return Optional.of(supplier.get());
+	}
+
+	final <V> Optional<V> supplyIfRunning(Supplier<V> supplier) {
+		synchronized (lock) {
+			if (state != State.RUNNING) {
+				return Optional.empty();
+			}
+
+			return Optional.of(supplier.get());
+		}
+	}
+
+	final void runIfStateIs(State expectedState, Runnable action) {
+		runIfState(expectedState::equals, action);
+	}
+
+	private void runIfStateIsNot(State notExpectedState, Runnable action) {
+		runIfState(
+			state -> !notExpectedState.equals(state),
+			action);
+	}
+
+	private void runIfState(Predicate<State> actionPredicate, Runnable action) {
+		synchronized (lock) {
+			if (actionPredicate.test(state)) {
+				action.run();
+			}
+		}
+	}
+
+	final <T> Void onErrorIfRunning(T ignored, Throwable throwable) {
+		synchronized (lock) {
+			if (state != State.RUNNING) {
+				return null;
+			}
+		}
+
+		if (throwable != null) {
+			closeAsync();
+			fatalErrorHandler.onFatalError(throwable);
+		}
+
+		return null;
+	}
+
+	protected enum State {
+		CREATED,
+		RUNNING,
+		STOPPED
+	}
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
index dc20e980a36..02b708f0113 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
@@ -28,16 +28,12 @@ import org.apache.flink.runtime.jobmanager.JobGraphStore;
 import org.apache.flink.runtime.jobmanager.JobGraphWriter;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcUtils;
-import org.apache.flink.runtime.webmonitor.RestfulGateway;
 import org.apache.flink.util.AutoCloseableAsync;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.function.FunctionUtils;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import javax.annotation.Nullable;
 
 import java.util.ArrayList;
@@ -47,20 +43,12 @@ import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
 
 /**
  * Process which encapsulates the job recovery logic and life cycle management of a
  * {@link Dispatcher}.
  */
-public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, JobGraphStore.JobGraphListener {
-
-	private static final Logger LOG = LoggerFactory.getLogger(DispatcherLeaderProcessImpl.class);
-
-	private final Object lock = new Object();
-
-	private final UUID leaderSessionId;
+public class DispatcherLeaderProcessImpl extends  AbstractDispatcherLeaderProcess implements JobGraphStore.JobGraphListener {
 
 	private final DispatcherServiceFactory dispatcherFactory;
 
@@ -68,16 +56,6 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 
 	private final Executor ioExecutor;
 
-	private final FatalErrorHandler fatalErrorHandler;
-
-	private final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture;
-
-	private final CompletableFuture<String> confirmLeaderSessionFuture;
-
-	private final CompletableFuture<Void> terminationFuture;
-
-	private State state;
-
 	@Nullable
 	private DispatcherService dispatcher;
 
@@ -89,36 +67,17 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 			JobGraphStore jobGraphStore,
 			Executor ioExecutor,
 			FatalErrorHandler fatalErrorHandler) {
-		this.leaderSessionId = leaderSessionId;
+		super(leaderSessionId, fatalErrorHandler);
+
 		this.dispatcherFactory = dispatcherFactory;
 		this.jobGraphStore = jobGraphStore;
 		this.ioExecutor = ioExecutor;
-		this.fatalErrorHandler = fatalErrorHandler;
 
-		this.dispatcherGatewayFuture = new CompletableFuture<>();
-		this.confirmLeaderSessionFuture = dispatcherGatewayFuture.thenApply(RestfulGateway::getAddress);
-		this.terminationFuture = new CompletableFuture<>();
-
-		this.state = State.CREATED;
 		this.dispatcher = null;
 	}
 
-	State getState() {
-		synchronized (lock) {
-			return state;
-		}
-	}
-
 	@Override
-	public void start() {
-		runIfStateIs(
-			State.CREATED,
-			this::startInternal);
-	}
-
-	private void startInternal() {
-		LOG.info("Start {}.", getClass().getSimpleName());
-		state = State.RUNNING;
+	protected void onStart() {
 		startServices();
 
 		onGoingRecoveryOperation = recoverJobsAsync()
@@ -139,31 +98,16 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 		}
 	}
 
-	private <T> Void onErrorIfRunning(T ignored, Throwable throwable) {
-		synchronized (lock) {
-			if (state != State.RUNNING) {
-				return null;
-			}
-		}
-
-		if (throwable != null) {
-			closeAsync();
-			fatalErrorHandler.onFatalError(throwable);
-		}
-
-		return null;
-	}
-
 	private void createDispatcherIfRunning(Collection<JobGraph> jobGraphs) {
 		runIfStateIs(State.RUNNING, () -> createDispatcher(jobGraphs));
 	}
 
 	private void createDispatcher(Collection<JobGraph> jobGraphs) {
 		dispatcher = dispatcherFactory.create(
-			DispatcherId.fromUuid(leaderSessionId),
+			DispatcherId.fromUuid(getLeaderSessionId()),
 			jobGraphs,
 			jobGraphStore);
-		dispatcherGatewayFuture.complete(dispatcher.getGateway());
+		completeDispatcherGatewayFuture(dispatcher.getGateway());
 	}
 
 	private CompletableFuture<Collection<JobGraph>> recoverJobsAsync() {
@@ -178,7 +122,7 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private Collection<JobGraph> recoverJobs() {
-		LOG.info("Recover all persisted job graphs.");
+		log.info("Recover all persisted job graphs.");
 		final Collection<JobID> jobIds = getJobIds();
 		final Collection<JobGraph> recoveredJobGraphs = new ArrayList<>();
 
@@ -186,7 +130,7 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 			recoveredJobGraphs.add(recoverJob(jobId));
 		}
 
-		LOG.info("Successfully recovered {} persisted job graphs.", recoveredJobGraphs.size());
+		log.info("Successfully recovered {} persisted job graphs.", recoveredJobGraphs.size());
 
 		return recoveredJobGraphs;
 	}
@@ -202,7 +146,7 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private JobGraph recoverJob(JobID jobId) {
-		LOG.info("Trying to recover job with job id {}.", jobId);
+		log.info("Trying to recover job with job id {}.", jobId);
 		try {
 			return jobGraphStore.recoverJobGraph(jobId);
 		} catch (Exception e) {
@@ -213,31 +157,8 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	@Override
-	public UUID getLeaderSessionId() {
-		return leaderSessionId;
-	}
-
-	@Override
-	public CompletableFuture<DispatcherGateway> getDispatcherGateway() {
-		return dispatcherGatewayFuture;
-	}
-
-	@Override
-	public CompletableFuture<String> getConfirmLeaderSessionFuture() {
-		return confirmLeaderSessionFuture;
-	}
-
-	@Override
-	public CompletableFuture<Void> closeAsync() {
-		runIfStateIsNot(
-			State.STOPPED,
-			this::closeInternal);
-
-		return terminationFuture;
-	}
-
-	private void closeInternal() {
-		LOG.info("Stopping {}.", getClass().getSimpleName());
+	protected CompletableFuture<Void> onClose() {
+		log.info("Stopping {}.", getClass().getSimpleName());
 		final CompletableFuture<Void> dispatcherTerminationFuture;
 
 		if (dispatcher != null) {
@@ -246,16 +167,10 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 			dispatcherTerminationFuture = FutureUtils.completedVoidFuture();
 		}
 
-		final CompletableFuture<Void> stopServicesFuture = FutureUtils.runAfterwardsAsync(
+		return FutureUtils.runAfterwardsAsync(
 			dispatcherTerminationFuture,
 			this::stopServices,
 			ioExecutor);
-
-		FutureUtils.forward(
-			stopServicesFuture,
-			terminationFuture);
-
-		state = State.STOPPED;
 	}
 
 	private void stopServices() throws Exception {
@@ -282,7 +197,7 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private void handleAddedJobGraph(JobID jobId) {
-		LOG.debug(
+		log.debug(
 			"Job {} has been added to the {} by another process.",
 			jobId,
 			jobGraphStore.getClass().getSimpleName());
@@ -312,7 +227,7 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private DispatcherGateway getDispatcherGatewayInternal() {
-		return Preconditions.checkNotNull(dispatcherGatewayFuture.getNow(null));
+		return Preconditions.checkNotNull(getDispatcherGateway().getNow(null));
 	}
 
 	private Optional<JobGraph> recoverJobIfRunning(JobID jobId) {
@@ -327,7 +242,7 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private void handleRemovedJobGraph(JobID jobId) {
-		LOG.debug(
+		log.debug(
 			"Job {} has been removed from the {} by another process.",
 			jobId,
 			jobGraphStore.getClass().getSimpleName());
@@ -368,48 +283,6 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 			fatalErrorHandler);
 	}
 
-	// ---------------------------------------------------------------
-	// Internal helper methods
-	// ---------------------------------------------------------------
-
-	private <V> Optional<V> supplyUnsynchronizedIfRunning(Supplier<V> supplier) {
-		synchronized (lock) {
-			if (state != State.RUNNING) {
-				return Optional.empty();
-			}
-		}
-
-		return Optional.of(supplier.get());
-	}
-
-	private <V> Optional<V> supplyIfRunning(Supplier<V> supplier) {
-		synchronized (lock) {
-			if (state != State.RUNNING) {
-				return Optional.empty();
-			}
-
-			return Optional.of(supplier.get());
-		}
-	}
-
-	private void runIfStateIs(State expectedState, Runnable action) {
-		runIfState(expectedState::equals, action);
-	}
-
-	private void runIfStateIsNot(State notExpectedState, Runnable action) {
-		runIfState(
-			state -> !notExpectedState.equals(state),
-			action);
-	}
-
-	private void runIfState(Predicate<State> actionPredicate, Runnable action) {
-		synchronized (lock) {
-			if (actionPredicate.test(state)) {
-				action.run();
-			}
-		}
-	}
-
 	// ------------------------------------------------------------
 	// Internal classes
 	// ------------------------------------------------------------
@@ -424,10 +297,4 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	interface DispatcherService extends AutoCloseableAsync {
 		DispatcherGateway getGateway();
 	}
-
-	enum State {
-		CREATED,
-		RUNNING,
-		STOPPED
-	}
 }
