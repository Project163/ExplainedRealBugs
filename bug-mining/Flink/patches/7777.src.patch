diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/v2/AbstractAggregatingState.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/v2/AbstractAggregatingState.java
index c92f3dc8421..556d63dad5e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/v2/AbstractAggregatingState.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/v2/AbstractAggregatingState.java
@@ -100,7 +100,8 @@ public class AbstractAggregatingState<K, N, IN, ACC, OUT> extends AbstractKeyedS
         try {
             ACC newValue =
                     acc == null
-                            ? this.aggregateFunction.createAccumulator()
+                            ? this.aggregateFunction.add(
+                                    value, this.aggregateFunction.createAccumulator())
                             : this.aggregateFunction.add(value, acc);
             updateInternal(newValue);
         } catch (Exception e) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/v2/AbstractAggregatingStateTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/v2/AbstractAggregatingStateTest.java
index 0522b88c05d..3be5ed9f418 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/v2/AbstractAggregatingStateTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/v2/AbstractAggregatingStateTest.java
@@ -100,17 +100,55 @@ class AbstractAggregatingStateTest extends AbstractKeyedStateTestBase {
         validateRequestRun(state, StateRequestType.AGGREGATING_ADD, 6, 0);
     }
 
+    @Test
+    @SuppressWarnings({"unchecked"})
+    public void testAggregatingStateAddWithSyncAPI() {
+        AggregateFunction<Integer, Integer, Integer> aggregator = new SumAggregator(1);
+        AggregatingStateDescriptor<Integer, Integer, Integer> descriptor =
+                new AggregatingStateDescriptor<>(
+                        "testState", aggregator, BasicTypeInfo.INT_TYPE_INFO);
+        AggregatingStateExecutor aggregatingStateExecutor = new AggregatingStateExecutor();
+        AsyncExecutionController<String> aec =
+                new AsyncExecutionController<>(
+                        new SyncMailboxExecutor(),
+                        (a, b) -> {},
+                        aggregatingStateExecutor,
+                        new DeclarationManager(),
+                        1,
+                        100,
+                        10000,
+                        1,
+                        null,
+                        null);
+        AbstractAggregatingState<String, String, Integer, Integer, Integer> aggregatingState =
+                new AbstractAggregatingState<>(aec, descriptor);
+        aec.setCurrentContext(aec.buildContext("test", "test"));
+        aec.setCurrentNamespaceForState(aggregatingState, "1");
+        aggregatingState.add(1);
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(1);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1")))
+                .isEqualTo(2);
+        aec.setCurrentNamespaceForState(aggregatingState, "2");
+        aggregatingState.add(2);
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(2);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1")))
+                .isEqualTo(2);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "2")))
+                .isEqualTo(3);
+    }
+
     @Test
     public void testMergeNamespace() throws Exception {
         AggregateFunction<Integer, Integer, Integer> aggregator = new SumAggregator(0);
         AggregatingStateDescriptor<Integer, Integer, Integer> descriptor =
                 new AggregatingStateDescriptor<>(
                         "testState", aggregator, BasicTypeInfo.INT_TYPE_INFO);
+        AggregatingStateExecutor aggregatingStateExecutor = new AggregatingStateExecutor();
         AsyncExecutionController<String> aec =
                 new AsyncExecutionController<>(
                         new SyncMailboxExecutor(),
                         (a, b) -> {},
-                        new AbstractAggregatingStateTest.AggregatingStateExecutor(),
+                        aggregatingStateExecutor,
                         new DeclarationManager(),
                         1,
                         100,
@@ -124,110 +162,63 @@ class AbstractAggregatingStateTest extends AbstractKeyedStateTestBase {
         aec.setCurrentNamespaceForState(aggregatingState, "1");
         aggregatingState.asyncAdd(1);
         aec.drainInflightRecords(0);
-        assertThat(AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.size())
-                .isEqualTo(1);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "1")))
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(1);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1")))
                 .isEqualTo(1);
         aec.setCurrentNamespaceForState(aggregatingState, "2");
         aggregatingState.asyncAdd(2);
         aec.drainInflightRecords(0);
-        assertThat(AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.size())
-                .isEqualTo(2);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "1")))
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(2);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1")))
                 .isEqualTo(1);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "2")))
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "2")))
                 .isEqualTo(2);
         aec.setCurrentNamespaceForState(aggregatingState, "3");
         aggregatingState.asyncAdd(3);
         aec.drainInflightRecords(0);
-        assertThat(AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.size())
-                .isEqualTo(3);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "1")))
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(3);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1")))
                 .isEqualTo(1);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "2")))
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "2")))
                 .isEqualTo(2);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "3")))
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "3")))
                 .isEqualTo(3);
 
         List<String> sources = new ArrayList<>(Arrays.asList("1", "2", "3"));
         aggregatingState.asyncMergeNamespaces("0", sources);
         aec.drainInflightRecords(0);
-        assertThat(AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.size())
-                .isEqualTo(1);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "0")))
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(1);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "0")))
                 .isEqualTo(6);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "1")))
-                .isNull();
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "2")))
-                .isNull();
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "3")))
-                .isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1"))).isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "2"))).isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "3"))).isNull();
 
         aec.setCurrentNamespaceForState(aggregatingState, "4");
         aggregatingState.asyncAdd(4);
         aec.drainInflightRecords(0);
-        assertThat(AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.size())
-                .isEqualTo(2);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "0")))
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(2);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "0")))
                 .isEqualTo(6);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "4")))
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "4")))
                 .isEqualTo(4);
 
         List<String> sources1 = new ArrayList<>(Arrays.asList("4"));
         aggregatingState.asyncMergeNamespaces("0", sources1);
         aec.drainInflightRecords(0);
 
-        assertThat(AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.size())
-                .isEqualTo(1);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "0")))
+        assertThat(aggregatingStateExecutor.getResultMap().size()).isEqualTo(1);
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "0")))
                 .isEqualTo(10);
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "1")))
-                .isNull();
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "2")))
-                .isNull();
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "3")))
-                .isNull();
-        assertThat(
-                        AbstractAggregatingStateTest.AggregatingStateExecutor.hashMap.get(
-                                Tuple2.of("test", "4")))
-                .isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "1"))).isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "2"))).isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "3"))).isNull();
+        assertThat(aggregatingStateExecutor.getResultMap().get(Tuple2.of("test", "4"))).isNull();
     }
 
     static class AggregatingStateExecutor implements StateExecutor {
 
-        private static final HashMap<Tuple2<String, String>, Integer> hashMap = new HashMap<>();
+        private final HashMap<Tuple2<String, String>, Integer> hashMap = new HashMap<>();
 
         @SuppressWarnings({"unchecked", "rawtypes"})
         @Override
@@ -267,6 +258,10 @@ class AbstractAggregatingStateTest extends AbstractKeyedStateTestBase {
             }
         }
 
+        public HashMap<Tuple2<String, String>, Integer> getResultMap() {
+            return hashMap;
+        }
+
         @Override
         public boolean fullyLoaded() {
             return false;
