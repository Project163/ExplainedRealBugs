diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterJobClient.java b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterJobClient.java
index 1c3639b80dc..3291c6f4691 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterJobClient.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterJobClient.java
@@ -21,8 +21,10 @@ package org.apache.flink.runtime.minicluster;
 import org.apache.flink.api.common.JobExecutionResult;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.api.common.accumulators.AccumulatorHelper;
 import org.apache.flink.core.execution.JobClient;
 import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.executiongraph.AccessExecutionGraph;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.operators.coordination.CoordinationRequest;
@@ -106,7 +108,25 @@ public final class MiniClusterJobClient implements JobClient, CoordinationReques
 
     @Override
     public CompletableFuture<Map<String, Object>> getAccumulators() {
-        return getJobExecutionResult().thenApply(JobExecutionResult::getAllAccumulatorResults);
+        final CompletableFuture<JobExecutionResult> jobExecutionResult = getJobExecutionResult();
+        if (jobExecutionResult.isDone()) {
+            return jobExecutionResult.thenApply(JobExecutionResult::getAllAccumulatorResults);
+        } else {
+            return miniCluster
+                    .getExecutionGraph(jobID)
+                    .thenApply(AccessExecutionGraph::getAccumulatorsSerialized)
+                    .thenApply(
+                            accumulators -> {
+                                try {
+                                    return AccumulatorHelper.deserializeAndUnwrapAccumulators(
+                                            accumulators, classLoader);
+                                } catch (Exception e) {
+                                    throw new CompletionException(
+                                            "Cannot deserialize and unwrap accumulators properly.",
+                                            e);
+                                }
+                            });
+        }
     }
 
     @Override
diff --git a/flink-tests/src/test/java/org/apache/flink/test/accumulators/AccumulatorLiveITCase.java b/flink-tests/src/test/java/org/apache/flink/test/accumulators/AccumulatorLiveITCase.java
index 3a76dd02cff..264fa0c9fcc 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/accumulators/AccumulatorLiveITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/accumulators/AccumulatorLiveITCase.java
@@ -38,6 +38,7 @@ import org.apache.flink.optimizer.plan.OptimizedPlan;
 import org.apache.flink.optimizer.plantranslate.JobGraphGenerator;
 import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.minicluster.MiniClusterJobClient;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
 import org.apache.flink.streaming.api.datastream.DataStream;
@@ -153,24 +154,10 @@ public class AccumulatorLiveITCase extends TestLogger {
         try {
             NotifyingMapper.notifyLatch.await();
 
-            FutureUtils.retrySuccessfulWithDelay(
-                            () -> {
-                                try {
-                                    return CompletableFuture.completedFuture(
-                                            client.getAccumulators(jobGraph.getJobID()).get());
-                                } catch (Exception e) {
-                                    return FutureUtils.completedExceptionally(e);
-                                }
-                            },
-                            Time.milliseconds(20),
-                            deadline,
-                            accumulators ->
-                                    accumulators.size() == 1
-                                            && accumulators.containsKey(ACCUMULATOR_NAME)
-                                            && (int) accumulators.get(ACCUMULATOR_NAME)
-                                                    == NUM_ITERATIONS,
-                            TestingUtils.defaultScheduledExecutor())
-                    .get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);
+            // verify using the ClusterClient
+            verifyResults(jobGraph, deadline, client);
+            // verify using the MiniClusterJobClient
+            verifyResults(jobGraph, deadline, null);
 
             NotifyingMapper.shutdownLatch.trigger();
         } finally {
@@ -181,6 +168,41 @@ public class AccumulatorLiveITCase extends TestLogger {
         }
     }
 
+    private static void verifyResults(JobGraph jobGraph, Deadline deadline, ClusterClient<?> client)
+            throws InterruptedException, java.util.concurrent.ExecutionException,
+                    java.util.concurrent.TimeoutException {
+        FutureUtils.retrySuccessfulWithDelay(
+                        () -> {
+                            try {
+                                if (client != null) {
+                                    return CompletableFuture.completedFuture(
+                                            client.getAccumulators(jobGraph.getJobID()).get());
+                                } else {
+                                    final MiniClusterJobClient miniClusterJobClient =
+                                            new MiniClusterJobClient(
+                                                    jobGraph.getJobID(),
+                                                    MINI_CLUSTER_RESOURCE.getMiniCluster(),
+                                                    ClassLoader.getSystemClassLoader(),
+                                                    MiniClusterJobClient.JobFinalizationBehavior
+                                                            .NOTHING);
+                                    return CompletableFuture.completedFuture(
+                                            miniClusterJobClient.getAccumulators().get());
+                                }
+                            } catch (Exception e) {
+                                return FutureUtils.completedExceptionally(e);
+                            }
+                        },
+                        Time.milliseconds(20),
+                        deadline,
+                        accumulators ->
+                                accumulators.size() == 1
+                                        && accumulators.containsKey(ACCUMULATOR_NAME)
+                                        && (int) accumulators.get(ACCUMULATOR_NAME)
+                                                == NUM_ITERATIONS,
+                        TestingUtils.defaultScheduledExecutor())
+                .get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);
+    }
+
     /** UDF that notifies when it changes the accumulator values. */
     private static class NotifyingMapper extends RichFlatMapFunction<Integer, Integer> {
         private static final long serialVersionUID = 1L;
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointCompatibilityITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointCompatibilityITCase.java
index d7888e6940b..1281e8f5223 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointCompatibilityITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointCompatibilityITCase.java
@@ -17,6 +17,7 @@
 
 package org.apache.flink.test.checkpointing;
 
+import org.apache.flink.api.common.JobExecutionResult;
 import org.apache.flink.api.common.restartstrategy.RestartStrategies;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.configuration.Configuration;
@@ -146,7 +147,10 @@ public class UnalignedCheckpointCompatibilityITCase extends TestLogger {
                 () -> miniCluster.getMiniCluster().getExecutionGraph(jobClient.getJobID()).get());
         Thread.sleep(FIRST_RUN_BACKPRESSURE_MS); // wait for some backpressure from sink
 
-        Future<Map<String, Object>> accFuture = jobClient.getAccumulators();
+        Future<Map<String, Object>> accFuture =
+                jobClient
+                        .getJobExecutionResult()
+                        .thenApply(JobExecutionResult::getAllAccumulatorResults);
         Future<String> savepointFuture =
                 jobClient.stopWithSavepoint(false, tempFolder().toURI().toString());
         return new Tuple2<>(savepointFuture.get(), accFuture.get());
