diff --git a/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java
index ef1fdf0567c..0975ddce440 100644
--- a/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java
+++ b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java
@@ -66,7 +66,13 @@ final class CombinedWatermarkStatus {
     public boolean updateCombinedWatermark() {
         long minimumOverAllOutputs = Long.MAX_VALUE;
 
-        boolean hasOutputs = false;
+        // if we don't have any outputs minimumOverAllOutputs is not valid, it's still
+        // at its initial Long.MAX_VALUE state and we must not emit that
+        if (partialWatermarks.isEmpty()) {
+            this.idle = combinedWatermark > Long.MIN_VALUE;
+            return false;
+        }
+
         boolean allIdle = true;
         for (PartialWatermark partialWatermark : partialWatermarks) {
             if (!partialWatermark.isIdle()) {
@@ -74,17 +80,11 @@ final class CombinedWatermarkStatus {
                         Math.min(minimumOverAllOutputs, partialWatermark.getWatermark());
                 allIdle = false;
             }
-            hasOutputs = true;
         }
 
-        // if we don't have any outputs minimumOverAllOutputs is not valid, it's still
-        // at its initial Long.MAX_VALUE state and we must not emit that
         this.idle = allIdle;
-        if (!hasOutputs || allIdle) {
-            return false;
-        }
 
-        if (minimumOverAllOutputs > combinedWatermark) {
+        if (!allIdle && minimumOverAllOutputs > combinedWatermark) {
             combinedWatermark = minimumOverAllOutputs;
             return true;
         }
diff --git a/flink-core/src/test/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexerTest.java b/flink-core/src/test/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexerTest.java
index 362caf7be73..61ce8d5e307 100644
--- a/flink-core/src/test/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexerTest.java
+++ b/flink-core/src/test/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexerTest.java
@@ -23,6 +23,7 @@ import org.junit.Test;
 import java.util.UUID;
 
 import static org.apache.flink.api.common.eventtime.WatermarkMatchers.watermark;
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.junit.Assert.assertEquals;
@@ -139,6 +140,9 @@ public class WatermarkOutputMultiplexerTest {
      * This test makes sure that we don't output any update if there are zero outputs. Due to how
      * aggregation of deferred updates in the KafkaConsumer works we had a bug there that caused a
      * Long.MAX_VALUE watermark to be emitted in case of zero partitions.
+     *
+     * <p>Additionally it verifies that the combined output is not IDLE during the initial phase
+     * when there are no splits assigned and the combined watermark is at its initial value.
      */
     @Test
     public void noCombinedDeferredUpdateWhenWeHaveZeroOutputs() {
@@ -149,6 +153,7 @@ public class WatermarkOutputMultiplexerTest {
         multiplexer.onPeriodicEmit();
 
         assertThat(underlyingWatermarkOutput.lastWatermark(), is(nullValue()));
+        assertThat(underlyingWatermarkOutput.isIdle(), is(false));
     }
 
     @Test
@@ -376,6 +381,24 @@ public class WatermarkOutputMultiplexerTest {
         assertFalse(unregistered);
     }
 
+    @Test
+    public void testEmittingIdleAfterAllSplitsRemoved() {
+        final TestingWatermarkOutput underlyingWatermarkOutput = createTestingWatermarkOutput();
+        final WatermarkOutputMultiplexer multiplexer =
+                new WatermarkOutputMultiplexer(underlyingWatermarkOutput);
+
+        Watermark emittedWatermark = new Watermark(1);
+        final String id = UUID.randomUUID().toString();
+        multiplexer.registerNewOutput(id);
+        WatermarkOutput immediateOutput = multiplexer.getImmediateOutput(id);
+        immediateOutput.emitWatermark(emittedWatermark);
+        multiplexer.unregisterOutput(id);
+
+        multiplexer.onPeriodicEmit();
+        assertThat(underlyingWatermarkOutput.lastWatermark(), equalTo(emittedWatermark));
+        assertThat(underlyingWatermarkOutput.isIdle(), equalTo(true));
+    }
+
     /**
      * Convenience method so we don't have to go through the output ID dance when we only want an
      * immediate output for a given output ID.
