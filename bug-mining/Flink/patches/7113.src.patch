diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java
index 9e17de2f0ea..0b627a88395 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkFilterCalcMergeRule.java
@@ -18,23 +18,21 @@
 
 package org.apache.flink.table.planner.plan.rules.logical;
 
-import org.apache.flink.table.planner.plan.utils.InputRefVisitor;
+import org.apache.flink.table.planner.plan.utils.FlinkRelUtil;
 
 import org.apache.calcite.plan.RelOptRule;
 import org.apache.calcite.plan.RelOptRuleCall;
+import org.apache.calcite.rel.core.Calc;
+import org.apache.calcite.rel.core.Filter;
 import org.apache.calcite.rel.logical.LogicalCalc;
 import org.apache.calcite.rel.logical.LogicalFilter;
 import org.apache.calcite.rel.rules.FilterCalcMergeRule;
 import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.rex.RexUtil;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.stream.Collectors;
 
 /**
- * Extends calcite's FilterCalcMergeRule for streaming scenario, modification: does not merge the
- * filter references field which generated by non-deterministic function.
+ * Extends calcite's FilterCalcMergeRule, modification: only merge the two neighbouring {@link
+ * Filter} and {@link Calc} if each non-deterministic {@link RexNode} of bottom {@link Calc} should
+ * appear at most once in the implicit project list and condition of top {@link Filter}.
  */
 public class FlinkFilterCalcMergeRule extends FilterCalcMergeRule {
 
@@ -45,22 +43,9 @@ public class FlinkFilterCalcMergeRule extends FilterCalcMergeRule {
     }
 
     @Override
-    public void onMatch(RelOptRuleCall call) {
-        LogicalFilter filter = call.rel(0);
-        LogicalCalc calc = call.rel(1);
-
-        List<RexNode> expandProjects =
-                calc.getProgram().getProjectList().stream()
-                        .map(p -> calc.getProgram().expandLocalRef(p))
-                        .collect(Collectors.toList());
-        InputRefVisitor inputRefVisitor = new InputRefVisitor();
-        filter.getCondition().accept(inputRefVisitor);
-        boolean existNonDeterministicRef =
-                Arrays.stream(inputRefVisitor.getFields())
-                        .anyMatch(i -> !RexUtil.isDeterministic(expandProjects.get(i)));
-
-        if (!existNonDeterministicRef) {
-            super.onMatch(call);
-        }
+    public boolean matches(RelOptRuleCall call) {
+        final LogicalFilter topFilter = call.rel(0);
+        final LogicalCalc bottomCalc = call.rel(1);
+        return FlinkRelUtil.isMergeable(topFilter, bottomCalc);
     }
 }
diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkProjectCalcMergeRule.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkProjectCalcMergeRule.java
new file mode 100644
index 00000000000..9b7c4ab6807
--- /dev/null
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkProjectCalcMergeRule.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.planner.plan.rules.logical;
+
+import org.apache.flink.table.planner.plan.utils.FlinkRelUtil;
+
+import org.apache.calcite.plan.RelOptRule;
+import org.apache.calcite.plan.RelOptRuleCall;
+import org.apache.calcite.rel.core.Calc;
+import org.apache.calcite.rel.core.Project;
+import org.apache.calcite.rel.logical.LogicalCalc;
+import org.apache.calcite.rel.rules.ProjectCalcMergeRule;
+import org.apache.calcite.rex.RexNode;
+
+/**
+ * Extends calcite's ProjectMergeRule, modification: only merge the two neighbouring {@link Project}
+ * and {@link Calc} if each non-deterministic {@link RexNode} of bottom {@link Calc} should appear
+ * at most once in the project list of top {@link Project}.
+ */
+public class FlinkProjectCalcMergeRule extends ProjectCalcMergeRule {
+
+    public static final RelOptRule INSTANCE = new FlinkProjectCalcMergeRule(Config.DEFAULT);
+
+    protected FlinkProjectCalcMergeRule(Config config) {
+        super(config);
+    }
+
+    @Override
+    public boolean matches(RelOptRuleCall call) {
+        final Project topProject = call.rel(0);
+        final LogicalCalc bottomCalc = call.rel(1);
+        return FlinkRelUtil.isMergeable(topProject, bottomCalc);
+    }
+}
diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkProjectMergeRule.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkProjectMergeRule.java
new file mode 100644
index 00000000000..1c0e8eeb21a
--- /dev/null
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/logical/FlinkProjectMergeRule.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.planner.plan.rules.logical;
+
+import org.apache.flink.table.planner.plan.utils.FlinkRelUtil;
+
+import org.apache.calcite.plan.RelOptRule;
+import org.apache.calcite.plan.RelOptRuleCall;
+import org.apache.calcite.rel.core.Project;
+import org.apache.calcite.rel.rules.ProjectMergeRule;
+import org.apache.calcite.rex.RexNode;
+
+/**
+ * Extends calcite's ProjectMergeRule, modification: only merge the two neighbouring {@link
+ * Project}s if each non-deterministic {@link RexNode} of bottom {@link Project} should appear at
+ * most once in the project list of top {@link Project}.
+ */
+public class FlinkProjectMergeRule extends ProjectMergeRule {
+
+    public static final RelOptRule INSTANCE = new FlinkProjectMergeRule(Config.DEFAULT);
+
+    protected FlinkProjectMergeRule(Config config) {
+        super(config);
+    }
+
+    @Override
+    public boolean matches(RelOptRuleCall call) {
+        final Project topProject = call.rel(0);
+        final Project bottomProject = call.rel(1);
+        return FlinkRelUtil.isMergeable(topProject, bottomProject);
+    }
+}
diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/utils/FlinkRelUtil.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/utils/FlinkRelUtil.java
new file mode 100644
index 00000000000..e49be537edc
--- /dev/null
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/utils/FlinkRelUtil.java
@@ -0,0 +1,171 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.planner.plan.utils;
+
+import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.Calc;
+import org.apache.calcite.rel.core.Filter;
+import org.apache.calcite.rel.core.Project;
+import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rex.RexInputRef;
+import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexProgram;
+import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.rex.RexVisitorImpl;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/** Utilities for {@link RelNode}. */
+public class FlinkRelUtil {
+
+    /**
+     * Return two neighbouring {@link Filter} and {@link Calc} can merge into one {@link Calc} or
+     * not. If the two nodes can merge into one, each non-deterministic {@link RexNode} of bottom
+     * {@link Calc} should appear at most once in the implicit project list and condition of top
+     * {@link Filter}.
+     */
+    public static boolean isMergeable(Filter topFilter, Calc bottomCalc) {
+        final RelDataType inputRowType = topFilter.getInput().getRowType();
+        final int inputFieldCnt = inputRowType.getFieldCount();
+        final int[] topInputRefCounter = initializeArray(inputFieldCnt, 0);
+        final RexProgram bottomProgram = bottomCalc.getProgram();
+        List<RexNode> topProjects = new ArrayList<>();
+        topProjects.add(topFilter.getCondition());
+        // the Filter node implicitly has a projection of input row
+        for (int i = 0; i < inputFieldCnt; i++) {
+            topProjects.add(new RexInputRef(i, inputRowType.getFieldList().get(i).getType()));
+        }
+        List<RexNode> bottomProjects =
+                bottomProgram.getProjectList().stream()
+                        .map(bottomProgram::expandLocalRef)
+                        .collect(Collectors.toList());
+
+        return mergeable(topInputRefCounter, topProjects, bottomProjects);
+    }
+
+    /**
+     * Return two neighbouring {@link Project} and {@link Calc} can merge into one {@link Calc} or
+     * not. If the two nodes can merge into one, each non-deterministic {@link RexNode} of bottom
+     * {@link Calc} should appear at most once in the project list of top {@link Project}.
+     */
+    public static boolean isMergeable(Project topProject, Calc bottomCalc) {
+        final int[] topInputRefCounter =
+                initializeArray(topProject.getInput().getRowType().getFieldCount(), 0);
+        final RexProgram bottomProgram = bottomCalc.getProgram();
+        List<RexNode> bottomProjects =
+                bottomProgram.getProjectList().stream()
+                        .map(bottomProgram::expandLocalRef)
+                        .collect(Collectors.toList());
+
+        return mergeable(topInputRefCounter, topProject.getProjects(), bottomProjects);
+    }
+
+    /**
+     * Return two neighbouring {@link Project} can merge into one {@link Project} or not. If the two
+     * {@link Project} can merge into one, each non-deterministic {@link RexNode} of bottom {@link
+     * Project} should appear at most once in the project list of top {@link Project}.
+     */
+    public static boolean isMergeable(Project topProject, Project bottomProject) {
+        final int[] topInputRefCounter =
+                initializeArray(topProject.getInput().getRowType().getFieldCount(), 0);
+
+        return mergeable(topInputRefCounter, topProject.getProjects(), bottomProject.getProjects());
+    }
+
+    /**
+     * Return two neighbouring {@link Calc} can merge into one {@link Calc} or not. If the two
+     * {@link Calc} can merge into one, each non-deterministic {@link RexNode} of bottom {@link
+     * Calc} should appear at most once in the project list of top {@link Calc}.
+     */
+    public static boolean isMergeable(Calc topCalc, Calc bottomCalc) {
+        final RexProgram topProgram = topCalc.getProgram();
+        final RexProgram bottomProgram = bottomCalc.getProgram();
+        final int[] topInputRefCounter =
+                initializeArray(topCalc.getInput().getRowType().getFieldCount(), 0);
+
+        List<RexNode> topInputRefs =
+                topProgram.getProjectList().stream()
+                        .map(topProgram::expandLocalRef)
+                        .collect(Collectors.toList());
+        List<RexNode> bottomProjects =
+                bottomProgram.getProjectList().stream()
+                        .map(bottomProgram::expandLocalRef)
+                        .collect(Collectors.toList());
+        if (null != topProgram.getCondition()) {
+            topInputRefs.add(topProgram.expandLocalRef(topProgram.getCondition()));
+        }
+
+        return mergeable(topInputRefCounter, topInputRefs, bottomProjects);
+    }
+
+    /**
+     * Returns an int array with given length and initial value.
+     *
+     * @param length array length
+     * @param initVal initial value
+     * @return initialized int array
+     */
+    public static int[] initializeArray(int length, int initVal) {
+        final int[] array = new int[length];
+        Arrays.fill(array, initVal);
+        return array;
+    }
+
+    /**
+     * An InputRefCounter that count every inputRef's reference count number, every reference will
+     * be counted, e.g., '$0 + 1' & '$0 + 2' will count 2 instead of 1.
+     */
+    private static class InputRefCounter extends RexVisitorImpl<Void> {
+        final int[] refCounts;
+
+        public InputRefCounter(boolean deep, int[] refCounts) {
+            super(deep);
+            this.refCounts = refCounts;
+        }
+
+        @Override
+        public Void visitInputRef(RexInputRef inputRef) {
+            final int index = inputRef.getIndex();
+            refCounts[index]++;
+            return null;
+        }
+    }
+
+    /** The internal reusable method for filter, project nd calc. */
+    private static boolean mergeable(
+            int[] topInputRefCounter, List<RexNode> topProjects, List<RexNode> bottomProjects) {
+        RexUtil.apply(new InputRefCounter(true, topInputRefCounter), topProjects, null);
+
+        boolean mergeable = true;
+        for (int idx = 0; idx < bottomProjects.size(); idx++) {
+            RexNode node = bottomProjects.get(idx);
+            if (!RexUtil.isDeterministic(node)) {
+                assert idx < topInputRefCounter.length;
+                if (topInputRefCounter[idx] > 1) {
+                    mergeable = false;
+                    break;
+                }
+            }
+        }
+        return mergeable;
+    }
+}
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkBatchRuleSets.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkBatchRuleSets.scala
index 583b1f01727..304fbee54af 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkBatchRuleSets.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkBatchRuleSets.scala
@@ -196,7 +196,7 @@ object FlinkBatchRuleSets {
     // push a projection to the children of a semi/anti Join
     ProjectSemiAntiJoinTransposeRule.INSTANCE,
     // merge projections
-    CoreRules.PROJECT_MERGE,
+    FlinkProjectMergeRule.INSTANCE,
     // remove identity project
     CoreRules.PROJECT_REMOVE,
     // removes constant keys from an Agg
@@ -288,7 +288,7 @@ object FlinkBatchRuleSets {
 
     // calc rules
     FlinkFilterCalcMergeRule.INSTANCE,
-    CoreRules.PROJECT_CALC_MERGE,
+    FlinkProjectCalcMergeRule.INSTANCE,
     CoreRules.FILTER_TO_CALC,
     CoreRules.PROJECT_TO_CALC,
     FlinkCalcMergeRule.INSTANCE,
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkStreamRuleSets.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkStreamRuleSets.scala
index b8512cf07fd..1b6c0b01145 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkStreamRuleSets.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/FlinkStreamRuleSets.scala
@@ -106,7 +106,7 @@ object FlinkStreamRuleSets {
           // fix: FLINK-17553 unsupported call error when constant exists in group window key
           // this rule will merge the project generated by AggregateProjectPullUpConstantsRule and
           // make sure window aggregate can be correctly rewritten by StreamLogicalWindowAggregateRule
-          CoreRules.PROJECT_MERGE,
+          FlinkProjectMergeRule.INSTANCE,
           StreamLogicalWindowAggregateRule.INSTANCE,
           // slices a project into sections which contain window agg functions
           // and sections which do not.
@@ -200,7 +200,7 @@ object FlinkStreamRuleSets {
     // push a projection to the children of a semi/anti Join
     ProjectSemiAntiJoinTransposeRule.INSTANCE,
     // merge projections
-    CoreRules.PROJECT_MERGE,
+    FlinkProjectMergeRule.INSTANCE,
     // remove identity project
     CoreRules.PROJECT_REMOVE,
     // removes constant keys from an Agg
@@ -281,7 +281,7 @@ object FlinkStreamRuleSets {
 
     // calc rules
     FlinkFilterCalcMergeRule.INSTANCE,
-    CoreRules.PROJECT_CALC_MERGE,
+    FlinkProjectCalcMergeRule.INSTANCE,
     CoreRules.FILTER_TO_CALC,
     CoreRules.PROJECT_TO_CALC,
     FlinkCalcMergeRule.INSTANCE,
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala
index a088879e281..fa7deac73c6 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/rules/logical/FlinkCalcMergeRule.scala
@@ -18,15 +18,12 @@
 package org.apache.flink.table.planner.plan.rules.logical
 
 import org.apache.flink.table.planner.plan.nodes.physical.stream.StreamPhysicalCalc
-import org.apache.flink.table.planner.plan.utils.FlinkRexUtil
+import org.apache.flink.table.planner.plan.utils.{FlinkRelUtil, FlinkRexUtil}
 
 import org.apache.calcite.plan.{RelOptRule, RelOptRuleCall}
 import org.apache.calcite.plan.RelOptRule.{any, operand}
-import org.apache.calcite.plan.RelOptUtil.InputFinder
 import org.apache.calcite.rel.core.{Calc, RelFactories}
-import org.apache.calcite.rex.{RexNode, RexOver, RexProgramBuilder, RexUtil}
-
-import scala.collection.JavaConversions._
+import org.apache.calcite.rex.{RexNode, RexOver, RexProgramBuilder}
 
 /**
  * This rule is copied from Calcite's [[org.apache.calcite.rel.rules.CalcMergeRule]].
@@ -61,49 +58,7 @@ class FlinkCalcMergeRule[C <: Calc](calcClass: Class[C])
       return false
     }
 
-    isMergeable(topCalc, bottomCalc)
-  }
-
-  /**
-   * Return two neighbouring [[Calc]] can merge into one [[Calc]] or not. If the two [[Calc]] can
-   * merge into one, each non-deterministic [[RexNode]] of bottom [[Calc]] should appear at most
-   * once in the project list and filter list of top [[Calc]].
-   */
-  private def isMergeable(topCalc: Calc, bottomCalc: Calc): Boolean = {
-    val topProgram = topCalc.getProgram
-    val bottomProgram = bottomCalc.getProgram
-
-    val topProjectInputIndices = topProgram.getProjectList
-      .map(r => topProgram.expandLocalRef(r))
-      .map(r => InputFinder.bits(r).toArray)
-
-    val topFilterInputIndices = if (topProgram.getCondition != null) {
-      InputFinder.bits(topProgram.expandLocalRef(topProgram.getCondition)).toArray
-    } else {
-      new Array[Int](0)
-    }
-
-    val bottomProjectList = bottomProgram.getProjectList
-      .map(r => bottomProgram.expandLocalRef(r))
-      .toArray
-
-    val topInputIndices = topProjectInputIndices :+ topFilterInputIndices
-
-    bottomProjectList.zipWithIndex.forall {
-      case (project: RexNode, index: Int) => {
-        var nonDeterministicRexRefCnt = 0
-        if (!RexUtil.isDeterministic(project)) {
-          topInputIndices.foreach(
-            indices =>
-              indices.foreach(
-                ref =>
-                  if (ref == index) {
-                    nonDeterministicRexRefCnt += 1
-                  }))
-        }
-        nonDeterministicRexRefCnt <= 1
-      }
-    }
+    FlinkRelUtil.isMergeable(topCalc, bottomCalc)
   }
 
   override def onMatch(call: RelOptRuleCall): Unit = {
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala
index 4cca5d8b139..057fa50ed9c 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala
@@ -312,6 +312,7 @@ object FlinkRexUtil {
 
   /**
    * Find all inputRefs.
+   *
    * @return
    *   InputRef HashSet.
    */
@@ -612,6 +613,7 @@ object FlinkRexUtil {
 
   /**
    * Returns whether a given [[RexProgram]] is deterministic.
+   *
    * @return
    *   false if any expression of the program is not deterministic
    */
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRuleTest.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRuleTest.java
index 5b2ea8135cc..9d16e67c7c5 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRuleTest.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRuleTest.java
@@ -360,16 +360,16 @@ public class PushProjectIntoTableSourceScanRuleTest
 
     private void replaceProgramWithProjectMergeRule() {
         FlinkChainedProgram programs = new FlinkChainedProgram<BatchOptimizeContext>();
-        programs
-                .addLast(
-                        "rules",
-                        FlinkHepRuleSetProgramBuilder.<BatchOptimizeContext>newBuilder()
-                                .setHepRulesExecutionType(HEP_RULES_EXECUTION_TYPE.RULE_SEQUENCE())
-                                .setHepMatchOrder(HepMatchOrder.BOTTOM_UP)
-                                .add(RuleSets.ofList(
+        programs.addLast(
+                "rules",
+                FlinkHepRuleSetProgramBuilder.<BatchOptimizeContext>newBuilder()
+                        .setHepRulesExecutionType(HEP_RULES_EXECUTION_TYPE.RULE_SEQUENCE())
+                        .setHepMatchOrder(HepMatchOrder.BOTTOM_UP)
+                        .add(
+                                RuleSets.ofList(
                                         CoreRules.PROJECT_MERGE,
                                         PushProjectIntoTableSourceScanRule.INSTANCE))
-                                .build());
+                        .build());
         util().replaceBatchProgram(programs);
     }
 
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/CalcMergeTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/CalcMergeTest.xml
index 6adb95720ad..06f29420cee 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/CalcMergeTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/CalcMergeTest.xml
@@ -30,8 +30,9 @@ LogicalProject(a2=[random_udf($0)], a3=[random_udf($0)])
     </Resource>
     <Resource name="optimized exec plan">
       <![CDATA[
-Calc(select=[random_udf(random_udf(a)) AS a2, random_udf(random_udf(a)) AS a3], where=[(b > 10)])
-+- TableSourceScan(table=[[default_catalog, default_database, MyTable, filter=[], project=[a, b], metadata=[]]], fields=[a, b])
+Calc(select=[random_udf(a1) AS a2, random_udf(a1) AS a3])
++- Calc(select=[random_udf(a) AS a1, b], where=[(b > 10)])
+   +- TableSourceScan(table=[[default_catalog, default_database, MyTable, filter=[], project=[a, b], metadata=[]]], fields=[a, b])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/nodes/exec/stream/DeduplicationJsonPlanTest_jsonplan/testDeduplication.out b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/nodes/exec/stream/DeduplicationJsonPlanTest_jsonplan/testDeduplication.out
index e17cf5d7e35..727b9f5f13c 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/nodes/exec/stream/DeduplicationJsonPlanTest_jsonplan/testDeduplication.out
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/nodes/exec/stream/DeduplicationJsonPlanTest_jsonplan/testDeduplication.out
@@ -105,7 +105,7 @@
         "name" : "order_time",
         "fieldType" : "TIMESTAMP(3)"
       }, {
-        "name" : "$4",
+        "name" : "proctime",
         "fieldType" : {
           "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
           "nullable" : false,
@@ -114,7 +114,7 @@
         }
       } ]
     },
-    "description" : "Calc(select=[order_id, user, product, order_time, PROCTIME() AS $4])"
+    "description" : "Calc(select=[order_id, user, product, order_time, PROCTIME() AS proctime])"
   }, {
     "id" : 3,
     "type" : "stream-exec-exchange_1",
@@ -141,7 +141,7 @@
         "name" : "order_time",
         "fieldType" : "TIMESTAMP(3)"
       }, {
-        "name" : "$4",
+        "name" : "proctime",
         "fieldType" : {
           "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
           "nullable" : false,
@@ -191,7 +191,7 @@
         "name" : "order_time",
         "fieldType" : "TIMESTAMP(3)"
       }, {
-        "name" : "$4",
+        "name" : "proctime",
         "fieldType" : {
           "type" : "TIMESTAMP_WITH_LOCAL_TIME_ZONE",
           "nullable" : false,
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/CalcMergeTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/CalcMergeTest.xml
index 6adb95720ad..06f29420cee 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/CalcMergeTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/CalcMergeTest.xml
@@ -30,8 +30,9 @@ LogicalProject(a2=[random_udf($0)], a3=[random_udf($0)])
     </Resource>
     <Resource name="optimized exec plan">
       <![CDATA[
-Calc(select=[random_udf(random_udf(a)) AS a2, random_udf(random_udf(a)) AS a3], where=[(b > 10)])
-+- TableSourceScan(table=[[default_catalog, default_database, MyTable, filter=[], project=[a, b], metadata=[]]], fields=[a, b])
+Calc(select=[random_udf(a1) AS a2, random_udf(a1) AS a3])
++- Calc(select=[random_udf(a) AS a1, b], where=[(b > 10)])
+   +- TableSourceScan(table=[[default_catalog, default_database, MyTable, filter=[], project=[a, b], metadata=[]]], fields=[a, b])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.xml
index c8a69536d4c..be0561d35d2 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.xml
@@ -2529,10 +2529,10 @@ LogicalSink(table=[default_catalog.default_database.sink_without_pk], fields=[a,
     <Resource name="optimized exec plan">
       <![CDATA[
 Sink(table=[default_catalog.default_database.sink_without_pk], fields=[a, b, c])
-+- Calc(select=[a, IF((a > 100), (d + $3), d) AS b, CASE(($3 > 100), JSON_VALUE(c, '$.count'), ||(CAST(d AS VARCHAR(2147483647)), '#')) AS c])
-   +- Rank(strategy=[RetractStrategy], rankType=[ROW_NUMBER], rankRange=[rankStart=1, rankEnd=1], partitionBy=[a], orderBy=[$3 DESC], select=[a, c, d, $3])
++- Calc(select=[a, IF((a > 100), (b + d), b) AS b, CASE((d > 100), JSON_VALUE(c, '$.count'), ||(CAST(b AS VARCHAR(2147483647)), '#')) AS c])
+   +- Rank(strategy=[RetractStrategy], rankType=[ROW_NUMBER], rankRange=[rankStart=1, rankEnd=1], partitionBy=[a], orderBy=[d DESC], select=[a, b, c, d])
       +- Exchange(distribution=[hash[a]])
-         +- Calc(select=[a, c, d, ndFunc(b) AS $3])
+         +- Calc(select=[a, d AS b, c, ndFunc(b) AS d])
             +- TableSourceScan(table=[[default_catalog, default_database, cdc]], fields=[a, b, c, d])
 ]]>
     </Resource>
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.xml
index df38c1a2dcd..5c767a80a00 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/TemporalJoinTest.xml
@@ -556,8 +556,8 @@ LogicalProject(amount=[$0], currency=[$1], rowtime=[$2], proctime=[$3], currency
     </Resource>
     <Resource name="optimized exec plan">
       <![CDATA[
-Calc(select=[amount, currency, rowtime, PROCTIME_MATERIALIZE(proctime) AS proctime, currency0, rate, PROCTIME_MATERIALIZE($2) AS $2])
-+- TemporalJoin(joinType=[InnerJoin], where=[((currency = currency0) AND __TEMPORAL_JOIN_CONDITION(proctime, __TEMPORAL_JOIN_CONDITION_PRIMARY_KEY(currency0), __TEMPORAL_JOIN_LEFT_KEY(currency), __TEMPORAL_JOIN_RIGHT_KEY(currency0)))], select=[amount, currency, rowtime, proctime, currency0, rate, $2])
+Calc(select=[amount, currency, rowtime, PROCTIME_MATERIALIZE(proctime) AS proctime, currency0, rate, PROCTIME_MATERIALIZE(proctime0) AS proctime0])
++- TemporalJoin(joinType=[InnerJoin], where=[((currency = currency0) AND __TEMPORAL_JOIN_CONDITION(proctime, __TEMPORAL_JOIN_CONDITION_PRIMARY_KEY(currency0), __TEMPORAL_JOIN_LEFT_KEY(currency), __TEMPORAL_JOIN_RIGHT_KEY(currency0)))], select=[amount, currency, rowtime, proctime, currency0, rate, proctime0])
    :- Exchange(distribution=[hash[currency]])
    :  +- WatermarkAssigner(rowtime=[rowtime], watermark=[rowtime])
    :     +- Calc(select=[amount, currency, rowtime, PROCTIME() AS proctime])
@@ -565,7 +565,7 @@ Calc(select=[amount, currency, rowtime, PROCTIME_MATERIALIZE(proctime) AS procti
    +- Exchange(distribution=[hash[currency]])
       +- Deduplicate(keep=[LastRow], key=[currency], order=[PROCTIME])
          +- Exchange(distribution=[hash[currency]])
-            +- Calc(select=[currency, rate, PROCTIME() AS $2])
+            +- Calc(select=[currency, rate, PROCTIME() AS proctime])
                +- TableSourceScan(table=[[default_catalog, default_database, RatesOnly]], fields=[currency, rate])
 ]]>
     </Resource>
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.scala
index 0e153d0ea52..58b0737683c 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/NonDeterministicDagTest.scala
@@ -229,7 +229,7 @@ class NonDeterministicDagTest(nonDeterministicUpdateStrategy: NonDeterministicUp
   def testNonDeterministicProjectionWithSinkWithoutPk(): Unit = {
     if (tryResolve) {
       thrown.expectMessage(
-        "The column(s): $3(generated by non-deterministic function: ndFunc ) can not satisfy the determinism")
+        "The column(s): d(generated by non-deterministic function: ndFunc ) can not satisfy the determinism")
       thrown.expect(classOf[TableException])
     }
     util.verifyExecPlanInsert("""
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala
index a0849349ace..ddfc2afa61b 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala
@@ -2283,4 +2283,19 @@ class CalcITCase extends BatchTestBase {
         |""".stripMargin,
       Seq(row(2, "cbc\"ddd")))
   }
+
+  @Test
+  def testNonMergeableRandCall(): Unit = {
+    // reported in FLINK-20887
+    checkResult(
+      s"""
+         |SELECT b - a FROM (
+         |  SELECT r + 5 AS a, r + 7 AS b FROM (
+         |    SELECT RAND() AS r FROM SmallTable3
+         |  ) t1
+         |) t2
+         |""".stripMargin,
+      Seq(row(2.0), row(2.0), row(2.0))
+    )
+  }
 }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala
index 5ebd4acb2ea..2ee99119bd6 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala
@@ -769,4 +769,28 @@ class CalcITCase extends StreamingTestBase {
     val expected = List("2,cbc\"ddd")
     assertEquals(expected.sorted, sink.getAppendResults.sorted)
   }
+
+  @Test
+  def testNonMergeableRandCall(): Unit = {
+    val t = env
+      .fromCollection(TestData.smallTupleData3)
+      .toTable(tEnv, 'a, 'b, 'c)
+    tEnv.createTemporaryView("SimpleTable", t)
+
+    val result = tEnv
+      .sqlQuery(s"""
+                   |SELECT b - a FROM (
+                   |  SELECT r + 5 AS a, r + 7 AS b FROM (
+                   |    SELECT RAND() AS r FROM SimpleTable
+                   |  ) t1
+                   |) t2
+                   |""".stripMargin)
+      .toAppendStream[Row]
+    val sink = new TestingAppendSink
+    result.addSink(sink)
+    env.execute()
+
+    val expected = List("2.0", "2.0", "2.0")
+    assertEquals(expected.sorted, sink.getAppendResults.sorted)
+  }
 }
