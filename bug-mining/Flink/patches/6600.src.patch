diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRule.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRule.java
index 8dcb45e86e8..c56cca21ef9 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRule.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRule.java
@@ -142,6 +142,10 @@ public abstract class DynamicPartitionPruningRule extends RelRule<RelRule.Config
         List<String> acceptedFields =
                 ((SupportsDynamicFiltering) tableSource).applyDynamicFiltering(candidateFields);
 
+        if (acceptedFields == null) {
+            return new ArrayList<>();
+        }
+
         for (String field : acceptedFields) {
             if (!candidateFields.contains(field)) {
                 throw new TableException(
@@ -152,9 +156,35 @@ public abstract class DynamicPartitionPruningRule extends RelRule<RelRule.Config
             }
         }
 
-        return acceptedFields.stream()
-                .map(f -> factScan.getRowType().getFieldNames().indexOf(f))
-                .collect(Collectors.toList());
+        if (factCalc == null) {
+            return acceptedFields.stream()
+                    .map(f -> factScan.getRowType().getFieldNames().indexOf(f))
+                    .collect(Collectors.toList());
+        } else {
+            return getAcceptedFieldsIndicesInCalc(acceptedFields, factJoinKeys, factCalc, factScan);
+        }
+    }
+
+    private static List<Integer> getAcceptedFieldsIndicesInCalc(
+            List<String> acceptedFields,
+            List<Integer> factJoinKeys,
+            BatchPhysicalCalc factCalc,
+            BatchPhysicalTableSourceScan factScan) {
+        List<Integer> acceptedFieldsIndicesInFactScan =
+                acceptedFields.stream()
+                        .map(f -> factScan.getRowType().getFieldNames().indexOf(f))
+                        .collect(Collectors.toList());
+        RexProgram program = factCalc.getProgram();
+        List<Integer> acceptedFieldsIndicesInCalc = new ArrayList<>();
+        for (int joinKeyIdx : factJoinKeys) {
+            RexNode node = program.expandLocalRef(program.getProjectList().get(joinKeyIdx));
+            if (node instanceof RexInputRef
+                    && acceptedFieldsIndicesInFactScan.contains(((RexInputRef) node).getIndex())) {
+                acceptedFieldsIndicesInCalc.add(joinKeyIdx);
+            }
+        }
+
+        return acceptedFieldsIndicesInCalc;
     }
 
     protected BatchPhysicalDynamicFilteringTableSourceScan createDynamicFilteringTableSourceScan(
@@ -200,7 +230,6 @@ public abstract class DynamicPartitionPruningRule extends RelRule<RelRule.Config
                         .projectStructType(
                                 dimSide.getRowType(),
                                 dynamicFilteringFieldIndices.stream().mapToInt(i -> i).toArray());
-
         return new BatchPhysicalDynamicFilteringDataCollector(
                 dimSide.getCluster(),
                 dimSide.getTraitSet(),
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.java
index eb4e6964c6e..51efc661996 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.java
@@ -273,6 +273,24 @@ public class DynamicPartitionPruningRuleTest extends TableTestBase {
         util.verifyRelPlan(query);
     }
 
+    @Test
+    public void testPartitionKeysOrderIsChangedInFactSide() {
+        // Dynamic filtering will succeed for this query.
+        String query =
+                "Select * from dim join (select fact_date_sk, id, name, amount, price from fact_part) t1"
+                        + " on t1.fact_date_sk = dim_date_sk and t1.price > 200 and dim.price < 500";
+        util.verifyRelPlan(query);
+    }
+
+    @Test
+    public void testPartitionKeysNameIsChangedInFactSide() {
+        // Dynamic filtering will succeed for this query.
+        String query =
+                "Select * from dim join (select id, name, amount, price, fact_date_sk as fact_date_sk1 from fact_part) t1"
+                        + " on t1.fact_date_sk1 = dim_date_sk and t1.price > 200 and dim.price < 500";
+        util.verifyRelPlan(query);
+    }
+
     @Test
     public void testDynamicFilteringFieldIsComputeColumnsInFactSide()
             throws TableNotExistException {
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.xml
index 0cf687019fc..b1951732632 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/physical/batch/DynamicPartitionPruningRuleTest.xml
@@ -66,7 +66,7 @@ HashJoin(joinType=[InnerJoin], where=[=(fact_date_sk1, dim_date_sk)], select=[id
 +- Exchange(distribution=[hash[fact_date_sk1]])
    +- Calc(select=[fact_date_sk AS fact_date_sk1, +(price, 1) AS price1], where=[>(+(price, 1), 200)])
       +- DynamicFilteringTableSourceScan(table=[[testCatalog, test_database, fact_part, filter=[], project=[price, fact_date_sk], metadata=[]]], fields=[price, fact_date_sk])
-         +- DynamicFilteringDataCollector(fields=[])
+         +- DynamicFilteringDataCollector(fields=[dim_date_sk])
             +- Calc(select=[id, male, amount, price, dim_date_sk], where=[<(price, 500)])
                +- TableSourceScan(table=[[testCatalog, test_database, dim, filter=[]]], fields=[id, male, amount, price, dim_date_sk])
 ]]>
@@ -765,6 +765,34 @@ HashJoin(joinType=[InnerJoin], where=[=(fact_date_sk1, dim_date_sk)], select=[id
 +- Exchange(distribution=[hash[fact_date_sk1]])
    +- Calc(select=[+(fact_date_sk, 1) AS fact_date_sk1, +(price, 1) AS price1], where=[>(+(price, 1), 200)])
       +- TableSourceScan(table=[[testCatalog, test_database, fact_part, filter=[], project=[price, fact_date_sk], metadata=[]]], fields=[price, fact_date_sk])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testPartitionKeysNameIsChangedInFactSide">
+    <Resource name="sql">
+      <![CDATA[Select * from dim join (select id, name, amount, price, fact_date_sk as fact_date_sk1 from fact_part) t1 on t1.fact_date_sk1 = dim_date_sk and t1.price > 200 and dim.price < 500]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(id=[$0], male=[$1], amount=[$2], price=[$3], dim_date_sk=[$4], id0=[$5], name=[$6], amount0=[$7], price0=[$8], fact_date_sk1=[$9])
++- LogicalJoin(condition=[AND(=($9, $4), >($8, 200), <($3, 500))], joinType=[inner])
+   :- LogicalTableScan(table=[[testCatalog, test_database, dim]])
+   +- LogicalProject(id=[$0], name=[$1], amount=[$2], price=[$3], fact_date_sk1=[$4])
+      +- LogicalTableScan(table=[[testCatalog, test_database, fact_part]])
+]]>
+    </Resource>
+    <Resource name="optimized rel plan">
+      <![CDATA[
+HashJoin(joinType=[InnerJoin], where=[=(fact_date_sk, dim_date_sk)], select=[id, male, amount, price, dim_date_sk, id0, name, amount0, price0, fact_date_sk], build=[left])
+:- Exchange(distribution=[hash[dim_date_sk]])
+:  +- Calc(select=[id, male, amount, price, dim_date_sk], where=[<(price, 500)])
+:     +- TableSourceScan(table=[[testCatalog, test_database, dim, filter=[]]], fields=[id, male, amount, price, dim_date_sk])
++- Exchange(distribution=[hash[fact_date_sk]])
+   +- Calc(select=[id, name, amount, price, fact_date_sk], where=[>(price, 200)])
+      +- DynamicFilteringTableSourceScan(table=[[testCatalog, test_database, fact_part, filter=[]]], fields=[id, name, amount, price, fact_date_sk])
+         +- DynamicFilteringDataCollector(fields=[dim_date_sk])
+            +- Calc(select=[id, male, amount, price, dim_date_sk], where=[<(price, 500)])
+               +- TableSourceScan(table=[[testCatalog, test_database, dim, filter=[]]], fields=[id, male, amount, price, dim_date_sk])
 ]]>
     </Resource>
   </TestCase>
@@ -794,6 +822,34 @@ HashJoin(joinType=[LeftSemiJoin], where=[=(fact_date_sk, dim_date_sk)], select=[
 +- Exchange(distribution=[hash[dim_date_sk]])
    +- Calc(select=[dim_date_sk], where=[<(price, 500)])
       +- TableSourceScan(table=[[testCatalog, test_database, dim, filter=[], project=[price, dim_date_sk], metadata=[]]], fields=[price, dim_date_sk])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testPartitionKeysOrderIsChangedInFactSide">
+    <Resource name="sql">
+      <![CDATA[Select * from dim join (select fact_date_sk, id, name, amount, price from fact_part) t1 on t1.fact_date_sk = dim_date_sk and t1.price > 200 and dim.price < 500]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(id=[$0], male=[$1], amount=[$2], price=[$3], dim_date_sk=[$4], fact_date_sk=[$5], id0=[$6], name=[$7], amount0=[$8], price0=[$9])
++- LogicalJoin(condition=[AND(=($5, $4), >($9, 200), <($3, 500))], joinType=[inner])
+   :- LogicalTableScan(table=[[testCatalog, test_database, dim]])
+   +- LogicalProject(fact_date_sk=[$4], id=[$0], name=[$1], amount=[$2], price=[$3])
+      +- LogicalTableScan(table=[[testCatalog, test_database, fact_part]])
+]]>
+    </Resource>
+    <Resource name="optimized rel plan">
+      <![CDATA[
+HashJoin(joinType=[InnerJoin], where=[=(fact_date_sk, dim_date_sk)], select=[id, male, amount, price, dim_date_sk, fact_date_sk, id0, name, amount0, price0], build=[left])
+:- Exchange(distribution=[hash[dim_date_sk]])
+:  +- Calc(select=[id, male, amount, price, dim_date_sk], where=[<(price, 500)])
+:     +- TableSourceScan(table=[[testCatalog, test_database, dim, filter=[]]], fields=[id, male, amount, price, dim_date_sk])
++- Exchange(distribution=[hash[fact_date_sk]])
+   +- Calc(select=[fact_date_sk, id, name, amount, price], where=[>(price, 200)])
+      +- DynamicFilteringTableSourceScan(table=[[testCatalog, test_database, fact_part, filter=[]]], fields=[id, name, amount, price, fact_date_sk])
+         +- DynamicFilteringDataCollector(fields=[dim_date_sk])
+            +- Calc(select=[id, male, amount, price, dim_date_sk], where=[<(price, 500)])
+               +- TableSourceScan(table=[[testCatalog, test_database, dim, filter=[]]], fields=[id, male, amount, price, dim_date_sk])
 ]]>
     </Resource>
   </TestCase>
