diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
index a4a12144181..2f052ec819c 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
@@ -127,7 +127,7 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
     private final AtomicBoolean isShutDown = new AtomicBoolean(false);
 
     @GuardedBy("lock")
-    private ResourceID resourceId;
+    private DeterminismEnvelope<ResourceID> resourceId;
 
     @GuardedBy("lock")
     private DispatcherResourceManagerComponent clusterComponent;
@@ -154,7 +154,7 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
     private ExecutorService ioExecutor;
 
     @GuardedBy("lock")
-    private WorkingDirectory workingDirectory;
+    private DeterminismEnvelope<WorkingDirectory> workingDirectory;
 
     private ExecutionGraphInfoStore executionGraphInfoStore;
 
@@ -262,7 +262,7 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
             clusterComponent =
                     dispatcherResourceManagerComponentFactory.create(
                             configuration,
-                            resourceId,
+                            resourceId.unwrap(),
                             ioExecutor,
                             commonRpcService,
                             haServices,
@@ -307,8 +307,14 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
             resourceId =
                     configuration
                             .getOptional(JobManagerOptions.JOB_MANAGER_RESOURCE_ID)
-                            .map(ResourceID::new)
-                            .orElseGet(ResourceID::generate);
+                            .map(
+                                    value ->
+                                            DeterminismEnvelope.deterministicValue(
+                                                    new ResourceID(value)))
+                            .orElseGet(
+                                    () ->
+                                            DeterminismEnvelope.nondeterministicValue(
+                                                    ResourceID.generate()));
 
             LOG.debug(
                     "Initialize cluster entrypoint {} with resource id {}.",
@@ -346,7 +352,7 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
             blobServer =
                     BlobUtils.createBlobServer(
                             configuration,
-                            Reference.borrowed(workingDirectory.getBlobStorageDirectory()),
+                            Reference.borrowed(workingDirectory.unwrap().getBlobStorageDirectory()),
                             haServices.createBlobStore());
             blobServer.start();
             heartbeatServices = createHeartbeatServices(configuration);
@@ -601,13 +607,15 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
             ioException = ioe;
         }
 
-        // We only clean up the working directory if we gracefully shut down. If it is a process
-        // failure, then we want to keep the working directory for potential recoveries.
-        if (shutdownBehaviour == ShutdownBehaviour.GRACEFUL_SHUTDOWN) {
-            synchronized (lock) {
-                if (workingDirectory != null) {
+        synchronized (lock) {
+            if (workingDirectory != null) {
+                // We only clean up the working directory if we gracefully shut down or if its path
+                // is nondeterministic. If it is a process failure, then we want to keep the working
+                // directory for potential recoveries.
+                if (!workingDirectory.isDeterministic()
+                        || shutdownBehaviour == ShutdownBehaviour.GRACEFUL_SHUTDOWN) {
                     try {
-                        workingDirectory.delete();
+                        workingDirectory.unwrap().delete();
                     } catch (IOException ioe) {
                         ioException = ExceptionUtils.firstOrSuppressed(ioe, ioException);
                     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointUtils.java
index 57f15f0155c..41235348efc 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointUtils.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointUtils.java
@@ -140,14 +140,18 @@ public final class ClusterEntrypointUtils {
      * working directory exists.
      *
      * @param configuration to extract the required settings from
-     * @param resourceId identifying the TaskManager process
+     * @param envelopedResourceId identifying the TaskManager process
      * @return working directory
      * @throws IOException if the working directory could not be created
      */
-    public static WorkingDirectory createTaskManagerWorkingDirectory(
-            Configuration configuration, ResourceID resourceId) throws IOException {
-        return WorkingDirectory.create(
-                generateTaskManagerWorkingDirectoryFile(configuration, resourceId));
+    public static DeterminismEnvelope<WorkingDirectory> createTaskManagerWorkingDirectory(
+            Configuration configuration, DeterminismEnvelope<ResourceID> envelopedResourceId)
+            throws IOException {
+        return envelopedResourceId.map(
+                resourceId ->
+                        WorkingDirectory.create(
+                                generateTaskManagerWorkingDirectoryFile(
+                                        configuration, resourceId)));
     }
 
     /**
@@ -225,13 +229,16 @@ public final class ClusterEntrypointUtils {
      * working diretory exists.
      *
      * @param configuration to extract the required settings from
-     * @param resourceId identifying the TaskManager process
+     * @param envelopedResourceId identifying the TaskManager process
      * @return working directory
      * @throws IOException if the working directory could not be created
      */
-    public static WorkingDirectory createJobManagerWorkingDirectory(
-            Configuration configuration, ResourceID resourceId) throws IOException {
-        return WorkingDirectory.create(
-                generateJobManagerWorkingDirectoryFile(configuration, resourceId));
+    public static DeterminismEnvelope<WorkingDirectory> createJobManagerWorkingDirectory(
+            Configuration configuration, DeterminismEnvelope<ResourceID> envelopedResourceId)
+            throws IOException {
+        return envelopedResourceId.map(
+                resourceId ->
+                        WorkingDirectory.create(
+                                generateJobManagerWorkingDirectoryFile(configuration, resourceId)));
     }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/DeterminismEnvelope.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/DeterminismEnvelope.java
new file mode 100644
index 00000000000..f0fecbfa0ea
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/DeterminismEnvelope.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.entrypoint;
+
+import org.apache.flink.util.function.FunctionWithException;
+
+/**
+ * Envelope that carries whether the wrapped value is deterministic or not.
+ *
+ * @param <T> type of the wrapped value
+ */
+public class DeterminismEnvelope<T> {
+
+    private final T value;
+
+    private final boolean isDeterministic;
+
+    private DeterminismEnvelope(T value, boolean isDeterministic) {
+        this.value = value;
+        this.isDeterministic = isDeterministic;
+    }
+
+    public boolean isDeterministic() {
+        return isDeterministic;
+    }
+
+    public T unwrap() {
+        return value;
+    }
+
+    public <V, E extends Exception> DeterminismEnvelope<V> map(
+            FunctionWithException<? super T, ? extends V, E> mapper) throws E {
+        final V newValue = mapper.apply(value);
+
+        if (isDeterministic) {
+            return deterministicValue(newValue);
+        } else {
+            return nondeterministicValue(newValue);
+        }
+    }
+
+    public static <T> DeterminismEnvelope<T> deterministicValue(T value) {
+        return new DeterminismEnvelope<>(value, true);
+    }
+
+    public static <T> DeterminismEnvelope<T> nondeterministicValue(T value) {
+        return new DeterminismEnvelope<>(value, false);
+    }
+
+    @Override
+    public String toString() {
+        return value.toString();
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
index 1fd0bcc9bb4..d4f56f2b416 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
@@ -37,6 +37,7 @@ import org.apache.flink.runtime.blob.BlobUtils;
 import org.apache.flink.runtime.blob.TaskExecutorBlobService;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.entrypoint.ClusterEntrypointUtils;
+import org.apache.flink.runtime.entrypoint.DeterminismEnvelope;
 import org.apache.flink.runtime.entrypoint.FlinkParseException;
 import org.apache.flink.runtime.entrypoint.WorkingDirectory;
 import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;
@@ -78,6 +79,7 @@ import org.apache.flink.util.StringUtils;
 import org.apache.flink.util.TaskManagerExceptionUtils;
 import org.apache.flink.util.concurrent.ExecutorThreadFactory;
 import org.apache.flink.util.concurrent.FutureUtils;
+import org.apache.flink.util.function.FunctionUtils;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -114,7 +116,7 @@ public class TaskManagerRunner implements FatalErrorHandler {
 
     private final Configuration configuration;
 
-    private final ResourceID resourceId;
+    private final DeterminismEnvelope<ResourceID> resourceId;
 
     private final Time timeout;
 
@@ -131,7 +133,7 @@ public class TaskManagerRunner implements FatalErrorHandler {
 
     private final TaskExecutorService taskExecutorService;
 
-    private final WorkingDirectory workingDirectory;
+    private final DeterminismEnvelope<WorkingDirectory> workingDirectory;
 
     private final CompletableFuture<Result> terminationFuture;
 
@@ -188,12 +190,12 @@ public class TaskManagerRunner implements FatalErrorHandler {
         final RpcService metricQueryServiceRpcService =
                 MetricUtils.startRemoteMetricsRpcService(
                         configuration, rpcService.getAddress(), rpcSystem);
-        metricRegistry.startQueryService(metricQueryServiceRpcService, resourceId);
+        metricRegistry.startQueryService(metricQueryServiceRpcService, resourceId.unwrap());
 
         blobCacheService =
                 BlobUtils.createBlobCacheService(
                         configuration,
-                        Reference.borrowed(workingDirectory.getBlobStorageDirectory()),
+                        Reference.borrowed(workingDirectory.unwrap().getBlobStorageDirectory()),
                         highAvailabilityServices.createBlobStore(),
                         null);
 
@@ -204,7 +206,7 @@ public class TaskManagerRunner implements FatalErrorHandler {
         taskExecutorService =
                 taskExecutorServiceFactory.createTaskExecutor(
                         this.configuration,
-                        this.resourceId,
+                        this.resourceId.unwrap(),
                         rpcService,
                         highAvailabilityServices,
                         heartbeatServices,
@@ -212,7 +214,7 @@ public class TaskManagerRunner implements FatalErrorHandler {
                         blobCacheService,
                         false,
                         externalResourceInfoProvider,
-                        workingDirectory,
+                        workingDirectory.unwrap(),
                         this);
 
         this.terminationFuture = new CompletableFuture<>();
@@ -271,16 +273,10 @@ public class TaskManagerRunner implements FatalErrorHandler {
                         FutureUtils.composeAfterwards(
                                 taskManagerTerminationFuture, this::shutDownServices);
 
-                final CompletableFuture<Void> workingDirCleanupFuture;
-
-                if (terminationResult == Result.SUCCESS) {
-                    workingDirCleanupFuture =
-                            FutureUtils.runAfterwards(
-                                    serviceTerminationFuture, this::deleteWorkingDir);
-                } else {
-                    // keep the working directory in case of a failure
-                    workingDirCleanupFuture = serviceTerminationFuture;
-                }
+                final CompletableFuture<Void> workingDirCleanupFuture =
+                        FutureUtils.runAfterwards(
+                                serviceTerminationFuture,
+                                () -> deleteWorkingDir(terminationResult));
 
                 final CompletableFuture<Void> rpcSystemClassLoaderCloseFuture =
                         FutureUtils.runAfterwards(workingDirCleanupFuture, rpcSystem::close);
@@ -299,9 +295,11 @@ public class TaskManagerRunner implements FatalErrorHandler {
         return terminationFuture;
     }
 
-    private void deleteWorkingDir() throws IOException {
+    private void deleteWorkingDir(Result terminationResult) throws IOException {
         if (workingDirectory != null) {
-            workingDirectory.delete();
+            if (!workingDirectory.isDeterministic() || terminationResult == Result.SUCCESS) {
+                workingDirectory.unwrap().delete();
+            }
         }
     }
 
@@ -664,21 +662,38 @@ public class TaskManagerRunner implements FatalErrorHandler {
     }
 
     @VisibleForTesting
-    static ResourceID getTaskManagerResourceID(Configuration config, String rpcAddress, int rpcPort)
-            throws Exception {
-        return new ResourceID(
-                config.getString(
-                        TaskManagerOptions.TASK_MANAGER_RESOURCE_ID,
-                        StringUtils.isNullOrWhitespaceOnly(rpcAddress)
-                                ? InetAddress.getLocalHost().getHostName()
-                                        + "-"
-                                        + new AbstractID().toString().substring(0, 6)
-                                : rpcAddress
-                                        + ":"
-                                        + rpcPort
-                                        + "-"
-                                        + new AbstractID().toString().substring(0, 6)),
-                config.getString(TaskManagerOptionsInternal.TASK_MANAGER_RESOURCE_ID_METADATA, ""));
+    static DeterminismEnvelope<ResourceID> getTaskManagerResourceID(
+            Configuration config, String rpcAddress, int rpcPort) {
+
+        final String metadata =
+                config.getString(TaskManagerOptionsInternal.TASK_MANAGER_RESOURCE_ID_METADATA, "");
+        return config.getOptional(TaskManagerOptions.TASK_MANAGER_RESOURCE_ID)
+                .map(
+                        value ->
+                                DeterminismEnvelope.deterministicValue(
+                                        new ResourceID(value, metadata)))
+                .orElseGet(
+                        FunctionUtils.uncheckedSupplier(
+                                () -> {
+                                    final String hostName =
+                                            InetAddress.getLocalHost().getHostName();
+                                    final String value =
+                                            StringUtils.isNullOrWhitespaceOnly(rpcAddress)
+                                                    ? hostName
+                                                            + "-"
+                                                            + new AbstractID()
+                                                                    .toString()
+                                                                    .substring(0, 6)
+                                                    : rpcAddress
+                                                            + ":"
+                                                            + rpcPort
+                                                            + "-"
+                                                            + new AbstractID()
+                                                                    .toString()
+                                                                    .substring(0, 6);
+                                    return DeterminismEnvelope.nondeterministicValue(
+                                            new ResourceID(value, metadata));
+                                }));
     }
 
     /** Factory for {@link TaskExecutor}. */
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunnerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunnerTest.java
index 4c6c04d4732..5980bc110cf 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunnerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunnerTest.java
@@ -109,7 +109,7 @@ public class TaskManagerRunnerTest extends TestLogger {
         final String metadata = "test";
         configuration.set(TaskManagerOptionsInternal.TASK_MANAGER_RESOURCE_ID_METADATA, metadata);
         final ResourceID taskManagerResourceID =
-                TaskManagerRunner.getTaskManagerResourceID(configuration, "", -1);
+                TaskManagerRunner.getTaskManagerResourceID(configuration, "", -1).unwrap();
 
         assertThat(taskManagerResourceID.getMetadata(), equalTo(metadata));
     }
@@ -120,7 +120,7 @@ public class TaskManagerRunnerTest extends TestLogger {
         final String resourceID = "test";
         configuration.set(TaskManagerOptions.TASK_MANAGER_RESOURCE_ID, resourceID);
         final ResourceID taskManagerResourceID =
-                TaskManagerRunner.getTaskManagerResourceID(configuration, "", -1);
+                TaskManagerRunner.getTaskManagerResourceID(configuration, "", -1).unwrap();
 
         assertThat(taskManagerResourceID.getMetadata(), equalTo(""));
         assertThat(taskManagerResourceID.getStringWithMetadata(), equalTo("test"));
@@ -132,7 +132,7 @@ public class TaskManagerRunnerTest extends TestLogger {
         final String resourceID = "test";
         configuration.set(TaskManagerOptions.TASK_MANAGER_RESOURCE_ID, resourceID);
         final ResourceID taskManagerResourceID =
-                TaskManagerRunner.getTaskManagerResourceID(configuration, "", -1);
+                TaskManagerRunner.getTaskManagerResourceID(configuration, "", -1).unwrap();
 
         assertThat(taskManagerResourceID.getResourceIdString(), equalTo(resourceID));
     }
@@ -143,7 +143,8 @@ public class TaskManagerRunnerTest extends TestLogger {
         final String rpcAddress = "flink";
         final int rpcPort = 9090;
         final ResourceID taskManagerResourceID =
-                TaskManagerRunner.getTaskManagerResourceID(configuration, rpcAddress, rpcPort);
+                TaskManagerRunner.getTaskManagerResourceID(configuration, rpcAddress, rpcPort)
+                        .unwrap();
 
         assertThat(taskManagerResourceID, notNullValue());
         assertThat(
@@ -157,7 +158,8 @@ public class TaskManagerRunnerTest extends TestLogger {
         final String rpcAddress = "";
         final int rpcPort = -1;
         final ResourceID taskManagerResourceID =
-                TaskManagerRunner.getTaskManagerResourceID(configuration, rpcAddress, rpcPort);
+                TaskManagerRunner.getTaskManagerResourceID(configuration, rpcAddress, rpcPort)
+                        .unwrap();
 
         assertThat(taskManagerResourceID, notNullValue());
         assertThat(
diff --git a/flink-tests/src/test/java/org/apache/flink/test/recovery/ClusterEntrypointITCase.java b/flink-tests/src/test/java/org/apache/flink/test/recovery/ClusterEntrypointITCase.java
index ab5917cac3c..c1b6ccccaa6 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/recovery/ClusterEntrypointITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/recovery/ClusterEntrypointITCase.java
@@ -29,13 +29,20 @@ import org.apache.flink.runtime.testutils.DispatcherProcess;
 import org.apache.flink.test.util.TestProcessBuilder;
 import org.apache.flink.util.TestLogger;
 
+import org.apache.flink.shaded.guava30.com.google.common.collect.Iterables;
+
 import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.time.Duration;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /** Integration tests for the {@link org.apache.flink.runtime.entrypoint.ClusterEntrypoint}. */
@@ -44,7 +51,8 @@ public class ClusterEntrypointITCase extends TestLogger {
     @ClassRule public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();
 
     @Test
-    public void testWorkingDirectoryIsNotDeletedInCaseOfProcessFailure() throws Exception {
+    public void testDeterministicWorkingDirectoryIsNotDeletedInCaseOfProcessFailure()
+            throws Exception {
         final File workingDirBase = TEMPORARY_FOLDER.newFolder();
         final ResourceID resourceId = ResourceID.generate();
 
@@ -81,4 +89,49 @@ public class ClusterEntrypointITCase extends TestLogger {
             }
         }
     }
+
+    @Test
+    public void testNondeterministicWorkingDirectoryIsDeletedInCaseOfProcessFailure()
+            throws Exception {
+        final File workingDirBase = TEMPORARY_FOLDER.newFolder();
+
+        final Configuration configuration = new Configuration();
+        configuration.set(
+                ClusterOptions.PROCESS_WORKING_DIR_BASE, workingDirBase.getAbsolutePath());
+
+        final TestProcessBuilder.TestProcess jobManagerProcess =
+                new TestProcessBuilder(
+                                DispatcherProcess.DispatcherProcessEntryPoint.class.getName())
+                        .addConfigAsMainClassArgs(configuration)
+                        .start();
+
+        boolean success = false;
+        try {
+            CommonTestUtils.waitUntilCondition(
+                    () -> {
+                        try (Stream<Path> files = Files.list(workingDirBase.toPath())) {
+                            return files.findAny().isPresent();
+                        }
+                    },
+                    Deadline.fromNow(Duration.ofMinutes(1L)));
+
+            final File workingDirectory =
+                    Iterables.getOnlyElement(
+                                    Files.list(workingDirBase.toPath())
+                                            .collect(Collectors.toList()))
+                            .toFile();
+
+            jobManagerProcess.getProcess().destroy();
+
+            jobManagerProcess.getProcess().waitFor();
+
+            assertFalse(workingDirectory.exists());
+            success = true;
+        } finally {
+            if (!success) {
+                AbstractTaskManagerProcessFailureRecoveryTest.printProcessLog(
+                        "JobManager", jobManagerProcess);
+            }
+        }
+    }
 }
diff --git a/flink-tests/src/test/java/org/apache/flink/test/recovery/TaskManagerRunnerITCase.java b/flink-tests/src/test/java/org/apache/flink/test/recovery/TaskManagerRunnerITCase.java
index 6d86ffce7d4..a5d64cb16d7 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/recovery/TaskManagerRunnerITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/recovery/TaskManagerRunnerITCase.java
@@ -31,13 +31,20 @@ import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.test.util.TestProcessBuilder;
 import org.apache.flink.util.TestLogger;
 
+import org.apache.flink.shaded.guava30.com.google.common.collect.Iterables;
+
 import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.time.Duration;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /** Integration tests for the {@link TaskManagerRunner}. */
@@ -46,7 +53,7 @@ public class TaskManagerRunnerITCase extends TestLogger {
     @ClassRule public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();
 
     @Test
-    public void testWorkingDirIsNotDeletedInCaseOfProcessFailure() throws Exception {
+    public void testDeterministicWorkingDirIsNotDeletedInCaseOfProcessFailure() throws Exception {
         final File workingDirBase = TEMPORARY_FOLDER.newFolder();
         final ResourceID resourceId = ResourceID.generate();
 
@@ -87,4 +94,52 @@ public class TaskManagerRunnerITCase extends TestLogger {
             }
         }
     }
+
+    @Test
+    public void testNondeterministicWorkingDirIsDeletedInCaseOfProcessFailure() throws Exception {
+        final File workingDirBase = TEMPORARY_FOLDER.newFolder();
+
+        final Configuration configuration = new Configuration();
+        configuration.set(
+                ClusterOptions.PROCESS_WORKING_DIR_BASE, workingDirBase.getAbsolutePath());
+        configuration.set(JobManagerOptions.ADDRESS, "localhost");
+        configuration.set(AkkaOptions.LOOKUP_TIMEOUT_DURATION, Duration.ZERO);
+
+        final TestProcessBuilder.TestProcess taskManagerProcess =
+                new TestProcessBuilder(
+                                AbstractTaskManagerProcessFailureRecoveryTest
+                                        .TaskExecutorProcessEntryPoint.class
+                                        .getName())
+                        .addConfigAsMainClassArgs(configuration)
+                        .start();
+
+        boolean success = false;
+        try {
+            CommonTestUtils.waitUntilCondition(
+                    () -> {
+                        try (Stream<Path> files = Files.list(workingDirBase.toPath())) {
+                            return files.findAny().isPresent();
+                        }
+                    },
+                    Deadline.fromNow(Duration.ofMinutes(1L)));
+
+            final File workingDirectory =
+                    Iterables.getOnlyElement(
+                                    Files.list(workingDirBase.toPath())
+                                            .collect(Collectors.toList()))
+                            .toFile();
+
+            taskManagerProcess.getProcess().destroy();
+
+            taskManagerProcess.getProcess().waitFor();
+
+            assertFalse(workingDirectory.exists());
+            success = true;
+        } finally {
+            if (!success) {
+                AbstractTaskManagerProcessFailureRecoveryTest.printProcessLog(
+                        "TaskManager", taskManagerProcess);
+            }
+        }
+    }
 }
