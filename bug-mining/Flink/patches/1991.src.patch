diff --git a/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/sources/CsvTableSource.scala b/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/sources/CsvTableSource.scala
index 8a458efb8f9..cfc8adaf49b 100644
--- a/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/sources/CsvTableSource.scala
+++ b/flink-libraries/flink-table/src/main/scala/org/apache/flink/table/sources/CsvTableSource.scala
@@ -105,8 +105,14 @@ class CsvTableSource(
   /** Returns a copy of [[TableSource]] with ability to project fields */
   override def projectFields(fields: Array[Int]): CsvTableSource = {
 
-    val newFieldNames: Array[String] = fields.map(fieldNames(_))
-    val newFieldTypes: Array[TypeInformation[_]] = fields.map(fieldTypes(_))
+    val (newFields, newFieldNames, newFieldTypes) = if (fields.nonEmpty) {
+      (fields, fields.map(fieldNames(_)), fields.map(fieldTypes(_)))
+    } else {
+      // reporting number of records only, we must read some columns to get row count.
+      // (e.g. SQL: select count(1) from csv_table)
+      // We choose the first column here.
+      (Array(0), Array(fieldNames.head), Array[TypeInformation[_]](fieldTypes.head))
+    }
 
     val source = new CsvTableSource(path,
       newFieldNames,
@@ -117,7 +123,7 @@ class CsvTableSource(
       ignoreFirstLine,
       ignoreComments,
       lenient)
-    source.selectedFields = fields
+    source.selectedFields = newFields
     source
   }
 
diff --git a/flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableSourceTest.scala b/flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableSourceTest.scala
index 486b0780029..6321e091655 100644
--- a/flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableSourceTest.scala
+++ b/flink-libraries/flink-table/src/test/scala/org/apache/flink/table/api/TableSourceTest.scala
@@ -117,6 +117,27 @@ class TableSourceTest extends TableTestBase {
     util.verifyTable(result, expected)
   }
 
+  @Test
+  def testBatchProjectableSourceFullProjection(): Unit = {
+    val (tableSource, tableName) = csvTable
+    val util = batchTestUtil()
+    val tableEnv = util.tableEnv
+
+    tableEnv.registerTableSource(tableName, tableSource)
+
+    val result = tableEnv
+      .scan(tableName)
+      .select(1)
+
+    val expected = unaryNode(
+      "DataSetCalc",
+      batchSourceTableNode(tableName, Array("first")),
+      term("select", "1 AS _c0")
+    )
+
+    util.verifyTable(result, expected)
+  }
+
   @Test
   def testBatchFilterableWithoutPushDown(): Unit = {
     val (tableSource, tableName) = filterableTableSource
