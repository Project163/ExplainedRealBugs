diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/AbstractStateTableSnapshot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/AbstractStateTableSnapshot.java
index 595583486c0..c41263632f8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/AbstractStateTableSnapshot.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/AbstractStateTableSnapshot.java
@@ -103,10 +103,7 @@ abstract class AbstractStateTableSnapshot<K, N, S>
     }
 
     /**
-     * Implementation note: we currently chose the same format between {@link NestedMapsStateTable}
-     * and {@link CopyOnWriteStateTable}.
-     *
-     * <p>{@link NestedMapsStateTable} could naturally support a kind of prefix-compressed format
+     * {@link CopyOnWriteStateTable} could naturally support a kind of prefix-compressed format
      * (grouping by namespace, writing the namespace only once per group instead for each mapping).
      * We might implement support for different formats later (tailored towards different state
      * table implementations).
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackendBuilder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackendBuilder.java
index 11322e4d0f1..6db0f7e4ad5 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackendBuilder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/HeapKeyedStateBackendBuilder.java
@@ -101,12 +101,7 @@ public class HeapKeyedStateBackendBuilder<K> extends AbstractKeyedStateBackendBu
         InternalKeyContext<K> keyContext =
                 new InternalKeyContextImpl<>(keyGroupRange, numberOfKeyGroups);
 
-        final StateTableFactory<K> stateTableFactory;
-        if (asynchronousSnapshots) {
-            stateTableFactory = CopyOnWriteStateTable::new;
-        } else {
-            stateTableFactory = NestedMapsStateTable::new;
-        }
+        final StateTableFactory<K> stateTableFactory = CopyOnWriteStateTable::new;
 
         restoreState(registeredKVStates, registeredPQStates, keyContext, stateTableFactory);
         return new HeapKeyedStateBackend<>(
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedMapsStateTable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedMapsStateTable.java
deleted file mode 100644
index 4bf0aac31d4..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedMapsStateTable.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.state.heap;
-
-import org.apache.flink.annotation.Internal;
-import org.apache.flink.api.common.typeutils.TypeSerializer;
-import org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo;
-import org.apache.flink.runtime.state.StateSnapshotTransformer;
-
-import javax.annotation.Nonnull;
-
-/**
- * This implementation of {@link StateTable} uses {@link NestedStateMap}.
- *
- * @param <K> type of key.
- * @param <N> type of namespace.
- * @param <S> type of state.
- */
-@Internal
-public class NestedMapsStateTable<K, N, S> extends StateTable<K, N, S> {
-
-    /**
-     * Creates a new {@link NestedMapsStateTable} for the given key context and meta info.
-     *
-     * @param keyContext the key context.
-     * @param metaInfo the meta information for this state table.
-     * @param keySerializer the serializer of the key.
-     */
-    public NestedMapsStateTable(
-            InternalKeyContext<K> keyContext,
-            RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo,
-            TypeSerializer<K> keySerializer) {
-        super(keyContext, metaInfo, keySerializer);
-    }
-
-    @Override
-    protected NestedStateMap<K, N, S> createStateMap() {
-        return new NestedStateMap<>();
-    }
-
-    // Snapshotting
-    // ----------------------------------------------------------------------------------------------------
-
-    @Nonnull
-    @Override
-    public NestedMapsStateTableSnapshot<K, N, S> stateSnapshot() {
-        return new NestedMapsStateTableSnapshot<>(
-                this,
-                getKeySerializer(),
-                getNamespaceSerializer(),
-                getStateSerializer(),
-                getMetaInfo()
-                        .getStateSnapshotTransformFactory()
-                        .createForDeserializedState()
-                        .orElse(null));
-    }
-
-    /**
-     * This class encapsulates the snapshot logic.
-     *
-     * @param <K> type of key.
-     * @param <N> type of namespace.
-     * @param <S> type of state.
-     */
-    static class NestedMapsStateTableSnapshot<K, N, S> extends AbstractStateTableSnapshot<K, N, S> {
-
-        NestedMapsStateTableSnapshot(
-                NestedMapsStateTable<K, N, S> owningTable,
-                TypeSerializer<K> localKeySerializer,
-                TypeSerializer<N> localNamespaceSerializer,
-                TypeSerializer<S> localStateSerializer,
-                StateSnapshotTransformer<S> stateSnapshotTransformer) {
-            super(
-                    owningTable,
-                    localKeySerializer,
-                    localNamespaceSerializer,
-                    localStateSerializer,
-                    stateSnapshotTransformer);
-        }
-
-        @Override
-        protected StateMapSnapshot<K, N, S, ? extends StateMap<K, N, S>>
-                getStateMapSnapshotForKeyGroup(int keyGroup) {
-            return owningStateTable.getMapForKeyGroup(keyGroup).stateSnapshot();
-        }
-
-        @Override
-        public void release() {}
-    }
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedStateMap.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedStateMap.java
deleted file mode 100644
index 89fa3085069..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedStateMap.java
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.state.heap;
-
-import org.apache.flink.runtime.state.StateEntry;
-import org.apache.flink.runtime.state.StateTransformationFunction;
-import org.apache.flink.runtime.state.internal.InternalKvState;
-
-import javax.annotation.Nonnull;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.stream.Stream;
-
-/**
- * This implementation of {@link StateMap} uses nested {@link HashMap} objects.
- *
- * @param <K> type of key.
- * @param <N> type of namespace.
- * @param <S> type of value.
- */
-public class NestedStateMap<K, N, S> extends StateMap<K, N, S> {
-
-    /**
-     * Map for holding the actual state objects. The nested map provide an outer scope by namespace
-     * and an inner scope by key.
-     */
-    private final Map<N, Map<K, S>> namespaceMap;
-
-    /** Constructs a new {@code NestedStateMap}. */
-    public NestedStateMap() {
-        this.namespaceMap = new HashMap<>();
-    }
-
-    // Public API from StateMap
-    // ------------------------------------------------------------------------------
-
-    @Override
-    public int size() {
-        int count = 0;
-        for (Map<K, S> keyMap : namespaceMap.values()) {
-            if (null != keyMap) {
-                count += keyMap.size();
-            }
-        }
-
-        return count;
-    }
-
-    @Override
-    public S get(K key, N namespace) {
-        Map<K, S> keyedMap = namespaceMap.get(namespace);
-
-        if (keyedMap == null) {
-            return null;
-        }
-
-        return keyedMap.get(key);
-    }
-
-    @Override
-    public boolean containsKey(K key, N namespace) {
-        Map<K, S> keyedMap = namespaceMap.get(namespace);
-
-        return keyedMap != null && keyedMap.containsKey(key);
-    }
-
-    @Override
-    public void put(K key, N namespace, S state) {
-        putAndGetOld(key, namespace, state);
-    }
-
-    @Override
-    public S putAndGetOld(K key, N namespace, S state) {
-        Map<K, S> keyedMap = namespaceMap.computeIfAbsent(namespace, k -> new HashMap<>());
-
-        return keyedMap.put(key, state);
-    }
-
-    @Override
-    public void remove(K key, N namespace) {
-        removeAndGetOld(key, namespace);
-    }
-
-    @Override
-    public S removeAndGetOld(K key, N namespace) {
-        Map<K, S> keyedMap = namespaceMap.get(namespace);
-
-        if (keyedMap == null) {
-            return null;
-        }
-
-        S removed = keyedMap.remove(key);
-
-        if (keyedMap.isEmpty()) {
-            namespaceMap.remove(namespace);
-        }
-
-        return removed;
-    }
-
-    @Override
-    public <T> void transform(
-            K key, N namespace, T value, StateTransformationFunction<S, T> transformation)
-            throws Exception {
-        Map<K, S> keyedMap = namespaceMap.computeIfAbsent(namespace, k -> new HashMap<>());
-        keyedMap.put(key, transformation.apply(keyedMap.get(key), value));
-    }
-
-    @Override
-    public Iterator<StateEntry<K, N, S>> iterator() {
-        return new StateEntryIterator();
-    }
-
-    @Override
-    public Stream<K> getKeys(N namespace) {
-        return namespaceMap.getOrDefault(namespace, Collections.emptyMap()).keySet().stream();
-    }
-
-    @Override
-    public InternalKvState.StateIncrementalVisitor<K, N, S> getStateIncrementalVisitor(
-            int recommendedMaxNumberOfReturnedRecords) {
-        return new StateEntryVisitor();
-    }
-
-    @Override
-    public int sizeOfNamespace(Object namespace) {
-        Map<K, S> keyMap = namespaceMap.get(namespace);
-        return keyMap != null ? keyMap.size() : 0;
-    }
-
-    @Nonnull
-    @Override
-    public StateMapSnapshot<K, N, S, ? extends StateMap<K, N, S>> stateSnapshot() {
-        return new NestedStateMapSnapshot<>(this);
-    }
-
-    public Map<N, Map<K, S>> getNamespaceMap() {
-        return namespaceMap;
-    }
-
-    /** Iterator over state entries in a {@link NestedStateMap}. */
-    class StateEntryIterator implements Iterator<StateEntry<K, N, S>> {
-        private Iterator<Map.Entry<N, Map<K, S>>> namespaceIterator;
-        private Map.Entry<N, Map<K, S>> namespace;
-        private Iterator<Map.Entry<K, S>> keyValueIterator;
-
-        StateEntryIterator() {
-            namespaceIterator = namespaceMap.entrySet().iterator();
-            namespace = null;
-            keyValueIterator = Collections.emptyIterator();
-        }
-
-        @Override
-        public boolean hasNext() {
-            return keyValueIterator.hasNext() || namespaceIterator.hasNext();
-        }
-
-        @Override
-        public StateEntry<K, N, S> next() {
-            if (!hasNext()) {
-                throw new NoSuchElementException();
-            }
-
-            if (!keyValueIterator.hasNext()) {
-                namespace = namespaceIterator.next();
-                keyValueIterator = namespace.getValue().entrySet().iterator();
-            }
-
-            Map.Entry<K, S> entry = keyValueIterator.next();
-
-            return new StateEntry.SimpleStateEntry<>(
-                    entry.getKey(), namespace.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Incremental visitor over state entries in a {@link NestedStateMap}.
-     *
-     * <p>The iterator keeps a snapshotted copy of key/namespace sets, available at the beginning of
-     * iteration. While further iterating the copy, the iterator returns the actual state value from
-     * primary maps if exists at that moment.
-     *
-     * <p>Note: Usage of this iterator can have a heap memory consumption impact.
-     */
-    class StateEntryVisitor
-            implements InternalKvState.StateIncrementalVisitor<K, N, S>,
-                    Iterator<StateEntry<K, N, S>> {
-        private Iterator<Map.Entry<N, Map<K, S>>> namespaceIterator;
-        private Map.Entry<N, Map<K, S>> namespace;
-        private Iterator<Map.Entry<K, S>> keyValueIterator;
-        private StateEntry<K, N, S> nextEntry;
-        private StateEntry<K, N, S> lastReturnedEntry;
-
-        StateEntryVisitor() {
-            namespaceIterator = new HashSet<>(namespaceMap.entrySet()).iterator();
-            namespace = null;
-            keyValueIterator = null;
-            nextKeyIterator();
-        }
-
-        @Override
-        public boolean hasNext() {
-            nextKeyIterator();
-            return keyIteratorHasNext();
-        }
-
-        @Override
-        public Collection<StateEntry<K, N, S>> nextEntries() {
-            StateEntry<K, N, S> nextEntry = next();
-            return nextEntry == null
-                    ? Collections.emptyList()
-                    : Collections.singletonList(nextEntry);
-        }
-
-        @Override
-        public StateEntry<K, N, S> next() {
-            StateEntry<K, N, S> next = null;
-            if (hasNext()) {
-                next = nextEntry;
-            }
-            nextEntry = null;
-            lastReturnedEntry = next;
-            return next;
-        }
-
-        private void nextKeyIterator() {
-            while (!keyIteratorHasNext()) {
-                if (namespaceIteratorHasNext()) {
-                    namespace = namespaceIterator.next();
-                    keyValueIterator = new HashSet<>(namespace.getValue().entrySet()).iterator();
-                } else {
-                    break;
-                }
-            }
-        }
-
-        private boolean keyIteratorHasNext() {
-            while (nextEntry == null && keyValueIterator != null && keyValueIterator.hasNext()) {
-                Map.Entry<K, S> next = keyValueIterator.next();
-                Map<K, S> ns = namespaceMap.getOrDefault(namespace.getKey(), null);
-                S upToDateValue = ns == null ? null : ns.getOrDefault(next.getKey(), null);
-                if (upToDateValue != null) {
-                    nextEntry =
-                            new StateEntry.SimpleStateEntry<>(
-                                    next.getKey(), namespace.getKey(), upToDateValue);
-                }
-            }
-            return nextEntry != null;
-        }
-
-        private boolean namespaceIteratorHasNext() {
-            return namespaceIterator.hasNext();
-        }
-
-        @Override
-        public void remove() {
-            remove(lastReturnedEntry);
-        }
-
-        @Override
-        public void remove(StateEntry<K, N, S> stateEntry) {
-            namespaceMap.get(stateEntry.getNamespace()).remove(stateEntry.getKey());
-        }
-
-        @Override
-        public void update(StateEntry<K, N, S> stateEntry, S newValue) {
-            namespaceMap.get(stateEntry.getNamespace()).put(stateEntry.getKey(), newValue);
-        }
-    }
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedStateMapSnapshot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedStateMapSnapshot.java
deleted file mode 100644
index e58cf91e9c8..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/heap/NestedStateMapSnapshot.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.state.heap;
-
-import org.apache.flink.api.common.typeutils.TypeSerializer;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.state.StateEntry;
-import org.apache.flink.runtime.state.StateSnapshotTransformer;
-
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Spliterators;
-import java.util.stream.StreamSupport;
-
-/**
- * This class represents the snapshot of a {@link NestedStateMap}.
- *
- * @param <K> type of key
- * @param <N> type of namespace
- * @param <S> type of state
- */
-public class NestedStateMapSnapshot<K, N, S>
-        extends StateMapSnapshot<K, N, S, NestedStateMap<K, N, S>> {
-
-    /**
-     * Creates a new {@link NestedStateMapSnapshot}.
-     *
-     * @param owningStateMap the {@link NestedStateMap} for which this object represents a snapshot.
-     */
-    public NestedStateMapSnapshot(NestedStateMap<K, N, S> owningStateMap) {
-        super(owningStateMap);
-    }
-
-    @Override
-    public Iterator<StateEntry<K, N, S>> getIterator(
-            @Nonnull TypeSerializer<K> keySerializer,
-            @Nonnull TypeSerializer<N> namespaceSerializer,
-            @Nonnull TypeSerializer<S> stateSerializer,
-            @Nullable StateSnapshotTransformer<S> stateSnapshotTransformer) {
-        if (stateSnapshotTransformer == null) {
-            return owningStateMap.iterator();
-        } else {
-            return StreamSupport.stream(
-                            Spliterators.spliteratorUnknownSize(owningStateMap.iterator(), 0),
-                            false)
-                    .map(entry -> entry.filterOrTransform(stateSnapshotTransformer))
-                    .filter(Objects::nonNull)
-                    .iterator();
-        }
-    }
-
-    @Override
-    public void writeState(
-            TypeSerializer<K> keySerializer,
-            TypeSerializer<N> namespaceSerializer,
-            TypeSerializer<S> stateSerializer,
-            @Nonnull DataOutputView dov,
-            @Nullable StateSnapshotTransformer<S> stateSnapshotTransformer)
-            throws IOException {
-        Map<N, Map<K, S>> mappings =
-                filterMappingsIfNeeded(owningStateMap.getNamespaceMap(), stateSnapshotTransformer);
-        int numberOfEntries = countMappingsInKeyGroup(mappings);
-
-        dov.writeInt(numberOfEntries);
-        for (Map.Entry<N, Map<K, S>> namespaceEntry : mappings.entrySet()) {
-            N namespace = namespaceEntry.getKey();
-            for (Map.Entry<K, S> entry : namespaceEntry.getValue().entrySet()) {
-                namespaceSerializer.serialize(namespace, dov);
-                keySerializer.serialize(entry.getKey(), dov);
-                stateSerializer.serialize(entry.getValue(), dov);
-            }
-        }
-    }
-
-    private Map<N, Map<K, S>> filterMappingsIfNeeded(
-            final Map<N, Map<K, S>> keyGroupMap,
-            StateSnapshotTransformer<S> stateSnapshotTransformer) {
-        if (stateSnapshotTransformer == null) {
-            return keyGroupMap;
-        }
-
-        Map<N, Map<K, S>> filtered = new HashMap<>();
-        for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {
-            N namespace = namespaceEntry.getKey();
-            Map<K, S> filteredNamespaceMap =
-                    filtered.computeIfAbsent(namespace, n -> new HashMap<>());
-            for (Map.Entry<K, S> keyEntry : namespaceEntry.getValue().entrySet()) {
-                K key = keyEntry.getKey();
-                S transformedvalue =
-                        stateSnapshotTransformer.filterOrTransform(keyEntry.getValue());
-                if (transformedvalue != null) {
-                    filteredNamespaceMap.put(key, transformedvalue);
-                }
-            }
-            if (filteredNamespaceMap.isEmpty()) {
-                filtered.remove(namespace);
-            }
-        }
-
-        return filtered;
-    }
-
-    private int countMappingsInKeyGroup(final Map<N, Map<K, S>> keyGroupMap) {
-        int count = 0;
-        for (Map<K, S> namespaceMap : keyGroupMap.values()) {
-            count += namespaceMap.size();
-        }
-
-        return count;
-    }
-}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java
index 3bade9554e7..21b2694e1db 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java
@@ -65,8 +65,6 @@ import org.apache.flink.runtime.operators.testutils.MockEnvironment;
 import org.apache.flink.runtime.query.KvStateRegistry;
 import org.apache.flink.runtime.query.KvStateRegistryListener;
 import org.apache.flink.runtime.state.heap.AbstractHeapState;
-import org.apache.flink.runtime.state.heap.NestedMapsStateTable;
-import org.apache.flink.runtime.state.heap.NestedStateMap;
 import org.apache.flink.runtime.state.heap.StateTable;
 import org.apache.flink.runtime.state.internal.InternalAggregatingState;
 import org.apache.flink.runtime.state.internal.InternalKvState;
@@ -114,7 +112,6 @@ import java.util.Timer;
 import java.util.TimerTask;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
@@ -4375,9 +4372,8 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 backend.setCurrentKey(1);
                 state.update(121818273);
 
-                StateTable<?, ?, ?> stateTable =
-                        ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
-                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+                assertNotNull(
+                        "State not set", ((AbstractHeapState<?, ?, ?>) kvState).getStateTable());
             }
 
             {
@@ -4398,9 +4394,8 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 backend.setCurrentKey(1);
                 state.add(121818273);
 
-                StateTable<?, ?, ?> stateTable =
-                        ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
-                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+                assertNotNull(
+                        "State not set", ((AbstractHeapState<?, ?, ?>) kvState).getStateTable());
             }
 
             {
@@ -4430,9 +4425,8 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 backend.setCurrentKey(1);
                 state.add(121818273);
 
-                StateTable<?, ?, ?> stateTable =
-                        ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
-                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+                assertNotNull(
+                        "State not set", ((AbstractHeapState<?, ?, ?>) kvState).getStateTable());
             }
 
             {
@@ -4456,7 +4450,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 int keyGroupIndex = KeyGroupRangeAssignment.assignToKeyGroup(1, numberOfKeyGroups);
                 StateTable stateTable = ((AbstractHeapState) kvState).getStateTable();
                 assertNotNull("State not set", stateTable.get(keyGroupIndex));
-                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
             }
         } finally {
             IOUtils.closeQuietly(backend);
@@ -4464,22 +4457,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         }
     }
 
-    private void checkConcurrentStateTable(StateTable<?, ?, ?> stateTable, int numberOfKeyGroups) {
-        assertNotNull("State not set", stateTable);
-        if (stateTable instanceof NestedMapsStateTable) {
-            int keyGroupIndex = KeyGroupRangeAssignment.assignToKeyGroup(1, numberOfKeyGroups);
-            NestedMapsStateTable<?, ?, ?> nestedMapsStateTable =
-                    (NestedMapsStateTable<?, ?, ?>) stateTable;
-            NestedStateMap<?, ?, ?>[] nestedStateMaps =
-                    (NestedStateMap<?, ?, ?>[]) nestedMapsStateTable.getState();
-            assertTrue(
-                    nestedStateMaps[keyGroupIndex].getNamespaceMap() instanceof ConcurrentHashMap);
-            assertTrue(
-                    nestedStateMaps[keyGroupIndex].getNamespaceMap().get(VoidNamespace.INSTANCE)
-                            instanceof ConcurrentHashMap);
-        }
-    }
-
     /** Tests registration with the KvStateRegistry. */
     @Test
     public void testQueryableStateRegistration() throws Exception {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/heap/NestedMapsStateTableTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/heap/NestedMapsStateTableTest.java
deleted file mode 100644
index d8ff6c2bf11..00000000000
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/heap/NestedMapsStateTableTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.state.heap;
-
-import org.apache.flink.api.common.typeutils.base.IntSerializer;
-import org.apache.flink.api.common.typeutils.base.ListSerializer;
-import org.apache.flink.api.common.typeutils.base.LongSerializer;
-import org.apache.flink.runtime.state.StateEntry;
-import org.apache.flink.runtime.state.StateSnapshotTransformer;
-
-import org.junit.Test;
-
-import javax.annotation.Nullable;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import static org.apache.flink.runtime.state.testutils.StateEntryMatcher.entry;
-import static org.hamcrest.Matchers.containsInAnyOrder;
-import static org.junit.Assert.assertThat;
-
-/** Tests for {@link NestedMapsStateTable}. */
-public class NestedMapsStateTableTest {
-    @Test
-    public void testIteratingOverSnapshot() {
-        ListSerializer<Integer> stateSerializer = new ListSerializer<>(IntSerializer.INSTANCE);
-        final NestedStateMap<Integer, Integer, List<Integer>> stateMap = new NestedStateMap<>();
-
-        List<Integer> originalState1 = new ArrayList<>(1);
-        List<Integer> originalState2 = new ArrayList<>(1);
-        List<Integer> originalState3 = new ArrayList<>(1);
-        List<Integer> originalState4 = new ArrayList<>(1);
-        List<Integer> originalState5 = new ArrayList<>(1);
-
-        originalState1.add(1);
-        originalState2.add(2);
-        originalState3.add(3);
-        originalState4.add(4);
-        originalState5.add(5);
-
-        stateMap.put(1, 1, originalState1);
-        stateMap.put(2, 1, originalState2);
-        stateMap.put(3, 1, originalState3);
-        stateMap.put(4, 1, originalState4);
-        stateMap.put(5, 1, originalState5);
-
-        StateMapSnapshot<
-                        Integer,
-                        Integer,
-                        List<Integer>,
-                        ? extends StateMap<Integer, Integer, List<Integer>>>
-                snapshot = stateMap.stateSnapshot();
-
-        Iterator<StateEntry<Integer, Integer, List<Integer>>> iterator =
-                snapshot.getIterator(
-                        IntSerializer.INSTANCE, IntSerializer.INSTANCE, stateSerializer, null);
-        assertThat(
-                () -> iterator,
-                containsInAnyOrder(
-                        entry(1, 1, originalState1),
-                        entry(2, 1, originalState2),
-                        entry(3, 1, originalState3),
-                        entry(4, 1, originalState4),
-                        entry(5, 1, originalState5)));
-    }
-
-    @Test
-    public void testIteratingOverSnapshotWithTransform() {
-        final NestedStateMap<Integer, Integer, Long> stateMap = new NestedStateMap<>();
-
-        stateMap.put(1, 1, 10L);
-        stateMap.put(2, 1, 11L);
-        stateMap.put(3, 1, 12L);
-        stateMap.put(4, 1, 13L);
-        stateMap.put(5, 1, 14L);
-
-        StateMapSnapshot<Integer, Integer, Long, ? extends StateMap<Integer, Integer, Long>>
-                snapshot = stateMap.stateSnapshot();
-
-        Iterator<StateEntry<Integer, Integer, Long>> iterator =
-                snapshot.getIterator(
-                        IntSerializer.INSTANCE,
-                        IntSerializer.INSTANCE,
-                        LongSerializer.INSTANCE,
-                        new StateSnapshotTransformer<Long>() {
-                            @Nullable
-                            @Override
-                            public Long filterOrTransform(@Nullable Long value) {
-                                if (value == 12L) {
-                                    return null;
-                                } else {
-                                    return value + 2L;
-                                }
-                            }
-                        });
-        assertThat(
-                () -> iterator,
-                containsInAnyOrder(
-                        entry(1, 1, 12L), entry(2, 1, 13L), entry(4, 1, 15L), entry(5, 1, 16L)));
-    }
-}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/heap/StateTableSnapshotCompatibilityTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/heap/StateTableSnapshotCompatibilityTest.java
deleted file mode 100644
index b592b242ba7..00000000000
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/heap/StateTableSnapshotCompatibilityTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.state.heap;
-
-import org.apache.flink.api.common.state.StateDescriptor;
-import org.apache.flink.api.common.typeutils.TypeSerializer;
-import org.apache.flink.api.common.typeutils.base.IntSerializer;
-import org.apache.flink.core.memory.ByteArrayInputStreamWithPos;
-import org.apache.flink.core.memory.ByteArrayOutputStreamWithPos;
-import org.apache.flink.core.memory.DataInputViewStreamWrapper;
-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
-import org.apache.flink.runtime.state.ArrayListSerializer;
-import org.apache.flink.runtime.state.KeyGroupRange;
-import org.apache.flink.runtime.state.KeyedBackendSerializationProxy;
-import org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo;
-import org.apache.flink.runtime.state.StateEntry;
-import org.apache.flink.runtime.state.StateSnapshot;
-import org.apache.flink.runtime.state.StateSnapshotKeyGroupReader;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Random;
-
-/** Test for snapshot compatiblily between differen state tables. */
-public class StateTableSnapshotCompatibilityTest {
-    private final TypeSerializer<Integer> keySerializer = IntSerializer.INSTANCE;
-
-    /**
-     * This test ensures that different implementations of {@link StateTable} are compatible in
-     * their serialization format.
-     */
-    @Test
-    public void checkCompatibleSerializationFormats() throws IOException {
-        final Random r = new Random(42);
-        RegisteredKeyValueStateBackendMetaInfo<Integer, ArrayList<Integer>> metaInfo =
-                new RegisteredKeyValueStateBackendMetaInfo<>(
-                        StateDescriptor.Type.UNKNOWN,
-                        "test",
-                        IntSerializer.INSTANCE,
-                        new ArrayListSerializer<>(IntSerializer.INSTANCE));
-
-        final MockInternalKeyContext<Integer> keyContext = new MockInternalKeyContext<>();
-
-        CopyOnWriteStateTable<Integer, Integer, ArrayList<Integer>> cowStateTable =
-                new CopyOnWriteStateTable<>(keyContext, metaInfo, keySerializer);
-
-        for (int i = 0; i < 100; ++i) {
-            ArrayList<Integer> list = new ArrayList<>(5);
-            int end = r.nextInt(5);
-            for (int j = 0; j < end; ++j) {
-                list.add(r.nextInt(100));
-            }
-
-            keyContext.setCurrentKey(r.nextInt(10));
-            cowStateTable.put(r.nextInt(2), list);
-        }
-
-        StateSnapshot snapshot = cowStateTable.stateSnapshot();
-
-        final NestedMapsStateTable<Integer, Integer, ArrayList<Integer>> nestedMapsStateTable =
-                new NestedMapsStateTable<>(keyContext, metaInfo, keySerializer);
-
-        restoreStateTableFromSnapshot(
-                nestedMapsStateTable, snapshot, keyContext.getKeyGroupRange());
-        snapshot.release();
-
-        Assert.assertEquals(cowStateTable.size(), nestedMapsStateTable.size());
-        for (StateEntry<Integer, Integer, ArrayList<Integer>> entry : cowStateTable) {
-            Assert.assertEquals(
-                    entry.getState(),
-                    nestedMapsStateTable.get(entry.getKey(), entry.getNamespace()));
-        }
-
-        snapshot = nestedMapsStateTable.stateSnapshot();
-        cowStateTable = new CopyOnWriteStateTable<>(keyContext, metaInfo, keySerializer);
-
-        restoreStateTableFromSnapshot(cowStateTable, snapshot, keyContext.getKeyGroupRange());
-        snapshot.release();
-
-        Assert.assertEquals(nestedMapsStateTable.size(), cowStateTable.size());
-        for (StateEntry<Integer, Integer, ArrayList<Integer>> entry : cowStateTable) {
-            Assert.assertEquals(
-                    nestedMapsStateTable.get(entry.getKey(), entry.getNamespace()),
-                    entry.getState());
-        }
-    }
-
-    private void restoreStateTableFromSnapshot(
-            StateTable<Integer, Integer, ArrayList<Integer>> stateTable,
-            StateSnapshot snapshot,
-            KeyGroupRange keyGroupRange)
-            throws IOException {
-
-        final ByteArrayOutputStreamWithPos out = new ByteArrayOutputStreamWithPos(1024 * 1024);
-        final DataOutputViewStreamWrapper dov = new DataOutputViewStreamWrapper(out);
-        final StateSnapshot.StateKeyGroupWriter keyGroupPartitionedSnapshot =
-                snapshot.getKeyGroupWriter();
-        for (Integer keyGroup : keyGroupRange) {
-            keyGroupPartitionedSnapshot.writeStateInKeyGroup(dov, keyGroup);
-        }
-
-        final ByteArrayInputStreamWithPos in = new ByteArrayInputStreamWithPos(out.getBuf());
-        final DataInputViewStreamWrapper div = new DataInputViewStreamWrapper(in);
-
-        final StateSnapshotKeyGroupReader keyGroupReader =
-                StateTableByKeyGroupReaders.readerForVersion(
-                        stateTable, KeyedBackendSerializationProxy.VERSION);
-
-        for (Integer keyGroup : keyGroupRange) {
-            keyGroupReader.readMappingsInKeyGroup(div, keyGroup);
-        }
-    }
-}
