diff --git a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
index 2481138ba74..c85b7972c90 100644
--- a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
+++ b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
@@ -1261,6 +1261,43 @@ public class FutureUtils {
         handleUncaughtException(completableFuture, FatalExitExceptionHandler.INSTANCE);
     }
 
+    /**
+     * Checks that the given {@link CompletableFuture} is not completed exceptionally with the
+     * specified class. If the future is completed exceptionally with the specific class, then try
+     * to recover using a given exception handler. If the exception does not match the specified
+     * class, just pass it through to later stages.
+     *
+     * @param completableFuture to assert for a given exception
+     * @param exceptionClass exception class to assert for
+     * @param exceptionHandler to call if the future is completed exceptionally with the specific
+     *     exception
+     * @return completable future, that can recover from a specified exception
+     */
+    public static <T, E extends Throwable> CompletableFuture<T> handleException(
+            CompletableFuture<T> completableFuture,
+            Class<E> exceptionClass,
+            Function<E, T> exceptionHandler) {
+        final CompletableFuture<T> handledFuture = new CompletableFuture<>();
+        checkNotNull(completableFuture)
+                .whenComplete(
+                        (result, throwable) -> {
+                            if (throwable == null) {
+                                handledFuture.complete(result);
+                            } else if (exceptionClass.isAssignableFrom(throwable.getClass())) {
+                                @SuppressWarnings("unchecked")
+                                final E exception = (E) throwable;
+                                try {
+                                    handledFuture.complete(exceptionHandler.apply(exception));
+                                } catch (Throwable t) {
+                                    handledFuture.completeExceptionally(t);
+                                }
+                            } else {
+                                handledFuture.completeExceptionally(throwable);
+                            }
+                        });
+        return handledFuture;
+    }
+
     /**
      * Checks that the given {@link CompletableFuture} is not completed exceptionally. If the future
      * is completed exceptionally, then it will call the given uncaught exception handler.
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java
index 8ca777e4187..727e9f2d15a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java
@@ -68,6 +68,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -824,6 +825,63 @@ public class FutureUtilsTest extends TestLogger {
         Assert.assertTrue(continuationFuture.isDone());
     }
 
+    @Test
+    public void testHandleExceptionWithCompletedFuture() {
+        final CompletableFuture<String> future = CompletableFuture.completedFuture("foobar");
+        final CompletableFuture<String> handled =
+                FutureUtils.handleException(future, Exception.class, exception -> "handled");
+        assertEquals("foobar", handled.join());
+    }
+
+    @Test
+    public void testHandleExceptionWithNormalCompletion() {
+        final CompletableFuture<String> future = new CompletableFuture<>();
+        final CompletableFuture<String> handled =
+                FutureUtils.handleException(future, Exception.class, exception -> "handled");
+        future.complete("foobar");
+        assertEquals("foobar", handled.join());
+    }
+
+    @Test
+    public void testHandleExceptionWithMatchingExceptionallyCompletedFuture() {
+        final CompletableFuture<String> future = new CompletableFuture<>();
+        final CompletableFuture<String> handled =
+                FutureUtils.handleException(
+                        future, UnsupportedOperationException.class, exception -> "handled");
+        future.completeExceptionally(new UnsupportedOperationException("foobar"));
+        assertEquals("handled", handled.join());
+    }
+
+    @Test
+    public void testHandleExceptionWithNotMatchingExceptionallyCompletedFuture() {
+        final CompletableFuture<String> future = new CompletableFuture<>();
+        final CompletableFuture<String> handled =
+                FutureUtils.handleException(
+                        future, UnsupportedOperationException.class, exception -> "handled");
+        future.completeExceptionally(new IllegalArgumentException("foobar"));
+        final CompletionException completionException =
+                assertThrows(CompletionException.class, handled::join);
+        assertTrue(completionException.getCause() instanceof IllegalArgumentException);
+        assertEquals("foobar", completionException.getCause().getMessage());
+    }
+
+    @Test
+    public void testHandleExceptionWithThrowingExceptionHandler() {
+        final CompletableFuture<String> future = new CompletableFuture<>();
+        final CompletableFuture<String> handled =
+                FutureUtils.handleException(
+                        future,
+                        UnsupportedOperationException.class,
+                        exception -> {
+                            throw new IllegalStateException("something went terribly wrong");
+                        });
+        future.completeExceptionally(new UnsupportedOperationException("foobar"));
+        final CompletionException completionException =
+                assertThrows(CompletionException.class, handled::join);
+        assertTrue(completionException.getCause() instanceof IllegalStateException);
+        assertEquals("something went terribly wrong", completionException.getCause().getMessage());
+    }
+
     @Test
     public void testHandleUncaughtExceptionWithCompletedFuture() {
         final CompletableFuture<String> future = CompletableFuture.completedFuture("foobar");
