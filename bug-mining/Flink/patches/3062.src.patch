diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/expressions/RexNodeConverter.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/expressions/RexNodeConverter.java
index 866f0f5e4d8..c3113289924 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/expressions/RexNodeConverter.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/expressions/RexNodeConverter.java
@@ -123,7 +123,7 @@ public class RexNodeConverter implements ExpressionVisitor<RexNode> {
 		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.CAST, exprs -> convertCast(exprs));
 		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.REINTERPRET_CAST, exprs -> convertReinterpretCast(exprs));
 		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.IN, exprs -> convertIn(exprs));
-		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.GET, exprs -> ConvertGet(exprs));
+		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.GET, exprs -> convertGet(exprs));
 		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.TRIM, exprs -> convertTrim(exprs));
 		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.AS, exprs -> convertAs(exprs));
 		conversionsOfBuiltInFunc.put(BuiltInFunctionDefinitions.OVER, exprs -> convertOver(exprs));
@@ -579,7 +579,7 @@ public class RexNodeConverter implements ExpressionVisitor<RexNode> {
 				str);
 	}
 
-	private RexNode ConvertGet(List<Expression> children) {
+	private RexNode convertGet(List<Expression> children) {
 		RexNode child = children.get(0).accept(this);
 		ValueLiteralExpression keyLiteral = (ValueLiteralExpression) children.get(1);
 		Optional<Integer> indexOptional = ExpressionUtils.extractValue(keyLiteral, String.class).map(
@@ -952,9 +952,8 @@ public class RexNodeConverter implements ExpressionVisitor<RexNode> {
 				throw new IllegalArgumentException("Unexpected expression: " + bound);
 			}
 		} else if (bound instanceof ValueLiteralExpression) {
-			int DECIMAL_PRECISION_NEEDED_FOR_LONG = 19;
 			RelDataType returnType = typeFactory
-					.createFieldTypeFromLogicalType(new DecimalType(true, DECIMAL_PRECISION_NEEDED_FOR_LONG, 0));
+					.createFieldTypeFromLogicalType(new DecimalType(true, 19, 0));
 			SqlOperator sqlOperator = new SqlPostfixOperator(
 					sqlKind.name(),
 					sqlKind,
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWithRetractAggFunction.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWithRetractAggFunction.java
index f22c4986618..8fa952da023 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWithRetractAggFunction.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWithRetractAggFunction.java
@@ -21,6 +21,7 @@ package org.apache.flink.table.functions.aggfunctions;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.table.api.dataview.ListView;
 import org.apache.flink.table.dataformat.BinaryString;
+import org.apache.flink.table.dataformat.BinaryStringUtil;
 import org.apache.flink.table.functions.AggregateFunction;
 import org.apache.flink.table.typeutils.BinaryStringTypeInfo;
 import org.apache.flink.util.FlinkRuntimeException;
@@ -123,7 +124,7 @@ public final class ConcatWithRetractAggFunction
 				// return null when the list is empty
 				return null;
 			} else {
-				return BinaryString.concatWs(lineDelimiter, accList);
+				return BinaryStringUtil.concatWs(lineDelimiter, accList);
 			}
 		} catch (Exception e) {
 			throw new FlinkRuntimeException(e);
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWsWithRetractAggFunction.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWsWithRetractAggFunction.java
index 99c15ee505a..e0a7ee7e782 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWsWithRetractAggFunction.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/functions/aggfunctions/ConcatWsWithRetractAggFunction.java
@@ -21,6 +21,7 @@ package org.apache.flink.table.functions.aggfunctions;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.table.api.dataview.ListView;
 import org.apache.flink.table.dataformat.BinaryString;
+import org.apache.flink.table.dataformat.BinaryStringUtil;
 import org.apache.flink.table.functions.AggregateFunction;
 import org.apache.flink.table.typeutils.BinaryStringTypeInfo;
 import org.apache.flink.util.FlinkRuntimeException;
@@ -133,7 +134,7 @@ public final class ConcatWsWithRetractAggFunction
 				// return null when the list is empty
 				return null;
 			} else {
-				return BinaryString.concatWs(acc.delimiter, accList);
+				return BinaryStringUtil.concatWs(acc.delimiter, accList);
 			}
 		} catch (Exception e) {
 			throw new FlinkRuntimeException(e);
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/CodeGenUtils.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/CodeGenUtils.scala
index 52d521f4ce9..1670a95fa89 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/CodeGenUtils.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/CodeGenUtils.scala
@@ -22,7 +22,7 @@ import org.apache.flink.api.common.ExecutionConfig
 import org.apache.flink.core.memory.MemorySegment
 import org.apache.flink.table.dataformat.DataFormatConverters.IdentityConverter
 import org.apache.flink.table.dataformat.util.BinaryRowUtil.BYTE_ARRAY_BASE_OFFSET
-import org.apache.flink.table.dataformat.{Decimal, _}
+import org.apache.flink.table.dataformat.{Decimal, BinaryStringUtil, _}
 import org.apache.flink.table.dataview.StateDataViewStore
 import org.apache.flink.table.functions.UserDefinedFunction
 import org.apache.flink.table.generated.{AggsHandleFunction, HashFunction, NamespaceAggsHandleFunction}
@@ -88,6 +88,8 @@ object CodeGenUtils {
 
   val STATE_DATA_VIEW_STORE: String = className[StateDataViewStore]
 
+  val STRING_UTIL: String = className[BinaryStringUtil]
+
   // ----------------------------------------------------------------------------------------
 
   private val nameCounter = new AtomicInteger
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/ExpressionReducer.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/ExpressionReducer.scala
index 95786f31eca..712f63c8c15 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/ExpressionReducer.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/ExpressionReducer.scala
@@ -24,7 +24,8 @@ import org.apache.flink.metrics.MetricGroup
 import org.apache.flink.table.api.{TableConfig, TableException}
 import org.apache.flink.table.calcite.FlinkTypeFactory
 import org.apache.flink.table.codegen.FunctionCodeGenerator.generateFunction
-import org.apache.flink.table.dataformat.{BinaryString, Decimal, GenericRow}
+import org.apache.flink.table.dataformat.BinaryStringUtil.safeToString
+import org.apache.flink.table.dataformat.{BinaryString, BinaryStringUtil, Decimal, GenericRow}
 import org.apache.flink.table.functions.{FunctionContext, UserDefinedFunction}
 import org.apache.flink.table.types.logical.RowType
 
@@ -123,8 +124,7 @@ class ExpressionReducer(
           reducedValues.add(unreduced)
         case SqlTypeName.VARCHAR | SqlTypeName.CHAR =>
           val escapeVarchar = StringEscapeUtils
-            .escapeJava(
-              BinaryString.safeToString(reduced.getField(reducedIdx).asInstanceOf[BinaryString]))
+            .escapeJava(safeToString(reduced.getField(reducedIdx).asInstanceOf[BinaryString]))
           reducedValues.add(maySkipNullLiteralReduce(rexBuilder, escapeVarchar, unreduced))
           reducedIdx += 1
         case SqlTypeName.VARBINARY | SqlTypeName.BINARY =>
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/ScalarOperatorGens.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/ScalarOperatorGens.scala
index 52532fda045..95b785d17d3 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/ScalarOperatorGens.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/ScalarOperatorGens.scala
@@ -838,7 +838,7 @@ object ScalarOperatorGens {
         targetType,
         operand,
         resultNullable = true) {
-        operandTerm => s"$operandTerm.toBooleanSQL()"
+        operandTerm => s"$STRING_UTIL.toBooleanSQL($operandTerm)"
       }
 
     // String -> NUMERIC TYPE (not Character)
@@ -846,8 +846,8 @@ object ScalarOperatorGens {
       if TypeCheckUtils.isNumeric(targetType) =>
       targetType match {
         case dt: DecimalType =>
-          generateUnaryOperatorIfNotNull(ctx, targetType, operand) {
-            operandTerm => s"$operandTerm.toDecimal(${dt.getPrecision}, ${dt.getScale})"
+          generateUnaryOperatorIfNotNull(ctx, targetType, operand) { operandTerm =>
+            s"$STRING_UTIL.toDecimal($operandTerm, ${dt.getPrecision}, ${dt.getScale})"
           }
         case _ =>
           val methodName = targetType.getTypeRoot match {
@@ -865,7 +865,7 @@ object ScalarOperatorGens {
             targetType,
             operand,
             resultNullable = true) {
-            operandTerm => s"($operandTerm.trim().$methodName())"
+            operandTerm => s"($STRING_UTIL.$methodName($operandTerm.trim()))"
           }
       }
 
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/StringCallGen.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/StringCallGen.scala
index 0d73ff1143e..02a1c40ba88 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/StringCallGen.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/codegen/calls/StringCallGen.scala
@@ -289,7 +289,7 @@ object StringCallGen {
   private def safeToStringTerms(terms: Seq[String], operands: Seq[GeneratedExpression]) = {
     terms.zipWithIndex.map { case (term, index) =>
       if (isCharacterString(operands(index).resultType)) {
-        s"$BINARY_STRING.safeToString($term)"
+        s"$STRING_UTIL.safeToString($term)"
       } else {
         term
       }
@@ -300,7 +300,7 @@ object StringCallGen {
       ctx: CodeGeneratorContext,
       operands: Seq[GeneratedExpression]): GeneratedExpression = {
     generateCallIfArgsNullable(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms => s"$BINARY_STRING.concat(${terms.mkString(", ")})"
+      terms => s"$STRING_UTIL.concat(${terms.mkString(", ")})"
     }
   }
 
@@ -308,7 +308,7 @@ object StringCallGen {
       ctx: CodeGeneratorContext,
       operands: Seq[GeneratedExpression]): GeneratedExpression = {
     generateCallIfArgsNullable(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms => s"$BINARY_STRING.concatWs(${terms.mkString(", ")})"
+      terms => s"$STRING_UTIL.concatWs(${terms.mkString(", ")})"
     }
   }
 
@@ -340,7 +340,7 @@ object StringCallGen {
     ctx: CodeGeneratorContext,
     operands: Seq[GeneratedExpression]): GeneratedExpression = {
     generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms => s"${terms.head}.substringSQL(${terms.drop(1).mkString(", ")})"
+      terms => s"$STRING_UTIL.substringSQL(${terms.head}, ${terms.drop(1).mkString(", ")})"
     }
   }
 
@@ -350,7 +350,9 @@ object StringCallGen {
     len: GeneratedExpression): GeneratedExpression = {
     generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), Seq(str, len)) {
       val emptyString = s"$BINARY_STRING.EMPTY_UTF8"
-      terms => s"${terms(1)} <= 0 ? $emptyString : ${terms.head}.substringSQL(1, ${terms(1)})"
+      terms =>
+        s"${terms(1)} <= 0 ? $emptyString :" +
+            s" $STRING_UTIL.substringSQL(${terms.head}, 1, ${terms(1)})"
     }
   }
 
@@ -365,7 +367,7 @@ object StringCallGen {
            |  $BINARY_STRING.EMPTY_UTF8 :
            |  ${terms(1)} >= ${terms.head}.numChars() ?
            |  ${terms.head} :
-           |  ${terms.head}.substringSQL(-${terms(1)})
+           |  $STRING_UTIL.substringSQL(${terms.head}, -${terms(1)})
        """.stripMargin
     }
   }
@@ -427,7 +429,7 @@ object StringCallGen {
     ctx: CodeGeneratorContext,
     str: GeneratedExpression): GeneratedExpression = {
     generateCallIfArgsNotNull(ctx, new IntType(), Seq(str)) {
-      terms => s"${terms.head}.getSizeInBytes() <= 0 ? 0 : (int) ${terms.head}.getByte(0)"
+      terms => s"${terms.head}.getSizeInBytes() <= 0 ? 0 : (int) ${terms.head}.byteAt(0)"
     }
   }
 
@@ -547,7 +549,7 @@ object StringCallGen {
     ctx: CodeGeneratorContext,
     operands: Seq[GeneratedExpression]): GeneratedExpression = {
     generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms => s"${terms.head}.reverse()"
+      terms => s"$STRING_UTIL.reverse(${terms.head})"
     }
   }
 
@@ -574,8 +576,7 @@ object StringCallGen {
     operands: Seq[GeneratedExpression]): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
     generateCallIfArgsNullable(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms =>
-        s"$className.keyValue(${terms.mkString(",")})"
+      terms => s"$className.keyValue(${terms.mkString(",")})"
     }
   }
 
@@ -600,7 +601,7 @@ object StringCallGen {
     val digestTerm = ctx.addReusableMessageDigest(algorithm)
     if (operands.length == 1) {
       generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-        terms =>s"${terms.head}.hash($digestTerm)"
+        terms =>s"$STRING_UTIL.hash(${terms.head}, $digestTerm)"
       }
     } else {
       val className = classOf[SqlFunctionUtils].getCanonicalName
@@ -643,7 +644,7 @@ object StringCallGen {
       val digestTerm = ctx.addReusableSha2MessageDigest(operands.last)
       if (operands.length == 2) {
         generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-          terms =>s"${terms.head}.hash($digestTerm)"
+          terms =>s"$STRING_UTIL.hash(${terms.head}, $digestTerm)"
         }
       } else {
         generateStringResultCallIfArgsNotNull(ctx, operands) {
@@ -656,7 +657,7 @@ object StringCallGen {
       if (operands.length == 2) {
         generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
           terms =>
-            s"""${terms.head}.hash("SHA-" + ${terms.last})"""
+            s"""$STRING_UTIL.hash(${terms.head}, "SHA-" + ${terms.last})"""
         }
       } else {
         generateStringResultCallIfArgsNotNull(ctx, operands) {
@@ -740,7 +741,7 @@ object StringCallGen {
         val leading = compareEnum(terms.head, BOTH) || compareEnum(terms.head, LEADING)
         val trailing = compareEnum(terms.head, BOTH) || compareEnum(terms.head, TRAILING)
         val args = s"$leading, $trailing, ${terms(1)}"
-        s"${terms(2)}.trim($args)"
+        s"$STRING_UTIL.trim(${terms(2)}, $args)"
     }
   }
 
@@ -748,7 +749,7 @@ object StringCallGen {
     ctx: CodeGeneratorContext,
     operands: Seq[GeneratedExpression]): GeneratedExpression = {
     generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms => s"${terms.head}.trimLeft(${terms.drop(1).mkString(", ")})"
+      terms => s"$STRING_UTIL.trimLeft(${terms.mkString(", ")})"
     }
   }
 
@@ -756,7 +757,7 @@ object StringCallGen {
     ctx: CodeGeneratorContext,
     operands: Seq[GeneratedExpression]): GeneratedExpression = {
     generateCallIfArgsNotNull(ctx, new VarCharType(VarCharType.MAX_LENGTH), operands) {
-      terms => s"${terms.head}.trimRight(${terms.drop(1).mkString(", ")})"
+      terms => s"$STRING_UTIL.trimRight(${terms.mkString(", ")})"
     }
   }
 
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryFormat.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryFormat.java
index cd8fe50ff54..fe374eb0e57 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryFormat.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryFormat.java
@@ -151,14 +151,14 @@ public abstract class BinaryFormat {
 		if (mark == 0) {
 			final int subOffset = (int) (variablePartOffsetAndLen >> 32);
 			final int len = (int) variablePartOffsetAndLen;
-			return new BinaryString(segments, baseOffset + subOffset, len);
+			return BinaryString.fromAddress(segments, baseOffset + subOffset, len);
 		} else {
 			int len = (int) ((variablePartOffsetAndLen & HIGHEST_SECOND_TO_EIGHTH_BIT) >>> 56);
 			if (SegmentsUtil.LITTLE_ENDIAN) {
-				return new BinaryString(segments, fieldOffset, len);
+				return BinaryString.fromAddress(segments, fieldOffset, len);
 			} else {
 				// fieldOffset + 1 to skip header.
-				return new BinaryString(segments, fieldOffset + 1, len);
+				return BinaryString.fromAddress(segments, fieldOffset + 1, len);
 			}
 		}
 	}
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryString.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryString.java
index 2c1591f392a..79afae68714 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryString.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryString.java
@@ -23,16 +23,10 @@ import org.apache.flink.core.memory.MemorySegmentFactory;
 import org.apache.flink.table.runtime.util.StringUtf8Utils;
 import org.apache.flink.table.typeutils.BinaryStringTypeInfoFactory;
 import org.apache.flink.table.util.SegmentsUtil;
-import org.apache.flink.table.utils.EncodingUtils;
 
-import java.math.BigDecimal;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
+import javax.annotation.Nonnull;
+
 import java.util.Arrays;
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
 
@@ -49,20 +43,25 @@ import static org.apache.flink.util.Preconditions.checkArgument;
 public final class BinaryString extends LazyBinaryFormat<String> implements Comparable<BinaryString> {
 
 	public static final BinaryString EMPTY_UTF8 = BinaryString.fromBytes(StringUtf8Utils.encodeUTF8(""));
-	protected static final BinaryString[] EMPTY_STRING_ARRAY = new BinaryString[0];
 
-	public BinaryString(MemorySegment[] segments, int offset, int sizeInBytes) {
+	public BinaryString() {}
+
+	private BinaryString(MemorySegment[] segments, int offset, int sizeInBytes) {
 		super(segments, offset, sizeInBytes);
 	}
 
-	public BinaryString(String javaObject) {
+	private BinaryString(String javaObject) {
 		super(javaObject);
 	}
 
-	public BinaryString(MemorySegment[] segments, int offset, int sizeInBytes, String javaObject) {
+	private BinaryString(MemorySegment[] segments, int offset, int sizeInBytes, String javaObject) {
 		super(segments, offset, sizeInBytes, javaObject);
 	}
 
+	// ------------------------------------------------------------------------------------------
+	// Constructor helper
+	// ------------------------------------------------------------------------------------------
+
 	/**
 	 * Creates an BinaryString from given address (base and offset) and length.
 	 */
@@ -71,6 +70,9 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		return new BinaryString(segments, offset, numBytes);
 	}
 
+	/**
+	 * Creates an BinaryString from given java String.
+	 */
 	public static BinaryString fromString(String str) {
 		if (str == null) {
 			return null;
@@ -79,13 +81,19 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		}
 	}
 
+	/**
+	 * Creates an BinaryString from given UTF-8 bytes.
+	 */
 	public static BinaryString fromBytes(byte[] bytes) {
 		return fromBytes(bytes, 0, bytes.length);
 	}
 
+	/**
+	 * Creates an BinaryString from given UTF-8 bytes with offset and number of bytes.
+	 */
 	public static BinaryString fromBytes(byte[] bytes, int offset, int numBytes) {
 		return new BinaryString(
-			new MemorySegment[] {MemorySegmentFactory.wrap(bytes)}, offset, numBytes);
+				new MemorySegment[] {MemorySegmentFactory.wrap(bytes)}, offset, numBytes);
 	}
 
 	/**
@@ -97,32 +105,12 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		return fromBytes(spaces);
 	}
 
-	/**
-	 * Returns the number of bytes for a code point with the first byte as `b`.
-	 * @param b The first byte of a code point
-	 */
-	private static int numBytesForFirstByte(final byte b) {
-		if (b >= 0) {
-			// 1 byte, 7 bits: 0xxxxxxx
-			return 1;
-		} else if ((b >> 5) == -2 && (b & 0x1e) != 0) {
-			// 2 bytes, 11 bits: 110xxxxx 10xxxxxx
-			return 2;
-		} else if ((b >> 4) == -2) {
-			// 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
-			return 3;
-		} else if ((b >> 3) == -2) {
-			// 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
-			return 4;
-		} else {
-			// throw new IllegalArgumentException();
-			// Skip the first byte disallowed in UTF-8
-			return 1;
-		}
-	}
+	// ------------------------------------------------------------------------------------------
+	// Public methods on BinaryString
+	// ------------------------------------------------------------------------------------------
 
 	/**
-	 * Returns the number of code points in it.
+	 * Returns the number of UTF-8 code points in the string.
 	 */
 	public int numChars() {
 		ensureMaterialized();
@@ -133,11 +121,11 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 			}
 			return len;
 		} else {
-			return numCharsSlow();
+			return numCharsMultiSegs();
 		}
 	}
 
-	private int numCharsSlow() {
+	private int numCharsMultiSegs() {
 		int len = 0;
 		int segSize = segments[0].size();
 		SegmentAndOffset index = firstSegmentAndOffset(segSize);
@@ -151,17 +139,19 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		return len;
 	}
 
-	public boolean isSpaceString() {
-		if (javaObject != null) {
-			return javaObject.equals(" ");
-		} else {
-			return getByte(0) == ' ';
-		}
-	}
-
-	public byte getByte(int i) {
+	/**
+	 * Returns the {@code byte} value at the specified index. An index ranges from {@code 0} to
+	 * {@code getSizeInBytes() - 1}.
+	 *
+	 * @param      index   the index of the {@code byte} value.
+	 * @return     the {@code byte} value at the specified index of this UTF-8 bytes.
+	 * @exception  IndexOutOfBoundsException  if the {@code index}
+	 *             argument is negative or not less than the length of this
+	 *             UTF-8 bytes.
+	 */
+	public byte byteAt(int index) {
 		ensureMaterialized();
-		int globalOffset = offset + i;
+		int globalOffset = offset + index;
 		int size = segments[0].size();
 		if (globalOffset < size) {
 			return segments[0].get(globalOffset);
@@ -170,12 +160,8 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		}
 	}
 
-	private byte getByteOneSegment(int i) {
-		return segments[0].get(offset + i);
-	}
-
 	/**
-	 * Get the underlying byte array, the returned bytes maybe reused.
+	 * Get the underlying UTF-8 byte array, the returned bytes may be reused.
 	 */
 	public byte[] getBytes() {
 		ensureMaterialized();
@@ -216,6 +202,9 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		sizeInBytes = bytes.length;
 	}
 
+	/**
+	 * Copy a new {@code BinaryString}.
+	 */
 	public BinaryString copy() {
 		ensureMaterialized();
 		byte[] copy = SegmentsUtil.copyToBytes(segments, offset, sizeInBytes);
@@ -224,11 +213,14 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 	}
 
 	/**
-	 * UTF-8 supports bytes comparison.
+	 * Compares two strings lexicographically.
+	 * Since UTF-8 uses groups of six bits, it is sometimes useful to use octal notation which
+	 * uses 3-bit groups. With a calculator which can convert between hexadecimal and octal it
+	 * can be easier to manually create or interpret UTF-8 compared with using binary.
+	 * So we just compare the binary.
 	 */
 	@Override
-	public int compareTo(BinaryString other) {
-
+	public int compareTo(@Nonnull BinaryString other) {
 		if (javaObject != null && other.javaObject != null) {
 			return javaObject.compareTo(other.javaObject);
 		}
@@ -334,83 +326,37 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		return sizeInBytes - other.sizeInBytes;
 	}
 
-	public static String safeToString(BinaryString str) {
-		if (str == null) {
-			return null;
-		} else {
-			return str.toString();
-		}
-	}
-
-	private boolean inFirstSegment() {
-		return sizeInBytes + offset <= segments[0].size();
-	}
-
-
-	// ------------------------------------------------------------------------------------------
-	// Utility methods on BinaryString
-	// ------------------------------------------------------------------------------------------
-
-	public BinaryString substringSQL(int pos) {
-		return substringSQL(pos, Integer.MAX_VALUE);
-	}
-
-	public BinaryString substringSQL(int pos, int length) {
-		if (length < 0) {
-			return null;
-		}
-		ensureMaterialized();
-		if (equals(EMPTY_UTF8)) {
-			return EMPTY_UTF8;
-		}
-
-		int start;
-		int end;
-		int numChars = numChars();
-
-		if (pos > 0) {
-			start = pos - 1;
-			if (start >= numChars) {
-				return EMPTY_UTF8;
-			}
-		} else if (pos < 0) {
-			start = numChars + pos;
-			if (start < 0) {
-				return EMPTY_UTF8;
-			}
-		} else {
-			start = 0;
-		}
-
-		if ((numChars - start) < length) {
-			end = numChars;
-		} else {
-			end = start + length;
-		}
-		return substring(start, end);
-	}
-
 	/**
-	 * Returns a substring of this.
-	 * @param start the position of first code point
-	 * @param until the position after last code point, exclusive.
+	 * Returns a binary string that is a substring of this binary string. The substring begins at
+	 * the specified {@code beginIndex} and extends to the character at index {@code endIndex - 1}.
+	 *
+	 * <p>Examples:
+	 * <blockquote><pre>
+	 * fromString("hamburger").substring(4, 8) returns binary string "urge"
+	 * fromString("smiles").substring(1, 5) returns binary string "mile"
+	 * </pre></blockquote>
+	 *
+	 * @param beginIndex   the beginning index, inclusive.
+	 * @param endIndex     the ending index, exclusive.
+	 * @return the specified substring, return EMPTY_UTF8 when index out of bounds
+	 * instead of StringIndexOutOfBoundsException.
 	 */
-	public BinaryString substring(final int start, final int until) {
+	public BinaryString substring(int beginIndex, int endIndex) {
 		ensureMaterialized();
-		if (until <= start || start >= sizeInBytes) {
+		if (endIndex <= beginIndex || beginIndex >= sizeInBytes) {
 			return EMPTY_UTF8;
 		}
 		if (inFirstSegment()) {
 			MemorySegment segment = segments[0];
 			int i = 0;
 			int c = 0;
-			while (i < sizeInBytes && c < start) {
+			while (i < sizeInBytes && c < beginIndex) {
 				i += numBytesForFirstByte(segment.get(i + offset));
 				c += 1;
 			}
 
 			int j = i;
-			while (i < sizeInBytes && c < until) {
+			while (i < sizeInBytes && c < endIndex) {
 				i += numBytesForFirstByte(segment.get(i + offset));
 				c += 1;
 			}
@@ -423,11 +369,11 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 				return EMPTY_UTF8;
 			}
 		} else {
-			return substringSlow(start, until);
+			return substringMultiSegs(beginIndex, endIndex);
 		}
 	}
 
-	private BinaryString substringSlow(final int start, final int until) {
+	private BinaryString substringMultiSegs(final int start, final int until) {
 		int segSize = segments[0].size();
 		SegmentAndOffset index = firstSegmentAndOffset(segSize);
 		int i = 0;
@@ -455,112 +401,32 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 	}
 
 	/**
-	 * Concatenates input strings together into a single string.
-	 */
-	public static BinaryString concat(BinaryString... inputs) {
-		return concat(Arrays.asList(inputs));
-	}
-
-	/**
-	 * Concatenates input strings together into a single string.
-	 */
-	public static BinaryString concat(Iterable<BinaryString> inputs) {
-		// Compute the total length of the result.
-		int totalLength = 0;
-		for (BinaryString input : inputs) {
-			if (input != null) {
-				input.ensureMaterialized();
-				totalLength += input.getSizeInBytes();
-			}
-		}
-
-		// Allocate a new byte array, and copy the inputs one by one into it.
-		final byte[] result = new byte[totalLength];
-		int offset = 0;
-		for (BinaryString input : inputs) {
-			if (input != null) {
-				int len = input.sizeInBytes;
-				SegmentsUtil.copyToBytes(input.segments, input.offset, result, offset, len);
-				offset += len;
-			}
-		}
-		return fromBytes(result);
-	}
-
-	/**
-	 * Concatenates input strings together into a single string using the separator.
-	 * A null input is skipped. For example, concat(",", "a", null, "c") would yield "a,c".
-	 */
-	public static BinaryString concatWs(BinaryString separator, BinaryString... inputs) {
-		return concatWs(separator, Arrays.asList(inputs));
-	}
-
-	/**
-	 * Concatenates input strings together into a single string using the separator.
-	 * A null input is skipped. For example, concat(",", "a", null, "c") would yield "a,c".
-	 */
-	public static BinaryString concatWs(BinaryString separator, Iterable<BinaryString> inputs) {
-		if (null == separator || EMPTY_UTF8.equals(separator)) {
-			return concat(inputs);
-		}
-		separator.ensureMaterialized();
-
-		int numInputBytes = 0;  // total number of bytes from the inputs
-		int numInputs = 0;      // number of non-null inputs
-		for (BinaryString input : inputs) {
-			if (input != null) {
-				input.ensureMaterialized();
-				numInputBytes += input.sizeInBytes;
-				numInputs++;
-			}
-		}
-
-		if (numInputs == 0) {
-			// Return an empty string if there is no input, or all the inputs are null.
-			return EMPTY_UTF8;
-		}
-
-		// Allocate a new byte array, and copy the inputs one by one into it.
-		// The size of the new array is the size of all inputs, plus the separators.
-		final byte[] result = new byte[numInputBytes + (numInputs - 1) * separator.sizeInBytes];
-		int offset = 0;
-
-		int j = 0;
-		for (BinaryString input : inputs) {
-			if (input != null) {
-				int len = input.sizeInBytes;
-				SegmentsUtil.copyToBytes(input.segments, input.offset, result, offset, len);
-				offset += len;
-
-				j++;
-				// Add separator if this is not the last input.
-				if (j < numInputs) {
-					SegmentsUtil.copyToBytes(separator.segments, separator.offset, result, offset, separator.sizeInBytes);
-					offset += separator.sizeInBytes;
-				}
-			}
-		}
-		return fromBytes(result);
-	}
-
-	/**
-	 * Returns whether this contains `substring` or not.
-	 * Same to like '%substring%'.
+	 * Returns true if and only if this BinaryString contains the specified
+	 * sequence of bytes values.
+	 *
+	 * @param s the sequence to search for
+	 * @return true if this BinaryString contains {@code s}, false otherwise
 	 */
-	public boolean contains(final BinaryString substring) {
+	public boolean contains(final BinaryString s) {
 		ensureMaterialized();
-		substring.ensureMaterialized();
-		if (substring.sizeInBytes == 0) {
+		s.ensureMaterialized();
+		if (s.sizeInBytes == 0) {
 			return true;
 		}
 		int find = SegmentsUtil.find(
 			segments, offset, sizeInBytes,
-			substring.segments, substring.offset, substring.sizeInBytes);
+			s.segments, s.offset, s.sizeInBytes);
 		return find != -1;
 	}
 
 	/**
-	 * Same to like 'prefix%'.
+	 * Tests if this BinaryString starts with the specified prefix.
+	 *
+	 * @param   prefix   the prefix.
+	 * @return  {@code true} if the bytes represented by the argument is a prefix of the bytes
+	 *          represented by this string; {@code false} otherwise. Note also that {@code true}
+	 *          will be returned if the argument is an empty BinaryString or is equal to this
+	 *          {@code BinaryString} object as determined by the {@link #equals(Object)} method.
 	 */
 	public boolean startsWith(final BinaryString prefix) {
 		ensureMaterialized();
@@ -569,7 +435,13 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 	}
 
 	/**
-	 * Same to like '%suffix'.
+	 * Tests if this BinaryString ends with the specified suffix.
+	 *
+	 * @param   suffix   the suffix.
+	 * @return  {@code true} if the bytes represented by the argument is a suffix of the bytes
+	 *          represented by this object; {@code false} otherwise. Note that the result will
+	 *          be {@code true} if the argument is the empty string or is equal to this
+	 *          {@code BinaryString} object as determined by the {@link #equals(Object)} method.
 	 */
 	public boolean endsWith(final BinaryString suffix) {
 		ensureMaterialized();
@@ -577,34 +449,14 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		return matchAt(suffix, sizeInBytes - suffix.sizeInBytes);
 	}
 
-	private boolean matchAt(final BinaryString s, int pos) {
-		return (inFirstSegment() && s.inFirstSegment()) ? matchAtOneSeg(s, pos) : matchAtVarSeg(s, pos);
-	}
-
-	private boolean matchAtOneSeg(final BinaryString s, int pos) {
-		return s.sizeInBytes + pos <= sizeInBytes && pos >= 0 &&
-			segments[0].equalTo(s.segments[0], offset + pos, s.offset, s.sizeInBytes);
-	}
-
-	private boolean matchAtVarSeg(final BinaryString s, int pos) {
-		return s.sizeInBytes + pos <= sizeInBytes && pos >= 0 &&
-			SegmentsUtil.equals(segments, offset + pos, s.segments, s.offset, s.sizeInBytes);
-	}
-
-	private BinaryString copyBinaryStringInOneSeg(int start, int end) {
-		int len = end - start + 1;
-		byte[] newBytes = new byte[len];
-		segments[0].get(offset + start, newBytes, 0, len);
-		return fromBytes(newBytes);
-	}
-
-	private BinaryString copyBinaryString(int start, int end) {
-		int len = end - start + 1;
-		byte[] newBytes = new byte[len];
-		SegmentsUtil.copyToBytes(segments, offset + start, newBytes, 0, len);
-		return fromBytes(newBytes);
-	}
-
+	/**
+	 * Returns a string whose value is this string, with any leading and trailing
+	 * whitespace removed.
+	 *
+	 * @return  A string whose value is this string, with any leading and trailing white
+	 *          space removed, or this string if it has no leading or
+	 *          trailing white space.
+	 */
 	public BinaryString trim() {
 		ensureMaterialized();
 		if (inFirstSegment()) {
@@ -622,14 +474,14 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 				// empty string
 				return EMPTY_UTF8;
 			} else {
-				return copyBinaryStringInOneSeg(s, e);
+				return copyBinaryStringInOneSeg(s, e - s + 1);
 			}
 		} else {
-			return trimSlow();
+			return trimMultiSegs();
 		}
 	}
 
-	private BinaryString trimSlow() {
+	private BinaryString trimMultiSegs() {
 		int s = 0;
 		int e = this.sizeInBytes - 1;
 		int segSize = segments[0].size();
@@ -654,531 +506,210 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 	}
 
 	/**
-	 * Walk each character of current string from both ends, remove the character if it
-	 * is in trim string.
-	 * Return the new substring which both ends trim characters have been removed.
+	 * Returns the index within this string of the first occurrence of the
+	 * specified substring, starting at the specified index.
 	 *
-	 * @param trimStr the trim string
-	 * @return A subString which both ends trim characters have been removed.
+	 * @param   str         the substring to search for.
+	 * @param   fromIndex   the index from which to start the search.
+	 * @return  the index of the first occurrence of the specified substring,
+	 *          starting at the specified index,
+	 *          or {@code -1} if there is no such occurrence.
 	 */
-	public BinaryString trim(BinaryString trimStr) {
-		if (trimStr == null) {
-			return null;
-		}
-		return trimLeft(trimStr).trimRight(trimStr);
-	}
-
-	public BinaryString trimLeft() {
+	public int indexOf(BinaryString str, int fromIndex) {
 		ensureMaterialized();
+		str.ensureMaterialized();
+		if (str.sizeInBytes == 0) {
+			return 0;
+		}
 		if (inFirstSegment()) {
-			int s = 0;
-			// skip all of the space (0x20) in the left side
-			while (s < this.sizeInBytes && getByteOneSegment(s) == 0x20) {
-				s++;
-			}
-			if (s == this.sizeInBytes) {
-				// empty string
-				return EMPTY_UTF8;
-			} else {
-				return copyBinaryStringInOneSeg(s, this.sizeInBytes - 1);
+			// position in byte
+			int byteIdx = 0;
+			// position is char
+			int charIdx = 0;
+			while (byteIdx < sizeInBytes && charIdx < fromIndex) {
+				byteIdx += numBytesForFirstByte(getByteOneSegment(byteIdx));
+				charIdx++;
 			}
+			do {
+				if (byteIdx + str.sizeInBytes > sizeInBytes) {
+					return -1;
+				}
+				if (SegmentsUtil.equals(segments, offset + byteIdx,
+						str.segments, str.offset, str.sizeInBytes)) {
+					return charIdx;
+				}
+				byteIdx += numBytesForFirstByte(getByteOneSegment(byteIdx));
+				charIdx++;
+			} while (byteIdx < sizeInBytes);
+
+			return -1;
 		} else {
-			return trimLeftSlow();
+			return indexOfMultiSegs(str, fromIndex);
 		}
 	}
 
-	private BinaryString trimLeftSlow() {
-		int s = 0;
+	private int indexOfMultiSegs(BinaryString str, int fromIndex) {
+		// position in byte
+		int byteIdx = 0;
+		// position is char
+		int charIdx = 0;
 		int segSize = segments[0].size();
-		SegmentAndOffset front = firstSegmentAndOffset(segSize);
-		// skip all of the space (0x20) in the left side
-		while (s < this.sizeInBytes && front.value() == 0x20) {
-			s++;
-			front.nextByte(segSize);
-		}
-		if (s == this.sizeInBytes) {
-			// empty string
-			return EMPTY_UTF8;
-		} else {
-			return copyBinaryString(s, this.sizeInBytes - 1);
+		SegmentAndOffset index = firstSegmentAndOffset(segSize);
+		while (byteIdx < sizeInBytes && charIdx < fromIndex) {
+			int charBytes = numBytesForFirstByte(index.value());
+			byteIdx += charBytes;
+			charIdx++;
+			index.skipBytes(charBytes, segSize);
 		}
+		do {
+			if (byteIdx + str.sizeInBytes > sizeInBytes) {
+				return -1;
+			}
+			if (SegmentsUtil.equals(segments, offset + byteIdx,
+					str.segments, str.offset, str.sizeInBytes)) {
+				return charIdx;
+			}
+			int charBytes = numBytesForFirstByte(index.segment.get(index.offset));
+			byteIdx += charBytes;
+			charIdx++;
+			index.skipBytes(charBytes, segSize);
+		} while (byteIdx < sizeInBytes);
+
+		return -1;
 	}
 
 	/**
-	 * Walk each character of current string from left end, remove the character if it
-	 * is in trim string. Stops at the first character which is not in trim string.
-	 * Return the new substring.
+	 * Converts all of the characters in this {@code BinaryString} to upper case.
 	 *
-	 * @param trimStr the trim string
-	 * @return A subString which removes all of the character from the left side that is in
-	 * trim string.
+	 * @return the {@code BinaryString}, converted to uppercase.
 	 */
-	public BinaryString trimLeft(BinaryString trimStr) {
-		ensureMaterialized();
-		if (trimStr == null) {
-			return null;
+	public BinaryString toUpperCase() {
+		if (javaObject != null) {
+			return javaToUpperCase();
 		}
-		trimStr.ensureMaterialized();
-		if (trimStr.isSpaceString()) {
-			return trimLeft();
+		if (sizeInBytes == 0) {
+			return EMPTY_UTF8;
 		}
-		if (inFirstSegment()) {
-			int searchIdx = 0;
-			while (searchIdx < this.sizeInBytes) {
-				int charBytes = numBytesForFirstByte(getByteOneSegment(searchIdx));
-				BinaryString currentChar = copyBinaryStringInOneSeg(searchIdx,
-					searchIdx + charBytes - 1);
-				// try to find the matching for the character in the trimString characters.
-				if (trimStr.contains(currentChar)) {
-					searchIdx += charBytes;
-				} else {
-					break;
-				}
+		int size = segments[0].size();
+		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
+		byte[] bytes = new byte[sizeInBytes];
+		bytes[0] = (byte) Character.toTitleCase(segmentAndOffset.value());
+		for (int i = 0; i < sizeInBytes; i++) {
+			byte b = segmentAndOffset.value();
+			if (numBytesForFirstByte(b) != 1) {
+				// fallback
+				return javaToUpperCase();
 			}
-			// empty string
-			if (searchIdx >= sizeInBytes) {
-				return EMPTY_UTF8;
-			} else {
-				return copyBinaryStringInOneSeg(searchIdx, sizeInBytes - 1);
+			int upper = Character.toUpperCase((int) b);
+			if (upper > 127) {
+				// fallback
+				return javaToUpperCase();
 			}
-		} else {
-			return trimLeftSlow(trimStr);
+			bytes[i] = (byte) upper;
+			segmentAndOffset.nextByte(size);
 		}
+		return fromBytes(bytes);
 	}
 
-	private BinaryString trimLeftSlow(BinaryString trimStr) {
-		int searchIdx = 0;
-		int segSize = segments[0].size();
-		SegmentAndOffset front = firstSegmentAndOffset(segSize);
-		while (searchIdx < this.sizeInBytes) {
-			int charBytes = numBytesForFirstByte(front.value());
-			BinaryString currentChar = copyBinaryString(searchIdx, searchIdx + charBytes - 1);
-			if (trimStr.contains(currentChar)) {
-				searchIdx += charBytes;
-				front.skipBytes(charBytes, segSize);
-			} else {
-				break;
-			}
+	private BinaryString javaToUpperCase() {
+		return fromString(toString().toUpperCase());
+	}
+
+	/**
+	 * Converts all of the characters in this {@code BinaryString} to lower case.
+	 *
+	 * @return the {@code BinaryString}, converted to lowercase.
+	 */
+	public BinaryString toLowerCase() {
+		if (javaObject != null) {
+			return javaToLowerCase();
 		}
-		if (searchIdx == this.sizeInBytes) {
-			// empty string
+		if (sizeInBytes == 0) {
 			return EMPTY_UTF8;
-		} else {
-			return copyBinaryString(searchIdx, this.sizeInBytes - 1);
 		}
-	}
-
-	public BinaryString trimRight() {
-		ensureMaterialized();
-		if (inFirstSegment()) {
-			int e = sizeInBytes - 1;
-			// skip all of the space (0x20) in the right side
-			while (e >= 0 && getByteOneSegment(e) == 0x20) {
-				e--;
-			}
-
-			if (e < 0) {
-				// empty string
-				return EMPTY_UTF8;
-			} else {
-				return copyBinaryStringInOneSeg(0, e);
-			}
-		} else {
-			return trimRightSlow();
-		}
-	}
-
-	private BinaryString trimRightSlow() {
-		int e = sizeInBytes - 1;
-		int segSize = segments[0].size();
-		SegmentAndOffset behind = lastSegmentAndOffset(segSize);
-		// skip all of the space (0x20) in the right side
-		while (e >= 0 && behind.value() == 0x20) {
-			e--;
-			behind.previousByte(segSize);
-		}
-
-		if (e < 0) {
-			// empty string
-			return EMPTY_UTF8;
-		} else {
-			return copyBinaryString(0, e);
-		}
-	}
-
-	/**
-	 * Walk each character of current string from right end, remove the character if it
-	 * is in trim string. Stops at the first character which is not in trim string.
-	 * Return the new substring.
-	 *
-	 * @param trimStr the trim string
-	 * @return A subString which removes all of the character from the right side that is in
-	 * trim string.
-	 */
-	public BinaryString trimRight(BinaryString trimStr) {
-		ensureMaterialized();
-		if (trimStr == null) {
-			return null;
-		}
-		trimStr.ensureMaterialized();
-		if (trimStr.isSpaceString()) {
-			return trimRight();
-		}
-		if (inFirstSegment()) {
-			int charIdx = 0;
-			int byteIdx = 0;
-			// each element in charLens is length of character in the source string
-			int[] charLens = new int[sizeInBytes];
-			// each element in charStartPos is start position of first byte in the source string
-			int[] charStartPos = new int[sizeInBytes];
-			while (byteIdx < sizeInBytes) {
-				charStartPos[charIdx] = byteIdx;
-				charLens[charIdx] = numBytesForFirstByte(getByteOneSegment(byteIdx));
-				byteIdx += charLens[charIdx];
-				charIdx++;
-			}
-			// searchIdx points to the first character which is not in trim string from the right
-			// end.
-			int searchIdx = sizeInBytes - 1;
-			charIdx -= 1;
-			while (charIdx >= 0) {
-				BinaryString currentChar = copyBinaryStringInOneSeg(
-					charStartPos[charIdx],
-					charStartPos[charIdx] + charLens[charIdx] - 1);
-				if (trimStr.contains(currentChar)) {
-					searchIdx -= charLens[charIdx];
-				} else {
-					break;
-				}
-				charIdx--;
-			}
-			if (searchIdx < 0) {
-				// empty string
-				return EMPTY_UTF8;
-			} else {
-				return copyBinaryStringInOneSeg(0, searchIdx);
+		int size = segments[0].size();
+		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
+		byte[] bytes = new byte[sizeInBytes];
+		bytes[0] = (byte) Character.toTitleCase(segmentAndOffset.value());
+		for (int i = 0; i < sizeInBytes; i++) {
+			byte b = segmentAndOffset.value();
+			if (numBytesForFirstByte(b) != 1) {
+				// fallback
+				return javaToLowerCase();
 			}
-		} else {
-			return trimRightSlow(trimStr);
-		}
-	}
-
-	private BinaryString trimRightSlow(BinaryString trimStr) {
-		int charIdx = 0;
-		int byteIdx = 0;
-		int segSize = segments[0].size();
-		SegmentAndOffset index = firstSegmentAndOffset(segSize);
-		// each element in charLens is length of character in the source string
-		int[] charLens = new int[sizeInBytes];
-		// each element in charStartPos is start position of first byte in the source string
-		int[] charStartPos = new int[sizeInBytes];
-		while (byteIdx < sizeInBytes) {
-			charStartPos[charIdx] = byteIdx;
-			int charBytes = numBytesForFirstByte(index.value());
-			charLens[charIdx] = charBytes;
-			byteIdx += charBytes;
-			charIdx++;
-			index.skipBytes(charBytes, segSize);
-		}
-		// searchIdx points to the first character which is not in trim string from the right
-		// end.
-		int searchIdx = sizeInBytes - 1;
-		charIdx -= 1;
-		while (charIdx >= 0) {
-			BinaryString currentChar = copyBinaryString(
-				charStartPos[charIdx],
-				charStartPos[charIdx] + charLens[charIdx] - 1);
-			if (trimStr.contains(currentChar)) {
-				searchIdx -= charLens[charIdx];
-			} else {
-				break;
+			int lower = Character.toLowerCase((int) b);
+			if (lower > 127) {
+				// fallback
+				return javaToLowerCase();
 			}
-			charIdx--;
-		}
-		if (searchIdx < 0) {
-			// empty string
-			return EMPTY_UTF8;
-		} else {
-			return copyBinaryString(0, searchIdx);
+			bytes[i] = (byte) lower;
+			segmentAndOffset.nextByte(size);
 		}
+		return fromBytes(bytes);
 	}
 
-	public BinaryString trim(boolean leading, boolean trailing, BinaryString seek) {
-		ensureMaterialized();
-		if (seek == null) {
-			return null;
-		}
-		if (leading && trailing) {
-			return trim(seek);
-		} else if (leading) {
-			return trimLeft(seek);
-		} else if (trailing) {
-			return trimRight(seek);
-		} else {
-			return this;
-		}
+	private BinaryString javaToLowerCase() {
+		return fromString(toString().toLowerCase());
 	}
 
-	/**
-	 * Parse target string as key-value string and
-	 * return the value matches key name.
-	 * If accept any null arguments, return null.
-	 * example:
-	 * keyvalue('k1=v1;k2=v2', ';', '=', 'k2') = 'v2'
-	 * keyvalue('k1:v1,k2:v2', ',', ':', 'k3') = NULL
-	 *
-	 * @param split1  separator between key-value tuple.
-	 * @param split2  separator between key and value.
-	 * @param keyName name of the key whose value you want return.
-	 *
-	 * @return target value.
-	 */
-	public BinaryString keyValue(byte split1, byte split2, BinaryString keyName) {
-		ensureMaterialized();
-		if (keyName == null || keyName.getSizeInBytes() == 0) {
-			return null;
-		}
-		if (inFirstSegment() && keyName.inFirstSegment()) {
-			// position in byte
-			int byteIdx = 0;
-			// position of last split1
-			int lastSplit1Idx = -1;
-			while (byteIdx < sizeInBytes) {
-				// If find next split1 in str, process current kv
-				if (segments[0].get(offset + byteIdx) == split1) {
-					int currentKeyIdx = lastSplit1Idx + 1;
-					// If key of current kv is keyName, return the value directly
-					BinaryString value = findValueOfKey(split2, keyName, currentKeyIdx, byteIdx);
-					if (value != null) {
-						return value;
-					}
-					lastSplit1Idx = byteIdx;
-				}
-				byteIdx++;
-			}
-			// process the string which is not ends with split1
-			int currentKeyIdx = lastSplit1Idx + 1;
-			return findValueOfKey(split2, keyName, currentKeyIdx, sizeInBytes);
-		} else {
-			return keyValueSlow(split1, split2, keyName);
-		}
-	}
+	// ------------------------------------------------------------------------------------------
+	// Internal methods on BinaryString
+	// ------------------------------------------------------------------------------------------
 
-	private BinaryString findValueOfKey(
-		byte split,
-		BinaryString keyName,
-		int start,
-		int end) {
-		int keyNameLen = keyName.sizeInBytes;
-		for (int idx = start; idx < end; idx++) {
-			if (segments[0].get(offset + idx) == split) {
-				if (idx == start + keyNameLen &&
-					segments[0].equalTo(keyName.segments[0], offset + start,
-						keyName.offset, keyNameLen)) {
-					int valueIdx = idx + 1;
-					int valueLen = end - valueIdx;
-					byte[] bytes = new byte[valueLen];
-					segments[0].get(offset + valueIdx, bytes, 0, valueLen);
-					return fromBytes(bytes, 0, valueLen);
-				} else {
-					return null;
-				}
-			}
-		}
-		return null;
+	byte getByteOneSegment(int i) {
+		return segments[0].get(offset + i);
 	}
 
-	private BinaryString keyValueSlow(
-		byte split1,
-		byte split2,
-		BinaryString keyName) {
-		// position in byte
-		int byteIdx = 0;
-		// position of last split1
-		int lastSplit1Idx = -1;
-		while (byteIdx < sizeInBytes) {
-			// If find next split1 in str, process current kv
-			if (getByte(byteIdx) == split1) {
-				int currentKeyIdx = lastSplit1Idx + 1;
-				BinaryString value = findValueOfKeySlow(split2, keyName, currentKeyIdx, byteIdx);
-				if (value != null) {
-					return value;
-				}
-				lastSplit1Idx = byteIdx;
-			}
-			byteIdx++;
-		}
-		int currentKeyIdx = lastSplit1Idx + 1;
-		return findValueOfKeySlow(split2, keyName, currentKeyIdx, sizeInBytes);
+	boolean inFirstSegment() {
+		return sizeInBytes + offset <= segments[0].size();
 	}
 
-	private BinaryString findValueOfKeySlow(
-		byte split,
-		BinaryString keyName,
-		int start,
-		int end) {
-		int keyNameLen = keyName.sizeInBytes;
-		for (int idx = start; idx < end; idx++) {
-			if (getByte(idx) == split) {
-				if (idx == start + keyNameLen &&
-					SegmentsUtil.equals(segments, offset + start, keyName.segments,
-						keyName.offset, keyNameLen)) {
-					int valueIdx = idx + 1;
-					byte[] bytes = SegmentsUtil.copyToBytes(segments, offset + valueIdx, end - valueIdx);
-					return fromBytes(bytes);
-				} else {
-					return null;
-				}
-			}
-		}
-		return null;
+	private boolean matchAt(final BinaryString s, int pos) {
+		return (inFirstSegment() && s.inFirstSegment()) ? matchAtOneSeg(s, pos) : matchAtVarSeg(s, pos);
 	}
 
-	/**
-	 * Returns the position of the first occurence of substr in  current string starting from given
-	 * position.
-	 *
-	 * @param subStr subStr to be searched
-	 * @param start  start position
-	 * @return the position of the first occurence of substring. Return -1 if not found.
-	 */
-	public int indexOf(BinaryString subStr, int start) {
-		ensureMaterialized();
-		subStr.ensureMaterialized();
-		if (subStr.sizeInBytes == 0) {
-			return 0;
-		}
-		if (inFirstSegment()) {
-			// position in byte
-			int byteIdx = 0;
-			// position is char
-			int charIdx = 0;
-			while (byteIdx < sizeInBytes && charIdx < start) {
-				byteIdx += numBytesForFirstByte(getByteOneSegment(byteIdx));
-				charIdx++;
-			}
-			do {
-				if (byteIdx + subStr.sizeInBytes > sizeInBytes) {
-					return -1;
-				}
-				if (SegmentsUtil.equals(segments, offset + byteIdx,
-					subStr.segments, subStr.offset, subStr.sizeInBytes)) {
-					return charIdx;
-				}
-				byteIdx += numBytesForFirstByte(getByteOneSegment(byteIdx));
-				charIdx++;
-			} while (byteIdx < sizeInBytes);
-
-			return -1;
-		} else {
-			return indexOfSlow(subStr, start);
-		}
+	private boolean matchAtOneSeg(final BinaryString s, int pos) {
+		return s.sizeInBytes + pos <= sizeInBytes && pos >= 0 &&
+			segments[0].equalTo(s.segments[0], offset + pos, s.offset, s.sizeInBytes);
 	}
 
-	private int indexOfSlow(BinaryString subStr, int start) {
-		// position in byte
-		int byteIdx = 0;
-		// position is char
-		int charIdx = 0;
-		int segSize = segments[0].size();
-		SegmentAndOffset index = firstSegmentAndOffset(segSize);
-		while (byteIdx < sizeInBytes && charIdx < start) {
-			int charBytes = numBytesForFirstByte(index.value());
-			byteIdx += charBytes;
-			charIdx++;
-			index.skipBytes(charBytes, segSize);
-		}
-		do {
-			if (byteIdx + subStr.sizeInBytes > sizeInBytes) {
-				return -1;
-			}
-			if (SegmentsUtil.equals(segments, offset + byteIdx,
-				subStr.segments, subStr.offset, subStr.sizeInBytes)) {
-				return charIdx;
-			}
-			int charBytes = numBytesForFirstByte(index.segment.get(index.offset));
-			byteIdx += charBytes;
-			charIdx++;
-			index.skipBytes(charBytes, segSize);
-		} while (byteIdx < sizeInBytes);
-
-		return -1;
+	private boolean matchAtVarSeg(final BinaryString s, int pos) {
+		return s.sizeInBytes + pos <= sizeInBytes && pos >= 0 &&
+			SegmentsUtil.equals(segments, offset + pos, s.segments, s.offset, s.sizeInBytes);
 	}
 
-	/**
-	 * Reverse each character in current string.
-	 *
-	 * @return a new string which character order is reverse to current string.
-	 */
-	public BinaryString reverse() {
-		ensureMaterialized();
-		if (inFirstSegment()) {
-			byte[] result = new byte[this.sizeInBytes];
-			// position in byte
-			int byteIdx = 0;
-			while (byteIdx < sizeInBytes) {
-				int charBytes = numBytesForFirstByte(getByteOneSegment(byteIdx));
-				segments[0].get(
-					offset + byteIdx,
-					result,
-					result.length - byteIdx - charBytes,
-					charBytes);
-				byteIdx += charBytes;
-			}
-			return BinaryString.fromBytes(result);
-		} else {
-			return reverseSlow();
-		}
+	BinaryString copyBinaryStringInOneSeg(int start, int len) {
+		byte[] newBytes = new byte[len];
+		segments[0].get(offset + start, newBytes, 0, len);
+		return fromBytes(newBytes);
 	}
 
-	private BinaryString reverseSlow() {
-		byte[] result = new byte[this.sizeInBytes];
-		// position in byte
-		int byteIdx = 0;
-		int segSize = segments[0].size();
-		SegmentAndOffset index = firstSegmentAndOffset(segSize);
-		while (byteIdx < sizeInBytes) {
-			int charBytes = numBytesForFirstByte(index.value());
-			SegmentsUtil.copyMultiSegmentsToBytes(
-				segments,
-				offset + byteIdx,
-				result,
-				result.length - byteIdx - charBytes,
-				charBytes);
-			byteIdx += charBytes;
-			index.skipBytes(charBytes, segSize);
-		}
-		return BinaryString.fromBytes(result);
+	BinaryString copyBinaryString(int start, int end) {
+		int len = end - start + 1;
+		byte[] newBytes = new byte[len];
+		SegmentsUtil.copyToBytes(segments, offset + start, newBytes, 0, len);
+		return fromBytes(newBytes);
 	}
 
-
-	// TODO repeat find rfind rpad lpad split
-	// TODO upper/lower is slow?..
-
-	private SegmentAndOffset firstSegmentAndOffset(int segSize) {
+	SegmentAndOffset firstSegmentAndOffset(int segSize) {
 		int segIndex = offset / segSize;
 		return new SegmentAndOffset(segIndex, offset % segSize);
 	}
 
-	private SegmentAndOffset lastSegmentAndOffset(int segSize) {
+	SegmentAndOffset lastSegmentAndOffset(int segSize) {
 		int lastOffset = offset + sizeInBytes - 1;
 		int segIndex = lastOffset / segSize;
 		return new SegmentAndOffset(segIndex, lastOffset % segSize);
 	}
 
 	private SegmentAndOffset startSegmentAndOffset(int segSize) {
-		if (inFirstSegment()) {
-			return new SegmentAndOffset(0, offset);
-		}
-		else {
-			return firstSegmentAndOffset(segSize);
-		}
+		return inFirstSegment() ? new SegmentAndOffset(0, offset) : firstSegmentAndOffset(segSize);
 	}
 
 	/**
 	 * CurrentSegment and positionInSegment.
 	 */
-	private class SegmentAndOffset {
+	class SegmentAndOffset {
 		int segIndex;
 		MemorySegment segment;
 		int offset;
@@ -1190,14 +721,11 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 		}
 
 		private void assignSegment() {
-			if (segIndex >= 0 && segIndex < segments.length) {
-				segment = segments[segIndex];
-			} else {
-				segment = null;
-			}
+			segment = segIndex >= 0 && segIndex < segments.length ?
+					segments[segIndex] : null;
 		}
 
-		private void previousByte(int segSize) {
+		void previousByte(int segSize) {
 			offset--;
 			if (offset == -1) {
 				segIndex--;
@@ -1206,7 +734,7 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 			}
 		}
 
-		private void nextByte(int segSize) {
+		void nextByte(int segSize) {
 			offset++;
 			checkAdvance(segSize);
 		}
@@ -1223,7 +751,7 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 			offset = 0;
 		}
 
-		private void skipBytes(int n, int segSize) {
+		void skipBytes(int n, int segSize) {
 			int remaining = segSize - this.offset;
 			if (remaining > n) {
 				this.offset += n;
@@ -1242,599 +770,32 @@ public final class BinaryString extends LazyBinaryFormat<String> implements Comp
 			}
 		}
 
-		private byte value() {
+		byte value() {
 			return this.segment.get(this.offset);
 		}
 	}
 
 	/**
-	 * Parses this BinaryString to Long.
-	 *
-	 * <p>Note that, in this method we accumulate the result in negative format, and convert it to
-	 * positive format at the end, if this string is not started with '-'. This is because min value
-	 * is bigger than max value in digits, e.g. Long.MAX_VALUE is '9223372036854775807' and
-	 * Long.MIN_VALUE is '-9223372036854775808'.
-	 *
-	 * <p>This code is mostly copied from LazyLong.parseLong in Hive.
-	 * @return Long value if the parsing was successful else null.
-	 */
-	public Long toLong() {
-		ensureMaterialized();
-		if (sizeInBytes == 0) {
-			return null;
-		}
-		int size = segments[0].size();
-		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
-		int totalOffset = 0;
-
-		byte b = segmentAndOffset.value();
-		final boolean negative = b == '-';
-		if (negative || b == '+') {
-			segmentAndOffset.nextByte(size);
-			totalOffset++;
-			if (sizeInBytes == 1) {
-				return null;
-			}
-		}
-
-		long result = 0;
-		final byte separator = '.';
-		final int radix = 10;
-		final long stopValue = Long.MIN_VALUE / radix;
-		while (totalOffset < this.sizeInBytes) {
-			b = segmentAndOffset.value();
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-			if (b == separator) {
-				// We allow decimals and will return a truncated integral in that case.
-				// Therefore we won't throw an exception here (checking the fractional
-				// part happens below.)
-				break;
-			}
-
-			int digit;
-			if (b >= '0' && b <= '9') {
-				digit = b - '0';
-			} else {
-				return null;
-			}
-
-			// We are going to process the new digit and accumulate the result. However, before
-			// doing this, if the result is already smaller than the
-			// stopValue(Long.MIN_VALUE / radix), then result * 10 will definitely be smaller
-			// than minValue, and we can stop.
-			if (result < stopValue) {
-				return null;
-			}
-
-			result = result * radix - digit;
-			// Since the previous result is less than or equal to
-			// stopValue(Long.MIN_VALUE / radix), we can just use `result > 0` to check overflow.
-			// If result overflows, we should stop.
-			if (result > 0) {
-				return null;
-			}
-		}
-
-		// This is the case when we've encountered a decimal separator. The fractional
-		// part will not change the number, but we will verify that the fractional part
-		// is well formed.
-		while (totalOffset < sizeInBytes) {
-			byte currentByte = segmentAndOffset.value();
-			if (currentByte < '0' || currentByte > '9') {
-				return null;
-			}
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-		}
-
-		if (!negative) {
-			result = -result;
-			if (result < 0) {
-				return null;
-			}
-		}
-		return result;
-	}
-
-	/**
-	 * Parses this BinaryString to Int.
-	 *
-	 * <p>Note that, in this method we accumulate the result in negative format, and convert it to
-	 * positive format at the end, if this string is not started with '-'. This is because min value
-	 * is bigger than max value in digits, e.g. Integer.MAX_VALUE is '2147483647' and
-	 * Integer.MIN_VALUE is '-2147483648'.
-	 *
-	 * <p>This code is mostly copied from LazyInt.parseInt in Hive.
-	 *
-	 * <p>Note that, this method is almost same as `toLong`, but we leave it duplicated for performance
-	 * reasons, like Hive does.
-	 * @return Integer value if the parsing was successful else null.
-	 */
-	public Integer toInt() {
-		ensureMaterialized();
-		if (sizeInBytes == 0) {
-			return null;
-		}
-		int size = segments[0].size();
-		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
-		int totalOffset = 0;
-
-		byte b = segmentAndOffset.value();
-		final boolean negative = b == '-';
-		if (negative || b == '+') {
-			segmentAndOffset.nextByte(size);
-			totalOffset++;
-			if (sizeInBytes == 1) {
-				return null;
-			}
-		}
-
-		int result = 0;
-		final byte separator = '.';
-		final int radix = 10;
-		final long stopValue = Integer.MIN_VALUE / radix;
-		while (totalOffset < this.sizeInBytes) {
-			b = segmentAndOffset.value();
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-			if (b == separator) {
-				// We allow decimals and will return a truncated integral in that case.
-				// Therefore we won't throw an exception here (checking the fractional
-				// part happens below.)
-				break;
-			}
-
-			int digit;
-			if (b >= '0' && b <= '9') {
-				digit = b - '0';
-			} else {
-				return null;
-			}
-
-			// We are going to process the new digit and accumulate the result. However, before
-			// doing this, if the result is already smaller than the
-			// stopValue(Long.MIN_VALUE / radix), then result * 10 will definitely be smaller
-			// than minValue, and we can stop.
-			if (result < stopValue) {
-				return null;
-			}
-
-			result = result * radix - digit;
-			// Since the previous result is less than or equal to
-			// stopValue(Long.MIN_VALUE / radix), we can just use `result > 0` to check overflow.
-			// If result overflows, we should stop.
-			if (result > 0) {
-				return null;
-			}
-		}
-
-		// This is the case when we've encountered a decimal separator. The fractional
-		// part will not change the number, but we will verify that the fractional part
-		// is well formed.
-		while (totalOffset < sizeInBytes) {
-			byte currentByte = segmentAndOffset.value();
-			if (currentByte < '0' || currentByte > '9') {
-				return null;
-			}
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-		}
-
-		if (!negative) {
-			result = -result;
-			if (result < 0) {
-				return null;
-			}
-		}
-		return result;
-	}
-
-	public Short toShort() {
-		Integer intValue = toInt();
-		if (intValue != null) {
-			short result = intValue.shortValue();
-			if (result == intValue) {
-				return result;
-			}
-		}
-		return null;
-	}
-
-	public Byte toByte() {
-		Integer intValue = toInt();
-		if (intValue != null) {
-			byte result = intValue.byteValue();
-			if (result == intValue) {
-				return result;
-			}
-		}
-		return null;
-	}
-
-	public Double toDouble() {
-		try {
-			return Double.valueOf(toString());
-		} catch (NumberFormatException e) {
-			return null;
-		}
-	}
-
-	public Float toFloat() {
-		try {
-			return Float.valueOf(toString());
-		} catch (NumberFormatException e) {
-			return null;
-		}
-	}
-
-	/**
-	 * Parses this BinaryString to Decimal.
-	 *
-	 * @return Decimal value if the parsing was successful, or null if overflow
-	 * @throws NumberFormatException if the parsing failed.
-	 */
-	public Decimal toDecimal(int precision, int scale) {
-		ensureMaterialized();
-		if (precision > Decimal.MAX_LONG_DIGITS || this.sizeInBytes > Decimal.MAX_LONG_DIGITS) {
-			return toDecimalSlow(precision, scale);
-		}
-
-		// Data in Decimal is stored by one long value if `precision` <= Decimal.MAX_LONG_DIGITS.
-		// In this case we can directly extract the value from memory segment.
-		int size = getSegments()[0].size();
-		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
-		int totalOffset = 0;
-
-		// Remove white spaces at the beginning
-		byte b = 0;
-		while (totalOffset < this.sizeInBytes) {
-			b = segmentAndOffset.value();
-			if (b != ' ' && b != '\n' && b != '\t') {
-				break;
-			}
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-		}
-		if (totalOffset == this.sizeInBytes) {
-			// all whitespaces
-			return null;
-		}
-
-		// ======= Significand part begin =======
-		final boolean negative = b == '-';
-		if (negative || b == '+') {
-			segmentAndOffset.nextByte(size);
-			totalOffset++;
-			if (totalOffset == this.sizeInBytes) {
-				// only contains prefix plus/minus
-				return null;
-			}
-		}
-
-		long significand = 0;
-		int exp = 0;
-		int significandLen = 0, pointPos = -1;
-
-		while (totalOffset < this.sizeInBytes) {
-			b = segmentAndOffset.value();
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-
-			if (b >= '0' && b <= '9') {
-				// No need to worry about overflow, because this.sizeInBytes <= Decimal.MAX_LONG_DIGITS
-				significand = significand * 10 + (b - '0');
-				significandLen++;
-			} else if (b == '.') {
-				if (pointPos >= 0) {
-					// More than one decimal point
-					return null;
-				}
-				pointPos = significandLen;
-			} else {
-				break;
-			}
-		}
-
-		if (pointPos < 0) {
-			pointPos = significandLen;
-		}
-		if (negative) {
-			significand = -significand;
-		}
-		// ======= Significand part end =======
-
-		// ======= Exponential part begin =======
-		if ((b == 'e' || b == 'E') && totalOffset < this.sizeInBytes) {
-			b = segmentAndOffset.value();
-			final boolean expNegative = b == '-';
-			if (expNegative || b == '+') {
-				segmentAndOffset.nextByte(size);
-				totalOffset++;
-				if (totalOffset == this.sizeInBytes) {
-					return null;
-				}
-			}
-
-			int expDigits = 0;
-			// As `precision` <= 18, value absolute range is limited to 10^-18 ~ 10^18.
-			// The worst case is <18-digits>E-36
-			final int expStopValue = 40;
-
-			while (totalOffset < this.sizeInBytes) {
-				b = segmentAndOffset.value();
-				totalOffset++;
-				segmentAndOffset.nextByte(size);
-
-				if (b >= '0' && b <= '9') {
-					// No need to worry about larger exponents,
-					// because they will produce overflow or underflow
-					if (expDigits < expStopValue) {
-						expDigits = expDigits * 10 + (b - '0');
-					}
-				} else {
-					break;
-				}
-			}
-
-			if (expNegative) {
-				expDigits = -expDigits;
-			}
-			exp += expDigits;
-		}
-		exp -= significandLen - pointPos;
-		// ======= Exponential part end =======
-
-		// Check for invalid character at the end
-		while (totalOffset < this.sizeInBytes) {
-			b = segmentAndOffset.value();
-			totalOffset++;
-			segmentAndOffset.nextByte(size);
-			// White spaces are allowed at the end
-			if (b != ' ' && b != '\n' && b != '\t') {
-				return null;
-			}
-		}
-
-		// Round exp to scale
-		int change = exp + scale;
-		if (significandLen + change > precision) {
-			// Overflow
-			return null;
-		}
-		if (change >= 0) {
-			significand *= Decimal.POW10[change];
-		} else {
-			int k = negative ? -5 : 5;
-			significand = (significand + k * Decimal.POW10[-change - 1]) / Decimal.POW10[-change];
-		}
-		return Decimal.fromLong(significand, precision, scale);
-	}
-
-	private Decimal toDecimalSlow(int precision, int scale) {
-		// As data in Decimal is currently stored by BigDecimal if `precision` > Decimal.MAX_LONG_DIGITS,
-		// and BigDecimal only supports String or char[] for its constructor,
-		// we can't directly extract the value from BinaryString.
-		//
-		// As BigDecimal(char[], int, int) is faster than BigDecimal(String, int, int),
-		// we extract char[] from the memory segment and pass it to the constructor of BigDecimal.
-		char[] chars = SegmentsUtil.allocateReuseChars(sizeInBytes);
-		int len;
-		if (segments.length == 1) {
-			len = StringUtf8Utils.decodeUTF8Strict(segments[0], offset, sizeInBytes, chars);
-		} else {
-			byte[] bytes = SegmentsUtil.allocateReuseBytes(sizeInBytes);
-			ensureMaterialized();
-			SegmentsUtil.copyToBytes(segments, offset, bytes, 0, sizeInBytes);
-			len = StringUtf8Utils.decodeUTF8Strict(bytes, 0, sizeInBytes, chars);
-		}
-
-		if (len < 0) {
-			return null;
-		} else {
-			// Trim white spaces
-			int start = 0, end = len;
-			for (int i = 0; i < len; i++) {
-				if (chars[i] != ' ' && chars[i] != '\n' && chars[i] != '\t') {
-					start = i;
-					break;
-				}
-			}
-			for (int i = len - 1; i >= 0; i--) {
-				if (chars[i] != ' ' && chars[i] != '\n' && chars[i] != '\t') {
-					end = i + 1;
-					break;
-				}
-			}
-			try {
-				BigDecimal bd = new BigDecimal(chars, start, end - start);
-				return Decimal.fromBigDecimal(bd, precision, scale);
-			} catch (NumberFormatException nfe) {
-				return null;
-			}
-		}
-	}
-
-	/**
-	 * Returns the upper case of this string.
-	 */
-	public BinaryString toUpperCase() {
-		if (javaObject != null) {
-			return toUpperCaseSlow();
-		}
-		if (sizeInBytes == 0) {
-			return EMPTY_UTF8;
-		}
-		int size = segments[0].size();
-		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
-		byte[] bytes = new byte[sizeInBytes];
-		bytes[0] = (byte) Character.toTitleCase(segmentAndOffset.value());
-		for (int i = 0; i < sizeInBytes; i++) {
-			byte b = segmentAndOffset.value();
-			if (numBytesForFirstByte(b) != 1) {
-				// fallback
-				return toUpperCaseSlow();
-			}
-			int upper = Character.toUpperCase((int) b);
-			if (upper > 127) {
-				// fallback
-				return toUpperCaseSlow();
-			}
-			bytes[i] = (byte) upper;
-			segmentAndOffset.nextByte(size);
-		}
-		return fromBytes(bytes);
-	}
-
-	private BinaryString toUpperCaseSlow() {
-		return fromString(toString().toUpperCase());
-	}
-
-	/**
-	 * Returns the lower case of this string.
-	 */
-	public BinaryString toLowerCase() {
-		if (javaObject != null) {
-			return toLowerCaseSlow();
-		}
-		if (sizeInBytes == 0) {
-			return EMPTY_UTF8;
-		}
-		int size = segments[0].size();
-		SegmentAndOffset segmentAndOffset = startSegmentAndOffset(size);
-		byte[] bytes = new byte[sizeInBytes];
-		bytes[0] = (byte) Character.toTitleCase(segmentAndOffset.value());
-		for (int i = 0; i < sizeInBytes; i++) {
-			byte b = segmentAndOffset.value();
-			if (numBytesForFirstByte(b) != 1) {
-				// fallback
-				return toLowerCaseSlow();
-			}
-			int lower = Character.toLowerCase((int) b);
-			if (lower > 127) {
-				// fallback
-				return toLowerCaseSlow();
-			}
-			bytes[i] = (byte) lower;
-			segmentAndOffset.nextByte(size);
-		}
-		return fromBytes(bytes);
-	}
-
-	private BinaryString toLowerCaseSlow() {
-		return fromString(toString().toLowerCase());
-	}
-
-	/**
-	 * <p>Splits the provided text into an array, separator string specified. </p>
-	 *
-	 * <p>The separator is not included in the returned String array.
-	 * Adjacent separators are treated as separators for empty tokens.</p>
-	 *
-	 * <p>A {@code null} separator splits on whitespace.</p>
-	 *
-	 * <pre>
-	 * "".splitByWholeSeparatorPreserveAllTokens(*)                 = []
-	 * "ab de fg".splitByWholeSeparatorPreserveAllTokens(null)      = ["ab", "de", "fg"]
-	 * "ab   de fg".splitByWholeSeparatorPreserveAllTokens(null)    = ["ab", "", "", "de", "fg"]
-	 * "ab:cd:ef".splitByWholeSeparatorPreserveAllTokens(":")       = ["ab", "cd", "ef"]
-	 * "ab-!-cd-!-ef".splitByWholeSeparatorPreserveAllTokens("-!-") = ["ab", "cd", "ef"]
-	 * </pre>
-	 *
-	 * <p>Note: return BinaryStrings is reuse MemorySegments from this.</p>
-	 *
-	 * @param separator  String containing the String to be used as a delimiter,
-	 *  {@code null} splits on whitespace
-	 * @return an array of parsed Strings, {@code null} if null String was input
-	 * @since 2.4
-	 */
-	public BinaryString[] splitByWholeSeparatorPreserveAllTokens(BinaryString separator) {
-		ensureMaterialized();
-		final int len = sizeInBytes;
-
-		if (len == 0) {
-			return EMPTY_STRING_ARRAY;
-		}
-
-		if (separator == null || EMPTY_UTF8.equals(separator)) {
-			// Split on whitespace.
-			return splitByWholeSeparatorPreserveAllTokens(fromString(" "));
-		}
-		separator.ensureMaterialized();
-
-		final int separatorLength = separator.sizeInBytes;
-
-		final ArrayList<BinaryString> substrings = new ArrayList<>();
-		int beg = 0;
-		int end = 0;
-		while (end < len) {
-			end = SegmentsUtil.find(
-				segments, offset + beg, sizeInBytes - beg,
-				separator.segments, separator.offset, separator.sizeInBytes) - offset;
-
-			if (end > -1) {
-				if (end > beg) {
-
-					// The following is OK, because String.substring( beg, end ) excludes
-					// the character at the position 'end'.
-					substrings.add(BinaryString.fromAddress(segments, offset + beg, end - beg));
-
-					// Set the starting point for the next search.
-					// The following is equivalent to beg = end + (separatorLength - 1) + 1,
-					// which is the right calculation:
-					beg = end + separatorLength;
-				} else {
-					// We found a consecutive occurrence of the separator.
-					substrings.add(EMPTY_UTF8);
-					beg = end + separatorLength;
-				}
-			} else {
-				// String.substring( beg ) goes from 'beg' to the end of the String.
-				substrings.add(BinaryString.fromAddress(segments, offset + beg, sizeInBytes - beg));
-				end = len;
-			}
-		}
-
-		return substrings.toArray(new BinaryString[0]);
-	}
-
-	/**
-	 * Calculate the hash value of a given string use {@link MessageDigest}.
-	 */
-	public BinaryString hash(MessageDigest md) {
-		String str = EncodingUtils.hex(md.digest(getBytes()));
-		return fromString(str);
-	}
-
-	public BinaryString hash(String algorithm) throws NoSuchAlgorithmException {
-		return hash(MessageDigest.getInstance(algorithm));
-	}
-
-	private static final List<BinaryString> TRUE_STRINGS =
-		Stream
-			.of("t", "true", "y", "yes", "1")
-			.map(BinaryString::fromString)
-			.peek(BinaryString::ensureMaterialized)
-			.collect(Collectors.toList());
-
-	private static final List<BinaryString> FALSE_STRINGS =
-		Stream
-			.of("f", "false", "n", "no", "0")
-			.map(BinaryString::fromString)
-			.peek(BinaryString::ensureMaterialized)
-			.collect(Collectors.toList());
-
-	/**
-	 * Decide boolean representation of a string.
+	 * Returns the number of bytes for a code point with the first byte as `b`.
+	 * @param b The first byte of a code point
 	 */
-	public Boolean toBooleanSQL() {
-		if (TRUE_STRINGS.contains(toLowerCase())) {
-			return true;
-		} else if (FALSE_STRINGS.contains(toLowerCase())) {
-			return false;
+	static int numBytesForFirstByte(final byte b) {
+		if (b >= 0) {
+			// 1 byte, 7 bits: 0xxxxxxx
+			return 1;
+		} else if ((b >> 5) == -2 && (b & 0x1e) != 0) {
+			// 2 bytes, 11 bits: 110xxxxx 10xxxxxx
+			return 2;
+		} else if ((b >> 4) == -2) {
+			// 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
+			return 3;
+		} else if ((b >> 3) == -2) {
+			// 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
+			return 4;
 		} else {
-			return null;
+			// Skip the first byte disallowed in UTF-8
+			// Handling errors quietly, same semantics to java String.
+			return 1;
 		}
 	}
-
 }
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryStringUtil.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryStringUtil.java
new file mode 100644
index 00000000000..b6525f2cab4
--- /dev/null
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/BinaryStringUtil.java
@@ -0,0 +1,1132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.	See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.	You may obtain a copy of the License at
+ *
+ *		http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.dataformat;
+
+import org.apache.flink.core.memory.MemorySegment;
+import org.apache.flink.table.runtime.util.StringUtf8Utils;
+import org.apache.flink.table.util.SegmentsUtil;
+import org.apache.flink.table.utils.EncodingUtils;
+
+import java.math.BigDecimal;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static org.apache.flink.table.dataformat.BinaryString.EMPTY_UTF8;
+import static org.apache.flink.table.dataformat.BinaryString.fromAddress;
+import static org.apache.flink.table.dataformat.BinaryString.fromBytes;
+import static org.apache.flink.table.dataformat.BinaryString.fromString;
+import static org.apache.flink.table.dataformat.BinaryString.numBytesForFirstByte;
+
+/**
+ * Util for {@link BinaryString}.
+ */
+public class BinaryStringUtil {
+
+	public static final BinaryString[] EMPTY_STRING_ARRAY = new BinaryString[0];
+	private static final List<BinaryString> TRUE_STRINGS =
+			Stream.of("t", "true", "y", "yes", "1")
+					.map(BinaryString::fromString)
+					.peek(BinaryString::ensureMaterialized)
+					.collect(Collectors.toList());
+
+	private static final List<BinaryString> FALSE_STRINGS =
+			Stream.of("f", "false", "n", "no", "0")
+					.map(BinaryString::fromString)
+					.peek(BinaryString::ensureMaterialized)
+					.collect(Collectors.toList());
+
+	private static byte[] getTmpBytes(BinaryString str, int sizeInBytes) {
+		byte[] bytes = SegmentsUtil.allocateReuseBytes(sizeInBytes);
+		SegmentsUtil.copyToBytes(str.getSegments(), str.getOffset(), bytes, 0, sizeInBytes);
+		return bytes;
+	}
+
+	/**
+	 * <p>Splits the provided text into an array, separator string specified. </p>
+	 *
+	 * <p>The separator is not included in the returned String array.
+	 * Adjacent separators are treated as separators for empty tokens.</p>
+	 *
+	 * <p>A {@code null} separator splits on whitespace.</p>
+	 *
+	 * <pre>
+	 * "".splitByWholeSeparatorPreserveAllTokens(*)                 = []
+	 * "ab de fg".splitByWholeSeparatorPreserveAllTokens(null)      = ["ab", "de", "fg"]
+	 * "ab   de fg".splitByWholeSeparatorPreserveAllTokens(null)    = ["ab", "", "", "de", "fg"]
+	 * "ab:cd:ef".splitByWholeSeparatorPreserveAllTokens(":")       = ["ab", "cd", "ef"]
+	 * "ab-!-cd-!-ef".splitByWholeSeparatorPreserveAllTokens("-!-") = ["ab", "cd", "ef"]
+	 * </pre>
+	 *
+	 * <p>Note: returned binary strings reuse memory segments from the input str.</p>
+	 *
+	 * @param separator  String containing the String to be used as a delimiter,
+	 *  {@code null} splits on whitespace
+	 * @return an array of parsed Strings, {@code null} if null String was input
+	 */
+	public static BinaryString[] splitByWholeSeparatorPreserveAllTokens(BinaryString str, BinaryString separator) {
+		str.ensureMaterialized();
+		final int sizeInBytes = str.getSizeInBytes();
+		MemorySegment[] segments = str.getSegments();
+		int offset = str.getOffset();
+
+		if (sizeInBytes == 0) {
+			return EMPTY_STRING_ARRAY;
+		}
+
+		if (separator == null || EMPTY_UTF8.equals(separator)) {
+			// Split on whitespace.
+			return splitByWholeSeparatorPreserveAllTokens(str, fromString(" "));
+		}
+		separator.ensureMaterialized();
+
+		int sepSize = separator.getSizeInBytes();
+		MemorySegment[] sepSegs = separator.getSegments();
+		int sepOffset = separator.getOffset();
+
+		final ArrayList<BinaryString> substrings = new ArrayList<>();
+		int beg = 0;
+		int end = 0;
+		while (end < sizeInBytes) {
+			end = SegmentsUtil.find(
+					segments, offset + beg, sizeInBytes - beg,
+					sepSegs, sepOffset, sepSize) - offset;
+
+			if (end > -1) {
+				if (end > beg) {
+
+					// The following is OK, because String.substring( beg, end ) excludes
+					// the character at the position 'end'.
+					substrings.add(fromAddress(segments, offset + beg, end - beg));
+
+					// Set the starting point for the next search.
+					// The following is equivalent to beg = end + (separatorLength - 1) + 1,
+					// which is the right calculation:
+					beg = end + sepSize;
+				} else {
+					// We found a consecutive occurrence of the separator.
+					substrings.add(EMPTY_UTF8);
+					beg = end + sepSize;
+				}
+			} else {
+				// String.substring( beg ) goes from 'beg' to the end of the String.
+				substrings.add(fromAddress(segments, offset + beg, sizeInBytes - beg));
+				end = sizeInBytes;
+			}
+		}
+
+		return substrings.toArray(new BinaryString[0]);
+	}
+
+	/**
+	 * Decide boolean representation of a string.
+	 */
+	public static Boolean toBooleanSQL(BinaryString str) {
+		BinaryString lowerCase = str.toLowerCase();
+		return TRUE_STRINGS.contains(lowerCase) ? Boolean.TRUE :
+				(FALSE_STRINGS.contains(lowerCase) ? Boolean.FALSE : null);
+	}
+
+	/**
+	 * Calculate the hash value of a given string use {@link MessageDigest}.
+	 */
+	public static BinaryString hash(BinaryString str, MessageDigest md) {
+		return fromString(EncodingUtils.hex(md.digest(str.getBytes())));
+	}
+
+	public static BinaryString hash(BinaryString str, String algorithm) throws NoSuchAlgorithmException {
+		return hash(str, MessageDigest.getInstance(algorithm));
+	}
+
+	/**
+	 * Parses this BinaryString to Decimal.
+	 *
+	 * @return Decimal value if the parsing was successful, or null if overflow
+	 * @throws NumberFormatException if the parsing failed.
+	 */
+	public static Decimal toDecimal(BinaryString str, int precision, int scale) {
+		str.ensureMaterialized();
+
+		if (precision > Decimal.MAX_LONG_DIGITS || str.getSizeInBytes() > Decimal.MAX_LONG_DIGITS) {
+			return toBigPrecisionDecimal(str, precision, scale);
+		}
+
+		int sizeInBytes = str.getSizeInBytes();
+		return toDecimalFromBytes(precision, scale, getTmpBytes(str, sizeInBytes), 0, sizeInBytes);
+	}
+
+	private static Decimal toDecimalFromBytes(
+			int precision, int scale, byte[] bytes, int offset, int sizeInBytes) {
+		// Data in Decimal is stored by one long value if `precision` <= Decimal.MAX_LONG_DIGITS.
+		// In this case we can directly extract the value from memory segment.
+		int i = 0;
+
+		// Remove white spaces at the beginning
+		byte b = 0;
+		while (i < sizeInBytes) {
+			b = bytes[offset + i];
+			if (b != ' ' && b != '\n' && b != '\t') {
+				break;
+			}
+			i++;
+		}
+		if (i == sizeInBytes) {
+			// all whitespaces
+			return null;
+		}
+
+		// ======= begin significant part =======
+		final boolean negative = b == '-';
+		if (negative || b == '+') {
+			i++;
+			if (i == sizeInBytes) {
+				// only contains prefix plus/minus
+				return null;
+			}
+		}
+
+		long significand = 0;
+		int exp = 0;
+		int significandLen = 0, pointPos = -1;
+
+		while (i < sizeInBytes) {
+			b = bytes[offset + i];
+			i++;
+
+			if (b >= '0' && b <= '9') {
+				// No need to worry about overflow, because sizeInBytes <= Decimal.MAX_LONG_DIGITS
+				significand = significand * 10 + (b - '0');
+				significandLen++;
+			} else if (b == '.') {
+				if (pointPos >= 0) {
+					// More than one decimal point
+					return null;
+				}
+				pointPos = significandLen;
+			} else {
+				break;
+			}
+		}
+
+		if (pointPos < 0) {
+			pointPos = significandLen;
+		}
+		if (negative) {
+			significand = -significand;
+		}
+		// ======= end significand part =======
+
+		// ======= begin exponential part =======
+		if ((b == 'e' || b == 'E') && i < sizeInBytes) {
+			b = bytes[offset + i];
+			final boolean expNegative = b == '-';
+			if (expNegative || b == '+') {
+				i++;
+				if (i == sizeInBytes) {
+					return null;
+				}
+			}
+
+			int expDigits = 0;
+			// As `precision` <= 18, value absolute range is limited to 10^-18 ~ 10^18.
+			// The worst case is <18-digits>E-36
+			final int expStopValue = 40;
+
+			while (i < sizeInBytes) {
+				b = bytes[offset + i];
+				i++;
+
+				if (b >= '0' && b <= '9') {
+					// No need to worry about larger exponents,
+					// because they will produce overflow or underflow
+					if (expDigits < expStopValue) {
+						expDigits = expDigits * 10 + (b - '0');
+					}
+				} else {
+					break;
+				}
+			}
+
+			if (expNegative) {
+				expDigits = -expDigits;
+			}
+			exp += expDigits;
+		}
+		exp -= significandLen - pointPos;
+		// ======= end exponential part =======
+
+		// Check for invalid character at the end
+		while (i < sizeInBytes) {
+			b = bytes[offset + i];
+			i++;
+			// White spaces are allowed at the end
+			if (b != ' ' && b != '\n' && b != '\t') {
+				return null;
+			}
+		}
+
+		// Round exp to scale
+		int change = exp + scale;
+		if (significandLen + change > precision) {
+			// Overflow
+			return null;
+		}
+		if (change >= 0) {
+			significand *= Decimal.POW10[change];
+		} else {
+			int k = negative ? -5 : 5;
+			significand = (significand + k * Decimal.POW10[-change - 1]) / Decimal.POW10[-change];
+		}
+		return Decimal.fromLong(significand, precision, scale);
+	}
+
+	private static Decimal toBigPrecisionDecimal(BinaryString str, int precision, int scale) {
+		// As data in Decimal is currently stored by BigDecimal if `precision` > Decimal.MAX_LONG_DIGITS,
+		// and BigDecimal only supports String or char[] for its constructor,
+		// we can't directly extract the value from BinaryString.
+		//
+		// As BigDecimal(char[], int, int) is faster than BigDecimal(String, int, int),
+		// we extract char[] from the memory segment and pass it to the constructor of BigDecimal.
+		int sizeInBytes = str.getSizeInBytes();
+		int offset = str.getOffset();
+		MemorySegment[] segments = str.getSegments();
+		char[] chars = SegmentsUtil.allocateReuseChars(sizeInBytes);
+		int len;
+		if (segments.length == 1) {
+			len = StringUtf8Utils.decodeUTF8Strict(segments[0], offset, sizeInBytes, chars);
+		} else {
+			byte[] bytes = SegmentsUtil.allocateReuseBytes(sizeInBytes);
+			SegmentsUtil.copyToBytes(segments, offset, bytes, 0, sizeInBytes);
+			len = StringUtf8Utils.decodeUTF8Strict(bytes, 0, sizeInBytes, chars);
+		}
+
+		if (len < 0) {
+			return null;
+		} else {
+			// Trim white spaces
+			int start = 0, end = len;
+			for (int i = 0; i < len; i++) {
+				if (chars[i] != ' ' && chars[i] != '\n' && chars[i] != '\t') {
+					start = i;
+					break;
+				}
+			}
+			for (int i = len - 1; i >= 0; i--) {
+				if (chars[i] != ' ' && chars[i] != '\n' && chars[i] != '\t') {
+					end = i + 1;
+					break;
+				}
+			}
+			try {
+				BigDecimal bd = new BigDecimal(chars, start, end - start);
+				return Decimal.fromBigDecimal(bd, precision, scale);
+			} catch (NumberFormatException nfe) {
+				return null;
+			}
+		}
+	}
+
+	/**
+	 * Parses this BinaryString to Long.
+	 *
+	 * <p>Note that, in this method we accumulate the result in negative format, and convert it to
+	 * positive format at the end, if this string is not started with '-'. This is because min value
+	 * is bigger than max value in digits, e.g. Long.MAX_VALUE is '9223372036854775807' and
+	 * Long.MIN_VALUE is '-9223372036854775808'.
+	 *
+	 * <p>This code is mostly copied from LazyLong.parseLong in Hive.
+	 * @return Long value if the parsing was successful else null.
+	 */
+	public static Long toLong(BinaryString str) {
+		int sizeInBytes = str.getSizeInBytes();
+		byte[] tmpBytes = getTmpBytes(str, sizeInBytes);
+		if (sizeInBytes == 0) {
+			return null;
+		}
+		int i = 0;
+
+		byte b = tmpBytes[i];
+		final boolean negative = b == '-';
+		if (negative || b == '+') {
+			i++;
+			if (sizeInBytes == 1) {
+				return null;
+			}
+		}
+
+		long result = 0;
+		final byte separator = '.';
+		final int radix = 10;
+		final long stopValue = Long.MIN_VALUE / radix;
+		while (i < sizeInBytes) {
+			b = tmpBytes[i];
+			i++;
+			if (b == separator) {
+				// We allow decimals and will return a truncated integral in that case.
+				// Therefore we won't throw an exception here (checking the fractional
+				// part happens below.)
+				break;
+			}
+
+			int digit;
+			if (b >= '0' && b <= '9') {
+				digit = b - '0';
+			} else {
+				return null;
+			}
+
+			// We are going to process the new digit and accumulate the result. However, before
+			// doing this, if the result is already smaller than the
+			// stopValue(Long.MIN_VALUE / radix), then result * 10 will definitely be smaller
+			// than minValue, and we can stop.
+			if (result < stopValue) {
+				return null;
+			}
+
+			result = result * radix - digit;
+			// Since the previous result is less than or equal to
+			// stopValue(Long.MIN_VALUE / radix), we can just use `result > 0` to check overflow.
+			// If result overflows, we should stop.
+			if (result > 0) {
+				return null;
+			}
+		}
+
+		// This is the case when we've encountered a decimal separator. The fractional
+		// part will not change the number, but we will verify that the fractional part
+		// is well formed.
+		while (i < sizeInBytes) {
+			byte currentByte = tmpBytes[i];
+			if (currentByte < '0' || currentByte > '9') {
+				return null;
+			}
+			i++;
+		}
+
+		if (!negative) {
+			result = -result;
+			if (result < 0) {
+				return null;
+			}
+		}
+		return result;
+	}
+
+	/**
+	 * Parses this BinaryString to Int.
+	 *
+	 * <p>Note that, in this method we accumulate the result in negative format, and convert it to
+	 * positive format at the end, if this string is not started with '-'. This is because min value
+	 * is bigger than max value in digits, e.g. Integer.MAX_VALUE is '2147483647' and
+	 * Integer.MIN_VALUE is '-2147483648'.
+	 *
+	 * <p>This code is mostly copied from LazyInt.parseInt in Hive.
+	 *
+	 * <p>Note that, this method is almost same as `toLong`, but we leave it duplicated for performance
+	 * reasons, like Hive does.
+	 * @return Integer value if the parsing was successful else null.
+	 */
+	public static Integer toInt(BinaryString str) {
+		int sizeInBytes = str.getSizeInBytes();
+		byte[] tmpBytes = getTmpBytes(str, sizeInBytes);
+		if (sizeInBytes == 0) {
+			return null;
+		}
+		int i = 0;
+
+		byte b = tmpBytes[i];
+		final boolean negative = b == '-';
+		if (negative || b == '+') {
+			i++;
+			if (sizeInBytes == 1) {
+				return null;
+			}
+		}
+
+		int result = 0;
+		final byte separator = '.';
+		final int radix = 10;
+		final long stopValue = Integer.MIN_VALUE / radix;
+		while (i < sizeInBytes) {
+			b = tmpBytes[i];
+			i++;
+			if (b == separator) {
+				// We allow decimals and will return a truncated integral in that case.
+				// Therefore we won't throw an exception here (checking the fractional
+				// part happens below.)
+				break;
+			}
+
+			int digit;
+			if (b >= '0' && b <= '9') {
+				digit = b - '0';
+			} else {
+				return null;
+			}
+
+			// We are going to process the new digit and accumulate the result. However, before
+			// doing this, if the result is already smaller than the
+			// stopValue(Long.MIN_VALUE / radix), then result * 10 will definitely be smaller
+			// than minValue, and we can stop.
+			if (result < stopValue) {
+				return null;
+			}
+
+			result = result * radix - digit;
+			// Since the previous result is less than or equal to
+			// stopValue(Long.MIN_VALUE / radix), we can just use `result > 0` to check overflow.
+			// If result overflows, we should stop.
+			if (result > 0) {
+				return null;
+			}
+		}
+
+		// This is the case when we've encountered a decimal separator. The fractional
+		// part will not change the number, but we will verify that the fractional part
+		// is well formed.
+		while (i < sizeInBytes) {
+			byte currentByte = tmpBytes[i];
+			if (currentByte < '0' || currentByte > '9') {
+				return null;
+			}
+			i++;
+		}
+
+		if (!negative) {
+			result = -result;
+			if (result < 0) {
+				return null;
+			}
+		}
+		return result;
+	}
+
+	public static Short toShort(BinaryString str) {
+		Integer intValue = toInt(str);
+		if (intValue != null) {
+			short result = intValue.shortValue();
+			if (result == intValue) {
+				return result;
+			}
+		}
+		return null;
+	}
+
+	public static Byte toByte(BinaryString str) {
+		Integer intValue = toInt(str);
+		if (intValue != null) {
+			byte result = intValue.byteValue();
+			if (result == intValue) {
+				return result;
+			}
+		}
+		return null;
+	}
+
+	public static Double toDouble(BinaryString str) {
+		try {
+			return Double.valueOf(str.toString());
+		} catch (NumberFormatException e) {
+			return null;
+		}
+	}
+
+	public static Float toFloat(BinaryString str) {
+		try {
+			return Float.valueOf(str.toString());
+		} catch (NumberFormatException e) {
+			return null;
+		}
+	}
+
+	/**
+	 * Parse target string as key-value string and
+	 * return the value matches key name.
+	 * If accept any null arguments, return null.
+	 * example:
+	 * keyvalue('k1=v1;k2=v2', ';', '=', 'k2') = 'v2'
+	 * keyvalue('k1:v1,k2:v2', ',', ':', 'k3') = NULL
+	 *
+	 * @param split1  separator between key-value tuple.
+	 * @param split2  separator between key and value.
+	 * @param keyName name of the key whose value you want return.
+	 *
+	 * @return target value.
+	 */
+	public static BinaryString keyValue(BinaryString str, byte split1, byte split2, BinaryString keyName) {
+		str.ensureMaterialized();
+		if (keyName == null || keyName.getSizeInBytes() == 0) {
+			return null;
+		}
+		if (str.inFirstSegment() && keyName.inFirstSegment()) {
+			// position in byte
+			int byteIdx = 0;
+			// position of last split1
+			int lastSplit1Idx = -1;
+			while (byteIdx < str.sizeInBytes) {
+				// If find next split1 in str, process current kv
+				if (str.segments[0].get(str.offset + byteIdx) == split1) {
+					int currentKeyIdx = lastSplit1Idx + 1;
+					// If key of current kv is keyName, return the value directly
+					BinaryString value = findValueOfKey(str, split2, keyName, currentKeyIdx, byteIdx);
+					if (value != null) {
+						return value;
+					}
+					lastSplit1Idx = byteIdx;
+				}
+				byteIdx++;
+			}
+			// process the string which is not ends with split1
+			int currentKeyIdx = lastSplit1Idx + 1;
+			return findValueOfKey(str, split2, keyName, currentKeyIdx, str.sizeInBytes);
+		} else {
+			return keyValueSlow(str, split1, split2, keyName);
+		}
+	}
+
+	private static BinaryString findValueOfKey(
+			BinaryString str,
+			byte split,
+			BinaryString keyName,
+			int start,
+			int end) {
+		int keyNameLen = keyName.sizeInBytes;
+		for (int idx = start; idx < end; idx++) {
+			if (str.segments[0].get(str.offset + idx) == split) {
+				if (idx == start + keyNameLen &&
+						str.segments[0].equalTo(keyName.segments[0], str.offset + start,
+								keyName.offset, keyNameLen)) {
+					int valueIdx = idx + 1;
+					int valueLen = end - valueIdx;
+					byte[] bytes = new byte[valueLen];
+					str.segments[0].get(str.offset + valueIdx, bytes, 0, valueLen);
+					return fromBytes(bytes, 0, valueLen);
+				} else {
+					return null;
+				}
+			}
+		}
+		return null;
+	}
+
+	private static BinaryString keyValueSlow(
+			BinaryString str,
+			byte split1,
+			byte split2,
+			BinaryString keyName) {
+		// position in byte
+		int byteIdx = 0;
+		// position of last split1
+		int lastSplit1Idx = -1;
+		while (byteIdx < str.sizeInBytes) {
+			// If find next split1 in str, process current kv
+			if (str.byteAt(byteIdx) == split1) {
+				int currentKeyIdx = lastSplit1Idx + 1;
+				BinaryString value = findValueOfKeySlow(str, split2, keyName, currentKeyIdx, byteIdx);
+				if (value != null) {
+					return value;
+				}
+				lastSplit1Idx = byteIdx;
+			}
+			byteIdx++;
+		}
+		int currentKeyIdx = lastSplit1Idx + 1;
+		return findValueOfKeySlow(str, split2, keyName, currentKeyIdx, str.sizeInBytes);
+	}
+
+	private static BinaryString findValueOfKeySlow(
+			BinaryString str,
+			byte split,
+			BinaryString keyName,
+			int start,
+			int end) {
+		int keyNameLen = keyName.sizeInBytes;
+		for (int idx = start; idx < end; idx++) {
+			if (str.byteAt(idx) == split) {
+				if (idx == start + keyNameLen &&
+						SegmentsUtil.equals(str.segments, str.offset + start, keyName.segments,
+								keyName.offset, keyNameLen)) {
+					int valueIdx = idx + 1;
+					byte[] bytes = SegmentsUtil.copyToBytes(str.segments, str.offset + valueIdx, end - valueIdx);
+					return fromBytes(bytes);
+				} else {
+					return null;
+				}
+			}
+		}
+		return null;
+	}
+
+	public static BinaryString substringSQL(BinaryString str, int pos) {
+		return substringSQL(str, pos, Integer.MAX_VALUE);
+	}
+
+	public static BinaryString substringSQL(BinaryString str, int pos, int length) {
+		if (length < 0) {
+			return null;
+		}
+		str.ensureMaterialized();
+		if (str.equals(EMPTY_UTF8)) {
+			return EMPTY_UTF8;
+		}
+
+		int start;
+		int end;
+		int numChars = str.numChars();
+
+		if (pos > 0) {
+			start = pos - 1;
+			if (start >= numChars) {
+				return EMPTY_UTF8;
+			}
+		} else if (pos < 0) {
+			start = numChars + pos;
+			if (start < 0) {
+				return EMPTY_UTF8;
+			}
+		} else {
+			start = 0;
+		}
+
+		if ((numChars - start) < length) {
+			end = numChars;
+		} else {
+			end = start + length;
+		}
+		return str.substring(start, end);
+	}
+
+	/**
+	 * Concatenates input strings together into a single string.
+	 */
+	public static BinaryString concat(BinaryString... inputs) {
+		return concat(Arrays.asList(inputs));
+	}
+
+	/**
+	 * Concatenates input strings together into a single string.
+	 */
+	public static BinaryString concat(Iterable<BinaryString> inputs) {
+		// Compute the total length of the result.
+		int totalLength = 0;
+		for (BinaryString input : inputs) {
+			if (input != null) {
+				input.ensureMaterialized();
+				totalLength += input.getSizeInBytes();
+			}
+		}
+
+		// Allocate a new byte array, and copy the inputs one by one into it.
+		final byte[] result = new byte[totalLength];
+		int offset = 0;
+		for (BinaryString input : inputs) {
+			if (input != null) {
+				int len = input.sizeInBytes;
+				SegmentsUtil.copyToBytes(input.segments, input.offset, result, offset, len);
+				offset += len;
+			}
+		}
+		return fromBytes(result);
+	}
+
+	/**
+	 * Concatenates input strings together into a single string using the separator.
+	 * A null input is skipped. For example, concat(",", "a", null, "c") would yield "a,c".
+	 */
+	public static BinaryString concatWs(BinaryString separator, BinaryString... inputs) {
+		return concatWs(separator, Arrays.asList(inputs));
+	}
+
+	/**
+	 * Concatenates input strings together into a single string using the separator.
+	 * A null input is skipped. For example, concat(",", "a", null, "c") would yield "a,c".
+	 */
+	public static BinaryString concatWs(BinaryString separator, Iterable<BinaryString> inputs) {
+		if (null == separator || EMPTY_UTF8.equals(separator)) {
+			return concat(inputs);
+		}
+		separator.ensureMaterialized();
+
+		int numInputBytes = 0;  // total number of bytes from the inputs
+		int numInputs = 0;      // number of non-null inputs
+		for (BinaryString input : inputs) {
+			if (input != null) {
+				input.ensureMaterialized();
+				numInputBytes += input.sizeInBytes;
+				numInputs++;
+			}
+		}
+
+		if (numInputs == 0) {
+			// Return an empty string if there is no input, or all the inputs are null.
+			return EMPTY_UTF8;
+		}
+
+		// Allocate a new byte array, and copy the inputs one by one into it.
+		// The size of the new array is the size of all inputs, plus the separators.
+		final byte[] result = new byte[numInputBytes + (numInputs - 1) * separator.sizeInBytes];
+		int offset = 0;
+
+		int j = 0;
+		for (BinaryString input : inputs) {
+			if (input != null) {
+				int len = input.sizeInBytes;
+				SegmentsUtil.copyToBytes(input.segments, input.offset, result, offset, len);
+				offset += len;
+
+				j++;
+				// Add separator if this is not the last input.
+				if (j < numInputs) {
+					SegmentsUtil.copyToBytes(separator.segments, separator.offset, result, offset, separator.sizeInBytes);
+					offset += separator.sizeInBytes;
+				}
+			}
+		}
+		return fromBytes(result);
+	}
+
+	/**
+	 * Reverse each character in current string.
+	 *
+	 * @return a new string which character order is reverse to current string.
+	 */
+	public static BinaryString reverse(BinaryString str) {
+		str.ensureMaterialized();
+		if (str.inFirstSegment()) {
+			byte[] result = new byte[str.sizeInBytes];
+			// position in byte
+			int byteIdx = 0;
+			while (byteIdx < str.sizeInBytes) {
+				int charBytes = numBytesForFirstByte(str.getByteOneSegment(byteIdx));
+				str.segments[0].get(
+						str.offset + byteIdx,
+						result,
+						result.length - byteIdx - charBytes,
+						charBytes);
+				byteIdx += charBytes;
+			}
+			return BinaryString.fromBytes(result);
+		} else {
+			return reverseMultiSegs(str);
+		}
+	}
+
+	private static BinaryString reverseMultiSegs(BinaryString str) {
+		byte[] result = new byte[str.sizeInBytes];
+		// position in byte
+		int byteIdx = 0;
+		int segSize = str.segments[0].size();
+		BinaryString.SegmentAndOffset index = str.firstSegmentAndOffset(segSize);
+		while (byteIdx <  str.sizeInBytes) {
+			int charBytes = numBytesForFirstByte(index.value());
+			SegmentsUtil.copyMultiSegmentsToBytes(
+					str.segments,
+					str.offset + byteIdx,
+					result,
+					result.length - byteIdx - charBytes,
+					charBytes);
+			byteIdx += charBytes;
+			index.skipBytes(charBytes, segSize);
+		}
+		return BinaryString.fromBytes(result);
+	}
+
+	/**
+	 * Walk each character of current string from both ends, remove the character if it
+	 * is in trim string.
+	 * Return the new substring which both ends trim characters have been removed.
+	 *
+	 * @param trimStr the trim string
+	 * @return A subString which both ends trim characters have been removed.
+	 */
+	public static BinaryString trim(BinaryString str, BinaryString trimStr) {
+		if (trimStr == null) {
+			return null;
+		}
+		return trimRight(trimLeft(str, trimStr), trimStr);
+	}
+
+	public static BinaryString trimLeft(BinaryString str) {
+		str.ensureMaterialized();
+		if (str.inFirstSegment()) {
+			int s = 0;
+			// skip all of the space (0x20) in the left side
+			while (s < str.sizeInBytes && str.getByteOneSegment(s) == 0x20) {
+				s++;
+			}
+			if (s == str.sizeInBytes) {
+				// empty string
+				return EMPTY_UTF8;
+			} else {
+				return str.copyBinaryStringInOneSeg(s, str.sizeInBytes - s);
+			}
+		} else {
+			return trimLeftSlow(str);
+		}
+	}
+
+	private static BinaryString trimLeftSlow(BinaryString str) {
+		int s = 0;
+		int segSize = str.segments[0].size();
+		BinaryString.SegmentAndOffset front = str.firstSegmentAndOffset(segSize);
+		// skip all of the space (0x20) in the left side
+		while (s < str.sizeInBytes && front.value() == 0x20) {
+			s++;
+			front.nextByte(segSize);
+		}
+		if (s == str.sizeInBytes) {
+			// empty string
+			return EMPTY_UTF8;
+		} else {
+			return str.copyBinaryString(s, str.sizeInBytes - 1);
+		}
+	}
+
+	public static boolean isSpaceString(BinaryString str) {
+		if (str.javaObject != null) {
+			return str.javaObject.equals(" ");
+		} else {
+			return str.byteAt(0) == ' ';
+		}
+	}
+
+	/**
+	 * Walk each character of current string from left end, remove the character if it
+	 * is in trim string. Stops at the first character which is not in trim string.
+	 * Return the new substring.
+	 *
+	 * @param trimStr the trim string
+	 * @return A subString which removes all of the character from the left side that is in
+	 * trim string.
+	 */
+	public static BinaryString trimLeft(BinaryString str, BinaryString trimStr) {
+		str.ensureMaterialized();
+		if (trimStr == null) {
+			return null;
+		}
+		trimStr.ensureMaterialized();
+		if (isSpaceString(trimStr)) {
+			return trimLeft(str);
+		}
+		if (str.inFirstSegment()) {
+			int searchIdx = 0;
+			while (searchIdx < str.sizeInBytes) {
+				int charBytes = numBytesForFirstByte(str.getByteOneSegment(searchIdx));
+				BinaryString currentChar = str.copyBinaryStringInOneSeg(searchIdx, charBytes);
+				// try to find the matching for the character in the trimString characters.
+				if (trimStr.contains(currentChar)) {
+					searchIdx += charBytes;
+				} else {
+					break;
+				}
+			}
+			// empty string
+			if (searchIdx >= str.sizeInBytes) {
+				return EMPTY_UTF8;
+			} else {
+				return str.copyBinaryStringInOneSeg(searchIdx, str.sizeInBytes - searchIdx);
+			}
+		} else {
+			return trimLeftSlow(str, trimStr);
+		}
+	}
+
+	private static BinaryString trimLeftSlow(BinaryString str, BinaryString trimStr) {
+		int searchIdx = 0;
+		int segSize = str.segments[0].size();
+		BinaryString.SegmentAndOffset front = str.firstSegmentAndOffset(segSize);
+		while (searchIdx < str.sizeInBytes) {
+			int charBytes = numBytesForFirstByte(front.value());
+			BinaryString currentChar = str.copyBinaryString(searchIdx, searchIdx + charBytes - 1);
+			if (trimStr.contains(currentChar)) {
+				searchIdx += charBytes;
+				front.skipBytes(charBytes, segSize);
+			} else {
+				break;
+			}
+		}
+		if (searchIdx == str.sizeInBytes) {
+			// empty string
+			return EMPTY_UTF8;
+		} else {
+			return str.copyBinaryString(searchIdx, str.sizeInBytes - 1);
+		}
+	}
+
+	public static BinaryString trimRight(BinaryString str) {
+		str.ensureMaterialized();
+		if (str.inFirstSegment()) {
+			int e = str.sizeInBytes - 1;
+			// skip all of the space (0x20) in the right side
+			while (e >= 0 && str.getByteOneSegment(e) == 0x20) {
+				e--;
+			}
+
+			if (e < 0) {
+				// empty string
+				return EMPTY_UTF8;
+			} else {
+				return str.copyBinaryStringInOneSeg(0, e + 1);
+			}
+		} else {
+			return trimRightSlow(str);
+		}
+	}
+
+	private static BinaryString trimRightSlow(BinaryString str) {
+		int e = str.sizeInBytes - 1;
+		int segSize = str.segments[0].size();
+		BinaryString.SegmentAndOffset behind = str.lastSegmentAndOffset(segSize);
+		// skip all of the space (0x20) in the right side
+		while (e >= 0 && behind.value() == 0x20) {
+			e--;
+			behind.previousByte(segSize);
+		}
+
+		if (e < 0) {
+			// empty string
+			return EMPTY_UTF8;
+		} else {
+			return str.copyBinaryString(0, e);
+		}
+	}
+
+	/**
+	 * Walk each character of current string from right end, remove the character if it
+	 * is in trim string. Stops at the first character which is not in trim string.
+	 * Return the new substring.
+	 *
+	 * @param trimStr the trim string
+	 * @return A subString which removes all of the character from the right side that is in
+	 * trim string.
+	 */
+	public static BinaryString trimRight(BinaryString str, BinaryString trimStr) {
+		str.ensureMaterialized();
+		if (trimStr == null) {
+			return null;
+		}
+		trimStr.ensureMaterialized();
+		if (isSpaceString(trimStr)) {
+			return trimRight(str);
+		}
+		if (str.inFirstSegment()) {
+			int charIdx = 0;
+			int byteIdx = 0;
+			// each element in charLens is length of character in the source string
+			int[] charLens = new int[str.sizeInBytes];
+			// each element in charStartPos is start position of first byte in the source string
+			int[] charStartPos = new int[str.sizeInBytes];
+			while (byteIdx < str.sizeInBytes) {
+				charStartPos[charIdx] = byteIdx;
+				charLens[charIdx] = numBytesForFirstByte(str.getByteOneSegment(byteIdx));
+				byteIdx += charLens[charIdx];
+				charIdx++;
+			}
+			// searchIdx points to the first character which is not in trim string from the right
+			// end.
+			int searchIdx = str.sizeInBytes - 1;
+			charIdx -= 1;
+			while (charIdx >= 0) {
+				BinaryString currentChar = str.copyBinaryStringInOneSeg(
+						charStartPos[charIdx], charLens[charIdx]);
+				if (trimStr.contains(currentChar)) {
+					searchIdx -= charLens[charIdx];
+				} else {
+					break;
+				}
+				charIdx--;
+			}
+			if (searchIdx < 0) {
+				// empty string
+				return EMPTY_UTF8;
+			} else {
+				return str.copyBinaryStringInOneSeg(0, searchIdx + 1);
+			}
+		} else {
+			return trimRightSlow(str, trimStr);
+		}
+	}
+
+	private static BinaryString trimRightSlow(BinaryString str, BinaryString trimStr) {
+		int charIdx = 0;
+		int byteIdx = 0;
+		int segSize = str.segments[0].size();
+		BinaryString.SegmentAndOffset index = str.firstSegmentAndOffset(segSize);
+		// each element in charLens is length of character in the source string
+		int[] charLens = new int[str.sizeInBytes];
+		// each element in charStartPos is start position of first byte in the source string
+		int[] charStartPos = new int[str.sizeInBytes];
+		while (byteIdx < str.sizeInBytes) {
+			charStartPos[charIdx] = byteIdx;
+			int charBytes = numBytesForFirstByte(index.value());
+			charLens[charIdx] = charBytes;
+			byteIdx += charBytes;
+			charIdx++;
+			index.skipBytes(charBytes, segSize);
+		}
+		// searchIdx points to the first character which is not in trim string from the right
+		// end.
+		int searchIdx = str.sizeInBytes - 1;
+		charIdx -= 1;
+		while (charIdx >= 0) {
+			BinaryString currentChar = str.copyBinaryString(
+					charStartPos[charIdx],
+					charStartPos[charIdx] + charLens[charIdx] - 1);
+			if (trimStr.contains(currentChar)) {
+				searchIdx -= charLens[charIdx];
+			} else {
+				break;
+			}
+			charIdx--;
+		}
+		if (searchIdx < 0) {
+			// empty string
+			return EMPTY_UTF8;
+		} else {
+			return str.copyBinaryString(0, searchIdx);
+		}
+	}
+
+	public static BinaryString trim(BinaryString str, boolean leading, boolean trailing, BinaryString seek) {
+		str.ensureMaterialized();
+		if (seek == null) {
+			return null;
+		}
+		if (leading && trailing) {
+			return trim(str, seek);
+		} else if (leading) {
+			return trimLeft(str, seek);
+		} else if (trailing) {
+			return trimRight(str, seek);
+		} else {
+			return str;
+		}
+	}
+
+	public static String safeToString(BinaryString str) {
+		if (str == null) {
+			return null;
+		} else {
+			return str.toString();
+		}
+	}
+}
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/LazyBinaryFormat.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/LazyBinaryFormat.java
index ba7478f6d6d..be29ee186e3 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/LazyBinaryFormat.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/dataformat/LazyBinaryFormat.java
@@ -41,7 +41,9 @@ public abstract class LazyBinaryFormat<T> extends BinaryFormat {
 
 	protected T javaObject;
 
-	public LazyBinaryFormat() {}
+	public LazyBinaryFormat() {
+		this(null, -1, -1, null);
+	}
 
 	public LazyBinaryFormat(MemorySegment[] segments, int offset, int sizeInBytes, T javaObject) {
 		super(segments, offset, sizeInBytes);
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/functions/SqlFunctionUtils.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/functions/SqlFunctionUtils.java
index 0859119044a..2e00fa1244c 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/functions/SqlFunctionUtils.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/functions/SqlFunctionUtils.java
@@ -19,6 +19,7 @@
 package org.apache.flink.table.runtime.functions;
 
 import org.apache.flink.table.dataformat.BinaryString;
+import org.apache.flink.table.dataformat.BinaryStringUtil;
 import org.apache.flink.table.dataformat.Decimal;
 import org.apache.flink.table.runtime.util.JsonUtils;
 import org.apache.flink.table.utils.EncodingUtils;
@@ -419,14 +420,14 @@ public class SqlFunctionUtils {
 		}
 		if (pairSeparator != null && pairSeparator.getSizeInBytes() == 1 &&
 			kvSeparator != null && kvSeparator.getSizeInBytes() == 1) {
-			return str.keyValue(pairSeparator.getByte(0), kvSeparator.getByte(0), keyName);
+			return BinaryStringUtil.keyValue(str, pairSeparator.byteAt(0), kvSeparator.byteAt(0), keyName);
 		} else {
 			return BinaryString.fromString(
 				keyValue(
-					BinaryString.safeToString(str),
-					BinaryString.safeToString(pairSeparator),
-					BinaryString.safeToString(kvSeparator),
-					BinaryString.safeToString(keyName)));
+						BinaryStringUtil.safeToString(str),
+						BinaryStringUtil.safeToString(pairSeparator),
+						BinaryStringUtil.safeToString(kvSeparator),
+						BinaryStringUtil.safeToString(keyName)));
 		}
 	}
 
@@ -675,7 +676,11 @@ public class SqlFunctionUtils {
 			}
 			return index;
 		} else {
-			int pos = instr(str.reverse(), subString.reverse(), -startPosition, nthAppearance);
+			int pos = instr(
+					BinaryStringUtil.reverse(str),
+					BinaryStringUtil.reverse(subString),
+					-startPosition,
+					nthAppearance);
 			if (pos == 0) {
 				return 0;
 			} else {
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/sort/SortUtil.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/sort/SortUtil.java
index a56d24a7690..98008321c69 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/sort/SortUtil.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/sort/SortUtil.java
@@ -76,7 +76,7 @@ public class SortUtil {
 		final int limit = offset + numBytes;
 		final int end = value.getSizeInBytes();
 		for (int i = 0; i < end && offset < limit; i++) {
-			target.put(offset++, value.getByte(i));
+			target.put(offset++, value.byteAt(i));
 		}
 
 		for (int i = offset; i < limit; i++) {
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/dataformat/BinaryStringTest.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/dataformat/BinaryStringTest.java
index 545bb09ea9a..60602132f17 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/dataformat/BinaryStringTest.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/dataformat/BinaryStringTest.java
@@ -35,9 +35,22 @@ import java.util.Random;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.apache.flink.table.dataformat.BinaryString.blankString;
-import static org.apache.flink.table.dataformat.BinaryString.concat;
-import static org.apache.flink.table.dataformat.BinaryString.concatWs;
 import static org.apache.flink.table.dataformat.BinaryString.fromBytes;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.EMPTY_STRING_ARRAY;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.concat;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.concatWs;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.keyValue;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.reverse;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.splitByWholeSeparatorPreserveAllTokens;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.substringSQL;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.toByte;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.toDecimal;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.toInt;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.toLong;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.toShort;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.trim;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.trimLeft;
+import static org.apache.flink.table.dataformat.BinaryStringUtil.trimRight;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -327,47 +340,47 @@ public class BinaryStringTest {
 		assertEquals(fromString("1"), fromString("1").trim());
 
 		assertEquals(fromString("hello"), fromString("  hello ").trim());
-		assertEquals(fromString("hello "), fromString("  hello ").trimLeft());
-		assertEquals(fromString("  hello"), fromString("  hello ").trimRight());
+		assertEquals(fromString("hello "), trimLeft(fromString("  hello ")));
+		assertEquals(fromString("  hello"), trimRight(fromString("  hello ")));
 
 		assertEquals(fromString("  hello "),
-			fromString("  hello ").trim(false, false, fromString(" ")));
+				trim(fromString("  hello "), false, false, fromString(" ")));
 		assertEquals(fromString("hello"),
-			fromString("  hello ").trim(true, true, fromString(" ")));
+				trim(fromString("  hello "), true, true, fromString(" ")));
 		assertEquals(fromString("hello "),
-			fromString("  hello ").trim(true, false, fromString(" ")));
+				trim(fromString("  hello "), true, false, fromString(" ")));
 		assertEquals(fromString("  hello"),
-			fromString("  hello ").trim(false, true, fromString(" ")));
+				trim(fromString("  hello "), false, true, fromString(" ")));
 		assertEquals(fromString("hello"),
-			fromString("xxxhellox").trim(true, true, fromString("x")));
+				trim(fromString("xxxhellox"), true, true, fromString("x")));
 
 		assertEquals(fromString("ell"),
-			fromString("xxxhellox").trim(fromString("xoh")));
+				trim(fromString("xxxhellox"), fromString("xoh")));
 
 		assertEquals(fromString("ellox"),
-			fromString("xxxhellox").trimLeft(fromString("xoh")));
+				trimLeft(fromString("xxxhellox"), fromString("xoh")));
 
 		assertEquals(fromString("xxxhell"),
-			fromString("xxxhellox").trimRight(fromString("xoh")));
+				trimRight(fromString("xxxhellox"), fromString("xoh")));
 
 		assertEquals(empty, empty.trim());
 		assertEquals(empty, fromString("  ").trim());
-		assertEquals(empty, fromString("  ").trimLeft());
-		assertEquals(empty, fromString("  ").trimRight());
+		assertEquals(empty, trimLeft(fromString("  ")));
+		assertEquals(empty, trimRight(fromString("  ")));
 
 		assertEquals(fromString(""), fromString("   ").trim());
-		assertEquals(fromString(" "), fromString("   ").trimLeft());
-		assertEquals(fromString("  "), fromString("   ").trimRight());
+		assertEquals(fromString(" "), trimLeft(fromString("   ")));
+		assertEquals(fromString("  "), trimRight(fromString("   ")));
 
 		assertEquals(fromString(""), fromString("").trim());
-		assertEquals(fromString(""), fromString("").trimLeft());
-		assertEquals(fromString(""), fromString("").trimRight());
+		assertEquals(fromString(""), trimLeft(fromString("")));
+		assertEquals(fromString(""), trimRight(fromString("")));
 
-		assertEquals(fromString(","), fromString(", ").trim(fromString(" ")));
+		assertEquals(fromString(","), trim(fromString(", "), fromString(" ")));
 		assertEquals(fromString(", "),
-			fromString(", ").trimLeft(fromString(" ")));
+				trimLeft(fromString(", "), fromString(" ")));
 		assertEquals(fromString(","),
-			fromString(", ").trimRight(fromString(" ")));
+				trimRight(fromString(", "), fromString(" ")));
 
 		char[] charsLessThan0x20 = new char[10];
 		Arrays.fill(charsLessThan0x20, (char) (' ' - 1));
@@ -375,29 +388,29 @@ public class BinaryStringTest {
 			new String(charsLessThan0x20) + "hello" + new String(charsLessThan0x20);
 		assertEquals(fromString(stringStartingWithSpace), fromString(stringStartingWithSpace).trim());
 		assertEquals(fromString(stringStartingWithSpace),
-			fromString(stringStartingWithSpace).trimLeft());
+				trimLeft(fromString(stringStartingWithSpace)));
 		assertEquals(fromString(stringStartingWithSpace),
-			fromString(stringStartingWithSpace).trimRight());
+				trimRight(fromString(stringStartingWithSpace)));
 	}
 
 	@Test
 	public void testSqlSubstring() {
-		assertEquals(fromString("ello"), fromString("hello").substringSQL(2));
-		assertEquals(fromString("ell"), fromString("hello").substringSQL(2, 3));
-		assertEquals(empty, empty.substringSQL(2, 3));
-		assertNull(fromString("hello").substringSQL(0, -1));
-		assertEquals(empty, fromString("hello").substringSQL(10));
-		assertEquals(fromString("hel"), fromString("hello").substringSQL(0, 3));
-		assertEquals(fromString("lo"), fromString("hello").substringSQL(-2, 3));
-		assertEquals(empty, fromString("hello").substringSQL(-100, 3));
+		assertEquals(fromString("ello"), substringSQL(fromString("hello"), 2));
+		assertEquals(fromString("ell"), substringSQL(fromString("hello"), 2, 3));
+		assertEquals(empty, substringSQL(empty, 2, 3));
+		assertNull(substringSQL(fromString("hello"), 0, -1));
+		assertEquals(empty, substringSQL(fromString("hello"), 10));
+		assertEquals(fromString("hel"), substringSQL(fromString("hello"), 0, 3));
+		assertEquals(fromString("lo"), substringSQL(fromString("hello"), -2, 3));
+		assertEquals(empty, substringSQL(fromString("hello"), -100, 3));
 	}
 
 	@Test
-	public void reverse() {
-		assertEquals(fromString("olleh"), fromString("hello").reverse());
-		assertEquals(fromString(""), fromString("").reverse());
-		assertEquals(fromString(" ,olleh"), fromString("hello, ").reverse());
-		assertEquals(empty, empty.reverse());
+	public void reverseTest() {
+		assertEquals(fromString("olleh"), reverse(fromString("hello")));
+		assertEquals(fromString(""), reverse(fromString("")));
+		assertEquals(fromString(" ,olleh"), reverse(fromString("hello, ")));
+		assertEquals(empty, reverse(empty));
 	}
 
 	@Test
@@ -419,32 +432,32 @@ public class BinaryStringTest {
 	@Test
 	public void testToNumeric() {
 		// Test to integer.
-		assertEquals(Byte.valueOf("123"), fromString("123").toByte());
-		assertEquals(Byte.valueOf("123"), fromString("+123").toByte());
-		assertEquals(Byte.valueOf("-123"), fromString("-123").toByte());
+		assertEquals(Byte.valueOf("123"), toByte(fromString("123")));
+		assertEquals(Byte.valueOf("123"), toByte(fromString("+123")));
+		assertEquals(Byte.valueOf("-123"), toByte(fromString("-123")));
 
-		assertEquals(Short.valueOf("123"), fromString("123").toShort());
-		assertEquals(Short.valueOf("123"), fromString("+123").toShort());
-		assertEquals(Short.valueOf("-123"), fromString("-123").toShort());
+		assertEquals(Short.valueOf("123"), toShort(fromString("123")));
+		assertEquals(Short.valueOf("123"), toShort(fromString("+123")));
+		assertEquals(Short.valueOf("-123"), toShort(fromString("-123")));
 
-		assertEquals(Integer.valueOf("123"), fromString("123").toInt());
-		assertEquals(Integer.valueOf("123"), fromString("+123").toInt());
-		assertEquals(Integer.valueOf("-123"), fromString("-123").toInt());
+		assertEquals(Integer.valueOf("123"), toInt(fromString("123")));
+		assertEquals(Integer.valueOf("123"), toInt(fromString("+123")));
+		assertEquals(Integer.valueOf("-123"), toInt(fromString("-123")));
 
 		assertEquals(Long.valueOf("1234567890"),
-			fromString("1234567890").toLong());
+				toLong(fromString("1234567890")));
 		assertEquals(Long.valueOf("+1234567890"),
-			fromString("+1234567890").toLong());
+				toLong(fromString("+1234567890")));
 		assertEquals(Long.valueOf("-1234567890"),
-			fromString("-1234567890").toLong());
+				toLong(fromString("-1234567890")));
 
 		// Test decimal string to integer.
-		assertEquals(Integer.valueOf("123"), fromString("123.456789").toInt());
-		assertEquals(Long.valueOf("123"), fromString("123.456789").toLong());
+		assertEquals(Integer.valueOf("123"), toInt(fromString("123.456789")));
+		assertEquals(Long.valueOf("123"), toLong(fromString("123.456789")));
 
 		// Test negative cases.
-		assertNull(fromString("1a3.456789").toInt());
-		assertNull(fromString("123.a56789").toInt());
+		assertNull(toInt(fromString("1a3.456789")));
+		assertNull(toInt(fromString("123.a56789")));
 
 		// Test composite in BinaryRow.
 		BinaryRow row = new BinaryRow(20);
@@ -455,10 +468,10 @@ public class BinaryStringTest {
 		writer.writeString(3, BinaryString.fromString("123456789"));
 		writer.complete();
 
-		assertEquals(Byte.valueOf("1"), row.getString(0).toByte());
-		assertEquals(Short.valueOf("123"), row.getString(1).toShort());
-		assertEquals(Integer.valueOf("12345"), row.getString(2).toInt());
-		assertEquals(Long.valueOf("123456789"), row.getString(3).toLong());
+		assertEquals(Byte.valueOf("1"), toByte(row.getString(0)));
+		assertEquals(Short.valueOf("123"), toShort(row.getString(1)));
+		assertEquals(Integer.valueOf("12345"), toInt(row.getString(2)));
+		assertEquals(Long.valueOf("123456789"), toLong(row.getString(3)));
 	}
 
 	@Test
@@ -563,7 +576,7 @@ public class BinaryStringTest {
 		for (DecimalData d : data) {
 			assertEquals(
 				Decimal.fromBigDecimal(new BigDecimal(d.str), d.precision, d.scale),
-				fromString(d.str).toDecimal(d.precision, d.scale));
+				toDecimal(fromString(d.str), d.precision, d.scale));
 		}
 
 		BinaryRow row = new BinaryRow(data.length);
@@ -576,14 +589,14 @@ public class BinaryStringTest {
 			DecimalData d = data[i];
 			assertEquals(
 				Decimal.fromBigDecimal(new BigDecimal(d.str), d.precision, d.scale),
-				row.getString(i).toDecimal(d.precision, d.scale));
+					toDecimal(row.getString(i), d.precision, d.scale));
 		}
 	}
 
 	@Test
 	public void testEmptyString() {
 		BinaryString str2 = fromString("hahahahah");
-		BinaryString str3 = new BinaryString(null);
+		BinaryString str3 = new BinaryString();
 		{
 			MemorySegment[] segments = new MemorySegment[2];
 			segments[0] = MemorySegmentFactory.wrap(new byte[10]);
@@ -624,83 +637,83 @@ public class BinaryStringTest {
 
 	@Test
 	public void testKeyValue() {
-		assertNull(fromString("k1:v1|k2:v2").keyValue(
-			fromString("|").getByte(0),
-			fromString(":").getByte(0),
+		assertNull(keyValue(fromString("k1:v1|k2:v2"),
+			fromString("|").byteAt(0),
+			fromString(":").byteAt(0),
 			fromString("k3")));
-		assertNull(fromString("k1:v1|k2:v2|").keyValue(
-			fromString("|").getByte(0),
-			fromString(":").getByte(0),
+		assertNull(keyValue(fromString("k1:v1|k2:v2|"),
+			fromString("|").byteAt(0),
+			fromString(":").byteAt(0),
 			fromString("k3")));
-		assertNull(fromString("|k1:v1|k2:v2|").keyValue(
-			fromString("|").getByte(0),
-			fromString(":").getByte(0),
+		assertNull(keyValue(fromString("|k1:v1|k2:v2|"),
+			fromString("|").byteAt(0),
+			fromString(":").byteAt(0),
 			fromString("k3")));
 		String tab = org.apache.commons.lang3.StringEscapeUtils.unescapeJava("\t");
 		assertEquals(fromString("v2"),
-			fromString("k1:v1" + tab + "k2:v2").keyValue(
-				fromString("\t").getByte(0),
-				fromString(":").getByte(0),
+				keyValue(fromString("k1:v1" + tab + "k2:v2"),
+				fromString("\t").byteAt(0),
+				fromString(":").byteAt(0),
 				fromString("k2")));
-		assertNull(fromString("k1:v1|k2:v2").keyValue(
-			fromString("|").getByte(0),
-			fromString(":").getByte(0),
+		assertNull(keyValue(fromString("k1:v1|k2:v2"),
+			fromString("|").byteAt(0),
+			fromString(":").byteAt(0),
 			null));
 		assertEquals(fromString("v2"),
-			fromString("k1=v1;k2=v2").keyValue(
-				fromString(";").getByte(0),
-				fromString("=").getByte(0),
+				keyValue(fromString("k1=v1;k2=v2"),
+				fromString(";").byteAt(0),
+				fromString("=").byteAt(0),
 				fromString("k2")));
 		assertEquals(fromString("v2"),
-			fromString("|k1=v1|k2=v2|").keyValue(
-				fromString("|").getByte(0),
-				fromString("=").getByte(0),
+				keyValue(fromString("|k1=v1|k2=v2|"),
+				fromString("|").byteAt(0),
+				fromString("=").byteAt(0),
 				fromString("k2")));
 		assertEquals(fromString("v2"),
-			fromString("k1=v1||k2=v2").keyValue(
-				fromString("|").getByte(0),
-				fromString("=").getByte(0),
+				keyValue(fromString("k1=v1||k2=v2"),
+				fromString("|").byteAt(0),
+				fromString("=").byteAt(0),
 				fromString("k2")));
-		assertNull(fromString("k1=v1;k2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0),
+		assertNull(keyValue(fromString("k1=v1;k2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0),
 			fromString("k2")));
-		assertNull(fromString("k1;k2=v2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0),
+		assertNull(keyValue(fromString("k1;k2=v2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0),
 			fromString("k1")));
-		assertNull(fromString("k=1=v1;k2=v2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0),
+		assertNull(keyValue(fromString("k=1=v1;k2=v2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0),
 			fromString("k=")));
 		assertEquals(fromString("=v1"),
-			fromString("k1==v1;k2=v2").keyValue(
-				fromString(";").getByte(0),
-				fromString("=").getByte(0), fromString("k1")));
-		assertNull(fromString("k1==v1;k2=v2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0), fromString("k1=")));
-		assertNull(fromString("k1=v1;k2=v2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0),
+				keyValue(fromString("k1==v1;k2=v2"),
+				fromString(";").byteAt(0),
+				fromString("=").byteAt(0), fromString("k1")));
+		assertNull(keyValue(fromString("k1==v1;k2=v2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0), fromString("k1=")));
+		assertNull(keyValue(fromString("k1=v1;k2=v2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0),
 			fromString("k1=")));
-		assertNull(fromString("k1k1=v1;k2=v2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0),
+		assertNull(keyValue(fromString("k1k1=v1;k2=v2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0),
 			fromString("k1")));
-		assertNull(fromString("k1=v1;k2=v2").keyValue(
-			fromString(";").getByte(0),
-			fromString("=").getByte(0),
+		assertNull(keyValue(fromString("k1=v1;k2=v2"),
+			fromString(";").byteAt(0),
+			fromString("=").byteAt(0),
 			fromString("k1k1k1k1k1k1k1k1k1k1")));
 		assertEquals(fromString("v2"),
-			fromString("k1:v||k2:v2").keyValue(
-				fromString("|").getByte(0),
-				fromString(":").getByte(0),
+				keyValue(fromString("k1:v||k2:v2"),
+				fromString("|").byteAt(0),
+				fromString(":").byteAt(0),
 				fromString("k2")));
 		assertEquals(fromString("v2"),
-			fromString("k1:v||k2:v2").keyValue(
-				fromString("|").getByte(0),
-				fromString(":").getByte(0),
+				keyValue(fromString("k1:v||k2:v2"),
+				fromString("|").byteAt(0),
+				fromString(":").byteAt(0),
 				fromString("k2")));
 	}
 
@@ -739,17 +752,17 @@ public class BinaryStringTest {
 
 	@Test
 	public void testSplit() {
-		assertArrayEquals(BinaryString.EMPTY_STRING_ARRAY,
-			fromString("").splitByWholeSeparatorPreserveAllTokens(fromString("")));
+		assertArrayEquals(EMPTY_STRING_ARRAY,
+				splitByWholeSeparatorPreserveAllTokens(fromString(""), fromString("")));
 		assertArrayEquals(new BinaryString[] {fromString("ab"), fromString("de"), fromString("fg")},
-			fromString("ab de fg").splitByWholeSeparatorPreserveAllTokens(null));
+				splitByWholeSeparatorPreserveAllTokens(fromString("ab de fg"), null));
 		assertArrayEquals(new BinaryString[] {fromString("ab"), fromString(""), fromString(""),
-				fromString("de"), fromString("fg")},
-			fromString("ab   de fg").splitByWholeSeparatorPreserveAllTokens(null));
+						fromString("de"), fromString("fg")},
+				splitByWholeSeparatorPreserveAllTokens(fromString("ab   de fg"), null));
 		assertArrayEquals(new BinaryString[] {fromString("ab"), fromString("cd"), fromString("ef")},
-			fromString("ab:cd:ef").splitByWholeSeparatorPreserveAllTokens(fromString(":")));
+				splitByWholeSeparatorPreserveAllTokens(fromString("ab:cd:ef"), fromString(":")));
 		assertArrayEquals(new BinaryString[] {fromString("ab"), fromString("cd"), fromString("ef")},
-			fromString("ab-!-cd-!-ef").splitByWholeSeparatorPreserveAllTokens(fromString("-!-")));
+				splitByWholeSeparatorPreserveAllTokens(fromString("ab-!-cd-!-ef"), fromString("-!-")));
 	}
 
 	@Test
