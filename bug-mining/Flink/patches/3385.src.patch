diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/AvailabilityProvider.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/AvailabilityProvider.java
index 09d8ed1ac2d..8ab59b3e5ef 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/AvailabilityProvider.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/AvailabilityProvider.java
@@ -89,6 +89,16 @@ public interface AvailabilityProvider {
 			return toNotify;
 		}
 
+		/**
+		 *  Creates a new uncompleted future as the current state and returns the
+		 *  previous uncompleted one.
+		 */
+		public CompletableFuture<?> getUnavailableToResetUnavailable() {
+			CompletableFuture<?> toNotify = isAvailable;
+			isAvailable = new CompletableFuture<>();
+			return toNotify;
+		}
+
 		/**
 		 * @return a future that is completed if the respective provider is available.
 		 */
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
index 6e4c8aee9b6..72f98c0959e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
@@ -305,9 +305,7 @@ class LocalBufferPool implements BufferPool {
 			notificationResult = fireBufferAvailableNotification(listener, segment);
 		}
 
-		if (toNotify != null) {
-			toNotify.complete(null);
-		}
+		mayNotifyAvailable(toNotify);
 	}
 
 	private NotificationResult fireBufferAvailableNotification(BufferListener listener, MemorySegment segment) {
@@ -348,7 +346,7 @@ class LocalBufferPool implements BufferPool {
 				}
 
 				final CompletableFuture<?> isAvailable = availabilityHelper.isAvailable();
-				if (isAvailable != AVAILABLE && !isAvailable.isDone()) {
+				if (!isAvailable(isAvailable)) {
 					toNotify = isAvailable;
 				}
 
@@ -356,10 +354,7 @@ class LocalBufferPool implements BufferPool {
 			}
 		}
 
-		// notify the potential blocking request thread
-		if (toNotify != null) {
-			toNotify.complete(null);
-		}
+		mayNotifyAvailable(toNotify);
 
 		try {
 			networkBufferPool.destroyBufferPool(this);
@@ -383,6 +378,7 @@ class LocalBufferPool implements BufferPool {
 	@Override
 	public void setNumBuffers(int numBuffers) throws IOException {
 		int numExcessBuffers;
+		CompletableFuture<?> toNotify = null;
 		synchronized (availableMemorySegments) {
 			checkArgument(numBuffers >= numberOfRequiredMemorySegments,
 					"Buffer pool needs at least %s buffers, but tried to set to %s",
@@ -397,8 +393,16 @@ class LocalBufferPool implements BufferPool {
 			returnExcessMemorySegments();
 
 			numExcessBuffers = numberOfRequestedMemorySegments - currentPoolSize;
+
+			if (numExcessBuffers < 0
+					&& availableMemorySegments.isEmpty()
+					&& isAvailable(networkBufferPool.isAvailable())) {
+				toNotify = availabilityHelper.getUnavailableToResetUnavailable();
+			}
 		}
 
+		mayNotifyAvailable(toNotify);
+
 		// If there is a registered owner and we have still requested more buffers than our
 		// size, trigger a recycle via the owner.
 		if (bufferPoolOwner != null && numExcessBuffers > 0) {
@@ -429,6 +433,20 @@ class LocalBufferPool implements BufferPool {
 
 	// ------------------------------------------------------------------------
 
+	/**
+	 * Notifies the potential segment consumer of the new available segments by
+	 * completing the previous uncompleted future.
+	 */
+	private void mayNotifyAvailable(@Nullable CompletableFuture<?> toNotify) {
+		if (toNotify != null) {
+			toNotify.complete(null);
+		}
+	}
+
+	private boolean isAvailable(CompletableFuture<?> isAvailable) {
+		return isAvailable == AVAILABLE || isAvailable.isDone();
+	}
+
 	private void returnMemorySegment(MemorySegment segment) {
 		assert Thread.holdsLock(availableMemorySegments);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
index 4cf7fffae59..19a312539c1 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
@@ -229,14 +229,14 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 	}
 
 	private void recycleMemorySegments(Collection<MemorySegment> segments, int size) throws IOException {
+		internalRecycleMemorySegments(segments);
+
 		synchronized (factoryLock) {
 			numTotalRequiredBuffers -= size;
 
 			// note: if this fails, we're fine for the buffer pool since we already recycled the segments
 			redistributeBuffers();
 		}
-
-		internalRecycleMemorySegments(segments);
 	}
 
 	private void internalRecycleMemorySegments(Collection<MemorySegment> segments) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
index a3f4aed6ffb..f22913b707d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
@@ -414,10 +414,12 @@ public class LocalBufferPoolTest extends TestLogger {
 
 		// request one buffer
 		final BufferBuilder bufferBuilder = checkNotNull(localBufferPool.requestBufferBuilderBlocking());
-		assertFalse(localBufferPool.isAvailable().isDone());
+		CompletableFuture<?> availableFuture = localBufferPool.isAvailable();
+		assertFalse(availableFuture.isDone());
 
 		// set the pool size
 		localBufferPool.setNumBuffers(2);
+		assertTrue(availableFuture.isDone());
 		assertTrue(localBufferPool.isAvailable().isDone());
 
 		// drain the global buffer pool
@@ -435,7 +437,7 @@ public class LocalBufferPoolTest extends TestLogger {
 
 		// reset the pool size
 		localBufferPool.setNumBuffers(1);
-		final CompletableFuture<?> availableFuture = localBufferPool.isAvailable();
+		availableFuture = localBufferPool.isAvailable();
 		assertFalse(availableFuture.isDone());
 
 		// recycle the requested buffer
