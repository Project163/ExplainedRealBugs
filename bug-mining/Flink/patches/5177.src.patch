diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java
index bfe9fb10e55..870383a381a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendTestBase.java
@@ -458,62 +458,67 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE, env);
 
-        // cast because our test serializer is not typed to TestPojo
-        env.getExecutionConfig()
-                .addDefaultKryoSerializer(
-                        TestPojo.class, (Class) ExceptionThrowingTestSerializer.class);
+        try {
+            // cast because our test serializer is not typed to TestPojo
+            env.getExecutionConfig()
+                    .addDefaultKryoSerializer(
+                            TestPojo.class, (Class) ExceptionThrowingTestSerializer.class);
 
-        TypeInformation<TestPojo> pojoType = new GenericTypeInfo<>(TestPojo.class);
+            TypeInformation<TestPojo> pojoType = new GenericTypeInfo<>(TestPojo.class);
 
-        // make sure that we are in fact using the KryoSerializer
-        assertTrue(pojoType.createSerializer(env.getExecutionConfig()) instanceof KryoSerializer);
+            // make sure that we are in fact using the KryoSerializer
+            assertTrue(
+                    pojoType.createSerializer(env.getExecutionConfig()) instanceof KryoSerializer);
 
-        ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
+            ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
 
-        ValueState<TestPojo> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            ValueState<TestPojo> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        // we will be expecting ExpectedKryoTestException to be thrown,
-        // because the ExceptionThrowingTestSerializer should be used
-        int numExceptions = 0;
+            // we will be expecting ExpectedKryoTestException to be thrown,
+            // because the ExceptionThrowingTestSerializer should be used
+            int numExceptions = 0;
 
-        backend.setCurrentKey(1);
+            backend.setCurrentKey(1);
 
-        try {
-            // backends that eagerly serializes (such as RocksDB) will fail here
-            state.update(new TestPojo("u1", 1));
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that eagerly serializes (such as RocksDB) will fail here
+                state.update(new TestPojo("u1", 1));
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        try {
-            // backends that lazily serializes (such as memory state backend) will fail here
-            runSnapshot(
-                    backend.snapshot(
-                            682375462378L,
-                            2,
-                            streamFactory,
-                            CheckpointOptions.forCheckpointWithDefaultLocation()),
-                    sharedStateRegistry);
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that lazily serializes (such as memory state backend) will fail here
+                runSnapshot(
+                        backend.snapshot(
+                                682375462378L,
+                                2,
+                                streamFactory,
+                                CheckpointOptions.forCheckpointWithDefaultLocation()),
+                        sharedStateRegistry);
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
-        backend.dispose();
+            assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
@@ -524,73 +529,76 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE, env);
 
-        // cast because our test serializer is not typed to TestPojo
-        env.getExecutionConfig()
-                .addDefaultKryoSerializer(
-                        TestPojo.class, (Class) ExceptionThrowingTestSerializer.class);
+        try {
+            // cast because our test serializer is not typed to TestPojo
+            env.getExecutionConfig()
+                    .addDefaultKryoSerializer(
+                            TestPojo.class, (Class) ExceptionThrowingTestSerializer.class);
 
-        TypeInformation<TestPojo> pojoType = new GenericTypeInfo<>(TestPojo.class);
+            TypeInformation<TestPojo> pojoType = new GenericTypeInfo<>(TestPojo.class);
 
-        // make sure that we are in fact using the KryoSerializer
-        assertTrue(pojoType.createSerializer(env.getExecutionConfig()) instanceof KryoSerializer);
+            // make sure that we are in fact using the KryoSerializer
+            assertTrue(
+                    pojoType.createSerializer(env.getExecutionConfig()) instanceof KryoSerializer);
 
-        pojoType.createSerializer(env.getExecutionConfig());
+            pojoType.createSerializer(env.getExecutionConfig());
 
-        ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
+            ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
 
-        ValueState<TestPojo> state =
-                backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
-        assertTrue(state instanceof InternalValueState);
-        ((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
+            ValueState<TestPojo> state =
+                    backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
+            assertTrue(state instanceof InternalValueState);
+            ((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
 
-        // we will be expecting ExpectedKryoTestException to be thrown,
-        // because the ExceptionThrowingTestSerializer should be used
-        int numExceptions = 0;
+            // we will be expecting ExpectedKryoTestException to be thrown,
+            // because the ExceptionThrowingTestSerializer should be used
+            int numExceptions = 0;
 
-        backend.setCurrentKey(1);
+            backend.setCurrentKey(1);
 
-        try {
-            // backends that eagerly serializes (such as RocksDB) will fail here
-            state.update(new TestPojo("u1", 1));
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that eagerly serializes (such as RocksDB) will fail here
+                state.update(new TestPojo("u1", 1));
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        try {
-            // backends that lazily serializes (such as memory state backend) will fail here
-            runSnapshot(
-                    backend.snapshot(
-                            682375462378L,
-                            2,
-                            streamFactory,
-                            CheckpointOptions.forCheckpointWithDefaultLocation()),
-                    sharedStateRegistry);
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that lazily serializes (such as memory state backend) will fail here
+                runSnapshot(
+                        backend.snapshot(
+                                682375462378L,
+                                2,
+                                streamFactory,
+                                CheckpointOptions.forCheckpointWithDefaultLocation()),
+                        sharedStateRegistry);
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
-        backend.dispose();
+            assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
     public void testBackendUsesRegisteredKryoSerializer() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE, env);
         env.getExecutionConfig()
                 .registerTypeWithKryoSerializer(
                         TestPojo.class, ExceptionThrowingTestSerializer.class);
@@ -602,50 +610,56 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
 
         ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
 
-        ValueState<TestPojo> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE, env);
+        try {
+            ValueState<TestPojo> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        // we will be expecting ExpectedKryoTestException to be thrown,
-        // because the ExceptionThrowingTestSerializer should be used
-        int numExceptions = 0;
+            // we will be expecting ExpectedKryoTestException to be thrown,
+            // because the ExceptionThrowingTestSerializer should be used
+            int numExceptions = 0;
 
-        backend.setCurrentKey(1);
+            backend.setCurrentKey(1);
 
-        try {
-            // backends that eagerly serializes (such as RocksDB) will fail here
-            state.update(new TestPojo("u1", 1));
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that eagerly serializes (such as RocksDB) will fail here
+                state.update(new TestPojo("u1", 1));
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        try {
-            // backends that lazily serializes (such as memory state backend) will fail here
-            runSnapshot(
-                    backend.snapshot(
-                            682375462378L,
-                            2,
-                            streamFactory,
-                            CheckpointOptions.forCheckpointWithDefaultLocation()),
-                    sharedStateRegistry);
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that lazily serializes (such as memory state backend) will fail here
+                runSnapshot(
+                        backend.snapshot(
+                                682375462378L,
+                                2,
+                                streamFactory,
+                                CheckpointOptions.forCheckpointWithDefaultLocation()),
+                        sharedStateRegistry);
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
-        backend.dispose();
+            assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
@@ -653,8 +667,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testBackendUsesRegisteredKryoSerializerUsingGetOrCreate() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE, env);
 
         env.getExecutionConfig()
                 .registerTypeWithKryoSerializer(
@@ -667,51 +679,57 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
 
         ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
 
-        ValueState<TestPojo> state =
-                backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
-        assertTrue(state instanceof InternalValueState);
-        ((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE, env);
+        try {
+            ValueState<TestPojo> state =
+                    backend.getOrCreateKeyedState(VoidNamespaceSerializer.INSTANCE, kvId);
+            assertTrue(state instanceof InternalValueState);
+            ((InternalValueState) state).setCurrentNamespace(VoidNamespace.INSTANCE);
 
-        // we will be expecting ExpectedKryoTestException to be thrown,
-        // because the ExceptionThrowingTestSerializer should be used
-        int numExceptions = 0;
+            // we will be expecting ExpectedKryoTestException to be thrown,
+            // because the ExceptionThrowingTestSerializer should be used
+            int numExceptions = 0;
 
-        backend.setCurrentKey(1);
+            backend.setCurrentKey(1);
 
-        try {
-            // backends that eagerly serializes (such as RocksDB) will fail here
-            state.update(new TestPojo("u1", 1));
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that eagerly serializes (such as RocksDB) will fail here
+                state.update(new TestPojo("u1", 1));
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        try {
-            // backends that lazily serializes (such as memory state backend) will fail here
-            runSnapshot(
-                    backend.snapshot(
-                            682375462378L,
-                            2,
-                            streamFactory,
-                            CheckpointOptions.forCheckpointWithDefaultLocation()),
-                    sharedStateRegistry);
-        } catch (ExpectedKryoTestException e) {
-            numExceptions++;
-        } catch (Exception e) {
-            if (e.getCause() instanceof ExpectedKryoTestException) {
+            try {
+                // backends that lazily serializes (such as memory state backend) will fail here
+                runSnapshot(
+                        backend.snapshot(
+                                682375462378L,
+                                2,
+                                streamFactory,
+                                CheckpointOptions.forCheckpointWithDefaultLocation()),
+                        sharedStateRegistry);
+            } catch (ExpectedKryoTestException e) {
                 numExceptions++;
-            } else {
-                throw e;
+            } catch (Exception e) {
+                if (e.getCause() instanceof ExpectedKryoTestException) {
+                    numExceptions++;
+                } else {
+                    throw e;
+                }
             }
-        }
 
-        assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
-        backend.dispose();
+            assertEquals("Didn't see the expected Kryo exception.", 1, numExceptions);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /**
@@ -726,8 +744,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testKryoRegisteringRestoreResilienceWithRegisteredType() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE, env);
 
         TypeInformation<TestPojo> pojoType = new GenericTypeInfo<>(TestPojo.class);
 
@@ -736,50 +752,57 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
 
         ValueStateDescriptor<TestPojo> kvId = new ValueStateDescriptor<>("id", pojoType);
 
-        ValueState<TestPojo> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        // ============== create snapshot - no Kryo registration or specific / default serializers
-        // ==============
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE, env);
+        try {
+            ValueState<TestPojo> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        // make some more modifications
-        backend.setCurrentKey(1);
-        state.update(new TestPojo("u1", 1));
+            // ============== create snapshot - no Kryo registration or specific / default
+            // serializers
+            // ==============
 
-        backend.setCurrentKey(2);
-        state.update(new TestPojo("u2", 2));
+            // make some more modifications
+            backend.setCurrentKey(1);
+            state.update(new TestPojo("u1", 1));
 
-        KeyedStateHandle snapshot =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            backend.setCurrentKey(2);
+            state.update(new TestPojo("u2", 2));
 
-        backend.dispose();
+            KeyedStateHandle snapshot =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
 
-        // ====================================== restore snapshot
-        // ======================================
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
 
-        env.getExecutionConfig().registerKryoType(TestPojo.class);
+            // ====================================== restore snapshot
+            // ======================================
 
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot, env);
+            env.getExecutionConfig().registerKryoType(TestPojo.class);
 
-        snapshot.discardState();
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot, env);
 
-        state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        backend.setCurrentKey(1);
-        assertEquals(state.value(), new TestPojo("u1", 1));
+            snapshot.discardState();
 
-        backend.setCurrentKey(2);
-        assertEquals(state.value(), new TestPojo("u2", 2));
+            state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            backend.setCurrentKey(1);
+            assertEquals(state.value(), new TestPojo("u1", 1));
 
-        backend.dispose();
+            backend.setCurrentKey(2);
+            assertEquals(state.value(), new TestPojo("u2", 2));
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /**
@@ -798,11 +821,9 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testKryoRegisteringRestoreResilienceWithDefaultSerializer() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend = null;
-
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE, env);
         try {
-            backend = createKeyedBackend(IntSerializer.INSTANCE, env);
-
             TypeInformation<TestPojo> pojoType = new GenericTypeInfo<>(TestPojo.class);
 
             // make sure that we are in fact using the KryoSerializer
@@ -900,7 +921,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             state.value();
 
             snapshot2.discardState();
-            backend.dispose();
         } finally {
             // ensure to release native resources even when we exit through exception
             IOUtils.closeQuietly(backend);
@@ -1019,8 +1039,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             backend.setCurrentKey(1);
             // state backends that lazily deserializes (such as RocksDB) will fail here
             state.value();
-
-            backend.dispose();
         } finally {
             // ensure that native resources are also released in case of exception
             if (backend != null) {
@@ -1263,223 +1281,226 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testValueState() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
 
         ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class);
 
         TypeSerializer<Integer> keySerializer = IntSerializer.INSTANCE;
         TypeSerializer<VoidNamespace> namespaceSerializer = VoidNamespaceSerializer.INSTANCE;
 
-        ValueState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> kvState =
-                (InternalKvState<Integer, VoidNamespace, String>) state;
-
-        // this is only available after the backend initialized the serializer
-        TypeSerializer<String> valueSerializer = kvId.getSerializer();
-
-        // some modifications to the state
-        backend.setCurrentKey(1);
-        assertNull(state.value());
-        assertNull(
-                getSerializedValue(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.update("1");
-        backend.setCurrentKey(2);
-        assertNull(state.value());
-        assertNull(
-                getSerializedValue(
-                        kvState,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.update("2");
-        backend.setCurrentKey(1);
-        assertEquals("1", state.value());
-        assertEquals(
-                "1",
-                getSerializedValue(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
-
-        // make some more modifications
-        backend.setCurrentKey(1);
-        state.update("u1");
-        backend.setCurrentKey(2);
-        state.update("u2");
-        backend.setCurrentKey(3);
-        state.update("u3");
-
-        // draw another snapshot
-        KeyedStateHandle snapshot2 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462379L,
-                                4,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
-
-        // validate the original state
-        backend.setCurrentKey(1);
-        assertEquals("u1", state.value());
-        assertEquals(
-                "u1",
-                getSerializedValue(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(2);
-        assertEquals("u2", state.value());
-        assertEquals(
-                "u2",
-                getSerializedValue(
-                        kvState,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(3);
-        assertEquals("u3", state.value());
-        assertEquals(
-                "u3",
-                getSerializedValue(
-                        kvState,
-                        3,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        backend.dispose();
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
-
-        snapshot1.discardState();
-
-        ValueState<String> restored1 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> restoredKvState1 =
-                (InternalKvState<Integer, VoidNamespace, String>) restored1;
-
-        backend.setCurrentKey(1);
-        assertEquals("1", restored1.value());
-        assertEquals(
-                "1",
-                getSerializedValue(
-                        restoredKvState1,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(2);
-        assertEquals("2", restored1.value());
-        assertEquals(
-                "2",
-                getSerializedValue(
-                        restoredKvState1,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        backend.dispose();
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot2);
-
-        snapshot2.discardState();
-
-        ValueState<String> restored2 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> restoredKvState2 =
-                (InternalKvState<Integer, VoidNamespace, String>) restored2;
-
-        backend.setCurrentKey(1);
-        assertEquals("u1", restored2.value());
-        assertEquals(
-                "u1",
-                getSerializedValue(
-                        restoredKvState2,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(2);
-        assertEquals("u2", restored2.value());
-        assertEquals(
-                "u2",
-                getSerializedValue(
-                        restoredKvState2,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(3);
-        assertEquals("u3", restored2.value());
-        assertEquals(
-                "u3",
-                getSerializedValue(
-                        restoredKvState2,
-                        3,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        backend.dispose();
-    }
-
-    @Test
-    public void testValueStateWorkWithTtl() throws Exception {
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE);
         try {
-            ValueStateDescriptor<MutableLong> kvId =
-                    new ValueStateDescriptor<>("id", MutableLong.class);
-            kvId.enableTimeToLive(StateTtlConfig.newBuilder(Time.seconds(1)).build());
-
-            ValueState<MutableLong> state =
+            ValueState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> kvState =
+                    (InternalKvState<Integer, VoidNamespace, String>) state;
+
+            // this is only available after the backend initialized the serializer
+            TypeSerializer<String> valueSerializer = kvId.getSerializer();
+
+            // some modifications to the state
+            backend.setCurrentKey(1);
+            assertNull(state.value());
+            assertNull(
+                    getSerializedValue(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.update("1");
+            backend.setCurrentKey(2);
+            assertNull(state.value());
+            assertNull(
+                    getSerializedValue(
+                            kvState,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.update("2");
+            backend.setCurrentKey(1);
+            assertEquals("1", state.value());
+            assertEquals(
+                    "1",
+                    getSerializedValue(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+
+            // draw a snapshot
+            KeyedStateHandle snapshot1 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // make some more modifications
+            backend.setCurrentKey(1);
+            state.update("u1");
+            backend.setCurrentKey(2);
+            state.update("u2");
+            backend.setCurrentKey(3);
+            state.update("u3");
+
+            // draw another snapshot
+            KeyedStateHandle snapshot2 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462379L,
+                                    4,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // validate the original state
+            backend.setCurrentKey(1);
+            assertEquals("u1", state.value());
+            assertEquals(
+                    "u1",
+                    getSerializedValue(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(2);
+            assertEquals("u2", state.value());
+            assertEquals(
+                    "u2",
+                    getSerializedValue(
+                            kvState,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(3);
+            assertEquals("u3", state.value());
+            assertEquals(
+                    "u3",
+                    getSerializedValue(
+                            kvState,
+                            3,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+
+            backend.dispose();
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
+
+            snapshot1.discardState();
+
+            ValueState<String> restored1 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> restoredKvState1 =
+                    (InternalKvState<Integer, VoidNamespace, String>) restored1;
+
+            backend.setCurrentKey(1);
+            assertEquals("1", restored1.value());
+            assertEquals(
+                    "1",
+                    getSerializedValue(
+                            restoredKvState1,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(2);
+            assertEquals("2", restored1.value());
+            assertEquals(
+                    "2",
+                    getSerializedValue(
+                            restoredKvState1,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+
+            backend.dispose();
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot2);
+
+            snapshot2.discardState();
+
+            ValueState<String> restored2 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> restoredKvState2 =
+                    (InternalKvState<Integer, VoidNamespace, String>) restored2;
+
+            backend.setCurrentKey(1);
+            assertEquals("u1", restored2.value());
+            assertEquals(
+                    "u1",
+                    getSerializedValue(
+                            restoredKvState2,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(2);
+            assertEquals("u2", restored2.value());
+            assertEquals(
+                    "u2",
+                    getSerializedValue(
+                            restoredKvState2,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(3);
+            assertEquals("u3", restored2.value());
+            assertEquals(
+                    "u3",
+                    getSerializedValue(
+                            restoredKvState2,
+                            3,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
+    }
+
+    @Test
+    public void testValueStateWorkWithTtl() throws Exception {
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ValueStateDescriptor<MutableLong> kvId =
+                    new ValueStateDescriptor<>("id", MutableLong.class);
+            kvId.enableTimeToLive(StateTtlConfig.newBuilder(Time.seconds(1)).build());
+
+            ValueState<MutableLong> state =
                     backend.getPartitionedState(
                             VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
             backend.setCurrentKey(1);
             state.update(new MutableLong());
             state.value();
         } finally {
-            backend.close();
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -1492,8 +1513,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     @Test
     @SuppressWarnings("unchecked")
     public void testValueStateRace() throws Exception {
-        final CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
         final Integer namespace = 1;
 
         final ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class);
@@ -1501,109 +1520,111 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         final TypeSerializer<Integer> keySerializer = IntSerializer.INSTANCE;
         final TypeSerializer<Integer> namespaceSerializer = IntSerializer.INSTANCE;
 
-        final ValueState<String> state =
-                backend.getPartitionedState(namespace, IntSerializer.INSTANCE, kvId);
-
-        // this is only available after the backend initialized the serializer
-        final TypeSerializer<String> valueSerializer = kvId.getSerializer();
-
-        @SuppressWarnings("unchecked")
-        final InternalKvState<Integer, Integer, String> kvState =
-                (InternalKvState<Integer, Integer, String>) state;
-
-        /**
-         * 1) Test that ValueState#value() before and after KvState#getSerializedValue(byte[])
-         * return the same value.
-         */
-
-        // set some key and namespace
-        final int key1 = 1;
-        backend.setCurrentKey(key1);
-        kvState.setCurrentNamespace(2);
-        state.update("2");
-        assertEquals("2", state.value());
-
-        // query another key and namespace
-        assertNull(
-                getSerializedValue(
-                        kvState,
-                        3,
-                        keySerializer,
-                        namespace,
-                        IntSerializer.INSTANCE,
-                        valueSerializer));
-
-        // the state should not have changed!
-        assertEquals("2", state.value());
-
-        // re-set values
-        kvState.setCurrentNamespace(namespace);
-
-        /**
-         * 2) Test two threads concurrently using ValueState#value() and
-         * KvState#getSerializedValue(byte[]).
-         */
-
-        // some modifications to the state
-        final int key2 = 10;
-        backend.setCurrentKey(key2);
-        assertNull(state.value());
-        assertNull(
-                getSerializedValue(
-                        kvState,
-                        key2,
-                        keySerializer,
-                        namespace,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.update("1");
-
-        final CheckedThread getter =
-                new CheckedThread("State getter") {
-                    @Override
-                    public void go() throws Exception {
-                        while (!isInterrupted()) {
-                            assertEquals("1", state.value());
+        final CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            final ValueState<String> state =
+                    backend.getPartitionedState(namespace, IntSerializer.INSTANCE, kvId);
+
+            // this is only available after the backend initialized the serializer
+            final TypeSerializer<String> valueSerializer = kvId.getSerializer();
+
+            @SuppressWarnings("unchecked")
+            final InternalKvState<Integer, Integer, String> kvState =
+                    (InternalKvState<Integer, Integer, String>) state;
+
+            /**
+             * 1) Test that ValueState#value() before and after KvState#getSerializedValue(byte[])
+             * return the same value.
+             */
+
+            // set some key and namespace
+            final int key1 = 1;
+            backend.setCurrentKey(key1);
+            kvState.setCurrentNamespace(2);
+            state.update("2");
+            assertEquals("2", state.value());
+
+            // query another key and namespace
+            assertNull(
+                    getSerializedValue(
+                            kvState,
+                            3,
+                            keySerializer,
+                            namespace,
+                            IntSerializer.INSTANCE,
+                            valueSerializer));
+
+            // the state should not have changed!
+            assertEquals("2", state.value());
+
+            // re-set values
+            kvState.setCurrentNamespace(namespace);
+
+            /**
+             * 2) Test two threads concurrently using ValueState#value() and
+             * KvState#getSerializedValue(byte[]).
+             */
+
+            // some modifications to the state
+            final int key2 = 10;
+            backend.setCurrentKey(key2);
+            assertNull(state.value());
+            assertNull(
+                    getSerializedValue(
+                            kvState,
+                            key2,
+                            keySerializer,
+                            namespace,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.update("1");
+
+            final CheckedThread getter =
+                    new CheckedThread("State getter") {
+                        @Override
+                        public void go() throws Exception {
+                            while (!isInterrupted()) {
+                                assertEquals("1", state.value());
+                            }
                         }
-                    }
-                };
-
-        final CheckedThread serializedGetter =
-                new CheckedThread("Serialized state getter") {
-                    @Override
-                    public void go() throws Exception {
-                        while (!isInterrupted() && getter.isAlive()) {
-                            final String serializedValue =
-                                    getSerializedValue(
-                                            kvState,
-                                            key2,
-                                            keySerializer,
-                                            namespace,
-                                            namespaceSerializer,
-                                            valueSerializer);
-                            assertEquals("1", serializedValue);
+                    };
+
+            final CheckedThread serializedGetter =
+                    new CheckedThread("Serialized state getter") {
+                        @Override
+                        public void go() throws Exception {
+                            while (!isInterrupted() && getter.isAlive()) {
+                                final String serializedValue =
+                                        getSerializedValue(
+                                                kvState,
+                                                key2,
+                                                keySerializer,
+                                                namespace,
+                                                namespaceSerializer,
+                                                valueSerializer);
+                                assertEquals("1", serializedValue);
+                            }
                         }
-                    }
-                };
-
-        getter.start();
-        serializedGetter.start();
-
-        // run both threads for max 100ms
-        Timer t = new Timer("stopper");
-        t.schedule(
-                new TimerTask() {
-                    @Override
-                    public void run() {
-                        getter.interrupt();
-                        serializedGetter.interrupt();
-                        this.cancel();
-                    }
-                },
-                100);
-
-        // wait for both threads to finish
-        try {
+                    };
+
+            getter.start();
+            serializedGetter.start();
+
+            // run both threads for max 100ms
+            Timer t = new Timer("stopper");
+            t.schedule(
+                    new TimerTask() {
+                        @Override
+                        public void run() {
+                            getter.interrupt();
+                            serializedGetter.interrupt();
+                            this.cancel();
+                        }
+                    },
+                    100);
+
+            // wait for both threads to finish
             // serializedGetter will finish if its assertion fails or if
             // getter is not alive any more
             serializedGetter.sync();
@@ -1613,6 +1634,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             t.cancel(); // if not executed yet
         } finally {
             // clean up
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -1622,71 +1644,75 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testMultipleValueStates() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE, 1, new KeyGroupRange(0, 0), env);
 
         ValueStateDescriptor<String> desc1 =
                 new ValueStateDescriptor<>("a-string", StringSerializer.INSTANCE);
         ValueStateDescriptor<Integer> desc2 =
                 new ValueStateDescriptor<>("an-integer", IntSerializer.INSTANCE);
 
-        ValueState<String> state1 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc1);
-        ValueState<Integer> state2 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc2);
-
-        // some modifications to the state
-        backend.setCurrentKey(1);
-        assertNull(state1.value());
-        assertNull(state2.value());
-        state1.update("1");
-
-        // state2 should still have nothing
-        assertEquals("1", state1.value());
-        assertNull(state2.value());
-        state2.update(13);
-
-        // both have some state now
-        assertEquals("1", state1.value());
-        assertEquals(13, (int) state2.value());
-
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE, 1, new KeyGroupRange(0, 0), env);
+        try {
+            ValueState<String> state1 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc1);
+            ValueState<Integer> state2 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc2);
 
-        backend.dispose();
-        backend =
-                restoreKeyedBackend(
-                        IntSerializer.INSTANCE,
-                        1,
-                        new KeyGroupRange(0, 0),
-                        Collections.singletonList(snapshot1),
-                        env);
+            // some modifications to the state
+            backend.setCurrentKey(1);
+            assertNull(state1.value());
+            assertNull(state2.value());
+            state1.update("1");
+
+            // state2 should still have nothing
+            assertEquals("1", state1.value());
+            assertNull(state2.value());
+            state2.update(13);
+
+            // both have some state now
+            assertEquals("1", state1.value());
+            assertEquals(13, (int) state2.value());
+
+            // draw a snapshot
+            KeyedStateHandle snapshot1 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
 
-        snapshot1.discardState();
+            backend.dispose();
+            backend =
+                    restoreKeyedBackend(
+                            IntSerializer.INSTANCE,
+                            1,
+                            new KeyGroupRange(0, 0),
+                            Collections.singletonList(snapshot1),
+                            env);
 
-        backend.setCurrentKey(1);
+            snapshot1.discardState();
 
-        state1 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc1);
-        state2 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc2);
+            backend.setCurrentKey(1);
 
-        // verify that they are still the same
-        assertEquals("1", state1.value());
-        assertEquals(13, (int) state2.value());
+            state1 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc1);
+            state2 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc2);
+
+            // verify that they are still the same
+            assertEquals("1", state1.value());
+            assertEquals(13, (int) state2.value());
 
-        backend.dispose();
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /**
@@ -1712,53 +1738,56 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ValueStateDescriptor<Long> kvId =
+                    new ValueStateDescriptor<>("id", LongSerializer.INSTANCE, 42L);
 
-        ValueStateDescriptor<Long> kvId =
-                new ValueStateDescriptor<>("id", LongSerializer.INSTANCE, 42L);
-
-        ValueState<Long> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        // some modifications to the state
-        backend.setCurrentKey(1);
+            ValueState<Long> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        // verify default value
-        assertEquals(42L, (long) state.value());
-        state.update(1L);
-        assertEquals(1L, (long) state.value());
+            // some modifications to the state
+            backend.setCurrentKey(1);
 
-        backend.setCurrentKey(2);
-        assertEquals(42L, (long) state.value());
+            // verify default value
+            assertEquals(42L, (long) state.value());
+            state.update(1L);
+            assertEquals(1L, (long) state.value());
 
-        backend.setCurrentKey(1);
-        state.clear();
-        assertEquals(42L, (long) state.value());
+            backend.setCurrentKey(2);
+            assertEquals(42L, (long) state.value());
 
-        state.update(17L);
-        assertEquals(17L, (long) state.value());
+            backend.setCurrentKey(1);
+            state.clear();
+            assertEquals(42L, (long) state.value());
 
-        state.update(null);
-        assertEquals(42L, (long) state.value());
+            state.update(17L);
+            assertEquals(17L, (long) state.value());
 
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            state.update(null);
+            assertEquals(42L, (long) state.value());
 
-        backend.dispose();
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
+            // draw a snapshot
+            KeyedStateHandle snapshot1 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
 
-        snapshot1.discardState();
+            backend.dispose();
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
 
-        backend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            snapshot1.discardState();
 
-        backend.dispose();
+            backend.getPartitionedState(
+                    VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
@@ -1766,224 +1795,227 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testListState() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
 
         ListStateDescriptor<String> kvId = new ListStateDescriptor<>("id", String.class);
 
         TypeSerializer<Integer> keySerializer = IntSerializer.INSTANCE;
         TypeSerializer<VoidNamespace> namespaceSerializer = VoidNamespaceSerializer.INSTANCE;
 
-        ListState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> kvState =
-                (InternalKvState<Integer, VoidNamespace, String>) state;
-
-        // this is only available after the backend initialized the serializer
-        TypeSerializer<String> valueSerializer = kvId.getElementSerializer();
-
-        Joiner joiner = Joiner.on(",");
-
-        // some modifications to the state
-        backend.setCurrentKey(1);
-        assertNull(state.get());
-        assertNull(
-                getSerializedList(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.add("1");
-
-        backend.setCurrentKey(2);
-        assertNull(state.get());
-        assertNull(
-                getSerializedList(
-                        kvState,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.update(Arrays.asList("2"));
-
-        backend.setCurrentKey(1);
-        assertEquals("1", joiner.join(state.get()));
-        assertEquals(
-                "1",
-                joiner.join(
-                        getSerializedList(
-                                kvState,
-                                1,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ListState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> kvState =
+                    (InternalKvState<Integer, VoidNamespace, String>) state;
 
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            // this is only available after the backend initialized the serializer
+            TypeSerializer<String> valueSerializer = kvId.getElementSerializer();
 
-        // make some more modifications
-        backend.setCurrentKey(1);
-        state.add("u1");
+            Joiner joiner = Joiner.on(",");
 
-        backend.setCurrentKey(2);
-        state.add("u2");
+            // some modifications to the state
+            backend.setCurrentKey(1);
+            assertNull(state.get());
+            assertNull(
+                    getSerializedList(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.add("1");
 
-        backend.setCurrentKey(3);
-        state.add("u3");
+            backend.setCurrentKey(2);
+            assertNull(state.get());
+            assertNull(
+                    getSerializedList(
+                            kvState,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.update(Arrays.asList("2"));
 
-        // draw another snapshot
-        KeyedStateHandle snapshot2 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462379L,
-                                4,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            backend.setCurrentKey(1);
+            assertEquals("1", joiner.join(state.get()));
+            assertEquals(
+                    "1",
+                    joiner.join(
+                            getSerializedList(
+                                    kvState,
+                                    1,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
 
-        // validate the original state
-        backend.setCurrentKey(1);
-        assertEquals("1,u1", joiner.join(state.get()));
-        assertEquals(
-                "1,u1",
-                joiner.join(
-                        getSerializedList(
-                                kvState,
-                                1,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.setCurrentKey(2);
-        assertEquals("2,u2", joiner.join(state.get()));
-        assertEquals(
-                "2,u2",
-                joiner.join(
-                        getSerializedList(
-                                kvState,
-                                2,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.setCurrentKey(3);
-        assertEquals("u3", joiner.join(state.get()));
-        assertEquals(
-                "u3",
-                joiner.join(
-                        getSerializedList(
-                                kvState,
-                                3,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.dispose();
-        // restore the first snapshot and validate it
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
-        snapshot1.discardState();
-
-        ListState<String> restored1 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> restoredKvState1 =
-                (InternalKvState<Integer, VoidNamespace, String>) restored1;
-
-        backend.setCurrentKey(1);
-        assertEquals("1", joiner.join(restored1.get()));
-        assertEquals(
-                "1",
-                joiner.join(
-                        getSerializedList(
-                                restoredKvState1,
-                                1,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.setCurrentKey(2);
-        assertEquals("2", joiner.join(restored1.get()));
-        assertEquals(
-                "2",
-                joiner.join(
-                        getSerializedList(
-                                restoredKvState1,
-                                2,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.dispose();
-        // restore the second snapshot and validate it
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot2);
-        snapshot2.discardState();
-
-        ListState<String> restored2 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> restoredKvState2 =
-                (InternalKvState<Integer, VoidNamespace, String>) restored2;
-
-        backend.setCurrentKey(1);
-        assertEquals("1,u1", joiner.join(restored2.get()));
-        assertEquals(
-                "1,u1",
-                joiner.join(
-                        getSerializedList(
-                                restoredKvState2,
-                                1,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.setCurrentKey(2);
-        assertEquals("2,u2", joiner.join(restored2.get()));
-        assertEquals(
-                "2,u2",
-                joiner.join(
-                        getSerializedList(
-                                restoredKvState2,
-                                2,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
-
-        backend.setCurrentKey(3);
-        assertEquals("u3", joiner.join(restored2.get()));
-        assertEquals(
-                "u3",
-                joiner.join(
-                        getSerializedList(
-                                restoredKvState2,
-                                3,
-                                keySerializer,
-                                VoidNamespace.INSTANCE,
-                                namespaceSerializer,
-                                valueSerializer)));
+            // draw a snapshot
+            KeyedStateHandle snapshot1 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // make some more modifications
+            backend.setCurrentKey(1);
+            state.add("u1");
+
+            backend.setCurrentKey(2);
+            state.add("u2");
+
+            backend.setCurrentKey(3);
+            state.add("u3");
+
+            // draw another snapshot
+            KeyedStateHandle snapshot2 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462379L,
+                                    4,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // validate the original state
+            backend.setCurrentKey(1);
+            assertEquals("1,u1", joiner.join(state.get()));
+            assertEquals(
+                    "1,u1",
+                    joiner.join(
+                            getSerializedList(
+                                    kvState,
+                                    1,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+
+            backend.setCurrentKey(2);
+            assertEquals("2,u2", joiner.join(state.get()));
+            assertEquals(
+                    "2,u2",
+                    joiner.join(
+                            getSerializedList(
+                                    kvState,
+                                    2,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+
+            backend.setCurrentKey(3);
+            assertEquals("u3", joiner.join(state.get()));
+            assertEquals(
+                    "u3",
+                    joiner.join(
+                            getSerializedList(
+                                    kvState,
+                                    3,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+
+            backend.dispose();
+            // restore the first snapshot and validate it
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
+            snapshot1.discardState();
+
+            ListState<String> restored1 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> restoredKvState1 =
+                    (InternalKvState<Integer, VoidNamespace, String>) restored1;
+
+            backend.setCurrentKey(1);
+            assertEquals("1", joiner.join(restored1.get()));
+            assertEquals(
+                    "1",
+                    joiner.join(
+                            getSerializedList(
+                                    restoredKvState1,
+                                    1,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+
+            backend.setCurrentKey(2);
+            assertEquals("2", joiner.join(restored1.get()));
+            assertEquals(
+                    "2",
+                    joiner.join(
+                            getSerializedList(
+                                    restoredKvState1,
+                                    2,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+
+            backend.dispose();
+            // restore the second snapshot and validate it
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot2);
+            snapshot2.discardState();
+
+            ListState<String> restored2 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> restoredKvState2 =
+                    (InternalKvState<Integer, VoidNamespace, String>) restored2;
+
+            backend.setCurrentKey(1);
+            assertEquals("1,u1", joiner.join(restored2.get()));
+            assertEquals(
+                    "1,u1",
+                    joiner.join(
+                            getSerializedList(
+                                    restoredKvState2,
+                                    1,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
 
-        backend.dispose();
+            backend.setCurrentKey(2);
+            assertEquals("2,u2", joiner.join(restored2.get()));
+            assertEquals(
+                    "2,u2",
+                    joiner.join(
+                            getSerializedList(
+                                    restoredKvState2,
+                                    2,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+
+            backend.setCurrentKey(3);
+            assertEquals("u3", joiner.join(restored2.get()));
+            assertEquals(
+                    "u3",
+                    joiner.join(
+                            getSerializedList(
+                                    restoredKvState2,
+                                    3,
+                                    keySerializer,
+                                    VoidNamespace.INSTANCE,
+                                    namespaceSerializer,
+                                    valueSerializer)));
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /**
@@ -1992,12 +2024,10 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
      */
     @Test
     public void testListStateAddNull() throws Exception {
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
-
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             ListState<Long> state =
                     keyedBackend.getPartitionedState(
@@ -2009,7 +2039,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             expectedException.expect(NullPointerException.class);
             state.add(null);
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2020,12 +2050,11 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
      */
     @Test
     public void testListStateAddAllNullEntries() throws Exception {
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
 
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             ListState<Long> state =
                     keyedBackend.getPartitionedState(
@@ -2042,7 +2071,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             adding.add(5L);
             state.addAll(adding);
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2053,12 +2082,11 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
      */
     @Test
     public void testListStateAddAllNull() throws Exception {
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
 
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             ListState<Long> state =
                     keyedBackend.getPartitionedState(
@@ -2070,7 +2098,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             expectedException.expect(NullPointerException.class);
             state.addAll(null);
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2081,12 +2109,11 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
      */
     @Test
     public void testListStateUpdateNullEntries() throws Exception {
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
 
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             ListState<Long> state =
                     keyedBackend.getPartitionedState(
@@ -2103,7 +2130,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             adding.add(5L);
             state.update(adding);
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2114,12 +2141,11 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
      */
     @Test
     public void testListStateUpdateNull() throws Exception {
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
 
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             ListState<Long> state =
                     keyedBackend.getPartitionedState(
@@ -2131,20 +2157,18 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             expectedException.expect(NullPointerException.class);
             state.update(null);
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
 
     @Test
     public void testListStateAPIs() throws Exception {
-
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
 
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             ListState<Long> state =
                     keyedBackend.getPartitionedState(
@@ -2209,17 +2233,13 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
 
     @Test
     public void testListStateMerging() throws Exception {
-
-        CheckpointableKeyedStateBackend<String> keyedBackend =
-                createKeyedBackend(StringSerializer.INSTANCE);
-
         final ListStateDescriptor<Long> stateDescr =
                 new ListStateDescriptor<>("my-state", Long.class);
 
@@ -2227,6 +2247,8 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         final Integer namespace2 = 2;
         final Integer namespace3 = 3;
 
+        CheckpointableKeyedStateBackend<String> keyedBackend =
+                createKeyedBackend(StringSerializer.INSTANCE);
         try {
             InternalListState<String, Integer, Long> state =
                     (InternalListState<String, Integer, Long>)
@@ -2320,224 +2342,227 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             state.setCurrentNamespace(namespace1);
             state.clear();
 
-            keyedBackend.setCurrentKey("mno");
-            state.setCurrentNamespace(namespace1);
-            state.clear();
+            keyedBackend.setCurrentKey("mno");
+            state.setCurrentNamespace(namespace1);
+            state.clear();
+
+            assertThat(
+                    "State backend is not empty.",
+                    ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
+                    is(0));
+        } finally {
+            IOUtils.closeQuietly(keyedBackend);
+            keyedBackend.dispose();
+        }
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testReducingState() throws Exception {
+        CheckpointStreamFactory streamFactory = createStreamFactory();
+        SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
+
+        ReducingStateDescriptor<String> kvId =
+                new ReducingStateDescriptor<>("id", new AppendingReduce(), String.class);
+
+        TypeSerializer<Integer> keySerializer = IntSerializer.INSTANCE;
+        TypeSerializer<VoidNamespace> namespaceSerializer = VoidNamespaceSerializer.INSTANCE;
+
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ReducingState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> kvState =
+                    (InternalKvState<Integer, VoidNamespace, String>) state;
+
+            // this is only available after the backend initialized the serializer
+            TypeSerializer<String> valueSerializer = kvId.getSerializer();
+
+            // some modifications to the state
+            backend.setCurrentKey(1);
+            assertNull(state.get());
+            assertNull(
+                    getSerializedValue(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.add("1");
+            backend.setCurrentKey(2);
+            assertNull(state.get());
+            assertNull(
+                    getSerializedValue(
+                            kvState,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            state.add("2");
+            backend.setCurrentKey(1);
+            assertEquals("1", state.get());
+            assertEquals(
+                    "1",
+                    getSerializedValue(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+
+            // draw a snapshot
+            KeyedStateHandle snapshot1 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // make some more modifications
+            backend.setCurrentKey(1);
+            state.add("u1");
+            backend.setCurrentKey(2);
+            state.add("u2");
+            backend.setCurrentKey(3);
+            state.add("u3");
 
-            assertThat(
-                    "State backend is not empty.",
-                    ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
-                    is(0));
-        } finally {
-            keyedBackend.close();
-            keyedBackend.dispose();
-        }
-    }
+            // draw another snapshot
+            KeyedStateHandle snapshot2 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462379L,
+                                    4,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
 
-    @Test
-    @SuppressWarnings("unchecked")
-    public void testReducingState() throws Exception {
-        CheckpointStreamFactory streamFactory = createStreamFactory();
-        SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
+            // validate the original state
+            backend.setCurrentKey(1);
+            assertEquals("1,u1", state.get());
+            assertEquals(
+                    "1,u1",
+                    getSerializedValue(
+                            kvState,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(2);
+            assertEquals("2,u2", state.get());
+            assertEquals(
+                    "2,u2",
+                    getSerializedValue(
+                            kvState,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(3);
+            assertEquals("u3", state.get());
+            assertEquals(
+                    "u3",
+                    getSerializedValue(
+                            kvState,
+                            3,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
 
-        ReducingStateDescriptor<String> kvId =
-                new ReducingStateDescriptor<>("id", new AppendingReduce(), String.class);
+            backend.dispose();
+            // restore the first snapshot and validate it
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
+            snapshot1.discardState();
 
-        TypeSerializer<Integer> keySerializer = IntSerializer.INSTANCE;
-        TypeSerializer<VoidNamespace> namespaceSerializer = VoidNamespaceSerializer.INSTANCE;
+            ReducingState<String> restored1 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> restoredKvState1 =
+                    (InternalKvState<Integer, VoidNamespace, String>) restored1;
 
-        ReducingState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> kvState =
-                (InternalKvState<Integer, VoidNamespace, String>) state;
-
-        // this is only available after the backend initialized the serializer
-        TypeSerializer<String> valueSerializer = kvId.getSerializer();
-
-        // some modifications to the state
-        backend.setCurrentKey(1);
-        assertNull(state.get());
-        assertNull(
-                getSerializedValue(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.add("1");
-        backend.setCurrentKey(2);
-        assertNull(state.get());
-        assertNull(
-                getSerializedValue(
-                        kvState,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        state.add("2");
-        backend.setCurrentKey(1);
-        assertEquals("1", state.get());
-        assertEquals(
-                "1",
-                getSerializedValue(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            backend.setCurrentKey(1);
+            assertEquals("1", restored1.get());
+            assertEquals(
+                    "1",
+                    getSerializedValue(
+                            restoredKvState1,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(2);
+            assertEquals("2", restored1.get());
+            assertEquals(
+                    "2",
+                    getSerializedValue(
+                            restoredKvState1,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
 
-        // make some more modifications
-        backend.setCurrentKey(1);
-        state.add("u1");
-        backend.setCurrentKey(2);
-        state.add("u2");
-        backend.setCurrentKey(3);
-        state.add("u3");
+            backend.dispose();
+            // restore the second snapshot and validate it
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot2);
+            snapshot2.discardState();
 
-        // draw another snapshot
-        KeyedStateHandle snapshot2 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462379L,
-                                4,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            ReducingState<String> restored2 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<Integer, VoidNamespace, String> restoredKvState2 =
+                    (InternalKvState<Integer, VoidNamespace, String>) restored2;
 
-        // validate the original state
-        backend.setCurrentKey(1);
-        assertEquals("1,u1", state.get());
-        assertEquals(
-                "1,u1",
-                getSerializedValue(
-                        kvState,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(2);
-        assertEquals("2,u2", state.get());
-        assertEquals(
-                "2,u2",
-                getSerializedValue(
-                        kvState,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(3);
-        assertEquals("u3", state.get());
-        assertEquals(
-                "u3",
-                getSerializedValue(
-                        kvState,
-                        3,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        backend.dispose();
-        // restore the first snapshot and validate it
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot1);
-        snapshot1.discardState();
-
-        ReducingState<String> restored1 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> restoredKvState1 =
-                (InternalKvState<Integer, VoidNamespace, String>) restored1;
-
-        backend.setCurrentKey(1);
-        assertEquals("1", restored1.get());
-        assertEquals(
-                "1",
-                getSerializedValue(
-                        restoredKvState1,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(2);
-        assertEquals("2", restored1.get());
-        assertEquals(
-                "2",
-                getSerializedValue(
-                        restoredKvState1,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        backend.dispose();
-        // restore the second snapshot and validate it
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot2);
-        snapshot2.discardState();
-
-        ReducingState<String> restored2 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<Integer, VoidNamespace, String> restoredKvState2 =
-                (InternalKvState<Integer, VoidNamespace, String>) restored2;
-
-        backend.setCurrentKey(1);
-        assertEquals("1,u1", restored2.get());
-        assertEquals(
-                "1,u1",
-                getSerializedValue(
-                        restoredKvState2,
-                        1,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(2);
-        assertEquals("2,u2", restored2.get());
-        assertEquals(
-                "2,u2",
-                getSerializedValue(
-                        restoredKvState2,
-                        2,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-        backend.setCurrentKey(3);
-        assertEquals("u3", restored2.get());
-        assertEquals(
-                "u3",
-                getSerializedValue(
-                        restoredKvState2,
-                        3,
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        valueSerializer));
-
-        backend.dispose();
+            backend.setCurrentKey(1);
+            assertEquals("1,u1", restored2.get());
+            assertEquals(
+                    "1,u1",
+                    getSerializedValue(
+                            restoredKvState2,
+                            1,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(2);
+            assertEquals("2,u2", restored2.get());
+            assertEquals(
+                    "2,u2",
+                    getSerializedValue(
+                            restoredKvState2,
+                            2,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+            backend.setCurrentKey(3);
+            assertEquals("u3", restored2.get());
+            assertEquals(
+                    "u3",
+                    getSerializedValue(
+                            restoredKvState2,
+                            3,
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            valueSerializer));
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
@@ -2594,7 +2619,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2716,7 +2741,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2776,7 +2801,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2899,7 +2924,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -2959,7 +2984,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -3082,7 +3107,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                     ((TestableKeyedStateBackend) keyedBackend).numKeyValueStateEntries(),
                     is(0));
         } finally {
-            keyedBackend.close();
+            IOUtils.closeQuietly(keyedBackend);
             keyedBackend.dispose();
         }
     }
@@ -3092,8 +3117,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testMapState() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        CheckpointableKeyedStateBackend<String> backend =
-                createKeyedBackend(StringSerializer.INSTANCE);
 
         MapStateDescriptor<Integer, String> kvId =
                 new MapStateDescriptor<>("id", Integer.class, String.class);
@@ -3101,323 +3124,328 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         TypeSerializer<String> keySerializer = StringSerializer.INSTANCE;
         TypeSerializer<VoidNamespace> namespaceSerializer = VoidNamespaceSerializer.INSTANCE;
 
-        MapState<Integer, String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<String, VoidNamespace, Map<Integer, String>> kvState =
-                (InternalKvState<String, VoidNamespace, Map<Integer, String>>) state;
-
-        // these are only available after the backend initialized the serializer
-        TypeSerializer<Integer> userKeySerializer = kvId.getKeySerializer();
-        TypeSerializer<String> userValueSerializer = kvId.getValueSerializer();
-
-        // some modifications to the state
-        backend.setCurrentKey("1");
-        assertNull(state.get(1));
-        assertNull(
-                getSerializedMap(
-                        kvState,
-                        "1",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        state.put(1, "1");
-        backend.setCurrentKey("2");
-        assertNull(state.get(2));
-        assertNull(
-                getSerializedMap(
-                        kvState,
-                        "2",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        state.put(2, "2");
-
-        // put entry with different userKeyOffset
-        backend.setCurrentKey("11");
-        state.put(11, "11");
-
-        backend.setCurrentKey("1");
-        assertTrue(state.contains(1));
-        assertEquals("1", state.get(1));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(1, "1");
-                    }
-                },
-                getSerializedMap(
-                        kvState,
-                        "1",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(11, "11");
-                    }
-                },
-                getSerializedMap(
-                        kvState,
-                        "11",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+        CheckpointableKeyedStateBackend<String> backend =
+                createKeyedBackend(StringSerializer.INSTANCE);
+        try {
+            MapState<Integer, String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<String, VoidNamespace, Map<Integer, String>> kvState =
+                    (InternalKvState<String, VoidNamespace, Map<Integer, String>>) state;
 
-        // make some more modifications
-        backend.setCurrentKey("1");
-        state.put(1, "101");
-        backend.setCurrentKey("2");
-        state.put(102, "102");
-        backend.setCurrentKey("3");
-        state.put(103, "103");
-        state.putAll(
-                new HashMap<Integer, String>() {
-                    {
-                        put(1031, "1031");
-                        put(1032, "1032");
-                    }
-                });
-
-        // draw another snapshot
-        KeyedStateHandle snapshot2 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462379L,
-                                4,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            // these are only available after the backend initialized the serializer
+            TypeSerializer<Integer> userKeySerializer = kvId.getKeySerializer();
+            TypeSerializer<String> userValueSerializer = kvId.getValueSerializer();
 
-        // validate the original state
-        backend.setCurrentKey("1");
-        assertEquals("101", state.get(1));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(1, "101");
-                    }
-                },
-                getSerializedMap(
-                        kvState,
-                        "1",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        backend.setCurrentKey("2");
-        assertEquals("102", state.get(102));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(2, "2");
-                        put(102, "102");
-                    }
-                },
-                getSerializedMap(
-                        kvState,
-                        "2",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        backend.setCurrentKey("3");
-        assertTrue(state.contains(103));
-        assertEquals("103", state.get(103));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(103, "103");
-                        put(1031, "1031");
-                        put(1032, "1032");
-                    }
-                },
-                getSerializedMap(
-                        kvState,
-                        "3",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-
-        List<Integer> keys = new ArrayList<>();
-        for (Integer key : state.keys()) {
-            keys.add(key);
-        }
-        List<Integer> expectedKeys = Arrays.asList(103, 1031, 1032);
-        assertEquals(keys.size(), expectedKeys.size());
-        keys.removeAll(expectedKeys);
+            // some modifications to the state
+            backend.setCurrentKey("1");
+            assertNull(state.get(1));
+            assertNull(
+                    getSerializedMap(
+                            kvState,
+                            "1",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            state.put(1, "1");
+            backend.setCurrentKey("2");
+            assertNull(state.get(2));
+            assertNull(
+                    getSerializedMap(
+                            kvState,
+                            "2",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            state.put(2, "2");
 
-        List<String> values = new ArrayList<>();
-        for (String value : state.values()) {
-            values.add(value);
-        }
-        List<String> expectedValues = Arrays.asList("103", "1031", "1032");
-        assertEquals(values.size(), expectedValues.size());
-        values.removeAll(expectedValues);
-
-        // make some more modifications
-        backend.setCurrentKey("1");
-        state.clear();
-        backend.setCurrentKey("2");
-        state.remove(102);
-        backend.setCurrentKey("3");
-        final String updateSuffix = "_updated";
-        Iterator<Map.Entry<Integer, String>> iterator = state.iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<Integer, String> entry = iterator.next();
-            if (entry.getValue().length() != 4) {
-                iterator.remove();
-            } else {
-                entry.setValue(entry.getValue() + updateSuffix);
+            // put entry with different userKeyOffset
+            backend.setCurrentKey("11");
+            state.put(11, "11");
+
+            backend.setCurrentKey("1");
+            assertTrue(state.contains(1));
+            assertEquals("1", state.get(1));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(1, "1");
+                        }
+                    },
+                    getSerializedMap(
+                            kvState,
+                            "1",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(11, "11");
+                        }
+                    },
+                    getSerializedMap(
+                            kvState,
+                            "11",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+
+            // draw a snapshot
+            KeyedStateHandle snapshot1 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // make some more modifications
+            backend.setCurrentKey("1");
+            state.put(1, "101");
+            backend.setCurrentKey("2");
+            state.put(102, "102");
+            backend.setCurrentKey("3");
+            state.put(103, "103");
+            state.putAll(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(1031, "1031");
+                            put(1032, "1032");
+                        }
+                    });
+
+            // draw another snapshot
+            KeyedStateHandle snapshot2 =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462379L,
+                                    4,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            // validate the original state
+            backend.setCurrentKey("1");
+            assertEquals("101", state.get(1));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(1, "101");
+                        }
+                    },
+                    getSerializedMap(
+                            kvState,
+                            "1",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            backend.setCurrentKey("2");
+            assertEquals("102", state.get(102));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(2, "2");
+                            put(102, "102");
+                        }
+                    },
+                    getSerializedMap(
+                            kvState,
+                            "2",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            backend.setCurrentKey("3");
+            assertTrue(state.contains(103));
+            assertEquals("103", state.get(103));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(103, "103");
+                            put(1031, "1031");
+                            put(1032, "1032");
+                        }
+                    },
+                    getSerializedMap(
+                            kvState,
+                            "3",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+
+            List<Integer> keys = new ArrayList<>();
+            for (Integer key : state.keys()) {
+                keys.add(key);
             }
-        }
+            List<Integer> expectedKeys = Arrays.asList(103, 1031, 1032);
+            assertEquals(keys.size(), expectedKeys.size());
+            keys.removeAll(expectedKeys);
 
-        // validate the state
-        backend.setCurrentKey("1");
-        backend.setCurrentKey("2");
-        assertFalse(state.contains(102));
-        backend.setCurrentKey("3");
-        for (Map.Entry<Integer, String> entry : state.entries()) {
-            assertEquals(4 + updateSuffix.length(), entry.getValue().length());
-            assertTrue(entry.getValue().endsWith(updateSuffix));
-        }
+            List<String> values = new ArrayList<>();
+            for (String value : state.values()) {
+                values.add(value);
+            }
+            List<String> expectedValues = Arrays.asList("103", "1031", "1032");
+            assertEquals(values.size(), expectedValues.size());
+            values.removeAll(expectedValues);
+
+            // make some more modifications
+            backend.setCurrentKey("1");
+            state.clear();
+            backend.setCurrentKey("2");
+            state.remove(102);
+            backend.setCurrentKey("3");
+            final String updateSuffix = "_updated";
+            Iterator<Map.Entry<Integer, String>> iterator = state.iterator();
+            while (iterator.hasNext()) {
+                Map.Entry<Integer, String> entry = iterator.next();
+                if (entry.getValue().length() != 4) {
+                    iterator.remove();
+                } else {
+                    entry.setValue(entry.getValue() + updateSuffix);
+                }
+            }
+
+            // validate the state
+            backend.setCurrentKey("1");
+            backend.setCurrentKey("2");
+            assertFalse(state.contains(102));
+            backend.setCurrentKey("3");
+            for (Map.Entry<Integer, String> entry : state.entries()) {
+                assertEquals(4 + updateSuffix.length(), entry.getValue().length());
+                assertTrue(entry.getValue().endsWith(updateSuffix));
+            }
+
+            backend.dispose();
+            // restore the first snapshot and validate it
+            backend = restoreKeyedBackend(StringSerializer.INSTANCE, snapshot1);
+            snapshot1.discardState();
+
+            MapState<Integer, String> restored1 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<String, VoidNamespace, Map<Integer, String>> restoredKvState1 =
+                    (InternalKvState<String, VoidNamespace, Map<Integer, String>>) restored1;
+
+            backend.setCurrentKey("1");
+            assertEquals("1", restored1.get(1));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(1, "1");
+                        }
+                    },
+                    getSerializedMap(
+                            restoredKvState1,
+                            "1",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            backend.setCurrentKey("2");
+            assertEquals("2", restored1.get(2));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(2, "2");
+                        }
+                    },
+                    getSerializedMap(
+                            restoredKvState1,
+                            "2",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+
+            backend.dispose();
+            // restore the second snapshot and validate it
+            backend = restoreKeyedBackend(StringSerializer.INSTANCE, snapshot2);
+            snapshot2.discardState();
+
+            @SuppressWarnings("unchecked")
+            MapState<Integer, String> restored2 =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+            @SuppressWarnings("unchecked")
+            InternalKvState<String, VoidNamespace, Map<Integer, String>> restoredKvState2 =
+                    (InternalKvState<String, VoidNamespace, Map<Integer, String>>) restored2;
 
-        backend.dispose();
-        // restore the first snapshot and validate it
-        backend = restoreKeyedBackend(StringSerializer.INSTANCE, snapshot1);
-        snapshot1.discardState();
-
-        MapState<Integer, String> restored1 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<String, VoidNamespace, Map<Integer, String>> restoredKvState1 =
-                (InternalKvState<String, VoidNamespace, Map<Integer, String>>) restored1;
-
-        backend.setCurrentKey("1");
-        assertEquals("1", restored1.get(1));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(1, "1");
-                    }
-                },
-                getSerializedMap(
-                        restoredKvState1,
-                        "1",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        backend.setCurrentKey("2");
-        assertEquals("2", restored1.get(2));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(2, "2");
-                    }
-                },
-                getSerializedMap(
-                        restoredKvState1,
-                        "2",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-
-        backend.dispose();
-        // restore the second snapshot and validate it
-        backend = restoreKeyedBackend(StringSerializer.INSTANCE, snapshot2);
-        snapshot2.discardState();
-
-        @SuppressWarnings("unchecked")
-        MapState<Integer, String> restored2 =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-        @SuppressWarnings("unchecked")
-        InternalKvState<String, VoidNamespace, Map<Integer, String>> restoredKvState2 =
-                (InternalKvState<String, VoidNamespace, Map<Integer, String>>) restored2;
-
-        backend.setCurrentKey("1");
-        assertEquals("101", restored2.get(1));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(1, "101");
-                    }
-                },
-                getSerializedMap(
-                        restoredKvState2,
-                        "1",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        backend.setCurrentKey("2");
-        assertEquals("102", restored2.get(102));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(2, "2");
-                        put(102, "102");
-                    }
-                },
-                getSerializedMap(
-                        restoredKvState2,
-                        "2",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-        backend.setCurrentKey("3");
-        assertEquals("103", restored2.get(103));
-        assertEquals(
-                new HashMap<Integer, String>() {
-                    {
-                        put(103, "103");
-                        put(1031, "1031");
-                        put(1032, "1032");
-                    }
-                },
-                getSerializedMap(
-                        restoredKvState2,
-                        "3",
-                        keySerializer,
-                        VoidNamespace.INSTANCE,
-                        namespaceSerializer,
-                        userKeySerializer,
-                        userValueSerializer));
-
-        backend.dispose();
+            backend.setCurrentKey("1");
+            assertEquals("101", restored2.get(1));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(1, "101");
+                        }
+                    },
+                    getSerializedMap(
+                            restoredKvState2,
+                            "1",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            backend.setCurrentKey("2");
+            assertEquals("102", restored2.get(102));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(2, "2");
+                            put(102, "102");
+                        }
+                    },
+                    getSerializedMap(
+                            restoredKvState2,
+                            "2",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+            backend.setCurrentKey("3");
+            assertEquals("103", restored2.get(103));
+            assertEquals(
+                    new HashMap<Integer, String>() {
+                        {
+                            put(103, "103");
+                            put(1031, "1031");
+                            put(1032, "1032");
+                        }
+                    },
+                    getSerializedMap(
+                            restoredKvState2,
+                            "3",
+                            keySerializer,
+                            VoidNamespace.INSTANCE,
+                            namespaceSerializer,
+                            userKeySerializer,
+                            userValueSerializer));
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
@@ -3448,6 +3476,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             assertTrue(state.isEmpty());
 
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -3499,6 +3528,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             }
             assertEquals(stateSize, iteratorCount);
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -3506,139 +3536,151 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     /** Verify that {@link ValueStateDescriptor} allows {@code null} as default. */
     @Test
     public void testValueStateNullAsDefaultValue() throws Exception {
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class, null);
 
-        ValueState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ValueState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        backend.setCurrentKey(1);
-        assertNull(state.value());
+            backend.setCurrentKey(1);
+            assertNull(state.value());
 
-        state.update("Ciao");
-        assertEquals("Ciao", state.value());
+            state.update("Ciao");
+            assertEquals("Ciao", state.value());
 
-        state.clear();
-        assertNull(state.value());
+            state.clear();
+            assertNull(state.value());
 
-        backend.dispose();
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /** Verify that an empty {@code ValueState} will yield the default value. */
     @Test
     public void testValueStateDefaultValue() throws Exception {
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class, "Hello");
 
-        ValueState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        backend.setCurrentKey(1);
-        assertEquals("Hello", state.value());
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ValueState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        state.update("Ciao");
-        assertEquals("Ciao", state.value());
+            backend.setCurrentKey(1);
+            assertEquals("Hello", state.value());
 
-        state.clear();
-        assertEquals("Hello", state.value());
+            state.update("Ciao");
+            assertEquals("Ciao", state.value());
 
-        backend.dispose();
+            state.clear();
+            assertEquals("Hello", state.value());
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /** Verify that an empty {@code ReduceState} yields {@code null}. */
     @Test
     public void testReducingStateDefaultValue() throws Exception {
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ReducingStateDescriptor<String> kvId =
                 new ReducingStateDescriptor<>("id", new AppendingReduce(), String.class);
 
-        ReducingState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        backend.setCurrentKey(1);
-        assertNull(state.get());
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ReducingState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        state.add("Ciao");
-        assertEquals("Ciao", state.get());
+            backend.setCurrentKey(1);
+            assertNull(state.get());
 
-        state.clear();
-        assertNull(state.get());
+            state.add("Ciao");
+            assertEquals("Ciao", state.get());
 
-        backend.dispose();
+            state.clear();
+            assertNull(state.get());
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /** Verify that an empty {@code ListState} yields {@code null}. */
     @Test
     public void testListStateDefaultValue() throws Exception {
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ListStateDescriptor<String> kvId = new ListStateDescriptor<>("id", String.class);
 
-        ListState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        backend.setCurrentKey(1);
-        assertNull(state.get());
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ListState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        state.update(Arrays.asList("Ciao", "Bello"));
-        assertThat(state.get(), containsInAnyOrder("Ciao", "Bello"));
+            backend.setCurrentKey(1);
+            assertNull(state.get());
 
-        state.clear();
-        assertNull(state.get());
+            state.update(Arrays.asList("Ciao", "Bello"));
+            assertThat(state.get(), containsInAnyOrder("Ciao", "Bello"));
 
-        backend.dispose();
+            state.clear();
+            assertNull(state.get());
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /** Verify that an empty {@code MapState} yields {@code null}. */
     @Test
     public void testMapStateDefaultValue() throws Exception {
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         MapStateDescriptor<String, String> kvId =
                 new MapStateDescriptor<>("id", String.class, String.class);
 
-        MapState<String, String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        backend.setCurrentKey(1);
-        assertNotNull(state.entries());
-        assertFalse(state.entries().iterator().hasNext());
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            MapState<String, String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        state.put("Ciao", "Hello");
-        state.put("Bello", "Nice");
+            backend.setCurrentKey(1);
+            assertNotNull(state.entries());
+            assertFalse(state.entries().iterator().hasNext());
 
-        assertNotNull(state.entries());
-        assertEquals(state.get("Ciao"), "Hello");
-        assertEquals(state.get("Bello"), "Nice");
+            state.put("Ciao", "Hello");
+            state.put("Bello", "Nice");
 
-        state.clear();
-        assertNotNull(state.entries());
-        assertFalse(state.entries().iterator().hasNext());
+            assertNotNull(state.entries());
+            assertEquals(state.get("Ciao"), "Hello");
+            assertEquals(state.get("Bello"), "Nice");
 
-        backend.dispose();
+            state.clear();
+            assertNotNull(state.entries());
+            assertFalse(state.entries().iterator().hasNext());
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
     public void testSnapshotNonAccessedState() throws Exception {
         CheckpointStreamFactory streamFactory = createStreamFactory();
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
+        final String stateName = "test-name";
+
         CheckpointableKeyedStateBackend<String> backend =
                 createKeyedBackend(StringSerializer.INSTANCE);
 
-        final String stateName = "test-name";
         try {
             MapStateDescriptor<Integer, String> kvId =
                     new MapStateDescriptor<>(stateName, Integer.class, String.class);
@@ -3693,6 +3735,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
 
             snapshot.discardState();
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -3778,66 +3821,55 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
 
         Random random = new Random();
 
-        CheckpointStreamFactory streamFactory = createStreamFactory();
-        SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-        List<KeyGroupRange> keyGroupRanges = new ArrayList<>();
-        List<CheckpointableKeyedStateBackend<Integer>> stateBackends = new ArrayList<>();
-        for (int i = 0; i < sourceParallelism; ++i) {
-            keyGroupRanges.add(
-                    KeyGroupRange.of(
-                            maxParallelism * i / sourceParallelism,
-                            maxParallelism * (i + 1) / sourceParallelism - 1));
-            stateBackends.add(
-                    createKeyedBackend(
-                            IntSerializer.INSTANCE, maxParallelism, keyGroupRanges.get(i), env));
-        }
-
         List<ValueStateDescriptor<String>> stateDescriptors = new ArrayList<>(maxParallelism);
-
+        List<Integer> keyInKeyGroups = new ArrayList<>(maxParallelism);
+        List<String> expectedValue = new ArrayList<>(maxParallelism);
         for (int i = 0; i < maxParallelism; ++i) {
             // all states have different name to mock that all the parallelisms of one operator have
             // different states.
             stateDescriptors.add(new ValueStateDescriptor<>("state" + i, String.class));
         }
 
-        List<Integer> keyInKeyGroups = new ArrayList<>(maxParallelism);
-        List<String> expectedValue = new ArrayList<>(maxParallelism);
-        for (int i = 0; i < sourceParallelism; ++i) {
-            CheckpointableKeyedStateBackend<Integer> backend = stateBackends.get(i);
-            KeyGroupRange range = keyGroupRanges.get(i);
-            for (int j = range.getStartKeyGroup(); j <= range.getEndKeyGroup(); ++j) {
-                ValueState<String> state =
-                        backend.getPartitionedState(
-                                VoidNamespace.INSTANCE,
-                                VoidNamespaceSerializer.INSTANCE,
-                                stateDescriptors.get(j));
-                int keyInKeyGroup =
-                        getKeyInKeyGroup(random, maxParallelism, KeyGroupRange.of(j, j));
-                backend.setCurrentKey(keyInKeyGroup);
-                keyInKeyGroups.add(keyInKeyGroup);
-                String updateValue = i + ":" + j;
-                state.update(updateValue);
-                expectedValue.add(updateValue);
-            }
-        }
+        CheckpointStreamFactory streamFactory = createStreamFactory();
+        SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 
-        // snapshot
         List<KeyedStateHandle> snapshots = new ArrayList<>(sourceParallelism);
         for (int i = 0; i < sourceParallelism; ++i) {
-            snapshots.add(
-                    runSnapshot(
-                            stateBackends
-                                    .get(i)
-                                    .snapshot(
-                                            0,
-                                            0,
-                                            streamFactory,
-                                            CheckpointOptions.forCheckpointWithDefaultLocation()),
-                            sharedStateRegistry));
-        }
+            KeyGroupRange range =
+                    KeyGroupRange.of(
+                            maxParallelism * i / sourceParallelism,
+                            maxParallelism * (i + 1) / sourceParallelism - 1);
+            CheckpointableKeyedStateBackend<Integer> backend =
+                    createKeyedBackend(IntSerializer.INSTANCE, maxParallelism, range, env);
+            try {
+                for (int j = range.getStartKeyGroup(); j <= range.getEndKeyGroup(); ++j) {
+                    ValueState<String> state =
+                            backend.getPartitionedState(
+                                    VoidNamespace.INSTANCE,
+                                    VoidNamespaceSerializer.INSTANCE,
+                                    stateDescriptors.get(j));
+                    int keyInKeyGroup =
+                            getKeyInKeyGroup(random, maxParallelism, KeyGroupRange.of(j, j));
+                    backend.setCurrentKey(keyInKeyGroup);
+                    keyInKeyGroups.add(keyInKeyGroup);
+                    String updateValue = i + ":" + j;
+                    state.update(updateValue);
+                    expectedValue.add(updateValue);
+                }
 
-        for (int i = 0; i < sourceParallelism; ++i) {
-            stateBackends.get(i).dispose();
+                // snapshot
+                snapshots.add(
+                        runSnapshot(
+                                backend.snapshot(
+                                        0,
+                                        0,
+                                        streamFactory,
+                                        CheckpointOptions.forCheckpointWithDefaultLocation()),
+                                sharedStateRegistry));
+            } finally {
+                IOUtils.closeQuietly(backend);
+                backend.dispose();
+            }
         }
 
         // redistribute the stateHandle
@@ -3857,9 +3889,6 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         }
 
         // restore and verify
-        List<CheckpointableKeyedStateBackend<Integer>> targetBackends =
-                new ArrayList<>(targetParallelism);
-
         for (int i = 0; i < targetParallelism; ++i) {
             CheckpointableKeyedStateBackend<Integer> backend =
                     restoreKeyedBackend(
@@ -3868,24 +3897,22 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                             keyGroupRangesRestore.get(i),
                             keyGroupStatesAfterDistribute.get(i),
                             env);
-            targetBackends.add(backend);
-            KeyGroupRange range = keyGroupRangesRestore.get(i);
-            for (int j = range.getStartKeyGroup(); j <= range.getEndKeyGroup(); ++j) {
-                ValueState<String> state =
-                        targetBackends
-                                .get(i)
-                                .getPartitionedState(
-                                        VoidNamespace.INSTANCE,
-                                        VoidNamespaceSerializer.INSTANCE,
-                                        stateDescriptors.get(j));
-                backend.setCurrentKey(keyInKeyGroups.get(j));
-                assertEquals(expectedValue.get(j), state.value());
+            try {
+                KeyGroupRange range = keyGroupRangesRestore.get(i);
+                for (int j = range.getStartKeyGroup(); j <= range.getEndKeyGroup(); ++j) {
+                    ValueState<String> state =
+                            backend.getPartitionedState(
+                                    VoidNamespace.INSTANCE,
+                                    VoidNamespaceSerializer.INSTANCE,
+                                    stateDescriptors.get(j));
+                    backend.setCurrentKey(keyInKeyGroups.get(j));
+                    assertEquals(expectedValue.get(j), state.value());
+                }
+            } finally {
+                IOUtils.closeQuietly(backend);
+                backend.dispose();
             }
         }
-
-        for (int i = 0; i < targetParallelism; ++i) {
-            targetBackends.get(i).dispose();
-        }
     }
 
     @Test
@@ -3894,37 +3921,40 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
 
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 
+        ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class);
+
+        KeyedStateHandle snapshot = null;
         // use an IntSerializer at first
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ValueState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class);
-
-        ValueState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        // write some state
-        backend.setCurrentKey(1);
-        state.update("1");
-        backend.setCurrentKey(2);
-        state.update("2");
-
-        // draw a snapshot
-        KeyedStateHandle snapshot1 =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462378L,
-                                2,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            // write some state
+            backend.setCurrentKey(1);
+            state.update("1");
+            backend.setCurrentKey(2);
+            state.update("2");
 
-        backend.dispose();
+            // draw a snapshot
+            snapshot =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462378L,
+                                    2,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
 
         // restore with the wrong key serializer
         try {
-            restoreKeyedBackend(DoubleSerializer.INSTANCE, snapshot1);
+            restoreKeyedBackend(DoubleSerializer.INSTANCE, snapshot);
 
             fail("should recognize wrong key serializer");
         } catch (StateMigrationException ignored) {
@@ -3987,6 +4017,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 // expected
             }
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -4043,6 +4074,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 // expected
             }
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -4103,6 +4135,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                 // expected
             }
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -4162,36 +4195,38 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             } catch (StateMigrationException ignored) {
                 // expected
             }
-            backend.dispose();
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
 
     @Test
     public void testCopyDefaultValue() throws Exception {
-        final CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ValueStateDescriptor<IntValue> kvId =
                 new ValueStateDescriptor<>("id", IntValue.class, new IntValue(-1));
 
-        ValueState<IntValue> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
-
-        backend.setCurrentKey(1);
-        IntValue default1 = state.value();
+        final CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            ValueState<IntValue> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        backend.setCurrentKey(2);
-        IntValue default2 = state.value();
+            backend.setCurrentKey(1);
+            IntValue default1 = state.value();
 
-        assertNotNull(default1);
-        assertNotNull(default2);
-        assertEquals(default1, default2);
-        assertFalse(default1 == default2);
+            backend.setCurrentKey(2);
+            IntValue default2 = state.value();
 
-        backend.dispose();
+            assertNotNull(default1);
+            assertNotNull(default2);
+            assertEquals(default1, default2);
+            assertFalse(default1 == default2);
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     /**
@@ -4200,31 +4235,33 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
      */
     @Test
     public void testRequireNonNullNamespace() throws Exception {
-        final CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ValueStateDescriptor<IntValue> kvId =
                 new ValueStateDescriptor<>("id", IntValue.class, new IntValue(-1));
 
+        final CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
         try {
-            backend.getPartitionedState(null, VoidNamespaceSerializer.INSTANCE, kvId);
-            fail("Did not throw expected NullPointerException");
-        } catch (NullPointerException ignored) {
-        }
+            try {
+                backend.getPartitionedState(null, VoidNamespaceSerializer.INSTANCE, kvId);
+                fail("Did not throw expected NullPointerException");
+            } catch (NullPointerException ignored) {
+            }
 
-        try {
-            backend.getPartitionedState(VoidNamespace.INSTANCE, null, kvId);
-            fail("Did not throw expected NullPointerException");
-        } catch (NullPointerException ignored) {
-        }
+            try {
+                backend.getPartitionedState(VoidNamespace.INSTANCE, null, kvId);
+                fail("Did not throw expected NullPointerException");
+            } catch (NullPointerException ignored) {
+            }
 
-        try {
-            backend.getPartitionedState(null, null, kvId);
-            fail("Did not throw expected NullPointerException");
-        } catch (NullPointerException ignored) {
+            try {
+                backend.getPartitionedState(null, null, kvId);
+                fail("Did not throw expected NullPointerException");
+            } catch (NullPointerException ignored) {
+            }
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
         }
-
-        backend.dispose();
     }
 
     /**
@@ -4241,106 +4278,112 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
                         new KeyGroupRange(0, 0),
                         new DummyEnvironment());
 
-        {
-            // ValueState
-            ValueStateDescriptor<Integer> desc =
-                    new ValueStateDescriptor<>("value-state", Integer.class, -1);
-            desc.setQueryable("my-query");
+        try {
+            {
+                // ValueState
+                ValueStateDescriptor<Integer> desc =
+                        new ValueStateDescriptor<>("value-state", Integer.class, -1);
+                desc.setQueryable("my-query");
 
-            ValueState<Integer> state =
-                    backend.getPartitionedState(
-                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
+                ValueState<Integer> state =
+                        backend.getPartitionedState(
+                                VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
 
-            InternalKvState<Integer, VoidNamespace, Integer> kvState =
-                    (InternalKvState<Integer, VoidNamespace, Integer>) state;
-            assertTrue(kvState instanceof AbstractHeapState);
+                InternalKvState<Integer, VoidNamespace, Integer> kvState =
+                        (InternalKvState<Integer, VoidNamespace, Integer>) state;
+                assertTrue(kvState instanceof AbstractHeapState);
 
-            kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
-            backend.setCurrentKey(1);
-            state.update(121818273);
+                kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
+                backend.setCurrentKey(1);
+                state.update(121818273);
 
-            StateTable<?, ?, ?> stateTable = ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
-            checkConcurrentStateTable(stateTable, numberOfKeyGroups);
-        }
+                StateTable<?, ?, ?> stateTable =
+                        ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
+                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+            }
 
-        {
-            // ListState
-            ListStateDescriptor<Integer> desc =
-                    new ListStateDescriptor<>("list-state", Integer.class);
-            desc.setQueryable("my-query");
+            {
+                // ListState
+                ListStateDescriptor<Integer> desc =
+                        new ListStateDescriptor<>("list-state", Integer.class);
+                desc.setQueryable("my-query");
 
-            ListState<Integer> state =
-                    backend.getPartitionedState(
-                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
+                ListState<Integer> state =
+                        backend.getPartitionedState(
+                                VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
 
-            InternalKvState<Integer, VoidNamespace, Integer> kvState =
-                    (InternalKvState<Integer, VoidNamespace, Integer>) state;
-            assertTrue(kvState instanceof AbstractHeapState);
+                InternalKvState<Integer, VoidNamespace, Integer> kvState =
+                        (InternalKvState<Integer, VoidNamespace, Integer>) state;
+                assertTrue(kvState instanceof AbstractHeapState);
 
-            kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
-            backend.setCurrentKey(1);
-            state.add(121818273);
+                kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
+                backend.setCurrentKey(1);
+                state.add(121818273);
 
-            StateTable<?, ?, ?> stateTable = ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
-            checkConcurrentStateTable(stateTable, numberOfKeyGroups);
-        }
+                StateTable<?, ?, ?> stateTable =
+                        ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
+                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+            }
 
-        {
-            // ReducingState
-            ReducingStateDescriptor<Integer> desc =
-                    new ReducingStateDescriptor<>(
-                            "reducing-state",
-                            new ReduceFunction<Integer>() {
-                                @Override
-                                public Integer reduce(Integer value1, Integer value2)
-                                        throws Exception {
-                                    return value1 + value2;
-                                }
-                            },
-                            Integer.class);
-            desc.setQueryable("my-query");
-
-            ReducingState<Integer> state =
-                    backend.getPartitionedState(
-                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
+            {
+                // ReducingState
+                ReducingStateDescriptor<Integer> desc =
+                        new ReducingStateDescriptor<>(
+                                "reducing-state",
+                                new ReduceFunction<Integer>() {
+                                    @Override
+                                    public Integer reduce(Integer value1, Integer value2)
+                                            throws Exception {
+                                        return value1 + value2;
+                                    }
+                                },
+                                Integer.class);
+                desc.setQueryable("my-query");
+
+                ReducingState<Integer> state =
+                        backend.getPartitionedState(
+                                VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
 
-            InternalKvState<Integer, VoidNamespace, Integer> kvState =
-                    (InternalKvState<Integer, VoidNamespace, Integer>) state;
-            assertTrue(kvState instanceof AbstractHeapState);
+                InternalKvState<Integer, VoidNamespace, Integer> kvState =
+                        (InternalKvState<Integer, VoidNamespace, Integer>) state;
+                assertTrue(kvState instanceof AbstractHeapState);
 
-            kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
-            backend.setCurrentKey(1);
-            state.add(121818273);
+                kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
+                backend.setCurrentKey(1);
+                state.add(121818273);
 
-            StateTable<?, ?, ?> stateTable = ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
-            checkConcurrentStateTable(stateTable, numberOfKeyGroups);
-        }
+                StateTable<?, ?, ?> stateTable =
+                        ((AbstractHeapState<?, ?, ?>) kvState).getStateTable();
+                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+            }
 
-        {
-            // MapState
-            MapStateDescriptor<Integer, String> desc =
-                    new MapStateDescriptor<>("map-state", Integer.class, String.class);
-            desc.setQueryable("my-query");
+            {
+                // MapState
+                MapStateDescriptor<Integer, String> desc =
+                        new MapStateDescriptor<>("map-state", Integer.class, String.class);
+                desc.setQueryable("my-query");
 
-            MapState<Integer, String> state =
-                    backend.getPartitionedState(
-                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
+                MapState<Integer, String> state =
+                        backend.getPartitionedState(
+                                VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
 
-            InternalKvState<Integer, VoidNamespace, Map<Integer, String>> kvState =
-                    (InternalKvState<Integer, VoidNamespace, Map<Integer, String>>) state;
-            assertTrue(kvState instanceof AbstractHeapState);
+                InternalKvState<Integer, VoidNamespace, Map<Integer, String>> kvState =
+                        (InternalKvState<Integer, VoidNamespace, Map<Integer, String>>) state;
+                assertTrue(kvState instanceof AbstractHeapState);
 
-            kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
-            backend.setCurrentKey(1);
-            state.put(121818273, "121818273");
+                kvState.setCurrentNamespace(VoidNamespace.INSTANCE);
+                backend.setCurrentKey(1);
+                state.put(121818273, "121818273");
 
-            int keyGroupIndex = KeyGroupRangeAssignment.assignToKeyGroup(1, numberOfKeyGroups);
-            StateTable stateTable = ((AbstractHeapState) kvState).getStateTable();
-            assertNotNull("State not set", stateTable.get(keyGroupIndex));
-            checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+                int keyGroupIndex = KeyGroupRangeAssignment.assignToKeyGroup(1, numberOfKeyGroups);
+                StateTable stateTable = ((AbstractHeapState) kvState).getStateTable();
+                assertNotNull("State not set", stateTable.get(keyGroupIndex));
+                checkConcurrentStateTable(stateTable, numberOfKeyGroups);
+            }
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
         }
-
-        backend.dispose();
     }
 
     private void checkConcurrentStateTable(StateTable<?, ?, ?> stateTable, int numberOfKeyGroups) {
@@ -4368,70 +4411,75 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE, env);
-        KeyGroupRange expectedKeyGroupRange = backend.getKeyGroupRange();
+        try {
+            KeyGroupRange expectedKeyGroupRange = backend.getKeyGroupRange();
 
-        KvStateRegistryListener listener = mock(KvStateRegistryListener.class);
-        registry.registerListener(HighAvailabilityServices.DEFAULT_JOB_ID, listener);
+            KvStateRegistryListener listener = mock(KvStateRegistryListener.class);
+            registry.registerListener(HighAvailabilityServices.DEFAULT_JOB_ID, listener);
 
-        ValueStateDescriptor<Integer> desc =
-                new ValueStateDescriptor<>("test", IntSerializer.INSTANCE);
-        desc.setQueryable("banana");
+            ValueStateDescriptor<Integer> desc =
+                    new ValueStateDescriptor<>("test", IntSerializer.INSTANCE);
+            desc.setQueryable("banana");
 
-        backend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
+            backend.getPartitionedState(
+                    VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
 
-        // Verify registered
-        verify(listener, times(1))
-                .notifyKvStateRegistered(
-                        eq(env.getJobID()),
-                        eq(env.getJobVertexId()),
-                        eq(expectedKeyGroupRange),
-                        eq("banana"),
-                        any(KvStateID.class));
+            // Verify registered
+            verify(listener, times(1))
+                    .notifyKvStateRegistered(
+                            eq(env.getJobID()),
+                            eq(env.getJobVertexId()),
+                            eq(expectedKeyGroupRange),
+                            eq("banana"),
+                            any(KvStateID.class));
 
-        KeyedStateHandle snapshot =
-                runSnapshot(
-                        backend.snapshot(
-                                682375462379L,
-                                4,
-                                streamFactory,
-                                CheckpointOptions.forCheckpointWithDefaultLocation()),
-                        sharedStateRegistry);
+            KeyedStateHandle snapshot =
+                    runSnapshot(
+                            backend.snapshot(
+                                    682375462379L,
+                                    4,
+                                    streamFactory,
+                                    CheckpointOptions.forCheckpointWithDefaultLocation()),
+                            sharedStateRegistry);
+
+            backend.dispose();
+
+            verify(listener, times(1))
+                    .notifyKvStateUnregistered(
+                            eq(env.getJobID()),
+                            eq(env.getJobVertexId()),
+                            eq(expectedKeyGroupRange),
+                            eq("banana"));
+            backend.dispose();
+            // Initialize again
+            backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot, env);
+            snapshot.discardState();
 
-        backend.dispose();
-
-        verify(listener, times(1))
-                .notifyKvStateUnregistered(
-                        eq(env.getJobID()),
-                        eq(env.getJobVertexId()),
-                        eq(expectedKeyGroupRange),
-                        eq("banana"));
-        backend.dispose();
-        // Initialize again
-        backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot, env);
-        snapshot.discardState();
-
-        backend.getPartitionedState(VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
-
-        // Verify registered again
-        verify(listener, times(2))
-                .notifyKvStateRegistered(
-                        eq(env.getJobID()),
-                        eq(env.getJobVertexId()),
-                        eq(expectedKeyGroupRange),
-                        eq("banana"),
-                        any(KvStateID.class));
-
-        backend.dispose();
+            backend.getPartitionedState(
+                    VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, desc);
+
+            // Verify registered again
+            verify(listener, times(2))
+                    .notifyKvStateRegistered(
+                            eq(env.getJobID()),
+                            eq(env.getJobVertexId()),
+                            eq(expectedKeyGroupRange),
+                            eq("banana"),
+                            any(KvStateID.class));
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     @Test
-    public void testEmptyStateCheckpointing() {
+    public void testEmptyStateCheckpointing() throws Exception {
 
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
         try {
             CheckpointStreamFactory streamFactory = createStreamFactory();
             SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
-            CheckpointableKeyedStateBackend<Integer> backend =
-                    createKeyedBackend(IntSerializer.INSTANCE);
 
             ListStateDescriptor<String> kvId = new ListStateDescriptor<>("id", String.class);
 
@@ -4448,49 +4496,53 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             backend.dispose();
 
             backend = restoreKeyedBackend(IntSerializer.INSTANCE, snapshot);
-            backend.dispose();
         } catch (Exception e) {
             e.printStackTrace();
             fail(e.getMessage());
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
         }
     }
 
     @Test
     @SuppressWarnings("unchecked")
     public void testNumStateEntries() throws Exception {
-        CheckpointableKeyedStateBackend<Integer> backend =
-                createKeyedBackend(IntSerializer.INSTANCE);
-
         ValueStateDescriptor<String> kvId = new ValueStateDescriptor<>("id", String.class);
 
-        assertEquals(0, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
-
-        ValueState<String> state =
-                backend.getPartitionedState(
-                        VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
+        CheckpointableKeyedStateBackend<Integer> backend =
+                createKeyedBackend(IntSerializer.INSTANCE);
+        try {
+            assertEquals(0, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
 
-        backend.setCurrentKey(0);
-        state.update("hello");
-        state.update("ciao");
+            ValueState<String> state =
+                    backend.getPartitionedState(
+                            VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE, kvId);
 
-        assertEquals(1, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
+            backend.setCurrentKey(0);
+            state.update("hello");
+            state.update("ciao");
 
-        backend.setCurrentKey(42);
-        state.update("foo");
+            assertEquals(1, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
 
-        assertEquals(2, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
+            backend.setCurrentKey(42);
+            state.update("foo");
 
-        backend.setCurrentKey(0);
-        state.clear();
+            assertEquals(2, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
 
-        assertEquals(1, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
+            backend.setCurrentKey(0);
+            state.clear();
 
-        backend.setCurrentKey(42);
-        state.clear();
+            assertEquals(1, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
 
-        assertEquals(0, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
+            backend.setCurrentKey(42);
+            state.clear();
 
-        backend.dispose();
+            assertEquals(0, ((TestableKeyedStateBackend) backend).numKeyValueStateEntries());
+        } finally {
+            IOUtils.closeQuietly(backend);
+            backend.dispose();
+        }
     }
 
     private static class AppendingReduce implements ReduceFunction<String> {
@@ -4576,6 +4628,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             snapshot1.get();
 
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -4873,6 +4926,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
             }
 
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
         }
     }
@@ -4952,10 +5006,9 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
     public void testCheckConcurrencyProblemWhenPerformingCheckpointAsync() throws Exception {
 
         CheckpointStreamFactory streamFactory = createStreamFactory();
+        ExecutorService executorService = Executors.newScheduledThreadPool(1);
         CheckpointableKeyedStateBackend<Integer> backend =
                 createKeyedBackend(IntSerializer.INSTANCE, env);
-
-        ExecutorService executorService = Executors.newScheduledThreadPool(1);
         try {
             long checkpointID = 0;
             List<Future> futureList = new ArrayList();
@@ -4984,6 +5037,7 @@ public abstract class StateBackendTestBase<B extends AbstractStateBackend> exten
         } catch (Exception e) {
             fail();
         } finally {
+            IOUtils.closeQuietly(backend);
             backend.dispose();
             executorService.shutdown();
         }
