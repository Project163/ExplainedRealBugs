diff --git a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
index f9a094a1c47..fa409b6a586 100644
--- a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
+++ b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
@@ -677,7 +677,7 @@ public class FutureUtils {
 
     /**
      * Run the given action after the completion of the given future. The given future can be
-     * completed normally or exceptionally. In case of an exceptional completion the, the action's
+     * completed normally or exceptionally. In case of an exceptional completion the action's
      * exception will be added to the initial exception.
      *
      * @param future to wait for its completion
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
index cd1160072ba..fdfa2384dda 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
@@ -23,6 +23,7 @@ import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
@@ -119,6 +120,7 @@ public class DefaultScheduler extends SchedulerBase implements SchedulerOperatio
             final Consumer<ComponentMainThreadExecutor> startUpAction,
             final ScheduledExecutor delayExecutor,
             final ClassLoader userCodeLoader,
+            final CheckpointsCleaner checkpointsCleaner,
             final CheckpointRecoveryFactory checkpointRecoveryFactory,
             final JobManagerJobMetricGroup jobManagerJobMetricGroup,
             final SchedulingStrategyFactory schedulingStrategyFactory,
@@ -141,6 +143,7 @@ public class DefaultScheduler extends SchedulerBase implements SchedulerOperatio
                 ioExecutor,
                 jobMasterConfiguration,
                 userCodeLoader,
+                checkpointsCleaner,
                 checkpointRecoveryFactory,
                 jobManagerJobMetricGroup,
                 executionVertexVersioner,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSchedulerFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSchedulerFactory.java
index 157844b9977..ec39bb9d69a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSchedulerFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSchedulerFactory.java
@@ -24,6 +24,7 @@ import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.runtime.blob.BlobWriter;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.executiongraph.JobStatusListener;
 import org.apache.flink.runtime.executiongraph.failover.flip1.FailoverStrategyFactoryLoader;
@@ -122,6 +123,7 @@ public class DefaultSchedulerFactory implements SchedulerNGFactory {
                 schedulerComponents.getStartUpAction(),
                 new ScheduledExecutorServiceAdapter(futureExecutor),
                 userCodeLoader,
+                new CheckpointsCleaner(),
                 checkpointRecoveryFactory,
                 jobManagerJobMetricGroup,
                 schedulerComponents.getSchedulingStrategyFactory(),
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
index 180921ec4a9..9f195d61030 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
@@ -162,6 +162,7 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
             final Executor ioExecutor,
             final Configuration jobMasterConfiguration,
             final ClassLoader userCodeLoader,
+            final CheckpointsCleaner checkpointsCleaner,
             final CheckpointRecoveryFactory checkpointRecoveryFactory,
             final JobManagerJobMetricGroup jobManagerJobMetricGroup,
             final ExecutionVertexVersioner executionVertexVersioner,
@@ -179,7 +180,7 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
         this.executionVertexVersioner = checkNotNull(executionVertexVersioner);
         this.mainThreadExecutor = mainThreadExecutor;
 
-        this.checkpointsCleaner = new CheckpointsCleaner();
+        this.checkpointsCleaner = checkpointsCleaner;
         this.completedCheckpointStore =
                 SchedulerUtils.createCompletedCheckpointStoreIfCheckpointingIsEnabled(
                         jobGraph,
@@ -610,12 +611,13 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
         final FlinkException cause = new FlinkException("Scheduler is being stopped.");
 
         final CompletableFuture<Void> checkpointServicesShutdownFuture =
-                CompletableFuture.allOf(
+                FutureUtils.composeAfterwards(
                         executionGraph
                                 .getTerminationFuture()
                                 .thenAcceptAsync(
                                         this::shutDownCheckpointServices, getMainThreadExecutor()),
-                        checkpointsCleaner.closeAsync());
+                        checkpointsCleaner::closeAsync);
+
         FutureUtils.assertNoException(checkpointServicesShutdownFuture);
 
         incrementVersionsOfAllVertices();
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java
index 4333881e0a6..01014e3aa1b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java
@@ -167,9 +167,9 @@ public class AdaptiveScheduler
     private final ClassLoader userCodeClassLoader;
     private final JobManagerJobMetricGroup jobManagerJobMetricGroup;
 
+    private final CheckpointsCleaner checkpointsCleaner;
     private final CompletedCheckpointStore completedCheckpointStore;
     private final CheckpointIDCounter checkpointIdCounter;
-    private final CheckpointsCleaner checkpointsCleaner;
 
     private final CompletableFuture<JobStatus> jobTerminationFuture = new CompletableFuture<>();
 
@@ -210,6 +210,7 @@ public class AdaptiveScheduler
             SlotAllocator slotAllocator,
             Executor ioExecutor,
             ClassLoader userCodeClassLoader,
+            CheckpointsCleaner checkpointsCleaner,
             CheckpointRecoveryFactory checkpointRecoveryFactory,
             Duration initialResourceAllocationTimeout,
             Duration resourceStabilizationTimeout,
@@ -238,6 +239,7 @@ public class AdaptiveScheduler
         this.restartBackoffTimeStrategy = restartBackoffTimeStrategy;
         this.jobManagerJobMetricGroup = jobManagerJobMetricGroup;
         this.fatalErrorHandler = fatalErrorHandler;
+        this.checkpointsCleaner = checkpointsCleaner;
         this.completedCheckpointStore =
                 SchedulerUtils.createCompletedCheckpointStoreIfCheckpointingIsEnabled(
                         jobGraph,
@@ -248,7 +250,6 @@ public class AdaptiveScheduler
         this.checkpointIdCounter =
                 SchedulerUtils.createCheckpointIDCounterIfCheckpointingIsEnabled(
                         jobGraph, checkpointRecoveryFactory);
-        this.checkpointsCleaner = new CheckpointsCleaner();
 
         this.slotAllocator = slotAllocator;
 
@@ -418,12 +419,12 @@ public class AdaptiveScheduler
 
         backgroundTask.abort();
         // wait for the background task to finish and then close services
-        return CompletableFuture.allOf(
+        return FutureUtils.composeAfterwards(
                 FutureUtils.runAfterwardsAsync(
                         backgroundTask.getTerminationFuture(),
                         () -> stopCheckpointServicesSafely(jobTerminationFuture.get()),
                         getMainThreadExecutor()),
-                checkpointsCleaner.closeAsync());
+                checkpointsCleaner::closeAsync);
     }
 
     private void stopCheckpointServicesSafely(JobStatus terminalState) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java
index ea9019be7b2..61236a1c18e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerFactory.java
@@ -23,6 +23,7 @@ import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.runtime.blob.BlobWriter;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.executiongraph.JobStatusListener;
 import org.apache.flink.runtime.executiongraph.failover.flip1.RestartBackoffTimeStrategy;
@@ -125,6 +126,7 @@ public class AdaptiveSchedulerFactory implements SchedulerNGFactory {
                 slotAllocator,
                 ioExecutor,
                 userCodeLoader,
+                new CheckpointsCleaner(),
                 checkpointRecoveryFactory,
                 initialResourceAllocationTimeout,
                 resourceStabilizationTimeout,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
index a8471629d38..2ae69a3b82a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
@@ -25,6 +25,13 @@ import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.WebOptions;
 import org.apache.flink.core.testutils.ScheduledTask;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinator;
+import org.apache.flink.runtime.checkpoint.CheckpointIDCounter;
+import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
+import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointIDCounter;
+import org.apache.flink.runtime.checkpoint.StandaloneCompletedCheckpointStore;
+import org.apache.flink.runtime.checkpoint.TestingCheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.hooks.TestMasterHook;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;
@@ -100,6 +107,7 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
@@ -1479,6 +1487,96 @@ public class DefaultSchedulerTest extends TestLogger {
         assertThat(shuffleMaster.getExternallyReleasedPartitions(), hasSize(1));
     }
 
+    @Test
+    public void testCheckpointCleanerIsClosedAfterCheckpointServices() throws Exception {
+        final ScheduledExecutorService executorService =
+                Executors.newSingleThreadScheduledExecutor();
+        try {
+            doTestCheckpointCleanerIsClosedAfterCheckpointServices(
+                    (checkpointRecoveryFactory, checkpointCleaner) -> {
+                        final JobGraph jobGraph = singleJobVertexJobGraph(1);
+                        enableCheckpointing(jobGraph);
+                        try {
+                            return SchedulerTestingUtils.newSchedulerBuilder(
+                                            jobGraph,
+                                            ComponentMainThreadExecutorServiceAdapter
+                                                    .forSingleThreadExecutor(executorService))
+                                    .setCheckpointRecoveryFactory(checkpointRecoveryFactory)
+                                    .setCheckpointCleaner(checkpointCleaner)
+                                    .build();
+                        } catch (Exception e) {
+                            throw new RuntimeException(e);
+                        }
+                    },
+                    executorService);
+        } finally {
+            executorService.shutdownNow();
+        }
+    }
+
+    /**
+     * Visible for re-use in {@link
+     * org.apache.flink.runtime.scheduler.adaptive.AdaptiveSchedulerTest}.
+     */
+    public static void doTestCheckpointCleanerIsClosedAfterCheckpointServices(
+            BiFunction<CheckpointRecoveryFactory, CheckpointsCleaner, SchedulerNG> schedulerFactory,
+            ScheduledExecutorService executorService)
+            throws Exception {
+        final CountDownLatch checkpointServicesShutdownBlocked = new CountDownLatch(1);
+        final CountDownLatch cleanerClosed = new CountDownLatch(1);
+        final CompletedCheckpointStore completedCheckpointStore =
+                new StandaloneCompletedCheckpointStore(1) {
+
+                    @Override
+                    public void shutdown(JobStatus jobStatus, CheckpointsCleaner checkpointsCleaner)
+                            throws Exception {
+                        checkpointServicesShutdownBlocked.await();
+                        super.shutdown(jobStatus, checkpointsCleaner);
+                    }
+                };
+        final CheckpointIDCounter checkpointIDCounter =
+                new StandaloneCheckpointIDCounter() {
+
+                    @Override
+                    public void shutdown(JobStatus jobStatus) throws Exception {
+                        checkpointServicesShutdownBlocked.await();
+                        super.shutdown(jobStatus);
+                    }
+                };
+        final CheckpointsCleaner checkpointsCleaner =
+                new CheckpointsCleaner() {
+
+                    @Override
+                    public synchronized CompletableFuture<Void> closeAsync() {
+                        cleanerClosed.countDown();
+                        return super.closeAsync();
+                    }
+                };
+
+        final SchedulerNG scheduler =
+                schedulerFactory.apply(
+                        new TestingCheckpointRecoveryFactory(
+                                completedCheckpointStore, checkpointIDCounter),
+                        checkpointsCleaner);
+        final CompletableFuture<Void> schedulerClosed = new CompletableFuture<>();
+        final CountDownLatch schedulerClosing = new CountDownLatch(1);
+
+        executorService.submit(
+                () -> {
+                    scheduler.closeAsync().thenRun(() -> schedulerClosed.complete(null));
+                    schedulerClosing.countDown();
+                });
+
+        // Wait for scheduler to start closing.
+        schedulerClosing.await();
+        assertFalse(
+                "CheckpointCleaner should not close before checkpoint services.",
+                cleanerClosed.await(10, TimeUnit.MILLISECONDS));
+        checkpointServicesShutdownBlocked.countDown();
+        cleanerClosed.await();
+        schedulerClosed.get();
+    }
+
     private static TaskExecutionState createFailedTaskExecutionState(
             ExecutionAttemptID executionAttemptID) {
         return new TaskExecutionState(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SchedulerTestingUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SchedulerTestingUtils.java
index a973000e937..8c1e9bee254 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SchedulerTestingUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SchedulerTestingUtils.java
@@ -28,6 +28,7 @@ import org.apache.flink.runtime.checkpoint.CheckpointException;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.PendingCheckpoint;
 import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;
@@ -400,6 +401,7 @@ public class SchedulerTestingUtils {
         private ScheduledExecutor delayExecutor =
                 new ScheduledExecutorServiceAdapter(futureExecutor);
         private ClassLoader userCodeLoader = ClassLoader.getSystemClassLoader();
+        private CheckpointsCleaner checkpointCleaner = new CheckpointsCleaner();
         private CheckpointRecoveryFactory checkpointRecoveryFactory =
                 new StandaloneCheckpointRecoveryFactory();
         private Time rpcTimeout = DEFAULT_TIMEOUT;
@@ -457,6 +459,12 @@ public class SchedulerTestingUtils {
             return this;
         }
 
+        public DefaultSchedulerBuilder setCheckpointCleaner(
+                final CheckpointsCleaner checkpointsCleaner) {
+            this.checkpointCleaner = checkpointsCleaner;
+            return this;
+        }
+
         public DefaultSchedulerBuilder setCheckpointRecoveryFactory(
                 final CheckpointRecoveryFactory checkpointRecoveryFactory) {
             this.checkpointRecoveryFactory = checkpointRecoveryFactory;
@@ -553,6 +561,7 @@ public class SchedulerTestingUtils {
                     componentMainThreadExecutor -> {},
                     delayExecutor,
                     userCodeLoader,
+                    checkpointCleaner,
                     checkpointRecoveryFactory,
                     jobManagerJobMetricGroup,
                     schedulingStrategyFactory,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java
index 12816fdd609..0bdabaac4c6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerBuilder.java
@@ -23,6 +23,7 @@ import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.runtime.blob.BlobWriter;
 import org.apache.flink.runtime.blob.VoidBlobWriter;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.executiongraph.JobStatusListener;
@@ -63,6 +64,7 @@ public class AdaptiveSchedulerBuilder {
     private Configuration jobMasterConfiguration = new Configuration();
     private ScheduledExecutorService futureExecutor = TestingUtils.defaultExecutor();
     private ClassLoader userCodeLoader = ClassLoader.getSystemClassLoader();
+    private CheckpointsCleaner checkpointsCleaner = new CheckpointsCleaner();
     private CheckpointRecoveryFactory checkpointRecoveryFactory =
             new StandaloneCheckpointRecoveryFactory();
     private DeclarativeSlotPool declarativeSlotPool;
@@ -119,6 +121,12 @@ public class AdaptiveSchedulerBuilder {
         return this;
     }
 
+    public AdaptiveSchedulerBuilder setCheckpointCleaner(
+            final CheckpointsCleaner checkpointsCleaner) {
+        this.checkpointsCleaner = checkpointsCleaner;
+        return this;
+    }
+
     public AdaptiveSchedulerBuilder setCheckpointRecoveryFactory(
             final CheckpointRecoveryFactory checkpointRecoveryFactory) {
         this.checkpointRecoveryFactory = checkpointRecoveryFactory;
@@ -208,6 +216,7 @@ public class AdaptiveSchedulerBuilder {
                         : slotAllocator,
                 ioExecutor,
                 userCodeLoader,
+                checkpointsCleaner,
                 checkpointRecoveryFactory,
                 jobMasterConfiguration.get(JobManagerOptions.RESOURCE_WAIT_TIMEOUT),
                 jobMasterConfiguration.get(JobManagerOptions.RESOURCE_STABILIZATION_TIMEOUT),
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java
index 55968045153..29263168992 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java
@@ -66,6 +66,7 @@ import org.apache.flink.runtime.operators.coordination.CoordinationRequest;
 import org.apache.flink.runtime.operators.coordination.TaskNotRunningException;
 import org.apache.flink.runtime.operators.coordination.TestOperatorEvent;
 import org.apache.flink.runtime.rest.handler.legacy.utils.ArchivedExecutionGraphBuilder;
+import org.apache.flink.runtime.scheduler.DefaultSchedulerTest;
 import org.apache.flink.runtime.scheduler.SchedulerBase;
 import org.apache.flink.runtime.scheduler.SchedulerNG;
 import org.apache.flink.runtime.scheduler.VertexParallelismInformation;
@@ -109,6 +110,7 @@ import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.cr
 import static org.apache.flink.runtime.jobgraph.JobGraphTestUtils.streamingJobGraph;
 import static org.apache.flink.runtime.jobmaster.slotpool.DefaultDeclarativeSlotPoolTest.createSlotOffersForResourceRequirements;
 import static org.apache.flink.runtime.jobmaster.slotpool.SlotPoolTestUtils.offerSlots;
+import static org.apache.flink.runtime.scheduler.SchedulerTestingUtils.enableCheckpointing;
 import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.greaterThan;
 import static org.hamcrest.Matchers.instanceOf;
@@ -1113,6 +1115,33 @@ public class AdaptiveSchedulerTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testCheckpointCleanerIsClosedAfterCheckpointServices() throws Exception {
+        final ScheduledExecutorService executorService =
+                Executors.newSingleThreadScheduledExecutor();
+        try {
+            DefaultSchedulerTest.doTestCheckpointCleanerIsClosedAfterCheckpointServices(
+                    (checkpointRecoveryFactory, checkpointCleaner) -> {
+                        final JobGraph jobGraph = createJobGraph();
+                        enableCheckpointing(jobGraph);
+                        try {
+                            return new AdaptiveSchedulerBuilder(
+                                            jobGraph,
+                                            ComponentMainThreadExecutorServiceAdapter
+                                                    .forSingleThreadExecutor(executorService))
+                                    .setCheckpointRecoveryFactory(checkpointRecoveryFactory)
+                                    .setCheckpointCleaner(checkpointCleaner)
+                                    .build();
+                        } catch (Exception e) {
+                            throw new RuntimeException(e);
+                        }
+                    },
+                    executorService);
+        } finally {
+            executorService.shutdownNow();
+        }
+    }
+
     // ---------------------------------------------------------------------------------------------
     // Utils
     // ---------------------------------------------------------------------------------------------
