diff --git a/flink-python/src/main/java/org/apache/flink/streaming/api/operators/python/PythonTimestampsAndWatermarksOperator.java b/flink-python/src/main/java/org/apache/flink/streaming/api/operators/python/PythonTimestampsAndWatermarksOperator.java
index 86075a58b0a..e9f64911612 100644
--- a/flink-python/src/main/java/org/apache/flink/streaming/api/operators/python/PythonTimestampsAndWatermarksOperator.java
+++ b/flink-python/src/main/java/org/apache/flink/streaming/api/operators/python/PythonTimestampsAndWatermarksOperator.java
@@ -110,9 +110,7 @@ public class PythonTimestampsAndWatermarksOperator<IN>
                 emitProgressiveWatermarks
                         ? watermarkStrategy.createWatermarkGenerator(this::getMetricGroup)
                         : new NoWatermarksGenerator<>();
-        watermarkOutput =
-                new TimestampsAndWatermarksOperator.WatermarkEmitter(
-                        output, getContainingTask().getStreamStatusMaintainer());
+        watermarkOutput = new TimestampsAndWatermarksOperator.WatermarkEmitter(output);
 
         watermarkInterval = getExecutionConfig().getAutoWatermarkInterval();
         if (watermarkInterval > 0 && emitProgressiveWatermarks) {
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
index fad3608c605..1fd7054b3f4 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
@@ -308,7 +308,6 @@ public class ContinuousFileReaderOperator<OUT, T extends TimestampedInputSplit>
                         getOperatorConfig().getTimeCharacteristic(),
                         getProcessingTimeService(),
                         new Object(), // no actual locking needed
-                        getContainingTask().getStreamStatusMaintainer(),
                         output,
                         getRuntimeContext().getExecutionConfig().getAutoWatermarkInterval(),
                         -1);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSource.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSource.java
index e3d2c89636c..bed6026b5fe 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSource.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSource.java
@@ -26,7 +26,6 @@ import org.apache.flink.streaming.api.functions.source.SourceFunction;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.OperatorChain;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
@@ -57,18 +56,14 @@ public class StreamSource<OUT, SRC extends SourceFunction<OUT>>
         this.chainingStrategy = ChainingStrategy.HEAD;
     }
 
-    public void run(
-            final Object lockingObject,
-            final StreamStatusMaintainer streamStatusMaintainer,
-            final OperatorChain<?, ?> operatorChain)
+    public void run(final Object lockingObject, final OperatorChain<?, ?> operatorChain)
             throws Exception {
 
-        run(lockingObject, streamStatusMaintainer, output, operatorChain);
+        run(lockingObject, output, operatorChain);
     }
 
     public void run(
             final Object lockingObject,
-            final StreamStatusMaintainer streamStatusMaintainer,
             final Output<StreamRecord<OUT>> collector,
             final OperatorChain<?, ?> operatorChain)
             throws Exception {
@@ -101,7 +96,6 @@ public class StreamSource<OUT, SRC extends SourceFunction<OUT>>
                         timeCharacteristic,
                         getProcessingTimeService(),
                         lockingObject,
-                        streamStatusMaintainer,
                         collector,
                         watermarkInterval,
                         -1);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSourceContexts.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSourceContexts.java
index 3af17d47b0d..9b66437db7f 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSourceContexts.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/StreamSourceContexts.java
@@ -22,7 +22,6 @@ import org.apache.flink.streaming.api.functions.source.SourceFunction;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.util.Preconditions;
@@ -46,7 +45,6 @@ public class StreamSourceContexts {
             TimeCharacteristic timeCharacteristic,
             ProcessingTimeService processingTimeService,
             Object checkpointLock,
-            StreamStatusMaintainer streamStatusMaintainer,
             Output<StreamRecord<OUT>> output,
             long watermarkInterval,
             long idleTimeout) {
@@ -56,11 +54,7 @@ public class StreamSourceContexts {
             case EventTime:
                 ctx =
                         new ManualWatermarkContext<>(
-                                output,
-                                processingTimeService,
-                                checkpointLock,
-                                streamStatusMaintainer,
-                                idleTimeout);
+                                output, processingTimeService, checkpointLock, idleTimeout);
 
                 break;
             case IngestionTime:
@@ -70,7 +64,6 @@ public class StreamSourceContexts {
                                 watermarkInterval,
                                 processingTimeService,
                                 checkpointLock,
-                                streamStatusMaintainer,
                                 idleTimeout);
 
                 break;
@@ -149,15 +142,16 @@ public class StreamSourceContexts {
 
         private long lastRecordTime;
 
+        private volatile boolean idle = false;
+
         private AutomaticWatermarkContext(
                 final Output<StreamRecord<T>> output,
                 final long watermarkInterval,
                 final ProcessingTimeService timeService,
                 final Object checkpointLock,
-                final StreamStatusMaintainer streamStatusMaintainer,
                 final long idleTimeout) {
 
-            super(timeService, checkpointLock, streamStatusMaintainer, idleTimeout);
+            super(timeService, checkpointLock, idleTimeout);
 
             this.output = Preconditions.checkNotNull(output, "The output cannot be null.");
 
@@ -222,6 +216,14 @@ public class StreamSourceContexts {
             }
         }
 
+        @Override
+        protected void processAndEmitStreamStatus(StreamStatus streamStatus) {
+            if (idle != streamStatus.isIdle()) {
+                output.emitStreamStatus(streamStatus);
+            }
+            idle = streamStatus.isIdle();
+        }
+
         @Override
         public void close() {
             super.close();
@@ -253,7 +255,7 @@ public class StreamSourceContexts {
 
                 synchronized (lock) {
                     // we should continue to automatically emit watermarks if we are active
-                    if (streamStatusMaintainer.getStreamStatus().isActive()) {
+                    if (!idle) {
                         if (idleTimeout != -1 && currentTime - lastRecordTime > idleTimeout) {
                             // if we are configured to detect idleness, piggy-back the idle
                             // detection check on the
@@ -298,15 +300,15 @@ public class StreamSourceContexts {
 
         private final Output<StreamRecord<T>> output;
         private final StreamRecord<T> reuse;
+        private volatile boolean idle = false;
 
         private ManualWatermarkContext(
                 final Output<StreamRecord<T>> output,
                 final ProcessingTimeService timeService,
                 final Object checkpointLock,
-                final StreamStatusMaintainer streamStatusMaintainer,
                 final long idleTimeout) {
 
-            super(timeService, checkpointLock, streamStatusMaintainer, idleTimeout);
+            super(timeService, checkpointLock, idleTimeout);
 
             this.output = Preconditions.checkNotNull(output, "The output cannot be null.");
             this.reuse = new StreamRecord<>(null);
@@ -327,6 +329,14 @@ public class StreamSourceContexts {
             output.emitWatermark(mark);
         }
 
+        @Override
+        protected void processAndEmitStreamStatus(StreamStatus streamStatus) {
+            if (idle != streamStatus.isIdle()) {
+                output.emitStreamStatus(streamStatus);
+            }
+            idle = streamStatus.isIdle();
+        }
+
         @Override
         protected boolean allowWatermark(Watermark mark) {
             return true;
@@ -351,7 +361,6 @@ public class StreamSourceContexts {
 
         protected final ProcessingTimeService timeService;
         protected final Object checkpointLock;
-        protected final StreamStatusMaintainer streamStatusMaintainer;
         protected final long idleTimeout;
 
         private ScheduledFuture<?> nextCheck;
@@ -370,23 +379,17 @@ public class StreamSourceContexts {
          *
          * @param timeService the time service to schedule idleness detection tasks
          * @param checkpointLock the checkpoint lock
-         * @param streamStatusMaintainer the stream status maintainer to toggle and retrieve current
-         *     status
          * @param idleTimeout (-1 if idleness checking is disabled)
          */
         public WatermarkContext(
                 final ProcessingTimeService timeService,
                 final Object checkpointLock,
-                final StreamStatusMaintainer streamStatusMaintainer,
                 final long idleTimeout) {
 
             this.timeService =
                     Preconditions.checkNotNull(timeService, "Time Service cannot be null.");
             this.checkpointLock =
                     Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.");
-            this.streamStatusMaintainer =
-                    Preconditions.checkNotNull(
-                            streamStatusMaintainer, "Stream Status Maintainer cannot be null.");
 
             if (idleTimeout != -1) {
                 Preconditions.checkArgument(
@@ -400,7 +403,7 @@ public class StreamSourceContexts {
         @Override
         public void collect(T element) {
             synchronized (checkpointLock) {
-                streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
+                processAndEmitStreamStatus(StreamStatus.ACTIVE);
 
                 if (nextCheck != null) {
                     this.failOnNextCheck = false;
@@ -415,7 +418,7 @@ public class StreamSourceContexts {
         @Override
         public void collectWithTimestamp(T element, long timestamp) {
             synchronized (checkpointLock) {
-                streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
+                processAndEmitStreamStatus(StreamStatus.ACTIVE);
 
                 if (nextCheck != null) {
                     this.failOnNextCheck = false;
@@ -431,7 +434,7 @@ public class StreamSourceContexts {
         public void emitWatermark(Watermark mark) {
             if (allowWatermark(mark)) {
                 synchronized (checkpointLock) {
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
+                    processAndEmitStreamStatus(StreamStatus.ACTIVE);
 
                     if (nextCheck != null) {
                         this.failOnNextCheck = false;
@@ -447,7 +450,7 @@ public class StreamSourceContexts {
         @Override
         public void markAsTemporarilyIdle() {
             synchronized (checkpointLock) {
-                streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE);
+                processAndEmitStreamStatus(StreamStatus.IDLE);
             }
         }
 
@@ -517,5 +520,7 @@ public class StreamSourceContexts {
          * WatermarkContext#allowWatermark(Watermark)} returns {@code true}.
          */
         protected abstract void processAndEmitWatermark(Watermark mark);
+
+        protected abstract void processAndEmitStreamStatus(StreamStatus streamStatus);
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java
deleted file mode 100644
index 78584b7623e..00000000000
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.streaming.runtime.io;
-
-import org.apache.flink.annotation.Internal;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
-
-import static org.apache.flink.util.Preconditions.checkNotNull;
-
-/**
- * Base class for all data outputs. It implements the unified way of emitting stream status for both
- * network and source outputs.
- *
- * @param <T> The output type
- */
-@Internal
-public abstract class AbstractDataOutput<T> implements PushingAsyncDataInput.DataOutput<T> {
-
-    /** The maintainer toggles the current stream status. */
-    protected final StreamStatusMaintainer streamStatusMaintainer;
-
-    public AbstractDataOutput(StreamStatusMaintainer streamStatusMaintainer) {
-        this.streamStatusMaintainer = checkNotNull(streamStatusMaintainer);
-    }
-
-    @Override
-    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
-        streamStatusMaintainer.toggleStreamStatus(streamStatus);
-    }
-}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java
index b02afd32fe6..8d1d38cc032 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java
@@ -33,7 +33,6 @@ import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.AnnouncedStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.streaming.runtime.tasks.WatermarkGaugeExposingOutput;
 import org.apache.flink.util.OutputTag;
 
@@ -49,8 +48,6 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
 
     private SerializationDelegate<StreamElement> serializationDelegate;
 
-    private final StreamStatusProvider streamStatusProvider;
-
     private final boolean supportsUnalignedCheckpoints;
 
     private final OutputTag outputTag;
@@ -64,7 +61,6 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
             RecordWriter<SerializationDelegate<StreamRecord<OUT>>> recordWriter,
             TypeSerializer<OUT> outSerializer,
             OutputTag outputTag,
-            StreamStatusProvider streamStatusProvider,
             boolean supportsUnalignedCheckpoints) {
 
         checkNotNull(recordWriter);
@@ -81,8 +77,6 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
             serializationDelegate = new SerializationDelegate<>(outRecordSerializer);
         }
 
-        this.streamStatusProvider = checkNotNull(streamStatusProvider);
-
         this.supportsUnalignedCheckpoints = supportsUnalignedCheckpoints;
     }
 
@@ -109,7 +103,6 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
         try (AutoCloseable ignored = announcedStatus.ensureActive(this::writeStreamStatus)) {
             serializationDelegate.setInstance(record);
             recordWriter.emit(serializationDelegate);
-
         } catch (Exception e) {
             throw new RuntimeException(e.getMessage(), e);
         }
@@ -117,14 +110,15 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
 
     @Override
     public void emitWatermark(Watermark mark) {
-        watermarkGauge.setCurrentWatermark(mark.getTimestamp());
-        serializationDelegate.setInstance(mark);
-        if (streamStatusProvider.getStreamStatus().isActive()) {
-            try {
-                recordWriter.broadcastEmit(serializationDelegate);
-            } catch (Exception e) {
-                throw new RuntimeException(e.getMessage(), e);
-            }
+        // watermark could've been generated somewhere in the pipeline even though an IDLE status
+        // was emitted. It might've originated from a periodic watermark generator or just a wrong
+        // behaving operator
+        try (AutoCloseable ignored = announcedStatus.ensureActive(this::writeStreamStatus)) {
+            watermarkGauge.setCurrentWatermark(mark.getTimestamp());
+            serializationDelegate.setInstance(mark);
+            recordWriter.broadcastEmit(serializationDelegate);
+        } catch (Exception e) {
+            throw new RuntimeException(e.getMessage(), e);
         }
     }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java
index 738a0ac55ee..8658866401a 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java
@@ -36,7 +36,6 @@ import org.apache.flink.streaming.api.graph.StreamConfig;
 import org.apache.flink.streaming.api.operators.Input;
 import org.apache.flink.streaming.api.operators.InputSelectable;
 import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;
-import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.operators.sort.MultiInputSortingDataInput;
 import org.apache.flink.streaming.api.operators.sort.MultiInputSortingDataInput.SelectableSortingInputs;
 import org.apache.flink.streaming.api.watermark.Watermark;
@@ -47,9 +46,9 @@ import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.OperatorChain;
 import org.apache.flink.streaming.runtime.tasks.SourceOperatorStreamTask;
+import org.apache.flink.streaming.runtime.tasks.WatermarkGaugeExposingOutput;
 
 import java.util.Arrays;
 import java.util.List;
@@ -73,7 +72,6 @@ public class StreamMultipleInputProcessorFactory {
             MemoryManager memoryManager,
             TaskIOMetricGroup ioMetricGroup,
             Counter mainOperatorRecordsIn,
-            StreamStatusMaintainer streamStatusMaintainer,
             MultipleInputStreamOperator<?> mainOperator,
             WatermarkGauge[] inputWatermarkGauges,
             StreamConfig streamConfig,
@@ -94,8 +92,6 @@ public class StreamMultipleInputProcessorFactory {
         Counter networkRecordsIn = new SimpleCounter();
         ioMetricGroup.reuseRecordsInputCounter(networkRecordsIn);
 
-        MultiStreamStreamStatusTracker streamStatusTracker =
-                new MultiStreamStreamStatusTracker(inputsCount);
         checkState(
                 configuredInputs.length == inputsCount,
                 "Number of configured inputs in StreamConfig [%s] doesn't match the main operator's number of inputs [%s]",
@@ -204,10 +200,7 @@ public class StreamMultipleInputProcessorFactory {
                 StreamTaskNetworkOutput dataOutput =
                         new StreamTaskNetworkOutput<>(
                                 operatorInputs.get(i),
-                                streamStatusMaintainer,
                                 inputWatermarkGauges[i],
-                                streamStatusTracker,
-                                i,
                                 mainOperatorRecordsIn,
                                 networkRecordsIn);
 
@@ -216,18 +209,14 @@ public class StreamMultipleInputProcessorFactory {
             } else if (configuredInput instanceof StreamConfig.SourceInputConfig) {
                 StreamConfig.SourceInputConfig sourceInput =
                         (StreamConfig.SourceInputConfig) configuredInput;
-                Output<StreamRecord<?>> chainedSourceOutput =
+                WatermarkGaugeExposingOutput<StreamRecord<?>> chainedSourceOutput =
                         operatorChain.getChainedSourceOutput(sourceInput);
 
                 inputProcessors[i] =
                         new StreamOneInputProcessor(
                                 inputs[i],
                                 new StreamTaskSourceOutput(
-                                        chainedSourceOutput,
-                                        streamStatusMaintainer,
-                                        inputWatermarkGauges[i],
-                                        streamStatusTracker,
-                                        i),
+                                        chainedSourceOutput, inputWatermarkGauges[i]),
                                 operatorChain);
             } else {
                 throw new UnsupportedOperationException("Unknown input type: " + configuredInput);
@@ -238,68 +227,26 @@ public class StreamMultipleInputProcessorFactory {
                 new MultipleInputSelectionHandler(inputSelectable, inputsCount), inputProcessors);
     }
 
-    /**
-     * Stream status tracker for the inputs. We need to keep track for determining when to forward
-     * stream status changes downstream.
-     */
-    private static class MultiStreamStreamStatusTracker {
-        private final StreamStatus[] streamStatuses;
-
-        private MultiStreamStreamStatusTracker(int numberOfInputs) {
-            streamStatuses = new StreamStatus[numberOfInputs];
-            Arrays.fill(streamStatuses, StreamStatus.ACTIVE);
-        }
-
-        public void setStreamStatus(int index, StreamStatus streamStatus) {
-            streamStatuses[index] = streamStatus;
-        }
-
-        public StreamStatus getStreamStatus(int index) {
-            return streamStatuses[index];
-        }
-
-        public boolean allStreamStatusesAreIdle() {
-            for (StreamStatus streamStatus : streamStatuses) {
-                if (streamStatus.isActive()) {
-                    return false;
-                }
-            }
-            return true;
-        }
-    }
-
     /**
      * The network data output implementation used for processing stream elements from {@link
      * StreamTaskNetworkInput} in two input selective processor.
      */
-    private static class StreamTaskNetworkOutput<T> extends AbstractDataOutput<T> {
+    private static class StreamTaskNetworkOutput<T> implements PushingAsyncDataInput.DataOutput<T> {
         private final Input<T> input;
 
         private final WatermarkGauge inputWatermarkGauge;
 
-        /** The input index to indicate how to process elements by two input operator. */
-        private final int inputIndex;
-
-        private final MultiStreamStreamStatusTracker streamStatusTracker;
-
         private final Counter mainOperatorRecordsIn;
 
         private final Counter networkRecordsIn;
 
         private StreamTaskNetworkOutput(
                 Input<T> input,
-                StreamStatusMaintainer streamStatusMaintainer,
                 WatermarkGauge inputWatermarkGauge,
-                MultiStreamStreamStatusTracker streamStatusTracker,
-                int inputIndex,
                 Counter mainOperatorRecordsIn,
                 Counter networkRecordsIn) {
-            super(streamStatusMaintainer);
-
             this.input = checkNotNull(input);
             this.inputWatermarkGauge = checkNotNull(inputWatermarkGauge);
-            this.streamStatusTracker = streamStatusTracker;
-            this.inputIndex = inputIndex;
             this.mainOperatorRecordsIn = mainOperatorRecordsIn;
             this.networkRecordsIn = networkRecordsIn;
         }
@@ -320,18 +267,7 @@ public class StreamMultipleInputProcessorFactory {
 
         @Override
         public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
-            streamStatusTracker.setStreamStatus(inputIndex, streamStatus);
             input.emitStreamStatus(streamStatus);
-
-            // check if we need to toggle the task's stream status
-            if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {
-                if (streamStatus.isActive()) {
-                    // we're no longer idle if at least one input has become active
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
-                } else if (streamStatusTracker.allStreamStatusesAreIdle()) {
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE);
-                }
-            }
         }
 
         @Override
@@ -343,40 +279,18 @@ public class StreamMultipleInputProcessorFactory {
     @SuppressWarnings({"unchecked", "rawtypes"})
     private static class StreamTaskSourceOutput
             extends SourceOperatorStreamTask.AsyncDataOutputToOutput {
-        private final int inputIndex;
-        private final MultiStreamStreamStatusTracker streamStatusTracker;
-        private final Output<StreamRecord<?>> output;
+        private final WatermarkGaugeExposingOutput<StreamRecord<?>> chainedOutput;
 
         public StreamTaskSourceOutput(
-                Output<StreamRecord<?>> chainedSourceOutput,
-                StreamStatusMaintainer streamStatusMaintainer,
-                WatermarkGauge inputWatermarkGauge,
-                MultiStreamStreamStatusTracker streamStatusTracker,
-                int inputIndex) {
-            super(
-                    chainedSourceOutput,
-                    streamStatusMaintainer,
-                    new SimpleCounter(),
-                    inputWatermarkGauge);
-            this.streamStatusTracker = streamStatusTracker;
-            this.inputIndex = inputIndex;
-            this.output = chainedSourceOutput;
+                WatermarkGaugeExposingOutput<StreamRecord<?>> chainedSourceOutput,
+                WatermarkGauge inputWatermarkGauge) {
+            super(chainedSourceOutput, new SimpleCounter(), inputWatermarkGauge);
+            this.chainedOutput = chainedSourceOutput;
         }
 
         @Override
-        public void emitStreamStatus(StreamStatus streamStatus) {
-            streamStatusTracker.setStreamStatus(inputIndex, streamStatus);
-            output.emitStreamStatus(streamStatus);
-
-            // check if we need to toggle the task's stream status
-            if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {
-                if (streamStatus.isActive()) {
-                    // we're no longer idle if at least one input has become active
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
-                } else if (streamStatusTracker.allStreamStatusesAreIdle()) {
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE);
-                }
-            }
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+            chainedOutput.emitStreamStatus(streamStatus);
         }
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java
index 87b91f076fd..cbe1f060426 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java
@@ -44,7 +44,6 @@ import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.util.function.ThrowingConsumer;
 
 import java.util.ArrayList;
@@ -62,7 +61,6 @@ public class StreamTwoInputProcessorFactory {
             IOManager ioManager,
             MemoryManager memoryManager,
             TaskIOMetricGroup taskIOMetricGroup,
-            StreamStatusMaintainer streamStatusMaintainer,
             TwoInputStreamOperator<IN1, IN2, ?> streamOperator,
             WatermarkGauge input1WatermarkGauge,
             WatermarkGauge input2WatermarkGauge,
@@ -79,7 +77,6 @@ public class StreamTwoInputProcessorFactory {
 
         checkNotNull(endOfInputAware);
 
-        StreamStatusTracker statusTracker = new StreamStatusTracker();
         taskIOMetricGroup.reuseRecordsInputCounter(numRecordsIn);
         TypeSerializer<IN1> typeSerializer1 = streamConfig.getTypeSerializerIn(0, userClassloader);
         StreamTaskInput<IN1> input1 =
@@ -176,9 +173,7 @@ public class StreamTwoInputProcessorFactory {
                 new StreamTaskNetworkOutput<>(
                         streamOperator,
                         record -> processRecord1(record, streamOperator),
-                        streamStatusMaintainer,
                         input1WatermarkGauge,
-                        statusTracker,
                         0,
                         numRecordsIn);
         StreamOneInputProcessor<IN1> processor1 =
@@ -188,9 +183,7 @@ public class StreamTwoInputProcessorFactory {
                 new StreamTaskNetworkOutput<>(
                         streamOperator,
                         record -> processRecord2(record, streamOperator),
-                        streamStatusMaintainer,
                         input2WatermarkGauge,
-                        statusTracker,
                         1,
                         numRecordsIn);
         StreamOneInputProcessor<IN2> processor2 =
@@ -221,37 +214,11 @@ public class StreamTwoInputProcessorFactory {
         streamOperator.processElement2(record);
     }
 
-    private static class StreamStatusTracker {
-        /**
-         * Stream status for the two inputs. We need to keep track for determining when to forward
-         * stream status changes downstream.
-         */
-        private StreamStatus firstStatus = StreamStatus.ACTIVE;
-
-        private StreamStatus secondStatus = StreamStatus.ACTIVE;
-
-        public StreamStatus getFirstStatus() {
-            return firstStatus;
-        }
-
-        public void setFirstStatus(StreamStatus firstStatus) {
-            this.firstStatus = firstStatus;
-        }
-
-        public StreamStatus getSecondStatus() {
-            return secondStatus;
-        }
-
-        public void setSecondStatus(StreamStatus secondStatus) {
-            this.secondStatus = secondStatus;
-        }
-    }
-
     /**
      * The network data output implementation used for processing stream elements from {@link
      * StreamTaskNetworkInput} in two input selective processor.
      */
-    private static class StreamTaskNetworkOutput<T> extends AbstractDataOutput<T> {
+    private static class StreamTaskNetworkOutput<T> implements PushingAsyncDataInput.DataOutput<T> {
 
         private final TwoInputStreamOperator<?, ?, ?> operator;
 
@@ -265,22 +232,15 @@ public class StreamTwoInputProcessorFactory {
 
         private final Counter numRecordsIn;
 
-        private final StreamStatusTracker statusTracker;
-
         private StreamTaskNetworkOutput(
                 TwoInputStreamOperator<?, ?, ?> operator,
                 ThrowingConsumer<StreamRecord<T>, Exception> recordConsumer,
-                StreamStatusMaintainer streamStatusMaintainer,
                 WatermarkGauge inputWatermarkGauge,
-                StreamStatusTracker statusTracker,
                 int inputIndex,
                 Counter numRecordsIn) {
-            super(streamStatusMaintainer);
-
             this.operator = checkNotNull(operator);
             this.recordConsumer = checkNotNull(recordConsumer);
             this.inputWatermarkGauge = checkNotNull(inputWatermarkGauge);
-            this.statusTracker = statusTracker;
             this.inputIndex = inputIndex;
             this.numRecordsIn = numRecordsIn;
         }
@@ -303,26 +263,10 @@ public class StreamTwoInputProcessorFactory {
 
         @Override
         public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
-            final StreamStatus anotherStreamStatus;
             if (inputIndex == 0) {
-                statusTracker.setFirstStatus(streamStatus);
                 operator.emitStreamStatus1(streamStatus);
-                anotherStreamStatus = statusTracker.getSecondStatus();
             } else {
-                statusTracker.setSecondStatus(streamStatus);
                 operator.emitStreamStatus2(streamStatus);
-                anotherStreamStatus = statusTracker.getFirstStatus();
-            }
-
-            // check if we need to toggle the task's stream status
-            if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {
-                if (streamStatus.isActive()) {
-                    // we're no longer idle if at least one input has become active
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
-                } else if (anotherStreamStatus.isIdle()) {
-                    // we're idle once both inputs are idle
-                    streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE);
-                }
             }
         }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/TimestampsAndWatermarksOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/TimestampsAndWatermarksOperator.java
index 86c2dfe47b9..b2d35014658 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/TimestampsAndWatermarksOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/TimestampsAndWatermarksOperator.java
@@ -29,7 +29,6 @@ import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -84,7 +83,7 @@ public class TimestampsAndWatermarksOperator<T> extends AbstractStreamOperator<T
                         ? watermarkStrategy.createWatermarkGenerator(this::getMetricGroup)
                         : new NoWatermarksGenerator<>();
 
-        wmOutput = new WatermarkEmitter(output, getContainingTask().getStreamStatusMaintainer());
+        wmOutput = new WatermarkEmitter(output);
 
         watermarkInterval = getExecutionConfig().getAutoWatermarkInterval();
         if (watermarkInterval > 0 && emitProgressiveWatermarks) {
@@ -143,15 +142,12 @@ public class TimestampsAndWatermarksOperator<T> extends AbstractStreamOperator<T
 
         private final Output<?> output;
 
-        private final StreamStatusMaintainer statusMaintainer;
-
         private long currentWatermark;
 
         private boolean idle;
 
-        public WatermarkEmitter(Output<?> output, StreamStatusMaintainer statusMaintainer) {
+        public WatermarkEmitter(Output<?> output) {
             this.output = output;
-            this.statusMaintainer = statusMaintainer;
             this.currentWatermark = Long.MIN_VALUE;
         }
 
@@ -167,7 +163,7 @@ public class TimestampsAndWatermarksOperator<T> extends AbstractStreamOperator<T
 
             if (idle) {
                 idle = false;
-                statusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
+                output.emitStreamStatus(StreamStatus.ACTIVE);
             }
 
             output.emitWatermark(new org.apache.flink.streaming.api.watermark.Watermark(ts));
@@ -176,7 +172,7 @@ public class TimestampsAndWatermarksOperator<T> extends AbstractStreamOperator<T
         @Override
         public void markIdle() {
             idle = true;
-            statusMaintainer.toggleStreamStatus(StreamStatus.IDLE);
+            output.emitStreamStatus(StreamStatus.IDLE);
         }
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StreamStatusMaintainer.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StreamStatusMaintainer.java
deleted file mode 100644
index 69b4ebe517f..00000000000
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StreamStatusMaintainer.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.streaming.runtime.streamstatus;
-
-import org.apache.flink.annotation.Internal;
-
-/** Interface that allows toggling the current {@link StreamStatus} as well as retrieving it. */
-@Internal
-public interface StreamStatusMaintainer extends StreamStatusProvider {
-
-    /**
-     * Toggles the current stream status. This method should only have effect if the supplied stream
-     * status is different from the current status.
-     *
-     * @param streamStatus the new status to toggle to
-     */
-    void toggleStreamStatus(StreamStatus streamStatus);
-}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StreamStatusProvider.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StreamStatusProvider.java
deleted file mode 100644
index b6128992495..00000000000
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StreamStatusProvider.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.streaming.runtime.streamstatus;
-
-import org.apache.flink.annotation.Internal;
-
-/** Interface for retrieving the current {@link StreamStatus}. */
-@Internal
-public interface StreamStatusProvider {
-
-    /**
-     * Returns the current stream status.
-     *
-     * @return current stream status.
-     */
-    StreamStatus getStreamStatus();
-}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java
index 3129cd6fee1..e79a7f3626b 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java
@@ -24,7 +24,6 @@ import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 import org.apache.flink.util.XORShiftRandom;
 
@@ -34,22 +33,17 @@ class BroadcastingOutputCollector<T> implements WatermarkGaugeExposingOutput<Str
 
     protected final Output<StreamRecord<T>>[] outputs;
     private final Random random = new XORShiftRandom();
-    private final StreamStatusProvider streamStatusProvider;
     private final WatermarkGauge watermarkGauge = new WatermarkGauge();
 
-    public BroadcastingOutputCollector(
-            Output<StreamRecord<T>>[] outputs, StreamStatusProvider streamStatusProvider) {
+    public BroadcastingOutputCollector(Output<StreamRecord<T>>[] outputs) {
         this.outputs = outputs;
-        this.streamStatusProvider = streamStatusProvider;
     }
 
     @Override
     public void emitWatermark(Watermark mark) {
         watermarkGauge.setCurrentWatermark(mark.getTimestamp());
-        if (streamStatusProvider.getStreamStatus().isActive()) {
-            for (Output<StreamRecord<T>> output : outputs) {
-                output.emitWatermark(mark);
-            }
+        for (Output<StreamRecord<T>> output : outputs) {
+            output.emitWatermark(mark);
         }
     }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java
index d837bc24982..839ead39484 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java
@@ -29,7 +29,6 @@ import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 
 import org.slf4j.Logger;
@@ -43,26 +42,16 @@ class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>>
     protected final Input<T> input;
     protected final Counter numRecordsIn;
     protected final WatermarkGauge watermarkGauge = new WatermarkGauge();
-    protected final StreamStatusProvider streamStatusProvider;
     @Nullable protected final OutputTag<T> outputTag;
     @Nullable protected final AutoCloseable closeable;
 
-    public ChainingOutput(
-            OneInputStreamOperator<T, ?> operator,
-            StreamStatusProvider streamStatusProvider,
-            @Nullable OutputTag<T> outputTag) {
-        this(
-                operator,
-                (OperatorMetricGroup) operator.getMetricGroup(),
-                streamStatusProvider,
-                outputTag,
-                operator::close);
+    public ChainingOutput(OneInputStreamOperator<T, ?> operator, @Nullable OutputTag<T> outputTag) {
+        this(operator, (OperatorMetricGroup) operator.getMetricGroup(), outputTag, operator::close);
     }
 
     public ChainingOutput(
             Input<T> input,
             OperatorMetricGroup operatorMetricGroup,
-            StreamStatusProvider streamStatusProvider,
             @Nullable OutputTag<T> outputTag,
             @Nullable AutoCloseable closeable) {
         this.input = input;
@@ -80,7 +69,6 @@ class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>>
             numRecordsIn = tmpNumRecordsIn;
         }
 
-        this.streamStatusProvider = streamStatusProvider;
         this.outputTag = outputTag;
     }
 
@@ -120,9 +108,7 @@ class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>>
     public void emitWatermark(Watermark mark) {
         try {
             watermarkGauge.setCurrentWatermark(mark.getTimestamp());
-            if (streamStatusProvider.getStreamStatus().isActive()) {
-                input.processWatermark(mark);
-            }
+            input.processWatermark(mark);
         } catch (Exception e) {
             throw new ExceptionInChainedOperatorException(e);
         }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingBroadcastingOutputCollector.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingBroadcastingOutputCollector.java
index 5e761bfe7d0..9e179b4c464 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingBroadcastingOutputCollector.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingBroadcastingOutputCollector.java
@@ -19,7 +19,6 @@ package org.apache.flink.streaming.runtime.tasks;
 
 import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 
 /**
@@ -28,9 +27,8 @@ import org.apache.flink.util.OutputTag;
  */
 final class CopyingBroadcastingOutputCollector<T> extends BroadcastingOutputCollector<T> {
 
-    public CopyingBroadcastingOutputCollector(
-            Output<StreamRecord<T>>[] outputs, StreamStatusProvider streamStatusProvider) {
-        super(outputs, streamStatusProvider);
+    public CopyingBroadcastingOutputCollector(Output<StreamRecord<T>>[] outputs) {
+        super(outputs);
     }
 
     @Override
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingChainingOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingChainingOutput.java
index 151ccaafee6..8a43e7a6cff 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingChainingOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/CopyingChainingOutput.java
@@ -20,7 +20,6 @@ package org.apache.flink.streaming.runtime.tasks;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 
 final class CopyingChainingOutput<T> extends ChainingOutput<T> {
@@ -30,9 +29,8 @@ final class CopyingChainingOutput<T> extends ChainingOutput<T> {
     public CopyingChainingOutput(
             OneInputStreamOperator<T, ?> operator,
             TypeSerializer<T> serializer,
-            OutputTag<T> outputTag,
-            StreamStatusProvider streamStatusProvider) {
-        super(operator, streamStatusProvider, outputTag);
+            OutputTag<T> outputTag) {
+        super(operator, outputTag);
         this.serializer = serializer;
     }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java
index 20daeaf61bc..20d775a258a 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java
@@ -162,7 +162,6 @@ public class MultipleInputStreamTask<OUT>
                         getEnvironment().getMemoryManager(),
                         getEnvironment().getMetricGroup().getIOMetricGroup(),
                         setupNumRecordsInCounter(mainOperator),
-                        getStreamStatusMaintainer(),
                         mainOperator,
                         inputWatermarkGauges,
                         getConfiguration(),
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
index d8b458b453c..b1497a9c9aa 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
@@ -30,7 +30,6 @@ import org.apache.flink.streaming.api.graph.StreamConfig;
 import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.streaming.api.operators.sort.SortingDataInput;
 import org.apache.flink.streaming.api.watermark.Watermark;
-import org.apache.flink.streaming.runtime.io.AbstractDataOutput;
 import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput.DataOutput;
 import org.apache.flink.streaming.runtime.io.StreamOneInputProcessor;
 import org.apache.flink.streaming.runtime.io.StreamTaskInput;
@@ -43,7 +42,6 @@ import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 
 import javax.annotation.Nullable;
 
@@ -150,8 +148,7 @@ public class OneInputStreamTask<IN, OUT> extends StreamTask<OUT, OneInputStreamO
     }
 
     private DataOutput<IN> createDataOutput(Counter numRecordsIn) {
-        return new StreamTaskNetworkOutput<>(
-                mainOperator, getStreamStatusMaintainer(), inputWatermarkGauge, numRecordsIn);
+        return new StreamTaskNetworkOutput<>(mainOperator, inputWatermarkGauge, numRecordsIn);
     }
 
     private StreamTaskInput<IN> createTaskInput(CheckpointedInputGate inputGate) {
@@ -180,7 +177,7 @@ public class OneInputStreamTask<IN, OUT> extends StreamTask<OUT, OneInputStreamO
      * The network data output implementation used for processing stream elements from {@link
      * StreamTaskNetworkInput} in one input processor.
      */
-    private static class StreamTaskNetworkOutput<IN> extends AbstractDataOutput<IN> {
+    private static class StreamTaskNetworkOutput<IN> implements DataOutput<IN> {
 
         private final OneInputStreamOperator<IN, ?> operator;
 
@@ -189,10 +186,8 @@ public class OneInputStreamTask<IN, OUT> extends StreamTask<OUT, OneInputStreamO
 
         private StreamTaskNetworkOutput(
                 OneInputStreamOperator<IN, ?> operator,
-                StreamStatusMaintainer streamStatusMaintainer,
                 WatermarkGauge watermarkGauge,
                 Counter numRecordsIn) {
-            super(streamStatusMaintainer);
 
             this.operator = checkNotNull(operator);
             this.watermarkGauge = checkNotNull(watermarkGauge);
@@ -213,14 +208,13 @@ public class OneInputStreamTask<IN, OUT> extends StreamTask<OUT, OneInputStreamO
         }
 
         @Override
-        public void emitLatencyMarker(LatencyMarker latencyMarker) throws Exception {
-            operator.processLatencyMarker(latencyMarker);
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+            operator.emitStreamStatus(streamStatus);
         }
 
         @Override
-        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
-            super.emitStreamStatus(streamStatus);
-            operator.emitStreamStatus(streamStatus);
+        public void emitLatencyMarker(LatencyMarker latencyMarker) throws Exception {
+            operator.processLatencyMarker(latencyMarker);
         }
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java
index d6d11ed6b15..10f74b98613 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java
@@ -50,7 +50,6 @@ import org.apache.flink.streaming.runtime.io.RecordWriterOutput;
 import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxExecutorFactory;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.OutputTag;
@@ -87,8 +86,7 @@ import static org.apache.flink.util.Preconditions.checkState;
  *     operator.
  */
 @Internal
-public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
-        implements StreamStatusMaintainer, BoundedMultiInput {
+public class OperatorChain<OUT, OP extends StreamOperator<OUT>> implements BoundedMultiInput {
 
     private static final Logger LOG = LoggerFactory.getLogger(OperatorChain.class);
 
@@ -363,12 +361,7 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
          * Chained sources are closed when {@link
          * org.apache.flink.streaming.runtime.io.StreamTaskSourceInput} are being closed.
          */
-        return new ChainingOutput<>(input, metricGroup, this, outputTag, null);
-    }
-
-    @Override
-    public StreamStatus getStreamStatus() {
-        return streamStatus;
+        return new ChainingOutput<>(input, metricGroup, outputTag, null);
     }
 
     public OperatorEventDispatcher getOperatorEventDispatcher() {
@@ -380,13 +373,6 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
         operatorEventDispatcher.dispatchEventToHandlers(operator, event);
     }
 
-    @Override
-    public void toggleStreamStatus(StreamStatus status) {
-        if (!status.equals(this.streamStatus)) {
-            this.streamStatus = status;
-        }
-    }
-
     public void broadcastEvent(AbstractEvent event) throws IOException {
         broadcastEvent(event, false);
     }
@@ -471,7 +457,8 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
         return mainOperatorOutput;
     }
 
-    public Output<StreamRecord<?>> getChainedSourceOutput(SourceInputConfig sourceInput) {
+    public WatermarkGaugeExposingOutput<StreamRecord<?>> getChainedSourceOutput(
+            SourceInputConfig sourceInput) {
         checkArgument(
                 chainedSources.containsKey(sourceInput),
                 "Chained source with sourcedId = [%s] was not found",
@@ -585,9 +572,9 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
             // If the chaining output does not copy we need to copy in the broadcast output,
             // otherwise multi-chaining would not work correctly.
             if (containingTask.getExecutionConfig().isObjectReuseEnabled()) {
-                return new CopyingBroadcastingOutputCollector<>(asArray, this);
+                return new CopyingBroadcastingOutputCollector<>(asArray);
             } else {
-                return new BroadcastingOutputCollector<>(asArray, this);
+                return new BroadcastingOutputCollector<>(asArray);
             }
         }
     }
@@ -677,12 +664,11 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
 
         WatermarkGaugeExposingOutput<StreamRecord<IN>> currentOperatorOutput;
         if (containingTask.getExecutionConfig().isObjectReuseEnabled()) {
-            currentOperatorOutput = new ChainingOutput<>(operator, this, outputTag);
+            currentOperatorOutput = new ChainingOutput<>(operator, outputTag);
         } else {
             TypeSerializer<IN> inSerializer =
                     operatorConfig.getTypeSerializerIn1(userCodeClassloader);
-            currentOperatorOutput =
-                    new CopyingChainingOutput<>(operator, inSerializer, outputTag, this);
+            currentOperatorOutput = new CopyingChainingOutput<>(operator, inSerializer, outputTag);
         }
 
         // wrap watermark gauges since registered metrics must be unique
@@ -717,11 +703,7 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
         }
 
         return new RecordWriterOutput<>(
-                recordWriter,
-                outSerializer,
-                sideOutputTag,
-                this,
-                edge.supportsUnalignedCheckpoints());
+                recordWriter, outSerializer, sideOutputTag, edge.supportsUnalignedCheckpoints());
     }
 
     /**
@@ -778,7 +760,7 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
             this.sourceTaskInput = sourceTaskInput;
         }
 
-        public Output<StreamRecord<?>> getSourceOutput() {
+        public WatermarkGaugeExposingOutput<StreamRecord<?>> getSourceOutput() {
             return chainedSourceOutput;
         }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
index 8b895f6ee79..290de9a3a88 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
@@ -31,7 +31,6 @@ import org.apache.flink.runtime.state.CheckpointStorageLocationReference;
 import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.operators.SourceOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
-import org.apache.flink.streaming.runtime.io.AbstractDataOutput;
 import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput.DataOutput;
 import org.apache.flink.streaming.runtime.io.StreamOneInputProcessor;
 import org.apache.flink.streaming.runtime.io.StreamTaskExternallyInducedSourceInput;
@@ -41,7 +40,6 @@ import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 
 import javax.annotation.Nullable;
 
@@ -100,10 +98,7 @@ public class SourceOperatorStreamTask<T> extends StreamTask<T, SourceOperator<T,
         // a WatermarkGauge on the input.
         output =
                 new AsyncDataOutputToOutput<>(
-                        operatorChain.getMainOperatorOutput(),
-                        getStreamStatusMaintainer(),
-                        numRecordsOut,
-                        null);
+                        operatorChain.getMainOperatorOutput(), numRecordsOut, null);
 
         inputProcessor = new StreamOneInputProcessor<>(input, output, operatorChain);
     }
@@ -157,7 +152,7 @@ public class SourceOperatorStreamTask<T> extends StreamTask<T, SourceOperator<T,
     // ---------------------------
 
     /** Implementation of {@link DataOutput} that wraps a specific {@link Output}. */
-    public static class AsyncDataOutputToOutput<T> extends AbstractDataOutput<T> {
+    public static class AsyncDataOutputToOutput<T> implements DataOutput<T> {
 
         private final Output<StreamRecord<T>> output;
         private final Counter numRecordsOut;
@@ -165,10 +160,8 @@ public class SourceOperatorStreamTask<T> extends StreamTask<T, SourceOperator<T,
 
         public AsyncDataOutputToOutput(
                 Output<StreamRecord<T>> output,
-                StreamStatusMaintainer streamStatusMaintainer,
                 Counter numRecordsOut,
                 @Nullable WatermarkGauge inputWatermarkGauge) {
-            super(streamStatusMaintainer);
 
             this.output = checkNotNull(output);
             this.numRecordsOut = numRecordsOut;
@@ -196,7 +189,6 @@ public class SourceOperatorStreamTask<T> extends StreamTask<T, SourceOperator<T,
 
         @Override
         public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
-            super.emitStreamStatus(streamStatus);
             output.emitStreamStatus(streamStatus);
         }
     }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
index ae3e6637bc0..2b791403dae 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
@@ -266,7 +266,7 @@ public class SourceStreamTask<
         @Override
         public void run() {
             try {
-                mainOperator.run(lock, getStreamStatusMaintainer(), operatorChain);
+                mainOperator.run(lock, operatorChain);
                 if (!wasStoppedExternally && !isCanceled()) {
                     synchronized (lock) {
                         operatorChain.setIgnoreEndOfInput(false);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index 9998743c9d4..2cda12a1a3f 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -77,7 +77,6 @@ import org.apache.flink.streaming.runtime.io.StreamInputProcessor;
 import org.apache.flink.streaming.runtime.partitioner.ConfigurableStreamPartitioner;
 import org.apache.flink.streaming.runtime.partitioner.StreamPartitioner;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxDefaultAction;
 import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxDefaultAction.Suspension;
 import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxExecutorFactory;
@@ -931,10 +930,6 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
         return configuration;
     }
 
-    public StreamStatusMaintainer getStreamStatusMaintainer() {
-        return operatorChain;
-    }
-
     RecordWriterOutput<?>[] getStreamOutputs() {
         return operatorChain.getStreamOutputs();
     }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
index 1db4da66b8d..6f15b8bda2b 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
@@ -70,7 +70,6 @@ public class TwoInputStreamTask<IN1, IN2, OUT> extends AbstractTwoInputStreamTas
                         getEnvironment().getIOManager(),
                         getEnvironment().getMemoryManager(),
                         getEnvironment().getMetricGroup().getIOMetricGroup(),
-                        getStreamStatusMaintainer(),
                         mainOperator,
                         input1WatermarkGauge,
                         input2WatermarkGauge,
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperatorLifecycleTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperatorLifecycleTest.java
index 9e15fe20340..86973533345 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperatorLifecycleTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractUdfStreamOperatorLifecycleTest.java
@@ -36,7 +36,6 @@ import org.apache.flink.streaming.api.functions.source.RichSourceFunction;
 import org.apache.flink.streaming.api.functions.source.SourceFunction;
 import org.apache.flink.streaming.api.graph.StreamConfig;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.OperatorChain;
 import org.apache.flink.streaming.runtime.tasks.SourceStreamTask;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
@@ -253,12 +252,11 @@ public class AbstractUdfStreamOperatorLifecycleTest {
         @Override
         public void run(
                 Object lockingObject,
-                StreamStatusMaintainer streamStatusMaintainer,
                 Output<StreamRecord<OUT>> collector,
                 OperatorChain<?, ?> operatorChain)
                 throws Exception {
             ACTUAL_ORDER_TRACKING.add("OPERATOR::run");
-            super.run(lockingObject, streamStatusMaintainer, collector, operatorChain);
+            super.run(lockingObject, collector, operatorChain);
             runStarted.trigger();
             runFinish.await();
         }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/MockStreamStatusMaintainer.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/MockStreamStatusMaintainer.java
deleted file mode 100644
index df63bd01953..00000000000
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/MockStreamStatusMaintainer.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.streaming.api.operators;
-
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
-
-/** A testing implementation of {@link StreamStatusMaintainer}. */
-public class MockStreamStatusMaintainer implements StreamStatusMaintainer {
-    private StreamStatus currentStreamStatus = StreamStatus.ACTIVE;
-
-    @Override
-    public void toggleStreamStatus(StreamStatus streamStatus) {
-        if (!currentStreamStatus.equals(streamStatus)) {
-            currentStreamStatus = streamStatus;
-        }
-    }
-
-    @Override
-    public StreamStatus getStreamStatus() {
-        return currentStreamStatus;
-    }
-}
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamSourceContextIdleDetectionTests.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamSourceContextIdleDetectionTests.java
index e5468fd0b2c..345c43bc36a 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamSourceContextIdleDetectionTests.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/StreamSourceContextIdleDetectionTests.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.functions.source.SourceFunction;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.TestProcessingTimeService;
 import org.apache.flink.streaming.util.CollectorOutput;
 
@@ -35,8 +36,9 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
+import static org.hamcrest.Matchers.equalTo;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertThat;
 
 /** Tests for {@link StreamSource} awareness of source idleness. */
 @RunWith(Parameterized.class)
@@ -86,16 +88,14 @@ public class StreamSourceContextIdleDetectionTests {
         processingTimeService.setCurrentTime(initialTime);
 
         final List<StreamElement> output = new ArrayList<>();
-
-        MockStreamStatusMaintainer mockStreamStatusMaintainer = new MockStreamStatusMaintainer();
+        final List<StreamElement> expectedOutput = new ArrayList<>();
 
         SourceFunction.SourceContext<String> context =
                 StreamSourceContexts.getSourceContext(
                         TimeCharacteristic.EventTime,
                         processingTimeService,
                         new Object(),
-                        mockStreamStatusMaintainer,
-                        new CollectorOutput<String>(output),
+                        new CollectorOutput<>(output),
                         0,
                         idleTimeout);
 
@@ -103,54 +103,64 @@ public class StreamSourceContextIdleDetectionTests {
 
         // corresponds to step (2) of scenario (please see method-level Javadoc comment)
         processingTimeService.setCurrentTime(initialTime + idleTimeout);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
+        expectedOutput.add(StreamStatus.IDLE);
+        assertThat(output, equalTo(expectedOutput));
 
         // corresponds to step (3) of scenario (please see method-level Javadoc comment)
         processingTimeService.setCurrentTime(initialTime + 2 * idleTimeout);
         processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
+        assertThat(output, equalTo(expectedOutput));
 
         // corresponds to step (4) of scenario (please see method-level Javadoc comment)
-        processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout + idleTimeout / 10);
-        switch (testMethod) {
-            case COLLECT:
-                context.collect("msg");
-                break;
-            case COLLECT_WITH_TIMESTAMP:
-                context.collectWithTimestamp(
-                        "msg", processingTimeService.getCurrentProcessingTime());
-                break;
-            case EMIT_WATERMARK:
-                context.emitWatermark(
-                        new Watermark(processingTimeService.getCurrentProcessingTime()));
-                break;
-        }
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
+        expectedOutput.add(StreamStatus.ACTIVE);
+        emitStreamElement(
+                initialTime + 3 * idleTimeout + idleTimeout / 10,
+                expectedOutput,
+                processingTimeService,
+                context);
+        assertThat(output, equalTo(expectedOutput));
 
         // corresponds to step (5) of scenario (please see method-level Javadoc comment)
-        processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout + 2 * idleTimeout / 10);
+        emitStreamElement(
+                initialTime + 3 * idleTimeout + 2 * idleTimeout / 10,
+                expectedOutput,
+                processingTimeService,
+                context);
+        assertThat(output, equalTo(expectedOutput));
+
+        // corresponds to step (6) of scenario (please see method-level Javadoc comment)
+        processingTimeService.setCurrentTime(initialTime + 4 * idleTimeout + idleTimeout / 10);
+        assertThat(output, equalTo(expectedOutput));
+
+        // corresponds to step (7) of scenario (please see method-level Javadoc comment)
+        processingTimeService.setCurrentTime(initialTime + 5 * idleTimeout + idleTimeout / 10);
+        expectedOutput.add(StreamStatus.IDLE);
+        assertThat(output, equalTo(expectedOutput));
+    }
+
+    private void emitStreamElement(
+            long currentTime,
+            List<StreamElement> expectedOutput,
+            TestProcessingTimeService processingTimeService,
+            SourceFunction.SourceContext<String> context)
+            throws Exception {
+        processingTimeService.setCurrentTime(currentTime);
         switch (testMethod) {
             case COLLECT:
+                expectedOutput.add(new StreamRecord<>("msg"));
                 context.collect("msg");
                 break;
             case COLLECT_WITH_TIMESTAMP:
-                context.collectWithTimestamp(
-                        "msg", processingTimeService.getCurrentProcessingTime());
+                long recordTime = processingTimeService.getCurrentProcessingTime();
+                expectedOutput.add(new StreamRecord<>("msg", recordTime));
+                context.collectWithTimestamp("msg", recordTime);
                 break;
             case EMIT_WATERMARK:
-                context.emitWatermark(
-                        new Watermark(processingTimeService.getCurrentProcessingTime()));
+                long watermarkTime = processingTimeService.getCurrentProcessingTime();
+                expectedOutput.add(new Watermark(watermarkTime));
+                context.emitWatermark(new Watermark(watermarkTime));
                 break;
         }
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
-
-        // corresponds to step (6) of scenario (please see method-level Javadoc comment)
-        processingTimeService.setCurrentTime(initialTime + 4 * idleTimeout + idleTimeout / 10);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
-
-        // corresponds to step (7) of scenario (please see method-level Javadoc comment)
-        processingTimeService.setCurrentTime(initialTime + 5 * idleTimeout + idleTimeout / 10);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
     }
 
     /**
@@ -176,8 +186,6 @@ public class StreamSourceContextIdleDetectionTests {
         TestProcessingTimeService processingTimeService = new TestProcessingTimeService();
         processingTimeService.setCurrentTime(initialTime);
 
-        MockStreamStatusMaintainer mockStreamStatusMaintainer = new MockStreamStatusMaintainer();
-
         final List<StreamElement> output = new ArrayList<>();
         final List<StreamElement> expectedOutput = new ArrayList<>();
 
@@ -186,7 +194,6 @@ public class StreamSourceContextIdleDetectionTests {
                         TimeCharacteristic.IngestionTime,
                         processingTimeService,
                         new Object(),
-                        mockStreamStatusMaintainer,
                         new CollectorOutput<String>(output),
                         watermarkInterval,
                         idleTimeout);
@@ -207,7 +214,7 @@ public class StreamSourceContextIdleDetectionTests {
                                 - (processingTimeService.getCurrentProcessingTime()
                                         % watermarkInterval)));
         processingTimeService.setCurrentTime(initialTime + idleTimeout);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
+        expectedOutput.add(StreamStatus.IDLE);
         assertEquals(expectedOutput, output);
 
         // corresponds to step (3) of scenario (please see method-level Javadoc comment)
@@ -217,13 +224,13 @@ public class StreamSourceContextIdleDetectionTests {
         processingTimeService.setCurrentTime(initialTime + 6 * watermarkInterval);
         processingTimeService.setCurrentTime(initialTime + 7 * watermarkInterval);
         processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
         assertEquals(expectedOutput, output);
 
         // corresponds to step (4) of scenario (please see method-level Javadoc comment)
         processingTimeService.setCurrentTime(initialTime + 3 * idleTimeout + idleTimeout / 10);
         switch (testMethod) {
             case COLLECT:
+                expectedOutput.add(StreamStatus.ACTIVE);
                 context.collect("msg");
                 expectedOutput.add(
                         new StreamRecord<>(
@@ -233,10 +240,10 @@ public class StreamSourceContextIdleDetectionTests {
                                 processingTimeService.getCurrentProcessingTime()
                                         - (processingTimeService.getCurrentProcessingTime()
                                                 % watermarkInterval)));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
                 assertEquals(expectedOutput, output);
                 break;
             case COLLECT_WITH_TIMESTAMP:
+                expectedOutput.add(StreamStatus.ACTIVE);
                 context.collectWithTimestamp(
                         "msg", processingTimeService.getCurrentProcessingTime());
                 expectedOutput.add(
@@ -247,7 +254,6 @@ public class StreamSourceContextIdleDetectionTests {
                                 processingTimeService.getCurrentProcessingTime()
                                         - (processingTimeService.getCurrentProcessingTime()
                                                 % watermarkInterval)));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
                 assertEquals(expectedOutput, output);
                 break;
             case EMIT_WATERMARK:
@@ -256,7 +262,6 @@ public class StreamSourceContextIdleDetectionTests {
                 // from here on, the status should remain idle for the emitWatermark variant test
                 context.emitWatermark(
                         new Watermark(processingTimeService.getCurrentProcessingTime()));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
                 assertEquals(expectedOutput, output);
         }
 
@@ -269,7 +274,6 @@ public class StreamSourceContextIdleDetectionTests {
                 expectedOutput.add(
                         new StreamRecord<>(
                                 "msg", processingTimeService.getCurrentProcessingTime()));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
                 assertEquals(expectedOutput, output);
                 break;
             case COLLECT_WITH_TIMESTAMP:
@@ -278,13 +282,11 @@ public class StreamSourceContextIdleDetectionTests {
                 expectedOutput.add(
                         new StreamRecord<>(
                                 "msg", processingTimeService.getCurrentProcessingTime()));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
                 assertEquals(expectedOutput, output);
                 break;
             case EMIT_WATERMARK:
                 context.emitWatermark(
                         new Watermark(processingTimeService.getCurrentProcessingTime()));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
                 assertEquals(expectedOutput, output);
         }
 
@@ -297,11 +299,9 @@ public class StreamSourceContextIdleDetectionTests {
                                 processingTimeService.getCurrentProcessingTime()
                                         - (processingTimeService.getCurrentProcessingTime()
                                                 % watermarkInterval)));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
                 assertEquals(expectedOutput, output);
                 break;
             case EMIT_WATERMARK:
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
                 assertEquals(expectedOutput, output);
         }
 
@@ -314,30 +314,22 @@ public class StreamSourceContextIdleDetectionTests {
                                 processingTimeService.getCurrentProcessingTime()
                                         - (processingTimeService.getCurrentProcessingTime()
                                                 % watermarkInterval)));
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
                 assertEquals(expectedOutput, output);
                 break;
             case EMIT_WATERMARK:
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
                 assertEquals(expectedOutput, output);
         }
 
         // corresponds to step (6) of scenario (please see method-level Javadoc comment)
         processingTimeService.setCurrentTime(initialTime + 4 * idleTimeout + idleTimeout / 10);
-        switch (testMethod) {
-            case COLLECT:
-            case COLLECT_WITH_TIMESTAMP:
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isActive());
-                assertEquals(expectedOutput, output);
-                break;
-            case EMIT_WATERMARK:
-                assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
-                assertEquals(expectedOutput, output);
-        }
+        assertEquals(expectedOutput, output);
 
         // corresponds to step (7) of scenario (please see method-level Javadoc comment)
         processingTimeService.setCurrentTime(initialTime + 11 * watermarkInterval);
-        assertTrue(mockStreamStatusMaintainer.getStreamStatus().isIdle());
+        // emit watermark does not change the previous status
+        if (testMethod != TestMethod.EMIT_WATERMARK) {
+            expectedOutput.add(StreamStatus.IDLE);
+        }
         assertEquals(expectedOutput, output);
     }
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorLatencyMetricsTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorLatencyMetricsTest.java
index 8494dcfb970..b89a92da03d 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorLatencyMetricsTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorLatencyMetricsTest.java
@@ -34,7 +34,6 @@ import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.operators.StreamSource;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.OperatorChain;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
 import org.apache.flink.streaming.runtime.tasks.TestProcessingTimeService;
@@ -190,11 +189,7 @@ public class StreamSourceOperatorLatencyMetricsTest extends TestLogger {
                                 operator.getOperatorConfig(),
                                 new MockEnvironmentBuilder().build()));
         try {
-            operator.run(
-                    new Object(),
-                    mock(StreamStatusMaintainer.class),
-                    new CollectorOutput<>(output),
-                    operatorChain);
+            operator.run(new Object(), new CollectorOutput<>(output), operatorChain);
             operator.close();
         } finally {
             operatorChain.releaseOutputs();
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorWatermarksTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorWatermarksTest.java
index 45221f4f085..fcdaa4dc17e 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorWatermarksTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/StreamSourceOperatorWatermarksTest.java
@@ -37,8 +37,6 @@ import org.apache.flink.streaming.api.operators.StreamSourceContexts;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.SourceStreamTask;
 import org.apache.flink.streaming.runtime.tasks.StreamTaskTestHarness;
 import org.apache.flink.streaming.runtime.tasks.TestProcessingTimeService;
@@ -59,7 +57,6 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
 
 /** Tests for {@link StreamSource} operators. */
 @SuppressWarnings("serial")
@@ -157,7 +154,6 @@ public class StreamSourceOperatorWatermarksTest {
                 TimeCharacteristic.IngestionTime,
                 processingTimeService,
                 task.getCheckpointLock(),
-                operator.getContainingTask().getStreamStatusMaintainer(),
                 new CollectorOutput<String>(output),
                 operator.getExecutionConfig().getAutoWatermarkInterval(),
                 -1);
@@ -201,14 +197,10 @@ public class StreamSourceOperatorWatermarksTest {
 
         Environment env = new DummyEnvironment("MockTwoInputTask", 1, 0);
 
-        StreamStatusMaintainer streamStatusMaintainer = mock(StreamStatusMaintainer.class);
-        when(streamStatusMaintainer.getStreamStatus()).thenReturn(StreamStatus.ACTIVE);
-
         MockStreamTask mockTask =
                 new MockStreamTaskBuilder(env)
                         .setConfig(cfg)
                         .setExecutionConfig(executionConfig)
-                        .setStreamStatusMaintainer(streamStatusMaintainer)
                         .setTimerService(timeProvider)
                         .build();
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java
index f317e8f04ec..858f0229535 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java
@@ -264,146 +264,6 @@ public class OneInputStreamTaskTest extends TestLogger {
         assertEquals(2, resultElements.size());
     }
 
-    /**
-     * This test verifies that watermarks are not forwarded when the task is idle. It also verifies
-     * that when task is idle, watermarks generated in the middle of chains are also blocked and
-     * never forwarded.
-     *
-     * <p>The tested chain will be: (HEAD: normal operator) --> (watermark generating operator) -->
-     * (normal operator). The operators will throw an exception and fail the test if either of them
-     * were forwarded watermarks when the task is idle.
-     */
-    @Test
-    public void testWatermarksNotForwardedWithinChainWhenIdle() throws Exception {
-
-        final OneInputStreamTaskTestHarness<String, String> testHarness =
-                new OneInputStreamTaskTestHarness<>(
-                        OneInputStreamTask::new,
-                        1,
-                        1,
-                        BasicTypeInfo.STRING_TYPE_INFO,
-                        BasicTypeInfo.STRING_TYPE_INFO);
-
-        TriggerableFailOnWatermarkTestOperator headOperator =
-                new TriggerableFailOnWatermarkTestOperator();
-        WatermarkGeneratingTestOperator watermarkOperator = new WatermarkGeneratingTestOperator();
-        TriggerableFailOnWatermarkTestOperator tailOperator =
-                new TriggerableFailOnWatermarkTestOperator();
-
-        testHarness
-                .setupOperatorChain(new OperatorID(42L, 42L), headOperator)
-                .chain(new OperatorID(4711L, 42L), watermarkOperator, StringSerializer.INSTANCE)
-                .chain(new OperatorID(123L, 123L), tailOperator, StringSerializer.INSTANCE)
-                .finish();
-
-        // --------------------- begin test ---------------------
-
-        ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();
-
-        testHarness.invoke();
-        testHarness.waitForTaskRunning();
-
-        // the task starts as active, so all generated watermarks should be forwarded
-        testHarness.processElement(
-                new StreamRecord<>(
-                        TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER));
-
-        testHarness.processElement(new StreamRecord<>("10"), 0, 0);
-
-        // this watermark will be forwarded since the task is currently active,
-        // but should not be in the final output because it should be blocked by the watermark
-        // generator in the chain
-        testHarness.processElement(new Watermark(15));
-
-        testHarness.processElement(new StreamRecord<>("20"), 0, 0);
-        testHarness.processElement(new StreamRecord<>("30"), 0, 0);
-
-        testHarness.waitForInputProcessing();
-
-        expectedOutput.add(
-                new StreamRecord<>(
-                        TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER));
-        expectedOutput.add(new StreamRecord<>("10"));
-        expectedOutput.add(new Watermark(10));
-        expectedOutput.add(new StreamRecord<>("20"));
-        expectedOutput.add(new Watermark(20));
-        expectedOutput.add(new StreamRecord<>("30"));
-        expectedOutput.add(new Watermark(30));
-        TestHarnessUtil.assertOutputEquals(
-                "Output was not correct.", expectedOutput, testHarness.getOutput());
-
-        // now, toggle the task to be idle, and let the watermark generator produce some watermarks
-        testHarness.processElement(StreamStatus.IDLE);
-
-        // after this, the operators will throw an exception if they are forwarded watermarks
-        // anywhere in the chain
-        testHarness.processElement(
-                new StreamRecord<>(
-                        TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER));
-
-        // NOTE: normally, tasks will not have records to process while idle;
-        // we're doing this here only to mimic watermark generating in operators
-        testHarness.processElement(new StreamRecord<>("40"), 0, 0);
-        testHarness.processElement(new StreamRecord<>("50"), 0, 0);
-        testHarness.processElement(new StreamRecord<>("60"), 0, 0);
-        testHarness.processElement(
-                new Watermark(
-                        65)); // the test will fail if any of the operators were forwarded this
-        testHarness.waitForInputProcessing();
-
-        // the 40 - 60 watermarks should not be forwarded, only the stream status toggle element and
-        // records
-        expectedOutput.add(StreamStatus.IDLE);
-        expectedOutput.add(StreamStatus.ACTIVE);
-        expectedOutput.add(
-                new StreamRecord<>(
-                        TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER));
-        expectedOutput.add(StreamStatus.IDLE);
-        expectedOutput.add(StreamStatus.ACTIVE);
-        expectedOutput.add(new StreamRecord<>("40"));
-        expectedOutput.add(StreamStatus.IDLE);
-        expectedOutput.add(StreamStatus.ACTIVE);
-        expectedOutput.add(new StreamRecord<>("50"));
-        expectedOutput.add(StreamStatus.IDLE);
-        expectedOutput.add(StreamStatus.ACTIVE);
-        expectedOutput.add(new StreamRecord<>("60"));
-        expectedOutput.add(StreamStatus.IDLE);
-        TestHarnessUtil.assertOutputEquals(
-                "Output was not correct.", expectedOutput, testHarness.getOutput());
-
-        // re-toggle the task to be active and see if new watermarks are correctly forwarded again
-        testHarness.processElement(StreamStatus.ACTIVE);
-        testHarness.processElement(
-                new StreamRecord<>(
-                        TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER));
-
-        testHarness.processElement(new StreamRecord<>("70"), 0, 0);
-        testHarness.processElement(new StreamRecord<>("80"), 0, 0);
-        testHarness.processElement(new StreamRecord<>("90"), 0, 0);
-        testHarness.waitForInputProcessing();
-
-        expectedOutput.add(StreamStatus.ACTIVE);
-        expectedOutput.add(
-                new StreamRecord<>(
-                        TriggerableFailOnWatermarkTestOperator.EXPECT_FORWARDED_WATERMARKS_MARKER));
-        expectedOutput.add(new StreamRecord<>("70"));
-        expectedOutput.add(new Watermark(70));
-        expectedOutput.add(new StreamRecord<>("80"));
-        expectedOutput.add(new Watermark(80));
-        expectedOutput.add(new StreamRecord<>("90"));
-        expectedOutput.add(new Watermark(90));
-        TestHarnessUtil.assertOutputEquals(
-                "Output was not correct.", expectedOutput, testHarness.getOutput());
-
-        testHarness.endInput();
-
-        testHarness.waitForTaskCompletion();
-
-        List<String> resultElements =
-                TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput());
-        assertEquals(12, resultElements.size());
-    }
-
     /** This test verifies that checkpoint barriers are correctly forwarded. */
     @Test
     public void testCheckpointBarriers() throws Exception {
@@ -1139,81 +999,4 @@ public class OneInputStreamTaskTest extends TestLogger {
             return value;
         }
     }
-
-    /** A {@link TriggerableFailOnWatermarkTestOperator} that generates watermarks. */
-    private static class WatermarkGeneratingTestOperator
-            extends TriggerableFailOnWatermarkTestOperator {
-
-        private static final long serialVersionUID = -5064871833244157221L;
-
-        private long lastWatermark;
-
-        @Override
-        protected void handleElement(StreamRecord<String> element) {
-            long timestamp = Long.valueOf(element.getValue());
-            if (timestamp > lastWatermark) {
-                output.emitWatermark(new Watermark(timestamp));
-                lastWatermark = timestamp;
-            }
-        }
-
-        @Override
-        protected void handleWatermark(Watermark mark) {
-            if (mark.equals(Watermark.MAX_WATERMARK)) {
-                output.emitWatermark(mark);
-                lastWatermark = Long.MAX_VALUE;
-            }
-        }
-    }
-
-    /**
-     * An operator that can be triggered whether or not to expect watermarks forwarded to it,
-     * toggled by letting it process special trigger marker records.
-     *
-     * <p>If it receives a watermark when it's not expecting one, it'll throw an exception and fail.
-     */
-    private static class TriggerableFailOnWatermarkTestOperator
-            extends AbstractStreamOperator<String>
-            implements OneInputStreamOperator<String, String> {
-
-        private static final long serialVersionUID = 2048954179291813243L;
-
-        public static final String EXPECT_FORWARDED_WATERMARKS_MARKER = "EXPECT_WATERMARKS";
-        public static final String NO_FORWARDED_WATERMARKS_MARKER = "NO_WATERMARKS";
-
-        protected boolean expectForwardedWatermarks;
-
-        @Override
-        public void processElement(StreamRecord<String> element) throws Exception {
-            output.collect(element);
-
-            if (element.getValue().equals(EXPECT_FORWARDED_WATERMARKS_MARKER)) {
-                this.expectForwardedWatermarks = true;
-            } else if (element.getValue().equals(NO_FORWARDED_WATERMARKS_MARKER)) {
-                this.expectForwardedWatermarks = false;
-            } else {
-                handleElement(element);
-            }
-        }
-
-        @Override
-        public void processWatermark(Watermark mark) throws Exception {
-            if (!expectForwardedWatermarks) {
-                throw new Exception(
-                        "Received a "
-                                + mark
-                                + ", but this operator should not be forwarded watermarks.");
-            } else {
-                handleWatermark(mark);
-            }
-        }
-
-        protected void handleElement(StreamRecord<String> element) {
-            // do nothing
-        }
-
-        protected void handleWatermark(Watermark mark) {
-            output.emitWatermark(mark);
-        }
-    }
 }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OperatorChainTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OperatorChainTest.java
index 39132c09401..23555b6722d 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OperatorChainTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OperatorChainTest.java
@@ -30,7 +30,6 @@ import org.apache.flink.streaming.api.operators.StreamOperator;
 import org.apache.flink.streaming.runtime.io.RecordWriterOutput;
 import org.apache.flink.streaming.runtime.operators.StreamOperatorChainingTest;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.streaming.util.MockStreamTaskBuilder;
 
 import org.junit.Test;
@@ -43,7 +42,6 @@ import java.util.concurrent.atomic.AtomicInteger;
 import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
 
 /**
  * This class test the {@link OperatorChain}.
@@ -81,7 +79,6 @@ public class OperatorChainTest {
         try (MockEnvironment env = MockEnvironment.builder().build()) {
             final StreamTask<?, ?> containingTask = new MockStreamTaskBuilder(env).build();
 
-            final StreamStatusProvider statusProvider = mock(StreamStatusProvider.class);
             final StreamConfig cfg = new StreamConfig(new Configuration());
 
             final List<StreamOperatorWrapper<?, ?>> operatorWrappers = new ArrayList<>();
@@ -89,7 +86,7 @@ public class OperatorChainTest {
             // initial output goes to nowhere
             @SuppressWarnings({"unchecked", "rawtypes"})
             WatermarkGaugeExposingOutput<StreamRecord<T>> lastWriter =
-                    new BroadcastingOutputCollector<>(new Output[0], statusProvider);
+                    new BroadcastingOutputCollector<>(new Output[0]);
 
             // build the reverse operators array
             for (int i = 0; i < operators.length; i++) {
@@ -98,7 +95,7 @@ public class OperatorChainTest {
                 if (op instanceof SetupableStreamOperator) {
                     ((SetupableStreamOperator) op).setup(containingTask, cfg, lastWriter);
                 }
-                lastWriter = new ChainingOutput<>(op, statusProvider, null);
+                lastWriter = new ChainingOutput<>(op, null);
 
                 ProcessingTimeService processingTimeService = null;
                 if (op instanceof AbstractStreamOperator) {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index 835151c3cc0..03864d153a6 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -114,7 +114,6 @@ import org.apache.flink.streaming.api.operators.StreamSource;
 import org.apache.flink.streaming.api.operators.StreamTaskStateInitializer;
 import org.apache.flink.streaming.runtime.io.StreamInputProcessor;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxDefaultAction;
 import org.apache.flink.streaming.util.MockStreamConfig;
 import org.apache.flink.streaming.util.MockStreamTaskBuilder;
@@ -1973,7 +1972,6 @@ public class StreamTaskTest extends TestLogger {
         @Override
         public void run(
                 Object lockingObject,
-                StreamStatusMaintainer streamStatusMaintainer,
                 Output<StreamRecord<Long>> collector,
                 OperatorChain<?, ?> operatorChain)
                 throws Exception {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
index 57783fe580b..3663052ea4b 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
@@ -756,11 +756,6 @@ public class AbstractStreamOperatorTestHarness<OUT> implements AutoCloseable {
         return processingTimeService;
     }
 
-    @VisibleForTesting
-    public StreamStatus getStreamStatus() {
-        return mockTask.getStreamStatusMaintainer().getStreamStatus();
-    }
-
     @VisibleForTesting
     public TaskMailbox getTaskMailbox() {
         return taskMailbox;
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java
index b00cd04e52d..1fbeab8ba0f 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java
@@ -26,7 +26,6 @@ import org.apache.flink.streaming.api.graph.StreamConfig;
 import org.apache.flink.streaming.api.operators.StreamOperator;
 import org.apache.flink.streaming.api.operators.StreamTaskStateInitializer;
 import org.apache.flink.streaming.runtime.io.StreamInputProcessor;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeServiceFactory;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
@@ -43,7 +42,6 @@ public class MockStreamTask<OUT, OP extends StreamOperator<OUT>> extends StreamT
     private final StreamConfig config;
     private final ExecutionConfig executionConfig;
     private StreamTaskStateInitializer streamTaskStateInitializer;
-    private final StreamStatusMaintainer streamStatusMaintainer;
     private final CheckpointStorageWorkerView checkpointStorage;
     private final ProcessingTimeService processingTimeService;
     private final BiConsumer<String, Throwable> handleAsyncException;
@@ -54,7 +52,6 @@ public class MockStreamTask<OUT, OP extends StreamOperator<OUT>> extends StreamT
             StreamConfig config,
             ExecutionConfig executionConfig,
             StreamTaskStateInitializer streamTaskStateInitializer,
-            StreamStatusMaintainer streamStatusMaintainer,
             CheckpointStorageWorkerView checkpointStorage,
             TimerService timerService,
             BiConsumer<String, Throwable> handleAsyncException,
@@ -73,7 +70,6 @@ public class MockStreamTask<OUT, OP extends StreamOperator<OUT>> extends StreamT
         this.config = config;
         this.executionConfig = executionConfig;
         this.streamTaskStateInitializer = streamTaskStateInitializer;
-        this.streamStatusMaintainer = streamStatusMaintainer;
         this.checkpointStorage = checkpointStorage;
         this.processingTimeService = timerService;
         this.handleAsyncException = handleAsyncException;
@@ -118,11 +114,6 @@ public class MockStreamTask<OUT, OP extends StreamOperator<OUT>> extends StreamT
         this.streamTaskStateInitializer = streamTaskStateInitializer;
     }
 
-    @Override
-    public StreamStatusMaintainer getStreamStatusMaintainer() {
-        return streamStatusMaintainer;
-    }
-
     @Override
     public CheckpointStorageWorkerView getCheckpointStorage() {
         return checkpointStorage;
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTaskBuilder.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTaskBuilder.java
index afa2244fef1..c9a15fbcafd 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTaskBuilder.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTaskBuilder.java
@@ -25,11 +25,9 @@ import org.apache.flink.runtime.state.CheckpointStorageAccess;
 import org.apache.flink.runtime.state.CheckpointStorageWorkerView;
 import org.apache.flink.runtime.state.memory.MemoryStateBackend;
 import org.apache.flink.streaming.api.graph.StreamConfig;
-import org.apache.flink.streaming.api.operators.MockStreamStatusMaintainer;
 import org.apache.flink.streaming.api.operators.StreamTaskStateInitializer;
 import org.apache.flink.streaming.api.operators.StreamTaskStateInitializerImpl;
 import org.apache.flink.streaming.runtime.io.StreamInputProcessor;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.StreamTaskActionExecutor;
 import org.apache.flink.streaming.runtime.tasks.TestProcessingTimeService;
 import org.apache.flink.streaming.runtime.tasks.TimerService;
@@ -46,7 +44,6 @@ public class MockStreamTaskBuilder {
     private Object checkpointLock = new Object();
     private StreamConfig config;
     private ExecutionConfig executionConfig = new ExecutionConfig();
-    private StreamStatusMaintainer streamStatusMaintainer = new MockStreamStatusMaintainer();
     private CheckpointStorageWorkerView checkpointStorage;
     private TimerService timerService = new TestProcessingTimeService();
     private StreamTaskStateInitializer streamTaskStateInitializer;
@@ -87,12 +84,6 @@ public class MockStreamTaskBuilder {
         return this;
     }
 
-    public MockStreamTaskBuilder setStreamStatusMaintainer(
-            StreamStatusMaintainer streamStatusMaintainer) {
-        this.streamStatusMaintainer = streamStatusMaintainer;
-        return this;
-    }
-
     public MockStreamTaskBuilder setCheckpointStorage(
             CheckpointStorageAccess checkpointStorageAccess) {
         this.checkpointStorage = checkpointStorageAccess;
@@ -133,7 +124,6 @@ public class MockStreamTaskBuilder {
                 config,
                 executionConfig,
                 streamTaskStateInitializer,
-                streamStatusMaintainer,
                 checkpointStorage,
                 timerService,
                 handleAsyncException,
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperator.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperator.java
index f1ee6e2c896..9e47b02133c 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperator.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperator.java
@@ -26,7 +26,6 @@ import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeCallback;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.table.data.RowData;
@@ -57,8 +56,6 @@ public class WatermarkAssignerOperator extends AbstractStreamOperator<RowData>
 
     private transient long lastRecordTime;
 
-    private transient StreamStatusMaintainer streamStatusMaintainer;
-
     /** Flag to prevent duplicate function.close() calls in close() and dispose(). */
     private transient boolean functionsClosed = false;
 
@@ -92,7 +89,6 @@ public class WatermarkAssignerOperator extends AbstractStreamOperator<RowData>
         this.currentWatermark = 0;
         this.watermarkInterval = getExecutionConfig().getAutoWatermarkInterval();
         this.lastRecordTime = getProcessingTimeService().getCurrentProcessingTime();
-        this.streamStatusMaintainer = getContainingTask().getStreamStatusMaintainer();
 
         if (watermarkInterval > 0) {
             long now = getProcessingTimeService().getCurrentProcessingTime();
@@ -107,7 +103,7 @@ public class WatermarkAssignerOperator extends AbstractStreamOperator<RowData>
     public void processElement(StreamRecord<RowData> element) throws Exception {
         if (idleTimeout > 0) {
             // mark the channel active
-            streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
+            output.emitStreamStatus(StreamStatus.ACTIVE);
             lastRecordTime = getProcessingTimeService().getCurrentProcessingTime();
         }
         RowData row = element.getValue();
@@ -147,7 +143,7 @@ public class WatermarkAssignerOperator extends AbstractStreamOperator<RowData>
             final long currentTime = getProcessingTimeService().getCurrentProcessingTime();
             if (currentTime - lastRecordTime > idleTimeout) {
                 // mark the channel as idle to ignore watermarks from this channel
-                streamStatusMaintainer.toggleStreamStatus(StreamStatus.IDLE);
+                output.emitStreamStatus(StreamStatus.IDLE);
             }
         }
 
@@ -167,7 +163,7 @@ public class WatermarkAssignerOperator extends AbstractStreamOperator<RowData>
         if (mark.getTimestamp() == Long.MAX_VALUE && currentWatermark != Long.MAX_VALUE) {
             if (idleTimeout > 0) {
                 // mark the channel active
-                streamStatusMaintainer.toggleStreamStatus(StreamStatus.ACTIVE);
+                output.emitStreamStatus(StreamStatus.ACTIVE);
             }
             currentWatermark = Long.MAX_VALUE;
             output.emitWatermark(mark);
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTest.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTest.java
index 00412991481..97dc443ad62 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTest.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTest.java
@@ -38,8 +38,10 @@ import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
 import static junit.framework.TestCase.assertTrue;
+import static org.hamcrest.Matchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 
 /** Tests of {@link WatermarkAssignerOperator}. */
@@ -56,36 +58,42 @@ public class WatermarkAssignerOperatorTest extends WatermarkAssignerOperatorTest
         testHarness.getExecutionConfig().setAutoWatermarkInterval(50);
         testHarness.open();
 
+        ConcurrentLinkedQueue<Object> output = testHarness.getOutput();
+        List<Object> expectedOutput = new ArrayList<>();
+
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(1L)));
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(2L)));
         testHarness.processWatermark(new Watermark(2)); // this watermark should be ignored
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(3L)));
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(4L)));
 
         // trigger watermark emit
         testHarness.setProcessingTime(51);
-        ConcurrentLinkedQueue<Object> output = testHarness.getOutput();
-        List<Watermark> watermarks = extractWatermarks(output);
-        assertEquals(1, watermarks.size());
-        assertEquals(new Watermark(3), watermarks.get(0));
-        assertEquals(StreamStatus.ACTIVE, testHarness.getStreamStatus());
-        output.clear();
+        expectedOutput.add(new Watermark(3));
+        assertThat(filterOutRecords(output), equalTo(expectedOutput));
 
         testHarness.setProcessingTime(1001);
-        assertEquals(StreamStatus.IDLE, testHarness.getStreamStatus());
+        expectedOutput.add(StreamStatus.IDLE);
+        assertThat(filterOutRecords(output), equalTo(expectedOutput));
 
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(4L)));
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(5L)));
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(6L)));
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(7L)));
+        expectedOutput.add(StreamStatus.ACTIVE);
         testHarness.processElement(new StreamRecord<>(GenericRowData.of(8L)));
 
-        assertEquals(StreamStatus.ACTIVE, testHarness.getStreamStatus());
         testHarness.setProcessingTime(1060);
-        output = testHarness.getOutput();
-        watermarks = extractWatermarks(output);
-        assertEquals(1, watermarks.size());
-        assertEquals(new Watermark(7), watermarks.get(0));
+        expectedOutput.add(new Watermark(7));
+        assertThat(filterOutRecords(output), equalTo(expectedOutput));
     }
 
     @Test
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTestBase.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTestBase.java
index f223a1f543a..a66387d02f6 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTestBase.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/wmassigners/WatermarkAssignerOperatorTestBase.java
@@ -20,12 +20,14 @@ package org.apache.flink.table.runtime.operators.wmassigners;
 
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.streaming.api.watermark.Watermark;
+import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.table.data.RowData;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
@@ -58,4 +60,10 @@ public abstract class WatermarkAssignerOperatorTestBase {
         }
         return watermarks;
     }
+
+    protected List<Object> filterOutRecords(Collection<Object> collection) {
+        return collection.stream()
+                .filter(obj -> !(obj instanceof StreamElement && ((StreamElement) obj).isRecord()))
+                .collect(Collectors.toList());
+    }
 }
