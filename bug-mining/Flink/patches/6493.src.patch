diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepoint.java
index de4584e0042..fbd9ffde3eb 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepoint.java
@@ -49,19 +49,48 @@ import java.util.concurrent.ScheduledFuture;
  * of the operation) is made available via the "operationFuture" to the user. This operation is only
  * considered successfully if the "savepointFuture" completed successfully, and the job reached the
  * terminal state FINISHED.
+ *
+ * <p>This state has to cover several failure scenarios, depending on whether the savepoint
+ * succeeeds/fails and the job succeeds/fails/keeps running.
+ *
+ * <ul>
+ *   <li>Savepoint succeeds, job succeeds - The happy path we like to see.
+ *   <li>Savepoint fails, job fails - The generic failure case. Something happened during
+ *       checkpointing on the TM side that also failed the task; fail the savepoint operation and
+ *       restart the job.
+ *   <li>Savepoint succeeds, job fails - Some issue occurred in notifyCheckpointComplete or during
+ *       the job shutdown. Fail the savepoint operation and job, but inform the user about the
+ *       created savepoint.
+ *   <li>Savepoint fails, job keeps running - The savepoint failed due to an error on the JM side,
+ *       before we ever triggered anything on the TM side. Fail the savepoint operation, but keep
+ *       the job running.
+ * </ul>
+ *
+ * <p>This is further complicated by this information being transmitted via 2 separate RPCs from
+ * TM->JM, with the {@code savepointFuture} not being completed in the main thread, introducing
+ * ordering/lateness issues. Be careful to not liberally use {@link Context#runIfState(State,
+ * Runnable, Duration)} because it can result in a message being lost if multiple operations are
+ * queued and the first initiates a state transition.
  */
 class StopWithSavepoint extends StateWithExecutionGraph {
 
     private final Context context;
+    /**
+     * The result future of this operation, containing the path to the savepoint. This is the future
+     * that other components (e.g., the REST API) wait for.
+     *
+     * <p>Must only be completed successfully if the savepoint was created and the job has FINISHED.
+     */
     private final CompletableFuture<String> operationFuture;
 
     private final CheckpointScheduling checkpointScheduling;
 
-    private boolean hasFullyFinished = false;
-
-    @Nullable private String savepoint = null;
-
     @Nullable private Throwable operationFailureCause;
+    private boolean hasPendingStateTransition = false;
+
+    // be careful when applying operations on this future that can trigger state transitions,
+    // as several other methods do the same and we mustn't trigger multiple transitions!
+    private final CompletableFuture<String> internalSavepointFuture = new CompletableFuture<>();
 
     StopWithSavepoint(
             Context context,
@@ -86,38 +115,29 @@ class StopWithSavepoint extends StateWithExecutionGraph {
         this.operationFuture = new CompletableFuture<>();
 
         FutureUtils.assertNoException(
-                savepointFuture.handle(
-                        (savepointLocation, throwable) -> {
-                            // make sure we handle the future completion in the main thread and
-                            // outside the constructor (where state transitions are not allowed)
-                            context.runIfState(
-                                    this,
-                                    () -> handleSavepointCompletion(savepointLocation, throwable),
-                                    Duration.ZERO);
+                internalSavepointFuture.exceptionally(
+                        cause -> {
+                            onSavepointFailure(cause);
                             return null;
                         }));
-    }
 
-    private void handleSavepointCompletion(
-            @Nullable String savepoint, @Nullable Throwable throwable) {
-        if (hasFullyFinished) {
-            Preconditions.checkState(
-                    throwable == null,
-                    "A savepoint should never fail after a job has been terminated via stop-with-savepoint.");
-            completeOperationAndGoToFinished(savepoint);
-        } else {
-            if (throwable != null) {
-                operationFailureCause = throwable;
-                checkpointScheduling.startCheckpointScheduler();
-                context.goToExecuting(
-                        getExecutionGraph(),
-                        getExecutionGraphHandler(),
-                        getOperatorCoordinatorHandler(),
-                        getFailures());
-            } else {
-                this.savepoint = savepoint;
-            }
-        }
+        // this is a roundabout way of splicing the completion of the future into the main thread.
+        // allows other methods to apply synchronous operations on the future without having to
+        // worry about the main thread.
+        savepointFuture.handle(
+                (savepoint, error) -> {
+                    context.runIfState(
+                            this,
+                            () -> {
+                                if (error != null) {
+                                    internalSavepointFuture.completeExceptionally(error);
+                                } else {
+                                    internalSavepointFuture.complete(savepoint);
+                                }
+                            },
+                            Duration.ZERO);
+                    return null;
+                });
     }
 
     @Override
@@ -130,8 +150,19 @@ class StopWithSavepoint extends StateWithExecutionGraph {
         super.onLeave(newState);
     }
 
+    /**
+     * Cancel the job and fail the savepoint operation future.
+     *
+     * <p>We don't wait for the {@link #internalSavepointFuture} here so that users can still cancel
+     * a job if the savepoint takes too long (or gets stuck).
+     *
+     * <p>Since we don't actually cancel the savepoint (for which there is no API to do so), there
+     * is a small risk that the job is cancelled at the very moment that the savepoint completes,
+     * causing it to not be reported to the user. See FLINK-28127.
+     */
     @Override
     public void cancel() {
+        operationFailureCause = new FlinkException("The job was cancelled.");
         context.goToCanceling(
                 getExecutionGraph(),
                 getExecutionGraphHandler(),
@@ -144,29 +175,81 @@ class StopWithSavepoint extends StateWithExecutionGraph {
         return JobStatus.RUNNING;
     }
 
+    /**
+     * Restarts the checkpoint scheduler and, if only the savepoint failed without a task failure /
+     * job termination, transitions back to {@link Executing}.
+     *
+     * <p>This method must assume that {@link #onFailure}/{@link #onGloballyTerminalState} MAY
+     * already be waiting for the savepoint operation to complete, itching to trigger a state
+     * transition (hence the {@link #hasPendingStateTransition} check).
+     *
+     * <p>If the above is violated (e.g., by always transitioning into another state), then
+     * depending on other implementation details something very bad will happen, like the scheduler
+     * crashing the JVM because it attempted multiple state transitions OR effectively dropping the
+     * onFailure/onGloballyTerminalState call OR we trigger state transitions while we are already
+     * in another state.
+     *
+     * <p>For maintainability reasons this method should not mutate any state that affects state
+     * transitions in other methods.
+     */
+    private void onSavepointFailure(Throwable cause) {
+        // revert side-effect of Executing#stopWithSavepoint
+        checkpointScheduling.startCheckpointScheduler();
+        // a task failed concurrently; defer the error handling to onFailure()
+        // otherwise we will attempt 2 state transitions, which is forbidden
+        if (!hasPendingStateTransition) {
+            operationFailureCause = cause;
+            context.goToExecuting(
+                    getExecutionGraph(),
+                    getExecutionGraphHandler(),
+                    getOperatorCoordinatorHandler(),
+                    getFailures());
+        }
+    }
+
     @Override
     void onFailure(Throwable cause) {
-        operationFailureCause = cause;
-        if (savepoint == null) {
-            FailureResultUtil.restartOrFail(context.howToHandleFailure(cause), context, this);
-        } else {
-            // savepoint has been create successfully, but the job failed while committing side
-            // effects
-            final StopWithSavepointStoppingException ex =
-                    new StopWithSavepointStoppingException(savepoint, this.getJobId(), cause);
-            this.operationFuture.completeExceptionally(ex);
-            FailureResultUtil.restartOrFail(context.howToHandleFailure(ex), context, this);
+        if (hasPendingStateTransition) {
+            // the error handling remains the same independent of how many tasks have failed
+            // we don't want to initiate the same state transition multiple times, so we exit early
+            // this could also be achieved via Context#runIfState, but that'd spam the logs
+            return;
         }
+        hasPendingStateTransition = true;
+
+        FutureUtils.assertNoException(
+                internalSavepointFuture.handle(
+                        (savepoint, savepointError) -> {
+                            // if savepointError is null then the savepoint has been created
+                            // successfully, but the job failed while committing side effects,
+                            // so we enrich the exception for the user
+                            final Throwable ex =
+                                    savepointError != null
+                                            ? cause
+                                            : new StopWithSavepointStoppingException(
+                                                    savepoint, getJobId(), cause);
+                            operationFailureCause = ex;
+                            FailureResultUtil.restartOrFail(
+                                    context.howToHandleFailure(ex), context, this);
+                            return null;
+                        }));
     }
 
     @Override
     void onGloballyTerminalState(JobStatus globallyTerminalState) {
         if (globallyTerminalState == JobStatus.FINISHED) {
-            if (savepoint == null) {
-                hasFullyFinished = true;
-            } else {
-                completeOperationAndGoToFinished(savepoint);
-            }
+            // do not set this in other cases
+            // handleGlobalFailure circles back to onFailure()
+            hasPendingStateTransition = true;
+            FutureUtils.assertNoException(
+                    internalSavepointFuture.handle(
+                            (savepoint, error) -> {
+                                Preconditions.checkState(
+                                        error == null,
+                                        "A savepoint should never fail after a job has been terminated via stop-with-savepoint.");
+                                completeOperationAndGoToFinished(savepoint);
+                                return null;
+                            }));
         } else {
             handleGlobalFailure(
                     new FlinkException(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java
index 28200416199..fee595c49d4 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerTest.java
@@ -27,6 +27,7 @@ import org.apache.flink.configuration.SchedulerExecutionMode;
 import org.apache.flink.core.execution.SavepointFormatType;
 import org.apache.flink.metrics.Gauge;
 import org.apache.flink.runtime.checkpoint.CheckpointException;
+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;
 import org.apache.flink.runtime.checkpoint.CheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
@@ -65,6 +66,7 @@ import org.apache.flink.runtime.jobgraph.tasks.JobCheckpointingSettings;
 import org.apache.flink.runtime.jobmanager.PartitionProducerDisposedException;
 import org.apache.flink.runtime.jobmaster.slotpool.DefaultAllocatedSlotPool;
 import org.apache.flink.runtime.jobmaster.slotpool.DefaultDeclarativeSlotPool;
+import org.apache.flink.runtime.messages.checkpoint.DeclineCheckpoint;
 import org.apache.flink.runtime.metrics.MetricNames;
 import org.apache.flink.runtime.metrics.MetricRegistry;
 import org.apache.flink.runtime.metrics.groups.JobManagerMetricGroup;
@@ -1166,7 +1168,11 @@ public class AdaptiveSchedulerTest extends TestLogger {
                 jobGraph ->
                         jobGraph.setSnapshotSettings(
                                 new JobCheckpointingSettings(
-                                        CheckpointCoordinatorConfiguration.builder().build(),
+                                        // set a large checkpoint interval so we can easily deduce
+                                        // the savepoints checkpoint id
+                                        CheckpointCoordinatorConfiguration.builder()
+                                                .setCheckpointInterval(Long.MAX_VALUE)
+                                                .build(),
                                         null));
         final CompletedCheckpointStore completedCheckpointStore =
                 new StandaloneCompletedCheckpointStore(1);
@@ -1190,6 +1196,17 @@ public class AdaptiveSchedulerTest extends TestLogger {
                             new TaskExecutionStateTransition(
                                     new TaskExecutionState(
                                             attemptId, ExecutionState.FAILED, expectedException)));
+
+                    // fail the savepoint so that the job terminates
+                    for (ExecutionAttemptID id : attemptIds) {
+                        scheduler.declineCheckpoint(
+                                new DeclineCheckpoint(
+                                        scheduler.requestJob().getJobId(),
+                                        id,
+                                        checkpointIDCounter.get() - 1,
+                                        new CheckpointException(
+                                                CheckpointFailureReason.IO_EXCEPTION)));
+                    }
                 };
 
         final Iterable<RootExceptionHistoryEntry> actualExceptionHistory =
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepointTest.java
index 4b2df124670..8738e7dfb47 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/StopWithSavepointTest.java
@@ -29,6 +29,7 @@ import org.apache.flink.runtime.scheduler.ExecutionGraphHandler;
 import org.apache.flink.runtime.scheduler.OperatorCoordinatorHandler;
 import org.apache.flink.runtime.scheduler.exceptionhistory.ExceptionHistoryEntry;
 import org.apache.flink.runtime.scheduler.exceptionhistory.TestingAccessExecution;
+import org.apache.flink.runtime.scheduler.stopwithsavepoint.StopWithSavepointStoppingException;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLoggerExtension;
 
@@ -67,9 +68,12 @@ class StopWithSavepointTest {
             StopWithSavepoint sws =
                     createStopWithSavepoint(ctx, mockExecutionGraph, savepointFuture);
             ctx.setStopWithSavepoint(sws);
-            ctx.setExpectFinished(assertNonNull());
 
-            mockExecutionGraph.completeTerminationFuture(JobStatus.FINISHED);
+            sws.onGloballyTerminalState(JobStatus.FINISHED);
+            // this is a sanity check that we haven't scheduled a state transition
+            ctx.triggerExecutors();
+
+            ctx.setExpectFinished(assertNonNull());
             savepointFuture.complete(SAVEPOINT_PATH);
             ctx.triggerExecutors();
 
@@ -78,24 +82,32 @@ class StopWithSavepointTest {
     }
 
     @Test
-    void testJobFailed() throws Exception {
+    void testJobFailedAndSavepointOperationSucceeds() throws Exception {
         try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
             StateTrackingMockExecutionGraph mockExecutionGraph =
                     new StateTrackingMockExecutionGraph();
-            StopWithSavepoint sws = createStopWithSavepoint(ctx, mockExecutionGraph);
+            final CompletableFuture<String> savepointFuture = new CompletableFuture<>();
+            StopWithSavepoint sws =
+                    createStopWithSavepoint(ctx, mockExecutionGraph, savepointFuture);
             ctx.setStopWithSavepoint(sws);
             ctx.setHowToHandleFailure(FailureResult::canNotRestart);
 
+            // fail job:
+            mockExecutionGraph.completeTerminationFuture(JobStatus.FAILED);
+            // this is a sanity check that we haven't scheduled a state transition
+            ctx.triggerExecutors();
+
             ctx.setExpectFailing(
                     failingArguments -> {
                         assertThat(failingArguments.getExecutionGraph().getState())
                                 .isEqualTo(JobStatus.FAILED);
                         assertThat(failingArguments.getFailureCause())
-                                .satisfies(FlinkAssertions.anyCauseMatches(FlinkException.class));
+                                .satisfies(
+                                        FlinkAssertions.anyCauseMatches(
+                                                StopWithSavepointStoppingException.class));
                     });
 
-            // fail job:
-            mockExecutionGraph.completeTerminationFuture(JobStatus.FAILED);
+            savepointFuture.complete(SAVEPOINT_PATH);
             ctx.triggerExecutors();
 
             assertThat(sws.getOperationFuture()).isCompletedExceptionally();
@@ -179,7 +191,8 @@ class StopWithSavepointTest {
     @Test
     void testRestartOnGlobalFailureIfRestartConfigured() throws Exception {
         try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
-            StopWithSavepoint sws = createStopWithSavepoint(ctx);
+            final CompletableFuture<String> savepointFuture = CompletableFuture.completedFuture("");
+            StopWithSavepoint sws = createStopWithSavepoint(ctx, savepointFuture);
             ctx.setStopWithSavepoint(sws);
             ctx.setHowToHandleFailure(failure -> FailureResult.canRestart(failure, Duration.ZERO));
 
@@ -193,7 +206,8 @@ class StopWithSavepointTest {
     void testFailingOnGlobalFailureIfNoRestartConfigured() throws Exception {
         try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
 
-            StopWithSavepoint sws = createStopWithSavepoint(ctx);
+            final CompletableFuture<String> savepointFuture = CompletableFuture.completedFuture("");
+            StopWithSavepoint sws = createStopWithSavepoint(ctx, savepointFuture);
             ctx.setStopWithSavepoint(sws);
             ctx.setHowToHandleFailure(FailureResult::canNotRestart);
 
@@ -211,7 +225,8 @@ class StopWithSavepointTest {
     void testFailingOnUpdateTaskExecutionStateWithNoRestart() throws Exception {
         try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
             StateTrackingMockExecutionGraph executionGraph = new StateTrackingMockExecutionGraph();
-            StopWithSavepoint sws = createStopWithSavepoint(ctx, executionGraph);
+            final CompletableFuture<String> savepointFuture = CompletableFuture.completedFuture("");
+            StopWithSavepoint sws = createStopWithSavepoint(ctx, executionGraph, savepointFuture);
             ctx.setStopWithSavepoint(sws);
             ctx.setHowToHandleFailure(FailureResult::canNotRestart);
 
@@ -238,7 +253,8 @@ class StopWithSavepointTest {
     void testRestartingOnUpdateTaskExecutionStateWithRestart() throws Exception {
         try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
             StateTrackingMockExecutionGraph executionGraph = new StateTrackingMockExecutionGraph();
-            StopWithSavepoint sws = createStopWithSavepoint(ctx, executionGraph);
+            final CompletableFuture<String> savepointFuture = CompletableFuture.completedFuture("");
+            StopWithSavepoint sws = createStopWithSavepoint(ctx, executionGraph, savepointFuture);
             ctx.setStopWithSavepoint(sws);
             ctx.setHowToHandleFailure(failure -> FailureResult.canRestart(failure, Duration.ZERO));
 
@@ -337,6 +353,52 @@ class StopWithSavepointTest {
         }
     }
 
+    @Test
+    void testOnFailureWaitsForSavepointCompletion() throws Exception {
+        try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
+            CheckpointScheduling mockStopWithSavepointOperations = new MockCheckpointScheduling();
+            CompletableFuture<String> savepointFuture = new CompletableFuture<>();
+            StateTrackingMockExecutionGraph executionGraph = new StateTrackingMockExecutionGraph();
+            StopWithSavepoint sws =
+                    createStopWithSavepoint(
+                            ctx, mockStopWithSavepointOperations, executionGraph, savepointFuture);
+            ctx.setStopWithSavepoint(sws);
+
+            ctx.setHowToHandleFailure(failure -> FailureResult.canRestart(failure, Duration.ZERO));
+
+            sws.onFailure(new Exception("task failure"));
+            // this is a sanity check that we haven't scheduled a state transition
+            ctx.triggerExecutors();
+
+            ctx.setExpectRestarting(assertNonNull());
+            savepointFuture.complete(SAVEPOINT_PATH);
+            ctx.triggerExecutors();
+        }
+    }
+
+    @Test
+    void testConcurrentSavepointFailureAndGloballyTerminalStateCauseRestart() throws Exception {
+        try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
+            CheckpointScheduling mockStopWithSavepointOperations = new MockCheckpointScheduling();
+            CompletableFuture<String> savepointFuture = new CompletableFuture<>();
+            StateTrackingMockExecutionGraph executionGraph = new StateTrackingMockExecutionGraph();
+            StopWithSavepoint sws =
+                    createStopWithSavepoint(
+                            ctx, mockStopWithSavepointOperations, executionGraph, savepointFuture);
+            ctx.setStopWithSavepoint(sws);
+
+            ctx.setHowToHandleFailure(failure -> FailureResult.canRestart(failure, Duration.ZERO));
+
+            sws.onFailure(new Exception("task failure"));
+            // this is a sanity check that we haven't scheduled a state transition
+            ctx.triggerExecutors();
+
+            ctx.setExpectRestarting(assertNonNull());
+            savepointFuture.completeExceptionally(new Exception("savepoint failure"));
+            ctx.triggerExecutors();
+        }
+    }
+
     @Test
     void testEnsureCheckpointSchedulerIsStartedAgain() throws Exception {
         try (MockStopWithSavepointContext ctx = new MockStopWithSavepointContext()) {
@@ -366,6 +428,15 @@ class StopWithSavepointTest {
                 new CompletableFuture<>());
     }
 
+    private static StopWithSavepoint createStopWithSavepoint(
+            MockStopWithSavepointContext ctx, CompletableFuture<String> savepointFuture) {
+        return createStopWithSavepoint(
+                ctx,
+                new MockCheckpointScheduling(),
+                new StateTrackingMockExecutionGraph(),
+                savepointFuture);
+    }
+
     private static StopWithSavepoint createStopWithSavepoint(
             MockStopWithSavepointContext ctx,
             ExecutionGraph executionGraph,
