diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
index e14cfda3b46..78e181a978b 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
@@ -196,11 +196,14 @@ public class ContinuousFileReaderOperator<OUT> extends AbstractStreamOperator<OU
 	public void close() throws Exception {
 		super.close();
 
+		// make sure that we hold the checkpointing lock
+		Thread.holdsLock(checkpointLock);
+
 		// close the reader to signal that no more splits will come. By doing this,
 		// the reader will exit as soon as it finishes processing the already pending splits.
 		// This method will wait until then. Further cleaning up is handled by the dispose().
 
-		if (reader != null && reader.isAlive() && reader.isRunning()) {
+		while (reader != null && reader.isAlive() && reader.isRunning()) {
 			reader.close();
 			checkpointLock.wait();
 		}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index 310df4de6c1..6089240c8db 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -277,10 +277,12 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
 			// we also need to make sure that no triggers fire concurrently with the close logic
 			// at the same time, this makes sure that during any "regular" exit where still
 			synchronized (lock) {
-				isRunning = false;
-
 				// this is part of the main logic, so if this fails, the task is considered failed
 				closeAllOperators();
+
+				// only set the StreamTask to not running after all operators have been closed!
+				// See FLINK-7430
+				isRunning = false;
 			}
 
 			LOG.debug("Closed operators for task {}", getName());
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index a2dc6c4f2fa..9bb91ad7ba8 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -56,6 +56,8 @@ import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
 import org.apache.flink.runtime.jobgraph.tasks.InputSplitProvider;
 import org.apache.flink.runtime.memory.MemoryManager;
+import org.apache.flink.runtime.operators.testutils.MockEnvironment;
+import org.apache.flink.runtime.operators.testutils.MockInputSplitProvider;
 import org.apache.flink.runtime.operators.testutils.UnregisteredTaskMetricsGroup;
 import org.apache.flink.runtime.query.TaskKvStateRegistry;
 import org.apache.flink.runtime.state.AbstractKeyedStateBackend;
@@ -73,6 +75,7 @@ import org.apache.flink.runtime.taskmanager.Task;
 import org.apache.flink.runtime.taskmanager.TaskExecutionState;
 import org.apache.flink.runtime.taskmanager.TaskExecutionStateListener;
 import org.apache.flink.runtime.taskmanager.TaskManagerActions;
+import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.util.DirectExecutorService;
 import org.apache.flink.runtime.util.TestingTaskManagerRuntimeInfo;
 import org.apache.flink.streaming.api.TimeCharacteristic;
@@ -111,12 +114,14 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 import java.util.PriorityQueue;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.RunnableFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import scala.concurrent.Await;
 import scala.concurrent.Future;
@@ -717,10 +722,96 @@ public class StreamTaskTest extends TestLogger {
 		Assert.assertNull(checkpointResult.get(0));
 	}
 
+	/**
+	 * Tests that the StreamTask first closes alls its operators before setting its
+	 * state to not running (isRunning == false)
+	 *
+	 * <p>See FLINK-7430.
+	 */
+	@Test
+	public void testOperatorClosingBeforeStopRunning() throws Throwable {
+		Configuration taskConfiguration = new Configuration();
+		StreamConfig streamConfig = new StreamConfig(taskConfiguration);
+		streamConfig.setStreamOperator(new BlockingCloseStreamOperator());
+		streamConfig.setOperatorID(new OperatorID());
+
+		MockEnvironment mockEnvironment = new MockEnvironment(
+			"Test Task",
+			32L * 1024L,
+			new MockInputSplitProvider(),
+			1,
+			taskConfiguration,
+			new ExecutionConfig());
+		StreamTask<Void, BlockingCloseStreamOperator> streamTask = new NoOpStreamTask<>(mockEnvironment);
+		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null);
+
+		CompletableFuture<Void> invokeFuture = CompletableFuture.runAsync(
+			() -> {
+				try {
+					streamTask.invoke();
+				} catch (Exception e) {
+					atomicThrowable.set(e);
+				}
+			},
+			TestingUtils.defaultExecutor());
+
+		BlockingCloseStreamOperator.IN_CLOSE.await();
+
+		// check that the StreamTask is not yet in isRunning == false
+		assertTrue(streamTask.isRunning());
+
+		// let the operator finish its close operation
+		BlockingCloseStreamOperator.FINISH_CLOSE.trigger();
+
+		// wait until the invoke is complete
+		invokeFuture.get();
+
+		// now the StreamTask should no longer be running
+		assertFalse(streamTask.isRunning());
+
+		// check if an exception occurred
+		if (atomicThrowable.get() != null) {
+			throw atomicThrowable.get();
+		}
+	}
+
 	// ------------------------------------------------------------------------
 	//  Test Utilities
 	// ------------------------------------------------------------------------
 
+	private static class NoOpStreamTask<T, OP extends StreamOperator<T>> extends StreamTask<T, OP> {
+
+		public NoOpStreamTask(Environment environment) {
+			setEnvironment(environment);
+		}
+
+		@Override
+		protected void init() throws Exception {}
+
+		@Override
+		protected void run() throws Exception {}
+
+		@Override
+		protected void cleanup() throws Exception {}
+
+		@Override
+		protected void cancelTask() throws Exception {}
+	}
+
+	private static class BlockingCloseStreamOperator extends AbstractStreamOperator<Void> {
+		private static final long serialVersionUID = -9042150529568008847L;
+
+		public static final OneShotLatch IN_CLOSE = new OneShotLatch();
+		public static final OneShotLatch FINISH_CLOSE = new OneShotLatch();
+
+		@Override
+		public void close() throws Exception {
+			IN_CLOSE.trigger();
+			FINISH_CLOSE.await();
+			super.close();
+		}
+	}
+
 	private static class TestingExecutionStateListener implements TaskExecutionStateListener {
 
 		private ExecutionState executionState = null;
