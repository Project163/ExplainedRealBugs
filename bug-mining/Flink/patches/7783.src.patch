diff --git a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java
index 048bca04c7e..d816ab13cc2 100644
--- a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java
+++ b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystem.java
@@ -25,6 +25,7 @@ import org.apache.flink.core.fs.FSDataOutputStream;
 import org.apache.flink.core.fs.FileStatus;
 import org.apache.flink.core.fs.FileSystem;
 import org.apache.flink.core.fs.Path;
+import org.apache.flink.core.fs.local.LocalBlockLocation;
 import org.apache.flink.metrics.MetricGroup;
 import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.state.forst.fs.cache.BundledCacheLimitPolicy;
@@ -34,6 +35,7 @@ import org.apache.flink.state.forst.fs.cache.CachedDataOutputStream;
 import org.apache.flink.state.forst.fs.cache.FileBasedCache;
 import org.apache.flink.state.forst.fs.cache.SizeBasedCacheLimitPolicy;
 import org.apache.flink.state.forst.fs.cache.SpaceBasedCacheLimitPolicy;
+import org.apache.flink.state.forst.fs.filemapping.FSDataOutputStreamWithEntry;
 import org.apache.flink.state.forst.fs.filemapping.FileBackedMappingEntrySource;
 import org.apache.flink.state.forst.fs.filemapping.FileMappingManager;
 import org.apache.flink.state.forst.fs.filemapping.FileOwnershipDecider;
@@ -49,7 +51,6 @@ import javax.annotation.Nullable;
 
 import java.io.Closeable;
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.URI;
 import java.util.ArrayList;
@@ -195,6 +196,9 @@ public class ForStFlinkFileSystem extends FileSystem implements Closeable {
         // Create the actual file output stream
         FileSystem fileSystem = sourceRealPath.getFileSystem();
         FSDataOutputStream outputStream = fileSystem.create(sourceRealPath, overwriteMode);
+        // Bundle the output stream with the mapping entry, to close the entry when the stream is
+        // closed.
+        outputStream = new FSDataOutputStreamWithEntry(outputStream, createdMappingEntry);
 
         // Try to create file cache for SST files
         CachedDataOutputStream cachedDataOutputStream =
@@ -273,40 +277,57 @@ public class ForStFlinkFileSystem extends FileSystem implements Closeable {
         }
 
         if (FileOwnershipDecider.shouldAlwaysBeLocal(f)) {
-            return localFS.exists(mappingEntry.getSourcePath())
-                    || delegateFS.exists(mappingEntry.getSourcePath());
+            return localFS.exists(mappingEntry.getSourcePath());
         } else {
+            // Should be protected with synchronized, since the file closing is not an atomic
+            // operation, see FSDataOutputStreamWithEntry.close()
+            synchronized (mappingEntry) {
+                if (mappingEntry.isWriting()) {
+                    return true;
+                }
+            }
             return delegateFS.exists(mappingEntry.getSourcePath());
         }
     }
 
     @Override
     public synchronized FileStatus getFileStatus(Path path) throws IOException {
-        Path sourcePath = getSourcePath(path);
-        FileSystem fileSystem = sourcePath.getFileSystem();
-        return new FileStatusWrapper(fileSystem.getFileStatus(sourcePath), path);
+        MappingEntry mappingEntry = fileMappingManager.mappingEntry(path.toString());
+        if (mappingEntry == null) {
+            return new FileStatusWrapper(delegateFS.getFileStatus(path), path);
+        }
+        if (FileOwnershipDecider.shouldAlwaysBeLocal(path)) {
+            return new FileStatusWrapper(localFS.getFileStatus(mappingEntry.getSourcePath()), path);
+        } else {
+            // Should be protected with synchronized, since the file closing is not an atomic
+            // operation, see FSDataOutputStreamWithEntry.close()
+            synchronized (mappingEntry) {
+                if (mappingEntry.isWriting()) {
+                    return new DummyFSFileStatus(path);
+                }
+            }
+            return new FileStatusWrapper(
+                    delegateFS.getFileStatus(mappingEntry.getSourcePath()), path);
+        }
     }
 
     @Override
     public synchronized BlockLocation[] getFileBlockLocations(FileStatus file, long start, long len)
             throws IOException {
-        Path sourcePath = getSourcePath(file.getPath());
-
-        FileSystem fileSystem = sourcePath.getFileSystem();
-        FileStatus fileStatus = fileSystem.getFileStatus(sourcePath);
-        return fileSystem.getFileBlockLocations(fileStatus, start, len);
-    }
-
-    private @Nonnull Path getSourcePath(Path path) throws FileNotFoundException {
-        MappingEntry mappingEntry = fileMappingManager.mappingEntry(path.toString());
-        Preconditions.checkNotNull(mappingEntry);
-        MappingEntrySource source = mappingEntry.getSource();
-        Path sourcePath = source.getFilePath();
-        if (sourcePath == null) {
-            throw new FileNotFoundException(
-                    String.format("Cannot get file path for source: %s", source));
+        Path path = file.getPath();
+        if (file instanceof FileStatusWrapper) {
+            if (FileOwnershipDecider.shouldAlwaysBeLocal(path)) {
+                return localFS.getFileBlockLocations(
+                        ((FileStatusWrapper) file).delegate, start, len);
+            } else {
+                return delegateFS.getFileBlockLocations(
+                        ((FileStatusWrapper) file).delegate, start, len);
+            }
+        } else if (file instanceof DummyFSFileStatus) {
+            return new BlockLocation[] {new LocalBlockLocation(0L)};
+        } else {
+            throw new IOException("file is not an instance from ForStFlinkFileSystem.");
         }
-        return sourcePath;
     }
 
     @Override
@@ -449,4 +470,48 @@ public class ForStFlinkFileSystem extends FileSystem implements Closeable {
             return path;
         }
     }
+
+    /** A dummy file status that only confirms the existence. */
+    static class DummyFSFileStatus implements FileStatus {
+        private final Path path;
+
+        DummyFSFileStatus(Path path) {
+            this.path = path;
+        }
+
+        @Override
+        public long getLen() {
+            return 0L;
+        }
+
+        @Override
+        public long getBlockSize() {
+            return 0L;
+        }
+
+        @Override
+        public short getReplication() {
+            return 0;
+        }
+
+        @Override
+        public long getModificationTime() {
+            return 0;
+        }
+
+        @Override
+        public long getAccessTime() {
+            return 0;
+        }
+
+        @Override
+        public boolean isDir() {
+            return false;
+        }
+
+        @Override
+        public Path getPath() {
+            return path;
+        }
+    }
 }
diff --git a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FSDataOutputStreamWithEntry.java b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FSDataOutputStreamWithEntry.java
new file mode 100644
index 00000000000..1e371c17815
--- /dev/null
+++ b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FSDataOutputStreamWithEntry.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.state.forst.fs.filemapping;
+
+import org.apache.flink.core.fs.FSDataOutputStream;
+import org.apache.flink.core.fs.FSDataOutputStreamWrapper;
+
+import java.io.IOException;
+
+/** A {@link FSDataOutputStream} that is associated with a {@link MappingEntry}. */
+public class FSDataOutputStreamWithEntry extends FSDataOutputStreamWrapper {
+
+    private final MappingEntry entry;
+
+    public FSDataOutputStreamWithEntry(FSDataOutputStream outputStream, MappingEntry entry) {
+        super(outputStream);
+        this.entry = entry;
+    }
+
+    @Override
+    public void close() throws IOException {
+        // Synchronize on the entry to ensure the atomicity of endWriting and close
+        // also see invokers of MappingEntry.isWriting
+        synchronized (entry) {
+            super.close();
+            entry.endWriting();
+        }
+    }
+}
diff --git a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FileMappingManager.java b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FileMappingManager.java
index 1e8cea5e58f..5b56c09cb77 100644
--- a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FileMappingManager.java
+++ b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/FileMappingManager.java
@@ -68,7 +68,7 @@ public class FileMappingManager {
         }
 
         return addFileToMappingTable(
-                key, toUUIDPath(filePath), FileOwnershipDecider.decideForNewFile(filePath));
+                key, toUUIDPath(filePath), FileOwnershipDecider.decideForNewFile(filePath), true);
     }
 
     /** Register a file restored from checkpoints to the mapping table. */
@@ -87,16 +87,16 @@ public class FileMappingManager {
         MappingEntrySource source = new HandleBackedMappingEntrySource(stateHandle);
         MappingEntry existingEntry = getExistingMappingEntry(key, source, fileOwnership);
         return existingEntry == null
-                ? addMappingEntry(key, new MappingEntry(1, source, fileOwnership, false))
+                ? addMappingEntry(key, new MappingEntry(1, source, fileOwnership, false, false))
                 : existingEntry;
     }
 
     private MappingEntry addFileToMappingTable(
-            String key, Path filePath, FileOwnership fileOwnership) {
+            String key, Path filePath, FileOwnership fileOwnership, boolean writing) {
         MappingEntrySource source = new FileBackedMappingEntrySource(filePath);
         MappingEntry existingEntry = getExistingMappingEntry(key, source, fileOwnership);
         return existingEntry == null
-                ? addMappingEntry(key, new MappingEntry(1, source, fileOwnership, false))
+                ? addMappingEntry(key, new MappingEntry(1, source, fileOwnership, false, writing))
                 : existingEntry;
     }
 
diff --git a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/MappingEntry.java b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/MappingEntry.java
index f0d502db19b..692a7f7f1a2 100644
--- a/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/MappingEntry.java
+++ b/flink-state-backends/flink-statebackend-forst/src/main/java/org/apache/flink/state/forst/fs/filemapping/MappingEntry.java
@@ -42,6 +42,8 @@ public class MappingEntry extends ReferenceCounted {
 
     final boolean isDirectory;
 
+    volatile boolean writing;
+
     /** When delete a directory, if the directory is the parent of this source file, track it. */
     @Nullable MappingEntry parentDir;
 
@@ -54,7 +56,8 @@ public class MappingEntry extends ReferenceCounted {
                 initReference,
                 new HandleBackedMappingEntrySource(stateHandle),
                 fileOwnership,
-                isDirectory);
+                isDirectory,
+                false);
     }
 
     public MappingEntry(
@@ -63,19 +66,22 @@ public class MappingEntry extends ReferenceCounted {
                 initReference,
                 new FileBackedMappingEntrySource(sourcePath),
                 fileOwnership,
-                isDirectory);
+                isDirectory,
+                false);
     }
 
     public MappingEntry(
             int initReference,
             MappingEntrySource source,
             FileOwnership fileOwnership,
-            boolean isDirectory) {
+            boolean isDirectory,
+            boolean writing) {
         super(initReference);
         this.source = source;
         this.parentDir = null;
         this.fileOwnership = fileOwnership;
         this.isDirectory = isDirectory;
+        this.writing = writing;
     }
 
     public void setFileOwnership(FileOwnership ownership) {
@@ -108,6 +114,14 @@ public class MappingEntry extends ReferenceCounted {
         return fileOwnership;
     }
 
+    public boolean isWriting() {
+        return writing;
+    }
+
+    public void endWriting() {
+        writing = false;
+    }
+
     @Override
     protected void referenceCountReachedZero(@Nullable Object o) {
         try {
diff --git a/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystemTest.java b/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystemTest.java
index cd41dc4cda0..d52f8edae65 100644
--- a/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystemTest.java
+++ b/flink-state-backends/flink-statebackend-forst/src/test/java/org/apache/flink/state/forst/fs/ForStFlinkFileSystemTest.java
@@ -19,8 +19,10 @@
 package org.apache.flink.state.forst.fs;
 
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.core.fs.BlockLocation;
 import org.apache.flink.core.fs.ByteBufferReadable;
 import org.apache.flink.core.fs.FSDataInputStream;
+import org.apache.flink.core.fs.FileStatus;
 import org.apache.flink.core.fs.FileSystem;
 import org.apache.flink.core.fs.local.LocalDataInputStream;
 import org.apache.flink.core.fs.local.LocalFileSystem;
@@ -49,6 +51,7 @@ import java.nio.ByteBuffer;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -342,6 +345,55 @@ public class ForStFlinkFileSystemTest {
         is.close();
     }
 
+    @Test
+    public void testFileStatusAndExist() throws IOException {
+        org.apache.flink.core.fs.Path remotePath =
+                new org.apache.flink.core.fs.Path(tempDir.toString() + "/remote");
+        org.apache.flink.core.fs.Path localPath =
+                new org.apache.flink.core.fs.Path(tempDir.toString() + "/local");
+        ForStFlinkFileSystem fileSystem =
+                new ForStFlinkFileSystem(
+                        new ByteBufferReadableLocalFileSystem(),
+                        remotePath.toString(),
+                        localPath.toString(),
+                        null);
+        fileSystem.mkdirs(remotePath);
+        fileSystem.mkdirs(localPath);
+        org.apache.flink.core.fs.Path sstRemotePath1 =
+                new org.apache.flink.core.fs.Path(remotePath, "1.sst");
+        ByteBufferWritableFSDataOutputStream os1 = fileSystem.create(sstRemotePath1);
+        assertThat(fileSystem.getFileStatus(sstRemotePath1)).isNotNull();
+        assertThat(fileSystem.getFileStatus(sstRemotePath1))
+                .isInstanceOf(ForStFlinkFileSystem.DummyFSFileStatus.class);
+        assertThat(fileSystem.getFileStatus(sstRemotePath1).getPath()).isEqualTo(sstRemotePath1);
+        assertThat(fileSystem.exists(sstRemotePath1)).isTrue();
+        assertThat(fileSystem.listStatus(remotePath)).hasSize(1);
+        assertFileStatusAndBlockLocations(fileSystem, fileSystem.getFileStatus(sstRemotePath1));
+        os1.write(1);
+        os1.close();
+        assertThat(fileSystem.getFileStatus(sstRemotePath1)).isNotNull();
+        assertThat(fileSystem.getFileStatus(sstRemotePath1))
+                .isNotInstanceOf(ForStFlinkFileSystem.DummyFSFileStatus.class);
+        assertThat(fileSystem.getFileStatus(sstRemotePath1).getPath()).isEqualTo(sstRemotePath1);
+        assertThat(fileSystem.getFileStatus(sstRemotePath1).getLen()).isEqualTo(1L);
+        assertThat(fileSystem.exists(sstRemotePath1)).isTrue();
+        assertThat(fileSystem.listStatus(remotePath)).hasSize(1);
+        assertFileStatusAndBlockLocations(fileSystem, fileSystem.getFileStatus(sstRemotePath1));
+    }
+
+    private static void assertFileStatusAndBlockLocations(
+            FileSystem fileSystem, FileStatus fileStatus) throws IOException {
+        BlockLocation[] blockLocations =
+                fileSystem.getFileBlockLocations(fileStatus, 0, fileStatus.getLen());
+        Arrays.sort(blockLocations, Comparator.comparingLong(BlockLocation::getOffset));
+        long offset = 0L;
+        for (BlockLocation blockLocation : blockLocations) {
+            assertThat(blockLocation.getOffset()).isEqualTo(offset);
+            offset += blockLocation.getLength();
+        }
+        assertThat(offset).isEqualTo(fileStatus.getLen());
+    }
+
     private static class ByteBufferReadableLocalFileSystem extends LocalFileSystem {
 
         @Override
