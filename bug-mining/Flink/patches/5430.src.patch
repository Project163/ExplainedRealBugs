diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
index d225275e3f6..68caf9f387e 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
@@ -23,12 +23,12 @@ import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesConfigMap;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesException;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesLeaderElector;
+import org.apache.flink.runtime.persistence.PossibleInconsistentStateException;
 import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.persistence.StringResourceVersion;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.util.ExceptionUtils;
-import org.apache.flink.util.InstantiationUtil;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -48,6 +48,8 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
+import static org.apache.flink.runtime.util.StateHandleStoreUtils.deserialize;
+import static org.apache.flink.runtime.util.StateHandleStoreUtils.serializeOrDiscard;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /**
@@ -114,21 +116,28 @@ public class KubernetesStateHandleStore<T extends Serializable>
      * @param key Key in ConfigMap
      * @param state State to be added
      * @throws AlreadyExistException if the name already exists
+     * @throws PossibleInconsistentStateException if the write-to-Kubernetes operation failed. This
+     *     indicates that it's not clear whether the new state was successfully written to
+     *     Kubernetes or not. No state was discarded. Proper error handling has to be applied on the
+     *     caller's side.
      * @throws Exception if persisting state or writing state handle failed
      */
     @Override
-    public RetrievableStateHandle<T> addAndLock(String key, T state) throws Exception {
+    public RetrievableStateHandle<T> addAndLock(String key, T state)
+            throws PossibleInconsistentStateException, Exception {
         checkNotNull(key, "Key in ConfigMap.");
         checkNotNull(state, "State.");
 
         final RetrievableStateHandle<T> storeHandle = storage.store(state);
 
-        boolean success = false;
+        final byte[] serializedStoreHandle = serializeOrDiscard(storeHandle);
 
+        // initialize flag to serve the failure case
+        boolean discardState = true;
         try {
-            final byte[] serializedStoreHandle = InstantiationUtil.serializeObject(storeHandle);
-            success =
-                    kubeClient
+            // a successful operation will result in the state not being discarded
+            discardState =
+                    !kubeClient
                             .checkAndUpdateConfigMap(
                                     configMapName,
                                     c -> {
@@ -151,14 +160,20 @@ public class KubernetesStateHandleStore<T extends Serializable>
                             .get();
             return storeHandle;
         } catch (Exception ex) {
+            final Optional<PossibleInconsistentStateException> possibleInconsistentStateException =
+                    ExceptionUtils.findThrowable(ex, PossibleInconsistentStateException.class);
+            if (possibleInconsistentStateException.isPresent()) {
+                // it's unclear whether the state handle metadata was written to the ConfigMap -
+                // hence, we don't discard the data
+                discardState = false;
+                throw possibleInconsistentStateException.get();
+            }
+
             throw ExceptionUtils.findThrowable(ex, AlreadyExistException.class)
                     .orElseThrow(() -> ex);
         } finally {
-            if (!success) {
-                // Cleanup the state handle if it was not written to ConfigMap.
-                if (storeHandle != null) {
-                    storeHandle.discardState();
-                }
+            if (discardState) {
+                storeHandle.discardState();
             }
         }
     }
@@ -173,6 +188,9 @@ public class KubernetesStateHandleStore<T extends Serializable>
      * @param resourceVersion resource version when checking existence via {@link #exists}.
      * @param state State to be added
      * @throws NotExistException if the name does not exist
+     * @throws PossibleInconsistentStateException if a failure occurred during the update operation.
+     *     It's unclear whether the operation actually succeeded or not. No state was discarded. The
+     *     method's caller should handle this case properly.
      * @throws Exception if persisting state or writing state handle failed
      */
     @Override
@@ -185,11 +203,13 @@ public class KubernetesStateHandleStore<T extends Serializable>
 
         final RetrievableStateHandle<T> newStateHandle = storage.store(state);
 
-        boolean success = false;
+        final byte[] serializedStateHandle = serializeOrDiscard(newStateHandle);
 
+        // initialize flags to serve the failure case
+        boolean discardOldState = false;
+        boolean discardNewState = true;
         try {
-            final byte[] serializedStoreHandle = InstantiationUtil.serializeObject(newStateHandle);
-            success =
+            boolean success =
                     kubeClient
                             .checkAndUpdateConfigMap(
                                     configMapName,
@@ -202,7 +222,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
                                                         .put(
                                                                 key,
                                                                 encodeStateHandle(
-                                                                        serializedStoreHandle));
+                                                                        serializedStateHandle));
                                             } else {
                                                 throw new CompletionException(
                                                         getKeyNotExistException(key));
@@ -212,14 +232,29 @@ public class KubernetesStateHandleStore<T extends Serializable>
                                         return Optional.empty();
                                     })
                             .get();
+
+            // swap subject for deletion in case of success
+            discardOldState = success;
+            discardNewState = !success;
         } catch (Exception ex) {
+            final Optional<PossibleInconsistentStateException> possibleInconsistentStateException =
+                    ExceptionUtils.findThrowable(ex, PossibleInconsistentStateException.class);
+            if (possibleInconsistentStateException.isPresent()) {
+                // it's unclear whether the state handle metadata was written to the ConfigMap -
+                // hence, we don't discard any data
+                discardNewState = false;
+                throw possibleInconsistentStateException.get();
+            }
+
             throw ExceptionUtils.findThrowable(ex, NotExistException.class).orElseThrow(() -> ex);
         } finally {
-            if (success) {
-                oldStateHandle.discardState();
-            } else {
+            if (discardNewState) {
                 newStateHandle.discardState();
             }
+
+            if (discardOldState) {
+                oldStateHandle.discardState();
+            }
         }
     }
 
@@ -476,8 +511,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
         final byte[] data = Base64.getDecoder().decode(content);
 
         try {
-            return InstantiationUtil.deserializeObject(
-                    data, Thread.currentThread().getContextClassLoader());
+            return deserialize(data);
         } catch (IOException | ClassNotFoundException e) {
             throw new IOException(
                     "Failed to deserialize state handle from ConfigMap data " + content + '.', e);
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
index 6e230f5250f..b1da85b9ec8 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
@@ -22,6 +22,8 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.core.testutils.FlinkMatchers;
 import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesLeaderElector;
+import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.persistence.PossibleInconsistentStateException;
 import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.persistence.StringResourceVersion;
 import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper;
@@ -126,6 +128,44 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
         };
     }
 
+    @Test
+    public void testAddWithPossiblyInconsistentStateHandling() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final FlinkKubeClient anotherFlinkKubeClient =
+                                    createFlinkKubeClientBuilder()
+                                            .setCheckAndUpdateConfigMapFunction(
+                                                    (configMapName, function) ->
+                                                            FutureUtils.completedExceptionally(
+                                                                    new PossibleInconsistentStateException()))
+                                            .build();
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    anotherFlinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+
+                            try {
+                                store.addAndLock(key, state);
+                                fail("PossibleInconsistentStateException should have been thrown.");
+                            } catch (PossibleInconsistentStateException ex) {
+                                // PossibleInconsistentStateException is expected
+                            }
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(1));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(0));
+                        });
+            }
+        };
+    }
+
     @Test
     public void testAddFailedWhenConfigMapNotExistAndDiscardState() throws Exception {
         new Context() {
@@ -346,6 +386,75 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
         };
     }
 
+    @Test
+    public void testReplaceFailedWithPossiblyInconsistentState() throws Exception {
+        final PossibleInconsistentStateException updateException =
+                new PossibleInconsistentStateException();
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+                            store.addAndLock(key, state);
+
+                            final FlinkKubeClient anotherFlinkKubeClient =
+                                    createFlinkKubeClientBuilder()
+                                            .setCheckAndUpdateConfigMapFunction(
+                                                    (configMapName, function) ->
+                                                            FutureUtils.completedExceptionally(
+                                                                    updateException))
+                                            .build();
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    anotherStore =
+                                            new KubernetesStateHandleStore<>(
+                                                    anotherFlinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+
+                            final StringResourceVersion resourceVersion = anotherStore.exists(key);
+                            assertThat(resourceVersion.isExisting(), is(true));
+                            try {
+                                anotherStore.replace(
+                                        key,
+                                        resourceVersion,
+                                        new TestingLongStateHandleHelper.LongStateHandle(23456L));
+                                fail(
+                                        "An exception having a PossibleInconsistentStateException as its cause should have been thrown.");
+                            } catch (Exception ex) {
+                                assertThat(ex, is(updateException));
+                            }
+                            assertThat(anotherStore.getAllAndLock().size(), is(1));
+                            // The state does not change
+                            assertThat(anotherStore.getAndLock(key).retrieveState(), is(state));
+
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
+                            // no state was discarded
+                            assertThat(
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(0),
+                                    is(0));
+                            assertThat(
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(1),
+                                    is(0));
+                        });
+            }
+        };
+    }
+
     @Test
     public void testGetAndExist() throws Exception {
         new Context() {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/PossibleInconsistentStateException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/PossibleInconsistentStateException.java
index fccfde8508e..364c012e9f1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/PossibleInconsistentStateException.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/PossibleInconsistentStateException.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.persistence;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.util.FlinkException;
 
 /**
@@ -28,6 +29,11 @@ public class PossibleInconsistentStateException extends FlinkException {
 
     private static final long serialVersionUID = 364105635349022882L;
 
+    @VisibleForTesting
+    public PossibleInconsistentStateException() {
+        super("The system might be in an inconsistent state.");
+    }
+
     public PossibleInconsistentStateException(String message, Throwable cause) {
         super(message, cause);
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/StateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/StateHandleStore.java
index cf5d8dc3c51..dff5d084f96 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/StateHandleStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/persistence/StateHandleStore.java
@@ -50,9 +50,14 @@ public interface StateHandleStore<T extends Serializable, R extends ResourceVers
      * @param name Key name in ConfigMap or child path name in ZooKeeper
      * @param state State to be added
      * @throws AlreadyExistException if the name already exists
+     * @throws PossibleInconsistentStateException if the write operation failed. This indicates that
+     *     it's not clear whether the new state was successfully written to distributed coordination
+     *     system or not. No state was discarded. Proper error handling has to be applied on the
+     *     caller's side.
      * @throws Exception if persisting state or writing state handle failed
      */
-    RetrievableStateHandle<T> addAndLock(String name, T state) throws Exception;
+    RetrievableStateHandle<T> addAndLock(String name, T state)
+            throws PossibleInconsistentStateException, Exception;
 
     /**
      * Replaces a state handle in the distributed coordination system and discards the old state
@@ -64,9 +69,13 @@ public interface StateHandleStore<T extends Serializable, R extends ResourceVers
      *     operation snuck in.
      * @param state State to be replace with
      * @throws NotExistException if the name does not exist
+     * @throws PossibleInconsistentStateException if a failure occurred during the update operation
+     *     for which it's unclear whether the operation actually succeeded or not. No state was
+     *     discarded. The method's caller should handle this case properly.
      * @throws Exception if persisting state or writing state handle failed
      */
-    void replace(String name, R resourceVersion, T state) throws Exception;
+    void replace(String name, R resourceVersion, T state)
+            throws PossibleInconsistentStateException, Exception;
 
     /**
      * Returns resource version of state handle with specific name on the underlying storage.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/StateHandleStoreUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/StateHandleStoreUtils.java
new file mode 100644
index 00000000000..d898900ee6c
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/StateHandleStoreUtils.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.util;
+
+import org.apache.flink.runtime.persistence.StateHandleStore;
+import org.apache.flink.runtime.state.RetrievableStateHandle;
+import org.apache.flink.runtime.state.StateObject;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.InstantiationUtil;
+
+import java.io.IOException;
+import java.io.Serializable;
+
+/**
+ * {@code StateHandleStoreUtils} collects utility methods that might be usefule for any {@link
+ * StateHandleStore} implementation.
+ */
+public class StateHandleStoreUtils {
+
+    /**
+     * Serializes the passed {@link StateObject} and discards the state in case of failure.
+     *
+     * @param stateObject the {@code StateObject} that shall be serialized.
+     * @return The serialized version of the passed {@code StateObject}.
+     * @throws Exception if an error occurred during the serialization. The corresponding {@code
+     *     StateObject} will be discarded in that case.
+     */
+    public static byte[] serializeOrDiscard(StateObject stateObject) throws Exception {
+        try {
+            return InstantiationUtil.serializeObject(stateObject);
+        } catch (Exception e) {
+            try {
+                stateObject.discardState();
+            } catch (Exception discardException) {
+                e.addSuppressed(discardException);
+            }
+
+            ExceptionUtils.rethrowException(e);
+        }
+
+        // will never happen but is added to please the compiler
+        return new byte[0];
+    }
+
+    /**
+     * Deserializes the passed data into a {@link RetrievableStateHandle}.
+     *
+     * @param data The data that shall be deserialized.
+     * @param <T> The type of data handled by the deserialized {@code RetrievableStateHandle}.
+     * @return The {@code RetrievableStateHandle} instance.
+     * @throws IOException Any of the usual Input/Output related exceptions.
+     * @throws ClassNotFoundException If the data couldn't be deserialized into a {@code
+     *     RetrievableStateHandle} referring to the expected type {@code <T>}.
+     */
+    public static <T extends Serializable> T deserialize(byte[] data)
+            throws IOException, ClassNotFoundException {
+        return InstantiationUtil.deserializeObject(
+                data, Thread.currentThread().getContextClassLoader());
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java
index 219e55d5e70..22d8f3124fe 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java
@@ -18,13 +18,14 @@
 
 package org.apache.flink.runtime.zookeeper;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.persistence.IntegerResourceVersion;
+import org.apache.flink.runtime.persistence.PossibleInconsistentStateException;
 import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.util.ExceptionUtils;
-import org.apache.flink.util.InstantiationUtil;
 
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
 import org.apache.flink.shaded.curator4.org.apache.curator.utils.ZKPaths;
@@ -41,8 +42,12 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.Set;
 import java.util.UUID;
 
+import static org.apache.flink.runtime.util.StateHandleStoreUtils.deserialize;
+import static org.apache.flink.runtime.util.StateHandleStoreUtils.serializeOrDiscard;
+import static org.apache.flink.shaded.guava18.com.google.common.collect.Sets.newHashSet;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /**
@@ -82,6 +87,19 @@ public class ZooKeeperStateHandleStore<T extends Serializable>
 
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperStateHandleStore.class);
 
+    @VisibleForTesting
+    static final Set<Class<? extends KeeperException>> PRE_COMMIT_EXCEPTIONS =
+            newHashSet(
+                    KeeperException.NodeExistsException.class,
+                    KeeperException.BadArgumentsException.class,
+                    KeeperException.NoNodeException.class,
+                    KeeperException.NoAuthException.class,
+                    KeeperException.BadVersionException.class,
+                    KeeperException.AuthFailedException.class,
+                    KeeperException.InvalidACLException.class,
+                    KeeperException.SessionMovedException.class,
+                    KeeperException.NotReadOnlyException.class);
+
     /** Curator ZooKeeper client. */
     private final CuratorFramework client;
 
@@ -126,10 +144,14 @@ public class ZooKeeperStateHandleStore<T extends Serializable>
      * @param pathInZooKeeper Destination path in ZooKeeper (expected to *not* exist yet)
      * @param state State to be added
      * @return The Created {@link RetrievableStateHandle}.
+     * @throws PossibleInconsistentStateException if the write-to-ZooKeeper operation failed. This
+     *     indicates that it's not clear whether the new state was successfully written to ZooKeeper
+     *     or not. Proper error handling has to be applied on the caller's side.
      * @throws Exception If a ZooKeeper or state handle operation fails
      */
     @Override
-    public RetrievableStateHandle<T> addAndLock(String pathInZooKeeper, T state) throws Exception {
+    public RetrievableStateHandle<T> addAndLock(String pathInZooKeeper, T state)
+            throws PossibleInconsistentStateException, Exception {
         checkNotNull(pathInZooKeeper, "Path in ZooKeeper");
         checkNotNull(state, "State");
 
@@ -137,45 +159,51 @@ public class ZooKeeperStateHandleStore<T extends Serializable>
 
         RetrievableStateHandle<T> storeHandle = storage.store(state);
 
-        boolean success = false;
+        byte[] serializedStoreHandle = serializeOrDiscard(storeHandle);
 
         try {
-            // Serialize the state handle. This writes the state to the backend.
-            byte[] serializedStoreHandle = InstantiationUtil.serializeObject(storeHandle);
-
-            // Write state handle (not the actual state) to ZooKeeper. This is expected to be
-            // smaller than the state itself. This level of indirection makes sure that data in
-            // ZooKeeper is small, because ZooKeeper is designed for data in the KB range, but
-            // the state can be larger.
-            // Create the lock node in a transaction with the actual state node. That way we can
-            // prevent
-            // race conditions with a concurrent delete operation.
-            client.inTransaction()
-                    .create()
-                    .withMode(CreateMode.PERSISTENT)
-                    .forPath(path, serializedStoreHandle)
-                    .and()
-                    .create()
-                    .withMode(CreateMode.EPHEMERAL)
-                    .forPath(getLockPath(path))
-                    .and()
-                    .commit();
-
-            success = true;
+            writeStoreHandleTransactionally(path, serializedStoreHandle);
             return storeHandle;
-        } catch (KeeperException.NodeExistsException e) {
-            // We wrap the exception here so that it could be caught in DefaultJobGraphStore
-            throw new AlreadyExistException("ZooKeeper node " + path + " already exists.", e);
-        } finally {
-            if (!success) {
-                // Cleanup the state handle if it was not written to ZooKeeper.
-                if (storeHandle != null) {
-                    storeHandle.discardState();
-                }
+        } catch (Exception e) {
+            if (indicatesPossiblyInconsistentState(e)) {
+                throw new PossibleInconsistentStateException(e);
             }
+
+            // in any other failure case: discard the state
+            storeHandle.discardState();
+
+            // We wrap the exception here so that it could be caught in DefaultJobGraphStore
+            throw ExceptionUtils.findThrowable(e, KeeperException.NodeExistsException.class)
+                    .map(
+                            nee ->
+                                    new AlreadyExistException(
+                                            "ZooKeeper node " + path + " already exists.", nee))
+                    .orElseThrow(() -> e);
         }
     }
 
+    // this method is provided for the sole purpose of easier testing
+    @VisibleForTesting
+    protected void writeStoreHandleTransactionally(String path, byte[] serializedStoreHandle)
+            throws Exception {
+        // Write state handle (not the actual state) to ZooKeeper. This is expected to be
+        // smaller than the state itself. This level of indirection makes sure that data in
+        // ZooKeeper is small, because ZooKeeper is designed for data in the KB range, but
+        // the state can be larger.
+        // Create the lock node in a transaction with the actual state node. That way we can
+        // prevent race conditions with a concurrent delete operation.
+        client.inTransaction()
+                .create()
+                .withMode(CreateMode.PERSISTENT)
+                .forPath(path, serializedStoreHandle)
+                .and()
+                .create()
+                .withMode(CreateMode.EPHEMERAL)
+                .forPath(getLockPath(path))
+                .and()
+                .commit();
+    }
+
     /**
      * Replaces a state handle in ZooKeeper and discards the old state handle.
      *
@@ -196,29 +224,55 @@ public class ZooKeeperStateHandleStore<T extends Serializable>
 
         RetrievableStateHandle<T> newStateHandle = storage.store(state);
 
-        boolean success = false;
+        final byte[] serializedStateHandle = serializeOrDiscard(newStateHandle);
 
+        // initialize flags to serve the failure case
+        boolean discardOldState = false;
+        boolean discardNewState = true;
         try {
-            // Serialize the new state handle. This writes the state to the backend.
-            byte[] serializedStateHandle = InstantiationUtil.serializeObject(newStateHandle);
+            setStateHandle(path, serializedStateHandle, expectedVersion.getValue());
+
+            // swap subject for deletion in case of success
+            discardOldState = true;
+            discardNewState = false;
+        } catch (Exception e) {
+            if (indicatesPossiblyInconsistentState(e)) {
+                // it's unclear whether the state handle metadata was written to ZooKeeper -
+                // hence, we don't discard any data
+                discardNewState = false;
+                throw new PossibleInconsistentStateException(e);
+            }
 
-            // Replace state handle in ZooKeeper.
-            client.setData()
-                    .withVersion(expectedVersion.getValue())
-                    .forPath(path, serializedStateHandle);
-            success = true;
-        } catch (KeeperException.NoNodeException e) {
             // We wrap the exception here so that it could be caught in DefaultJobGraphStore
-            throw new NotExistException("ZooKeeper node " + path + " does not exist.", e);
+            throw ExceptionUtils.findThrowable(e, KeeperException.NoNodeException.class)
+                    .map(
+                            nnee ->
+                                    new NotExistException(
+                                            "ZooKeeper node " + path + " does not exist.", nnee))
+                    .orElseThrow(() -> e);
         } finally {
-            if (success) {
+            if (discardOldState) {
                 oldStateHandle.discardState();
-            } else {
+            }
+
+            if (discardNewState) {
                 newStateHandle.discardState();
             }
         }
     }
 
+    // this method is provided for the sole purpose of easier testing
+    @VisibleForTesting
+    protected void setStateHandle(String path, byte[] serializedStateHandle, int expectedVersion)
+            throws Exception {
+        // Replace state handle in ZooKeeper.
+        client.setData().withVersion(expectedVersion).forPath(path, serializedStateHandle);
+    }
+
+    private boolean indicatesPossiblyInconsistentState(Exception e) {
+        return !PRE_COMMIT_EXCEPTIONS.contains(e.getClass());
+    }
+
     /**
      * Returns the version of the node if it exists or <code>-1</code> if it doesn't.
      *
@@ -516,9 +570,7 @@ public class ZooKeeperStateHandleStore<T extends Serializable>
         try {
             byte[] data = client.getData().forPath(path);
 
-            RetrievableStateHandle<T> retrievableStateHandle =
-                    InstantiationUtil.deserializeObject(
-                            data, Thread.currentThread().getContextClassLoader());
+            RetrievableStateHandle<T> retrievableStateHandle = deserialize(data);
 
             success = true;
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/StateHandleStoreUtilsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/StateHandleStoreUtilsTest.java
new file mode 100644
index 00000000000..eb79ade5b6f
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/util/StateHandleStoreUtilsTest.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.util;
+
+import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper;
+import org.apache.flink.runtime.state.StateObject;
+import org.apache.flink.util.TestLogger;
+import org.apache.flink.util.function.RunnableWithException;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * {@code StateHandleStoreUtilsTest} tests the utility classes collected in {@link
+ * StateHandleStoreUtils}.
+ */
+public class StateHandleStoreUtilsTest extends TestLogger {
+
+    @Test
+    public void testSerializationAndDeserialization() throws Exception {
+        final TestingLongStateHandleHelper.LongStateHandle original =
+                new TestingLongStateHandleHelper.LongStateHandle(42L);
+        byte[] serializedData = StateHandleStoreUtils.serializeOrDiscard(original);
+
+        final TestingLongStateHandleHelper.LongStateHandle deserializedInstance =
+                StateHandleStoreUtils.deserialize(serializedData);
+        assertThat(deserializedInstance.getStateSize(), is(original.getStateSize()));
+        assertThat(deserializedInstance.getValue(), is(original.getValue()));
+    }
+
+    @Test
+    public void testSerializeOrDiscardFailureHandling() throws Exception {
+        final AtomicBoolean discardCalled = new AtomicBoolean(false);
+        final StateObject original =
+                new FailingSerializationStateObject(() -> discardCalled.set(true));
+
+        try {
+            StateHandleStoreUtils.serializeOrDiscard(original);
+            fail("An IOException is expected to be thrown.");
+        } catch (IOException e) {
+            // IOException is expected
+        }
+
+        assertThat(discardCalled.get(), is(true));
+    }
+
+    @Test
+    public void testSerializationOrDiscardWithDiscardFailure() throws Exception {
+        final Exception discardException =
+                new IllegalStateException(
+                        "Expected IllegalStateException that should be suppressed.");
+        final StateObject original =
+                new FailingSerializationStateObject(
+                        () -> {
+                            throw discardException;
+                        });
+
+        try {
+            StateHandleStoreUtils.serializeOrDiscard(original);
+            fail("An IOException is expected to be thrown.");
+        } catch (IOException e) {
+            // IOException is expected
+            assertThat(e.getSuppressed().length, is(1));
+            assertThat(e.getSuppressed()[0], is(discardException));
+        }
+    }
+
+    private static class FailingSerializationStateObject implements StateObject {
+
+        private static final long serialVersionUID = 6382458109061973983L;
+        private final RunnableWithException discardStateRunnable;
+
+        public FailingSerializationStateObject(RunnableWithException discardStateRunnable) {
+            this.discardStateRunnable = discardStateRunnable;
+        }
+
+        private void writeObject(ObjectOutputStream outputStream) throws IOException {
+            throw new IOException("Expected IOException to test serialization error.");
+        }
+
+        @Override
+        public void discardState() throws Exception {
+            discardStateRunnable.run();
+        }
+
+        @Override
+        public long getStateSize() {
+            return 0;
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
index e9f0bd249ae..0acaa80560a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
@@ -22,7 +22,9 @@ import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.runtime.persistence.IntegerResourceVersion;
+import org.apache.flink.runtime.persistence.PossibleInconsistentStateException;
 import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
+import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.runtime.util.ZooKeeperUtils;
@@ -30,8 +32,10 @@ import org.apache.flink.util.InstantiationUtil;
 import org.apache.flink.util.TestLogger;
 
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
+import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.KeeperException;
 import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.data.Stat;
 
+import org.hamcrest.core.IsInstanceOf;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
@@ -132,53 +136,119 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         assertEquals(state, actual);
     }
 
-    /** Tests that an existing path throws an Exception. */
-    @Test(expected = Exception.class)
-    public void testAddAlreadyExistingPath() throws Exception {
+    /**
+     * Tests that the created state handle is not discarded if ZooKeeper create fails with an
+     * generic exception.
+     */
+    @Test
+    public void testFailingAddWithPossiblyInconsistentState() throws Exception {
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
+        CuratorFramework client = spy(ZOOKEEPER.getClient());
+        when(client.inTransaction().create())
+                .thenThrow(new RuntimeException("Expected test Exception."));
+
         ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
-                new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
+                new ZooKeeperStateHandleStore<>(client, stateHandleProvider);
 
-        ZOOKEEPER.getClient().create().forPath("/testAddAlreadyExistingPath");
+        // Config
+        final String pathInZooKeeper = "/testAddDiscardStateHandleAfterFailure";
+        final long state = 81282227L;
 
-        store.addAndLock(
-                "/testAddAlreadyExistingPath",
-                new TestingLongStateHandleHelper.LongStateHandle(1L));
+        try {
+            // Test
+            store.addAndLock(
+                    pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(state));
+            fail("PossibleInconsistentStateException should have been thrown.");
+        } catch (PossibleInconsistentStateException ignored) {
+            // PossibleInconsistentStateException expected
+        }
 
-        // writing to the state storage should have succeeded
+        // State handle created and not discarded
         assertEquals(1, TestingLongStateHandleHelper.getGlobalStorageSize());
+        assertEquals(state, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
+        assertEquals(0, TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(0));
+    }
 
-        // the created state handle should have been cleaned up if the add operation failed
-        assertEquals(1, TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(0));
+    @Test
+    public void testAddFailureHandlingForNodeExistsException() {
+        testFailingAddWithStateDiscardTriggeredFor(
+                new KeeperException.NodeExistsException(),
+                StateHandleStore.AlreadyExistException.class);
     }
 
-    /** Tests that the created state handle is discarded if ZooKeeper create fails. */
     @Test
-    public void testAddDiscardStateHandleAfterFailure() {
-        // Setup
-        final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
+    public void testAddFailureHandlingForBadArgumentsException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.BadArgumentsException());
+    }
 
-        CuratorFramework client = spy(ZOOKEEPER.getClient());
-        when(client.inTransaction().create())
-                .thenThrow(new RuntimeException("Expected test Exception."));
+    @Test
+    public void testAddFailureHandlingForNoNodeException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.NoNodeException());
+    }
+
+    @Test
+    public void testAddFailureHandlingForNoAuthException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.NoAuthException());
+    }
+
+    @Test
+    public void testAddFailureHandlingForBadVersionException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.BadVersionException());
+    }
+
+    @Test
+    public void testAddFailureHandlingForAuthFailedException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.AuthFailedException());
+    }
+
+    @Test
+    public void testAddFailureHandlingForInvalidACLException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.InvalidACLException());
+    }
+
+    @Test
+    public void testAddFailureHandlingForSessionMovedException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.SessionMovedException());
+    }
+
+    @Test
+    public void testAddFailureHandlingForNotReadOnlyException() {
+        testFailingAddWithStateDiscardTriggeredFor(new KeeperException.NotReadOnlyException());
+    }
+
+    private static void testFailingAddWithStateDiscardTriggeredFor(Exception actualException) {
+        testFailingAddWithStateDiscardTriggeredFor(actualException, actualException.getClass());
+    }
+
+    private static void testFailingAddWithStateDiscardTriggeredFor(
+            Exception actualException, Class<? extends Throwable> expectedException) {
+        final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
         ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
-                new ZooKeeperStateHandleStore<>(client, stateHandleProvider);
+                new ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle>(
+                        ZOOKEEPER.getClient(), stateHandleProvider) {
+                    @Override
+                    protected void writeStoreHandleTransactionally(
+                            String path, byte[] serializedStoreHandle) throws Exception {
+                        throw actualException;
+                    }
+                };
 
         // Config
-        final String pathInZooKeeper = "/testAddDiscardStateHandleAfterFailure";
+        final String pathInZooKeeper =
+                "/testAddDiscardStateHandleAfterFailure-" + expectedException.getSimpleName();
         final long state = 81282227L;
 
         try {
             // Test
             store.addAndLock(
                     pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(state));
-            fail("Did not throw expected exception");
-        } catch (Exception ignored) {
+            fail(expectedException.getSimpleName() + " should have been thrown.");
+        } catch (Exception ex) {
+            assertThat(ex, IsInstanceOf.instanceOf(expectedException));
         }
 
-        // Verify
         // State handle created and discarded
         assertEquals(1, TestingLongStateHandleHelper.getGlobalStorageSize());
         assertEquals(state, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
@@ -281,7 +351,115 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         assertEquals(2, TestingLongStateHandleHelper.getGlobalStorageSize());
         assertEquals(initialState, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
         assertEquals(replaceState, TestingLongStateHandleHelper.getStateHandleValueByIndex(1));
-        assertEquals(1, TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(1));
+        assertThat(TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(0), is(0));
+        assertThat(TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(1), is(0));
+
+        // Initial value
+        @SuppressWarnings("unchecked")
+        final long actual =
+                ((RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>)
+                                InstantiationUtil.deserializeObject(
+                                        ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),
+                                        ClassLoader.getSystemClassLoader()))
+                        .retrieveState()
+                        .getValue();
+
+        assertEquals(initialState, actual);
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithNoNodeException() throws Exception {
+        testDiscardAfterReplaceFailureWith(
+                new KeeperException.NoNodeException(), StateHandleStore.NotExistException.class);
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithNodeExistsException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.NodeExistsException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithBadArgumentsException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.BadArgumentsException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithNoAuthException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.NoAuthException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithBadVersionException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.BadVersionException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithAuthFailedException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.AuthFailedException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithInvalidACLException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.InvalidACLException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithSessionMovedException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.SessionMovedException());
+    }
+
+    @Test
+    public void testDiscardAfterReplaceFailureWithNotReadOnlyException() throws Exception {
+        testDiscardAfterReplaceFailureWith(new KeeperException.NotReadOnlyException());
+    }
+
+    private static void testDiscardAfterReplaceFailureWith(Exception actualException)
+            throws Exception {
+        testDiscardAfterReplaceFailureWith(actualException, actualException.getClass());
+    }
+
+    private static void testDiscardAfterReplaceFailureWith(
+            Exception actualException, Class<? extends Throwable> expectedException)
+            throws Exception {
+        final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
+
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
+                new ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle>(
+                        ZOOKEEPER.getClient(), stateHandleProvider) {
+                    @Override
+                    protected void setStateHandle(
+                            String path, byte[] serializedStateHandle, int expectedVersion)
+                            throws Exception {
+                        throw actualException;
+                    }
+                };
+
+        // Config
+        final String pathInZooKeeper =
+                "/testReplaceDiscardStateHandleAfterFailure-" + expectedException.getSimpleName();
+        final long initialState = 30968470898L;
+        final long replaceState = 88383776661L;
+
+        // Test
+        store.addAndLock(
+                pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(initialState));
+
+        try {
+            store.replace(
+                    pathInZooKeeper,
+                    IntegerResourceVersion.valueOf(0),
+                    new TestingLongStateHandleHelper.LongStateHandle(replaceState));
+            fail("Did not throw expected exception");
+        } catch (Throwable t) {
+            assertThat(t, IsInstanceOf.instanceOf(expectedException));
+        }
+
+        // State handle created and discarded
+        assertEquals(2, TestingLongStateHandleHelper.getGlobalStorageSize());
+        assertEquals(initialState, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
+        assertEquals(replaceState, TestingLongStateHandleHelper.getStateHandleValueByIndex(1));
+        assertThat(TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(0), is(0));
+        assertThat(TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(1), is(1));
 
         // Initial value
         @SuppressWarnings("unchecked")
