diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java
index 7b8c4dd18e6..87c3381abaf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManager.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.jobmaster.slotpool;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
+import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.instance.SlotSharingGroupId;
 import org.apache.flink.runtime.jobmanager.scheduler.Locality;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
@@ -143,41 +144,44 @@ public class SlotSharingManager {
 			SlotRequestId slotRequestId,
 			CompletableFuture<? extends SlotContext> slotContextFuture,
 			SlotRequestId allocatedSlotRequestId) {
+		final CompletableFuture<SlotContext> slotContextFutureAfterRootSlotResolution = new CompletableFuture<>();
 		final MultiTaskSlot rootMultiTaskSlot = new MultiTaskSlot(
 			slotRequestId,
-			slotContextFuture,
+			slotContextFutureAfterRootSlotResolution,
 			allocatedSlotRequestId);
 
 		LOG.debug("Create multi task slot [{}] in slot [{}].", slotRequestId, allocatedSlotRequestId);
 
 		allTaskSlots.put(slotRequestId, rootMultiTaskSlot);
-
 		unresolvedRootSlots.put(slotRequestId, rootMultiTaskSlot);
 
-		// add the root node to the set of resolved root nodes once the SlotContext future has
-		// been completed and we know the slot's TaskManagerLocation
-		slotContextFuture.whenComplete(
-			(SlotContext slotContext, Throwable throwable) -> {
-				if (slotContext != null) {
-					final MultiTaskSlot resolvedRootNode = unresolvedRootSlots.remove(slotRequestId);
+		FutureUtils.forward(
+			slotContextFuture.thenApply(
+				(SlotContext slotContext) -> {
+					// add the root node to the set of resolved root nodes once the SlotContext future has
+					// been completed and we know the slot's TaskManagerLocation
+					tryMarkSlotAsResolved(slotRequestId, slotContext);
+					return slotContext;
+				}),
+			slotContextFutureAfterRootSlotResolution);
 
-					if (resolvedRootNode != null) {
-						final AllocationID allocationId = slotContext.getAllocationId();
-						LOG.trace("Fulfill multi task slot [{}] with slot [{}].", slotRequestId, allocationId);
+		return rootMultiTaskSlot;
+	}
 
-						final Map<AllocationID, MultiTaskSlot> innerMap = resolvedRootSlots.computeIfAbsent(
-							slotContext.getTaskManagerLocation(),
-							taskManagerLocation -> new HashMap<>(4));
+	private void tryMarkSlotAsResolved(SlotRequestId slotRequestId, SlotInfo slotInfo) {
+		final MultiTaskSlot resolvedRootNode = unresolvedRootSlots.remove(slotRequestId);
 
-						MultiTaskSlot previousValue = innerMap.put(allocationId, resolvedRootNode);
-						Preconditions.checkState(previousValue == null);
-					}
-				} else {
-					rootMultiTaskSlot.release(throwable);
-				}
-			});
+		if (resolvedRootNode != null) {
+			final AllocationID allocationId = slotInfo.getAllocationId();
+			LOG.trace("Fulfill multi task slot [{}] with slot [{}].", slotRequestId, allocationId);
 
-		return rootMultiTaskSlot;
+			final Map<AllocationID, MultiTaskSlot> innerMap = resolvedRootSlots.computeIfAbsent(
+				slotInfo.getTaskManagerLocation(),
+				taskManagerLocation -> new HashMap<>(4));
+
+			MultiTaskSlot previousValue = innerMap.put(allocationId, resolvedRootNode);
+			Preconditions.checkState(previousValue == null);
+		}
 	}
 
 	@Nonnull
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManagerTest.java
index 830173c09c5..cdde6dfd1e8 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotSharingManagerTest.java
@@ -53,10 +53,12 @@ import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import static org.hamcrest.CoreMatchers.notNullValue;
 import static org.hamcrest.Matchers.closeTo;
+import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.core.Is.is;
@@ -270,11 +272,7 @@ public class SlotSharingManagerTest extends TestLogger {
 	public void testSlotContextFutureCompletion() throws Exception {
 		final SlotSharingManager slotSharingManager = createTestingSlotSharingManager();
 
-		final SlotContext slotContext = new SimpleSlotContext(
-			new AllocationID(),
-			new LocalTaskManagerLocation(),
-			0,
-			new SimpleAckingTaskManagerGateway());
+		final SlotContext slotContext = createSimpleSlotContext();
 
 		CompletableFuture<SlotContext> slotContextFuture = new CompletableFuture<>();
 		SlotSharingManager.MultiTaskSlot rootSlot = slotSharingManager.createRootSlot(
@@ -330,6 +328,14 @@ public class SlotSharingManagerTest extends TestLogger {
 		assertEquals(slotContext.getAllocationId(), logicalSlot3.getAllocationId());
 	}
 
+	private SimpleSlotContext createSimpleSlotContext() {
+		return new SimpleSlotContext(
+			new AllocationID(),
+			new LocalTaskManagerLocation(),
+			0,
+			new SimpleAckingTaskManagerGateway());
+	}
+
 	/**
 	 * Tests that slot context future failures will release the root slot.
 	 */
@@ -378,12 +384,7 @@ public class SlotSharingManagerTest extends TestLogger {
 		assertFalse(slotSharingManager.getResolvedRootSlots().contains(rootSlot));
 
 		// now complete the slotContextFuture
-		slotContextFuture.complete(
-			new SimpleSlotContext(
-				new AllocationID(),
-				new LocalTaskManagerLocation(),
-				0,
-				new SimpleAckingTaskManagerGateway()));
+		slotContextFuture.complete(createSimpleSlotContext());
 
 		assertFalse(slotSharingManager.getUnresolvedRootSlots().contains(rootSlot));
 		assertTrue(slotSharingManager.getResolvedRootSlots().contains(rootSlot));
@@ -839,6 +840,34 @@ public class SlotSharingManagerTest extends TestLogger {
 		assertThat(utilizationPerTaskExecutor.get(secondTaskExecutorLocation), is(closeTo(0, 0.1)));
 	}
 
+	@Test
+	public void shouldResolveRootSlotBeforeCompletingChildSlots() {
+		final SlotSharingManager slotSharingManager = createTestingSlotSharingManager();
+
+		final CompletableFuture<SlotContext> slotFuture = new CompletableFuture<>();
+		// important to add additional completion stage in order to reverse the execution order of callbacks
+		final CompletableFuture<SlotContext> identityFuture = slotFuture.thenApply(Function.identity());
+
+		final SlotSharingManager.MultiTaskSlot rootSlot = slotSharingManager.createRootSlot(
+			new SlotRequestId(),
+			identityFuture,
+			new SlotRequestId());
+
+		final SlotSharingManager.SingleTaskSlot singleTaskSlot = rootSlot.allocateSingleTaskSlot(
+			new SlotRequestId(),
+			ResourceProfile.UNKNOWN,
+			new AbstractID(),
+			Locality.UNCONSTRAINED);
+
+		final CompletableFuture<Void> assertionFuture = singleTaskSlot.getLogicalSlotFuture().thenRun(() -> assertThat(
+			slotSharingManager.getResolvedRootSlots(),
+			contains(rootSlot)));
+
+		slotFuture.complete(createSimpleSlotContext());
+
+		assertionFuture.join();
+	}
+
 	private SlotSharingManager.MultiTaskSlot createRootSlot(TaskManagerLocation firstTaskExecutorLocation, SlotSharingManager slotSharingManager) {
 		return slotSharingManager.createRootSlot(
 			new SlotRequestId(),
