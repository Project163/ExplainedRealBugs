diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java
index 86eb28dac13..9cdc834f4f3 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java
@@ -364,9 +364,9 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 			SortedMap<RowData, Long> sortedMap, RowData sortKey, RowData inputRow, Collector<RowData> out)
 			throws Exception {
 		Iterator<Map.Entry<RowData, Long>> iterator = sortedMap.entrySet().iterator();
-		long curRank = 0L;
+		long nextRank = 1L; // the next rank number, should be in the rank range
 		boolean findsSortKey = false;
-		while (iterator.hasNext() && isInRankEnd(curRank)) {
+		while (iterator.hasNext() && isInRankEnd(nextRank)) {
 			Map.Entry<RowData, Long> entry = iterator.next();
 			RowData key = entry.getKey();
 			if (!findsSortKey && key.equals(sortKey)) {
@@ -380,20 +380,19 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 					}
 				} else {
 					Iterator<RowData> inputIter = inputs.iterator();
-					while (inputIter.hasNext() && isInRankEnd(curRank)) {
-						curRank += 1;
+					while (inputIter.hasNext() && isInRankEnd(nextRank)) {
 						RowData prevRow = inputIter.next();
 						if (!findsSortKey && equaliser.equals(prevRow, inputRow)) {
-							collectDelete(out, prevRow, curRank);
-							curRank -= 1;
+							collectDelete(out, prevRow, nextRank);
+							nextRank -= 1;
 							findsSortKey = true;
 							inputIter.remove();
 						} else if (findsSortKey) {
-							if (curRank == rankEnd) {
-								collectInsert(out, prevRow, curRank);
-								break;
+							if (nextRank == rankEnd) {
+								collectInsert(out, prevRow, nextRank);
 							}
 						}
+						nextRank += 1;
 					}
 					if (inputs.isEmpty()) {
 						dataState.remove(key);
@@ -404,19 +403,19 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 			} else if (findsSortKey) {
 				long count = entry.getValue();
 				// gets the rank of last record with same sortKey
-				long rankOfLastRecord = curRank + count;
-				// sends the record if there is a record recently upgrades to Top-N
+				long rankOfLastRecord = nextRank + count - 1;
 				if (rankOfLastRecord < rankEnd) {
-					curRank = rankOfLastRecord;
+					nextRank = rankOfLastRecord + 1;
 				} else {
-					int index = Long.valueOf(rankEnd - curRank - 1).intValue();
+					// sends the record if there is a record recently upgrades to Top-N
+					int index = Long.valueOf(rankEnd - nextRank).intValue();
 					List<RowData> inputs = dataState.get(key);
 					RowData toAdd = inputs.get(index);
 					collectInsert(out, toAdd);
 					break;
 				}
 			} else {
-				curRank += entry.getValue();
+				nextRank += entry.getValue();
 			}
 		}
 	}
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java
index a57e0ef0fab..b17cc2b99f6 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java
@@ -399,4 +399,52 @@ public class RetractableTopNFunctionTest extends TopNFunctionTestBase {
 		expectedOutput.add(insertRecord("book", 1L, 12, 1L));
 		assertorWithRowNumber.assertOutputEquals("output wrong.", expectedOutput, testHarness.getOutput());
 	}
+
+	@Test
+	public void testConstantRankRangeWithoutRowNumber() throws Exception {
+		AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER, new ConstantRankRange(1, 3), false,
+			false);
+		OneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(func);
+		testHarness.open();
+		testHarness.processElement(insertRecord("a", 1L, 1));
+		testHarness.processElement(insertRecord("a", 2L, 2));
+		testHarness.processElement(insertRecord("a", 3L, 2));
+		testHarness.processElement(insertRecord("a", 4L, 2));
+		testHarness.processElement(insertRecord("a", 5L, 3));
+		testHarness.processElement(insertRecord("a", 6L, 4));
+		testHarness.processElement(updateBeforeRecord("a", 2L, 2));
+		testHarness.close();
+
+		List<Object> expectedOutput = new ArrayList<>();
+		expectedOutput.add(insertRecord("a", 1L, 1));
+		expectedOutput.add(insertRecord("a", 2L, 2));
+		expectedOutput.add(insertRecord("a", 3L, 2));
+		expectedOutput.add(deleteRecord("a", 2L, 2));
+		expectedOutput.add(insertRecord("a", 4L, 2));
+		assertorWithoutRowNumber.assertOutputEquals("output wrong.", expectedOutput, testHarness.getOutput());
+	}
+
+	@Test
+	public void testConstantRankRangeWithRowNumber() throws Exception {
+		AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER, new ConstantRankRange(1, 3), false,
+			true);
+		OneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(func);
+		testHarness.open();
+		testHarness.processElement(insertRecord("a", 1L, 1));
+		testHarness.processElement(insertRecord("a", 2L, 2));
+		testHarness.processElement(insertRecord("a", 3L, 2));
+		testHarness.processElement(insertRecord("a", 4L, 2));
+		testHarness.processElement(insertRecord("a", 5L, 3));
+		testHarness.processElement(insertRecord("a", 6L, 4));
+		testHarness.processElement(updateBeforeRecord("a", 2L, 2));
+		testHarness.close();
+
+		List<Object> expectedOutput = new ArrayList<>();
+		expectedOutput.add(insertRecord("a", 1L, 1, 1L));
+		expectedOutput.add(insertRecord("a", 2L, 2, 2L));
+		expectedOutput.add(insertRecord("a", 3L, 2, 3L));
+		expectedOutput.add(updateAfterRecord("a", 3L, 2, 2L));
+		expectedOutput.add(updateAfterRecord("a", 4L, 2, 3L));
+		assertorWithRowNumber.assertOutputEquals("output wrong.", expectedOutput, testHarness.getOutput());
+	}
 }
