diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/calcite/FlinkPlannerImpl.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/calcite/FlinkPlannerImpl.scala
index a256c239301..d4b589dcfe7 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/calcite/FlinkPlannerImpl.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/calcite/FlinkPlannerImpl.scala
@@ -177,19 +177,7 @@ class FlinkPlannerImpl(
     )
     val validator = createSqlValidator(readerWithPathAdjusted)
     val validated = validateInternal(parsed, validator)
-    val equivRel = rel(validated, validator)
-    if (!RelOptUtil.areRowTypesEqual(
-      rowType,
-      equivRel.validatedRowType,
-      true
-    )) {
-      throw new TableException(
-        s"""Could not expand view. Types mismatch.
-           | Expected row type: $rowType
-           | Expanded view type: ${equivRel.validatedRowType}
-           |""".stripMargin)
-    }
-    equivRel
+    rel(validated, validator)
   }
 
   private def createRexBuilder: RexBuilder = {
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/CatalogStructureBuilder.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/CatalogStructureBuilder.java
index f4cc7e7d835..94dcac514b2 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/CatalogStructureBuilder.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/CatalogStructureBuilder.java
@@ -22,7 +22,6 @@ import org.apache.flink.api.common.typeinfo.TypeInformation;
 import org.apache.flink.streaming.api.datastream.DataStream;
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
 import org.apache.flink.table.api.TableSchema;
-import org.apache.flink.table.api.Types;
 import org.apache.flink.table.sources.StreamTableSource;
 import org.apache.flink.types.Row;
 
@@ -176,6 +175,8 @@ public class CatalogStructureBuilder {
 	public interface DatabaseEntryBuilder {
 		String getName();
 
+		DatabaseEntryBuilder withTableSchema(TableSchema tableSchema);
+
 		CatalogBaseTable build(String path);
 	}
 
@@ -184,6 +185,7 @@ public class CatalogStructureBuilder {
 	 */
 	public static class TableBuilder implements DatabaseEntryBuilder {
 		private final String name;
+		private TableSchema tableSchema = TableSchema.builder().build();
 
 		TableBuilder(String name) {
 			this.name = name;
@@ -193,8 +195,17 @@ public class CatalogStructureBuilder {
 			return name;
 		}
 
+		@Override
+		public TableBuilder withTableSchema(TableSchema tableSchema) {
+			this.tableSchema = Objects.requireNonNull(tableSchema);
+			return this;
+		}
+
 		public TestTable build(String path) {
-			return new TestTable(path + "." + name, false);
+			return new TestTable(
+				path + "." + name,
+				tableSchema,
+				false);
 		}
 	}
 
@@ -203,6 +214,7 @@ public class CatalogStructureBuilder {
 	 */
 	public static class ViewBuilder implements DatabaseEntryBuilder {
 		private final String name;
+		private TableSchema tableSchema = TableSchema.builder().build();
 		private String query;
 
 		ViewBuilder(String name) {
@@ -218,11 +230,17 @@ public class CatalogStructureBuilder {
 			return this;
 		}
 
+		@Override
+		public ViewBuilder withTableSchema(TableSchema tableSchema) {
+			this.tableSchema = Objects.requireNonNull(tableSchema);
+			return this;
+		}
+
 		public TestView build(String path) {
 			return new TestView(
 				query,
 				query,
-				TableSchema.builder().build(),
+				tableSchema,
 				Collections.emptyMap(),
 				"",
 				true,
@@ -241,7 +259,10 @@ public class CatalogStructureBuilder {
 			return isTemporary;
 		}
 
-		private TestTable(String fullyQualifiedPath, boolean isTemporary) {
+		private TestTable(
+				String fullyQualifiedPath,
+				TableSchema tableSchema,
+				boolean isTemporary) {
 			super(new StreamTableSource<Row>() {
 				@Override
 				public DataStream<Row> getDataStream(StreamExecutionEnvironment execEnv) {
@@ -250,12 +271,12 @@ public class CatalogStructureBuilder {
 
 				@Override
 				public TypeInformation<Row> getReturnType() {
-					return Types.ROW();
+					return tableSchema.toRowType();
 				}
 
 				@Override
 				public TableSchema getTableSchema() {
-					return TableSchema.builder().build();
+					return tableSchema;
 				}
 
 				@Override
@@ -268,6 +289,10 @@ public class CatalogStructureBuilder {
 			this.isTemporary = isTemporary;
 		}
 
+		private TestTable(String fullyQualifiedPath, boolean isTemporary) {
+			this(fullyQualifiedPath, TableSchema.builder().build(), isTemporary);
+		}
+
 		@Override
 		public boolean equals(Object o) {
 			if (this == o) {
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/ViewExpansionTest.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/ViewExpansionTest.java
index b8f8f1c5e70..a206bfb3d9e 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/ViewExpansionTest.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/catalog/ViewExpansionTest.java
@@ -18,7 +18,9 @@
 
 package org.apache.flink.table.catalog;
 
+import org.apache.flink.table.api.DataTypes;
 import org.apache.flink.table.api.Table;
+import org.apache.flink.table.api.TableSchema;
 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
 import org.apache.flink.table.utils.StreamTableTestUtil;
 
@@ -58,6 +60,40 @@ public class ViewExpansionTest {
 			source("builtin", "default", "tab1"));
 	}
 
+	@Test
+	public void testSqlViewExpansionWithMismatchRowType() throws Exception {
+		CatalogManager catalogManager = root()
+			.builtin(
+				database(
+					"default",
+					table("tab1")
+						.withTableSchema(
+							TableSchema.builder()
+								.field("a", DataTypes.INT())
+								.field("b", DataTypes.STRING())
+								.field("c", DataTypes.INT())
+								.build()),
+					view("view")
+						.withTableSchema(
+							TableSchema.builder()
+								// Change the nullability intentionally.
+								.field("a", DataTypes.INT().notNull())
+								.field("b", DataTypes.STRING())
+								.field("c", DataTypes.INT())
+								.build())
+						.withQuery("SELECT a, b, count(c) FROM `builtin`.`default`.tab1 group by a, b")
+				)
+			).build();
+
+		StreamTableTestUtil util = new StreamTableTestUtil(new Some<>(catalogManager));
+		final String expected = "DataStreamCalc(select=[a, b, CAST(EXPR$2) AS c])\n"
+			+ "DataStreamGroupAggregate(groupBy=[a, b], select=[a, b, COUNT(c) AS EXPR$2])\n"
+			+ "StreamTableSourceScan(table=[[builtin, default, tab1]], fields=[a, b, c], source=[isTemporary=[false]])";
+		util.verifyJavaSql(
+				"SELECT * FROM `builtin`.`default`.`view`",
+				expected);
+	}
+
 	@Test
 	public void testTableViewExpansion() throws Exception {
 		CatalogManager catalogManager = root()
@@ -76,6 +112,41 @@ public class ViewExpansionTest {
 			source("builtin", "default", "tab1"));
 	}
 
+	@Test
+	public void testTableViewExpansionWithMismatchRowType() throws Exception {
+		CatalogManager catalogManager = root()
+			.builtin(
+				database(
+					"default",
+					table("tab1")
+						.withTableSchema(
+							TableSchema.builder()
+								.field("a", DataTypes.INT())
+								.field("b", DataTypes.STRING())
+								.field("c", DataTypes.INT())
+								.build()),
+					view("view")
+						.withTableSchema(
+							TableSchema.builder()
+								// Change the nullability intentionally.
+								.field("a", DataTypes.INT().notNull())
+								.field("b", DataTypes.STRING())
+								.field("c", DataTypes.INT())
+								.build())
+						.withQuery("SELECT a, b, count(c) FROM `builtin`.`default`.tab1 group by a, b")
+				)
+			).build();
+
+		StreamTableTestUtil util = new StreamTableTestUtil(new Some<>(catalogManager));
+		Table tab = util.javaTableEnv().scan("builtin", "default", "view").select("*");
+		final String expected = "DataStreamCalc(select=[a, b, CAST(EXPR$2) AS c])\n"
+			+ "DataStreamGroupAggregate(groupBy=[a, b], select=[a, b, COUNT(c) AS EXPR$2])\n"
+			+ "StreamTableSourceScan(table=[[builtin, default, tab1]], fields=[a, b, c], source=[isTemporary=[false]])";
+		util.verifyJavaTable(
+			tab,
+			expected);
+	}
+
 	@Test
 	public void testSqlViewWithoutFullyQualified() throws Exception {
 		CatalogManager catalogManager = root()
