diff --git a/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java b/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java
index 3a377f3ef49..98332968004 100644
--- a/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java
+++ b/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java
@@ -77,6 +77,7 @@ import org.apache.flink.runtime.rest.util.RestClientException;
 import org.apache.flink.runtime.util.ExecutorThreadFactory;
 import org.apache.flink.runtime.util.LeaderConnectionInfo;
 import org.apache.flink.runtime.util.LeaderRetrievalUtils;
+import org.apache.flink.runtime.util.ScalaUtils;
 import org.apache.flink.runtime.webmonitor.retriever.LeaderRetriever;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.ExecutorUtils;
@@ -97,6 +98,7 @@ import java.net.URL;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.ExecutorService;
@@ -107,10 +109,6 @@ import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 
-import scala.Option;
-
-import static org.apache.flink.util.Preconditions.checkArgument;
-
 /**
  * A {@link ClusterClient} implementation that communicates via HTTP REST requests.
  */
@@ -636,9 +634,17 @@ public class RestClusterClient<T> extends ClusterClient<T> {
 				TimeUnit.MILLISECONDS)
 			.thenApplyAsync(leaderAddressSessionId -> {
 				final String address = leaderAddressSessionId.f0;
-				final Option<String> host = AddressFromURIString.parse(address).host();
-				checkArgument(host.isDefined(), "Could not parse host from %s", address);
-				return host.get();
+				final Optional<String> host = ScalaUtils.toJava(AddressFromURIString.parse(address).host());
+
+				return host.orElseGet(() -> {
+					// if the dispatcher address does not contain a host part, then assume it's running
+					// on the same machine as the client
+					log.info("The dispatcher seems to run without remoting enabled. This indicates that we are " +
+						"in a test. This can only work if the RestClusterClient runs on the same machine. " +
+						"Assuming, therefore, 'localhost' as the host.");
+
+					return "localhost";
+				});
 			}, executorService);
 	}
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ScalaUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ScalaUtils.java
new file mode 100644
index 00000000000..fa4260eded8
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ScalaUtils.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.util;
+
+import java.util.Optional;
+
+import scala.Option;
+
+/**
+ * Utilities to convert Scala types into Java types.
+ */
+public class ScalaUtils {
+
+	/**
+	 * Converts a Scala {@link Option} to a {@link Optional}.
+	 *
+	 * @param scalaOption to convert into ta Java {@link Optional}
+	 * @param <T> type of the optional value
+	 * @return Optional of the given option
+	 */
+	public static <T> Optional<T> toJava(Option<T> scalaOption) {
+		if (scalaOption.isEmpty()) {
+			return Optional.empty();
+		} else {
+			return Optional.ofNullable(scalaOption.get());
+		}
+	}
+
+	private ScalaUtils() {}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/ScalaUtilsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ScalaUtilsTest.java
new file mode 100644
index 00000000000..e5e9896240d
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ScalaUtilsTest.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.util;
+
+import org.apache.flink.util.TestLogger;
+
+import org.junit.Test;
+
+import java.util.NoSuchElementException;
+import java.util.Optional;
+
+import scala.Option;
+
+import static org.apache.flink.runtime.util.ScalaUtils.toJava;
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for {@link ScalaUtils} convenience methods.
+ */
+public class ScalaUtilsTest extends TestLogger {
+
+	@Test
+	public void testOptionToOptional() {
+		final String value = "foobar";
+		final Option<String> option = Option.apply(value);
+		final Optional<String> optional = toJava(option);
+
+		assertThat(optional.isPresent(), is(true));
+		assertThat(optional.get(), is(value));
+
+		final Option<String> nullOption = Option.apply(null);
+		final Optional<String> nullOptional = toJava(nullOption);
+
+		assertThat(nullOptional.isPresent(), is(false));
+
+		try {
+			nullOptional.get();
+			fail("Expected NoSuchElementException");
+		} catch (NoSuchElementException ignored) {
+			// ignored
+		}
+
+		final Option<String> emptyOption = Option.empty();
+		final Optional<String> emptyOptional = toJava(emptyOption);
+
+		assertThat(emptyOptional.isPresent(), is(false));
+	}
+}
