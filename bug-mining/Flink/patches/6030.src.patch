diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/JoinedRowDataTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/JoinedRowDataTest.java
index 0feef268638..e9b156e38d3 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/JoinedRowDataTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/JoinedRowDataTest.java
@@ -23,9 +23,9 @@ import org.apache.flink.table.data.RowData;
 import org.apache.flink.table.data.StringData;
 import org.apache.flink.types.RowKind;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
 
 /** Tests for {@link JoinedRowData}. */
 public class JoinedRowDataTest {
@@ -36,19 +36,18 @@ public class JoinedRowDataTest {
         final RowData row2 = GenericRowData.of(3L, StringData.fromString("4"));
         final RowData joinedRow = new JoinedRowData(row1, row2);
 
-        assertEquals(RowKind.INSERT, joinedRow.getRowKind());
-        assertEquals(4, joinedRow.getArity());
-        assertEquals(1L, joinedRow.getLong(0));
-        assertEquals(2L, joinedRow.getLong(1));
-        assertEquals(3L, joinedRow.getLong(2));
-        assertEquals("4", joinedRow.getString(3).toString());
+        assertThat(joinedRow).hasKind(RowKind.INSERT).hasArity(4);
+        assertThat(joinedRow).getLong(0).isEqualTo(1);
+        assertThat(joinedRow).getLong(1).isEqualTo(2);
+        assertThat(joinedRow).getLong(2).isEqualTo(3);
+        assertThat(joinedRow).getString(3).isEqualTo("4");
     }
 
     @Test
     public void testJoinedRowKind() {
         final RowData joinedRow =
                 new JoinedRowData(RowKind.DELETE, GenericRowData.of(), GenericRowData.of());
-        assertEquals(RowKind.DELETE, joinedRow.getRowKind());
+        assertThat(joinedRow).hasKind(RowKind.DELETE);
     }
 
     @Test
@@ -56,12 +55,13 @@ public class JoinedRowDataTest {
         final RowData row1 = GenericRowData.of(1L);
         final RowData row2 = GenericRowData.of(2L);
         final JoinedRowData joinedRow = new JoinedRowData(row1, row2);
-        assertEquals(2, joinedRow.getArity());
+
+        assertThat(joinedRow).hasArity(2);
 
         joinedRow.replace(GenericRowData.of(3L), GenericRowData.of(4L, 5L));
-        assertEquals(3, joinedRow.getArity());
-        assertEquals(3L, joinedRow.getLong(0));
-        assertEquals(4L, joinedRow.getLong(1));
-        assertEquals(5L, joinedRow.getLong(2));
+        assertThat(joinedRow).hasArity(3);
+        assertThat(joinedRow).getLong(0).isEqualTo(3);
+        assertThat(joinedRow).getLong(1).isEqualTo(4);
+        assertThat(joinedRow).getLong(2).isEqualTo(5);
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/ProjectedRowDataTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/ProjectedRowDataTest.java
index 9bb2b056b68..30601e8d230 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/ProjectedRowDataTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/data/utils/ProjectedRowDataTest.java
@@ -20,12 +20,13 @@ package org.apache.flink.table.data.utils;
 
 import org.apache.flink.table.data.GenericRowData;
 import org.apache.flink.table.data.RowData;
+import org.apache.flink.table.test.RowDataAssert;
 import org.apache.flink.types.RowKind;
 
 import org.junit.jupiter.api.Test;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 /** Tests for {@link ProjectedRowData}. */
 public class ProjectedRowDataTest {
@@ -36,31 +37,34 @@ public class ProjectedRowDataTest {
         final ProjectedRowData projectedRowData =
                 ProjectedRowData.from(
                         new int[][] {new int[] {2}, new int[] {0}, new int[] {1}, new int[] {4}});
+        final RowDataAssert rowAssert = assertThat(projectedRowData);
         projectedRowData.replaceRow(initialRow);
 
-        assertEquals(RowKind.INSERT, initialRow.getRowKind());
-        assertEquals(4, projectedRowData.getArity());
-        assertEquals(2L, projectedRowData.getLong(0));
-        assertEquals(0L, projectedRowData.getLong(1));
-        assertEquals(1L, projectedRowData.getLong(2));
-        assertEquals(4L, projectedRowData.getLong(3));
+        rowAssert.hasKind(RowKind.INSERT).hasArity(4);
+        rowAssert.getLong(0).isEqualTo(2);
+        rowAssert.getLong(1).isEqualTo(0);
+        rowAssert.getLong(2).isEqualTo(1);
+        rowAssert.getLong(3).isEqualTo(4);
 
         projectedRowData.replaceRow(GenericRowData.of(5L, 6L, 7L, 8L, 9L, 10L));
-        assertEquals(4, projectedRowData.getArity());
-        assertEquals(7L, projectedRowData.getLong(0));
-        assertEquals(5L, projectedRowData.getLong(1));
-        assertEquals(6L, projectedRowData.getLong(2));
-        assertEquals(9L, projectedRowData.getLong(3));
+        rowAssert.hasKind(RowKind.INSERT).hasArity(4);
+        rowAssert.getLong(0).isEqualTo(7);
+        rowAssert.getLong(1).isEqualTo(5);
+        rowAssert.getLong(2).isEqualTo(6);
+        rowAssert.getLong(3).isEqualTo(9);
     }
 
     @Test
     public void testProjectedRowsDoesntSupportNestedProjections() {
-        assertThrows(
-                IllegalArgumentException.class,
-                () ->
-                        ProjectedRowData.from(
-                                new int[][] {
-                                    new int[] {2}, new int[] {0, 1}, new int[] {1}, new int[] {4}
-                                }));
+        assertThatThrownBy(
+                        () ->
+                                ProjectedRowData.from(
+                                        new int[][] {
+                                            new int[] {2},
+                                            new int[] {0, 1},
+                                            new int[] {1},
+                                            new int[] {4}
+                                        }))
+                .isInstanceOf(IllegalArgumentException.class);
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ClassDataTypeConverterTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ClassDataTypeConverterTest.java
index 9fb9785220b..506fe7d5bb2 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ClassDataTypeConverterTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ClassDataTypeConverterTest.java
@@ -33,9 +33,8 @@ import javax.annotation.Nullable;
 import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Optional;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link ClassDataTypeConverter}. */
 @RunWith(Parameterized.class)
@@ -114,6 +113,10 @@ public class ClassDataTypeConverterTest {
 
     @Test
     public void testClassToDataTypeConversion() {
-        assertEquals(Optional.ofNullable(dataType), ClassDataTypeConverter.extractDataType(clazz));
+        if (dataType == null) {
+            assertThat(ClassDataTypeConverter.extractDataType(clazz)).isEmpty();
+        } else {
+            assertThat(ClassDataTypeConverter.extractDataType(clazz)).contains(dataType);
+        }
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypeTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypeTest.java
index c27b1e16c2f..008fd9e907e 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypeTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypeTest.java
@@ -25,11 +25,8 @@ import org.apache.flink.table.data.MapData;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.table.data.StringData;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
 import java.util.Map;
 
 import static org.apache.flink.table.api.DataTypes.ARRAY;
@@ -48,28 +45,24 @@ import static org.apache.flink.table.api.DataTypes.STRING;
 import static org.apache.flink.table.api.DataTypes.STRUCTURED;
 import static org.apache.flink.table.api.DataTypes.TIMESTAMP;
 import static org.apache.flink.table.api.DataTypes.YEAR;
-import static org.apache.flink.table.types.TypeTestingUtils.hasConversionClass;
-import static org.apache.flink.table.types.TypeTestingUtils.hasNullability;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThat;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 /** Test for {@link DataType}. */
 public class DataTypeTest {
 
     @Test
     public void testNullability() {
-        assertThat(BIGINT().nullable(), hasNullability(true));
-
-        assertThat(BIGINT().notNull(), hasNullability(false));
-
-        assertThat(BIGINT().notNull().nullable(), hasNullability(true));
+        assertThat(BIGINT().nullable()).isNullable();
+        assertThat(BIGINT().notNull()).isNotNullable();
+        assertThat(BIGINT().notNull().nullable()).isNullable();
     }
 
     @Test
     public void testAtomicConversion() {
-        assertThat(
-                TIMESTAMP(0).bridgedTo(java.sql.Timestamp.class),
-                hasConversionClass(java.sql.Timestamp.class));
+        assertThat(TIMESTAMP(0).bridgedTo(java.sql.Timestamp.class))
+                .hasConversionClass(java.sql.Timestamp.class);
     }
 
     @Test
@@ -77,19 +70,19 @@ public class DataTypeTest {
         // this is logically only supported as input type because of
         // nullability but is tolerated until the planner complains
         // about an output type
-        assertThat(BIGINT().nullable().bridgedTo(long.class), hasConversionClass(long.class));
+        assertThat(BIGINT().nullable().bridgedTo(long.class)).hasConversionClass(long.class);
     }
 
-    @Test(expected = ValidationException.class)
+    @Test
     public void testInvalidAtomicConversion() {
-        TIMESTAMP(0).bridgedTo(DataTypesTest.class);
+        assertThatThrownBy(() -> TIMESTAMP(0).bridgedTo(DataTypesTest.class))
+                .isInstanceOf(ValidationException.class);
     }
 
     @Test
     public void testArrayElementConversion() {
-        assertThat(
-                ARRAY(ARRAY(INT().notNull().bridgedTo(int.class))),
-                hasConversionClass(int[][].class));
+        assertThat(ARRAY(ARRAY(INT().notNull().bridgedTo(int.class))))
+                .hasConversionClass(int[][].class);
     }
 
     @Test
@@ -97,127 +90,134 @@ public class DataTypeTest {
         // this is logically only supported as input type because of
         // nullability but is tolerated until the planner complains
         // about an output type
-        assertThat(
-                ARRAY(ARRAY(INT().nullable())).bridgedTo(int[][].class),
-                hasConversionClass(int[][].class));
+        assertThat(ARRAY(ARRAY(INT().nullable())).bridgedTo(int[][].class))
+                .hasConversionClass(int[][].class);
     }
 
-    @Test(expected = ValidationException.class)
+    @Test
     public void testInvalidArrayConversion() {
-        ARRAY(ARRAY(INT())).bridgedTo(int[][][].class);
+        assertThatThrownBy(() -> ARRAY(ARRAY(INT())).bridgedTo(int[][][].class))
+                .isInstanceOf(ValidationException.class);
     }
 
     @Test
     public void testTolerantMapConversion() {
         // this doesn't make much sense logically but is supported until the planner complains
-        assertThat(MULTISET(MULTISET(INT().bridgedTo(int.class))), hasConversionClass(Map.class));
+        assertThat(MULTISET(MULTISET(INT().bridgedTo(int.class)))).hasConversionClass(Map.class);
     }
 
     @Test
     public void testFields() {
-        final DataType rowDataType = ROW(FIELD("field1", CHAR(2)), FIELD("field2", BOOLEAN()));
-
-        final List<DataType> fields = Arrays.asList(CHAR(2), BOOLEAN());
-        assertEquals(fields, rowDataType.getChildren());
+        assertThat(ROW(FIELD("field1", CHAR(2)), FIELD("field2", BOOLEAN())))
+                .getChildren()
+                .containsExactly(CHAR(2), BOOLEAN());
     }
 
-    @Test(expected = ValidationException.class)
+    @Test
     public void testInvalidOrderInterval() {
-        INTERVAL(MONTH(), YEAR(2));
+        assertThatThrownBy(() -> INTERVAL(MONTH(), YEAR(2)))
+                .isInstanceOf(ValidationException.class);
     }
 
     @Test
     public void testConversionEquality() {
-        assertEquals(DataTypes.VARCHAR(2).bridgedTo(String.class), DataTypes.VARCHAR(2));
+        assertThat(DataTypes.VARCHAR(2).bridgedTo(String.class)).isEqualTo(DataTypes.VARCHAR(2));
     }
 
     @Test
     public void testArrayInternalElementConversion() {
-        final DataType arrayDataType = ARRAY(STRING()).bridgedTo(ArrayData.class);
-
-        final List<DataType> children =
-                Collections.singletonList(STRING().bridgedTo(StringData.class));
-
-        assertEquals(children, arrayDataType.getChildren());
+        assertThat(ARRAY(STRING()).bridgedTo(ArrayData.class))
+                .getChildren()
+                .containsExactly(STRING().bridgedTo(StringData.class));
     }
 
     @Test
     public void testMapInternalElementConversion() {
-        final DataType mapDataType = MAP(STRING(), ROW()).bridgedTo(MapData.class);
-
-        final List<DataType> children =
-                Arrays.asList(STRING().bridgedTo(StringData.class), ROW().bridgedTo(RowData.class));
-
-        assertEquals(children, mapDataType.getChildren());
+        assertThat(MAP(STRING(), ROW()).bridgedTo(MapData.class))
+                .getChildren()
+                .containsExactly(
+                        STRING().bridgedTo(StringData.class), ROW().bridgedTo(RowData.class));
     }
 
     @Test
     public void testGetFieldNames() {
-        assertEquals(
-                Arrays.asList("c0", "c1", "c2"),
-                DataType.getFieldNames(
-                        ROW(FIELD("c0", BOOLEAN()), FIELD("c1", DOUBLE()), FIELD("c2", INT()))));
-        assertEquals(
-                Arrays.asList("name", "count"),
-                DataType.getFieldNames(
-                        STRUCTURED(
-                                DataTypesTest.SimplePojo.class,
-                                FIELD("name", STRING()),
-                                FIELD("count", INT().notNull().bridgedTo(int.class)))));
-        assertEquals(Collections.emptyList(), DataType.getFieldNames(ARRAY(INT())));
-        assertEquals(Collections.emptyList(), DataType.getFieldNames(INT()));
+        assertThat(
+                        DataType.getFieldNames(
+                                ROW(
+                                        FIELD("c0", BOOLEAN()),
+                                        FIELD("c1", DOUBLE()),
+                                        FIELD("c2", INT()))))
+                .containsExactly("c0", "c1", "c2");
+        assertThat(
+                        DataType.getFieldNames(
+                                STRUCTURED(
+                                        DataTypesTest.SimplePojo.class,
+                                        FIELD("name", STRING()),
+                                        FIELD("count", INT().notNull().bridgedTo(int.class)))))
+                .containsExactly("name", "count");
+        assertThat(DataType.getFieldNames(ARRAY(INT()))).isEmpty();
+        assertThat(DataType.getFieldNames(INT())).isEmpty();
     }
 
     @Test
     public void testGetFieldDataTypes() {
-        assertEquals(
-                Arrays.asList(BOOLEAN(), DOUBLE(), INT()),
-                DataType.getFieldDataTypes(
-                        ROW(FIELD("c0", BOOLEAN()), FIELD("c1", DOUBLE()), FIELD("c2", INT()))));
-        assertEquals(
-                Arrays.asList(STRING(), INT().notNull().bridgedTo(int.class)),
-                DataType.getFieldDataTypes(
-                        STRUCTURED(
-                                DataTypesTest.SimplePojo.class,
-                                FIELD("name", STRING()),
-                                FIELD("count", INT().notNull().bridgedTo(int.class)))));
-        assertEquals(Collections.emptyList(), DataType.getFieldDataTypes(ARRAY(INT())));
-        assertEquals(Collections.emptyList(), DataType.getFieldDataTypes(INT()));
+        assertThat(
+                        DataType.getFieldDataTypes(
+                                ROW(
+                                        FIELD("c0", BOOLEAN()),
+                                        FIELD("c1", DOUBLE()),
+                                        FIELD("c2", INT()))))
+                .containsExactly(BOOLEAN(), DOUBLE(), INT());
+        assertThat(
+                        DataType.getFieldDataTypes(
+                                STRUCTURED(
+                                        DataTypesTest.SimplePojo.class,
+                                        FIELD("name", STRING()),
+                                        FIELD("count", INT().notNull().bridgedTo(int.class)))))
+                .containsExactly(STRING(), INT().notNull().bridgedTo(int.class));
+        assertThat(DataType.getFieldDataTypes(ARRAY(INT()))).isEmpty();
+        assertThat(DataType.getFieldDataTypes(INT())).isEmpty();
     }
 
     @Test
     public void testGetFieldCount() {
-        assertEquals(
-                3,
-                DataType.getFieldCount(
-                        ROW(FIELD("c0", BOOLEAN()), FIELD("c1", DOUBLE()), FIELD("c2", INT()))));
-        assertEquals(
-                2,
-                DataType.getFieldCount(
-                        STRUCTURED(
-                                DataTypesTest.SimplePojo.class,
-                                FIELD("name", STRING()),
-                                FIELD("count", INT().notNull().bridgedTo(int.class)))));
-        assertEquals(0, DataType.getFieldCount(ARRAY(INT())));
-        assertEquals(0, DataType.getFieldCount(INT()));
+        assertThat(
+                        DataType.getFieldCount(
+                                ROW(
+                                        FIELD("c0", BOOLEAN()),
+                                        FIELD("c1", DOUBLE()),
+                                        FIELD("c2", INT()))))
+                .isEqualTo(3);
+        assertThat(
+                        DataType.getFieldCount(
+                                STRUCTURED(
+                                        DataTypesTest.SimplePojo.class,
+                                        FIELD("name", STRING()),
+                                        FIELD("count", INT().notNull().bridgedTo(int.class)))))
+                .isEqualTo(2);
+        assertThat(DataType.getFieldCount(ARRAY(INT()))).isZero();
+        assertThat(DataType.getFieldCount(INT())).isZero();
     }
 
     @Test
     public void testGetFields() {
-        assertEquals(
-                Arrays.asList(FIELD("c0", BOOLEAN()), FIELD("c1", DOUBLE()), FIELD("c2", INT())),
-                DataType.getFields(
-                        ROW(FIELD("c0", BOOLEAN()), FIELD("c1", DOUBLE()), FIELD("c2", INT()))));
-        assertEquals(
-                Arrays.asList(
+        assertThat(
+                        DataType.getFields(
+                                ROW(
+                                        FIELD("c0", BOOLEAN()),
+                                        FIELD("c1", DOUBLE()),
+                                        FIELD("c2", INT()))))
+                .containsExactly(FIELD("c0", BOOLEAN()), FIELD("c1", DOUBLE()), FIELD("c2", INT()));
+        assertThat(
+                        DataType.getFields(
+                                STRUCTURED(
+                                        DataTypesTest.SimplePojo.class,
+                                        FIELD("name", STRING()),
+                                        FIELD("count", INT().notNull().bridgedTo(int.class)))))
+                .containsExactly(
                         FIELD("name", STRING()),
-                        FIELD("count", INT().notNull().bridgedTo(int.class))),
-                DataType.getFields(
-                        STRUCTURED(
-                                DataTypesTest.SimplePojo.class,
-                                FIELD("name", STRING()),
-                                FIELD("count", INT().notNull().bridgedTo(int.class)))));
-        assertEquals(Collections.emptyList(), DataType.getFields(ARRAY(INT())));
-        assertEquals(Collections.emptyList(), DataType.getFields(INT()));
+                        FIELD("count", INT().notNull().bridgedTo(int.class)));
+        assertThat(DataType.getFields(ARRAY(INT()))).isEmpty();
+        assertThat(DataType.getFields(INT())).isEmpty();
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypesTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypesTest.java
index 281e473f271..9d5288ef126 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypesTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/DataTypesTest.java
@@ -98,15 +98,11 @@ import static org.apache.flink.table.api.DataTypes.TIMESTAMP_WITH_TIME_ZONE;
 import static org.apache.flink.table.api.DataTypes.TINYINT;
 import static org.apache.flink.table.api.DataTypes.VARBINARY;
 import static org.apache.flink.table.api.DataTypes.VARCHAR;
-import static org.apache.flink.table.types.TypeTestingUtils.hasConversionClass;
-import static org.apache.flink.table.types.TypeTestingUtils.hasLogicalType;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
 import static org.apache.flink.table.types.logical.DayTimeIntervalType.DEFAULT_DAY_PRECISION;
 import static org.apache.flink.table.types.logical.DayTimeIntervalType.DayTimeResolution.MINUTE_TO_SECOND;
 import static org.apache.flink.table.types.utils.DataTypeFactoryMock.dummyRaw;
-import static org.apache.flink.table.types.utils.LogicalTypeDataTypeConverter.toDataType;
-import static org.apache.flink.table.types.utils.LogicalTypeDataTypeConverter.toLogicalType;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link DataTypes} and {@link LogicalTypeDataTypeConverter}. */
 @RunWith(Parameterized.class)
@@ -305,51 +301,44 @@ public class DataTypesTest {
         if (testSpec.expectedLogicalType != null) {
             final DataType dataType =
                     testSpec.typeFactory.createDataType(testSpec.abstractDataType);
-
-            assertThat(dataType, hasLogicalType(testSpec.expectedLogicalType));
-
+            assertThat(dataType).hasLogicalType(testSpec.expectedLogicalType);
             assertThat(
-                    toDataType(testSpec.expectedLogicalType)
-                            .bridgedTo(dataType.getConversionClass()),
-                    equalTo(dataType));
-
-            assertThat(toLogicalType(dataType), equalTo(testSpec.expectedLogicalType));
+                            DataTypes.of(testSpec.expectedLogicalType)
+                                    .bridgedTo(dataType.getConversionClass()))
+                    .isEqualTo(dataType);
         }
     }
 
     @Test
     public void testConversionClass() {
         if (testSpec.expectedConversionClass != null) {
-            final DataType dataType =
-                    testSpec.typeFactory.createDataType(testSpec.abstractDataType);
-            assertThat(dataType, hasConversionClass(testSpec.expectedConversionClass));
+            assertThat(testSpec.typeFactory.createDataType(testSpec.abstractDataType))
+                    .hasConversionClass(testSpec.expectedConversionClass);
         }
     }
 
     @Test
     public void testChildren() {
         if (testSpec.expectedChildren != null) {
-            final DataType dataType =
-                    testSpec.typeFactory.createDataType(testSpec.abstractDataType);
-            assertThat(dataType.getChildren(), equalTo(testSpec.expectedChildren));
+            assertThat(testSpec.typeFactory.createDataType(testSpec.abstractDataType))
+                    .getChildren()
+                    .isEqualTo(testSpec.expectedChildren);
         }
     }
 
     @Test
     public void testUnresolvedString() {
         if (testSpec.expectedUnresolvedString != null) {
-            assertThat(
-                    testSpec.abstractDataType.toString(),
-                    equalTo(testSpec.expectedUnresolvedString));
+            assertThat(testSpec.abstractDataType.toString())
+                    .isEqualTo(testSpec.expectedUnresolvedString);
         }
     }
 
     @Test
     public void testResolvedDataType() {
         if (testSpec.expectedResolvedDataType != null) {
-            final DataType dataType =
-                    testSpec.typeFactory.createDataType(testSpec.abstractDataType);
-            assertThat(dataType, equalTo(testSpec.expectedResolvedDataType));
+            assertThat(testSpec.typeFactory.createDataType(testSpec.abstractDataType))
+                    .isEqualTo(testSpec.expectedResolvedDataType);
         }
     }
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalCommonTypeTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalCommonTypeTest.java
index f42537ee6d8..29745ec466a 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalCommonTypeTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalCommonTypeTest.java
@@ -50,12 +50,12 @@ import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameter;
 import org.junit.runners.Parameterized.Parameters;
 
+import javax.annotation.Nullable;
+
 import java.util.Arrays;
 import java.util.List;
-import java.util.Optional;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link LogicalTypeMerging#findCommonType(List)}. */
 @RunWith(Parameterized.class)
@@ -298,11 +298,14 @@ public class LogicalCommonTypeTest {
     @Parameter public List<LogicalType> types;
 
     @Parameter(1)
-    public LogicalType commonType;
+    public @Nullable LogicalType commonType;
 
     @Test
     public void testCommonType() {
-        assertThat(
-                LogicalTypeMerging.findCommonType(types), equalTo(Optional.ofNullable(commonType)));
+        if (commonType == null) {
+            assertThat(LogicalTypeMerging.findCommonType(types)).isEmpty();
+        } else {
+            assertThat(LogicalTypeMerging.findCommonType(types)).contains(commonType);
+        }
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastAvoidanceTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastAvoidanceTest.java
index 470b7208ce7..b60501aa1ab 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastAvoidanceTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastAvoidanceTest.java
@@ -61,9 +61,7 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.table.types.logical.utils.LogicalTypeCasts.supportsAvoidingCast;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link LogicalTypeCasts#supportsAvoidingCast(LogicalType, LogicalType)}. */
 @RunWith(Parameterized.class)
@@ -304,9 +302,9 @@ public class LogicalTypeCastAvoidanceTest {
 
     @Test
     public void testSupportsAvoidingCast() {
-        assertThat(supportsAvoidingCast(sourceType, targetType), equalTo(equals));
-        assertTrue(supportsAvoidingCast(sourceType, sourceType.copy()));
-        assertTrue(supportsAvoidingCast(targetType, targetType.copy()));
+        assertThat(supportsAvoidingCast(sourceType, targetType)).isEqualTo(equals);
+        assertThat(supportsAvoidingCast(sourceType, sourceType.copy())).isTrue();
+        assertThat(supportsAvoidingCast(targetType, targetType.copy())).isTrue();
     }
 
     private static DistinctType createDistinctType(String name, LogicalType sourceType) {
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastsTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastsTest.java
index 4544bb36df2..b80fefed341 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastsTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeCastsTest.java
@@ -53,8 +53,7 @@ import org.junit.runners.Parameterized.Parameters;
 import java.util.Arrays;
 import java.util.List;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link LogicalTypeCasts}. */
 @RunWith(Parameterized.class)
@@ -281,15 +280,13 @@ public class LogicalTypeCastsTest {
 
     @Test
     public void testImplicitCasting() {
-        assertThat(
-                LogicalTypeCasts.supportsImplicitCast(sourceType, targetType),
-                equalTo(supportsImplicit));
+        assertThat(LogicalTypeCasts.supportsImplicitCast(sourceType, targetType))
+                .isEqualTo(supportsImplicit);
     }
 
     @Test
     public void testExplicitCasting() {
-        assertThat(
-                LogicalTypeCasts.supportsExplicitCast(sourceType, targetType),
-                equalTo(supportsExplicit));
+        assertThat(LogicalTypeCasts.supportsExplicitCast(sourceType, targetType))
+                .isEqualTo(supportsExplicit);
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeDuplicatorTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeDuplicatorTest.java
index 674029a471b..93aff7c2df4 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeDuplicatorTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeDuplicatorTest.java
@@ -44,8 +44,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link LogicalTypeDuplicator}. */
 @RunWith(Parameterized.class)
@@ -77,12 +76,12 @@ public class LogicalTypeDuplicatorTest {
 
     @Test
     public void testDuplication() {
-        assertThat(logicalType.accept(DUPLICATOR), equalTo(logicalType));
+        assertThat(logicalType.accept(DUPLICATOR)).isEqualTo(logicalType);
     }
 
     @Test
     public void testReplacement() {
-        assertThat(logicalType.accept(INT_REPLACER), equalTo(replacedLogicalType));
+        assertThat(logicalType.accept(INT_REPLACER)).isEqualTo(replacedLogicalType);
     }
 
     // --------------------------------------------------------------------------------------------
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeParserTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeParserTest.java
index c7780eab211..1a58475f5a8 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeParserTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypeParserTest.java
@@ -74,8 +74,7 @@ import java.util.Collections;
 import java.util.List;
 
 import static org.apache.flink.table.types.logical.LogicalTypeRoot.UNRESOLVED;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link LogicalTypeParser}. */
 @RunWith(Parameterized.class)
@@ -269,8 +268,8 @@ public class LogicalTypeParserTest {
     @Test
     public void testParsing() {
         if (testSpec.expectedType != null) {
-            assertThat(
-                    LogicalTypeParser.parse(testSpec.typeString), equalTo(testSpec.expectedType));
+            assertThat(LogicalTypeParser.parse(testSpec.typeString))
+                    .isEqualTo(testSpec.expectedType);
         }
     }
 
@@ -280,9 +279,8 @@ public class LogicalTypeParserTest {
             if (!testSpec.expectedType.is(UNRESOLVED)
                     && testSpec.expectedType.getChildren().stream()
                             .noneMatch(t -> t.is(UNRESOLVED))) {
-                assertThat(
-                        LogicalTypeParser.parse(testSpec.expectedType.asSerializableString()),
-                        equalTo(testSpec.expectedType));
+                assertThat(LogicalTypeParser.parse(testSpec.expectedType.asSerializableString()))
+                        .isEqualTo(testSpec.expectedType);
             }
         }
     }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypesTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypesTest.java
index 9bd98209546..10ee557085e 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypesTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/LogicalTypesTest.java
@@ -23,7 +23,6 @@ import org.apache.flink.api.common.typeinfo.Types;
 import org.apache.flink.api.java.tuple.Tuple;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer;
-import org.apache.flink.table.api.TableException;
 import org.apache.flink.table.api.ValidationException;
 import org.apache.flink.table.catalog.ObjectIdentifier;
 import org.apache.flink.table.catalog.UnresolvedIdentifier;
@@ -62,8 +61,8 @@ import org.apache.flink.table.types.logical.VarCharType;
 import org.apache.flink.table.types.logical.YearMonthIntervalType;
 import org.apache.flink.table.types.logical.ZonedTimestampType;
 import org.apache.flink.types.Row;
-import org.apache.flink.util.InstantiationUtil;
 
+import org.assertj.core.api.ThrowingConsumer;
 import org.junit.Test;
 
 import java.math.BigDecimal;
@@ -76,480 +75,531 @@ import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 /** Test for subclasses of {@link org.apache.flink.table.types.logical.LogicalType}. */
 public class LogicalTypesTest {
 
     @Test
     public void testCharType() {
-        testAll(
-                new CharType(33),
-                "CHAR(33)",
-                "CHAR(33)",
-                new Class[] {String.class, byte[].class},
-                new Class[] {String.class, byte[].class},
-                new LogicalType[] {},
-                new CharType(Integer.MAX_VALUE));
+        assertThat(new CharType(33))
+                .satisfies(
+                        baseAssertions(
+                                "CHAR(33)",
+                                "CHAR(33)",
+                                new Class[] {String.class, byte[].class},
+                                new Class[] {String.class, byte[].class},
+                                new LogicalType[] {},
+                                new CharType(Integer.MAX_VALUE)));
     }
 
     @Test
     public void testVarCharType() {
-        testAll(
-                new VarCharType(33),
-                "VARCHAR(33)",
-                "VARCHAR(33)",
-                new Class[] {String.class, byte[].class},
-                new Class[] {String.class, byte[].class},
-                new LogicalType[] {},
-                new VarCharType(12));
+        assertThat(new VarCharType(33))
+                .satisfies(
+                        baseAssertions(
+                                "VARCHAR(33)",
+                                "VARCHAR(33)",
+                                new Class[] {String.class, byte[].class},
+                                new Class[] {String.class, byte[].class},
+                                new LogicalType[] {},
+                                new VarCharType(12)));
     }
 
     @Test
     public void testVarCharTypeWithMaximumLength() {
-        testAll(
-                new VarCharType(Integer.MAX_VALUE),
-                "VARCHAR(2147483647)",
-                "STRING",
-                new Class[] {String.class, byte[].class},
-                new Class[] {String.class, byte[].class},
-                new LogicalType[] {},
-                new VarCharType(12));
+        assertThat(new VarCharType(Integer.MAX_VALUE))
+                .satisfies(
+                        baseAssertions(
+                                "VARCHAR(2147483647)",
+                                "STRING",
+                                new Class[] {String.class, byte[].class},
+                                new Class[] {String.class, byte[].class},
+                                new LogicalType[] {},
+                                new VarCharType(12)));
     }
 
     @Test
     public void testBooleanType() {
-        testAll(
-                new BooleanType(),
-                "BOOLEAN",
-                "BOOLEAN",
-                new Class[] {Boolean.class, boolean.class},
-                new Class[] {Boolean.class},
-                new LogicalType[] {},
-                new BooleanType(false));
+        assertThat(new BooleanType())
+                .satisfies(
+                        baseAssertions(
+                                "BOOLEAN",
+                                "BOOLEAN",
+                                new Class[] {Boolean.class, boolean.class},
+                                new Class[] {Boolean.class},
+                                new LogicalType[] {},
+                                new BooleanType(false)));
     }
 
     @Test
     public void testBinaryType() {
-        testAll(
-                new BinaryType(22),
-                "BINARY(22)",
-                "BINARY(22)",
-                new Class[] {byte[].class},
-                new Class[] {byte[].class},
-                new LogicalType[] {},
-                new BinaryType());
+        assertThat(new BinaryType(22))
+                .satisfies(
+                        baseAssertions(
+                                "BINARY(22)",
+                                "BINARY(22)",
+                                new Class[] {byte[].class},
+                                new Class[] {byte[].class},
+                                new LogicalType[] {},
+                                new BinaryType()));
     }
 
     @Test
     public void testVarBinaryType() {
-        testAll(
-                new VarBinaryType(22),
-                "VARBINARY(22)",
-                "VARBINARY(22)",
-                new Class[] {byte[].class},
-                new Class[] {byte[].class},
-                new LogicalType[] {},
-                new VarBinaryType());
+        assertThat(new VarBinaryType(22))
+                .satisfies(
+                        baseAssertions(
+                                "VARBINARY(22)",
+                                "VARBINARY(22)",
+                                new Class[] {byte[].class},
+                                new Class[] {byte[].class},
+                                new LogicalType[] {},
+                                new VarBinaryType()));
     }
 
     @Test
     public void testVarBinaryTypeWithMaximumLength() {
-        testAll(
-                new VarBinaryType(Integer.MAX_VALUE),
-                "VARBINARY(2147483647)",
-                "BYTES",
-                new Class[] {byte[].class},
-                new Class[] {byte[].class},
-                new LogicalType[] {},
-                new VarBinaryType(12));
+        assertThat(new VarBinaryType(Integer.MAX_VALUE))
+                .satisfies(
+                        baseAssertions(
+                                "VARBINARY(2147483647)",
+                                "BYTES",
+                                new Class[] {byte[].class},
+                                new Class[] {byte[].class},
+                                new LogicalType[] {},
+                                new VarBinaryType(12)));
     }
 
     @Test
     public void testDecimalType() {
-        testAll(
-                new DecimalType(10, 2),
-                "DECIMAL(10, 2)",
-                "DECIMAL(10, 2)",
-                new Class[] {BigDecimal.class},
-                new Class[] {BigDecimal.class},
-                new LogicalType[] {},
-                new DecimalType());
+        assertThat(new DecimalType(10, 2))
+                .satisfies(
+                        baseAssertions(
+                                "DECIMAL(10, 2)",
+                                "DECIMAL(10, 2)",
+                                new Class[] {BigDecimal.class},
+                                new Class[] {BigDecimal.class},
+                                new LogicalType[] {},
+                                new DecimalType()));
     }
 
     @Test
     public void testTinyIntType() {
-        testAll(
-                new TinyIntType(),
-                "TINYINT",
-                "TINYINT",
-                new Class[] {Byte.class, byte.class},
-                new Class[] {Byte.class},
-                new LogicalType[] {},
-                new TinyIntType(false));
+        assertThat(new TinyIntType())
+                .satisfies(
+                        baseAssertions(
+                                "TINYINT",
+                                "TINYINT",
+                                new Class[] {Byte.class, byte.class},
+                                new Class[] {Byte.class},
+                                new LogicalType[] {},
+                                new TinyIntType(false)));
     }
 
     @Test
     public void testSmallIntType() {
-        testAll(
-                new SmallIntType(),
-                "SMALLINT",
-                "SMALLINT",
-                new Class[] {Short.class, short.class},
-                new Class[] {Short.class},
-                new LogicalType[] {},
-                new SmallIntType(false));
+        assertThat(new SmallIntType())
+                .satisfies(
+                        baseAssertions(
+                                "SMALLINT",
+                                "SMALLINT",
+                                new Class[] {Short.class, short.class},
+                                new Class[] {Short.class},
+                                new LogicalType[] {},
+                                new SmallIntType(false)));
     }
 
     @Test
     public void testIntType() {
-        testAll(
-                new IntType(),
-                "INT",
-                "INT",
-                new Class[] {Integer.class, int.class},
-                new Class[] {Integer.class},
-                new LogicalType[] {},
-                new IntType(false));
+        assertThat(new IntType())
+                .satisfies(
+                        baseAssertions(
+                                "INT",
+                                "INT",
+                                new Class[] {Integer.class, int.class},
+                                new Class[] {Integer.class},
+                                new LogicalType[] {},
+                                new IntType(false)));
     }
 
     @Test
     public void testBigIntType() {
-        testAll(
-                new BigIntType(),
-                "BIGINT",
-                "BIGINT",
-                new Class[] {Long.class, long.class},
-                new Class[] {Long.class},
-                new LogicalType[] {},
-                new BigIntType(false));
+        assertThat(new BigIntType())
+                .satisfies(
+                        baseAssertions(
+                                "BIGINT",
+                                "BIGINT",
+                                new Class[] {Long.class, long.class},
+                                new Class[] {Long.class},
+                                new LogicalType[] {},
+                                new BigIntType(false)));
     }
 
     @Test
     public void testFloatType() {
-        testAll(
-                new FloatType(),
-                "FLOAT",
-                "FLOAT",
-                new Class[] {Float.class, float.class},
-                new Class[] {Float.class},
-                new LogicalType[] {},
-                new FloatType(false));
+        assertThat(new FloatType())
+                .satisfies(
+                        baseAssertions(
+                                "FLOAT",
+                                "FLOAT",
+                                new Class[] {Float.class, float.class},
+                                new Class[] {Float.class},
+                                new LogicalType[] {},
+                                new FloatType(false)));
     }
 
     @Test
     public void testDoubleType() {
-        testAll(
-                new DoubleType(),
-                "DOUBLE",
-                "DOUBLE",
-                new Class[] {Double.class, double.class},
-                new Class[] {Double.class},
-                new LogicalType[] {},
-                new DoubleType(false));
+        assertThat(new DoubleType())
+                .satisfies(
+                        baseAssertions(
+                                "DOUBLE",
+                                "DOUBLE",
+                                new Class[] {Double.class, double.class},
+                                new Class[] {Double.class},
+                                new LogicalType[] {},
+                                new DoubleType(false)));
     }
 
     @Test
     public void testDateType() {
-        testAll(
-                new DateType(),
-                "DATE",
-                "DATE",
-                new Class[] {java.sql.Date.class, java.time.LocalDate.class, int.class},
-                new Class[] {java.time.LocalDate.class},
-                new LogicalType[] {},
-                new DateType(false));
+        assertThat(new DateType())
+                .satisfies(
+                        baseAssertions(
+                                "DATE",
+                                "DATE",
+                                new Class[] {
+                                    java.sql.Date.class, java.time.LocalDate.class, int.class
+                                },
+                                new Class[] {java.time.LocalDate.class},
+                                new LogicalType[] {},
+                                new DateType(false)));
     }
 
     @Test
     public void testTimeType() {
-        testAll(
-                new TimeType(9),
-                "TIME(9)",
-                "TIME(9)",
-                new Class[] {java.sql.Time.class, java.time.LocalTime.class, long.class},
-                new Class[] {java.time.LocalTime.class},
-                new LogicalType[] {},
-                new TimeType());
+        assertThat(new TimeType(9))
+                .satisfies(
+                        baseAssertions(
+                                "TIME(9)",
+                                "TIME(9)",
+                                new Class[] {
+                                    java.sql.Time.class, java.time.LocalTime.class, long.class
+                                },
+                                new Class[] {java.time.LocalTime.class},
+                                new LogicalType[] {},
+                                new TimeType()));
     }
 
     @Test
     public void testTimestampType() {
-        testAll(
-                new TimestampType(9),
-                "TIMESTAMP(9)",
-                "TIMESTAMP(9)",
-                new Class[] {java.sql.Timestamp.class, java.time.LocalDateTime.class},
-                new Class[] {java.time.LocalDateTime.class},
-                new LogicalType[] {},
-                new TimestampType(3));
+        assertThat(new TimestampType(9))
+                .satisfies(
+                        baseAssertions(
+                                "TIMESTAMP(9)",
+                                "TIMESTAMP(9)",
+                                new Class[] {
+                                    java.sql.Timestamp.class, java.time.LocalDateTime.class
+                                },
+                                new Class[] {java.time.LocalDateTime.class},
+                                new LogicalType[] {},
+                                new TimestampType(3)));
     }
 
     @Test
     public void testTimestampTypeWithTimeAttribute() {
-        testAll(
-                new TimestampType(true, TimestampKind.ROWTIME, 9),
-                "TIMESTAMP(9)",
-                "TIMESTAMP(9) *ROWTIME*",
-                new Class[] {java.sql.Timestamp.class, java.time.LocalDateTime.class},
-                new Class[] {java.time.LocalDateTime.class},
-                new LogicalType[] {},
-                new TimestampType(3));
+        assertThat(new TimestampType(true, TimestampKind.ROWTIME, 9))
+                .satisfies(
+                        baseAssertions(
+                                "TIMESTAMP(9)",
+                                "TIMESTAMP(9) *ROWTIME*",
+                                new Class[] {
+                                    java.sql.Timestamp.class, java.time.LocalDateTime.class
+                                },
+                                new Class[] {java.time.LocalDateTime.class},
+                                new LogicalType[] {},
+                                new TimestampType(3)));
     }
 
     @Test
     public void testZonedTimestampType() {
-        testAll(
-                new ZonedTimestampType(9),
-                "TIMESTAMP(9) WITH TIME ZONE",
-                "TIMESTAMP(9) WITH TIME ZONE",
-                new Class[] {java.time.ZonedDateTime.class, java.time.OffsetDateTime.class},
-                new Class[] {java.time.OffsetDateTime.class},
-                new LogicalType[] {},
-                new ZonedTimestampType(3));
+        assertThat(new ZonedTimestampType(9))
+                .satisfies(
+                        baseAssertions(
+                                "TIMESTAMP(9) WITH TIME ZONE",
+                                "TIMESTAMP(9) WITH TIME ZONE",
+                                new Class[] {
+                                    java.time.ZonedDateTime.class, java.time.OffsetDateTime.class
+                                },
+                                new Class[] {java.time.OffsetDateTime.class},
+                                new LogicalType[] {},
+                                new ZonedTimestampType(3)));
     }
 
     @Test
     public void testZonedTimestampTypeWithTimeAttribute() {
-        testAll(
-                new ZonedTimestampType(true, TimestampKind.ROWTIME, 9),
-                "TIMESTAMP(9) WITH TIME ZONE",
-                "TIMESTAMP(9) WITH TIME ZONE *ROWTIME*",
-                new Class[] {java.time.ZonedDateTime.class, java.time.OffsetDateTime.class},
-                new Class[] {java.time.OffsetDateTime.class},
-                new LogicalType[] {},
-                new ZonedTimestampType(3));
+        assertThat(new ZonedTimestampType(true, TimestampKind.ROWTIME, 9))
+                .satisfies(
+                        baseAssertions(
+                                "TIMESTAMP(9) WITH TIME ZONE",
+                                "TIMESTAMP(9) WITH TIME ZONE *ROWTIME*",
+                                new Class[] {
+                                    java.time.ZonedDateTime.class, java.time.OffsetDateTime.class
+                                },
+                                new Class[] {java.time.OffsetDateTime.class},
+                                new LogicalType[] {},
+                                new ZonedTimestampType(3)));
     }
 
     @Test
     public void testLocalZonedTimestampType() {
-        testAll(
-                new LocalZonedTimestampType(9),
-                "TIMESTAMP(9) WITH LOCAL TIME ZONE",
-                "TIMESTAMP_LTZ(9)",
-                new Class[] {java.time.Instant.class, long.class, int.class},
-                new Class[] {java.time.Instant.class},
-                new LogicalType[] {},
-                new LocalZonedTimestampType(3));
+        assertThat(new LocalZonedTimestampType(9))
+                .satisfies(
+                        baseAssertions(
+                                "TIMESTAMP(9) WITH LOCAL TIME ZONE",
+                                "TIMESTAMP_LTZ(9)",
+                                new Class[] {java.time.Instant.class, long.class, int.class},
+                                new Class[] {java.time.Instant.class},
+                                new LogicalType[] {},
+                                new LocalZonedTimestampType(3)));
     }
 
     @Test
     public void testLocalZonedTimestampTypeWithTimeAttribute() {
-        testAll(
-                new LocalZonedTimestampType(true, TimestampKind.ROWTIME, 9),
-                "TIMESTAMP(9) WITH LOCAL TIME ZONE",
-                "TIMESTAMP_LTZ(9) *ROWTIME*",
-                new Class[] {java.time.Instant.class, long.class, int.class},
-                new Class[] {java.time.Instant.class},
-                new LogicalType[] {},
-                new LocalZonedTimestampType(3));
+        assertThat(new LocalZonedTimestampType(true, TimestampKind.ROWTIME, 9))
+                .satisfies(
+                        baseAssertions(
+                                "TIMESTAMP(9) WITH LOCAL TIME ZONE",
+                                "TIMESTAMP_LTZ(9) *ROWTIME*",
+                                new Class[] {java.time.Instant.class, long.class, int.class},
+                                new Class[] {java.time.Instant.class},
+                                new LogicalType[] {},
+                                new LocalZonedTimestampType(3)));
     }
 
     @Test
     public void testYearMonthIntervalType() {
-        testAll(
-                new YearMonthIntervalType(
-                        YearMonthIntervalType.YearMonthResolution.YEAR_TO_MONTH, 2),
-                "INTERVAL YEAR(2) TO MONTH",
-                "INTERVAL YEAR(2) TO MONTH",
-                new Class[] {java.time.Period.class, int.class},
-                new Class[] {java.time.Period.class},
-                new LogicalType[] {},
-                new YearMonthIntervalType(YearMonthIntervalType.YearMonthResolution.MONTH));
+        assertThat(
+                        new YearMonthIntervalType(
+                                YearMonthIntervalType.YearMonthResolution.YEAR_TO_MONTH, 2))
+                .satisfies(
+                        baseAssertions(
+                                "INTERVAL YEAR(2) TO MONTH",
+                                "INTERVAL YEAR(2) TO MONTH",
+                                new Class[] {java.time.Period.class, int.class},
+                                new Class[] {java.time.Period.class},
+                                new LogicalType[] {},
+                                new YearMonthIntervalType(
+                                        YearMonthIntervalType.YearMonthResolution.MONTH)));
     }
 
     @Test
     public void testDayTimeIntervalType() {
-        testAll(
-                new DayTimeIntervalType(DayTimeIntervalType.DayTimeResolution.DAY_TO_SECOND, 2, 6),
-                "INTERVAL DAY(2) TO SECOND(6)",
-                "INTERVAL DAY(2) TO SECOND(6)",
-                new Class[] {java.time.Duration.class, long.class},
-                new Class[] {java.time.Duration.class},
-                new LogicalType[] {},
-                new DayTimeIntervalType(DayTimeIntervalType.DayTimeResolution.DAY_TO_SECOND, 2, 7));
+        assertThat(
+                        new DayTimeIntervalType(
+                                DayTimeIntervalType.DayTimeResolution.DAY_TO_SECOND, 2, 6))
+                .satisfies(
+                        baseAssertions(
+                                "INTERVAL DAY(2) TO SECOND(6)",
+                                "INTERVAL DAY(2) TO SECOND(6)",
+                                new Class[] {java.time.Duration.class, long.class},
+                                new Class[] {java.time.Duration.class},
+                                new LogicalType[] {},
+                                new DayTimeIntervalType(
+                                        DayTimeIntervalType.DayTimeResolution.DAY_TO_SECOND,
+                                        2,
+                                        7)));
     }
 
     @Test
     public void testArrayType() {
-        testAll(
-                new ArrayType(new TimestampType()),
-                "ARRAY<TIMESTAMP(6)>",
-                "ARRAY<TIMESTAMP(6)>",
-                new Class[] {
-                    java.sql.Timestamp[].class,
-                    java.time.LocalDateTime[].class,
-                    List.class,
-                    ArrayList.class
-                },
-                new Class[] {
-                    java.sql.Timestamp[].class, java.time.LocalDateTime[].class, List.class
-                },
-                new LogicalType[] {new TimestampType()},
-                new ArrayType(new SmallIntType()));
-
-        testAll(
-                new ArrayType(new ArrayType(new TimestampType())),
-                "ARRAY<ARRAY<TIMESTAMP(6)>>",
-                "ARRAY<ARRAY<TIMESTAMP(6)>>",
-                new Class[] {java.sql.Timestamp[][].class, java.time.LocalDateTime[][].class},
-                new Class[] {java.sql.Timestamp[][].class, java.time.LocalDateTime[][].class},
-                new LogicalType[] {new ArrayType(new TimestampType())},
-                new ArrayType(new ArrayType(new SmallIntType())));
+        assertThat(new ArrayType(new TimestampType()))
+                .satisfies(
+                        baseAssertions(
+                                "ARRAY<TIMESTAMP(6)>",
+                                "ARRAY<TIMESTAMP(6)>",
+                                new Class[] {
+                                    java.sql.Timestamp[].class,
+                                    java.time.LocalDateTime[].class,
+                                    List.class,
+                                    ArrayList.class
+                                },
+                                new Class[] {
+                                    java.sql.Timestamp[].class,
+                                    java.time.LocalDateTime[].class,
+                                    List.class
+                                },
+                                new LogicalType[] {new TimestampType()},
+                                new ArrayType(new SmallIntType())));
+
+        assertThat(new ArrayType(new ArrayType(new TimestampType())))
+                .satisfies(
+                        baseAssertions(
+                                "ARRAY<ARRAY<TIMESTAMP(6)>>",
+                                "ARRAY<ARRAY<TIMESTAMP(6)>>",
+                                new Class[] {
+                                    java.sql.Timestamp[][].class, java.time.LocalDateTime[][].class
+                                },
+                                new Class[] {
+                                    java.sql.Timestamp[][].class, java.time.LocalDateTime[][].class
+                                },
+                                new LogicalType[] {new ArrayType(new TimestampType())},
+                                new ArrayType(new ArrayType(new SmallIntType()))));
 
         final LogicalType nestedArray = new ArrayType(new ArrayType(new TimestampType()));
-        assertFalse(nestedArray.supportsInputConversion(java.sql.Timestamp[].class));
-        assertFalse(nestedArray.supportsOutputConversion(java.sql.Timestamp[].class));
+        assertThat(nestedArray)
+                .doesNotSupportInputConversion(java.sql.Timestamp[].class)
+                .doesNotSupportOutputConversion(java.sql.Timestamp[].class);
     }
 
     @Test
     public void testMultisetType() {
-        testAll(
-                new MultisetType(new TimestampType()),
-                "MULTISET<TIMESTAMP(6)>",
-                "MULTISET<TIMESTAMP(6)>",
-                new Class[] {Map.class, HashMap.class, TreeMap.class},
-                new Class[] {Map.class},
-                new LogicalType[] {new TimestampType()},
-                new MultisetType(new SmallIntType()));
-
-        testAll(
-                new MultisetType(new MultisetType(new TimestampType())),
-                "MULTISET<MULTISET<TIMESTAMP(6)>>",
-                "MULTISET<MULTISET<TIMESTAMP(6)>>",
-                new Class[] {Map.class, HashMap.class, TreeMap.class},
-                new Class[] {Map.class},
-                new LogicalType[] {new MultisetType(new TimestampType())},
-                new MultisetType(new MultisetType(new SmallIntType())));
+        assertThat(new MultisetType(new TimestampType()))
+                .satisfies(
+                        baseAssertions(
+                                "MULTISET<TIMESTAMP(6)>",
+                                "MULTISET<TIMESTAMP(6)>",
+                                new Class[] {Map.class, HashMap.class, TreeMap.class},
+                                new Class[] {Map.class},
+                                new LogicalType[] {new TimestampType()},
+                                new MultisetType(new SmallIntType())));
+
+        assertThat(new MultisetType(new MultisetType(new TimestampType())))
+                .satisfies(
+                        baseAssertions(
+                                "MULTISET<MULTISET<TIMESTAMP(6)>>",
+                                "MULTISET<MULTISET<TIMESTAMP(6)>>",
+                                new Class[] {Map.class, HashMap.class, TreeMap.class},
+                                new Class[] {Map.class},
+                                new LogicalType[] {new MultisetType(new TimestampType())},
+                                new MultisetType(new MultisetType(new SmallIntType()))));
     }
 
     @Test
     public void testMapType() {
-        testAll(
-                new MapType(new VarCharType(20), new TimestampType()),
-                "MAP<VARCHAR(20), TIMESTAMP(6)>",
-                "MAP<VARCHAR(20), TIMESTAMP(6)>",
-                new Class[] {Map.class, HashMap.class, TreeMap.class},
-                new Class[] {Map.class},
-                new LogicalType[] {new VarCharType(20), new TimestampType()},
-                new MapType(new VarCharType(99), new TimestampType()));
+        assertThat(new MapType(new VarCharType(20), new TimestampType()))
+                .satisfies(
+                        baseAssertions(
+                                "MAP<VARCHAR(20), TIMESTAMP(6)>",
+                                "MAP<VARCHAR(20), TIMESTAMP(6)>",
+                                new Class[] {Map.class, HashMap.class, TreeMap.class},
+                                new Class[] {Map.class},
+                                new LogicalType[] {new VarCharType(20), new TimestampType()},
+                                new MapType(new VarCharType(99), new TimestampType())));
     }
 
     @Test
     public void testRowType() {
-        testAll(
-                new RowType(
-                        Arrays.asList(
-                                new RowType.RowField("a", new VarCharType(), "Someone's desc."),
-                                new RowType.RowField("b`", new TimestampType()))),
-                "ROW<`a` VARCHAR(1) 'Someone''s desc.', `b``` TIMESTAMP(6)>",
-                "ROW<`a` VARCHAR(1) '...', `b``` TIMESTAMP(6)>",
-                new Class[] {Row.class},
-                new Class[] {Row.class},
-                new LogicalType[] {new VarCharType(), new TimestampType()},
-                new RowType(
-                        Arrays.asList(
-                                new RowType.RowField("a", new VarCharType(), "Different desc."),
-                                new RowType.RowField("b`", new TimestampType()))));
-
-        try {
-            new RowType(
-                    Arrays.asList(
-                            new RowType.RowField("b", new VarCharType()),
-                            new RowType.RowField("b", new VarCharType()),
-                            new RowType.RowField("a", new VarCharType()),
-                            new RowType.RowField("a", new TimestampType())));
-            fail("Not unique fields expected.");
-        } catch (ValidationException e) {
-            // ok
-        }
-
-        try {
-            new RowType(Collections.singletonList(new RowType.RowField("", new VarCharType())));
-            fail("Invalid name.");
-        } catch (ValidationException e) {
-            // ok
-        }
+        assertThat(
+                        new RowType(
+                                Arrays.asList(
+                                        new RowType.RowField(
+                                                "a", new VarCharType(), "Someone's desc."),
+                                        new RowType.RowField("b`", new TimestampType()))))
+                .satisfies(
+                        baseAssertions(
+                                "ROW<`a` VARCHAR(1) 'Someone''s desc.', `b``` TIMESTAMP(6)>",
+                                "ROW<`a` VARCHAR(1) '...', `b``` TIMESTAMP(6)>",
+                                new Class[] {Row.class},
+                                new Class[] {Row.class},
+                                new LogicalType[] {new VarCharType(), new TimestampType()},
+                                new RowType(
+                                        Arrays.asList(
+                                                new RowType.RowField(
+                                                        "a", new VarCharType(), "Different desc."),
+                                                new RowType.RowField("b`", new TimestampType())))));
+
+        assertThatThrownBy(
+                        () ->
+                                new RowType(
+                                        Arrays.asList(
+                                                new RowType.RowField("b", new VarCharType()),
+                                                new RowType.RowField("b", new VarCharType()),
+                                                new RowType.RowField("a", new VarCharType()),
+                                                new RowType.RowField("a", new TimestampType()))))
+                .isInstanceOf(ValidationException.class);
+
+        assertThatThrownBy(
+                        () ->
+                                new RowType(
+                                        Collections.singletonList(
+                                                new RowType.RowField("", new VarCharType()))))
+                .isInstanceOf(ValidationException.class);
     }
 
     @Test
     public void testDistinctType() {
-        testAll(
-                createDistinctType("Money"),
-                "`cat`.`db`.`Money`",
-                "`cat`.`db`.`Money`",
-                new Class[] {BigDecimal.class},
-                new Class[] {BigDecimal.class},
-                new LogicalType[] {new DecimalType(10, 2)},
-                createDistinctType("Monetary"));
+        assertThat(createDistinctType("Money"))
+                .satisfies(
+                        baseAssertions(
+                                "`cat`.`db`.`Money`",
+                                "`cat`.`db`.`Money`",
+                                new Class[] {BigDecimal.class},
+                                new Class[] {BigDecimal.class},
+                                new LogicalType[] {new DecimalType(10, 2)},
+                                createDistinctType("Monetary")));
     }
 
     @Test
     public void testStructuredType() {
-        testAll(
-                createUserType(true, true),
-                "`cat`.`db`.`User`",
-                "`cat`.`db`.`User`",
-                new Class[] {Row.class, User.class},
-                new Class[] {Row.class, Human.class, User.class},
-                new LogicalType[] {UDT_NAME_TYPE, UDT_SETTING_TYPE, UDT_TIMESTAMP_TYPE},
-                createUserType(true, false));
-
-        testConversions(
-                createHumanType(false),
-                new Class[] {Row.class, Human.class, User.class}, // every User is Human
-                new Class[] {Row.class, Human.class});
+        assertThat(createUserType(true, true))
+                .satisfies(
+                        baseAssertions(
+                                "`cat`.`db`.`User`",
+                                "`cat`.`db`.`User`",
+                                new Class[] {Row.class, User.class},
+                                new Class[] {Row.class, Human.class, User.class},
+                                new LogicalType[] {
+                                    UDT_NAME_TYPE, UDT_SETTING_TYPE, UDT_TIMESTAMP_TYPE
+                                },
+                                createUserType(true, false)));
+
+        assertThat(createHumanType(false))
+                .satisfies(
+                        conversions(
+                                new Class[] {
+                                    Row.class, Human.class, User.class // every User is Human
+                                },
+                                new Class[] {Row.class, Human.class}));
 
         // not every Human is User
-        assertFalse(createUserType(true, true).supportsInputConversion(Human.class));
+        assertThat(createUserType(true, true)).doesNotSupportInputConversion(Human.class);
 
         // User is not implementing SpecialHuman
-        assertFalse(createHumanType(true).supportsInputConversion(User.class));
+        assertThat(createHumanType(true)).doesNotSupportInputConversion(User.class);
     }
 
     @Test
     public void testNullType() {
-        final NullType nullType = new NullType();
-
-        testEquality(nullType, new TimeType());
-
-        testJavaSerializability(nullType);
-
-        testStringSerializability(nullType, "NULL");
-
-        testStringSummary(nullType, "NULL");
-
-        assertTrue(nullType.supportsInputConversion(Object.class));
-
-        assertTrue(nullType.supportsOutputConversion(Object.class));
-
-        assertTrue(nullType.supportsOutputConversion(Integer.class));
-
-        assertFalse(nullType.supportsOutputConversion(int.class));
+        assertThat(new NullType())
+                .isJavaSerializable()
+                .satisfies(nonEqualityCheckWithOtherType(new TimeType()))
+                .hasSerializableString("NULL")
+                .hasSummaryString("NULL")
+                .supportsInputConversion(Object.class)
+                .supportsOutputConversion(Object.class)
+                .supportsOutputConversion(Integer.class)
+                .doesNotSupportOutputConversion(int.class);
     }
 
     @Test
-    public void testTypeInformationRawType() {
+    public void testTypeInformationRawType() throws Exception {
         final TypeInformationRawType<?> rawType =
                 new TypeInformationRawType<>(Types.TUPLE(Types.STRING, Types.INT));
 
-        testEquality(rawType, new TypeInformationRawType<>(Types.TUPLE(Types.STRING, Types.LONG)));
-
-        testStringSummary(rawType, "RAW('org.apache.flink.api.java.tuple.Tuple2', ?)");
-
-        testNullability(rawType);
-
-        testJavaSerializability(rawType);
-
-        testConversions(rawType, new Class[] {Tuple2.class}, new Class[] {Tuple.class});
-
-        testInvalidStringSerializability(rawType);
+        assertThat(rawType)
+                .satisfies(
+                        nonEqualityCheckWithOtherType(
+                                new TypeInformationRawType<>(
+                                        Types.TUPLE(Types.STRING, Types.LONG))))
+                .satisfies(LogicalTypesTest::nullability)
+                .isJavaSerializable()
+                .hasSummaryString("RAW('org.apache.flink.api.java.tuple.Tuple2', ?)")
+                .hasNoSerializableString()
+                .satisfies(conversions(new Class[] {Tuple2.class}, new Class[] {Tuple.class}));
     }
 
     @Test
@@ -572,39 +622,40 @@ public class LogicalTypesTest {
                         + "ldXRpbHMucnVudGltZS5rcnlvLlNlcmlhbGl6ZXJzJER1bW15QXZyb0tyeW9TZXJpYWxpemVyQ2xhc3"
                         + "MAAATyxpo9cAAAAAAAAATyxpo9cAAAAAA=";
 
-        testAll(
-                rawType,
-                "RAW('" + className + "', '" + serializerString + "')",
-                "RAW('org.apache.flink.table.types.LogicalTypesTest$Human', '...')",
-                new Class[] {Human.class, User.class}, // every User is Human
-                new Class[] {Human.class},
-                new LogicalType[] {},
-                new RawType<>(User.class, new KryoSerializer<>(User.class, new ExecutionConfig())));
+        assertThat(rawType)
+                .satisfies(
+                        baseAssertions(
+                                "RAW('" + className + "', '" + serializerString + "')",
+                                "RAW('org.apache.flink.table.types.LogicalTypesTest$Human', '...')",
+                                new Class[] {Human.class, User.class}, // every User is Human
+                                new Class[] {Human.class},
+                                new LogicalType[] {},
+                                new RawType<>(
+                                        User.class,
+                                        new KryoSerializer<>(User.class, new ExecutionConfig()))));
 
         assertThat(
-                RawType.restore(
-                        LogicalTypesTest.class.getClassLoader(), className, serializerString),
-                equalTo(rawType));
+                        RawType.restore(
+                                LogicalTypesTest.class.getClassLoader(),
+                                className,
+                                serializerString))
+                .isEqualTo(rawType);
     }
 
     @Test
     public void testSymbolType() {
         final SymbolType<?> symbolType = new SymbolType<>(TimeIntervalUnit.class);
 
-        testEquality(symbolType, new SymbolType<>(TimePointUnit.class));
-
-        testStringSummary(symbolType, "SYMBOL('" + TimeIntervalUnit.class.getName() + "')");
-
-        testNullability(symbolType);
-
-        testJavaSerializability(symbolType);
-
-        testConversions(
-                symbolType,
-                new Class[] {TimeIntervalUnit.class},
-                new Class[] {TimeIntervalUnit.class});
-
-        testInvalidStringSerializability(symbolType);
+        assertThat(symbolType)
+                .satisfies(nonEqualityCheckWithOtherType(new SymbolType<>(TimePointUnit.class)))
+                .hasSummaryString("SYMBOL('" + TimeIntervalUnit.class.getName() + "')")
+                .satisfies(LogicalTypesTest::nullability)
+                .isJavaSerializable()
+                .satisfies(
+                        conversions(
+                                new Class[] {TimeIntervalUnit.class},
+                                new Class[] {TimeIntervalUnit.class}))
+                .hasNoSerializableString();
     }
 
     @Test
@@ -613,12 +664,12 @@ public class LogicalTypesTest {
                 new UnresolvedUserDefinedType(
                         UnresolvedIdentifier.of("catalog", "database", "Type"));
 
-        testEquality(
-                unresolvedType,
-                new UnresolvedUserDefinedType(
-                        UnresolvedIdentifier.of("different", "database", "Type")));
-
-        testStringSummary(unresolvedType, "`catalog`.`database`.`Type`");
+        assertThat(unresolvedType)
+                .satisfies(
+                        nonEqualityCheckWithOtherType(
+                                new UnresolvedUserDefinedType(
+                                        UnresolvedIdentifier.of("different", "database", "Type"))))
+                .hasSummaryString("`catalog`.`database`.`Type`");
     }
 
     @Test
@@ -629,147 +680,103 @@ public class LogicalTypesTest {
         final VarBinaryType varBinaryType = VarBinaryType.ofEmptyLiteral();
 
         // make the types nullable for testing
-        testEquality(charType.copy(true), new CharType(1));
-        testEquality(varcharType.copy(true), new VarCharType(1));
-        testEquality(binaryType.copy(true), new BinaryType(1));
-        testEquality(varBinaryType.copy(true), new VarBinaryType(1));
+        assertThat(charType.copy(true)).satisfies(nonEqualityCheckWithOtherType(new CharType(1)));
+        assertThat(varcharType.copy(true))
+                .satisfies(nonEqualityCheckWithOtherType(new VarCharType(1)));
+        assertThat(binaryType.copy(true))
+                .satisfies(nonEqualityCheckWithOtherType(new BinaryType(1)));
+        assertThat(varBinaryType.copy(true))
+                .satisfies(nonEqualityCheckWithOtherType(new VarBinaryType(1)));
 
-        testStringSummary(charType, "CHAR(0) NOT NULL");
-        testStringSummary(varcharType, "VARCHAR(0) NOT NULL");
-        testStringSummary(binaryType, "BINARY(0) NOT NULL");
-        testStringSummary(varBinaryType, "VARBINARY(0) NOT NULL");
+        assertThat(charType).hasSummaryString("CHAR(0) NOT NULL");
+        assertThat(varcharType).hasSummaryString("VARCHAR(0) NOT NULL");
+        assertThat(binaryType).hasSummaryString("BINARY(0) NOT NULL");
+        assertThat(varBinaryType).hasSummaryString("VARBINARY(0) NOT NULL");
 
-        testInvalidStringSerializability(charType);
-        testInvalidStringSerializability(varcharType);
-        testInvalidStringSerializability(binaryType);
-        testInvalidStringSerializability(varBinaryType);
+        assertThat(charType).hasNoSerializableString();
+        assertThat(varcharType).hasNoSerializableString();
+        assertThat(binaryType).hasNoSerializableString();
+        assertThat(varBinaryType).hasNoSerializableString();
     }
 
     @Test
     public void testUnregisteredStructuredType() {
         final StructuredType structuredType = createUserType(false, true);
 
-        testEquality(structuredType, createUserType(false, false));
-
-        testNullability(structuredType);
-
-        testJavaSerializability(structuredType);
-
-        testInvalidStringSerializability(structuredType);
-
-        testStringSummary(
-                structuredType,
-                String.format(
-                        "*%s<`name` VARCHAR(1) '...', `setting` INT, `timestamp` TIMESTAMP(6)>*",
-                        User.class.getName()));
-
-        testConversions(
-                structuredType,
-                new Class[] {Row.class, User.class},
-                new Class[] {Row.class, Human.class, User.class});
-
-        testChildren(
-                structuredType,
-                new LogicalType[] {UDT_NAME_TYPE, UDT_SETTING_TYPE, UDT_TIMESTAMP_TYPE});
+        assertThat(structuredType)
+                .satisfies(nonEqualityCheckWithOtherType(createUserType(false, false)))
+                .satisfies(LogicalTypesTest::nullability)
+                .isJavaSerializable()
+                .hasNoSerializableString()
+                .hasSummaryString(
+                        String.format(
+                                "*%s<`name` VARCHAR(1) '...', `setting` INT, `timestamp` TIMESTAMP(6)>*",
+                                User.class.getName()))
+                .satisfies(
+                        conversions(
+                                new Class[] {Row.class, User.class},
+                                new Class[] {Row.class, Human.class, User.class}))
+                .hasExactlyChildren(UDT_NAME_TYPE, UDT_SETTING_TYPE, UDT_TIMESTAMP_TYPE);
     }
 
     // --------------------------------------------------------------------------------------------
 
-    private static void testAll(
-            LogicalType nullableType,
+    private static ThrowingConsumer<LogicalType> baseAssertions(
             String serializableString,
             String summaryString,
             Class<?>[] supportedInputClasses,
             Class<?>[] supportedOutputClasses,
             LogicalType[] children,
             LogicalType otherType) {
+        return nullableType ->
+                assertThat(nullableType)
+                        .satisfies(nonEqualityCheckWithOtherType(otherType))
+                        .satisfies(LogicalTypesTest::nullability)
+                        .isJavaSerializable()
+                        .hasSerializableString(serializableString)
+                        .hasSummaryString(summaryString)
+                        .satisfies(conversions(supportedInputClasses, supportedOutputClasses))
+                        .hasExactlyChildren(children);
+    }
+
+    private static ThrowingConsumer<LogicalType> nonEqualityCheckWithOtherType(
+            LogicalType otherType) {
+        return nullableType -> {
+            assertThat(nullableType)
+                    .isNullable()
+                    .isEqualTo(nullableType)
+                    .isEqualTo(nullableType.copy())
+                    .isNotEqualTo(otherType);
 
-        testEquality(nullableType, otherType);
-
-        testNullability(nullableType);
-
-        testJavaSerializability(nullableType);
-
-        testStringSerializability(nullableType, serializableString);
-
-        testStringSummary(nullableType, summaryString);
-
-        testConversions(nullableType, supportedInputClasses, supportedOutputClasses);
-
-        testChildren(nullableType, children);
-    }
-
-    private static void testEquality(LogicalType nullableType, LogicalType otherType) {
-        assertTrue(nullableType.isNullable());
-
-        assertEquals(nullableType, nullableType);
-        assertEquals(nullableType.hashCode(), nullableType.hashCode());
-
-        assertEquals(nullableType, nullableType.copy());
-
-        assertNotEquals(nullableType, otherType);
-        assertNotEquals(nullableType.hashCode(), otherType.hashCode());
+            assertThat(nullableType.hashCode())
+                    .isEqualTo(nullableType.hashCode())
+                    .isNotEqualTo(otherType.hashCode());
+        };
     }
 
-    private static void testNullability(LogicalType nullableType) {
+    private static void nullability(LogicalType nullableType) {
         final LogicalType notNullInstance = nullableType.copy(false);
-
-        assertNotEquals(nullableType, notNullInstance);
-
-        assertFalse(notNullInstance.isNullable());
-    }
-
-    private static void testJavaSerializability(LogicalType serializableType) {
-        try {
-            final LogicalType deserializedInstance =
-                    InstantiationUtil.deserializeObject(
-                            InstantiationUtil.serializeObject(serializableType),
-                            LogicalTypesTest.class.getClassLoader());
-
-            assertEquals(serializableType, deserializedInstance);
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static void testStringSerializability(
-            LogicalType serializableType, String serializableString) {
-        assertEquals(serializableString, serializableType.asSerializableString());
-    }
-
-    private static void testInvalidStringSerializability(LogicalType nonSerializableType) {
-        try {
-            final String serializedString = nonSerializableType.asSerializableString();
-            fail("No serializablility expected: " + serializedString);
-        } catch (TableException e) {
-            // ok
-        }
-    }
-
-    private static void testStringSummary(LogicalType type, String summaryString) {
-        assertEquals(summaryString, type.asSummaryString());
-    }
-
-    private static void testConversions(LogicalType type, Class<?>[] inputs, Class<?>[] outputs) {
-        for (Class<?> clazz : inputs) {
-            assertTrue(type.supportsInputConversion(clazz));
-        }
-
-        for (Class<?> clazz : outputs) {
-            assertTrue(type.supportsOutputConversion(clazz));
-        }
-
-        assertTrue(type.supportsInputConversion(type.getDefaultConversion()));
-
-        assertTrue(type.supportsOutputConversion(type.getDefaultConversion()));
-
-        assertFalse(type.supportsOutputConversion(LogicalTypesTest.class));
-
-        assertFalse(type.supportsInputConversion(LogicalTypesTest.class));
-    }
-
-    private static void testChildren(LogicalType type, LogicalType[] children) {
-        assertEquals(Arrays.asList(children), type.getChildren());
+        assertThat(notNullInstance).isNotNullable();
+        assertThat(nullableType).isNotEqualTo(notNullInstance);
+    }
+
+    private static ThrowingConsumer<LogicalType> conversions(
+            Class<?>[] inputs, Class<?>[] outputs) {
+        return type -> {
+            assertThat(type)
+                    .supportsInputConversion(type.getDefaultConversion())
+                    .supportsOutputConversion(type.getDefaultConversion())
+                    .doesNotSupportInputConversion(LogicalTypesTest.class)
+                    .doesNotSupportOutputConversion(LogicalTypesTest.class);
+
+            for (Class<?> clazz : inputs) {
+                assertThat(type).supportsInputConversion(clazz);
+            }
+
+            for (Class<?> clazz : outputs) {
+                assertThat(type).supportsOutputConversion(clazz);
+            }
+        };
     }
 
     private DistinctType createDistinctType(String typeName) {
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeInfoDataTypeConverterTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeInfoDataTypeConverterTest.java
index 0cafb01b85e..8eedd97d215 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeInfoDataTypeConverterTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeInfoDataTypeConverterTest.java
@@ -40,8 +40,7 @@ import java.util.List;
 import java.util.Optional;
 
 import static org.apache.flink.table.types.utils.DataTypeFactoryMock.dummyRaw;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link TypeInfoDataTypeConverter}. */
 @RunWith(Parameterized.class)
@@ -123,9 +122,8 @@ public class TypeInfoDataTypeConverterTest {
 
     @Test
     public void testConversion() {
-        final DataType dataType =
-                TypeInfoDataTypeConverter.toDataType(testSpec.typeFactory, testSpec.typeInfo);
-        assertThat(dataType, equalTo(testSpec.expectedDataType));
+        assertThat(TypeInfoDataTypeConverter.toDataType(testSpec.typeFactory, testSpec.typeInfo))
+                .isEqualTo(testSpec.expectedDataType);
     }
 
     // --------------------------------------------------------------------------------------------
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeTestingUtils.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeTestingUtils.java
deleted file mode 100644
index 1932cd739a3..00000000000
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/TypeTestingUtils.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.table.types;
-
-import org.apache.flink.table.types.logical.LogicalType;
-
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.FeatureMatcher;
-import org.hamcrest.Matcher;
-
-/** Utilities for testing types. */
-public class TypeTestingUtils {
-
-    public static Matcher<DataType> hasLogicalType(LogicalType logicalType) {
-        return new FeatureMatcher<DataType, LogicalType>(
-                CoreMatchers.equalTo(logicalType),
-                "logical type of the data type",
-                "logical type") {
-
-            @Override
-            protected LogicalType featureValueOf(DataType actual) {
-                return actual.getLogicalType();
-            }
-        };
-    }
-
-    public static Matcher<DataType> hasConversionClass(Class<?> clazz) {
-        return new FeatureMatcher<DataType, Class<?>>(
-                CoreMatchers.equalTo(clazz),
-                "conversion class of the data type",
-                "conversion class") {
-
-            @Override
-            protected Class<?> featureValueOf(DataType actual) {
-                return actual.getConversionClass();
-            }
-        };
-    }
-
-    public static Matcher<DataType> hasNullability(boolean isNullable) {
-        return new FeatureMatcher<DataType, Boolean>(
-                CoreMatchers.equalTo(isNullable), "nullability of the data type", "nullability") {
-
-            @Override
-            protected Boolean featureValueOf(DataType actual) {
-                return actual.getLogicalType().isNullable();
-            }
-        };
-    }
-}
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ValueDataTypeConverterTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ValueDataTypeConverterTest.java
index ae375992a94..612e5355124 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ValueDataTypeConverterTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/ValueDataTypeConverterTest.java
@@ -44,9 +44,8 @@ import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
 import java.util.Arrays;
 import java.util.List;
-import java.util.Optional;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link ValueDataTypeConverter}. */
 @RunWith(Parameterized.class)
@@ -133,8 +132,10 @@ public class ValueDataTypeConverterTest {
 
     @Test
     public void testClassToDataTypeConversion() {
-        assertEquals(
-                Optional.ofNullable(dataType).map(DataType::notNull),
-                ValueDataTypeConverter.extractDataType(value));
+        if (dataType == null) {
+            assertThat(ValueDataTypeConverter.extractDataType(value)).isEmpty();
+        } else {
+            assertThat(ValueDataTypeConverter.extractDataType(value)).contains(dataType.notNull());
+        }
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java
index d34fe9e0dbb..f023a504eed 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java
@@ -67,9 +67,8 @@ import java.util.Optional;
 import java.util.function.Function;
 
 import static org.apache.flink.core.testutils.FlinkMatchers.containsCause;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
 import static org.apache.flink.table.types.utils.DataTypeFactoryMock.dummyRaw;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
 
 /** Tests for {@link DataTypeExtractor}. */
 @RunWith(Parameterized.class)
@@ -604,7 +603,7 @@ public class DataTypeExtractorTest {
     static void runExtraction(TestSpec testSpec) {
         final DataType dataType = testSpec.extractor.apply(testSpec.typeFactory);
         if (testSpec.expectedDataType != null) {
-            assertThat(dataType, equalTo(testSpec.expectedDataType));
+            assertThat(dataType).isEqualTo(testSpec.expectedDataType);
         }
     }
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java
index 527bedac2d2..d72b51440dc 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java
@@ -57,8 +57,7 @@ import java.util.Optional;
 import java.util.function.Supplier;
 
 import static org.apache.flink.core.testutils.FlinkMatchers.containsCause;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link TypeInferenceExtractor}. */
 @RunWith(Parameterized.class)
@@ -446,38 +445,33 @@ public class TypeInferenceExtractorTest {
     @Test
     public void testArgumentNames() {
         if (testSpec.expectedArgumentNames != null) {
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getNamedArguments(),
-                    equalTo(Optional.of(testSpec.expectedArgumentNames)));
+            assertThat(testSpec.typeInferenceExtraction.get().getNamedArguments())
+                    .isEqualTo(Optional.of(testSpec.expectedArgumentNames));
         } else if (testSpec.expectedErrorMessage == null) {
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getNamedArguments(),
-                    equalTo(Optional.empty()));
+            assertThat(testSpec.typeInferenceExtraction.get().getNamedArguments())
+                    .isEqualTo(Optional.empty());
         }
     }
 
     @Test
     public void testArgumentTypes() {
         if (testSpec.expectedArgumentTypes != null) {
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getTypedArguments(),
-                    equalTo(Optional.of(testSpec.expectedArgumentTypes)));
+            assertThat(testSpec.typeInferenceExtraction.get().getTypedArguments())
+                    .isEqualTo(Optional.of(testSpec.expectedArgumentTypes));
         } else if (testSpec.expectedErrorMessage == null) {
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getTypedArguments(),
-                    equalTo(Optional.empty()));
+            assertThat(testSpec.typeInferenceExtraction.get().getTypedArguments())
+                    .isEqualTo(Optional.empty());
         }
     }
 
     @Test
     public void testInputTypeStrategy() {
         if (!testSpec.expectedOutputStrategies.isEmpty()) {
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getInputTypeStrategy(),
-                    equalTo(
+            assertThat(testSpec.typeInferenceExtraction.get().getInputTypeStrategy())
+                    .isEqualTo(
                             testSpec.expectedOutputStrategies.keySet().stream()
                                     .reduce(InputTypeStrategies::or)
-                                    .orElseThrow(AssertionError::new)));
+                                    .orElseThrow(AssertionError::new));
         }
     }
 
@@ -485,20 +479,21 @@ public class TypeInferenceExtractorTest {
     public void testAccumulatorTypeStrategy() {
         if (!testSpec.expectedAccumulatorStrategies.isEmpty()) {
             assertThat(
-                    testSpec.typeInferenceExtraction.get().getAccumulatorTypeStrategy().isPresent(),
-                    equalTo(true));
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getAccumulatorTypeStrategy().get(),
-                    equalTo(TypeStrategies.mapping(testSpec.expectedAccumulatorStrategies)));
+                            testSpec.typeInferenceExtraction
+                                    .get()
+                                    .getAccumulatorTypeStrategy()
+                                    .isPresent())
+                    .isEqualTo(true);
+            assertThat(testSpec.typeInferenceExtraction.get().getAccumulatorTypeStrategy().get())
+                    .isEqualTo(TypeStrategies.mapping(testSpec.expectedAccumulatorStrategies));
         }
     }
 
     @Test
     public void testOutputTypeStrategy() {
         if (!testSpec.expectedOutputStrategies.isEmpty()) {
-            assertThat(
-                    testSpec.typeInferenceExtraction.get().getOutputTypeStrategy(),
-                    equalTo(TypeStrategies.mapping(testSpec.expectedOutputStrategies)));
+            assertThat(testSpec.typeInferenceExtraction.get().getOutputTypeStrategy())
+                    .isEqualTo(TypeStrategies.mapping(testSpec.expectedOutputStrategies));
         }
     }
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTestBase.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTestBase.java
index 4f3bff80efa..527d3105496 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTestBase.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTestBase.java
@@ -27,9 +27,7 @@ import org.apache.flink.table.types.inference.utils.CallContextMock;
 import org.apache.flink.table.types.inference.utils.FunctionDefinitionMock;
 import org.apache.flink.table.types.utils.DataTypeFactoryMock;
 
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -42,9 +40,9 @@ import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
-import static org.apache.flink.core.testutils.FlinkMatchers.containsCause;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertThat;
+import static org.apache.flink.core.testutils.FlinkAssertions.anyCauseMatches;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 /** Base class for testing {@link InputTypeStrategy}. */
 @RunWith(Parameterized.class)
@@ -52,23 +50,20 @@ public abstract class InputTypeStrategiesTestBase {
 
     @Parameterized.Parameter public TestSpec testSpec;
 
-    @Rule public ExpectedException thrown = ExpectedException.none();
-
     @Test
     public void testStrategy() {
         if (testSpec.expectedSignature != null) {
-            assertThat(generateSignature(), equalTo(testSpec.expectedSignature));
-        }
-        if (testSpec.expectedErrorMessage != null) {
-            thrown.expect(ValidationException.class);
-            thrown.expectCause(
-                    containsCause(new ValidationException(testSpec.expectedErrorMessage)));
+            assertThat(generateSignature()).isEqualTo(testSpec.expectedSignature);
         }
         for (List<DataType> actualArgumentTypes : testSpec.actualArgumentTypes) {
-            TypeInferenceUtil.Result result = runTypeInference(actualArgumentTypes);
-            if (testSpec.expectedArgumentTypes != null) {
-                assertThat(
-                        result.getExpectedArgumentTypes(), equalTo(testSpec.expectedArgumentTypes));
+            if (testSpec.expectedErrorMessage != null) {
+                assertThatThrownBy(() -> runTypeInference(actualArgumentTypes))
+                        .satisfies(
+                                anyCauseMatches(
+                                        ValidationException.class, testSpec.expectedErrorMessage));
+            } else if (testSpec.expectedArgumentTypes != null) {
+                assertThat(runTypeInference(actualArgumentTypes).getExpectedArgumentTypes())
+                        .isEqualTo(testSpec.expectedArgumentTypes);
             }
         }
     }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/TypeStrategiesTestBase.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/TypeStrategiesTestBase.java
index b3abcd7646b..f29e960193f 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/TypeStrategiesTestBase.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/TypeStrategiesTestBase.java
@@ -24,10 +24,7 @@ import org.apache.flink.table.types.DataType;
 import org.apache.flink.table.types.inference.utils.CallContextMock;
 import org.apache.flink.table.types.inference.utils.FunctionDefinitionMock;
 
-import org.junit.Assert;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameter;
@@ -40,8 +37,9 @@ import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
-import static org.apache.flink.core.testutils.FlinkMatchers.containsCause;
-import static org.hamcrest.CoreMatchers.equalTo;
+import static org.apache.flink.core.testutils.FlinkAssertions.anyCauseMatches;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 /** Base class for tests of {@link TypeStrategies}. */
 @RunWith(Parameterized.class)
@@ -49,18 +47,15 @@ public abstract class TypeStrategiesTestBase {
 
     @Parameter public TestSpec testSpec;
 
-    @Rule public ExpectedException thrown = ExpectedException.none();
-
     @Test
     public void testTypeStrategy() {
         if (testSpec.expectedErrorMessage != null) {
-            thrown.expect(ValidationException.class);
-            thrown.expectCause(
-                    containsCause(new ValidationException(testSpec.expectedErrorMessage)));
-        }
-        TypeInferenceUtil.Result result = runTypeInference();
-        if (testSpec.expectedDataType != null) {
-            Assert.assertThat(result.getOutputDataType(), equalTo(testSpec.expectedDataType));
+            assertThatThrownBy(this::runTypeInference)
+                    .satisfies(
+                            anyCauseMatches(
+                                    ValidationException.class, testSpec.expectedErrorMessage));
+        } else if (testSpec.expectedDataType != null) {
+            assertThat(runTypeInference().getOutputDataType()).isEqualTo(testSpec.expectedDataType);
         }
     }
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeChecksTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeChecksTest.java
index d2c041eae07..5b18afb104b 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeChecksTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeChecksTest.java
@@ -38,8 +38,7 @@ import static org.apache.flink.table.api.DataTypes.FIELD;
 import static org.apache.flink.table.api.DataTypes.INT;
 import static org.apache.flink.table.api.DataTypes.ROW;
 import static org.apache.flink.table.api.DataTypes.STRING;
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link LogicalTypeChecks}. */
 public class LogicalTypeChecksTest {
@@ -48,27 +47,26 @@ public class LogicalTypeChecksTest {
     public void testHasNested() {
         final DataType dataType = ROW(FIELD("f0", INT()), FIELD("f1", STRING()));
         assertThat(
-                LogicalTypeChecks.hasNested(
-                        dataType.getLogicalType(), t -> t.is(LogicalTypeRoot.VARCHAR)),
-                is(true));
+                        LogicalTypeChecks.hasNested(
+                                dataType.getLogicalType(), t -> t.is(LogicalTypeRoot.VARCHAR)))
+                .isTrue();
 
         assertThat(
-                LogicalTypeChecks.hasNested(
-                        dataType.getLogicalType(), t -> t.is(LogicalTypeRoot.ROW)),
-                is(true));
+                        LogicalTypeChecks.hasNested(
+                                dataType.getLogicalType(), t -> t.is(LogicalTypeRoot.ROW)))
+                .isTrue();
 
         assertThat(
-                LogicalTypeChecks.hasNested(
-                        dataType.getLogicalType(), t -> t.is(LogicalTypeRoot.BOOLEAN)),
-                is(false));
+                        LogicalTypeChecks.hasNested(
+                                dataType.getLogicalType(), t -> t.is(LogicalTypeRoot.BOOLEAN)))
+                .isFalse();
     }
 
     @Test
     public void testIsCompositeTypeRowType() {
         DataType dataType = ROW(FIELD("f0", INT()), FIELD("f1", STRING()));
-        boolean isCompositeType = LogicalTypeChecks.isCompositeType(dataType.getLogicalType());
 
-        assertThat(isCompositeType, is(true));
+        assertThat(LogicalTypeChecks.isCompositeType(dataType.getLogicalType())).isTrue();
     }
 
     @Test
@@ -79,18 +77,16 @@ public class LogicalTypeChecksTest {
                                 ObjectIdentifier.of("catalog", "database", "type"),
                                 dataType.getLogicalType())
                         .build();
-        boolean isCompositeType = LogicalTypeChecks.isCompositeType(distinctType);
 
-        assertThat(isCompositeType, is(true));
+        assertThat(LogicalTypeChecks.isCompositeType(distinctType)).isTrue();
     }
 
     @Test
     public void testIsCompositeTypeLegacyCompositeType() {
         DataType dataType =
                 TypeConversions.fromLegacyInfoToDataType(new RowTypeInfo(Types.STRING, Types.INT));
-        boolean isCompositeType = LogicalTypeChecks.isCompositeType(dataType.getLogicalType());
 
-        assertThat(isCompositeType, is(true));
+        assertThat(LogicalTypeChecks.isCompositeType(dataType.getLogicalType())).isTrue();
     }
 
     @Test
@@ -107,38 +103,34 @@ public class LogicalTypeChecksTest {
 
         List<DataType> fieldDataTypes = Arrays.asList(DataTypes.INT(), DataTypes.STRING());
         FieldsDataType dataType = new FieldsDataType(logicalType, fieldDataTypes);
-        boolean isCompositeType = LogicalTypeChecks.isCompositeType(dataType.getLogicalType());
 
-        assertThat(isCompositeType, is(true));
+        assertThat(LogicalTypeChecks.isCompositeType(dataType.getLogicalType())).isTrue();
     }
 
     @Test
     public void testIsCompositeTypeLegacySimpleType() {
         DataType dataType = TypeConversions.fromLegacyInfoToDataType(Types.STRING);
-        boolean isCompositeType = LogicalTypeChecks.isCompositeType(dataType.getLogicalType());
 
-        assertThat(isCompositeType, is(false));
+        assertThat(LogicalTypeChecks.isCompositeType(dataType.getLogicalType())).isFalse();
     }
 
     @Test
     public void testIsCompositeTypeSimpleType() {
         DataType dataType = DataTypes.TIMESTAMP();
-        boolean isCompositeType = LogicalTypeChecks.isCompositeType(dataType.getLogicalType());
 
-        assertThat(isCompositeType, is(false));
+        assertThat(LogicalTypeChecks.isCompositeType(dataType.getLogicalType())).isFalse();
     }
 
     @Test
     public void testFieldNameExtraction() {
         DataType dataType = ROW(FIELD("f0", INT()), FIELD("f1", STRING()));
-        assertThat(
-                LogicalTypeChecks.getFieldNames(dataType.getLogicalType()),
-                is(Arrays.asList("f0", "f1")));
+        assertThat(LogicalTypeChecks.getFieldNames(dataType.getLogicalType()))
+                .containsExactly("f0", "f1");
     }
 
     @Test
     public void testFieldCountExtraction() {
         DataType dataType = ROW(FIELD("f0", INT()), FIELD("f1", STRING()));
-        assertThat(LogicalTypeChecks.getFieldCount(dataType.getLogicalType()), is(2));
+        assertThat(LogicalTypeChecks.getFieldCount(dataType.getLogicalType())).isEqualTo(2);
     }
 }
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeMergingTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeMergingTest.java
index 821713072de..fc9c6f33e9d 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeMergingTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/logical/utils/LogicalTypeMergingTest.java
@@ -25,8 +25,7 @@ import org.junit.Test;
 
 import java.util.List;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.MatcherAssert.assertThat;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
 
 /**
  * Tests for {@link LogicalTypeMerging} for finding the result decimal type for the various
@@ -40,67 +39,72 @@ public class LogicalTypeMergingTest {
 
     @Test
     public void testFindDivisionDecimalType() {
-        assertThat(
-                LogicalTypeMerging.findDivisionDecimalType(32, 8, 38, 8), equalTo(decimal(38, 6)));
-        assertThat(
-                LogicalTypeMerging.findDivisionDecimalType(30, 20, 30, 20),
-                equalTo(decimal(38, 8)));
+        assertThat(LogicalTypeMerging.findDivisionDecimalType(32, 8, 38, 8))
+                .hasPrecisionAndScale(38, 6);
+        assertThat(LogicalTypeMerging.findDivisionDecimalType(30, 20, 30, 20))
+                .hasPrecisionAndScale(38, 8);
     }
 
     @Test
     public void testFindMultiplicationDecimalType() {
-        assertThat(
-                LogicalTypeMerging.findMultiplicationDecimalType(30, 10, 30, 10),
-                equalTo(decimal(38, 6)));
-        assertThat(
-                LogicalTypeMerging.findMultiplicationDecimalType(30, 20, 30, 20),
-                equalTo(decimal(38, 17)));
-        assertThat(
-                LogicalTypeMerging.findMultiplicationDecimalType(38, 2, 38, 3),
-                equalTo(decimal(38, 5)));
+        assertThat(LogicalTypeMerging.findMultiplicationDecimalType(30, 10, 30, 10))
+                .hasPrecisionAndScale(38, 6);
+        assertThat(LogicalTypeMerging.findMultiplicationDecimalType(30, 20, 30, 20))
+                .hasPrecisionAndScale(38, 17);
+        assertThat(LogicalTypeMerging.findMultiplicationDecimalType(38, 2, 38, 3))
+                .hasPrecisionAndScale(38, 5);
     }
 
     @Test
     public void testFindModuloDecimalType() {
-        assertThat(
-                LogicalTypeMerging.findModuloDecimalType(30, 10, 30, 10), equalTo(decimal(30, 10)));
-        assertThat(
-                LogicalTypeMerging.findModuloDecimalType(30, 20, 25, 20), equalTo(decimal(25, 20)));
-        assertThat(
-                LogicalTypeMerging.findModuloDecimalType(10, 10, 10, 10), equalTo(decimal(10, 10)));
+        assertThat(LogicalTypeMerging.findModuloDecimalType(30, 10, 30, 10))
+                .hasPrecisionAndScale(30, 10);
+        assertThat(LogicalTypeMerging.findModuloDecimalType(30, 20, 25, 20))
+                .hasPrecisionAndScale(25, 20);
+        assertThat(LogicalTypeMerging.findModuloDecimalType(10, 10, 10, 10))
+                .hasPrecisionAndScale(10, 10);
     }
 
     @Test
     public void testFindAdditionDecimalType() {
-        assertThat(
-                LogicalTypeMerging.findAdditionDecimalType(38, 8, 32, 8), equalTo(decimal(38, 7)));
-        assertThat(
-                LogicalTypeMerging.findAdditionDecimalType(32, 8, 38, 8), equalTo(decimal(38, 7)));
-        assertThat(
-                LogicalTypeMerging.findAdditionDecimalType(30, 20, 28, 20),
-                equalTo(decimal(31, 20)));
-        assertThat(
-                LogicalTypeMerging.findAdditionDecimalType(10, 10, 10, 10),
-                equalTo(decimal(11, 10)));
-        assertThat(
-                LogicalTypeMerging.findAdditionDecimalType(38, 5, 38, 4), equalTo(decimal(38, 5)));
+        assertThat(LogicalTypeMerging.findAdditionDecimalType(38, 8, 32, 8))
+                .hasPrecisionAndScale(38, 7);
+        assertThat(LogicalTypeMerging.findAdditionDecimalType(32, 8, 38, 8))
+                .hasPrecisionAndScale(38, 7);
+        assertThat(LogicalTypeMerging.findAdditionDecimalType(30, 20, 28, 20))
+                .hasPrecisionAndScale(31, 20);
+        assertThat(LogicalTypeMerging.findAdditionDecimalType(10, 10, 10, 10))
+                .hasPrecisionAndScale(11, 10);
+        assertThat(LogicalTypeMerging.findAdditionDecimalType(38, 5, 38, 4))
+                .hasPrecisionAndScale(38, 5);
     }
 
     @Test
     public void testFindRoundingDecimalType() {
-        assertThat(LogicalTypeMerging.findRoundDecimalType(32, 8, 5), equalTo(decimal(30, 5)));
-        assertThat(LogicalTypeMerging.findRoundDecimalType(32, 8, 10), equalTo(decimal(32, 8)));
-        assertThat(LogicalTypeMerging.findRoundDecimalType(30, 20, 18), equalTo(decimal(29, 18)));
-        assertThat(LogicalTypeMerging.findRoundDecimalType(10, 10, 2), equalTo(decimal(3, 2)));
+        assertThat(LogicalTypeMerging.findRoundDecimalType(32, 8, 5)).hasPrecisionAndScale(30, 5);
+        assertThat(LogicalTypeMerging.findRoundDecimalType(32, 8, 10)).hasPrecisionAndScale(32, 8);
+        assertThat(LogicalTypeMerging.findRoundDecimalType(30, 20, 18))
+                .hasPrecisionAndScale(29, 18);
+        assertThat(LogicalTypeMerging.findRoundDecimalType(10, 10, 2)).hasPrecisionAndScale(3, 2);
     }
 
     @Test
     public void testFindAvgAggType() {
-        assertThat(LogicalTypeMerging.findAvgAggType(decimal(38, 20)), equalTo(decimal(38, 20)));
-        assertThat(LogicalTypeMerging.findAvgAggType(decimal(38, 2)), equalTo(decimal(38, 6)));
-        assertThat(LogicalTypeMerging.findAvgAggType(decimal(38, 8)), equalTo(decimal(38, 8)));
-        assertThat(LogicalTypeMerging.findAvgAggType(decimal(30, 20)), equalTo(decimal(38, 20)));
-        assertThat(LogicalTypeMerging.findAvgAggType(decimal(10, 10)), equalTo(decimal(38, 10)));
+        assertThat(LogicalTypeMerging.findAvgAggType(decimal(38, 20)))
+                .isDecimalType()
+                .hasPrecisionAndScale(38, 20);
+        assertThat(LogicalTypeMerging.findAvgAggType(decimal(38, 2)))
+                .isDecimalType()
+                .hasPrecisionAndScale(38, 6);
+        assertThat(LogicalTypeMerging.findAvgAggType(decimal(38, 8)))
+                .isDecimalType()
+                .hasPrecisionAndScale(38, 8);
+        assertThat(LogicalTypeMerging.findAvgAggType(decimal(30, 20)))
+                .isDecimalType()
+                .hasPrecisionAndScale(38, 20);
+        assertThat(LogicalTypeMerging.findAvgAggType(decimal(10, 10)))
+                .isDecimalType()
+                .hasPrecisionAndScale(38, 10);
     }
 
     private static final DecimalType decimal(int precision, int scale) {
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeFactoryMock.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeFactoryMock.java
index c48d9078fea..b00b58f3bac 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeFactoryMock.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeFactoryMock.java
@@ -33,7 +33,7 @@ import org.apache.flink.table.types.logical.utils.LogicalTypeParser;
 
 import java.util.Optional;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** {@link DataTypeFactory} mock for testing purposes. */
 public class DataTypeFactoryMock implements DataTypeFactory {
@@ -64,7 +64,7 @@ public class DataTypeFactoryMock implements DataTypeFactory {
 
     @Override
     public <T> DataType createDataType(Class<T> clazz) {
-        expectedClass.ifPresent(expected -> assertEquals(expected, clazz));
+        expectedClass.ifPresent(expected -> assertThat(expected).isEqualTo(clazz));
         return DataTypeExtractor.extractFromType(this, clazz);
     }
 
@@ -75,7 +75,7 @@ public class DataTypeFactoryMock implements DataTypeFactory {
 
     @Override
     public <T> DataType createRawDataType(Class<T> clazz) {
-        expectedClass.ifPresent(expected -> assertEquals(expected, clazz));
+        expectedClass.ifPresent(expected -> assertThat(expected).isEqualTo(clazz));
         return dataType.orElseThrow(IllegalStateException::new);
     }
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeUtilsTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeUtilsTest.java
index 9c6b6e8f410..4912160f975 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeUtilsTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/utils/DataTypeUtilsTest.java
@@ -26,6 +26,7 @@ import org.apache.flink.table.catalog.Column;
 import org.apache.flink.table.catalog.ObjectIdentifier;
 import org.apache.flink.table.catalog.ResolvedSchema;
 import org.apache.flink.table.data.RowData;
+import org.apache.flink.table.test.DataTypeConditions;
 import org.apache.flink.table.types.DataType;
 import org.apache.flink.table.types.FieldsDataType;
 import org.apache.flink.table.types.logical.DistinctType;
@@ -49,80 +50,64 @@ import static org.apache.flink.table.api.DataTypes.INT;
 import static org.apache.flink.table.api.DataTypes.ROW;
 import static org.apache.flink.table.api.DataTypes.STRING;
 import static org.apache.flink.table.api.DataTypes.TIMESTAMP;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.apache.flink.table.test.TableAssertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 /** Tests for {@link DataTypeUtils}. */
 public class DataTypeUtilsTest {
 
     @Test
     public void testAppendRowFields() {
-        {
-            final DataType row =
-                    ROW(FIELD("a0", BOOLEAN()), FIELD("a1", DOUBLE()), FIELD("a2", INT()));
-
-            final DataType expectedRow =
-                    ROW(
-                            FIELD("a0", BOOLEAN()),
-                            FIELD("a1", DOUBLE()),
-                            FIELD("a2", INT()),
-                            FIELD("a3", BIGINT()),
-                            FIELD("a4", TIMESTAMP(3)));
-
-            assertThat(
-                    DataTypeUtils.appendRowFields(
-                            row, Arrays.asList(FIELD("a3", BIGINT()), FIELD("a4", TIMESTAMP(3)))),
-                    equalTo(expectedRow));
-        }
-
-        {
-            final DataType row = ROW();
-
-            final DataType expectedRow = ROW(FIELD("a", BOOLEAN()), FIELD("b", INT()));
+        assertThat(
+                        DataTypeUtils.appendRowFields(
+                                ROW(
+                                        FIELD("a0", BOOLEAN()),
+                                        FIELD("a1", DOUBLE()),
+                                        FIELD("a2", INT())),
+                                Arrays.asList(FIELD("a3", BIGINT()), FIELD("a4", TIMESTAMP(3)))))
+                .isEqualTo(
+                        ROW(
+                                FIELD("a0", BOOLEAN()),
+                                FIELD("a1", DOUBLE()),
+                                FIELD("a2", INT()),
+                                FIELD("a3", BIGINT()),
+                                FIELD("a4", TIMESTAMP(3))));
 
-            assertThat(
-                    DataTypeUtils.appendRowFields(
-                            row, Arrays.asList(FIELD("a", BOOLEAN()), FIELD("b", INT()))),
-                    equalTo(expectedRow));
-        }
+        assertThat(
+                        DataTypeUtils.appendRowFields(
+                                ROW(), Arrays.asList(FIELD("a", BOOLEAN()), FIELD("b", INT()))))
+                .isEqualTo(ROW(FIELD("a", BOOLEAN()), FIELD("b", INT())));
     }
 
     @Test
     public void testIsInternalClass() {
-        assertTrue(DataTypeUtils.isInternal(DataTypes.INT()));
-        assertTrue(DataTypeUtils.isInternal(DataTypes.INT().notNull().bridgedTo(int.class)));
-        assertTrue(DataTypeUtils.isInternal(DataTypes.ROW().bridgedTo(RowData.class)));
-        assertFalse(DataTypeUtils.isInternal(DataTypes.ROW()));
+        assertThat(DataTypes.INT()).is(DataTypeConditions.INTERNAL);
+        assertThat(DataTypes.INT().notNull().bridgedTo(int.class)).is(DataTypeConditions.INTERNAL);
+        assertThat(DataTypes.ROW().bridgedTo(RowData.class)).is(DataTypeConditions.INTERNAL);
+        assertThat(DataTypes.ROW()).isNot(DataTypeConditions.INTERNAL);
     }
 
     @Test
     public void testFlattenToDataTypes() {
-        assertThat(
-                DataTypeUtils.flattenToDataTypes(INT()), equalTo(Collections.singletonList(INT())));
+        assertThat(DataTypeUtils.flattenToDataTypes(INT())).containsOnly(INT());
 
-        assertThat(
-                DataTypeUtils.flattenToDataTypes(ROW(FIELD("a", INT()), FIELD("b", BOOLEAN()))),
-                equalTo(Arrays.asList(INT(), BOOLEAN())));
+        assertThat(DataTypeUtils.flattenToDataTypes(ROW(FIELD("a", INT()), FIELD("b", BOOLEAN()))))
+                .containsExactly(INT(), BOOLEAN());
     }
 
     @Test
     public void testFlattenToNames() {
-        assertThat(
-                DataTypeUtils.flattenToNames(INT(), Collections.emptyList()),
-                equalTo(Collections.singletonList("f0")));
+        assertThat(DataTypeUtils.flattenToNames(INT(), Collections.emptyList())).containsOnly("f0");
 
-        assertThat(
-                DataTypeUtils.flattenToNames(INT(), Collections.singletonList("f0")),
-                equalTo(Collections.singletonList("f0_0")));
+        assertThat(DataTypeUtils.flattenToNames(INT(), Collections.singletonList("f0")))
+                .containsOnly("f0_0");
 
         assertThat(
-                DataTypeUtils.flattenToNames(
-                        ROW(FIELD("a", INT()), FIELD("b", BOOLEAN())), Collections.emptyList()),
-                equalTo(Arrays.asList("a", "b")));
+                        DataTypeUtils.flattenToNames(
+                                ROW(FIELD("a", INT()), FIELD("b", BOOLEAN())),
+                                Collections.emptyList()))
+                .containsExactly("a", "b");
     }
 
     @Test
@@ -135,15 +120,14 @@ public class DataTypeUtilsTest {
                         FIELD("f3", TIMESTAMP(3)));
         ResolvedSchema schema = DataTypeUtils.expandCompositeTypeToSchema(dataType);
 
-        assertThat(
-                schema,
-                equalTo(
+        assertThat(schema)
+                .isEqualTo(
                         ResolvedSchema.of(
                                 Column.physical("f0", INT()),
                                 Column.physical("f1", STRING()),
                                 Column.physical("f2", TIMESTAMP(5).bridgedTo(Timestamp.class)),
                                 Column.physical(
-                                        "f3", TIMESTAMP(3).bridgedTo(LocalDateTime.class)))));
+                                        "f3", TIMESTAMP(3).bridgedTo(LocalDateTime.class))));
     }
 
     @Test
@@ -153,13 +137,12 @@ public class DataTypeUtilsTest {
                         new TupleTypeInfo<>(Types.STRING, Types.INT, Types.SQL_TIMESTAMP));
         ResolvedSchema schema = DataTypeUtils.expandCompositeTypeToSchema(dataType);
 
-        assertThat(
-                schema,
-                equalTo(
+        assertThat(schema)
+                .isEqualTo(
                         ResolvedSchema.of(
                                 Column.physical("f0", STRING()),
                                 Column.physical("f1", INT()),
-                                Column.physical("f2", TIMESTAMP(3).bridgedTo(Timestamp.class)))));
+                                Column.physical("f2", TIMESTAMP(3).bridgedTo(Timestamp.class))));
     }
 
     @Test
@@ -188,15 +171,14 @@ public class DataTypeUtilsTest {
 
         ResolvedSchema schema = DataTypeUtils.expandCompositeTypeToSchema(dataType);
 
-        assertThat(
-                schema,
-                equalTo(
+        assertThat(schema)
+                .isEqualTo(
                         ResolvedSchema.of(
                                 Column.physical("f0", INT()),
                                 Column.physical("f1", STRING()),
                                 Column.physical("f2", TIMESTAMP(5).bridgedTo(Timestamp.class)),
                                 Column.physical(
-                                        "f3", TIMESTAMP(3).bridgedTo(LocalDateTime.class)))));
+                                        "f3", TIMESTAMP(3).bridgedTo(LocalDateTime.class))));
     }
 
     @Test
@@ -219,15 +201,14 @@ public class DataTypeUtilsTest {
 
         ResolvedSchema schema = DataTypeUtils.expandCompositeTypeToSchema(distinctDataType);
 
-        assertThat(
-                schema,
-                equalTo(
+        assertThat(schema)
+                .isEqualTo(
                         ResolvedSchema.of(
                                 Column.physical("f0", INT()),
                                 Column.physical("f1", STRING()),
                                 Column.physical("f2", TIMESTAMP(5).bridgedTo(Timestamp.class)),
                                 Column.physical(
-                                        "f3", TIMESTAMP(3).bridgedTo(LocalDateTime.class)))));
+                                        "f3", TIMESTAMP(3).bridgedTo(LocalDateTime.class))));
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -244,15 +225,12 @@ public class DataTypeUtilsTest {
 
         final DataType inputOnlyDataType = validDataType.bridgedTo(HashMap.class);
         DataTypeUtils.validateInputDataType(inputOnlyDataType);
-        try {
-            DataTypeUtils.validateOutputDataType(inputOnlyDataType);
-            fail();
-        } catch (ValidationException e) {
-            assertEquals(
-                    e.getMessage(),
-                    "Data type 'MAP<INT, STRING>' does not support an output conversion to class '"
-                            + java.util.HashMap.class.getName()
-                            + "'.");
-        }
+
+        assertThatThrownBy(() -> DataTypeUtils.validateOutputDataType(inputOnlyDataType))
+                .isInstanceOf(ValidationException.class)
+                .hasMessage(
+                        "Data type 'MAP<INT, STRING>' does not support an output conversion to class '"
+                                + java.util.HashMap.class.getName()
+                                + "'.");
     }
 }
