diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/EqualiserCodeGenerator.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/EqualiserCodeGenerator.scala
index 01016be00ee..e45b8e94a11 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/EqualiserCodeGenerator.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/EqualiserCodeGenerator.scala
@@ -23,7 +23,7 @@ import org.apache.flink.table.planner.codegen.Indenter.toISC
 import org.apache.flink.table.planner.codegen.calls.ScalarOperatorGens.generateEquals
 import org.apache.flink.table.runtime.generated.{GeneratedRecordEqualiser, RecordEqualiser}
 import org.apache.flink.table.runtime.types.PlannerTypeUtils
-import org.apache.flink.table.types.logical.{DistinctType, LogicalType, RowType}
+import org.apache.flink.table.types.logical.{BooleanType, DistinctType, LogicalType, RowType}
 import org.apache.flink.table.types.logical.LogicalTypeRoot._
 import org.apache.flink.table.types.logical.utils.LogicalTypeChecks.{getFieldTypes, isCompositeType}
 
@@ -157,7 +157,8 @@ class EqualiserCodeGenerator(fieldTypes: Array[LogicalType], classLoader: ClassL
     } else {
       val left = GeneratedExpression(leftFieldTerm, leftNullTerm, "", fieldType)
       val right = GeneratedExpression(rightFieldTerm, rightNullTerm, "", fieldType)
-      val gen = generateEquals(ctx, left, right)
+      val resultType = new BooleanType(fieldType.isNullable)
+      val gen = generateEquals(ctx, left, right, resultType)
       (gen.code, gen.resultTerm)
     }
   }
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/ExprCodeGenerator.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/ExprCodeGenerator.scala
index d67cb5613a4..c797b04042d 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/ExprCodeGenerator.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/ExprCodeGenerator.scala
@@ -572,7 +572,7 @@ class ExprCodeGenerator(ctx: CodeGeneratorContext, nullableInput: Boolean)
       case UNARY_MINUS if isTimeInterval(resultType) =>
         val operand = operands.head
         requireTimeInterval(operand)
-        generateUnaryIntervalPlusMinus(ctx, plus = false, operand)
+        generateUnaryIntervalPlusMinus(ctx, plus = false, resultType, operand)
 
       case UNARY_PLUS if isNumeric(resultType) =>
         val operand = operands.head
@@ -582,59 +582,59 @@ class ExprCodeGenerator(ctx: CodeGeneratorContext, nullableInput: Boolean)
       case UNARY_PLUS if isTimeInterval(resultType) =>
         val operand = operands.head
         requireTimeInterval(operand)
-        generateUnaryIntervalPlusMinus(ctx, plus = true, operand)
+        generateUnaryIntervalPlusMinus(ctx, plus = true, resultType, operand)
 
       // comparison
       case EQUALS =>
         val left = operands.head
         val right = operands(1)
-        generateEquals(ctx, left, right)
+        generateEquals(ctx, left, right, resultType)
 
       case IS_NOT_DISTINCT_FROM =>
         val left = operands.head
         val right = operands(1)
-        generateIsNotDistinctFrom(ctx, left, right)
+        generateIsNotDistinctFrom(ctx, left, right, resultType)
 
       case NOT_EQUALS =>
         val left = operands.head
         val right = operands(1)
-        generateNotEquals(ctx, left, right)
+        generateNotEquals(ctx, left, right, resultType)
 
       case GREATER_THAN =>
         val left = operands.head
         val right = operands(1)
         requireComparable(left)
         requireComparable(right)
-        generateComparison(ctx, ">", left, right)
+        generateComparison(ctx, ">", left, right, resultType)
 
       case GREATER_THAN_OR_EQUAL =>
         val left = operands.head
         val right = operands(1)
         requireComparable(left)
         requireComparable(right)
-        generateComparison(ctx, ">=", left, right)
+        generateComparison(ctx, ">=", left, right, resultType)
 
       case LESS_THAN =>
         val left = operands.head
         val right = operands(1)
         requireComparable(left)
         requireComparable(right)
-        generateComparison(ctx, "<", left, right)
+        generateComparison(ctx, "<", left, right, resultType)
 
       case LESS_THAN_OR_EQUAL =>
         val left = operands.head
         val right = operands(1)
         requireComparable(left)
         requireComparable(right)
-        generateComparison(ctx, "<=", left, right)
+        generateComparison(ctx, "<=", left, right, resultType)
 
       case IS_NULL =>
         val operand = operands.head
-        generateIsNull(operand)
+        generateIsNull(operand, resultType)
 
       case IS_NOT_NULL =>
         val operand = operands.head
-        generateIsNotNull(operand)
+        generateIsNotNull(operand, resultType)
 
       // logic
       case AND =>
@@ -642,7 +642,7 @@ class ExprCodeGenerator(ctx: CodeGeneratorContext, nullableInput: Boolean)
           (left: GeneratedExpression, right: GeneratedExpression) =>
             requireBoolean(left)
             requireBoolean(right)
-            generateAnd(left, right)
+            generateAnd(left, right, resultType)
         }
 
       case OR =>
@@ -650,13 +650,13 @@ class ExprCodeGenerator(ctx: CodeGeneratorContext, nullableInput: Boolean)
           (left: GeneratedExpression, right: GeneratedExpression) =>
             requireBoolean(left)
             requireBoolean(right)
-            generateOr(left, right)
+            generateOr(left, right, resultType)
         }
 
       case NOT =>
         val operand = operands.head
         requireBoolean(operand)
-        generateNot(ctx, operand)
+        generateNot(ctx, operand, resultType)
 
       case CASE =>
         generateIfElse(ctx, operands, resultType)
@@ -664,22 +664,22 @@ class ExprCodeGenerator(ctx: CodeGeneratorContext, nullableInput: Boolean)
       case IS_TRUE =>
         val operand = operands.head
         requireBoolean(operand)
-        generateIsTrue(operand)
+        generateIsTrue(operand, resultType)
 
       case IS_NOT_TRUE =>
         val operand = operands.head
         requireBoolean(operand)
-        generateIsNotTrue(operand)
+        generateIsNotTrue(operand, resultType)
 
       case IS_FALSE =>
         val operand = operands.head
         requireBoolean(operand)
-        generateIsFalse(operand)
+        generateIsFalse(operand, resultType)
 
       case IS_NOT_FALSE =>
         val operand = operands.head
         requireBoolean(operand)
-        generateIsNotFalse(operand)
+        generateIsNotFalse(operand, resultType)
 
       // casting
       case CAST =>
@@ -737,11 +737,11 @@ class ExprCodeGenerator(ctx: CodeGeneratorContext, nullableInput: Boolean)
         operands.head.resultType match {
           case t: LogicalType if TypeCheckUtils.isArray(t) =>
             val array = operands.head
-            generateArrayCardinality(ctx, array)
+            generateArrayCardinality(ctx, array, resultType)
 
           case t: LogicalType if TypeCheckUtils.isMap(t) =>
             val map = operands.head
-            generateMapCardinality(ctx, map)
+            generateMapCardinality(ctx, map, resultType)
 
           case _ => throw new CodeGenException("Expect an array or a map.")
         }
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/NotCallGen.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/NotCallGen.scala
index aec672fab0c..18003645847 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/NotCallGen.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/NotCallGen.scala
@@ -30,7 +30,10 @@ class NotCallGen(callGenerator: CallGenerator) extends CallGenerator {
   ): GeneratedExpression = {
     assert(returnType.isInstanceOf[BooleanType])
 
-    ScalarOperatorGens.generateNot(ctx, callGenerator.generate(ctx, operands, returnType))
+    ScalarOperatorGens.generateNot(
+      ctx,
+      callGenerator.generate(ctx, operands, returnType),
+      returnType)
   }
 
 }
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala
index 1e2040becef..7082e93f71f 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala
@@ -313,9 +313,10 @@ object ScalarOperatorGens {
   def generateUnaryIntervalPlusMinus(
       ctx: CodeGeneratorContext,
       plus: Boolean,
+      resultType: LogicalType,
       operand: GeneratedExpression): GeneratedExpression = {
     val operator = if (plus) "+" else "-"
-    generateUnaryArithmeticOperator(ctx, operator, operand.resultType, operand)
+    generateUnaryArithmeticOperator(ctx, operator, resultType, operand)
   }
 
   // ----------------------------------------------------------------------------------------
@@ -347,42 +348,47 @@ object ScalarOperatorGens {
   def generateEquals(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression = {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     checkImplicitConversionValidity(left, right)
     val canEqual = isInteroperable(left.resultType, right.resultType)
     if (isCharacterString(left.resultType) && isCharacterString(right.resultType)) {
-      generateOperatorIfNotNull(ctx, new BooleanType(), left, right) {
-        (leftTerm, rightTerm) => s"$leftTerm.equals($rightTerm)"
-      }
+      generateOperatorIfNotNull(ctx, resultType, left, right)(
+        (leftTerm, rightTerm) => s"$leftTerm.equals($rightTerm)")
     }
     // numeric types
     else if (isNumeric(left.resultType) && isNumeric(right.resultType)) {
-      generateComparison(ctx, "==", left, right)
+      generateComparison(ctx, "==", left, right, resultType)
     }
     // array types
     else if (isArray(left.resultType) && canEqual) {
-      generateArrayComparison(ctx, left, right)
+      generateArrayComparison(ctx, left, right, resultType)
     }
     // map types
     else if (isMap(left.resultType) && canEqual) {
       val mapType = left.resultType.asInstanceOf[MapType]
-      generateMapComparison(ctx, left, right, mapType.getKeyType, mapType.getValueType)
+      generateMapComparison(ctx, left, right, mapType.getKeyType, mapType.getValueType, resultType)
     }
     // multiset types
     else if (isMultiset(left.resultType) && canEqual) {
       val multisetType = left.resultType.asInstanceOf[MultisetType]
-      generateMapComparison(ctx, left, right, multisetType.getElementType, new IntType(false))
+      generateMapComparison(
+        ctx,
+        left,
+        right,
+        multisetType.getElementType,
+        new IntType(false),
+        resultType)
     }
     // comparable types of same type
     else if (isComparable(left.resultType) && canEqual) {
-      generateComparison(ctx, "==", left, right)
+      generateComparison(ctx, "==", left, right, resultType)
     }
     // generic types of same type
     else if (isRaw(left.resultType) && canEqual) {
       val Seq(resultTerm, nullTerm) = newNames("result", "isNull")
       val genericSer = ctx.addReusableTypeSerializer(left.resultType)
       val ser = s"$genericSer.getInnerSerializer()"
-      val resultType = new BooleanType()
       val code =
         s"""
            |${left.code}
@@ -393,7 +399,8 @@ object ScalarOperatorGens {
            |  ${left.resultTerm}.ensureMaterialized($ser);
            |  ${right.resultTerm}.ensureMaterialized($ser);
            |  $resultTerm =
-           |    ${left.resultTerm}.getBinarySection().equals(${right.resultTerm}.getBinarySection());
+           |    ${left.resultTerm}.getBinarySection().
+           |    equals(${right.resultTerm}.getBinarySection());
            |}
            |""".stripMargin
       GeneratedExpression(resultTerm, nullTerm, code, resultType)
@@ -402,20 +409,28 @@ object ScalarOperatorGens {
     // for performance, we cast literal string to literal time.
     else if (isTimePoint(left.resultType) && isCharacterString(right.resultType)) {
       if (right.literal) {
-        generateEquals(ctx, left, generateCastLiteral(ctx, right, left.resultType))
+        generateEquals(ctx, left, generateCastLiteral(ctx, right, left.resultType), resultType)
       } else {
-        generateEquals(ctx, left, generateCast(ctx, right, left.resultType, nullOnFailure = true))
+        generateEquals(
+          ctx,
+          left,
+          generateCast(ctx, right, left.resultType, nullOnFailure = true),
+          resultType)
       }
     } else if (isTimePoint(right.resultType) && isCharacterString(left.resultType)) {
       if (left.literal) {
-        generateEquals(ctx, generateCastLiteral(ctx, left, right.resultType), right)
+        generateEquals(ctx, generateCastLiteral(ctx, left, right.resultType), right, resultType)
       } else {
-        generateEquals(ctx, generateCast(ctx, left, right.resultType, nullOnFailure = true), right)
+        generateEquals(
+          ctx,
+          generateCast(ctx, left, right.resultType, nullOnFailure = true),
+          right,
+          resultType)
       }
     }
     // non comparable types
     else {
-      generateOperatorIfNotNull(ctx, new BooleanType(), left, right) {
+      generateOperatorIfNotNull(ctx, resultType, left, right) {
         if (isReference(left.resultType)) {
           (leftTerm, rightTerm) => s"$leftTerm.equals($rightTerm)"
         } else if (isReference(right.resultType)) {
@@ -432,61 +447,67 @@ object ScalarOperatorGens {
   def generateIsNotDistinctFrom(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression = {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     generateOr(
-      generateAnd(generateIsNull(left), generateIsNull(right)),
-      generateEquals(ctx, left, right))
+      generateAnd(
+        generateIsNull(left, new BooleanType(false)),
+        generateIsNull(right, new BooleanType(false)),
+        resultType),
+      generateEquals(ctx, left, right, resultType),
+      resultType
+    )
   }
 
   def generateNotEquals(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression = {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     checkImplicitConversionValidity(left, right)
     if (isCharacterString(left.resultType) && isCharacterString(right.resultType)) {
-      generateOperatorIfNotNull(ctx, new BooleanType(), left, right) {
-        (leftTerm, rightTerm) => s"!$leftTerm.equals($rightTerm)"
-      }
+      generateOperatorIfNotNull(ctx, resultType, left, right)(
+        (leftTerm, rightTerm) => s"!$leftTerm.equals($rightTerm)")
     }
     // numeric types
     else if (isNumeric(left.resultType) && isNumeric(right.resultType)) {
-      generateComparison(ctx, "!=", left, right)
+      generateComparison(ctx, "!=", left, right, resultType)
     }
     // temporal types
     else if (
       isTemporal(left.resultType) &&
       isInteroperable(left.resultType, right.resultType)
     ) {
-      generateComparison(ctx, "!=", left, right)
+      generateComparison(ctx, "!=", left, right, resultType)
     }
     // array types
     else if (isArray(left.resultType) && isInteroperable(left.resultType, right.resultType)) {
-      val equalsExpr = generateEquals(ctx, left, right)
+      val equalsExpr = generateEquals(ctx, left, right, resultType)
       GeneratedExpression(
         s"(!${equalsExpr.resultTerm})",
         equalsExpr.nullTerm,
         equalsExpr.code,
-        new BooleanType())
+        resultType)
     }
     // map types
     else if (isMap(left.resultType) && isInteroperable(left.resultType, right.resultType)) {
-      val equalsExpr = generateEquals(ctx, left, right)
+      val equalsExpr = generateEquals(ctx, left, right, resultType)
       GeneratedExpression(
         s"(!${equalsExpr.resultTerm})",
         equalsExpr.nullTerm,
         equalsExpr.code,
-        new BooleanType())
+        resultType)
     }
     // comparable types
     else if (
       isComparable(left.resultType) &&
       isInteroperable(left.resultType, right.resultType)
     ) {
-      generateComparison(ctx, "!=", left, right)
+      generateComparison(ctx, "!=", left, right, resultType)
     }
     // non-comparable types
     else {
-      generateOperatorIfNotNull(ctx, new BooleanType(), left, right) {
+      generateOperatorIfNotNull(ctx, resultType, left, right) {
         if (isReference(left.resultType)) {
           (leftTerm, rightTerm) => s"!($leftTerm.equals($rightTerm))"
         } else if (isReference(right.resultType)) {
@@ -505,8 +526,9 @@ object ScalarOperatorGens {
       ctx: CodeGeneratorContext,
       operator: String,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression = {
-    generateOperatorIfNotNull(ctx, new BooleanType(), left, right) {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateOperatorIfNotNull(ctx, resultType, left, right) {
       // either side is decimal
       if (isDecimal(left.resultType) || isDecimal(right.resultType)) {
         (leftTerm, rightTerm) =>
@@ -571,9 +593,9 @@ object ScalarOperatorGens {
     }
   }
 
-  def generateIsNull(operand: GeneratedExpression): GeneratedExpression = {
+  def generateIsNull(operand: GeneratedExpression, resultType: LogicalType): GeneratedExpression = {
     if (operand.resultType.isNullable) {
-      GeneratedExpression(operand.nullTerm, NEVER_NULL, operand.code, new BooleanType(false))
+      GeneratedExpression(operand.nullTerm, NEVER_NULL, operand.code, resultType)
     } else if (isReference(operand.resultType)) {
       val resultTerm = newName("isNull")
       val operatorCode =
@@ -581,13 +603,15 @@ object ScalarOperatorGens {
            |${operand.code}
            |boolean $resultTerm = ${operand.resultTerm} == null;
            |""".stripMargin
-      GeneratedExpression(resultTerm, NEVER_NULL, operatorCode, new BooleanType(false))
+      GeneratedExpression(resultTerm, NEVER_NULL, operatorCode, resultType)
     } else {
-      GeneratedExpression("false", NEVER_NULL, operand.code, new BooleanType(false))
+      GeneratedExpression("false", NEVER_NULL, operand.code, resultType)
     }
   }
 
-  def generateIsNotNull(operand: GeneratedExpression): GeneratedExpression = {
+  def generateIsNotNull(
+      operand: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     if (operand.resultType.isNullable) {
       val resultTerm = newName("result")
       val operatorCode =
@@ -595,7 +619,7 @@ object ScalarOperatorGens {
            |${operand.code}
            |boolean $resultTerm = !${operand.nullTerm};
            |""".stripMargin.trim
-      GeneratedExpression(resultTerm, NEVER_NULL, operatorCode, new BooleanType(false))
+      GeneratedExpression(resultTerm, NEVER_NULL, operatorCode, resultType)
     } else if (isReference(operand.resultType)) {
       val resultTerm = newName("result")
       val operatorCode =
@@ -603,13 +627,16 @@ object ScalarOperatorGens {
            |${operand.code}
            |boolean $resultTerm = ${operand.resultTerm} != null;
            |""".stripMargin.trim
-      GeneratedExpression(resultTerm, NEVER_NULL, operatorCode, new BooleanType(false))
+      GeneratedExpression(resultTerm, NEVER_NULL, operatorCode, resultType)
     } else {
-      GeneratedExpression("true", NEVER_NULL, operand.code, new BooleanType(false))
+      GeneratedExpression("true", NEVER_NULL, operand.code, resultType)
     }
   }
 
-  def generateAnd(left: GeneratedExpression, right: GeneratedExpression): GeneratedExpression = {
+  def generateAnd(
+      left: GeneratedExpression,
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     val Seq(resultTerm, nullTerm) = newNames("result", "isNull")
 
     val operatorCode =
@@ -657,10 +684,13 @@ object ScalarOperatorGens {
          |}
        """.stripMargin.trim
 
-    GeneratedExpression(resultTerm, nullTerm, operatorCode, new BooleanType())
+    GeneratedExpression(resultTerm, nullTerm, operatorCode, resultType)
   }
 
-  def generateOr(left: GeneratedExpression, right: GeneratedExpression): GeneratedExpression = {
+  def generateOr(
+      left: GeneratedExpression,
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     val Seq(resultTerm, nullTerm) = newNames("result", "isNull")
 
     val operatorCode =
@@ -708,48 +738,55 @@ object ScalarOperatorGens {
          |}
          |""".stripMargin.trim
 
-    GeneratedExpression(resultTerm, nullTerm, operatorCode, new BooleanType())
+    GeneratedExpression(resultTerm, nullTerm, operatorCode, resultType)
   }
 
-  def generateNot(ctx: CodeGeneratorContext, operand: GeneratedExpression): GeneratedExpression = {
+  def generateNot(
+      ctx: CodeGeneratorContext,
+      operand: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     // Three-valued logic:
     // no Unknown -> Two-valued logic
     // Unknown -> Unknown
-    generateUnaryOperatorIfNotNull(ctx, new BooleanType(), operand) {
-      operandTerm => s"!($operandTerm)"
-    }
+    generateUnaryOperatorIfNotNull(ctx, resultType, operand)(operandTerm => s"!($operandTerm)")
   }
 
-  def generateIsTrue(operand: GeneratedExpression): GeneratedExpression = {
+  def generateIsTrue(operand: GeneratedExpression, resultType: LogicalType): GeneratedExpression = {
     GeneratedExpression(
       operand.resultTerm, // unknown is always false by default
       GeneratedExpression.NEVER_NULL,
       operand.code,
-      new BooleanType())
+      resultType)
   }
 
-  def generateIsNotTrue(operand: GeneratedExpression): GeneratedExpression = {
+  def generateIsNotTrue(
+      operand: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     GeneratedExpression(
       s"(!${operand.resultTerm})", // unknown is always false by default
       GeneratedExpression.NEVER_NULL,
       operand.code,
-      new BooleanType())
+      resultType)
   }
 
-  def generateIsFalse(operand: GeneratedExpression): GeneratedExpression = {
+  def generateIsFalse(
+      operand: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     GeneratedExpression(
       s"(!${operand.resultTerm} && !${operand.nullTerm})",
       GeneratedExpression.NEVER_NULL,
       operand.code,
-      new BooleanType())
+      resultType)
   }
 
-  def generateIsNotFalse(operand: GeneratedExpression): GeneratedExpression = {
+  def generateIsNotFalse(
+      operand: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
     GeneratedExpression(
       s"(${operand.resultTerm} || ${operand.nullTerm})",
       GeneratedExpression.NEVER_NULL,
       operand.code,
-      new BooleanType())
+      resultType)
   }
 
   def generateReinterpret(
@@ -1289,8 +1326,9 @@ object ScalarOperatorGens {
 
   def generateArrayCardinality(
       ctx: CodeGeneratorContext,
-      array: GeneratedExpression): GeneratedExpression = {
-    generateUnaryOperatorIfNotNull(ctx, new IntType(), array)(_ => s"${array.resultTerm}.size()")
+      array: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateUnaryOperatorIfNotNull(ctx, resultType, array)(_ => s"${array.resultTerm}.size()")
   }
 
   /**
@@ -1450,7 +1488,8 @@ object ScalarOperatorGens {
       // Otherwise, the code of `key` will be called twice in `accessCode`, which may lead to
       // exceptions such as 'Redefinition of local variable'.
       GeneratedExpression(key.resultTerm, key.nullTerm, NO_CODE, key.resultType, key.literalValue),
-      GeneratedExpression(tmpKey, NEVER_NULL, NO_CODE, keyType)
+      GeneratedExpression(tmpKey, NEVER_NULL, NO_CODE, keyType),
+      new BooleanType(key.resultType.isNullable)
     )
     val code =
       s"""
@@ -1515,8 +1554,9 @@ object ScalarOperatorGens {
 
   def generateMapCardinality(
       ctx: CodeGeneratorContext,
-      map: GeneratedExpression): GeneratedExpression = {
-    generateUnaryOperatorIfNotNull(ctx, new IntType(), map)(_ => s"${map.resultTerm}.size()")
+      map: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateUnaryOperatorIfNotNull(ctx, resultType, map)(_ => s"${map.resultTerm}.size()")
   }
 
   // ----------------------------------------------------------------------------------------
@@ -1567,8 +1607,9 @@ object ScalarOperatorGens {
   private def generateArrayComparison(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression =
-    generateCallWithStmtIfArgsNotNull(ctx, new BooleanType(), Seq(left, right)) {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateCallWithStmtIfArgsNotNull(ctx, resultType, Seq(left, right)) {
       args =>
         val leftTerm = args.head
         val rightTerm = args(1)
@@ -1590,7 +1631,11 @@ object ScalarOperatorGens {
           GeneratedExpression(rightElementTerm, rightElementNullTerm, "", elementType)
 
         val indexTerm = newName("index")
-        val elementEqualsExpr = generateEquals(ctx, leftElementExpr, rightElementExpr)
+        val elementEqualsExpr = generateEquals(
+          ctx,
+          leftElementExpr,
+          rightElementExpr,
+          new BooleanType(elementType.isNullable))
 
         val stmt =
           s"""
@@ -1628,14 +1673,16 @@ object ScalarOperatorGens {
              """.stripMargin
         (stmt, resultTerm)
     }
+  }
 
   private def generateMapComparison(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
       right: GeneratedExpression,
       keyType: LogicalType,
-      valueType: LogicalType): GeneratedExpression =
-    generateCallWithStmtIfArgsNotNull(ctx, new BooleanType(), Seq(left, right)) {
+      valueType: LogicalType,
+      resultType: LogicalType): GeneratedExpression =
+    generateCallWithStmtIfArgsNotNull(ctx, resultType, Seq(left, right)) {
       args =>
         val leftTerm = args.head
         val rightTerm = args(1)
@@ -1661,7 +1708,8 @@ object ScalarOperatorGens {
 
         val entryTerm = newName("entry")
         val entryCls = classOf[java.util.Map.Entry[AnyRef, AnyRef]].getCanonicalName
-        val valueEqualsExpr = generateEquals(ctx, leftValueExpr, rightValueExpr)
+        val valueEqualsExpr =
+          generateEquals(ctx, leftValueExpr, rightValueExpr, new BooleanType(valueType.isNullable))
 
         val internalTypeCls = classOf[LogicalType].getCanonicalName
         val keyTypeTerm = ctx.addReusableObject(keyType, "keyType", internalTypeCls)
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/SearchOperatorGen.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/SearchOperatorGen.scala
index fa3e05a2c73..4dcd67875b7 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/SearchOperatorGen.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/SearchOperatorGen.scala
@@ -113,11 +113,17 @@ object SearchOperatorGen {
         .map(RangeSets.map(_, rangeToExpression))
 
       if (sarg.containsNull) {
-        rangeChecks = Seq(generateIsNull(target)) ++ rangeChecks
+        rangeChecks =
+          Seq(generateIsNull(target, new BooleanType(target.resultType.isNullable))) ++ rangeChecks
       }
 
       val generatedRangeChecks = rangeChecks
-        .reduce((left, right) => generateOr(left, right))
+        .reduce(
+          (left, right) =>
+            generateOr(
+              left,
+              right,
+              new BooleanType(left.resultType.isNullable || right.resultType.isNullable)))
 
       // Add the target expression code
       val finalCode =
@@ -137,64 +143,72 @@ object SearchOperatorGen {
       target: GeneratedExpression)
     extends RangeSets.Handler[C, GeneratedExpression] {
 
+    final val resultTypeForBoolExpr = new BooleanType(
+      boundType.isNullable
+        || target.resultType.isNullable)
+
     override def all(): GeneratedExpression = {
-      generateLiteral(ctx, true, new BooleanType())
+      generateLiteral(ctx, true, new BooleanType(false))
     }
 
     /** lower <= target */
     override def atLeast(lower: C): GeneratedExpression = {
-      generateComparison(ctx, "<=", lit(lower), target)
+      generateComparison(ctx, "<=", lit(lower), target, resultTypeForBoolExpr)
     }
 
     /** target <= upper */
     override def atMost(upper: C): GeneratedExpression = {
-      generateComparison(ctx, "<=", target, lit(upper))
+      generateComparison(ctx, "<=", target, lit(upper), resultTypeForBoolExpr)
     }
 
     /** lower < target */
     override def greaterThan(lower: C): GeneratedExpression = {
-      generateComparison(ctx, "<", lit(lower), target)
+      generateComparison(ctx, "<", lit(lower), target, resultTypeForBoolExpr)
     }
 
     /** target < upper */
     override def lessThan(upper: C): GeneratedExpression = {
-      generateComparison(ctx, "<", target, lit(upper))
+      generateComparison(ctx, "<", target, lit(upper), resultTypeForBoolExpr)
     }
 
     /** value == target */
     override def singleton(value: C): GeneratedExpression = {
-      generateComparison(ctx, "==", lit(value), target)
+      generateComparison(ctx, "==", lit(value), target, resultTypeForBoolExpr)
     }
 
     /** lower <= target && target <= upper */
     override def closed(lower: C, upper: C): GeneratedExpression = {
       generateAnd(
-        generateComparison(ctx, "<=", lit(lower), target),
-        generateComparison(ctx, "<=", target, lit(upper))
+        generateComparison(ctx, "<=", lit(lower), target, resultTypeForBoolExpr),
+        generateComparison(ctx, "<=", target, lit(upper), resultTypeForBoolExpr),
+        resultTypeForBoolExpr
       )
     }
 
     /** lower <= target && target < upper */
     override def closedOpen(lower: C, upper: C): GeneratedExpression = {
       generateAnd(
-        generateComparison(ctx, "<=", lit(lower), target),
-        generateComparison(ctx, "<", target, lit(upper))
+        generateComparison(ctx, "<=", lit(lower), target, resultTypeForBoolExpr),
+        generateComparison(ctx, "<", target, lit(upper), resultTypeForBoolExpr),
+        resultTypeForBoolExpr
       )
     }
 
     /** lower < target && target <= upper */
     override def openClosed(lower: C, upper: C): GeneratedExpression = {
       generateAnd(
-        generateComparison(ctx, "<", lit(lower), target),
-        generateComparison(ctx, "<=", target, lit(upper))
+        generateComparison(ctx, "<", lit(lower), target, resultTypeForBoolExpr),
+        generateComparison(ctx, "<=", target, lit(upper), resultTypeForBoolExpr),
+        resultTypeForBoolExpr
       )
     }
 
     /** lower < target && target < upper */
     override def open(lower: C, upper: C): GeneratedExpression = {
       generateAnd(
-        generateComparison(ctx, "<", lit(lower), target),
-        generateComparison(ctx, "<", target, lit(upper))
+        generateComparison(ctx, "<", lit(lower), target, resultTypeForBoolExpr),
+        generateComparison(ctx, "<", target, lit(upper), resultTypeForBoolExpr),
+        resultTypeForBoolExpr
       )
     }
 
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/StringCallGen.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/StringCallGen.scala
index 6db5e476df1..8a052c0ac53 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/StringCallGen.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/StringCallGen.scala
@@ -60,10 +60,10 @@ object StringCallGen {
     val generator = operator match {
 
       case LIKE =>
-        new LikeCallGen().generate(ctx, operands, new BooleanType())
+        new LikeCallGen().generate(ctx, operands, returnType)
 
       case NOT_LIKE =>
-        generateNot(ctx, new LikeCallGen().generate(ctx, operands, new BooleanType()))
+        generateNot(ctx, new LikeCallGen().generate(ctx, operands, returnType), returnType)
 
       case SUBSTR | SUBSTRING => generateSubString(ctx, operands, returnType)
 
@@ -71,21 +71,22 @@ object StringCallGen {
 
       case RIGHT => generateRight(ctx, operands.head, operands(1), returnType)
 
-      case CHAR_LENGTH | CHARACTER_LENGTH => generateCharLength(ctx, operands)
+      case CHAR_LENGTH | CHARACTER_LENGTH => generateCharLength(ctx, operands, returnType)
 
-      case SIMILAR_TO => generateSimilarTo(ctx, operands)
+      case SIMILAR_TO => generateSimilarTo(ctx, operands, returnType)
 
-      case NOT_SIMILAR_TO => generateNot(ctx, generateSimilarTo(ctx, operands))
+      case NOT_SIMILAR_TO =>
+        generateNot(ctx, generateSimilarTo(ctx, operands, returnType), returnType)
 
       case REGEXP_EXTRACT => generateRegexpExtract(ctx, operands, returnType)
 
       case REGEXP_REPLACE => generateRegexpReplace(ctx, operands, returnType)
 
-      case IS_DECIMAL => generateIsDecimal(ctx, operands)
+      case IS_DECIMAL => generateIsDecimal(ctx, operands, returnType)
 
-      case IS_DIGIT => generateIsDigit(ctx, operands)
+      case IS_DIGIT => generateIsDigit(ctx, operands, returnType)
 
-      case IS_ALPHA => generateIsAlpha(ctx, operands)
+      case IS_ALPHA => generateIsAlpha(ctx, operands, returnType)
 
       case UPPER => generateUpper(ctx, operands, returnType)
 
@@ -93,9 +94,9 @@ object StringCallGen {
 
       case INITCAP => generateInitcap(ctx, operands, returnType)
 
-      case POSITION => generatePosition(ctx, operands)
+      case POSITION => generatePosition(ctx, operands, returnType)
 
-      case LOCATE => generateLocate(ctx, operands)
+      case LOCATE => generateLocate(ctx, operands, returnType)
 
       case OVERLAY => generateOverlay(ctx, operands, returnType)
 
@@ -112,7 +113,7 @@ object StringCallGen {
       case SPLIT_INDEX => generateSplitIndex(ctx, operands, returnType)
 
       case HASH_CODE if isCharacterString(operands.head.resultType) =>
-        generateHashCode(ctx, operands)
+        generateHashCode(ctx, operands, returnType)
 
       case MD5 => generateMd5(ctx, operands, returnType)
 
@@ -136,7 +137,7 @@ object StringCallGen {
 
       case CHR => generateChr(ctx, operands, returnType)
 
-      case REGEXP => generateRegExp(ctx, operands)
+      case REGEXP => generateRegExp(ctx, operands, returnType)
 
       case BIN => generateBin(ctx, operands, returnType)
 
@@ -148,7 +149,7 @@ object StringCallGen {
         operands.foreach(requireCharacterString)
         generateConcatWs(ctx, operands, returnType)
 
-      case STR_TO_MAP => generateStrToMap(ctx, operands)
+      case STR_TO_MAP => generateStrToMap(ctx, operands, returnType)
 
       case TRIM => generateTrim(ctx, operands, returnType)
 
@@ -164,13 +165,13 @@ object StringCallGen {
 
       case UUID => generateUuid(ctx, operands, returnType)
 
-      case ASCII => generateAscii(ctx, operands.head)
+      case ASCII => generateAscii(ctx, operands.head, returnType)
 
       case ENCODE => generateEncode(ctx, operands.head, operands(1), returnType)
 
       case DECODE => generateDecode(ctx, operands.head, operands(1), returnType)
 
-      case INSTR => generateInstr(ctx, operands)
+      case INSTR => generateInstr(ctx, operands, returnType)
 
       case PRINT => new PrintCallGen().generate(ctx, operands, returnType)
 
@@ -286,8 +287,9 @@ object StringCallGen {
   def generateStringEquals(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression = {
-    generateCallIfArgsNotNull(ctx, new BooleanType(), Seq(left, right)) {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateCallIfArgsNotNull(ctx, resultType, Seq(left, right)) {
       terms => s"(${terms.head}.equals(${terms(1)}))"
     }
   }
@@ -296,8 +298,9 @@ object StringCallGen {
   def generateStringNotEquals(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
-      right: GeneratedExpression): GeneratedExpression = {
-    generateCallIfArgsNotNull(ctx, new BooleanType(), Seq(left, right)) {
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateCallIfArgsNotNull(ctx, resultType, Seq(left, right)) {
       terms => s"!(${terms.head}.equals(${terms(1)}))"
     }
   }
@@ -343,14 +346,16 @@ object StringCallGen {
 
   def generateCharLength(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
-    generateCallIfArgsNotNull(ctx, new IntType(), operands)(terms => s"${terms.head}.numChars()")
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
+    generateCallIfArgsNotNull(ctx, resultType, operands)(terms => s"${terms.head}.numChars()")
   }
 
   def generateSimilarTo(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
-    generateCallIfArgsNotNull(ctx, new BooleanType(), operands) {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
+    generateCallIfArgsNotNull(ctx, resultType, operands) {
       terms => s"${qualifyMethod(BuiltInMethods.STRING_SIMILAR)}(${toStringTerms(terms, operands)})"
     }
   }
@@ -358,9 +363,9 @@ object StringCallGen {
   def generateRegexpExtract(
       ctx: CodeGeneratorContext,
       operands: Seq[GeneratedExpression],
-      returnType: LogicalType): GeneratedExpression = {
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateStringResultCallIfArgsNotNull(ctx, operands, returnType) {
+    generateStringResultCallIfArgsNotNull(ctx, operands, resultType) {
       terms => s"$className.regexpExtract(${safeToStringTerms(terms, operands)})"
     }
   }
@@ -368,42 +373,48 @@ object StringCallGen {
   def generateRegexpReplace(
       ctx: CodeGeneratorContext,
       operands: Seq[GeneratedExpression],
-      returnType: LogicalType): GeneratedExpression = {
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateStringResultCallIfArgsNotNull(ctx, operands, returnType) {
+    generateStringResultCallIfArgsNotNull(ctx, operands, resultType) {
       terms => s"$className.regexpReplace(${toStringTerms(terms, operands)})"
     }
   }
 
   def generateIsDecimal(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNullable(ctx, new BooleanType(), operands) {
+    generateCallIfArgsNullable(ctx, resultType, operands) {
       terms => s"$className.isDecimal(${safeToStringTerms(terms, operands)})"
     }
   }
 
   def generateIsDigit(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNullable(ctx, new BooleanType(), operands) {
+    generateCallIfArgsNullable(ctx, resultType, operands) {
       terms => s"$className.isDigit(${safeToStringTerms(terms, operands)})"
     }
   }
 
-  def generateAscii(ctx: CodeGeneratorContext, str: GeneratedExpression): GeneratedExpression = {
-    generateCallIfArgsNotNull(ctx, new IntType(), Seq(str)) {
+  def generateAscii(
+      ctx: CodeGeneratorContext,
+      str: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateCallIfArgsNotNull(ctx, resultType, Seq(str)) {
       terms => s"${terms.head}.getSizeInBytes() <= 0 ? 0 : (int) ${terms.head}.byteAt(0)"
     }
   }
 
   def generateIsAlpha(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNullable(ctx, new BooleanType(), operands) {
+    generateCallIfArgsNullable(ctx, resultType, operands) {
       terms => s"$className.isAlpha(${safeToStringTerms(terms, operands)})"
     }
   }
@@ -433,27 +444,30 @@ object StringCallGen {
 
   def generatePosition(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNotNull(ctx, new IntType(), operands) {
+    generateCallIfArgsNotNull(ctx, resultType, operands) {
       terms => s"$className.position(${terms.mkString(",")})"
     }
   }
 
   def generateLocate(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNotNull(ctx, new IntType(), operands) {
+    generateCallIfArgsNotNull(ctx, resultType, operands) {
       terms => s"$className.position(${terms.mkString(",")})"
     }
   }
 
   def generateInstr(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNotNull(ctx, new IntType(), operands) {
+    generateCallIfArgsNotNull(ctx, resultType, operands) {
       terms =>
         val startPosition = if (operands.length < 3) 1 else terms(2)
         val nthAppearance = if (operands.length < 4) 1 else terms(3)
@@ -553,9 +567,10 @@ object StringCallGen {
 
   def generateHashCode(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNotNull(ctx, new IntType(), operands) {
+    generateCallIfArgsNotNull(ctx, resultType, operands) {
       terms => s"$className.hashCode(${terms.head}.toString())"
     }
   }
@@ -691,9 +706,10 @@ object StringCallGen {
 
   def generateRegExp(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      returnType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    generateCallIfArgsNotNull(ctx, new BooleanType(), operands) {
+    generateCallIfArgsNotNull(ctx, returnType, operands) {
       terms => s"$className.regExp(${toStringTerms(terms, operands)})"
     }
   }
@@ -760,13 +776,13 @@ object StringCallGen {
 
   def generateStrToMap(
       ctx: CodeGeneratorContext,
-      operands: Seq[GeneratedExpression]): GeneratedExpression = {
+      operands: Seq[GeneratedExpression],
+      resultType: LogicalType): GeneratedExpression = {
     val className = classOf[SqlFunctionUtils].getCanonicalName
-    val t = new MapType(VarCharType.STRING_TYPE, VarCharType.STRING_TYPE)
     val converter = DataFormatConverters.getConverterForDataType(
       DataTypes.MAP(DataTypes.STRING(), DataTypes.STRING()))
     val converterTerm = ctx.addReusableObject(converter, "mapConverter")
-    generateCallIfArgsNotNull(ctx, t, operands) {
+    generateCallIfArgsNotNull(ctx, resultType, operands) {
       terms =>
         val map = s"$className.strToMap(${toStringTerms(terms, operands)})"
         s"($BINARY_MAP) $converterTerm.toInternal($map)"
diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java
index 0553d95d8ce..bd55a390e1d 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java
@@ -1076,6 +1076,19 @@ public class FunctionITCase extends StreamingTestBase {
                         .collect());
     }
 
+    @Test
+    public void testWithBoolNotNullTypeHint() {
+        List<Row> sourceData = Arrays.asList(Row.of(1, 2), Row.of(2, 3));
+        TestCollectionTableFactory.reset();
+        TestCollectionTableFactory.initData(sourceData);
+
+        tEnv().executeSql(
+                        "CREATE TABLE SourceTable(x INT NOT NULL,y INT) WITH ('connector' = 'COLLECTION')");
+        tEnv().executeSql("CREATE FUNCTION BoolEcho AS '" + BoolEcho.class.getName() + "'");
+        CollectionUtil.iteratorToList(
+                tEnv().executeSql("SELECT BoolEcho(x=1 and y is null) FROM SourceTable").collect());
+    }
+
     // --------------------------------------------------------------------------------------------
     // Test functions
     // --------------------------------------------------------------------------------------------
@@ -1495,4 +1508,11 @@ public class FunctionITCase extends StreamingTestBase {
             }
         }
     }
+
+    /** A function that takes BOOLEAN NOT NULL. */
+    public static class BoolEcho extends ScalarFunction {
+        public Boolean eval(@DataTypeHint("BOOLEAN NOT NULL") Boolean b) {
+            return b;
+        }
+    }
 }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala
index 5e8d3db20b0..c01cb8f5f11 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala
@@ -80,6 +80,28 @@ class ScalarOperatorsTest extends ScalarOperatorsTestBase {
 
   }
 
+  @Test
+  def testFunctionWithBooleanExpression(): Unit = {
+    // this test is to check if the `resultType` of the `GeneratedExpression`
+    // of these boolean expression match their definition in `FlinkSqlOperatorTable`,
+    // if not, exceptions will be thrown from BridgingFunctionGenUtil#verifyArgumentTypes
+
+    // test comparison expression
+    testSqlApi("IFNULL(f18 > f19, false)", "TRUE")
+    testSqlApi("IFNULL(f18 >= f19, false)", "TRUE")
+    testSqlApi("IFNULL(f18 < f19, true)", "FALSE")
+    testSqlApi("IFNULL(f18 <= f19, true)", "FALSE")
+    testSqlApi("IFNULL(f18 = f18, false)", "TRUE")
+    // test logic expression
+    testSqlApi("IFNULL((f6 is false) and f11, true) ", "FALSE")
+    testSqlApi("IFNULL((f6 is true) or f11, false) ", "TRUE")
+    testSqlApi("IFNULL(not f11, false) ", "TRUE")
+    testSqlApi("IFNULL(f6 is true, false) ", "TRUE")
+    testSqlApi("IFNULL(f6 is not true, true) ", "FALSE")
+    testSqlApi("IFNULL(f6 is false, true) ", "FALSE")
+    testSqlApi("IFNULL(f6 is not false, false) ", "TRUE")
+  }
+
   @Test
   def testOtherExpressions(): Unit = {
 
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala
index 5d33cc80b9e..b32c5618f45 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala
@@ -67,7 +67,7 @@ abstract class ScalarOperatorsTestBase extends ExpressionTestBase {
       DataTypes.FIELD("f8", DataTypes.INT()),
       DataTypes.FIELD("f9", DataTypes.INT()),
       DataTypes.FIELD("f10", DataTypes.STRING()),
-      DataTypes.FIELD("f11", DataTypes.BOOLEAN()),
+      DataTypes.FIELD("f11", DataTypes.BOOLEAN().notNull()),
       DataTypes.FIELD("f12", DataTypes.BOOLEAN()),
       DataTypes.FIELD(
         "f13",
@@ -78,8 +78,8 @@ abstract class ScalarOperatorsTestBase extends ExpressionTestBase {
       DataTypes.FIELD("f15", DataTypes.DATE()),
       DataTypes.FIELD("f16", DataTypes.DECIMAL(19, 8)),
       DataTypes.FIELD("f17", DataTypes.DECIMAL(19, 1)),
-      DataTypes.FIELD("f18", DataTypes.BINARY(200)),
-      DataTypes.FIELD("f19", DataTypes.VARBINARY(200)),
+      DataTypes.FIELD("f18", DataTypes.BINARY(200).notNull()),
+      DataTypes.FIELD("f19", DataTypes.VARBINARY(200).notNull()),
       DataTypes.FIELD("f20", DataTypes.VARBINARY(200)),
       DataTypes.FIELD("f21", DataTypes.TIME()),
       DataTypes.FIELD("f22", DataTypes.TIMESTAMP())
