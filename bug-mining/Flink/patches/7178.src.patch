diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionDeployer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionDeployer.java
index 99b3bcd04e5..9589981dcf9 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionDeployer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionDeployer.java
@@ -94,12 +94,12 @@ public class DefaultExecutionDeployer implements ExecutionDeployer {
 
         transitionToScheduled(executionsToDeploy);
 
-        final List<ExecutionSlotAssignment> executionSlotAssignments =
+        final Map<ExecutionAttemptID, ExecutionSlotAssignment> executionSlotAssignmentMap =
                 allocateSlotsFor(executionsToDeploy);
 
         final List<ExecutionDeploymentHandle> deploymentHandles =
                 createDeploymentHandles(
-                        executionsToDeploy, requiredVersionByVertex, executionSlotAssignments);
+                        executionsToDeploy, requiredVersionByVertex, executionSlotAssignmentMap);
 
         waitForAllSlotsAndDeploy(deploymentHandles);
     }
@@ -118,7 +118,7 @@ public class DefaultExecutionDeployer implements ExecutionDeployer {
         executionsToDeploy.forEach(e -> e.transitionState(ExecutionState.SCHEDULED));
     }
 
-    private List<ExecutionSlotAssignment> allocateSlotsFor(
+    private Map<ExecutionAttemptID, ExecutionSlotAssignment> allocateSlotsFor(
             final List<Execution> executionsToDeploy) {
         final List<ExecutionAttemptID> executionAttemptIds =
                 executionsToDeploy.stream()
@@ -130,14 +130,13 @@ public class DefaultExecutionDeployer implements ExecutionDeployer {
     private List<ExecutionDeploymentHandle> createDeploymentHandles(
             final List<Execution> executionsToDeploy,
             final Map<ExecutionVertexID, ExecutionVertexVersion> requiredVersionByVertex,
-            final List<ExecutionSlotAssignment> executionSlotAssignments) {
-
+            final Map<ExecutionAttemptID, ExecutionSlotAssignment> executionSlotAssignmentMap) {
+        checkState(executionsToDeploy.size() == executionSlotAssignmentMap.size());
         final List<ExecutionDeploymentHandle> deploymentHandles =
                 new ArrayList<>(executionsToDeploy.size());
-        for (int i = 0; i < executionsToDeploy.size(); i++) {
-            final Execution execution = executionsToDeploy.get(i);
-            final ExecutionSlotAssignment assignment = executionSlotAssignments.get(i);
-            checkState(execution.getAttemptId().equals(assignment.getExecutionAttemptId()));
+        for (final Execution execution : executionsToDeploy) {
+            final ExecutionSlotAssignment assignment =
+                    checkNotNull(executionSlotAssignmentMap.get(execution.getAttemptId()));
 
             final ExecutionVertexID executionVertexId = execution.getVertex().getID();
             final ExecutionDeploymentHandle deploymentHandle =
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionSlotAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionSlotAllocator.java
index 526ebae99a4..569ec5fb5c8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionSlotAllocator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/ExecutionSlotAllocator.java
@@ -22,6 +22,7 @@ import org.apache.flink.runtime.executiongraph.Execution;
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
 
 import java.util.List;
+import java.util.Map;
 
 /** Component responsible for assigning slots to a collection of {@link Execution}. */
 public interface ExecutionSlotAllocator {
@@ -30,9 +31,10 @@ public interface ExecutionSlotAllocator {
      * Allocate slots for the given executions.
      *
      * @param executionAttemptIds executions to allocate slots for
-     * @return List of slot assignments to the executions
+     * @return Map of slot assignments to the executions
      */
-    List<ExecutionSlotAssignment> allocateSlotsFor(List<ExecutionAttemptID> executionAttemptIds);
+    Map<ExecutionAttemptID, ExecutionSlotAssignment> allocateSlotsFor(
+            List<ExecutionAttemptID> executionAttemptIds);
 
     /**
      * Cancel the ongoing slot request of the given {@link Execution}.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocator.java
index ca2a763296c..3ceb4b0ba35 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocator.java
@@ -74,9 +74,9 @@ public class SimpleExecutionSlotAllocator implements ExecutionSlotAllocator {
     }
 
     @Override
-    public List<ExecutionSlotAssignment> allocateSlotsFor(
+    public Map<ExecutionAttemptID, ExecutionSlotAssignment> allocateSlotsFor(
             List<ExecutionAttemptID> executionAttemptIds) {
-        List<ExecutionSlotAssignment> result = new ArrayList<>(executionAttemptIds.size());
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> result = new HashMap<>();
 
         Map<SlotRequestId, ExecutionAttemptID> remainingExecutionsToSlotRequest =
                 new HashMap<>(executionAttemptIds.size());
@@ -85,7 +85,8 @@ public class SimpleExecutionSlotAllocator implements ExecutionSlotAllocator {
 
         for (ExecutionAttemptID executionAttemptId : executionAttemptIds) {
             if (requestedPhysicalSlots.containsKeyA(executionAttemptId)) {
-                result.add(
+                result.put(
+                        executionAttemptId,
                         new ExecutionSlotAssignment(
                                 executionAttemptId,
                                 requestedPhysicalSlots.getValueByKeyA(executionAttemptId)));
@@ -111,16 +112,15 @@ public class SimpleExecutionSlotAllocator implements ExecutionSlotAllocator {
             }
         }
 
-        result.addAll(
+        result.putAll(
                 allocatePhysicalSlotsFor(remainingExecutionsToSlotRequest, physicalSlotRequests));
-
         return result;
     }
 
-    private List<ExecutionSlotAssignment> allocatePhysicalSlotsFor(
+    private Map<ExecutionAttemptID, ExecutionSlotAssignment> allocatePhysicalSlotsFor(
             Map<SlotRequestId, ExecutionAttemptID> executionAttemptIds,
             List<PhysicalSlotRequest> slotRequests) {
-        List<ExecutionSlotAssignment> allocatedSlots = new ArrayList<>();
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> allocatedSlots = new HashMap<>();
         Map<SlotRequestId, CompletableFuture<PhysicalSlotRequest.Result>> slotFutures =
                 slotProvider.allocatePhysicalSlots(slotRequests);
 
@@ -142,7 +142,9 @@ public class SimpleExecutionSlotAllocator implements ExecutionSlotAllocator {
                                 return null;
                             });
                     requestedPhysicalSlots.put(executionAttemptId, slotRequestId, slotFuture);
-                    allocatedSlots.add(new ExecutionSlotAssignment(executionAttemptId, slotFuture));
+                    allocatedSlots.put(
+                            executionAttemptId,
+                            new ExecutionSlotAssignment(executionAttemptId, slotFuture));
                 });
         return allocatedSlots;
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java
index 9be00e497df..ad8c8dd2f0a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java
@@ -102,7 +102,7 @@ class SlotSharingExecutionSlotAllocator implements ExecutionSlotAllocator {
     }
 
     @Override
-    public List<ExecutionSlotAssignment> allocateSlotsFor(
+    public Map<ExecutionAttemptID, ExecutionSlotAssignment> allocateSlotsFor(
             List<ExecutionAttemptID> executionAttemptIds) {
 
         final Map<ExecutionVertexID, ExecutionAttemptID> vertexIdToExecutionId = new HashMap<>();
@@ -120,13 +120,16 @@ class SlotSharingExecutionSlotAllocator implements ExecutionSlotAllocator {
                         .collect(Collectors.toList());
 
         return allocateSlotsForVertices(vertexIds).stream()
-                .map(
-                        vertexAssignment ->
-                                new ExecutionSlotAssignment(
+                .collect(
+                        Collectors.toMap(
+                                vertexAssignment ->
                                         vertexIdToExecutionId.get(
                                                 vertexAssignment.getExecutionVertexId()),
-                                        vertexAssignment.getLogicalSlotFuture()))
-                .collect(Collectors.toList());
+                                vertexAssignment ->
+                                        new ExecutionSlotAssignment(
+                                                vertexIdToExecutionId.get(
+                                                        vertexAssignment.getExecutionVertexId()),
+                                                vertexAssignment.getLogicalSlotFuture())));
     }
 
     /**
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocatorTest.java
index 8c8b4191f1d..d9a6081a6f2 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SimpleExecutionSlotAllocatorTest.java
@@ -288,7 +288,7 @@ class SimpleExecutionSlotAllocatorTest {
                 ExecutionAttemptID executionAttemptId) {
             return allocator
                     .allocateSlotsFor(Collections.singletonList(executionAttemptId))
-                    .get(0)
+                    .get(executionAttemptId)
                     .getLogicalSlotFuture();
         }
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java
index 277869fba3d..edab30c0afc 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java
@@ -103,9 +103,9 @@ class SlotSharingExecutionSlotAllocatorTest {
         AllocationContext context =
                 AllocationContext.newBuilder().addGroup(EV1, EV2).addGroup(EV3, EV4).build();
 
-        List<ExecutionSlotAssignment> executionSlotAssignments =
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> executionSlotAssignments =
                 context.allocateSlotsFor(EV1, EV2, EV3, EV4);
-        Collection<ExecutionVertexID> assignIds = getAssignIds(executionSlotAssignments);
+        Collection<ExecutionVertexID> assignIds = getAssignIds(executionSlotAssignments.values());
 
         assertThat(assignIds).containsExactlyInAnyOrder(EV1, EV2, EV3, EV4);
         assertThat(context.getSlotProvider().getRequests()).hasSize(2);
@@ -116,8 +116,9 @@ class SlotSharingExecutionSlotAllocatorTest {
         AllocationContext context = AllocationContext.newBuilder().addGroup(EV1, EV2).build();
 
         context.allocateSlotsFor(EV1);
-        List<ExecutionSlotAssignment> executionSlotAssignments = context.allocateSlotsFor(EV2);
-        Collection<ExecutionVertexID> assignIds = getAssignIds(executionSlotAssignments);
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> executionSlotAssignments =
+                context.allocateSlotsFor(EV2);
+        Collection<ExecutionVertexID> assignIds = getAssignIds(executionSlotAssignments.values());
 
         // execution 0 from the first allocateSlotsFor call and execution 1 from the second
         // allocateSlotsFor call
@@ -131,8 +132,10 @@ class SlotSharingExecutionSlotAllocatorTest {
             throws ExecutionException, InterruptedException {
         AllocationContext context = AllocationContext.newBuilder().addGroup(EV1).build();
 
-        ExecutionSlotAssignment assignment1 = context.allocateSlotsFor(EV1).get(0);
-        ExecutionSlotAssignment assignment2 = context.allocateSlotsFor(EV1).get(0);
+        ExecutionSlotAssignment assignment1 =
+                getAssignmentByExecutionVertexId(context.allocateSlotsFor(EV1), EV1);
+        ExecutionSlotAssignment assignment2 =
+                getAssignmentByExecutionVertexId(context.allocateSlotsFor(EV1), EV1);
 
         assertThat(assignment1.getLogicalSlotFuture().get())
                 .isSameAs(assignment2.getLogicalSlotFuture().get());
@@ -148,7 +151,8 @@ class SlotSharingExecutionSlotAllocatorTest {
                                         .createWithoutImmediatePhysicalSlotCreation())
                         .build();
         CompletableFuture<LogicalSlot> logicalSlotFuture =
-                context.allocateSlotsFor(EV1).get(0).getLogicalSlotFuture();
+                getAssignmentByExecutionVertexId(context.allocateSlotsFor(EV1), EV1)
+                        .getLogicalSlotFuture();
         SlotRequestId slotRequestId =
                 context.getSlotProvider().getFirstRequestOrFail().getSlotRequestId();
 
@@ -250,19 +254,20 @@ class SlotSharingExecutionSlotAllocatorTest {
         }
         AllocationContext context = allocationContextBuilder.build();
 
-        List<ExecutionSlotAssignment> assignments = context.allocateSlotsFor(EV1, EV2);
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> assignments =
+                context.allocateSlotsFor(EV1, EV2);
         assertThat(context.getSlotProvider().getRequests()).hasSize(1);
 
         // cancel or release only one sharing logical slots
-        cancelOrReleaseAction.accept(context, assignments.get(0));
-        List<ExecutionSlotAssignment> assignmentsAfterOneCancellation =
+        cancelOrReleaseAction.accept(context, getAssignmentByExecutionVertexId(assignments, EV1));
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> assignmentsAfterOneCancellation =
                 context.allocateSlotsFor(EV1, EV2);
         // there should be no more physical slot allocations, as the first logical slot reuses the
         // previous shared slot
         assertThat(context.getSlotProvider().getRequests()).hasSize(1);
 
         // cancel or release all sharing logical slots
-        for (ExecutionSlotAssignment assignment : assignmentsAfterOneCancellation) {
+        for (ExecutionSlotAssignment assignment : assignmentsAfterOneCancellation.values()) {
             cancelOrReleaseAction.accept(context, assignment);
         }
         SlotRequestId slotRequestId =
@@ -280,9 +285,10 @@ class SlotSharingExecutionSlotAllocatorTest {
     @Test
     void testPhysicalSlotReleaseLogicalSlots() throws ExecutionException, InterruptedException {
         AllocationContext context = AllocationContext.newBuilder().addGroup(EV1, EV2).build();
-        List<ExecutionSlotAssignment> assignments = context.allocateSlotsFor(EV1, EV2);
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> assignments =
+                context.allocateSlotsFor(EV1, EV2);
         List<TestingPayload> payloads =
-                assignments.stream()
+                assignments.values().stream()
                         .map(
                                 assignment -> {
                                     TestingPayload payload = new TestingPayload();
@@ -354,19 +360,24 @@ class SlotSharingExecutionSlotAllocatorTest {
         AllocationContext context = createBulkCheckerContextWithEv12GroupAndEv3Group(bulkChecker);
 
         // allocate 2 physical slots for 2 groups
-        List<ExecutionSlotAssignment> assignments1 = context.allocateSlotsFor(EV1, EV3);
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> assignments1 =
+                context.allocateSlotsFor(EV1, EV3);
         fulfilOneOfTwoSlotRequestsAndGetPendingProfile(context, new AllocationID());
         PhysicalSlotRequestBulk bulk1 = bulkChecker.getBulk();
-        List<ExecutionSlotAssignment> assignments2 = context.allocateSlotsFor(EV2);
+        Map<ExecutionAttemptID, ExecutionSlotAssignment> assignments2 =
+                context.allocateSlotsFor(EV2);
 
         // cancelling of (EV1, EV3) releases assignments1 and only one physical slot for EV3
         // the second physical slot is held by sharing EV2 from the next bulk
         bulk1.cancel(new Throwable());
 
         // return completed logical slot to clear shared slot and release physical slot
-        CompletableFuture<LogicalSlot> ev1slot = assignments1.get(0).getLogicalSlotFuture();
+        assertThat(assignments1).hasSize(2);
+        CompletableFuture<LogicalSlot> ev1slot =
+                getAssignmentByExecutionVertexId(assignments1, EV1).getLogicalSlotFuture();
         boolean ev1failed = ev1slot.isCompletedExceptionally();
-        CompletableFuture<LogicalSlot> ev3slot = assignments1.get(1).getLogicalSlotFuture();
+        CompletableFuture<LogicalSlot> ev3slot =
+                getAssignmentByExecutionVertexId(assignments1, EV3).getLogicalSlotFuture();
         boolean ev3failed = ev3slot.isCompletedExceptionally();
         LogicalSlot slot = ev1failed ? ev3slot.join() : ev1slot.join();
         releaseLogicalSlot(slot);
@@ -377,7 +388,9 @@ class SlotSharingExecutionSlotAllocatorTest {
         assertThat(context.getSlotProvider().getRequests()).hasSize(3);
         // either EV1 or EV3 logical slot future is fulfilled before cancellation
         assertThat(ev1failed).isNotEqualTo(ev3failed);
-        assertThat(assignments2.get(0).getLogicalSlotFuture()).isNotCompletedExceptionally();
+        assertThat(assignments2).hasSize(1);
+        assertThat(getAssignmentByExecutionVertexId(assignments2, EV2).getLogicalSlotFuture())
+                .isNotCompletedExceptionally();
     }
 
     private static void releaseLogicalSlot(LogicalSlot slot) {
@@ -415,9 +428,10 @@ class SlotSharingExecutionSlotAllocatorTest {
                                         new FlinkException("test failure")))
                         .build();
 
-        final List<ExecutionSlotAssignment> allocatedSlots = context.allocateSlotsFor(EV1, EV2);
+        final Map<ExecutionAttemptID, ExecutionSlotAssignment> allocatedSlots =
+                context.allocateSlotsFor(EV1, EV2);
 
-        for (ExecutionSlotAssignment allocatedSlot : allocatedSlots) {
+        for (ExecutionSlotAssignment allocatedSlot : allocatedSlots.values()) {
             assertThat(allocatedSlot.getLogicalSlotFuture()).isCompletedExceptionally();
         }
 
@@ -486,6 +500,16 @@ class SlotSharingExecutionSlotAllocatorTest {
         return requests.get(slotRequestId2).getSlotProfile().getPhysicalSlotResourceProfile();
     }
 
+    private static ExecutionSlotAssignment getAssignmentByExecutionVertexId(
+            Map<ExecutionAttemptID, ExecutionSlotAssignment> assignments,
+            ExecutionVertexID executionVertexId) {
+        return assignments.entrySet().stream()
+                .filter(entry -> entry.getKey().getExecutionVertexId().equals(executionVertexId))
+                .map(Map.Entry::getValue)
+                .collect(Collectors.toList())
+                .get(0);
+    }
+
     private static class AllocationContext {
         private final TestingPhysicalSlotProvider slotProvider;
         private final TestingSlotSharingStrategy slotSharingStrategy;
@@ -507,7 +531,8 @@ class SlotSharingExecutionSlotAllocatorTest {
             return allocator;
         }
 
-        private List<ExecutionSlotAssignment> allocateSlotsFor(ExecutionVertexID... ids) {
+        private Map<ExecutionAttemptID, ExecutionSlotAssignment> allocateSlotsFor(
+                ExecutionVertexID... ids) {
             return allocator.allocateSlotsFor(
                     Arrays.stream(ids)
                             .map(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestExecutionSlotAllocator.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestExecutionSlotAllocator.java
index cb36635d767..b8df3b971bb 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestExecutionSlotAllocator.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestExecutionSlotAllocator.java
@@ -64,32 +64,31 @@ public class TestExecutionSlotAllocator implements ExecutionSlotAllocator, SlotO
     }
 
     @Override
-    public List<ExecutionSlotAssignment> allocateSlotsFor(
+    public Map<ExecutionAttemptID, ExecutionSlotAssignment> allocateSlotsFor(
             final List<ExecutionAttemptID> executionAttemptIds) {
-        final List<ExecutionSlotAssignment> executionSlotAssignments =
+        final Map<ExecutionAttemptID, ExecutionSlotAssignment> executionSlotAssignments =
                 createExecutionSlotAssignments(executionAttemptIds);
         registerPendingRequests(executionSlotAssignments);
         maybeCompletePendingRequests();
         return executionSlotAssignments;
     }
 
-    private List<ExecutionSlotAssignment> createExecutionSlotAssignments(
+    private Map<ExecutionAttemptID, ExecutionSlotAssignment> createExecutionSlotAssignments(
             final List<ExecutionAttemptID> executionAttemptIds) {
 
-        final List<ExecutionSlotAssignment> result = new ArrayList<>();
+        final Map<ExecutionAttemptID, ExecutionSlotAssignment> result = new HashMap<>();
         for (ExecutionAttemptID executionAttemptId : executionAttemptIds) {
             final CompletableFuture<LogicalSlot> logicalSlotFuture = new CompletableFuture<>();
-            result.add(new ExecutionSlotAssignment(executionAttemptId, logicalSlotFuture));
+            result.put(
+                    executionAttemptId,
+                    new ExecutionSlotAssignment(executionAttemptId, logicalSlotFuture));
         }
         return result;
     }
 
     private void registerPendingRequests(
-            final List<ExecutionSlotAssignment> executionSlotAssignments) {
-        for (ExecutionSlotAssignment executionSlotAssignment : executionSlotAssignments) {
-            pendingRequests.put(
-                    executionSlotAssignment.getExecutionAttemptId(), executionSlotAssignment);
-        }
+            final Map<ExecutionAttemptID, ExecutionSlotAssignment> executionSlotAssignments) {
+        pendingRequests.putAll(executionSlotAssignments);
     }
 
     private void maybeCompletePendingRequests() {
