diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JMTMRegistrationRejection.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JMTMRegistrationRejection.java
new file mode 100644
index 00000000000..4fae37f873d
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JMTMRegistrationRejection.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.jobmaster;
+
+import org.apache.flink.runtime.registration.RegistrationResponse;
+
+/**
+ * Message indicating a registration rejection from the {@link JobMaster} for the {@link
+ * org.apache.flink.runtime.taskexecutor.TaskExecutor}.
+ */
+public class JMTMRegistrationRejection extends RegistrationResponse.Rejection {
+    private static final long serialVersionUID = -5763721635090700901L;
+
+    private final String reason;
+
+    public JMTMRegistrationRejection(String reason) {
+        this.reason = reason;
+    }
+
+    public String getReason() {
+        return reason;
+    }
+
+    @Override
+    public String toString() {
+        return "The JobManager has rejected the registration attempt because: " + reason;
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
index 0779caedeae..f61dd25ae75 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
@@ -663,6 +663,17 @@ public class JobMaster extends PermanentlyFencedRpcEndpoint<JobMasterId>
             final JobID jobId,
             final Time timeout) {
 
+        if (!jobGraph.getJobID().equals(jobId)) {
+            log.debug(
+                    "Rejecting TaskManager registration attempt because of wrong job id {}.",
+                    jobId);
+            return CompletableFuture.completedFuture(
+                    new JMTMRegistrationRejection(
+                            String.format(
+                                    "The JobManager is not responsible for job %s. Maybe the TaskManager used outdated connection information.",
+                                    jobId)));
+        }
+
         final TaskManagerLocation taskManagerLocation;
         try {
             if (retrieveTaskManagerHostName) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java
index 124ba3f111a..a5d206e37ca 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java
@@ -23,6 +23,7 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
+import org.apache.flink.runtime.jobmaster.JMTMRegistrationRejection;
 import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
@@ -234,7 +235,7 @@ public class DefaultJobLeaderService implements JobLeaderService {
                         JobMasterId,
                         JobMasterGateway,
                         JMTMRegistrationSuccess,
-                        RegistrationResponse.Rejection>
+                        JMTMRegistrationRejection>
                 rpcConnection;
 
         /** Leader id of the current job leader. */
@@ -378,7 +379,7 @@ public class DefaultJobLeaderService implements JobLeaderService {
                         JobMasterId,
                         JobMasterGateway,
                         JMTMRegistrationSuccess,
-                        RegistrationResponse.Rejection> {
+                        JMTMRegistrationRejection> {
 
             JobManagerRegisteredRpcConnection(
                     Logger log, String targetAddress, JobMasterId jobMasterId, Executor executor) {
@@ -390,7 +391,7 @@ public class DefaultJobLeaderService implements JobLeaderService {
                             JobMasterId,
                             JobMasterGateway,
                             JMTMRegistrationSuccess,
-                            RegistrationResponse.Rejection>
+                            JMTMRegistrationRejection>
                     generateRegistration() {
                 return new DefaultJobLeaderService.JobManagerRetryingRegistration(
                         LOG,
@@ -407,41 +408,67 @@ public class DefaultJobLeaderService implements JobLeaderService {
 
             @Override
             protected void onRegistrationSuccess(JMTMRegistrationSuccess success) {
-                // filter out old registration attempts
-                if (Objects.equals(getTargetLeaderId(), getCurrentJobMasterId())) {
-                    log.info(
-                            "Successful registration at job manager {} for job {}.",
-                            getTargetAddress(),
-                            jobId);
+                runIfValidRegistrationAttemptOrElse(
+                        () -> {
+                            log.info(
+                                    "Successful registration at job manager {} for job {}.",
+                                    getTargetAddress(),
+                                    jobId);
 
-                    jobLeaderListener.jobManagerGainedLeadership(
-                            jobId, getTargetGateway(), success);
-                } else {
-                    log.debug(
-                            "Encountered obsolete JobManager registration success from {} with leader session ID {}.",
-                            getTargetAddress(),
-                            getTargetLeaderId());
-                }
+                            jobLeaderListener.jobManagerGainedLeadership(
+                                    jobId, getTargetGateway(), success);
+                        },
+                        () ->
+                                log.debug(
+                                        "Encountered obsolete JobManager registration success from {} with leader session ID {}.",
+                                        getTargetAddress(),
+                                        getTargetLeaderId()));
             }
 
             @Override
-            protected void onRegistrationRejection(RegistrationResponse.Rejection rejection) {}
+            protected void onRegistrationRejection(JMTMRegistrationRejection rejection) {
+                runIfValidRegistrationAttemptOrElse(
+                        () -> {
+                            log.info(
+                                    "Rejected registration at job manager {} for job {}.",
+                                    getTargetAddress(),
+                                    jobId);
+
+                            jobLeaderListener.jobManagerRejectedRegistration(
+                                    jobId, getTargetAddress(), rejection);
+                        },
+                        () ->
+                                log.debug(
+                                        "Encountered obsolete JobManager registration rejection {} from {} with leader session ID {}.",
+                                        rejection,
+                                        getTargetAddress(),
+                                        getTargetLeaderId()));
+            }
 
             @Override
             protected void onRegistrationFailure(Throwable failure) {
-                // filter out old registration attempts
+                runIfValidRegistrationAttemptOrElse(
+                        () -> {
+                            log.info(
+                                    "Failed to register at job  manager {} for job {}.",
+                                    getTargetAddress(),
+                                    jobId);
+                            jobLeaderListener.handleError(failure);
+                        },
+                        () ->
+                                log.debug(
+                                        "Obsolete JobManager registration failure from {} with leader session ID {}.",
+                                        getTargetAddress(),
+                                        getTargetLeaderId(),
+                                        failure));
+            }
+
+            private void runIfValidRegistrationAttemptOrElse(
+                    Runnable runIfValid, Runnable runIfInvalid) {
                 if (Objects.equals(getTargetLeaderId(), getCurrentJobMasterId())) {
-                    log.info(
-                            "Failed to register at job  manager {} for job {}.",
-                            getTargetAddress(),
-                            jobId);
-                    jobLeaderListener.handleError(failure);
+                    runIfValid.run();
                 } else {
-                    log.debug(
-                            "Obsolete JobManager registration failure from {} with leader session ID {}.",
-                            getTargetAddress(),
-                            getTargetLeaderId(),
-                            failure);
+                    runIfInvalid.run();
                 }
             }
         }
@@ -453,7 +480,7 @@ public class DefaultJobLeaderService implements JobLeaderService {
                     JobMasterId,
                     JobMasterGateway,
                     JMTMRegistrationSuccess,
-                    RegistrationResponse.Rejection> {
+                    JMTMRegistrationRejection> {
 
         private final String taskManagerRpcAddress;
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/JobLeaderListener.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/JobLeaderListener.java
index 77b62a5a0fa..d9bf267b62a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/JobLeaderListener.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/JobLeaderListener.java
@@ -19,6 +19,7 @@
 package org.apache.flink.runtime.taskexecutor;
 
 import org.apache.flink.api.common.JobID;
+import org.apache.flink.runtime.jobmaster.JMTMRegistrationRejection;
 import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
@@ -58,4 +59,14 @@ public interface JobLeaderListener {
      * @param throwable cause
      */
     void handleError(Throwable throwable);
+
+    /**
+     * Callback if a job manager rejected the connection attempts of a task manager.
+     *
+     * @param jobId jobId identifying the job to connect to
+     * @param targetAddress targetAddress of the responsible job manager
+     * @param rejection rejection containing more information about the rejection
+     */
+    void jobManagerRejectedRegistration(
+            JobID jobId, String targetAddress, JMTMRegistrationRejection rejection);
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java
index be76511caf8..36f8ec7225d 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java
@@ -65,6 +65,7 @@ import org.apache.flink.runtime.jobgraph.tasks.InputSplitProvider;
 import org.apache.flink.runtime.jobgraph.tasks.TaskOperatorEventGateway;
 import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;
 import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;
+import org.apache.flink.runtime.jobmaster.JMTMRegistrationRejection;
 import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
@@ -1660,6 +1661,45 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
         jobManagerGateway.disconnectTaskManager(getResourceID(), cause);
     }
 
+    private void handleRejectedJobManagerConnection(
+            JobID jobId, String targetAddress, JMTMRegistrationRejection rejection) {
+        log.info(
+                "The JobManager under {} rejected the registration for job {}: {}. Releasing all job related resources.",
+                targetAddress,
+                jobId,
+                rejection.getReason());
+
+        releaseJobResources(
+                jobId,
+                new FlinkException(
+                        String.format("JobManager %s has rejected the registration.", jobId)));
+    }
+
+    private void releaseJobResources(JobID jobId, Exception cause) {
+        log.debug("Releasing job resources for job {}.", jobId, cause);
+
+        if (partitionTracker.isTrackingPartitionsFor(jobId)) {
+            // stop tracking job partitions
+            partitionTracker.stopTrackingAndReleaseJobPartitionsFor(jobId);
+        }
+
+        // free slots
+        final Set<AllocationID> allocationIds = taskSlotTable.getAllocationIdsPerJob(jobId);
+
+        if (!allocationIds.isEmpty()) {
+            for (AllocationID allocationId : allocationIds) {
+                freeSlotInternal(allocationId, cause);
+            }
+        }
+
+        jobLeaderService.removeJob(jobId);
+        jobTable.getJob(jobId)
+                .ifPresent(
+                        job -> {
+                            closeJob(job, cause);
+                        });
+    }
+
     private void scheduleResultPartitionCleanup(JobID jobId) {
         final Collection<CompletableFuture<ExecutionState>> taskTerminationFutures =
                 taskResultPartitionCleanupFuturesPerJob.remove(jobId);
@@ -1799,19 +1839,16 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
         if (taskSlotTable.getAllocationIdsPerJob(jobId).isEmpty()
                 && !partitionTracker.isTrackingPartitionsFor(jobId)) {
             // we can remove the job from the job leader service
-            jobLeaderService.removeJob(jobId);
 
-            jobTable.getJob(jobId)
-                    .ifPresent(
-                            job ->
-                                    closeJob(
-                                            job,
-                                            new FlinkException(
-                                                    "TaskExecutor "
-                                                            + getAddress()
-                                                            + " has no more allocated slots for job "
-                                                            + jobId
-                                                            + '.')));
+            final FlinkException cause =
+                    new FlinkException(
+                            "TaskExecutor "
+                                    + getAddress()
+                                    + " has no more allocated slots for job "
+                                    + jobId
+                                    + '.');
+
+            releaseJobResources(jobId, cause);
         }
     }
 
@@ -2066,6 +2103,12 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
         public void handleError(Throwable throwable) {
             onFatalError(throwable);
         }
+
+        @Override
+        public void jobManagerRejectedRegistration(
+                JobID jobId, String targetAddress, JMTMRegistrationRejection rejection) {
+            runAsync(() -> handleRejectedJobManagerConnection(jobId, targetAddress, rejection));
+        }
     }
 
     private final class ResourceManagerRegistrationListener
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
index bd8c98a991d..5b7c1e94395 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
@@ -1604,6 +1604,30 @@ public class JobMasterTest extends TestLogger {
                         });
     }
 
+    /**
+     * Tests that the JobMaster rejects a TaskExecutor registration attempt if the expected and
+     * actual JobID are not equal. See FLINK-21606.
+     */
+    @Test
+    public void testJobMasterRejectsTaskExecutorRegistrationIfJobIdsAreNotEqual() throws Exception {
+        final JobMaster jobMaster = new JobMasterBuilder(jobGraph, rpcService).createJobMaster();
+
+        try {
+            jobMaster.start();
+
+            final CompletableFuture<RegistrationResponse> registrationResponse =
+                    jobMaster.registerTaskManager(
+                            "foobar",
+                            new LocalUnresolvedTaskManagerLocation(),
+                            new JobID(),
+                            testingTimeout);
+
+            assertThat(registrationResponse.get(), instanceOf(JMTMRegistrationRejection.class));
+        } finally {
+            RpcUtils.terminateRpcEndpoint(jobMaster, testingTimeout);
+        }
+    }
+
     private void runJobFailureWhenTaskExecutorTerminatesTest(
             HeartbeatServices heartbeatServices,
             BiConsumer<LocalUnresolvedTaskManagerLocation, JobMasterGateway> jobReachedRunningState,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderServiceTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderServiceTest.java
index 1b484437d24..a5a53a3eeee 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderServiceTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderServiceTest.java
@@ -24,6 +24,7 @@ import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServicesBuilder;
+import org.apache.flink.runtime.jobmaster.JMTMRegistrationRejection;
 import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
@@ -242,6 +243,47 @@ public class DefaultJobLeaderServiceTest extends TestLogger {
         }
     }
 
+    @Test
+    public void rejectedJobManagerRegistrationCallsJobLeaderListener() throws Exception {
+        final SettableLeaderRetrievalService leaderRetrievalService =
+                new SettableLeaderRetrievalService();
+        final TestingHighAvailabilityServices haServices =
+                new TestingHighAvailabilityServicesBuilder()
+                        .setJobMasterLeaderRetrieverFunction(ignored -> leaderRetrievalService)
+                        .build();
+
+        final JobID jobId = new JobID();
+        final CompletableFuture<JobID> rejectedRegistrationFuture = new CompletableFuture<>();
+        final TestingJobLeaderListener testingJobLeaderListener =
+                new TestingJobLeaderListener(ignored -> {}, rejectedRegistrationFuture::complete);
+
+        final JobLeaderService jobLeaderService =
+                createAndStartJobLeaderService(haServices, testingJobLeaderListener);
+
+        final TestingJobMasterGateway jobMasterGateway =
+                new TestingJobMasterGatewayBuilder()
+                        .setRegisterTaskManagerFunction(
+                                (s, unresolvedTaskManagerLocation, jobID) ->
+                                        CompletableFuture.completedFuture(
+                                                new JMTMRegistrationRejection("foobar")))
+                        .build();
+
+        rpcServiceResource
+                .getTestingRpcService()
+                .registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);
+
+        try {
+            jobLeaderService.addJob(jobId, "foobar");
+
+            leaderRetrievalService.notifyListener(
+                    jobMasterGateway.getAddress(), jobMasterGateway.getFencingToken().toUUID());
+
+            assertThat(rejectedRegistrationFuture.get(), is(jobId));
+        } finally {
+            jobLeaderService.stop();
+        }
+    }
+
     private static final class FailingSettableLeaderRetrievalService
             extends SettableLeaderRetrievalService {
         @Override
@@ -281,12 +323,21 @@ public class DefaultJobLeaderServiceTest extends TestLogger {
 
         private final Consumer<JobID> jobManagerGainedLeadership;
 
+        private final Consumer<JobID> jobManagerRejectedRegistrationConsumer;
+
         private TestingJobLeaderListener() {
             this(ignored -> {});
         }
 
         private TestingJobLeaderListener(Consumer<JobID> jobManagerGainedLeadership) {
+            this(jobManagerGainedLeadership, ignored -> {});
+        }
+
+        private TestingJobLeaderListener(
+                Consumer<JobID> jobManagerGainedLeadership,
+                Consumer<JobID> jobManagerRejectedRegistrationConsumer) {
             this.jobManagerGainedLeadership = jobManagerGainedLeadership;
+            this.jobManagerRejectedRegistrationConsumer = jobManagerRejectedRegistrationConsumer;
         }
 
         @Override
@@ -307,6 +358,12 @@ public class DefaultJobLeaderServiceTest extends TestLogger {
             // ignored
         }
 
+        @Override
+        public void jobManagerRejectedRegistration(
+                JobID jobId, String targetAddress, JMTMRegistrationRejection rejection) {
+            jobManagerRejectedRegistrationConsumer.accept(jobId);
+        }
+
         private void waitUntilJobManagerLostLeadership() throws InterruptedException {
             jobManagerLostLeadership.await();
         }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
index f45acdc3cca..fc16e650372 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
@@ -58,9 +58,11 @@ import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionID;
 import org.apache.flink.runtime.io.network.partition.TaskExecutorPartitionTracker;
 import org.apache.flink.runtime.io.network.partition.TaskExecutorPartitionTrackerImpl;
+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;
 import org.apache.flink.runtime.jobgraph.IntermediateDataSetID;
 import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;
 import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;
+import org.apache.flink.runtime.jobmaster.JMTMRegistrationRejection;
 import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;
 import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;
 import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;
@@ -2120,6 +2122,91 @@ public class TaskExecutorTest extends TestLogger {
         closeHookLatch.await();
     }
 
+    /**
+     * Tests that the TaskExecutor releases all of its job resources if the JobMaster is not running
+     * the specified job. See FLINK-21606.
+     */
+    @Test
+    public void testReleaseOfJobResourcesIfJobMasterIsNotCorrect() throws Exception {
+        final TaskManagerServices taskManagerServices =
+                new TaskManagerServicesBuilder()
+                        .setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1))
+                        .build();
+
+        final TestingTaskExecutorPartitionTracker taskExecutorPartitionTracker =
+                new TestingTaskExecutorPartitionTracker();
+        final CompletableFuture<JobID> jobPartitionsReleaseFuture = new CompletableFuture<>();
+        // simulate that we have some partitions tracked
+        taskExecutorPartitionTracker.setIsTrackingPartitionsForFunction(ignored -> true);
+        taskExecutorPartitionTracker.setStopTrackingAndReleaseAllPartitionsConsumer(
+                jobPartitionsReleaseFuture::complete);
+
+        final TaskExecutor taskExecutor =
+                createTaskExecutor(
+                        taskManagerServices, HEARTBEAT_SERVICES, taskExecutorPartitionTracker);
+
+        final TestingJobMasterGateway jobMasterGateway =
+                new TestingJobMasterGatewayBuilder()
+                        .setRegisterTaskManagerFunction(
+                                (s, unresolvedTaskManagerLocation, jobID) ->
+                                        CompletableFuture.completedFuture(
+                                                new JMTMRegistrationRejection("foobar")))
+                        .build();
+
+        rpc.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);
+
+        final InstanceID registrationId = new InstanceID();
+        final OneShotLatch taskExecutorIsRegistered = new OneShotLatch();
+        final CompletableFuture<Tuple3<InstanceID, SlotID, AllocationID>> availableSlotFuture =
+                new CompletableFuture<>();
+        final TestingResourceManagerGateway resourceManagerGateway =
+                createRmWithTmRegisterAndNotifySlotHooks(
+                        registrationId, taskExecutorIsRegistered, availableSlotFuture);
+
+        rpc.registerGateway(resourceManagerGateway.getAddress(), resourceManagerGateway);
+
+        resourceManagerLeaderRetriever.notifyListener(
+                resourceManagerGateway.getAddress(),
+                resourceManagerGateway.getFencingToken().toUUID());
+
+        try {
+            taskExecutor.start();
+
+            final TaskExecutorGateway taskExecutorGateway =
+                    taskExecutor.getSelfGateway(TaskExecutorGateway.class);
+
+            taskExecutorIsRegistered.await();
+
+            final AllocationID allocationId = new AllocationID();
+            final SlotID slotId = new SlotID(taskExecutor.getResourceID(), 0);
+            final CompletableFuture<Acknowledge> requestSlotFuture =
+                    taskExecutorGateway.requestSlot(
+                            slotId,
+                            jobId,
+                            allocationId,
+                            ResourceProfile.UNKNOWN,
+                            jobMasterGateway.getAddress(),
+                            resourceManagerGateway.getFencingToken(),
+                            timeout);
+
+            assertThat(requestSlotFuture.get(), is(Acknowledge.get()));
+
+            // The JobManager should reject the registration which should release all job resources
+            // on the TaskExecutor
+            jobManagerLeaderRetriever.notifyListener(
+                    jobMasterGateway.getAddress(), jobMasterGateway.getFencingToken().toUUID());
+
+            // the slot should be freed
+            assertThat(availableSlotFuture.get().f1, is(slotId));
+            assertThat(availableSlotFuture.get().f2, is(allocationId));
+
+            // all job partitions should be released
+            assertThat(jobPartitionsReleaseFuture.get(), is(jobId));
+        } finally {
+            RpcUtils.terminateRpcEndpoint(taskExecutor, timeout);
+        }
+    }
+
     private TaskExecutorLocalStateStoresManager createTaskExecutorLocalStateStoresManager()
             throws IOException {
         return new TaskExecutorLocalStateStoresManager(
