diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java
index a2f30e9f64a..24ff9db5f04 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java
@@ -30,6 +30,7 @@ import org.apache.flink.runtime.state.SharedStateRegistryImpl.EmptyDiscardStateO
 import org.apache.flink.runtime.state.SharedStateRegistryKey;
 import org.apache.flink.runtime.state.StateObject;
 import org.apache.flink.runtime.state.StateUtil;
+import org.apache.flink.runtime.state.filemerging.FileMergingOperatorStreamStateHandle;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -225,6 +226,13 @@ public class OperatorSubtaskState implements CompositeStateHandle {
     public void registerSharedStates(SharedStateRegistry sharedStateRegistry, long checkpointID) {
         registerSharedState(sharedStateRegistry, managedKeyedState, checkpointID);
         registerSharedState(sharedStateRegistry, rawKeyedState, checkpointID);
+        registerFileMergingDirectoryHandle(
+                sharedStateRegistry,
+                managedOperatorState.stream()
+                        .filter(e -> e instanceof FileMergingOperatorStreamStateHandle)
+                        .map(e -> (FileMergingOperatorStreamStateHandle) e)
+                        .collect(Collectors.toList()),
+                checkpointID);
     }
 
     private static void registerSharedState(
@@ -245,6 +253,17 @@ public class OperatorSubtaskState implements CompositeStateHandle {
         }
     }
 
+    private static void registerFileMergingDirectoryHandle(
+            SharedStateRegistry sharedStateRegistry,
+            Iterable<FileMergingOperatorStreamStateHandle> stateHandles,
+            long checkpointID) {
+        for (FileMergingOperatorStreamStateHandle stateHandle : stateHandles) {
+            if (stateHandle != null) {
+                stateHandle.registerSharedStates(sharedStateRegistry, checkpointID);
+            }
+        }
+    }
+
     @Override
     public long getCheckpointedSize() {
         return checkpointedSize;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/filemerging/FileMergingOperatorStreamStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/filemerging/FileMergingOperatorStreamStateHandle.java
index 11cbefb664d..962121edae5 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/filemerging/FileMergingOperatorStreamStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/filemerging/FileMergingOperatorStreamStateHandle.java
@@ -21,7 +21,6 @@ package org.apache.flink.runtime.state.filemerging;
 import org.apache.flink.runtime.state.CompositeStateHandle;
 import org.apache.flink.runtime.state.OperatorStreamStateHandle;
 import org.apache.flink.runtime.state.SharedStateRegistry;
-import org.apache.flink.runtime.state.SharedStateRegistryKey;
 import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.util.Preconditions;
 
@@ -83,12 +82,9 @@ public class FileMergingOperatorStreamStateHandle extends OperatorStreamStateHan
         LOG.trace(
                 "Registering FileMergingOperatorStreamStateHandle for checkpoint {} from backend.",
                 checkpointId);
-        stateRegistry.registerReference(
-                new SharedStateRegistryKey(
-                        getDelegateStateHandle().getStreamStateHandleID().getKeyString()),
-                getDelegateStateHandle(),
-                checkpointId);
-
+        // Only register the directory here, leave the delegateStateHandle unregistered, since the
+        // OperatorSubtaskState will only take care of the keyed state while leaving others
+        // unregistered.
         stateRegistry.registerReference(
                 taskOwnedDirHandle.createStateRegistryKey(), taskOwnedDirHandle, checkpointId);
         stateRegistry.registerReference(
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/ResumeCheckpointManuallyITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/ResumeCheckpointManuallyITCase.java
index 9e862a8cc56..8f86af079d4 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/ResumeCheckpointManuallyITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/ResumeCheckpointManuallyITCase.java
@@ -404,7 +404,7 @@ public class ResumeCheckpointManuallyITCase extends TestLogger {
             throws Exception {
         // complete at least two checkpoints so that the initial checkpoint can be subsumed
         return runJobAndGetExternalizedCheckpoint(
-                backend, externalCheckpoint, cluster, restoreMode, new Configuration(), 2);
+                backend, externalCheckpoint, cluster, restoreMode, new Configuration(), 2, true);
     }
 
     static String runJobAndGetExternalizedCheckpoint(
@@ -413,9 +413,11 @@ public class ResumeCheckpointManuallyITCase extends TestLogger {
             MiniClusterWithClientResource cluster,
             RestoreMode restoreMode,
             Configuration jobConfig,
-            int consecutiveCheckpoints)
+            int consecutiveCheckpoints,
+            boolean retainCheckpoints)
             throws Exception {
-        JobGraph initialJobGraph = getJobGraph(backend, externalCheckpoint, restoreMode, jobConfig);
+        JobGraph initialJobGraph =
+                getJobGraph(backend, externalCheckpoint, restoreMode, jobConfig, retainCheckpoints);
         NotifyingInfiniteTupleSource.countDownLatch = new CountDownLatch(PARALLELISM);
         cluster.getClusterClient().submitJob(initialJobGraph).get();
 
@@ -439,7 +441,8 @@ public class ResumeCheckpointManuallyITCase extends TestLogger {
             StateBackend backend,
             @Nullable String externalCheckpoint,
             RestoreMode restoreMode,
-            Configuration jobConfig) {
+            Configuration jobConfig,
+            boolean retainCheckpoints) {
         final StreamExecutionEnvironment env =
                 StreamExecutionEnvironment.getExecutionEnvironment(jobConfig);
 
@@ -448,7 +451,9 @@ public class ResumeCheckpointManuallyITCase extends TestLogger {
         env.setParallelism(PARALLELISM);
         env.getCheckpointConfig()
                 .setExternalizedCheckpointRetention(
-                        ExternalizedCheckpointRetention.RETAIN_ON_CANCELLATION);
+                        retainCheckpoints
+                                ? ExternalizedCheckpointRetention.RETAIN_ON_CANCELLATION
+                                : ExternalizedCheckpointRetention.DELETE_ON_CANCELLATION);
         env.setRestartStrategy(RestartStrategies.noRestart());
 
         env.addSource(new NotifyingInfiniteTupleSource(10_000))
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/SnapshotFileMergingCompatibilityITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/SnapshotFileMergingCompatibilityITCase.java
index ed759673777..8379e4288ba 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/SnapshotFileMergingCompatibilityITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/SnapshotFileMergingCompatibilityITCase.java
@@ -22,6 +22,7 @@ import org.apache.flink.configuration.CheckpointingOptions;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.contrib.streaming.state.EmbeddedRocksDBStateBackend;
 import org.apache.flink.core.execution.RestoreMode;
+import org.apache.flink.core.fs.FileSystem;
 import org.apache.flink.runtime.checkpoint.OperatorState;
 import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
@@ -44,6 +45,8 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
+import static org.apache.flink.runtime.state.filesystem.AbstractFsCheckpointStorageAccess.CHECKPOINT_SHARED_STATE_DIR;
+import static org.apache.flink.runtime.state.filesystem.AbstractFsCheckpointStorageAccess.CHECKPOINT_TASK_OWNED_STATE_DIR;
 import static org.apache.flink.test.checkpointing.ResumeCheckpointManuallyITCase.runJobAndGetExternalizedCheckpoint;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -115,7 +118,8 @@ public class SnapshotFileMergingCompatibilityITCase extends TestLogger {
                             firstCluster,
                             restoreMode,
                             config,
-                            consecutiveCheckpoint);
+                            consecutiveCheckpoint,
+                            true);
             assertThat(firstCheckpoint).isNotNull();
             verifyStateHandleType(firstCheckpoint, firstFileMergingSwitch);
         } finally {
@@ -142,7 +146,8 @@ public class SnapshotFileMergingCompatibilityITCase extends TestLogger {
                             secondCluster,
                             restoreMode,
                             config,
-                            consecutiveCheckpoint);
+                            consecutiveCheckpoint,
+                            true);
             assertThat(secondCheckpoint).isNotNull();
             verifyStateHandleType(secondCheckpoint, secondFileMergingSwitch);
         } finally {
@@ -159,20 +164,58 @@ public class SnapshotFileMergingCompatibilityITCase extends TestLogger {
                                 .setNumberSlotsPerTaskManager(2)
                                 .build());
         thirdCluster.before();
+        String thirdCheckpoint;
         try {
-            String thirdCheckpoint =
+            thirdCheckpoint =
                     runJobAndGetExternalizedCheckpoint(
                             stateBackend3,
                             secondCheckpoint,
                             thirdCluster,
                             restoreMode,
                             config,
-                            consecutiveCheckpoint);
+                            consecutiveCheckpoint,
+                            true);
             assertThat(thirdCheckpoint).isNotNull();
             verifyStateHandleType(thirdCheckpoint, secondFileMergingSwitch);
         } finally {
             thirdCluster.after();
         }
+
+        // We config ExternalizedCheckpointRetention.DELETE_ON_CANCELLATION here.
+        EmbeddedRocksDBStateBackend stateBackend4 = new EmbeddedRocksDBStateBackend();
+        stateBackend4.configure(config, Thread.currentThread().getContextClassLoader());
+        MiniClusterWithClientResource fourthCluster =
+                new MiniClusterWithClientResource(
+                        new MiniClusterResourceConfiguration.Builder()
+                                .setConfiguration(config)
+                                .setNumberTaskManagers(3)
+                                .setNumberSlotsPerTaskManager(2)
+                                .build());
+        fourthCluster.before();
+        String fourthCheckpoint;
+        try {
+            fourthCheckpoint =
+                    runJobAndGetExternalizedCheckpoint(
+                            stateBackend4,
+                            thirdCheckpoint,
+                            fourthCluster,
+                            restoreMode,
+                            config,
+                            consecutiveCheckpoint,
+                            false);
+            assertThat(fourthCheckpoint).isNotNull();
+        } finally {
+            fourthCluster.after();
+        }
+
+        waitUntilNoJobThreads();
+        verifyCheckpointExist(
+                firstCheckpoint, restoreMode != RestoreMode.CLAIM, firstFileMergingSwitch);
+        verifyCheckpointExist(
+                secondCheckpoint, restoreMode != RestoreMode.CLAIM, secondFileMergingSwitch);
+        verifyCheckpointExist(
+                thirdCheckpoint, restoreMode != RestoreMode.CLAIM, secondFileMergingSwitch);
+        verifyCheckpointExist(fourthCheckpoint, false, secondFileMergingSwitch);
     }
 
     private void verifyStateHandleType(String checkpointPath, boolean fileMergingEnabled)
@@ -205,4 +248,49 @@ public class SnapshotFileMergingCompatibilityITCase extends TestLogger {
         }
         assertThat(hasKeyedState).isTrue();
     }
+
+    private static void waitUntilNoJobThreads() throws InterruptedException {
+        SecurityManager securityManager = System.getSecurityManager();
+        ThreadGroup group =
+                (securityManager != null)
+                        ? securityManager.getThreadGroup()
+                        : Thread.currentThread().getThreadGroup();
+
+        boolean jobThreads = true;
+        while (jobThreads) {
+            jobThreads = false;
+            Thread[] activeThreads = new Thread[group.activeCount() * 2];
+            group.enumerate(activeThreads);
+            for (Thread thread : activeThreads) {
+                if (thread != null
+                        && thread != Thread.currentThread()
+                        && thread.getName().contains("jobmanager")) {
+                    jobThreads = true;
+                    Thread.sleep(500);
+                    break;
+                }
+            }
+        }
+    }
+
+    private void verifyCheckpointExist(
+            String checkpointPath, boolean exist, boolean fileMergingEnabled) throws IOException {
+        org.apache.flink.core.fs.Path checkpointDir =
+                new org.apache.flink.core.fs.Path(checkpointPath);
+        FileSystem fs = checkpointDir.getFileSystem();
+        assertThat(fs.exists(checkpointDir)).isEqualTo(exist);
+        org.apache.flink.core.fs.Path baseDir = checkpointDir.getParent();
+        assertThat(fs.exists(baseDir)).isTrue();
+        org.apache.flink.core.fs.Path sharedFile =
+                new org.apache.flink.core.fs.Path(baseDir, CHECKPOINT_SHARED_STATE_DIR);
+        assertThat(fs.exists(sharedFile)).isTrue();
+        assertThat(fs.listStatus(sharedFile) != null && fs.listStatus(sharedFile).length > 0)
+                .isEqualTo(exist);
+        org.apache.flink.core.fs.Path taskOwnedFile =
+                new org.apache.flink.core.fs.Path(baseDir, CHECKPOINT_TASK_OWNED_STATE_DIR);
+        assertThat(fs.exists(taskOwnedFile)).isTrue();
+        // Since there is no exclusive state, we should consider fileMergingEnabled.
+        assertThat(fs.exists(taskOwnedFile) && fs.listStatus(taskOwnedFile).length > 0)
+                .isEqualTo(exist && fileMergingEnabled);
+    }
 }
