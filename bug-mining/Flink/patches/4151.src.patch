diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java
index 6a2b68d8510..97d16257be3 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java
@@ -25,6 +25,7 @@ import org.apache.flink.runtime.state.CheckpointStreamFactory.CheckpointStateOut
 import org.apache.flink.runtime.state.InputChannelStateHandle;
 import org.apache.flink.runtime.state.ResultSubpartitionStateHandle;
 import org.apache.flink.runtime.state.StreamStateHandle;
+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.function.RunnableWithException;
 
@@ -40,10 +41,12 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
-import java.util.function.BiFunction;
 
 import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
+import static java.util.UUID.randomUUID;
 import static org.apache.flink.runtime.state.CheckpointedStateScope.EXCLUSIVE;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
@@ -159,14 +162,8 @@ class ChannelStateCheckpointWriter {
 		}
 		dataStream.flush();
 		StreamStateHandle underlying = checkpointStream.closeAndGetHandle();
-		complete(
-				result.inputChannelStateHandles,
-				inputChannelOffsets,
-				(chan, offsets) -> new InputChannelStateHandle(chan, underlying, offsets));
-		complete(
-				result.resultSubpartitionStateHandles,
-				resultSubpartitionOffsets,
-				(chan, offsets) -> new ResultSubpartitionStateHandle(chan, underlying, offsets));
+		complete(underlying, result.inputChannelStateHandles, inputChannelOffsets, HandleFactory.INPUT_CHANNEL);
+		complete(underlying, result.resultSubpartitionStateHandles, resultSubpartitionOffsets, HandleFactory.RESULT_SUBPARTITION);
 	}
 
 	private void doComplete(boolean precondition, RunnableWithException complete, RunnableWithException... callbacks) throws Exception {
@@ -180,17 +177,34 @@ class ChannelStateCheckpointWriter {
 	}
 
 	private <I, H extends AbstractChannelStateHandle<I>> void complete(
+			StreamStateHandle underlying,
 			CompletableFuture<Collection<H>> future,
 			Map<I, List<Long>> offsets,
-			BiFunction<I, List<Long>, H> buildHandle) {
+			HandleFactory<I, H> handleFactory) throws IOException {
 		final Collection<H> handles = new ArrayList<>();
 		for (Map.Entry<I, List<Long>> e : offsets.entrySet()) {
-			handles.add(buildHandle.apply(e.getKey(), e.getValue()));
+			handles.add(createHandle(handleFactory, underlying, e.getKey(), e.getValue()));
 		}
 		future.complete(handles);
 		LOG.debug("channel state write completed, checkpointId: {}, handles: {}", checkpointId, handles);
 	}
 
+	private <I, H extends AbstractChannelStateHandle<I>> H createHandle(
+			HandleFactory<I, H> handleFactory,
+			StreamStateHandle underlying,
+			I channelInfo,
+			List<Long> offsets) throws IOException {
+		Optional<byte[]> bytes = underlying.asBytesIfInMemory(); // todo: consider restructuring channel state and removing this method: https://issues.apache.org/jira/browse/FLINK-17972
+		if (bytes.isPresent()) {
+			return handleFactory.create(
+				channelInfo,
+				new ByteStreamStateHandle(randomUUID().toString(), serializer.extractAndMerge(bytes.get(), offsets)),
+				singletonList(serializer.getHeaderLength()));
+		} else {
+			return handleFactory.create(channelInfo, underlying, offsets);
+		}
+	}
+
 	private void runWithChecks(RunnableWithException r) throws Exception {
 		try {
 			checkState(!result.isDone(), "result is already completed", result);
@@ -206,4 +220,11 @@ class ChannelStateCheckpointWriter {
 		checkpointStream.close();
 	}
 
+	private interface HandleFactory<I, H extends AbstractChannelStateHandle<I>> {
+		H create(I info, StreamStateHandle underlying, List<Long> offsets);
+
+		HandleFactory<InputChannelInfo, InputChannelStateHandle> INPUT_CHANNEL = InputChannelStateHandle::new;
+
+		HandleFactory<ResultSubpartitionInfo, ResultSubpartitionStateHandle> RESULT_SUBPARTITION = ResultSubpartitionStateHandle::new;
+	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java
index 2d1184ec727..e9bb317cc2b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java
@@ -26,10 +26,13 @@ import org.apache.flink.shaded.netty4.io.netty.buffer.ByteBuf;
 
 import javax.annotation.concurrent.NotThreadSafe;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.List;
 
 import static java.lang.Math.addExact;
 import static java.lang.Math.min;
@@ -45,6 +48,10 @@ interface ChannelStateSerializer {
 	int readLength(InputStream stream) throws IOException;
 
 	int readData(InputStream stream, ChannelStateByteBuffer buffer, int bytes) throws IOException;
+
+	byte[] extractAndMerge(byte[] bytes, List<Long> offsets) throws IOException;
+
+	long getHeaderLength();
 }
 
 /**
@@ -171,4 +178,35 @@ class ChannelStateSerializerImpl implements ChannelStateSerializer {
 	private static int readInt(InputStream stream) throws IOException {
 		return new DataInputStream(stream).readInt();
 	}
+
+	@Override
+	public byte[] extractAndMerge(byte[] bytes, List<Long> offsets) throws IOException {
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		DataOutputStream dataOutputStream = new DataOutputStream(out);
+		byte[] merged = extractByOffsets(bytes, offsets);
+		writeHeader(dataOutputStream);
+		dataOutputStream.writeInt(merged.length);
+		dataOutputStream.write(merged, 0, merged.length);
+		dataOutputStream.close();
+		return out.toByteArray();
+	}
+
+	private byte[] extractByOffsets(byte[] data, List<Long> offsets) throws IOException {
+		DataInputStream lengthReadingStream = new DataInputStream(new ByteArrayInputStream(data, 0, data.length));
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		long prevOffset = 0;
+		for (long offset : offsets) {
+			lengthReadingStream.skipBytes((int) (offset - prevOffset));
+			int dataWithLengthOffset = (int) offset + Integer.BYTES;
+			out.write(data, dataWithLengthOffset, lengthReadingStream.readInt());
+			prevOffset = dataWithLengthOffset;
+		}
+		return out.toByteArray();
+	}
+
+	@Override
+	public long getHeaderLength() {
+		return Integer.BYTES;
+	}
+
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyGroupsStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyGroupsStateHandle.java
index f78ec51d071..34ef88eb452 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyGroupsStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/KeyGroupsStateHandle.java
@@ -23,6 +23,7 @@ import org.apache.flink.core.fs.FSDataInputStream;
 import org.apache.flink.util.Preconditions;
 
 import java.io.IOException;
+import java.util.Optional;
 
 /**
  * A handle to the partitioned stream operator state after it has been checkpointed. This state
@@ -117,6 +118,11 @@ public class KeyGroupsStateHandle implements StreamStateHandle, KeyedStateHandle
 		return stateHandle.openInputStream();
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		return stateHandle.asBytesIfInMemory();
+	}
+
 	@Override
 	public boolean equals(Object o) {
 		if (this == o) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/OperatorStreamStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/OperatorStreamStateHandle.java
index 39008345bd8..4b3a53cf545 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/OperatorStreamStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/OperatorStreamStateHandle.java
@@ -23,6 +23,7 @@ import org.apache.flink.util.Preconditions;
 
 import java.io.IOException;
 import java.util.Map;
+import java.util.Optional;
 
 /**
  * State handle for partitionable operator state. Besides being a {@link StreamStateHandle}, this also provides a
@@ -66,6 +67,11 @@ public class OperatorStreamStateHandle implements OperatorStateHandle {
 		return delegateStateHandle.openInputStream();
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		return delegateStateHandle.asBytesIfInMemory();
+	}
+
 	@Override
 	public StreamStateHandle getDelegateStateHandle() {
 		return delegateStateHandle;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/PlaceholderStreamStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/PlaceholderStreamStateHandle.java
index 17f1d004186..ad022fec081 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/PlaceholderStreamStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/PlaceholderStreamStateHandle.java
@@ -21,6 +21,8 @@ package org.apache.flink.runtime.state;
 import org.apache.flink.core.fs.FSDataInputStream;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 
+import java.util.Optional;
+
 /**
  * A placeholder state handle for shared state that will replaced by an original that was
  * created in a previous checkpoint. So we don't have to send a state handle twice, e.g. in
@@ -40,6 +42,12 @@ public class PlaceholderStreamStateHandle implements StreamStateHandle {
 			"This is only a placeholder to be replaced by a real StreamStateHandle in the checkpoint coordinator.");
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		throw new UnsupportedOperationException(
+				"This is only a placeholder to be replaced by a real StreamStateHandle in the checkpoint coordinator.");
+	}
+
 	@Override
 	public void discardState() throws Exception {
 		// nothing to do.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RetrievableStreamStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RetrievableStreamStateHandle.java
index 6ed60faa4c2..6c4d2584b24 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/RetrievableStreamStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/RetrievableStreamStateHandle.java
@@ -27,6 +27,7 @@ import org.apache.flink.util.Preconditions;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.Serializable;
+import java.util.Optional;
 
 /**
  * Wrapper around a {@link StreamStateHandle} to make the referenced state object retrievable trough a simple get call.
@@ -64,6 +65,11 @@ public class RetrievableStreamStateHandle<T extends Serializable> implements
 		return wrappedStreamStateHandle.openInputStream();
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		return wrappedStreamStateHandle.asBytesIfInMemory();
+	}
+
 	@Override
 	public void discardState() throws Exception {
 		wrappedStreamStateHandle.discardState();
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/StreamStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/StreamStateHandle.java
index e792e62563f..2e86500f4a4 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/StreamStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/StreamStateHandle.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.state;
 import org.apache.flink.core.fs.FSDataInputStream;
 
 import java.io.IOException;
+import java.util.Optional;
 
 /**
  * A {@link StateObject} that represents state that was written to a stream. The data can be read
@@ -33,4 +34,9 @@ public interface StreamStateHandle extends StateObject {
 	 * was previously written to the stream.
 	 */
 	FSDataInputStream openInputStream() throws IOException;
+
+	/**
+	 * @return Content of this handle as bytes array if it is already in memory.
+	 */
+	Optional<byte[]> asBytesIfInMemory();
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/filesystem/FileStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/filesystem/FileStateHandle.java
index 18eb4796133..8ea576d338a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/filesystem/FileStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/filesystem/FileStateHandle.java
@@ -24,6 +24,7 @@ import org.apache.flink.core.fs.Path;
 import org.apache.flink.runtime.state.StreamStateHandle;
 
 import java.io.IOException;
+import java.util.Optional;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -68,6 +69,11 @@ public class FileStateHandle implements StreamStateHandle {
 		return getFileSystem().open(filePath);
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		return Optional.empty();
+	}
+
 	/**
 	 * Discard the state by deleting the file that stores the state. If the parent directory
 	 * of the state is empty after deleting the state file, it is also deleted.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/memory/ByteStreamStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/memory/ByteStreamStateHandle.java
index 05d20ddacf2..19dc6d40d30 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/memory/ByteStreamStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/memory/ByteStreamStateHandle.java
@@ -23,6 +23,7 @@ import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.util.Preconditions;
 
 import java.io.IOException;
+import java.util.Optional;
 
 /**
  * A state handle that contains stream state in a byte array.
@@ -55,6 +56,11 @@ public class ByteStreamStateHandle implements StreamStateHandle {
 		return new ByteStateHandleInputStream(data);
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		return Optional.of(getData());
+	}
+
 	public byte[] getData() {
 		return data;
 	}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriterTest.java
index e9222297c2e..91b5f9f7c19 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriterTest.java
@@ -42,6 +42,7 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.Random;
 
+import static java.util.Collections.singletonList;
 import static org.apache.flink.core.fs.Path.fromLocalFile;
 import static org.apache.flink.core.fs.local.LocalFileSystem.getSharedInstance;
 import static org.apache.flink.core.memory.MemorySegmentFactory.wrap;
@@ -151,19 +152,23 @@ public class ChannelStateCheckpointWriterTest {
 		offsetCounts.put(new InputChannelInfo(1, 1), 1);
 		offsetCounts.put(new InputChannelInfo(1, 2), 2);
 		offsetCounts.put(new InputChannelInfo(1, 3), 5);
+		int numBytes = 100;
 
 		ChannelStateWriteResult result = new ChannelStateWriteResult();
 		ChannelStateCheckpointWriter writer = createWriter(result);
 		for (Map.Entry<InputChannelInfo, Integer> e : offsetCounts.entrySet()) {
 			for (int i = 0; i < e.getValue(); i++) {
-				write(writer, e.getKey(), getData(100));
+				write(writer, e.getKey(), getData(numBytes));
 			}
 		}
 		writer.completeInput();
 		writer.completeOutput();
 
 		for (InputChannelStateHandle handle : result.inputChannelStateHandles.get()) {
-			assertEquals(handle.getOffsets().size(), (int) offsetCounts.remove(handle.getInfo()));
+			int headerSize = Integer.BYTES;
+			int lengthSize = Integer.BYTES;
+			assertEquals(singletonList((long) headerSize), handle.getOffsets());
+			assertEquals(headerSize + lengthSize + numBytes * offsetCounts.remove(handle.getInfo()), handle.getDelegate().getStateSize());
 		}
 		assertTrue(offsetCounts.isEmpty());
 	}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/messages/CheckpointMessagesTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/messages/CheckpointMessagesTest.java
index 1596e9b98e1..262c86940fe 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/messages/CheckpointMessagesTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/messages/CheckpointMessagesTest.java
@@ -37,6 +37,7 @@ import org.junit.Test;
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.Collections;
+import java.util.Optional;
 import java.util.Random;
 
 import static org.apache.flink.runtime.checkpoint.StateHandleDummyUtil.createNewInputChannelStateHandle;
@@ -126,5 +127,10 @@ public class CheckpointMessagesTest {
 		public FSDataInputStream openInputStream() throws IOException {
 			return null;
 		}
+
+		@Override
+		public Optional<byte[]> asBytesIfInMemory() {
+			return Optional.empty();
+		}
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
index 6272473f4d1..f5e783928fa 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.core.fs.FSDataInputStream;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.util.Optional;
 
 import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.assertEquals;
@@ -126,6 +127,11 @@ public class SharedStateRegistryTest {
 			throw new UnsupportedOperationException();
 		}
 
+		@Override
+		public Optional<byte[]> asBytesIfInMemory() {
+			return Optional.empty();
+		}
+
 		public boolean isDiscarded() {
 			return discarded;
 		}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/testutils/EmptyStreamStateHandle.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/testutils/EmptyStreamStateHandle.java
index 3dad0109725..b4c49936bf8 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/testutils/EmptyStreamStateHandle.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/testutils/EmptyStreamStateHandle.java
@@ -22,6 +22,7 @@ import org.apache.flink.core.fs.FSDataInputStream;
 import org.apache.flink.runtime.state.StreamStateHandle;
 
 import java.io.IOException;
+import java.util.Optional;
 
 /**
  * A simple dummy implementation of a stream state handle that can be passed in tests.
@@ -61,6 +62,11 @@ public class EmptyStreamStateHandle implements StreamStateHandle {
 		};
 	}
 
+	@Override
+	public Optional<byte[]> asBytesIfInMemory() {
+		return Optional.empty();
+	}
+
 	@Override
 	public void discardState() throws Exception {
 		disposed = true;
diff --git a/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java b/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java
index 897b855e51b..d4ab10dc26b 100644
--- a/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java
+++ b/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java
@@ -39,6 +39,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Random;
 import java.util.UUID;
 
@@ -65,6 +66,11 @@ public class RocksDBStateDownloaderTest extends TestLogger {
 				throw expectedException;
 			}
 
+			@Override
+			public Optional<byte[]> asBytesIfInMemory() {
+				return Optional.empty();
+			}
+
 			@Override
 			public void discardState() {
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java
index d7009209360..1b16f2f8838 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/InterruptSensitiveRestoreTest.java
@@ -88,6 +88,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.concurrent.Executor;
 
 import static org.junit.Assert.assertEquals;
@@ -328,6 +329,11 @@ public class InterruptSensitiveRestoreTest {
 			return is;
 		}
 
+		@Override
+		public Optional<byte[]> asBytesIfInMemory() {
+			return Optional.empty();
+		}
+
 		private void block() {
 			IN_RESTORE_LATCH.trigger();
 			// this mimics what happens in the HDFS client code.
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index b5031b374ab..e46dc0b6ace 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -1778,6 +1778,11 @@ public class StreamTaskTest extends TestLogger {
 			throw new IOException("Cannot open input streams in testing implementation.");
 		}
 
+		@Override
+		public Optional<byte[]> asBytesIfInMemory() {
+			return Optional.empty();
+		}
+
 		@Override
 		public StreamStateHandle getDelegateStateHandle() {
 			throw new UnsupportedOperationException("Not implemented.");
