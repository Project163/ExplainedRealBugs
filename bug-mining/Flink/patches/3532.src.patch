diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/api/NoMatchingTableFactoryException.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/api/NoMatchingTableFactoryException.java
index daf7c78cc8f..c1911bad8fa 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/api/NoMatchingTableFactoryException.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/api/NoMatchingTableFactoryException.java
@@ -21,6 +21,8 @@ package org.apache.flink.table.api;
 import org.apache.flink.table.descriptors.DescriptorProperties;
 import org.apache.flink.table.factories.TableFactory;
 
+import javax.annotation.Nullable;
+
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
@@ -32,6 +34,9 @@ public class NoMatchingTableFactoryException extends RuntimeException {
 
 	// message that indicates the current matching step
 	private final String message;
+	// message that indicates the best matched factory
+	@Nullable
+	private final String matchCandidatesMessage;
 	// required factory class
 	private final Class<?> factoryClass;
 	// all found factories
@@ -41,6 +46,7 @@ public class NoMatchingTableFactoryException extends RuntimeException {
 
 	public NoMatchingTableFactoryException(
 		String message,
+		@Nullable String matchCandidatesMessage,
 		Class<?> factoryClass,
 		List<TableFactory> factories,
 		Map<String, String> properties,
@@ -48,6 +54,7 @@ public class NoMatchingTableFactoryException extends RuntimeException {
 
 		super(cause);
 		this.message = message;
+		this.matchCandidatesMessage = matchCandidatesMessage;
 		this.factoryClass = factoryClass;
 		this.factories = factories;
 		this.properties = properties;
@@ -58,24 +65,33 @@ public class NoMatchingTableFactoryException extends RuntimeException {
 		Class<?> factoryClass,
 		List<TableFactory> factories,
 		Map<String, String> properties) {
+		this(message, null, factoryClass, factories, properties, null);
+	}
 
-		this(message, factoryClass, factories, properties, null);
+	public NoMatchingTableFactoryException(
+		String message,
+		@Nullable String matchCandidatesMessage,
+		Class<?> factoryClass,
+		List<TableFactory> factories,
+		Map<String, String> properties) {
+		this(message, matchCandidatesMessage, factoryClass, factories, properties, null);
 	}
 
 	@Override
 	public String getMessage() {
+		String matchCandidatesString = matchCandidatesMessage == null ?
+			"" :
+			"The matching candidates:\n" + matchCandidatesMessage + "\n\n";
 		return String.format(
 			"Could not find a suitable table factory for '%s' in\nthe classpath.\n\n" +
-				"Reason: %s\n\n" +
+				"Reason: %s\n\n%s" +
 				"The following properties are requested:\n%s\n\n" +
 				"The following factories have been considered:\n%s",
 			factoryClass.getName(),
 			message,
+			matchCandidatesString,
 			DescriptorProperties.toString(properties),
-			String.join(
-				"\n",
-				factories.stream().map(p -> p.getClass().getName()).collect(Collectors.toList())
-			)
+			factories.stream().map(p -> p.getClass().getName()).collect(Collectors.joining("\n"))
 		);
 	}
 }
diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/TableFactoryService.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/TableFactoryService.java
index d297ce0c1ed..f3949678c28 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/TableFactoryService.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/TableFactoryService.java
@@ -30,10 +30,12 @@ import org.apache.flink.util.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.ServiceConfigurationError;
 import java.util.ServiceLoader;
@@ -189,13 +191,12 @@ public class TableFactoryService {
 		List<T> contextFactories = filterByContext(
 			factoryClass,
 			properties,
-			foundFactories,
 			classFactories);
 
 		return filterBySupportedProperties(
 			factoryClass,
 			properties,
-			foundFactories,
+			classFactories,
 			contextFactories);
 	}
 
@@ -255,10 +256,11 @@ public class TableFactoryService {
 	private static <T extends TableFactory> List<T> filterByContext(
 			Class<T> factoryClass,
 			Map<String, String> properties,
-			List<TableFactory> foundFactories,
 			List<T> classFactories) {
 
-		List<T> matchingFactories = classFactories.stream().filter(factory -> {
+		List<T> matchingFactories = new ArrayList<>();
+		ContextBestMatched<T> bestMatched = null;
+		for (T factory : classFactories) {
 			Map<String, String> requestedContext = normalizeContext(factory);
 
 			Map<String, String> plainContext = new HashMap<>(requestedContext);
@@ -269,22 +271,97 @@ public class TableFactoryService {
 			plainContext.remove(CATALOG_PROPERTY_VERSION);
 
 			// check if required context is met
-			return plainContext.keySet()
-				.stream()
-				.allMatch(e -> properties.containsKey(e) && properties.get(e).equals(plainContext.get(e)));
-		}).collect(Collectors.toList());
+			Map<String, Tuple2<String, String>> mismatchedProperties = new HashMap<>();
+			Map<String, String> missingProperties = new HashMap<>();
+			for (Map.Entry<String, String> e : plainContext.entrySet()) {
+				if (properties.containsKey(e.getKey())) {
+					String fromProperties = properties.get(e.getKey());
+					if (!Objects.equals(fromProperties, e.getValue())) {
+						mismatchedProperties.put(e.getKey(), new Tuple2<>(e.getValue(), fromProperties));
+					}
+				} else {
+					missingProperties.put(e.getKey(), e.getValue());
+				}
+			}
+			int matchedSize = plainContext.size() - mismatchedProperties.size() - missingProperties.size();
+			if (matchedSize == plainContext.size()) {
+				matchingFactories.add(factory);
+			} else {
+				if (bestMatched == null || matchedSize > bestMatched.matchedSize) {
+					bestMatched = new ContextBestMatched<>(
+							factory, matchedSize, mismatchedProperties, missingProperties);
+				}
+			}
+		}
 
 		if (matchingFactories.isEmpty()) {
+			String bestMatchedMessage = null;
+			if (bestMatched != null && bestMatched.matchedSize > 0) {
+				StringBuilder builder = new StringBuilder();
+				builder.append(bestMatched.factory.getClass().getName());
+
+				if (bestMatched.missingProperties.size() > 0) {
+					builder.append("\nMissing properties:");
+					bestMatched.missingProperties.forEach((k, v) ->
+							builder.append("\n").append(k).append("=").append(v));
+				}
+
+				if (bestMatched.mismatchedProperties.size() > 0) {
+					builder.append("\nMismatched properties:");
+					bestMatched.mismatchedProperties
+						.entrySet()
+						.stream()
+						.filter(e -> e.getValue().f1 != null)
+						.forEach(e -> builder.append(
+							String.format(
+								"\n'%s' expects '%s', but is '%s'",
+								e.getKey(),
+								e.getValue().f0,
+								e.getValue().f1)));
+				}
+
+				bestMatchedMessage = builder.toString();
+			}
+			//noinspection unchecked
 			throw new NoMatchingTableFactoryException(
-				"No context matches.",
+				"Required context properties mismatch.",
+				bestMatchedMessage,
 				factoryClass,
-				foundFactories,
+				(List<TableFactory>) classFactories,
 				properties);
 		}
 
 		return matchingFactories;
 	}
 
+	private static class ContextBestMatched<T extends TableFactory> {
+
+		private final T factory;
+
+		private final int matchedSize;
+
+		/**
+		 * Key -> (value in factory, value in properties).
+		 */
+		private final Map<String, Tuple2<String, String>> mismatchedProperties;
+
+		/**
+		 * Key -> value in factory.
+		 */
+		private final Map<String, String> missingProperties;
+
+		private ContextBestMatched(
+				T factory,
+				int matchedSize,
+				Map<String, Tuple2<String, String>> mismatchedProperties,
+				Map<String, String> missingProperties) {
+			this.factory = factory;
+			this.matchedSize = matchedSize;
+			this.mismatchedProperties = mismatchedProperties;
+			this.missingProperties = missingProperties;
+		}
+	}
+
 	/**
 	 * Prepares the properties of a context to be used for match operations.
 	 */
@@ -304,8 +381,8 @@ public class TableFactoryService {
 	private static <T extends TableFactory> List<T> filterBySupportedProperties(
 			Class<T> factoryClass,
 			Map<String, String> properties,
-			List<TableFactory> foundFactories,
-			List<T> classFactories) {
+			List<T> classFactories,
+			List<T> contextFactories) {
 
 		final List<String> plainGivenKeys = new LinkedList<>();
 		properties.keySet().forEach(k -> {
@@ -317,9 +394,9 @@ public class TableFactoryService {
 			}
 		});
 
-		Optional<String> lastKey = Optional.empty();
 		List<T> supportedFactories = new LinkedList<>();
-		for (T factory: classFactories) {
+		Tuple2<T, List<String>> bestMatched = null;
+		for (T factory: contextFactories) {
 			Set<String> requiredContextKeys = normalizeContext(factory).keySet();
 			Tuple2<List<String>, List<String>> tuple2 = normalizeSupportedProperties(factory);
 			// ignore context keys
@@ -331,41 +408,38 @@ public class TableFactoryService {
 				givenContextFreeKeys);
 
 			boolean allTrue = true;
-			for (String k: givenFilteredKeys) {
-				lastKey = Optional.of(k);
+			List<String> unsupportedKeys = new ArrayList<>();
+			for (String k : givenFilteredKeys) {
 				if (!(tuple2.f0.contains(k) || tuple2.f1.stream().anyMatch(k::startsWith))) {
 					allTrue = false;
-					break;
+					unsupportedKeys.add(k);
 				}
 			}
 			if (allTrue) {
 				supportedFactories.add(factory);
+			} else {
+				if (bestMatched == null || unsupportedKeys.size() < bestMatched.f1.size()) {
+					bestMatched = new Tuple2<>(factory, unsupportedKeys);
+				}
 			}
 		}
 
-		if (supportedFactories.isEmpty() && classFactories.size() == 1 && lastKey.isPresent()) {
-			// special case: when there is only one matching factory but the last property key
-			// was incorrect
-			TableFactory factory = classFactories.get(0);
-			Tuple2<List<String>, List<String>> tuple2 = normalizeSupportedProperties(factory);
-
-			String errorMessage = String.format(
-				"The matching factory '%s' doesn't support '%s'.\n\nSupported properties of " +
-					"this factory are:\n%s",
-				factory.getClass().getName(),
-				lastKey.get(),
-				String.join("\n", tuple2.f0));
+		if (supportedFactories.isEmpty()) {
+			String bestMatchedMessage = null;
+			if (bestMatched != null) {
+				bestMatchedMessage = String.format(
+						"%s\nUnsupported property keys:\n%s",
+						bestMatched.f0.getClass().getName(),
+						String.join("\n", bestMatched.f1)
+				);
+			}
 
-			throw new NoMatchingTableFactoryException(
-				errorMessage,
-				factoryClass,
-				foundFactories,
-				properties);
-		} else if (supportedFactories.isEmpty()) {
+			//noinspection unchecked
 			throw new NoMatchingTableFactoryException(
 				"No factory supports all properties.",
+				bestMatchedMessage,
 				factoryClass,
-				foundFactories,
+				(List<TableFactory>) classFactories,
 				properties);
 		}
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/factories/TableSinkFactoryServiceTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/factories/TableSinkFactoryServiceTest.java
new file mode 100644
index 00000000000..bfd296b9d98
--- /dev/null
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/factories/TableSinkFactoryServiceTest.java
@@ -0,0 +1,139 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.factories;
+
+import org.apache.flink.table.api.NoMatchingTableFactoryException;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.apache.flink.table.descriptors.ConnectorDescriptorValidator.CONNECTOR_PROPERTY_VERSION;
+import static org.apache.flink.table.descriptors.ConnectorDescriptorValidator.CONNECTOR_TYPE;
+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT_PROPERTY_VERSION;
+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT_TYPE;
+import static org.apache.flink.table.factories.TestTableSinkFactory.CONNECTOR_TYPE_VALUE_TEST;
+import static org.apache.flink.table.factories.TestTableSinkFactory.FORMAT_PATH;
+import static org.apache.flink.table.factories.TestTableSinkFactory.FORMAT_TYPE_VALUE_TEST;
+import static org.apache.flink.table.factories.TestTableSinkFactory.REQUIRED_TEST;
+import static org.apache.flink.table.factories.TestTableSinkFactory.REQUIRED_TEST_VALUE;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests for testing table sink discovery using {@link TableFactoryService}. The tests assume the
+ * table sink factory {@link TestTableSinkFactory} is registered.
+ */
+public class TableSinkFactoryServiceTest {
+
+	@Rule
+	public ExpectedException thrown = ExpectedException.none();
+
+	@Test
+	public void testValidProperties() {
+		Map<String, String> props = properties();
+		assertTrue(TableFactoryService.find(TableSinkFactory.class, props) instanceof TestTableSinkFactory);
+	}
+
+	@Test
+	public void testInvalidContext() {
+		thrown.expect(NoMatchingTableFactoryException.class);
+		Map<String, String> props = properties();
+		props.put(CONNECTOR_TYPE, "unknown-connector-type");
+		TableFactoryService.find(TableSinkFactory.class, props);
+	}
+
+	@Test
+	public void testDifferentContextVersion() {
+		Map<String, String> props = properties();
+		props.put(CONNECTOR_PROPERTY_VERSION, "2");
+		// the table source should still be found
+		assertTrue(TableFactoryService.find(TableSinkFactory.class, props) instanceof TestTableSinkFactory);
+	}
+
+	@Test
+	public void testUnsupportedProperty() {
+		thrown.expect(NoMatchingTableFactoryException.class);
+		thrown.expectMessage("The matching candidates:\n" +
+				"org.apache.flink.table.factories.TestTableSinkFactory\n" +
+				"Unsupported property keys:\n" +
+				"format.path_new");
+		Map<String, String> props = properties();
+		props.put("format.path_new", "/new/path");
+		TableFactoryService.find(TableSinkFactory.class, props);
+	}
+
+	@Test
+	public void testMissingProperty() {
+		thrown.expect(NoMatchingTableFactoryException.class);
+		thrown.expectMessage("The matching candidates:\n" +
+				"org.apache.flink.table.factories.TestTableSinkFactory\n" +
+				"Missing properties:\n" +
+				"format.type=test");
+		Map<String, String> props = properties();
+		props.remove(FORMAT_TYPE);
+		TableFactoryService.find(TableSinkFactory.class, props);
+	}
+
+	@Test
+	public void testMismatchedProperty() {
+		thrown.expect(NoMatchingTableFactoryException.class);
+		thrown.expectMessage("The matching candidates:\n" +
+				"org.apache.flink.table.factories.TestTableSinkFactory\n" +
+				"Mismatched properties:\n" +
+				"'format.type' expects 'test', but is 'test_new'");
+		Map<String, String> props = properties();
+		props.put(FORMAT_TYPE, FORMAT_TYPE_VALUE_TEST + "_new");
+		TableFactoryService.find(TableSinkFactory.class, props);
+	}
+
+	@Test
+	public void testMissingAndMismatchedProperty() {
+		thrown.expect(NoMatchingTableFactoryException.class);
+		thrown.expectMessage("The matching candidates:\n" +
+				"org.apache.flink.table.factories.TestTableSinkFactory\n" +
+				"Missing properties:\n" +
+				"required.test=required-0\n" +
+				"Mismatched properties:\n" +
+				"'format.type' expects 'test', but is 'test_new'");
+		Map<String, String> props = properties();
+		props.put(FORMAT_TYPE, FORMAT_TYPE_VALUE_TEST + "_new");
+		props.remove(REQUIRED_TEST);
+		TableFactoryService.find(TableSinkFactory.class, props);
+	}
+
+	private Map<String, String> properties() {
+		Map<String, String> properties = new HashMap<>();
+		properties.put(CONNECTOR_TYPE, CONNECTOR_TYPE_VALUE_TEST);
+		properties.put(FORMAT_TYPE, FORMAT_TYPE_VALUE_TEST);
+		properties.put(REQUIRED_TEST, REQUIRED_TEST_VALUE);
+		properties.put(CONNECTOR_PROPERTY_VERSION, "1");
+		properties.put(FORMAT_PROPERTY_VERSION, "1");
+		properties.put(FORMAT_PATH, "/path/to/target");
+		properties.put("schema.0.name", "a");
+		properties.put("schema.1.name", "b");
+		properties.put("schema.2.name", "c");
+		properties.put("schema.0.field.0.name", "a");
+		properties.put("schema.0.field.1.name", "b");
+		properties.put("schema.0.field.2.name", "c");
+		return properties;
+	}
+}
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/factories/TestTableSinkFactory.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/factories/TestTableSinkFactory.java
new file mode 100644
index 00000000000..434dea70e3e
--- /dev/null
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/factories/TestTableSinkFactory.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.factories;
+
+import org.apache.flink.table.sinks.TableSink;
+import org.apache.flink.types.Row;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.apache.flink.table.descriptors.ConnectorDescriptorValidator.CONNECTOR_PROPERTY_VERSION;
+import static org.apache.flink.table.descriptors.ConnectorDescriptorValidator.CONNECTOR_TYPE;
+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT_PROPERTY_VERSION;
+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT_TYPE;
+
+/**
+ * Test table sink factory.
+ */
+public class TestTableSinkFactory implements TableFactory, TableSinkFactory<Row> {
+
+	public static final String CONNECTOR_TYPE_VALUE_TEST = "test";
+	public static final String FORMAT_TYPE_VALUE_TEST = "test";
+	public static final String FORMAT_PATH = "format.path";
+	public static final String REQUIRED_TEST = "required.test";
+	public static final String REQUIRED_TEST_VALUE = "required-0";
+
+	@Override
+	public TableSink<Row> createTableSink(Map<String, String> properties) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Map<String, String> requiredContext() {
+		Map<String, String> context = new HashMap<>();
+		context.put(CONNECTOR_TYPE, CONNECTOR_TYPE_VALUE_TEST);
+		context.put(FORMAT_TYPE, FORMAT_TYPE_VALUE_TEST);
+		context.put(REQUIRED_TEST, REQUIRED_TEST_VALUE);
+		context.put(CONNECTOR_PROPERTY_VERSION, "1");
+		context.put(FORMAT_PROPERTY_VERSION, "1");
+		return context;
+	}
+
+	@Override
+	public List<String> supportedProperties() {
+		List<String> properties = new ArrayList<>();
+		// connector
+		properties.add(FORMAT_PATH);
+		properties.add("schema.#.name");
+		properties.add("schema.#.field.#.name");
+		return properties;
+	}
+}
diff --git a/flink-table/flink-table-common/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory b/flink-table/flink-table-common/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory
new file mode 100644
index 00000000000..109471382f5
--- /dev/null
+++ b/flink-table/flink-table-common/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory
@@ -0,0 +1,16 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+org.apache.flink.table.factories.TestTableSinkFactory
diff --git a/flink-table/flink-table-planner/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory b/flink-table/flink-table-planner/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory
index 9a9941dbfab..d9aab281faf 100644
--- a/flink-table/flink-table-planner/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory
+++ b/flink-table/flink-table-planner/src/test/resources/META-INF/services/org.apache.flink.table.factories.TableFactory
@@ -15,7 +15,6 @@
 
 org.apache.flink.table.factories.utils.TestFixedFormatTableFactory
 org.apache.flink.table.factories.utils.TestWildcardFormatTableSourceFactory
-org.apache.flink.table.factories.utils.TestTableSinkFactory
 org.apache.flink.table.factories.utils.TestTableSourceFactory
 org.apache.flink.table.factories.utils.TestTableFormatFactory
 org.apache.flink.table.factories.utils.TestAmbiguousTableFormatFactory
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/TableSinkFactoryServiceTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/TableSinkFactoryServiceTest.scala
deleted file mode 100644
index ebc9a8a630e..00000000000
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/TableSinkFactoryServiceTest.scala
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.table.factories
-
-import java.util.{HashMap => JHashMap, Map => JMap}
-
-import org.apache.flink.table.api.NoMatchingTableFactoryException
-import org.apache.flink.table.descriptors.ConnectorDescriptorValidator._
-import org.apache.flink.table.descriptors.FormatDescriptorValidator._
-import org.apache.flink.table.factories.utils.TestTableSinkFactory
-import org.apache.flink.table.factories.utils.TestTableSinkFactory._
-import org.junit.Assert._
-import org.junit.Test
-
-/**
-  * Tests for testing table sink discovery using [[TableFactoryService]]. The tests assume the
-  * table sink factory [[TestTableSinkFactory]] is registered.
-  */
-class TableSinkFactoryServiceTest {
-
-  @Test
-  def testValidProperties(): Unit = {
-    val props = properties()
-    assertTrue(TableFactoryService.find(classOf[StreamTableSinkFactory[_]], props)
-      .isInstanceOf[TestTableSinkFactory])
-  }
-
-  @Test(expected = classOf[NoMatchingTableFactoryException])
-  def testInvalidContext(): Unit = {
-    val props = properties()
-    props.put(CONNECTOR_TYPE, "unknown-connector-type")
-    TableFactoryService.find(classOf[StreamTableSinkFactory[_]], props)
-  }
-
-  @Test
-  def testDifferentContextVersion(): Unit = {
-    val props = properties()
-    props.put(CONNECTOR_PROPERTY_VERSION, "2")
-    // the table source should still be found
-    assertTrue(TableFactoryService.find(classOf[StreamTableSinkFactory[_]], props)
-      .isInstanceOf[TestTableSinkFactory])
-  }
-
-  @Test(expected = classOf[NoMatchingTableFactoryException])
-  def testUnsupportedProperty(): Unit = {
-    val props = properties()
-    props.put("format.path_new", "/new/path")
-    TableFactoryService.find(classOf[StreamTableSinkFactory[_]], props)
-  }
-
-  private def properties(): JMap[String, String] = {
-    val properties = new JHashMap[String, String]()
-    properties.put(CONNECTOR_TYPE, CONNECTOR_TYPE_VALUE_TEST)
-    properties.put(FORMAT_TYPE, FORMAT_TYPE_VALUE_TEST)
-    properties.put(CONNECTOR_PROPERTY_VERSION, "1")
-    properties.put(FORMAT_PROPERTY_VERSION, "1")
-    properties.put(FORMAT_PATH, "/path/to/target")
-    properties.put("schema.0.name", "a")
-    properties.put("schema.1.name", "b")
-    properties.put("schema.2.name", "c")
-    properties.put("schema.0.field.0.name", "a")
-    properties.put("schema.0.field.1.name", "b")
-    properties.put("schema.0.field.2.name", "c")
-    properties
-  }
-}
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSinkFactory.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSinkFactory.scala
deleted file mode 100644
index ed4fec51305..00000000000
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSinkFactory.scala
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.table.factories.utils
-
-import java.util
-
-import org.apache.flink.table.descriptors.ConnectorDescriptorValidator._
-import org.apache.flink.table.descriptors.FormatDescriptorValidator._
-import org.apache.flink.table.factories.utils.TestTableSinkFactory._
-import org.apache.flink.table.factories.{StreamTableSinkFactory, TableFactory}
-import org.apache.flink.table.sinks.StreamTableSink
-import org.apache.flink.types.Row
-
-/**
-  * Test table sink factory.
-  */
-class TestTableSinkFactory extends StreamTableSinkFactory[Row] with TableFactory {
-
-  override def requiredContext(): util.Map[String, String] = {
-    val context = new util.HashMap[String, String]()
-    context.put(CONNECTOR_TYPE, CONNECTOR_TYPE_VALUE_TEST)
-    context.put(FORMAT_TYPE, FORMAT_TYPE_VALUE_TEST)
-    context.put(CONNECTOR_PROPERTY_VERSION, "1")
-    context.put(FORMAT_PROPERTY_VERSION, "1")
-    context
-  }
-
-  override def supportedProperties(): util.List[String] = {
-    val properties = new util.ArrayList[String]()
-    // connector
-    properties.add(FORMAT_PATH)
-    properties.add("schema.#.name")
-    properties.add("schema.#.field.#.name")
-    properties
-  }
-
-  override def createStreamTableSink(
-      properties: util.Map[String, String])
-    : StreamTableSink[Row] = {
-    throw new UnsupportedOperationException()
-  }
-}
-
-object TestTableSinkFactory {
-  val CONNECTOR_TYPE_VALUE_TEST = "test"
-  val FORMAT_TYPE_VALUE_TEST = "test"
-  val FORMAT_PATH = "format.path"
-}
-
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSourceFactory.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSourceFactory.scala
index b5584a906ad..c0ea9886d0f 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSourceFactory.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/factories/utils/TestTableSourceFactory.scala
@@ -22,7 +22,7 @@ import java.util
 
 import org.apache.flink.table.descriptors.ConnectorDescriptorValidator.{CONNECTOR_PROPERTY_VERSION, CONNECTOR_TYPE}
 import org.apache.flink.table.descriptors.FormatDescriptorValidator.{FORMAT_PROPERTY_VERSION, FORMAT_TYPE}
-import org.apache.flink.table.factories.utils.TestTableSinkFactory.{CONNECTOR_TYPE_VALUE_TEST, FORMAT_TYPE_VALUE_TEST}
+import org.apache.flink.table.factories.utils.TestTableSourceFactory.{CONNECTOR_TYPE_VALUE_TEST, FORMAT_TYPE_VALUE_TEST}
 import org.apache.flink.table.factories.{StreamTableSourceFactory, TableFactory}
 import org.apache.flink.table.sources.StreamTableSource
 import org.apache.flink.types.Row
