diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
index ebb2e56d959..f2112cfd751 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
@@ -24,6 +24,7 @@ import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.operators.coordination.util.IncompleteFuturesTracker;
+import org.apache.flink.runtime.scheduler.GlobalFailureHandler;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.SerializedValue;
@@ -38,7 +39,6 @@ import javax.annotation.Nullable;
 import java.util.Collection;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.function.Consumer;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
@@ -126,7 +126,7 @@ public class OperatorCoordinatorHolder
     private final int operatorParallelism;
     private final int operatorMaxParallelism;
 
-    private Consumer<Throwable> globalFailureHandler;
+    private GlobalFailureHandler globalFailureHandler;
     private ComponentMainThreadExecutor mainThreadExecutor;
 
     private OperatorCoordinatorHolder(
@@ -149,7 +149,7 @@ public class OperatorCoordinatorHolder
     }
 
     public void lazyInitialize(
-            Consumer<Throwable> globalFailureHandler,
+            GlobalFailureHandler globalFailureHandler,
             ComponentMainThreadExecutor mainThreadExecutor) {
 
         this.globalFailureHandler = globalFailureHandler;
@@ -304,7 +304,7 @@ public class OperatorCoordinatorHolder
         } catch (Throwable t) {
             ExceptionUtils.rethrowIfFatalErrorOrOOM(t);
             result.completeExceptionally(t);
-            globalFailureHandler.accept(t);
+            globalFailureHandler.handleGlobalFailure(t);
         }
     }
 
@@ -412,7 +412,8 @@ public class OperatorCoordinatorHolder
             coordinator.subtaskReady(subtask, gateway);
         } catch (Throwable t) {
             ExceptionUtils.rethrowIfFatalErrorOrOOM(t);
-            globalFailureHandler.accept(new FlinkException("Error from OperatorCoordinator", t));
+            globalFailureHandler.handleGlobalFailure(
+                    new FlinkException("Error from OperatorCoordinator", t));
         }
     }
 
@@ -503,7 +504,7 @@ public class OperatorCoordinatorHolder
         private final int operatorParallelism;
         private final CoordinatorStore coordinatorStore;
 
-        private Consumer<Throwable> globalFailureHandler;
+        private GlobalFailureHandler globalFailureHandler;
         private Executor schedulerExecutor;
 
         private volatile boolean failed;
@@ -521,7 +522,7 @@ public class OperatorCoordinatorHolder
             this.coordinatorStore = checkNotNull(coordinatorStore);
         }
 
-        void lazyInitialize(Consumer<Throwable> globalFailureHandler, Executor schedulerExecutor) {
+        void lazyInitialize(GlobalFailureHandler globalFailureHandler, Executor schedulerExecutor) {
             this.globalFailureHandler = checkNotNull(globalFailureHandler);
             this.schedulerExecutor = checkNotNull(schedulerExecutor);
         }
@@ -570,7 +571,7 @@ public class OperatorCoordinatorHolder
             }
             failed = true;
 
-            schedulerExecutor.execute(() -> globalFailureHandler.accept(e));
+            schedulerExecutor.execute(() -> globalFailureHandler.handleGlobalFailure(e));
         }
 
         @Override
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultOperatorCoordinatorHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultOperatorCoordinatorHandler.java
index f35a9d25831..2fe02fda282 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultOperatorCoordinatorHandler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultOperatorCoordinatorHandler.java
@@ -41,7 +41,6 @@ import org.apache.flink.util.IOUtils;
 import java.util.Collection;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
@@ -51,10 +50,10 @@ public class DefaultOperatorCoordinatorHandler implements OperatorCoordinatorHan
 
     private final Map<OperatorID, OperatorCoordinatorHolder> coordinatorMap;
 
-    private final Consumer<Throwable> globalFailureHandler;
+    private final GlobalFailureHandler globalFailureHandler;
 
     public DefaultOperatorCoordinatorHandler(
-            ExecutionGraph executionGraph, Consumer<Throwable> globalFailureHandler) {
+            ExecutionGraph executionGraph, GlobalFailureHandler globalFailureHandler) {
         this.executionGraph = executionGraph;
 
         this.coordinatorMap = createCoordinatorMap(executionGraph);
@@ -122,7 +121,7 @@ public class DefaultOperatorCoordinatorHandler implements OperatorCoordinatorHan
             coordinator.handleEventFromOperator(exec.getParallelSubtaskIndex(), evt);
         } catch (Throwable t) {
             ExceptionUtils.rethrowIfFatalErrorOrOOM(t);
-            globalFailureHandler.accept(t);
+            globalFailureHandler.handleGlobalFailure(t);
         }
     }
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/GlobalFailureHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/GlobalFailureHandler.java
new file mode 100644
index 00000000000..634eea6f92d
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/GlobalFailureHandler.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.flink.runtime.scheduler;
+
+/**
+ * An interface for handling global failures. In context of a scheduler we distinguish between local
+ * and global failures. Global failure is the one that happens in context of the scheduler (in the
+ * JobManager process) and local failure is one that is "local" to an executing task.
+ */
+@FunctionalInterface
+public interface GlobalFailureHandler {
+
+    /**
+     * Handles a global failure.
+     *
+     * @param cause A cause that describes the global failure.
+     */
+    void handleGlobalFailure(Throwable cause);
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerNG.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerNG.java
index 8f6dc9ca59f..faa1b593585 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerNG.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerNG.java
@@ -66,7 +66,7 @@ import java.util.concurrent.CompletableFuture;
  * <p>Implementations can expect that methods will not be invoked concurrently. In fact, all
  * invocations will originate from a thread in the {@link ComponentMainThreadExecutor}.
  */
-public interface SchedulerNG extends AutoCloseableAsync {
+public interface SchedulerNG extends GlobalFailureHandler, AutoCloseableAsync {
 
     void startScheduling();
 
@@ -74,8 +74,6 @@ public interface SchedulerNG extends AutoCloseableAsync {
 
     CompletableFuture<JobStatus> getJobTerminationFuture();
 
-    void handleGlobalFailure(Throwable cause);
-
     default boolean updateTaskExecutionState(TaskExecutionState taskExecutionState) {
         return updateTaskExecutionState(new TaskExecutionStateTransition(taskExecutionState));
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraph.java
index a70fbae6681..1df2f29f2f1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraph.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraph.java
@@ -26,6 +26,7 @@ import org.apache.flink.runtime.executiongraph.ExecutionGraph;
 import org.apache.flink.runtime.executiongraph.ExecutionVertex;
 import org.apache.flink.runtime.scheduler.DefaultOperatorCoordinatorHandler;
 import org.apache.flink.runtime.scheduler.ExecutionGraphHandler;
+import org.apache.flink.runtime.scheduler.GlobalFailureHandler;
 import org.apache.flink.runtime.scheduler.OperatorCoordinatorHandler;
 import org.apache.flink.runtime.scheduler.adaptive.allocator.VertexParallelism;
 import org.apache.flink.util.Preconditions;
@@ -51,16 +52,18 @@ import java.util.concurrent.ScheduledFuture;
 public class CreatingExecutionGraph implements State {
 
     private final Context context;
-
     private final Logger logger;
+    private final OperatorCoordinatorHandlerFactory operatorCoordinatorHandlerFactory;
 
     public CreatingExecutionGraph(
             Context context,
             CompletableFuture<ExecutionGraphWithVertexParallelism>
                     executionGraphWithParallelismFuture,
-            Logger logger) {
+            Logger logger,
+            OperatorCoordinatorHandlerFactory operatorCoordinatorFactory) {
         this.context = context;
         this.logger = logger;
+        this.operatorCoordinatorHandlerFactory = operatorCoordinatorFactory;
 
         FutureUtils.assertNoException(
                 executionGraphWithParallelismFuture.handle(
@@ -104,9 +107,10 @@ public class CreatingExecutionGraph implements State {
                                 getLogger(),
                                 context.getIOExecutor(),
                                 context.getMainThreadExecutor());
+                // Operator coordinator outlives the current state, so we need to use context as a
+                // global failure handler.
                 final OperatorCoordinatorHandler operatorCoordinatorHandler =
-                        new DefaultOperatorCoordinatorHandler(
-                                executionGraph, this::handleGlobalFailure);
+                        operatorCoordinatorHandlerFactory.create(executionGraph, context);
                 operatorCoordinatorHandler.initializeOperatorCoordinators(
                         context.getMainThreadExecutor());
                 operatorCoordinatorHandler.startAllOperatorCoordinators();
@@ -154,7 +158,8 @@ public class CreatingExecutionGraph implements State {
 
     /** Context for the {@link CreatingExecutionGraph} state. */
     interface Context
-            extends StateTransitions.ToExecuting,
+            extends GlobalFailureHandler,
+                    StateTransitions.ToExecuting,
                     StateTransitions.ToFinished,
                     StateTransitions.ToWaitingForResources {
 
@@ -207,6 +212,22 @@ public class CreatingExecutionGraph implements State {
         ComponentMainThreadExecutor getMainThreadExecutor();
     }
 
+    @FunctionalInterface
+    interface OperatorCoordinatorHandlerFactory {
+
+        /**
+         * Creates a new {@link OperatorCoordinatorHandler}. This interface is primarily intended
+         * for easier testing.
+         *
+         * @param executionGraph Current execution graph, that contains operator coordinators that
+         *     we want to start.
+         * @param globalFailureHandler Global failure handler.
+         * @return An {@link OperatorCoordinatorHandler} instance.
+         */
+        OperatorCoordinatorHandler create(
+                ExecutionGraph executionGraph, GlobalFailureHandler globalFailureHandler);
+    }
+
     /**
      * Class representing the assignment result of the slots to the {@link ExecutionGraph}. The
      * assignment is either successful or not possible. If it is successful, the assignment also
@@ -271,7 +292,11 @@ public class CreatingExecutionGraph implements State {
 
         @Override
         public CreatingExecutionGraph getState() {
-            return new CreatingExecutionGraph(context, executionGraphWithParallelismFuture, log);
+            return new CreatingExecutionGraph(
+                    context,
+                    executionGraphWithParallelismFuture,
+                    log,
+                    DefaultOperatorCoordinatorHandler::new);
         }
     }
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/State.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/State.java
index 139c57baa14..52248d56a1f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/State.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/State.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.scheduler.adaptive;
 
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
+import org.apache.flink.runtime.scheduler.GlobalFailureHandler;
 import org.apache.flink.util.function.FunctionWithException;
 import org.apache.flink.util.function.ThrowingConsumer;
 
@@ -31,7 +32,7 @@ import java.util.Optional;
  * State abstraction of the {@link AdaptiveScheduler}. This interface contains all methods every
  * state implementation must support.
  */
-interface State {
+interface State extends GlobalFailureHandler {
 
     /**
      * This method is called whenever one transitions out of this state.
@@ -65,13 +66,6 @@ interface State {
      */
     ArchivedExecutionGraph getJob();
 
-    /**
-     * Handles a global failure.
-     *
-     * @param cause cause describes the global failure
-     */
-    void handleGlobalFailure(Throwable cause);
-
     /**
      * Gets the logger.
      *
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
index daf02142178..b2694c625ce 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
@@ -25,6 +25,7 @@ import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutorSer
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.operators.coordination.EventReceivingTasks.EventWithSubtask;
+import org.apache.flink.runtime.scheduler.GlobalFailureHandler;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.TestLogger;
 
@@ -43,7 +44,6 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
-import java.util.function.Consumer;
 import java.util.function.Function;
 
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -62,7 +62,7 @@ import static org.junit.Assert.assertTrue;
 @SuppressWarnings("serial")
 public class OperatorCoordinatorHolderTest extends TestLogger {
 
-    private final Consumer<Throwable> globalFailureHandler = (t) -> globalFailure = t;
+    private final GlobalFailureHandler globalFailureHandler = (t) -> globalFailure = t;
     private Throwable globalFailure;
 
     @After
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraphTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraphTest.java
index d574d402399..2afe00307e5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraphTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/CreatingExecutionGraphTest.java
@@ -27,13 +27,16 @@ import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.executiongraph.ExecutionGraph;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.scheduler.ExecutionGraphHandler;
+import org.apache.flink.runtime.scheduler.GlobalFailureHandler;
 import org.apache.flink.runtime.scheduler.OperatorCoordinatorHandler;
 import org.apache.flink.runtime.scheduler.adaptive.allocator.VertexParallelism;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
+import org.apache.flink.util.TestLoggerExtension;
 import org.apache.flink.util.concurrent.Executors;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
 
 import javax.annotation.Nullable;
 
@@ -42,25 +45,30 @@ import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.Function;
 
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.sameInstance;
-import static org.junit.Assert.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for the {@link CreatingExecutionGraph} state. */
+@ExtendWith(TestLoggerExtension.class)
 public class CreatingExecutionGraphTest extends TestLogger {
 
     @Test
     public void testCancelTransitionsToFinished() throws Exception {
         try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
             final CreatingExecutionGraph creatingExecutionGraph =
-                    new CreatingExecutionGraph(context, new CompletableFuture<>(), log);
+                    new CreatingExecutionGraph(
+                            context,
+                            new CompletableFuture<>(),
+                            log,
+                            CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler);
 
             context.setExpectFinished(
                     archivedExecutionGraph ->
-                            assertThat(archivedExecutionGraph.getState(), is(JobStatus.CANCELED)));
+                            assertThat(archivedExecutionGraph.getState())
+                                    .isEqualTo(JobStatus.CANCELED));
 
             creatingExecutionGraph.cancel();
         }
@@ -70,11 +78,16 @@ public class CreatingExecutionGraphTest extends TestLogger {
     public void testSuspendTransitionsToFinished() throws Exception {
         try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
             final CreatingExecutionGraph creatingExecutionGraph =
-                    new CreatingExecutionGraph(context, new CompletableFuture<>(), log);
+                    new CreatingExecutionGraph(
+                            context,
+                            new CompletableFuture<>(),
+                            log,
+                            CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler);
 
             context.setExpectFinished(
                     archivedExecutionGraph ->
-                            assertThat(archivedExecutionGraph.getState(), is(JobStatus.SUSPENDED)));
+                            assertThat(archivedExecutionGraph.getState())
+                                    .isEqualTo(JobStatus.SUSPENDED));
 
             creatingExecutionGraph.suspend(new FlinkException("Job has been suspended."));
         }
@@ -84,11 +97,16 @@ public class CreatingExecutionGraphTest extends TestLogger {
     public void testGlobalFailureTransitionsToFinished() throws Exception {
         try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
             final CreatingExecutionGraph creatingExecutionGraph =
-                    new CreatingExecutionGraph(context, new CompletableFuture<>(), log);
+                    new CreatingExecutionGraph(
+                            context,
+                            new CompletableFuture<>(),
+                            log,
+                            CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler);
 
             context.setExpectFinished(
                     archivedExecutionGraph ->
-                            assertThat(archivedExecutionGraph.getState(), is(JobStatus.FAILED)));
+                            assertThat(archivedExecutionGraph.getState())
+                                    .isEqualTo(JobStatus.FAILED));
 
             creatingExecutionGraph.handleGlobalFailure(new FlinkException("Test exception"));
         }
@@ -99,13 +117,16 @@ public class CreatingExecutionGraphTest extends TestLogger {
         try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
             final CompletableFuture<CreatingExecutionGraph.ExecutionGraphWithVertexParallelism>
                     executionGraphWithVertexParallelismFuture = new CompletableFuture<>();
-            final CreatingExecutionGraph creatingExecutionGraph =
-                    new CreatingExecutionGraph(
-                            context, executionGraphWithVertexParallelismFuture, log);
+            new CreatingExecutionGraph(
+                    context,
+                    executionGraphWithVertexParallelismFuture,
+                    log,
+                    CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler);
 
             context.setExpectFinished(
                     archivedExecutionGraph ->
-                            assertThat(archivedExecutionGraph.getState(), is(JobStatus.FAILED)));
+                            assertThat(archivedExecutionGraph.getState())
+                                    .isEqualTo(JobStatus.FAILED));
 
             executionGraphWithVertexParallelismFuture.completeExceptionally(
                     new FlinkException("Test exception"));
@@ -117,9 +138,11 @@ public class CreatingExecutionGraphTest extends TestLogger {
         try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
             final CompletableFuture<CreatingExecutionGraph.ExecutionGraphWithVertexParallelism>
                     executionGraphWithVertexParallelismFuture = new CompletableFuture<>();
-            final CreatingExecutionGraph creatingExecutionGraph =
-                    new CreatingExecutionGraph(
-                            context, executionGraphWithVertexParallelismFuture, log);
+            new CreatingExecutionGraph(
+                    context,
+                    executionGraphWithVertexParallelismFuture,
+                    log,
+                    CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler);
 
             context.setTryToAssignSlotsFunction(
                     ignored -> CreatingExecutionGraph.AssignmentResult.notPossible());
@@ -135,26 +158,71 @@ public class CreatingExecutionGraphTest extends TestLogger {
     public void testSuccessfulSlotAssignmentTransitionsToExecuting() throws Exception {
         try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
             final CompletableFuture<CreatingExecutionGraph.ExecutionGraphWithVertexParallelism>
-                    executionGraphWithvertexParallelismFuture = new CompletableFuture<>();
-            final CreatingExecutionGraph creatingExecutionGraph =
-                    new CreatingExecutionGraph(
-                            context, executionGraphWithvertexParallelismFuture, log);
+                    executionGraphWithVertexParallelismFuture = new CompletableFuture<>();
+            new CreatingExecutionGraph(
+                    context,
+                    executionGraphWithVertexParallelismFuture,
+                    log,
+                    CreatingExecutionGraphTest::createTestingOperatorCoordinatorHandler);
 
             final StateTrackingMockExecutionGraph executionGraph =
                     new StateTrackingMockExecutionGraph();
 
-            context.setTryToAssignSlotsFunction(
-                    e -> CreatingExecutionGraph.AssignmentResult.success(e.getExecutionGraph()));
+            context.setTryToAssignSlotsFunction(CreatingExecutionGraphTest::successfulAssignment);
+            context.setExpectedExecuting(
+                    actualExecutionGraph ->
+                            assertThat(actualExecutionGraph).isEqualTo(executionGraph));
+
+            executionGraphWithVertexParallelismFuture.complete(
+                    CreatingExecutionGraph.ExecutionGraphWithVertexParallelism.create(
+                            executionGraph, new TestingVertexParallelism()));
+        }
+    }
+
+    @Test
+    public void testOperatorCoordinatorUsesFailureHandlerOfTheCurrentState() throws Exception {
+        try (MockCreatingExecutionGraphContext context = new MockCreatingExecutionGraphContext()) {
+            final CompletableFuture<CreatingExecutionGraph.ExecutionGraphWithVertexParallelism>
+                    executionGraphWithVertexParallelismFuture = new CompletableFuture<>();
+            final AtomicReference<GlobalFailureHandler> operatorCoordinatorGlobalFailureHandlerRef =
+                    new AtomicReference<>();
+            new CreatingExecutionGraph(
+                    context,
+                    executionGraphWithVertexParallelismFuture,
+                    log,
+                    (executionGraph, errorHandler) -> {
+                        operatorCoordinatorGlobalFailureHandlerRef.set(errorHandler);
+                        return new TestingOperatorCoordinatorHandler();
+                    });
+
+            final StateTrackingMockExecutionGraph executionGraph =
+                    new StateTrackingMockExecutionGraph();
+
+            context.setTryToAssignSlotsFunction(CreatingExecutionGraphTest::successfulAssignment);
             context.setExpectedExecuting(
                     actualExecutionGraph ->
-                            assertThat(actualExecutionGraph, sameInstance(executionGraph)));
+                            assertThat(actualExecutionGraph).isEqualTo(executionGraph));
 
-            executionGraphWithvertexParallelismFuture.complete(
+            executionGraphWithVertexParallelismFuture.complete(
                     CreatingExecutionGraph.ExecutionGraphWithVertexParallelism.create(
                             executionGraph, new TestingVertexParallelism()));
+
+            assertThat(operatorCoordinatorGlobalFailureHandlerRef.get()).isSameAs(context);
         }
     }
 
+    private static CreatingExecutionGraph.AssignmentResult successfulAssignment(
+            CreatingExecutionGraph.ExecutionGraphWithVertexParallelism
+                    executionGraphWithVertexParallelism) {
+        return CreatingExecutionGraph.AssignmentResult.success(
+                executionGraphWithVertexParallelism.getExecutionGraph());
+    }
+
+    private static OperatorCoordinatorHandler createTestingOperatorCoordinatorHandler(
+            ExecutionGraph executionGraph, GlobalFailureHandler globalFailureHandler) {
+        return new TestingOperatorCoordinatorHandler();
+    }
+
     static class MockCreatingExecutionGraphContext
             implements CreatingExecutionGraph.Context, AutoCloseable {
         private final StateValidator<ArchivedExecutionGraph> finishedStateValidator =
@@ -170,6 +238,11 @@ public class CreatingExecutionGraphTest extends TestLogger {
                 tryToAssignSlotsFunction =
                         e -> CreatingExecutionGraph.AssignmentResult.success(e.getExecutionGraph());
 
+        private GlobalFailureHandler globalFailureHandler =
+                t -> {
+                    // No-op.
+                };
+
         private boolean hadStateTransitionHappened = false;
 
         public void setExpectFinished(Consumer<ArchivedExecutionGraph> asserter) {
@@ -192,6 +265,10 @@ public class CreatingExecutionGraphTest extends TestLogger {
             this.tryToAssignSlotsFunction = tryToAssignSlotsFunction;
         }
 
+        public void setGlobalFailureHandler(GlobalFailureHandler globalFailureHandler) {
+            this.globalFailureHandler = globalFailureHandler;
+        }
+
         @Override
         public void goToFinished(ArchivedExecutionGraph archivedExecutionGraph) {
             finishedStateValidator.validateInput(archivedExecutionGraph);
@@ -223,6 +300,11 @@ public class CreatingExecutionGraphTest extends TestLogger {
             return CompletedScheduledFuture.create(null);
         }
 
+        @Override
+        public void handleGlobalFailure(Throwable cause) {
+            globalFailureHandler.handleGlobalFailure(cause);
+        }
+
         @Override
         public CreatingExecutionGraph.AssignmentResult tryToAssignSlots(
                 CreatingExecutionGraph.ExecutionGraphWithVertexParallelism
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/TestingOperatorCoordinatorHandler.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/TestingOperatorCoordinatorHandler.java
index a1e125850f7..a9b5669e98d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/TestingOperatorCoordinatorHandler.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/TestingOperatorCoordinatorHandler.java
@@ -45,12 +45,12 @@ class TestingOperatorCoordinatorHandler implements OperatorCoordinatorHandler {
 
     @Override
     public void initializeOperatorCoordinators(ComponentMainThreadExecutor mainThreadExecutor) {
-        throw new UnsupportedOperationException();
+        // No-op.
     }
 
     @Override
     public void startAllOperatorCoordinators() {
-        throw new UnsupportedOperationException();
+        // No-op.
     }
 
     @Override
