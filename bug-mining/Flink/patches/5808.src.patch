diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/DataStreamJavaITCase.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/DataStreamJavaITCase.java
index 623c0c0ecee..318e749d17b 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/DataStreamJavaITCase.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/DataStreamJavaITCase.java
@@ -859,19 +859,17 @@ public class DataStreamJavaITCase extends AbstractTestBase {
                         final RowKind kind = row.getKind();
                         row.setKind(RowKind.INSERT);
                         switch (kind) {
-                            case UPDATE_BEFORE:
-                                materializedResult.remove(row);
-                                break;
-                            case INSERT: // temporary solution for FLINK-24054
                             case UPDATE_AFTER:
                                 final Object primaryKeyValue = row.getField(primaryKeyPos);
                                 assert primaryKeyValue != null;
                                 materializedResult.removeIf(
                                         r -> primaryKeyValue.equals(r.getField(primaryKeyPos)));
+                                // fall through
+                            case INSERT:
                                 materializedResult.add(row);
                                 break;
+                            case UPDATE_BEFORE:
                             case DELETE:
-                                row.setKind(RowKind.INSERT);
                                 materializedResult.remove(row);
                                 break;
                         }
diff --git a/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializer.java b/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializer.java
index 2c06e679e33..0d18cb4c540 100644
--- a/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializer.java
+++ b/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializer.java
@@ -30,6 +30,7 @@ import org.apache.flink.table.data.RowData;
 import org.apache.flink.table.runtime.generated.GeneratedRecordEqualiser;
 import org.apache.flink.table.runtime.generated.RecordEqualiser;
 import org.apache.flink.table.runtime.operators.TableStreamOperator;
+import org.apache.flink.types.RowKind;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -43,13 +44,14 @@ import static org.apache.flink.types.RowKind.INSERT;
 import static org.apache.flink.types.RowKind.UPDATE_AFTER;
 
 /**
- * A operator that maintains the records corresponding to the upsert keys in the state, it receives
- * the upstream changelog records and generate an upsert view for the downstream.
+ * An operator that maintains incoming records in state corresponding to the upsert keys and
+ * generates an upsert view for the downstream operator.
  *
  * <ul>
- *   <li>For insert record, append the state and collect current record.
- *   <li>For delete record, delete in the state, collect delete record when the state is empty.
- *   <li>For delete record, delete in the state, collect the last one when the state is not empty.
+ *   <li>Adds an insertion to state and emits it with updated {@link RowKind}.
+ *   <li>Applies a deletion to state.
+ *   <li>Emits a deletion with updated {@link RowKind} iff affects the last record or the state is
+ *       empty afterwards. A deletion to an already updated record is swallowed.
  * </ul>
  */
 public class SinkUpsertMaterializer extends TableStreamOperator<RowData>
@@ -68,6 +70,8 @@ public class SinkUpsertMaterializer extends TableStreamOperator<RowData>
     private final GeneratedRecordEqualiser generatedEqualiser;
 
     private transient RecordEqualiser equaliser;
+    // Buffer of emitted insertions on which deletions will be applied first.
+    // The row kind might be +I or +U and will be ignored when applying the deletion.
     private transient ValueState<List<RowData>> state;
     private transient TimestampedCollector<RowData> collector;
 
@@ -96,36 +100,39 @@ public class SinkUpsertMaterializer extends TableStreamOperator<RowData>
 
     @Override
     public void processElement(StreamRecord<RowData> element) throws Exception {
-        RowData row = element.getValue();
-        boolean isInsertOp = row.getRowKind() == INSERT || row.getRowKind() == UPDATE_AFTER;
-        // Always set the RowKind to INSERT, so that we can compare rows correctly (RowKind will
-        // be ignored)
-        row.setRowKind(INSERT);
+        final RowData row = element.getValue();
         List<RowData> values = state.value();
         if (values == null) {
             values = new ArrayList<>(2);
         }
 
-        if (isInsertOp) {
-            values.add(row);
-            // Update to this new one
-            collector.collect(row);
-        } else {
-            int lastIndex = values.size() - 1;
-            int index = removeFirst(values, row);
-            if (index == -1) {
-                LOG.info(STATE_CLEARED_WARN_MSG);
-                return;
-            }
-            if (values.isEmpty()) {
-                // Delete this row
-                row.setRowKind(DELETE);
+        switch (row.getRowKind()) {
+            case INSERT:
+            case UPDATE_AFTER:
+                row.setRowKind(values.isEmpty() ? INSERT : UPDATE_AFTER);
+                values.add(row);
                 collector.collect(row);
-            } else if (index == lastIndex) {
-                // Last one removed
-                // Update to newer
-                collector.collect(values.get(values.size() - 1));
-            }
+                break;
+
+            case UPDATE_BEFORE:
+            case DELETE:
+                final int lastIndex = values.size() - 1;
+                final int index = removeFirst(values, row);
+                if (index == -1) {
+                    LOG.info(STATE_CLEARED_WARN_MSG);
+                    return;
+                }
+                if (values.isEmpty()) {
+                    // Delete this row
+                    row.setRowKind(DELETE);
+                    collector.collect(row);
+                } else if (index == lastIndex) {
+                    // Last row has been removed, update to the second last one
+                    final RowData latestRow = values.get(values.size() - 1);
+                    latestRow.setRowKind(UPDATE_AFTER);
+                    collector.collect(latestRow);
+                }
+                break;
         }
 
         if (values.isEmpty()) {
@@ -136,10 +143,12 @@ public class SinkUpsertMaterializer extends TableStreamOperator<RowData>
     }
 
     private int removeFirst(List<RowData> values, RowData remove) {
-        Iterator<RowData> iterator = values.iterator();
+        final Iterator<RowData> iterator = values.iterator();
         int i = 0;
         while (iterator.hasNext()) {
-            RowData row = iterator.next();
+            final RowData row = iterator.next();
+            // Ignore kind during comparison
+            remove.setRowKind(row.getRowKind());
             if (equaliser.equals(row, remove)) {
                 iterator.remove();
                 return i;
diff --git a/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializerTest.java b/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializerTest.java
index 3b246beeb2d..7f4f464aba2 100644
--- a/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializerTest.java
+++ b/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/operators/sink/SinkUpsertMaterializerTest.java
@@ -35,7 +35,6 @@ import org.apache.flink.table.types.logical.VarCharType;
 import org.apache.flink.table.utils.HandwrittenSelectorUtil;
 import org.apache.flink.types.RowKind;
 
-import org.junit.Assert;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -45,6 +44,7 @@ import java.util.List;
 import static org.apache.flink.table.runtime.util.StreamRecordUtils.deleteRecord;
 import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;
 import static org.apache.flink.table.runtime.util.StreamRecordUtils.row;
+import static org.junit.Assert.assertEquals;
 
 /** Test for {@link SinkUpsertMaterializer}. */
 public class SinkUpsertMaterializerTest {
@@ -76,52 +76,62 @@ public class SinkUpsertMaterializerTest {
         testHarness.setStateTtlProcessingTime(1);
 
         testHarness.processElement(insertRecord(1, "a1"));
-        Assert.assertEquals(Collections.singletonList(row(1, "a1")), toRows(testHarness));
+        shouldEmit(testHarness, row(RowKind.INSERT, 1, "a1"));
 
         testHarness.processElement(insertRecord(1, "a2"));
-        Assert.assertEquals(Collections.singletonList(row(1, "a2")), toRows(testHarness));
+        shouldEmit(testHarness, row(RowKind.UPDATE_AFTER, 1, "a2"));
 
         testHarness.processElement(insertRecord(1, "a3"));
-        Assert.assertEquals(Collections.singletonList(row(1, "a3")), toRows(testHarness));
+        shouldEmit(testHarness, row(RowKind.UPDATE_AFTER, 1, "a3"));
 
         testHarness.processElement(deleteRecord(1, "a2"));
-        Assert.assertEquals(Collections.emptyList(), toRows(testHarness));
+        shouldEmitNothing(testHarness);
 
         testHarness.processElement(deleteRecord(1, "a3"));
-        Assert.assertEquals(Collections.singletonList(row(1, "a1")), toRows(testHarness));
+        shouldEmit(testHarness, row(RowKind.UPDATE_AFTER, 1, "a1"));
 
         testHarness.processElement(deleteRecord(1, "a1"));
-        RowData deleteRow = row(1, "a1");
-        deleteRow.setRowKind(RowKind.DELETE);
-        Assert.assertEquals(Collections.singletonList(deleteRow), toRows(testHarness));
+        shouldEmit(testHarness, row(RowKind.DELETE, 1, "a1"));
 
         testHarness.processElement(insertRecord(1, "a4"));
-        Assert.assertEquals(Collections.singletonList(row(1, "a4")), toRows(testHarness));
+        shouldEmit(testHarness, row(RowKind.INSERT, 1, "a4"));
 
         testHarness.setStateTtlProcessingTime(1002);
 
         testHarness.processElement(deleteRecord(1, "a4"));
-        Assert.assertEquals(Collections.emptyList(), toRows(testHarness));
+        shouldEmitNothing(testHarness);
 
         testHarness.close();
     }
 
-    private List<RowData> toRows(OneInputStreamOperatorTestHarness<RowData, RowData> harness) {
+    private void shouldEmitNothing(OneInputStreamOperatorTestHarness<RowData, RowData> harness) {
+        assertEquals(Collections.emptyList(), getEmittedRows(harness));
+    }
+
+    private void shouldEmit(
+            OneInputStreamOperatorTestHarness<RowData, RowData> harness, RowData expected) {
+        assertEquals(Collections.singletonList(expected), getEmittedRows(harness));
+    }
+
+    private static List<RowData> getEmittedRows(
+            OneInputStreamOperatorTestHarness<RowData, RowData> harness) {
+        final List<RowData> rows = new ArrayList<>();
         Object o;
-        List<RowData> ret = new ArrayList<>();
         while ((o = harness.getOutput().poll()) != null) {
-            RowData value = (RowData) ((StreamRecord) o).getValue();
+            RowData value = (RowData) ((StreamRecord<?>) o).getValue();
             GenericRowData newRow = GenericRowData.of(value.getInt(0), value.getString(1));
             newRow.setRowKind(value.getRowKind());
-            ret.add(newRow);
+            rows.add(newRow);
         }
-        return ret;
+        return rows;
     }
 
     private static class TestRecordEqualiser implements RecordEqualiser {
         @Override
         public boolean equals(RowData row1, RowData row2) {
-            return row1.getInt(0) == row2.getInt(0) && row1.getString(1).equals(row2.getString(1));
+            return row1.getRowKind() == row2.getRowKind()
+                    && row1.getInt(0) == row2.getInt(0)
+                    && row1.getString(1).equals(row2.getString(1));
         }
     }
 }
diff --git a/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/util/StreamRecordUtils.java b/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/util/StreamRecordUtils.java
index fb69100c617..586d57143a9 100644
--- a/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/util/StreamRecordUtils.java
+++ b/flink-table/flink-table-runtime/src/test/java/org/apache/flink/table/runtime/util/StreamRecordUtils.java
@@ -104,13 +104,8 @@ public class StreamRecordUtils {
         return new StreamRecord<>(row);
     }
 
-    /**
-     * Receives a object array, generates a RowData based on the array.
-     *
-     * @param fields input object array
-     * @return generated RowData.
-     */
-    public static RowData row(Object... fields) {
+    /** Receives a object array, generates a RowData based on the array. */
+    public static RowData row(RowKind rowKind, Object... fields) {
         Object[] objects = new Object[fields.length];
         for (int i = 0; i < fields.length; i++) {
             Object field = fields[i];
@@ -120,7 +115,12 @@ public class StreamRecordUtils {
                 objects[i] = field;
             }
         }
-        return GenericRowData.of(objects);
+        return GenericRowData.ofKind(rowKind, objects);
+    }
+
+    /** Receives a object array, generates a RowData based on the array. */
+    public static RowData row(Object... fields) {
+        return row(RowKind.INSERT, fields);
     }
 
     /**
