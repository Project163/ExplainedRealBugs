diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index 53e6737ff85..41d76318593 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -388,34 +388,58 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 		runningJobs.put(jobGraph.getJobID(), dispatcherJob);
 
 		final JobID jobId = jobGraph.getJobID();
-		FutureUtils.assertNoException(
-			dispatcherJob.getResultFuture().handleAsync(
-				(DispatcherJobResult dispatcherJobResult, Throwable throwable) -> {
-					// check if we are still the active DispatcherJob by checking the identity
-					DispatcherJob job = runningJobs.get(jobId);
-					if (job == dispatcherJob) {
-						if (dispatcherJobResult != null) {
-							if (dispatcherJobResult.isInitializationFailure() && executionType == ExecutionType.RECOVERY) {
-								dispatcherJobFailed(jobId, dispatcherJobResult.getInitializationFailure());
-							} else {
-								jobReachedGloballyTerminalState(dispatcherJobResult.getArchivedExecutionGraph());
-							}
-						} else {
-							dispatcherJobFailed(jobId, throwable);
-						}
-					} else {
-						log.debug("Job {} is not registered anymore at dispatcher", jobId);
-					}
-					return null;
-				}, getMainThreadExecutor()));
-	}
-
-	private void dispatcherJobFailed(JobID jobId, Throwable throwable) {
+
+		final CompletableFuture<CleanupJobState> cleanupJobStateFuture = dispatcherJob.getResultFuture().handleAsync(
+			(dispatcherJobResult, throwable) -> {
+				Preconditions.checkState(runningJobs.get(jobId) == dispatcherJob, "The job entry in runningJobs must be bound to the lifetime of the DispatcherJob.");
+
+				if (dispatcherJobResult != null) {
+					return handleDispatcherJobResult(jobId, dispatcherJobResult, executionType);
+				} else {
+					return dispatcherJobFailed(jobId, throwable);
+				}
+			}, getMainThreadExecutor());
+
+		final CompletableFuture<Void> jobTerminationFuture = cleanupJobStateFuture
+			.thenApply(cleanupJobState -> removeJob(jobId, cleanupJobState))
+			.thenCompose(Function.identity());
+
+		FutureUtils.assertNoException(jobTerminationFuture);
+		registerDispatcherJobTerminationFuture(jobId, jobTerminationFuture);
+	}
+
+	private CleanupJobState handleDispatcherJobResult(
+		JobID jobId,
+		DispatcherJobResult dispatcherJobResult,
+		ExecutionType executionType) {
+		if (dispatcherJobResult.isInitializationFailure() && executionType == ExecutionType.RECOVERY) {
+			return dispatcherJobFailed(
+				jobId,
+				dispatcherJobResult.getInitializationFailure());
+		} else {
+			return jobReachedGloballyTerminalState(dispatcherJobResult.getArchivedExecutionGraph());
+		}
+	}
+
+	enum CleanupJobState {
+		LOCAL(false),
+		GLOBAL(true);
+
+		final boolean cleanupHAData;
+
+		CleanupJobState(boolean cleanupHAData) {
+			this.cleanupHAData = cleanupHAData;
+		}
+	}
+
+	private CleanupJobState dispatcherJobFailed(JobID jobId, Throwable throwable) {
 		if (throwable instanceof JobNotFinishedException) {
 			jobNotFinished(jobId);
 		} else {
 			jobMasterFailed(jobId, throwable);
 		}
+
+		return CleanupJobState.LOCAL;
 	}
 
 	CompletableFuture<JobManagerRunner> createJobManagerRunner(JobGraph jobGraph, long initializationTimestamp) {
@@ -631,19 +655,6 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 		return performOperationOnJobMasterGateway(jobId, gateway -> gateway.deliverCoordinationRequestToCoordinator(operatorId, serializedRequest, timeout));
 	}
 
-	/**
-	 * Cleans up the job related data from the dispatcher. If cleanupHA is true, then
-	 * the data will also be removed from HA.
-	 *
-	 * @param jobId JobID identifying the job to clean up
-	 * @param cleanupHA True iff HA data shall also be cleaned up
-	 */
-	private void removeJobAndRegisterTerminationFuture(JobID jobId, boolean cleanupHA) {
-		final CompletableFuture<Void> cleanupFuture = removeJob(jobId, cleanupHA);
-
-		registerDispatcherJobTerminationFuture(jobId, cleanupFuture);
-	}
-
 	private void registerDispatcherJobTerminationFuture(JobID jobId, CompletableFuture<Void> dispatcherJobTerminationFuture) {
 		Preconditions.checkState(!dispatcherJobTerminationFutures.containsKey(jobId));
 		dispatcherJobTerminationFutures.put(jobId, dispatcherJobTerminationFuture);
@@ -661,18 +672,12 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 			getMainThreadExecutor());
 	}
 
-	private CompletableFuture<Void> removeJob(JobID jobId, boolean cleanupHA) {
-		DispatcherJob job = runningJobs.remove(jobId);
+	private CompletableFuture<Void> removeJob(JobID jobId, CleanupJobState cleanupJobState) {
+		final DispatcherJob job = checkNotNull(runningJobs.remove(jobId));
 
-		final CompletableFuture<Void> dispatcherJobTerminationFuture;
-		if (job != null) {
-			dispatcherJobTerminationFuture = job.closeAsync();
-		} else {
-			dispatcherJobTerminationFuture = CompletableFuture.completedFuture(null);
-		}
-		return dispatcherJobTerminationFuture.thenRunAsync(
-			() -> cleanUpJobData(jobId, cleanupHA),
-			ioExecutor);
+		final CompletableFuture<Void> jobTerminationFuture = job.closeAsync();
+
+		return jobTerminationFuture.thenRunAsync(() -> cleanUpJobData(jobId, cleanupJobState.cleanupHAData), ioExecutor);
 	}
 
 	private void cleanUpJobData(JobID jobId, boolean cleanupHA) {
@@ -714,7 +719,15 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 		final HashSet<JobID> jobsToRemove = new HashSet<>(runningJobs.keySet());
 
 		for (JobID jobId : jobsToRemove) {
-			removeJobAndRegisterTerminationFuture(jobId, false);
+			terminateJob(jobId);
+		}
+	}
+
+	private void terminateJob(JobID jobId) {
+		final DispatcherJob dispatcherJob = runningJobs.get(jobId);
+
+		if (dispatcherJob != null) {
+			dispatcherJob.closeAsync();
 		}
 	}
 
@@ -728,7 +741,7 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 		fatalErrorHandler.onFatalError(throwable);
 	}
 
-	protected void jobReachedGloballyTerminalState(ArchivedExecutionGraph archivedExecutionGraph) {
+	protected CleanupJobState jobReachedGloballyTerminalState(ArchivedExecutionGraph archivedExecutionGraph) {
 		Preconditions.checkArgument(
 			archivedExecutionGraph.getState().isGloballyTerminalState(),
 			"Job %s is in state %s which is not globally terminal.",
@@ -739,9 +752,7 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 
 		archiveExecutionGraph(archivedExecutionGraph);
 
-		final JobID jobId = archivedExecutionGraph.getJobID();
-
-		removeJobAndRegisterTerminationFuture(jobId, true);
+		return CleanupJobState.GLOBAL;
 	}
 
 	private void archiveExecutionGraph(ArchivedExecutionGraph archivedExecutionGraph) {
@@ -771,8 +782,6 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 
 	protected void jobNotFinished(JobID jobId) {
 		log.info("Job {} was not finished by JobManager.", jobId);
-
-		removeJobAndRegisterTerminationFuture(jobId, false);
 	}
 
 	private void jobMasterFailed(JobID jobId, Throwable cause) {
@@ -862,7 +871,7 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 
 	public CompletableFuture<Void> onRemovedJobGraph(JobID jobId) {
 		return CompletableFuture.runAsync(
-			() -> removeJobAndRegisterTerminationFuture(jobId, false),
+			() -> terminateJob(jobId),
 			getMainThreadExecutor());
 	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java
index da4dd80974b..464d925fe50 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java
@@ -108,14 +108,16 @@ public class MiniDispatcher extends Dispatcher {
 	}
 
 	@Override
-	protected void jobReachedGloballyTerminalState(ArchivedExecutionGraph archivedExecutionGraph) {
-		super.jobReachedGloballyTerminalState(archivedExecutionGraph);
+	protected CleanupJobState jobReachedGloballyTerminalState(ArchivedExecutionGraph archivedExecutionGraph) {
+		final CleanupJobState cleanupHAState = super.jobReachedGloballyTerminalState(archivedExecutionGraph);
 
 		if (jobCancelled || executionMode == ClusterEntrypoint.ExecutionMode.DETACHED) {
 			// shut down if job is cancelled or we don't have to wait for the execution result retrieval
 			log.info("Shutting down cluster with state {}, jobCancelled: {}, executionMode: {}", archivedExecutionGraph.getState(), jobCancelled, executionMode);
 			shutDownFuture.complete(ApplicationStatus.fromJobStatus(archivedExecutionGraph.getState()));
 		}
+
+		return cleanupHAState;
 	}
 
 	@Override
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobManagerRunnerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobManagerRunnerImpl.java
index c7916d740a4..34f1b2603f2 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobManagerRunnerImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobManagerRunnerImpl.java
@@ -195,6 +195,8 @@ public class JobManagerRunnerImpl implements LeaderContender, OnCompletionAction
 
 						classLoaderLease.release();
 
+						resultFuture.completeExceptionally(new JobNotFinishedException(jobGraph.getJobID()));
+
 						if (throwable != null) {
 							terminationFuture.completeExceptionally(
 								new FlinkException("Could not properly shut down the JobManagerRunner", throwable));
@@ -202,11 +204,6 @@ public class JobManagerRunnerImpl implements LeaderContender, OnCompletionAction
 							terminationFuture.complete(null);
 						}
 					});
-
-				terminationFuture.whenComplete(
-					(Void ignored, Throwable throwable) -> {
-						resultFuture.completeExceptionally(new JobNotFinishedException(jobGraph.getJobID()));
-					});
 			}
 
 			return terminationFuture;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
index 77e163fb2ec..fbbbb6b4bcb 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
@@ -75,8 +75,11 @@ import javax.annotation.Nonnull;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ForkJoinPool;
@@ -319,6 +322,35 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 		assertThat(deleteAllHABlobsFuture.isDone(), is(false));
 	}
 
+	@Test
+	public void testHACleanupWhenJobFinishedWhileClosingDispatcher() throws Exception {
+		final TestingJobManagerRunner testingJobManagerRunner = new TestingJobManagerRunner.Builder()
+			.setBlockingTermination(true)
+			.setJobId(jobId)
+			.build();
+
+		final Queue<JobManagerRunner> jobManagerRunners = new ArrayDeque<>(Arrays.asList(testingJobManagerRunner));
+
+		startDispatcher(new QueueJobManagerRunnerFactory(jobManagerRunners));
+		submitJob();
+
+		final CompletableFuture<Void> dispatcherTerminationFuture = dispatcher.closeAsync();
+
+		testingJobManagerRunner.getCloseAsyncCalledLatch().await();
+		testingJobManagerRunner.completeResultFuture(new ArchivedExecutionGraphBuilder()
+			.setJobID(jobId)
+			.setState(JobStatus.FINISHED)
+			.build());
+
+		testingJobManagerRunner.completeTerminationFuture();
+
+		// check that no exceptions have been thrown
+		dispatcherTerminationFuture.get();
+
+		assertThat(cleanupJobFuture.get(), is(jobId));
+		assertThat(deleteAllHABlobsFuture.get(), is(jobId));
+	}
+
 	/**
 	 * Tests that the {@link RunningJobsRegistry} entries are cleared after the
 	 * job reached a terminal state.
@@ -557,6 +589,29 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 		}
 	}
 
+	private static final class QueueJobManagerRunnerFactory implements JobManagerRunnerFactory {
+		private final Queue<? extends JobManagerRunner> jobManagerRunners;
+
+		private QueueJobManagerRunnerFactory(Queue<? extends JobManagerRunner> jobManagerRunners) {
+			this.jobManagerRunners = jobManagerRunners;
+		}
+
+		@Override
+		public JobManagerRunner createJobManagerRunner(
+			JobGraph jobGraph,
+			Configuration configuration,
+			RpcService rpcService,
+			HighAvailabilityServices highAvailabilityServices,
+			HeartbeatServices heartbeatServices,
+			JobManagerSharedServices jobManagerServices,
+			JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory,
+			FatalErrorHandler fatalErrorHandler,
+			long initializationTimestamp) {
+			return Optional.ofNullable(jobManagerRunners.poll())
+				.orElseThrow(() -> new IllegalStateException("Cannot create more JobManagerRunners."));
+		}
+	}
+
 	private class FailingJobManagerRunnerFactory implements JobManagerRunnerFactory {
 		private final Exception testException;
 
