diff --git a/flink-python/docs/reference/pyflink.datastream/connectors.rst b/flink-python/docs/reference/pyflink.datastream/connectors.rst
index 7b9ceb149ee..6c0c7bc2e07 100644
--- a/flink-python/docs/reference/pyflink.datastream/connectors.rst
+++ b/flink-python/docs/reference/pyflink.datastream/connectors.rst
@@ -151,6 +151,7 @@ Pulsar Source
 
     StartCursor
     StopCursor
+    RangeGenerator
     PulsarSource
     PulsarSourceBuilder
 
diff --git a/flink-python/pyflink/datastream/connectors/pulsar.py b/flink-python/pyflink/datastream/connectors/pulsar.py
index bb4b503e8cd..a24ba07810b 100644
--- a/flink-python/pyflink/datastream/connectors/pulsar.py
+++ b/flink-python/pyflink/datastream/connectors/pulsar.py
@@ -17,7 +17,7 @@
 ################################################################################
 import warnings
 from enum import Enum
-from typing import Dict, Union, List
+from typing import Dict, Union, List, Optional
 
 from pyflink.common import DeserializationSchema, ConfigOptions, Duration, SerializationSchema, \
     ConfigOption
@@ -31,6 +31,7 @@ __all__ = [
     'PulsarSourceBuilder',
     'StartCursor',
     'StopCursor',
+    'RangeGenerator',
     'PulsarSink',
     'PulsarSinkBuilder',
     'MessageDelayer',
@@ -69,18 +70,6 @@ class StartCursor(object):
             .org.apache.flink.connector.pulsar.source.enumerator.cursor.StartCursor
         return StartCursor(JStartCursor.latest())
 
-    @staticmethod
-    def from_message_time(timestamp: int) -> 'StartCursor':
-        """
-        This method is designed for seeking message from event time. But Pulsar didn't support
-        seeking from message time, instead, it would seek the position from publish time. We only
-        keep this method for backward compatible.
-        """
-        warnings.warn("Deprecated in 1.16, use from_publish_time() instead.", DeprecationWarning)
-        JStartCursor = get_gateway().jvm \
-            .org.apache.flink.connector.pulsar.source.enumerator.cursor.StartCursor
-        return StartCursor(JStartCursor.fromMessageTime(timestamp))
-
     @staticmethod
     def from_message_id(message_id: bytes, inclusive: bool = True) -> 'StartCursor':
         """
@@ -213,6 +202,76 @@ class StopCursor(object):
         return StopCursor(JStopCursor.afterMessageId(j_message_id))
 
 
+class RangeGenerator(object):
+    """
+    A generator for generating the TopicRange for given topic. It was used for pulsar's
+    SubscriptionType#Key_Shared mode. TopicRange would be used in KeySharedPolicy for different
+    pulsar source readers.
+
+    If you implement this interface, make sure that each TopicRange would be assigned to a
+    specified source reader. Since flink parallelism is provided, make sure the pulsar message key's
+    hashcode is evenly distributed among these topic ranges.
+    """
+
+    def __init__(self, j_range_generator):
+        self._j_range_generator = j_range_generator
+
+    @staticmethod
+    def full() -> 'RangeGenerator':
+        """
+        Default implementation for SubscriptionType#Shared, SubscriptionType#Failover and
+        SubscriptionType#Exclusive subscription.
+        """
+        JFullRangeGenerator = get_gateway().jvm \
+            .org.apache.flink.connector.pulsar.source.enumerator.topic.range.FullRangeGenerator
+        return RangeGenerator(JFullRangeGenerator())
+
+    @staticmethod
+    def fixed_key(support_null_key: bool = False,
+                  keys: Optional[Union[str, List[str]]] = None,
+                  key_bytes: Optional[bytes] = None,
+                  ordering_key_bytes: Optional[bytes] = None) -> 'RangeGenerator':
+        """
+        Pulsar didn't expose the key hash range method. We have to provide an implementation for
+        end-user. You can add the keys you want to consume, no need to provide any hash ranges.
+
+        Since the key's hash isn't specified to only one key. The consuming results may contain the
+        messages with different keys comparing the keys you have defined in this range generator.
+        Remember to use flink's DataStream.filter() method.
+
+        :param support_null_key: Some Message in Pulsar may not have Message#getOrderingKey() or
+                                 Message#getKey(), use this method for supporting consuming such
+                                 messages.
+        :param keys: If you set the message key by using PulsarMessageBuilder#key(String) or
+                     TypedMessageBuilder#key(String), use this method for supporting consuming such
+                     messages.
+        :param key_bytes: If you set the message key by using TypedMessageBuilder#keyBytes(byte[]),
+                          use this method for supporting consuming such messages.
+        :param ordering_key_bytes: Pulsar's ordering key is prior to the message key. If you set
+                                   the ordering key by using
+                                   PulsarMessageBuilder#orderingKey(byte[]) or
+                                   TypedMessageBuilder#orderingKey(byte[]), use this method for
+                                   supporting consuming such messages.
+         * messages.
+        """
+        JFixedKeysRangeGenerator = get_gateway().jvm \
+            .org.apache.flink.connector.pulsar.source.enumerator.topic.range.FixedKeysRangeGenerator
+        j_range_generator_builder = JFixedKeysRangeGenerator.builder()
+        if support_null_key:
+            j_range_generator_builder.supportNullKey()
+        if keys is not None:
+            if isinstance(keys, str):
+                j_range_generator_builder.key(keys)
+            else:
+                for key in keys:
+                    j_range_generator_builder.key(key)
+        if key_bytes is not None:
+            j_range_generator_builder.keyBytes(key_bytes)
+        if ordering_key_bytes is not None:
+            j_range_generator_builder.orderingKey(ordering_key_bytes)
+        return RangeGenerator(j_range_generator_builder.build())
+
+
 class PulsarSource(Source):
     """
     The Source implementation of Pulsar. Please use a PulsarSourceBuilder to construct a
@@ -330,22 +389,34 @@ class PulsarSourceBuilder(object):
         self._j_pulsar_source_builder.setTopics(topics)
         return self
 
-    def set_topics_pattern(self, topics_pattern: str) -> 'PulsarSourceBuilder':
+    def set_topic_pattern(self, topic_pattern: str) -> 'PulsarSourceBuilder':
         """
         Set a topic pattern to consume from the java regex str. You can set topics once either with
         set_topics or set_topic_pattern in this builder.
         """
-        warnings.warn("set_topics_pattern is deprecated. Use set_topic_pattern instead.",
-                      DeprecationWarning, stacklevel=2)
-        self._j_pulsar_source_builder.setTopicPattern(topics_pattern)
+        self._j_pulsar_source_builder.setTopicPattern(topic_pattern)
         return self
 
-    def set_topic_pattern(self, topic_pattern: str) -> 'PulsarSourceBuilder':
+    def set_consumer_name(self, consumer_name: str) -> 'PulsarSourceBuilder':
         """
-        Set a topic pattern to consume from the java regex str. You can set topics once either with
-        set_topics or set_topic_pattern in this builder.
+        The consumer name is informative, and it can be used to identify a particular consumer
+        instance from the topic stats.
+
+        .. versionadded:: 1.17.2
         """
-        self._j_pulsar_source_builder.setTopicPattern(topic_pattern)
+        self._j_pulsar_source_builder.setConsumerName(consumer_name)
+        return self
+
+    def set_range_generator(self, range_generator: RangeGenerator) -> 'PulsarSourceBuilder':
+        """
+        Set a topic range generator for consuming a sub set of keys.
+
+        :param range_generator: A generator which would generate a set of TopicRange for given
+                                topic.
+
+        .. versionadded:: 1.17.2
+        """
+        self._j_pulsar_source_builder.setRangeGenerator(range_generator._j_range_generator)
         return self
 
     def set_start_cursor(self, start_cursor: StartCursor) -> 'PulsarSourceBuilder':
@@ -401,6 +472,30 @@ class PulsarSourceBuilder(object):
             deserialization_schema._j_deserialization_schema)
         return self
 
+    def set_authentication(self,
+                           auth_plugin_class_name: str,
+                           auth_params_string: Union[str, Dict[str, str]]) \
+            -> 'PulsarSourceBuilder':
+        """
+        Configure the authentication provider to use in the Pulsar client instance.
+
+        :param auth_plugin_class_name: Name of the Authentication-Plugin you want to use.
+        :param auth_params_string: String which represents parameters for the Authentication-Plugin,
+                                   e.g., "key1:val1,key2:val2".
+
+        .. versionadded:: 1.17.2
+        """
+        if isinstance(auth_params_string, str):
+            self._j_pulsar_source_builder.setAuthentication(
+                auth_plugin_class_name, auth_params_string)
+        else:
+            j_auth_params_map = get_gateway().jvm.java.util.HashMap()
+            for k, v in auth_params_string.items():
+                j_auth_params_map.put(k, v)
+            self._j_pulsar_source_builder.setAuthentication(
+                auth_plugin_class_name, j_auth_params_map)
+        return self
+
     def set_config(self, key: Union[str, ConfigOption], value) -> 'PulsarSourceBuilder':
         """
         Set arbitrary properties for the PulsarSource and PulsarConsumer. The valid keys can be
@@ -667,6 +762,30 @@ class PulsarSinkBuilder(object):
             serialization_schema._j_serialization_schema)
         return self
 
+    def set_authentication(self,
+                           auth_plugin_class_name: str,
+                           auth_params_string: Union[str, Dict[str, str]]) \
+            -> 'PulsarSinkBuilder':
+        """
+        Configure the authentication provider to use in the Pulsar client instance.
+
+        :param auth_plugin_class_name: Name of the Authentication-Plugin you want to use.
+        :param auth_params_string: String which represents parameters for the Authentication-Plugin,
+                                   e.g., "key1:val1,key2:val2".
+
+        .. versionadded:: 1.17.2
+        """
+        if isinstance(auth_params_string, str):
+            self._j_pulsar_sink_builder.setAuthentication(
+                auth_plugin_class_name, auth_params_string)
+        else:
+            j_auth_params_map = get_gateway().jvm.java.util.HashMap()
+            for k, v in auth_params_string.items():
+                j_auth_params_map.put(k, v)
+            self._j_pulsar_sink_builder.setAuthentication(
+                auth_plugin_class_name, j_auth_params_map)
+        return self
+
     def delay_sending_message(self, message_delayer: MessageDelayer) -> 'PulsarSinkBuilder':
         """
         Set a message delayer for enable Pulsar message delay delivery.
diff --git a/flink-python/pyflink/datastream/connectors/tests/test_pulsar.py b/flink-python/pyflink/datastream/connectors/tests/test_pulsar.py
index 64c625ef0d1..55f4659c28f 100644
--- a/flink-python/pyflink/datastream/connectors/tests/test_pulsar.py
+++ b/flink-python/pyflink/datastream/connectors/tests/test_pulsar.py
@@ -18,7 +18,7 @@
 from pyflink.common import WatermarkStrategy, SimpleStringSchema, Types, ConfigOptions, Duration
 from pyflink.datastream.connectors import DeliveryGuarantee
 from pyflink.datastream.connectors.pulsar import TopicRoutingMode, MessageDelayer, PulsarSink, \
-    PulsarSource, StartCursor, StopCursor
+    PulsarSource, StartCursor, StopCursor, RangeGenerator
 from pyflink.testing.test_case_utils import PyFlinkUTTestCase
 from pyflink.util.java_utils import get_field_value, is_instance_of
 
@@ -35,6 +35,7 @@ class FlinkPulsarTest(PyFlinkUTTestCase):
             .set_unbounded_stop_cursor(StopCursor.never()) \
             .set_bounded_stop_cursor(StopCursor.at_publish_time(22)) \
             .set_subscription_name('ff') \
+            .set_consumer_name('test_consumer') \
             .set_deserialization_schema(SimpleStringSchema()) \
             .set_config(TEST_OPTION_NAME, True) \
             .set_properties({'pulsar.source.autoCommitCursorInterval': '1000'}) \
@@ -137,6 +138,44 @@ class FlinkPulsarTest(PyFlinkUTTestCase):
             .set_bounded_stop_cursor(StopCursor.at_event_time(24)) \
             .build()
 
+    def test_set_range_generator(self):
+        PulsarSource.builder() \
+            .set_service_url('pulsar://localhost:6650') \
+            .set_admin_url('http://localhost:8080') \
+            .set_topics(['ada', 'beta']) \
+            .set_subscription_name('ff') \
+            .set_deserialization_schema(SimpleStringSchema()) \
+            .set_range_generator(RangeGenerator.full()) \
+            .build()
+
+        PulsarSource.builder() \
+            .set_service_url('pulsar://localhost:6650') \
+            .set_admin_url('http://localhost:8080') \
+            .set_topics(['ada', 'beta']) \
+            .set_subscription_name('ff') \
+            .set_deserialization_schema(SimpleStringSchema()) \
+            .set_range_generator(RangeGenerator.fixed_key(keys='k', key_bytes=bytearray(b'abc'))) \
+            .build()
+
+    def test_set_authentication(self):
+        PulsarSource.builder() \
+            .set_service_url('pulsar://localhost:6650') \
+            .set_admin_url('http://localhost:8080') \
+            .set_topics(['ada', 'beta']) \
+            .set_subscription_name('ff') \
+            .set_deserialization_schema(SimpleStringSchema()) \
+            .set_authentication('test.class', 'key1:val1,key2:val2') \
+            .build()
+
+        PulsarSource.builder() \
+            .set_service_url('pulsar://localhost:6650') \
+            .set_admin_url('http://localhost:8080') \
+            .set_topics(['ada', 'beta']) \
+            .set_subscription_name('ff') \
+            .set_deserialization_schema(SimpleStringSchema()) \
+            .set_authentication('test.class', {'k1': 'v1', 'k2': 'v2'}) \
+            .build()
+
     def test_pulsar_sink(self):
         ds = self.env.from_collection([('ab', 1), ('bdc', 2), ('cfgs', 3), ('deeefg', 4)],
                                       type_info=Types.ROW([Types.STRING(), Types.INT()]))
