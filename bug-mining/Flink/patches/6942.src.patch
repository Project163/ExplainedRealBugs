diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
index e485b461557..c7f84e73bc1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
@@ -1314,14 +1314,18 @@ public class CheckpointCoordinator {
             if (!props.isSavepoint()) {
                 lastSubsumed =
                         addCompletedCheckpointToStoreAndSubsumeOldest(
-                                checkpointId,
-                                completedCheckpoint,
-                                pendingCheckpoint.getCheckpointPlan().getTasksToCommitTo());
+                                checkpointId, completedCheckpoint, pendingCheckpoint);
             } else {
                 lastSubsumed = null;
             }
 
+            pendingCheckpoint.getCompletionFuture().complete(completedCheckpoint);
             reportCompletedCheckpoint(completedCheckpoint);
+        } catch (Exception exception) {
+            // For robustness reasons, we need catch exception and try marking the checkpoint
+            // completed.
+            pendingCheckpoint.getCompletionFuture().completeExceptionally(exception);
+            throw exception;
         } finally {
             pendingCheckpoints.remove(checkpointId);
             scheduleTriggerRequest();
@@ -1442,8 +1446,10 @@ public class CheckpointCoordinator {
     private CompletedCheckpoint addCompletedCheckpointToStoreAndSubsumeOldest(
             long checkpointId,
             CompletedCheckpoint completedCheckpoint,
-            List<ExecutionVertex> tasksToAbort)
+            PendingCheckpoint pendingCheckpoint)
             throws CheckpointException {
+        List<ExecutionVertex> tasksToAbort =
+                pendingCheckpoint.getCheckpointPlan().getTasksToCommitTo();
         try {
             final CompletedCheckpoint subsumedCheckpoint =
                     completedCheckpointStore.addCheckpointAndSubsumeOldestOne(
@@ -1453,6 +1459,7 @@ public class CheckpointCoordinator {
             this.forceFullSnapshot = false;
             return subsumedCheckpoint;
         } catch (Exception exception) {
+            pendingCheckpoint.getCompletionFuture().completeExceptionally(exception);
             if (exception instanceof PossibleInconsistentStateException) {
                 LOG.warn(
                         "An error occurred while writing checkpoint {} to the underlying metadata"
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
index cbe096a5481..a02d0d1d29e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
@@ -107,7 +107,10 @@ public class PendingCheckpoint implements Checkpoint {
     /** The checkpoint properties. */
     private final CheckpointProperties props;
 
-    /** The promise to fulfill once the checkpoint has been completed. */
+    /**
+     * The promise to fulfill once the checkpoint has been completed. Note that it will be completed
+     * only after the checkpoint is successfully added to CompletedCheckpointStore.
+     */
     private final CompletableFuture<CompletedCheckpoint> onCompletionPromise;
 
     @Nullable private final PendingCheckpointStats pendingCheckpointStats;
@@ -340,8 +343,6 @@ public class PendingCheckpoint implements Checkpoint {
                                 finalizedLocation,
                                 toCompletedCheckpointStats(finalizedLocation));
 
-                onCompletionPromise.complete(completed);
-
                 // mark this pending checkpoint as disposed, but do NOT drop the state
                 dispose(false, checkpointsCleaner, postCleanup, executor);
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
index 4724ccd765f..e4902f4fde0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
@@ -205,7 +205,7 @@ class PendingCheckpointTest {
         pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics());
         assertThat(pending.areTasksFullyAcknowledged()).isTrue();
         pending.finalizeCheckpoint(new CheckpointsCleaner(), () -> {}, Executors.directExecutor());
-        assertThat(future.isDone()).isTrue();
+        assertThat(future.isDone()).isFalse();
 
         // Finalize (missing ACKs)
         PendingCheckpoint pendingCheckpoint = createPendingCheckpoint(props);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
index 49ba055732b..0f14e3c81f2 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
@@ -25,16 +25,19 @@ import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.MetricOptions;
 import org.apache.flink.configuration.WebOptions;
+import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.core.testutils.ScheduledTask;
 import org.apache.flink.metrics.Gauge;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinator;
 import org.apache.flink.runtime.checkpoint.CheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
+import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
 import org.apache.flink.runtime.checkpoint.StandaloneCheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.StandaloneCompletedCheckpointStore;
 import org.apache.flink.runtime.checkpoint.TestingCheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.TestingCompletedCheckpointStore;
 import org.apache.flink.runtime.checkpoint.hooks.TestMasterHook;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
@@ -71,6 +74,7 @@ import org.apache.flink.runtime.jobmaster.slotpool.LocationPreferenceSlotSelecti
 import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotProvider;
 import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotProviderImpl;
 import org.apache.flink.runtime.jobmaster.slotpool.SlotPool;
+import org.apache.flink.runtime.messages.checkpoint.AcknowledgeCheckpoint;
 import org.apache.flink.runtime.metrics.MetricRegistry;
 import org.apache.flink.runtime.metrics.groups.JobManagerMetricGroup;
 import org.apache.flink.runtime.metrics.util.TestingMetricRegistry;
@@ -84,6 +88,7 @@ import org.apache.flink.runtime.scheduler.strategy.SchedulingStrategyFactory;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;
 import org.apache.flink.runtime.scheduler.strategy.TestSchedulingStrategy;
 import org.apache.flink.runtime.shuffle.TestingShuffleMaster;
+import org.apache.flink.runtime.state.SharedStateRegistryImpl;
 import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;
 import org.apache.flink.runtime.taskmanager.TaskExecutionState;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
@@ -832,6 +837,75 @@ public class DefaultSchedulerTest extends TestLogger {
         assertThat(masterHook.getRestoreCount()).isOne();
     }
 
+    @Test
+    void testTriggerCheckpointAndCompletedAfterStore() throws Exception {
+        final JobGraph jobGraph = singleNonParallelJobVertexJobGraph();
+        enableCheckpointing(jobGraph);
+
+        final CountDownLatch checkpointTriggeredLatch = getCheckpointTriggeredLatch();
+
+        CompletedCheckpointStore store =
+                TestingCompletedCheckpointStore.builder()
+                        .withGetAllCheckpointsSupplier(Collections::emptyList)
+                        .withAddCheckpointAndSubsumeOldestOneFunction(
+                                (ignoredCompletedCheckpoint,
+                                        ignoredCheckpointsCleaner,
+                                        ignoredPostCleanup) -> {
+                                    throw new RuntimeException(
+                                            "Throw exception when add checkpoint to store.");
+                                })
+                        .withGetSharedStateRegistrySupplier(SharedStateRegistryImpl::new)
+                        .build();
+
+        ComponentMainThreadExecutor mainThreadExecutor =
+                ComponentMainThreadExecutorServiceAdapter.forSingleThreadExecutor(
+                        new DirectScheduledExecutorService());
+        final DefaultScheduler scheduler;
+        scheduler =
+                createSchedulerBuilder(jobGraph, mainThreadExecutor)
+                        .setCheckpointRecoveryFactory(
+                                new TestingCheckpointRecoveryFactory(
+                                        store, new StandaloneCheckpointIDCounter()))
+                        .build();
+        mainThreadExecutor.execute(scheduler::startScheduling);
+
+        final ArchivedExecutionVertex onlyExecutionVertex =
+                Iterables.getOnlyElement(
+                        scheduler
+                                .requestJob()
+                                .getArchivedExecutionGraph()
+                                .getAllExecutionVertices());
+        final ExecutionAttemptID attemptId =
+                onlyExecutionVertex.getCurrentExecutionAttempt().getAttemptId();
+        transitionToRunning(scheduler, attemptId);
+
+        final CheckpointCoordinator checkpointCoordinator = getCheckpointCoordinator(scheduler);
+
+        // complete one checkpoint for state restore
+        CompletableFuture<CompletedCheckpoint> checkpointCompletableFuture =
+                checkpointCoordinator.triggerCheckpoint(false);
+        checkpointTriggeredLatch.await();
+
+        final long checkpointId =
+                checkpointCoordinator.getPendingCheckpoints().keySet().iterator().next();
+        OneShotLatch latch = new OneShotLatch();
+        executor.execute(
+                () -> {
+                    try {
+                        final AcknowledgeCheckpoint acknowledgeCheckpoint =
+                                new AcknowledgeCheckpoint(
+                                        jobGraph.getJobID(), attemptId, checkpointId);
+                        checkpointCoordinator.receiveAcknowledgeMessage(
+                                acknowledgeCheckpoint, "Unknown location");
+                    } catch (Exception e) {
+                        latch.trigger();
+                    }
+                });
+
+        latch.await();
+        assertThat(checkpointCompletableFuture).isCompletedExceptionally();
+    }
+
     @Test
     void failGlobalWhenRestoringStateFails() throws Exception {
         final JobGraph jobGraph = singleNonParallelJobVertexJobGraph();
