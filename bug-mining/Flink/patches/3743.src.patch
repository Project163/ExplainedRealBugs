diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/functions/BuiltInFunctionDefinitions.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/functions/BuiltInFunctionDefinitions.java
index 5c6a70c9d59..3c7b5f79643 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/functions/BuiltInFunctionDefinitions.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/functions/BuiltInFunctionDefinitions.java
@@ -247,10 +247,18 @@ public final class BuiltInFunctionDefinitions {
 			.build();
 	public static final BuiltInFunctionDefinition LOWER =
 		new BuiltInFunctionDefinition.Builder()
-			.name("lowerCase")
+			.name("lower")
 			.kind(SCALAR)
 			.outputTypeStrategy(TypeStrategies.MISSING)
 			.build();
+	// we need LOWERCASE here to maintain compatibility for the string-based expression DSL
+	// which exposes LOWER as lowerCase()
+	public static final BuiltInFunctionDefinition LOWERCASE =
+			new BuiltInFunctionDefinition.Builder()
+					.name("lowerCase")
+					.kind(SCALAR)
+					.outputTypeStrategy(TypeStrategies.MISSING)
+					.build();
 	public static final BuiltInFunctionDefinition SIMILAR =
 		new BuiltInFunctionDefinition.Builder()
 			.name("similar")
@@ -277,10 +285,18 @@ public final class BuiltInFunctionDefinitions {
 			.build();
 	public static final BuiltInFunctionDefinition UPPER =
 		new BuiltInFunctionDefinition.Builder()
-			.name("upperCase")
+			.name("upper")
 			.kind(SCALAR)
 			.outputTypeStrategy(TypeStrategies.MISSING)
 			.build();
+	// we need UPPERCASE here to maintain compatibility for the string-based expression DSL
+	// which exposes UPPER as upperCase()
+	public static final BuiltInFunctionDefinition UPPERCASE =
+			new BuiltInFunctionDefinition.Builder()
+					.name("upperCase")
+					.kind(SCALAR)
+					.outputTypeStrategy(TypeStrategies.MISSING)
+					.build();
 	public static final BuiltInFunctionDefinition POSITION =
 		new BuiltInFunctionDefinition.Builder()
 			.name("position")
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/DirectConvertRule.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/DirectConvertRule.java
index 432b8c7ee6a..f4406264395 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/DirectConvertRule.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/DirectConvertRule.java
@@ -67,9 +67,11 @@ public class DirectConvertRule implements CallExpressionConvertRule {
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.INIT_CAP, FlinkSqlOperatorTable.INITCAP);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.LIKE, FlinkSqlOperatorTable.LIKE);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.LOWER, FlinkSqlOperatorTable.LOWER);
+		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.LOWERCASE, FlinkSqlOperatorTable.LOWER);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.SIMILAR, FlinkSqlOperatorTable.SIMILAR_TO);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.SUBSTRING, FlinkSqlOperatorTable.SUBSTRING);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.UPPER, FlinkSqlOperatorTable.UPPER);
+		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.UPPERCASE, FlinkSqlOperatorTable.UPPER);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.POSITION, FlinkSqlOperatorTable.POSITION);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.OVERLAY, FlinkSqlOperatorTable.OVERLAY);
 		DEFINITION_OPERATOR_MAP.put(BuiltInFunctionDefinitions.CONCAT, FlinkSqlOperatorTable.CONCAT_FUNCTION);
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/expressions/PlannerExpressionConverter.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/expressions/PlannerExpressionConverter.scala
index 38d93b09973..06a9b5fe99d 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/expressions/PlannerExpressionConverter.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/expressions/PlannerExpressionConverter.scala
@@ -290,6 +290,10 @@ class PlannerExpressionConverter private extends ApiExpressionVisitor[PlannerExp
             assert(args.size == 1)
             Lower(args.head)
 
+          case LOWERCASE =>
+            assert(args.size == 1)
+            Lower(args.head)
+
           case SIMILAR =>
             assert(args.size == 2)
             Similar(args.head, args.last)
@@ -326,6 +330,10 @@ class PlannerExpressionConverter private extends ApiExpressionVisitor[PlannerExp
             assert(args.size == 1)
             Upper(args.head)
 
+          case UPPERCASE =>
+            assert(args.size == 1)
+            Upper(args.head)
+
           case POSITION =>
             assert(args.size == 2)
             Position(args.head, args.last)
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.xml
index 6c58346516d..f8180e4ff30 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.xml
@@ -290,6 +290,24 @@ LogicalProject(name=[$0], id=[$1], amount=[$2], virtualField=[$3], price=[$4])
 +- LogicalProject(name=[$0], id=[$1], amount=[$2], virtualField=[+($2, 1)], price=[$3])
    +- LogicalFilter(condition=[>($3, 10)])
       +- LogicalTableScan(table=[[default_catalog, default_database, VirtualTable, source: [filterPushedDown=[true], filter=[greaterThan(amount, 2)]]]])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testLowerUpperPushdown">
+    <Resource name="sql">
+      <![CDATA[SELECT * FROM MTable WHERE LOWER(a) = 'foo' AND UPPER(b) = 'bar']]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1])
++- LogicalFilter(condition=[AND(=(LOWER($0), _UTF-16LE'foo'), =(UPPER($1), _UTF-16LE'bar'))])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MTable, source: [filterPushedDown=[false], filter=[]]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1])
++- LogicalTableScan(table=[[default_catalog, default_database, MTable, source: [filterPushedDown=[true], filter=[and(equals(lower(a), 'foo'), equals(upper(b), 'bar'))]]]])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.scala
index e58735368f6..1aa06171da9 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/PushFilterIntoTableSourceScanRuleTest.scala
@@ -20,10 +20,13 @@ package org.apache.flink.table.planner.plan.rules.logical
 import org.apache.flink.table.planner.expressions.utils.Func1
 import org.apache.flink.table.planner.plan.optimize.program.{FlinkBatchProgram, FlinkHepRuleSetProgramBuilder, HEP_RULES_EXECUTION_TYPE}
 import org.apache.flink.table.planner.utils.{TableConfigUtils, TableTestBase, TestFilterableTableSource}
-
 import org.apache.calcite.plan.hep.HepMatchOrder
 import org.apache.calcite.rel.rules.FilterProjectTransposeRule
 import org.apache.calcite.tools.RuleSets
+import org.apache.flink.api.common.typeinfo.TypeInformation
+import org.apache.flink.api.java.typeutils.RowTypeInfo
+import org.apache.flink.table.api.Types
+import org.apache.flink.types.Row
 import org.junit.{Before, Test}
 
 /**
@@ -142,4 +145,18 @@ class PushFilterIntoTableSourceScanRuleTest extends TableTestBase {
     util.verifyPlan("SELECT * FROM MyTable WHERE amount > 2 AND myUdf(amount) < 32")
   }
 
+  @Test
+  def testLowerUpperPushdown(): Unit = {
+    val rti = new RowTypeInfo(Array[TypeInformation[_]](
+      Types.STRING, Types.STRING),
+      Array("a", "b"))
+    val data = List(Row.of("foo", "bar"))
+    util.tableEnv
+      .registerTableSource(
+        "MTable",
+        TestFilterableTableSource(true, rti, data, Set("a", "b"))
+      )
+
+    util.verifyPlan("SELECT * FROM MTable WHERE LOWER(a) = 'foo' AND UPPER(b) = 'bar'")
+  }
 }
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/TableSourceITCase.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/TableSourceITCase.scala
index dc4d4416626..6abe51fad7f 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/TableSourceITCase.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/TableSourceITCase.scala
@@ -28,6 +28,7 @@ import org.apache.flink.table.planner.utils.{TestDataTypeTableSource, TestFileIn
 import org.apache.flink.table.runtime.types.TypeInfoDataTypeConverter
 import org.apache.flink.types.Row
 import org.junit.{Before, Test}
+
 import java.io.FileWriter
 import java.lang.{Boolean => JBool, Integer => JInt, Long => JLong}
 import java.math.{BigDecimal => JDecimal}
@@ -155,6 +156,23 @@ class TableSourceITCase extends BatchTestBase {
     )
   }
 
+  @Test
+  def testTableSourceWithFunctionFilterable(): Unit = {
+    tEnv.registerTableSource(
+      "FilterableTable",
+      TestFilterableTableSource(
+        true,
+        TestFilterableTableSource.defaultTypeInfo,
+        TestFilterableTableSource.defaultRows,
+        Set("amount", "name")))
+    checkResult(
+      "SELECT id, name FROM FilterableTable " +
+        "WHERE amount > 4 AND price < 9 AND upper(name) = 'RECORD_5'",
+      Seq(
+        row(5, "Record_5"))
+    )
+  }
+
   @Test
   def testTableSourceWithPartitionable(): Unit = {
     TestPartitionableSourceFactory.registerTableSource(tEnv, "PartitionableTable", true)
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/utils/testTableSources.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/utils/testTableSources.scala
index 19870a82414..c86e4d0e740 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/utils/testTableSources.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/utils/testTableSources.scala
@@ -29,7 +29,7 @@ import org.apache.flink.streaming.api.datastream.DataStream
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment
 import org.apache.flink.table.api.{DataTypes, TableEnvironment, TableSchema, Types}
 import org.apache.flink.table.catalog.{CatalogPartitionImpl, CatalogPartitionSpec, CatalogTableImpl, ObjectPath}
-import org.apache.flink.table.descriptors.ConnectorDescriptorValidator.{CONNECTOR, CONNECTOR_TYPE}
+import org.apache.flink.table.descriptors.ConnectorDescriptorValidator.CONNECTOR_TYPE
 import org.apache.flink.table.descriptors.{DescriptorProperties, Schema}
 import org.apache.flink.table.expressions.utils.ApiExpressionUtils.unresolvedCall
 import org.apache.flink.table.expressions.{CallExpression, Expression, FieldReferenceExpression, ValueLiteralExpression}
@@ -45,7 +45,6 @@ import org.apache.flink.table.sources.wmstrategies.{AscendingTimestamps, Preserv
 import org.apache.flink.table.types.DataType
 import org.apache.flink.table.types.utils.TypeConversions.fromLegacyInfoToDataType
 import org.apache.flink.types.Row
-
 import java.io.{File, FileOutputStream, OutputStreamWriter}
 import java.util
 import java.util.{Collections, function, ArrayList => JArrayList, List => JList, Map => JMap}
@@ -377,6 +376,9 @@ class TestProjectableTableSourceFactory extends StreamTableSourceFactory[Row] {
   * A data source that implements some very basic filtering in-memory in order to test
   * expression push-down logic.
   *
+  * <p>NOTE: Currently, only `>, >=, &lt;, <=, =, &lt;>` operators and UPPER and LOWER functions
+  * are allowed to be pushed down into this source.
+  *
   * @param isBounded whether this is a bounded source
   * @param rowTypeInfo The type info for the rows.
   * @param data The data that filtering is applied to in order to get the final dataset.
@@ -440,23 +442,23 @@ class TestFilterableTableSource(
 
   private def shouldPushDown(expr: Expression): Boolean = {
     expr match {
-      case expr: CallExpression if expr.getChildren.size() == 2 => shouldPushDown(expr)
+      case expr: CallExpression if expr.getChildren.size() == 2 =>
+        shouldPushDownUnaryExpression(expr.getChildren.head) &&
+          shouldPushDownUnaryExpression(expr.getChildren.last)
       case _ => false
     }
   }
 
-  private def shouldPushDown(binExpr: CallExpression): Boolean = {
-    val children = binExpr.getChildren
-    require(children.size() == 2)
-    (children.head, children.last) match {
-      case (f: FieldReferenceExpression, _: ValueLiteralExpression) =>
-        filterableFields.contains(f.getName)
-      case (_: ValueLiteralExpression, f: FieldReferenceExpression) =>
-        filterableFields.contains(f.getName)
-      case (f1: FieldReferenceExpression, f2: FieldReferenceExpression) =>
-        filterableFields.contains(f1.getName) && filterableFields.contains(f2.getName)
-      case (_, _) => false
-    }
+  private def shouldPushDownUnaryExpression(expr: Expression): Boolean = expr match {
+    case f: FieldReferenceExpression => filterableFields.contains(f.getName)
+    case _: ValueLiteralExpression => true
+    case c: CallExpression if c.getChildren.size() == 1 =>
+      c.getFunctionDefinition match {
+        case BuiltInFunctionDefinitions.UPPER | BuiltInFunctionDefinitions.LOWER =>
+          shouldPushDownUnaryExpression(c.getChildren.head)
+        case _ => false
+      }
+    case _ => false
   }
 
   private def shouldKeep(row: Row): Boolean = {
@@ -493,39 +495,30 @@ class TestFilterableTableSource(
       row: Row): (Comparable[Any], Comparable[Any]) = {
     val children = binExpr.getChildren
     require(children.size() == 2)
-
-    (children.head, children.last) match {
-      case (l: FieldReferenceExpression, r: ValueLiteralExpression) =>
-        val idx = rowTypeInfo.getFieldIndex(l.getName)
-        val lv = row.getField(idx).asInstanceOf[Comparable[Any]]
-        val rv = getValue(r)
-        (lv, rv)
-      case (l: ValueLiteralExpression, r: FieldReferenceExpression) =>
-        val idx = rowTypeInfo.getFieldIndex(r.getName)
-        val lv = getValue(l)
-        val rv = row.getField(idx).asInstanceOf[Comparable[Any]]
-        (lv, rv)
-      case (l: ValueLiteralExpression, r: ValueLiteralExpression) =>
-        val lv = getValue(l)
-        val rv = getValue(r)
-        (lv, rv)
-      case (l: FieldReferenceExpression, r: FieldReferenceExpression) =>
-        val lidx = rowTypeInfo.getFieldIndex(l.getName)
-        val ridx = rowTypeInfo.getFieldIndex(r.getName)
-        val lv = row.getField(lidx).asInstanceOf[Comparable[Any]]
-        val rv = row.getField(ridx).asInstanceOf[Comparable[Any]]
-        (lv, rv)
-      case _ => throw new RuntimeException(binExpr + " not supported!")
-    }
+    (getValue(children.head, row), getValue(children.last, row))
   }
 
-  private def getValue(v: ValueLiteralExpression): Comparable[Any] = {
-    val value = v.getValueAs(v.getOutputDataType.getConversionClass)
-    if (value.isPresent) {
-      value.get().asInstanceOf[Comparable[Any]]
-    } else {
-      null
-    }
+  private def getValue(expr: Expression, row: Row): Comparable[Any] = expr match {
+    case v: ValueLiteralExpression =>
+      val value = v.getValueAs(v.getOutputDataType.getConversionClass)
+      if (value.isPresent) {
+        value.get().asInstanceOf[Comparable[Any]]
+      } else {
+        null
+      }
+    case f: FieldReferenceExpression =>
+      val idx = rowTypeInfo.getFieldIndex(f.getName)
+      row.getField(idx).asInstanceOf[Comparable[Any]]
+    case c: CallExpression if c.getChildren.size() == 1 =>
+      val child = getValue(c.getChildren.head, row)
+      c.getFunctionDefinition match {
+        case BuiltInFunctionDefinitions.UPPER =>
+          child.toString.toUpperCase.asInstanceOf[Comparable[Any]]
+        case BuiltInFunctionDefinitions.LOWER =>
+          child.toString.toLowerCase().asInstanceOf[Comparable[Any]]
+        case _ => throw new RuntimeException(c + " not supported!")
+      }
+    case _ => throw new RuntimeException(expr + " not supported!")
   }
 
   override def getTableSchema: TableSchema = new TableSchema(fieldNames, fieldTypes)
@@ -558,16 +551,16 @@ object TestFilterableTableSource {
     new TestFilterableTableSource(isBounded, rowTypeInfo, rows, filterableFields)
   }
 
-  private lazy val defaultFilterableFields = Set("amount")
+  val defaultFilterableFields = Set("amount")
 
-  private lazy val defaultTypeInfo: RowTypeInfo = {
+  val defaultTypeInfo: RowTypeInfo = {
     val fieldNames: Array[String] = Array("name", "id", "amount", "price")
     val fieldTypes: Array[TypeInformation[_]] =
       Array(Types.STRING, Types.LONG, Types.INT, Types.DOUBLE)
     new RowTypeInfo(fieldTypes, fieldNames)
   }
 
-  private lazy val defaultRows: Seq[Row] = {
+  val defaultRows: Seq[Row] = {
     for {
       cnt <- 0 until 33
     } yield {
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/expressions/PlannerExpressionConverter.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/expressions/PlannerExpressionConverter.scala
index 5d89de961eb..cb9f6b19e45 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/expressions/PlannerExpressionConverter.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/expressions/PlannerExpressionConverter.scala
@@ -272,6 +272,10 @@ class PlannerExpressionConverter private extends ApiExpressionVisitor[PlannerExp
             assert(args.size == 1)
             Lower(args.head)
 
+          case LOWERCASE =>
+            assert(args.size == 1)
+            Lower(args.head)
+
           case SIMILAR =>
             assert(args.size == 2)
             Similar(args.head, args.last)
@@ -308,6 +312,10 @@ class PlannerExpressionConverter private extends ApiExpressionVisitor[PlannerExp
             assert(args.size == 1)
             Upper(args.head)
 
+          case UPPERCASE =>
+            assert(args.size == 1)
+            Upper(args.head)
+
           case POSITION =>
             assert(args.size == 2)
             Position(args.head, args.last)
