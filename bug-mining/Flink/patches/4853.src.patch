diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategy.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategy.java
index 5e36b16cc8b..52cc8e52270 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategy.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategy.java
@@ -25,9 +25,10 @@ import org.apache.flink.runtime.scheduler.ExecutionVertexDeploymentOption;
 import org.apache.flink.runtime.scheduler.SchedulerOperations;
 import org.apache.flink.util.IterableUtils;
 
+import org.apache.flink.shaded.guava18.com.google.common.collect.Sets;
+
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.function.Predicate;
@@ -125,20 +126,15 @@ public class LazyFromSourcesSchedulingStrategy implements SchedulingStrategy {
 	private void allocateSlotsAndDeployExecutionVertices(
 			final Iterable<? extends SchedulingExecutionVertex> vertices) {
 
-		final Set<ExecutionVertexID> verticesToDeploy = IterableUtils.toStream(vertices)
-			.filter(IS_IN_CREATED_EXECUTION_STATE.and(isInputConstraintSatisfied()))
-			.map(SchedulingExecutionVertex::getId)
-			.collect(Collectors.toSet());
-
-		final List<ExecutionVertexDeploymentOption> vertexDeploymentOptions =
-			SchedulingStrategyUtils.createExecutionVertexDeploymentOptionsInTopologicalOrder(
-				schedulingTopology,
-				verticesToDeploy,
-				deploymentOptions::get);
+		final Set<SchedulingExecutionVertex> vertexSet = Sets.newHashSet(vertices);
 
-		for (ExecutionVertexDeploymentOption deploymentOption : vertexDeploymentOptions) {
-			schedulerOperations.allocateSlotsAndDeploy(Collections.singletonList(deploymentOption));
-		}
+		// do the check right before scheduling each vertex in case that a vertex's status is changed
+		// when scheduling other vertices
+		IterableUtils.toStream(schedulingTopology.getVertices())
+			.filter((v -> vertexSet.contains(v)))
+			.filter(IS_IN_CREATED_EXECUTION_STATE.and(isInputConstraintSatisfied()))
+			.map(v -> new ExecutionVertexDeploymentOption(v.getId(), deploymentOptions.get(v.getId())))
+			.forEach(d -> schedulerOperations.allocateSlotsAndDeploy(Collections.singletonList(d)));
 	}
 
 	private Predicate<SchedulingExecutionVertex> isInputConstraintSatisfied() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategyTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategyTest.java
index df11b9960f3..e8d926b7b1b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategyTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/LazyFromSourcesSchedulingStrategyTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
 import org.apache.flink.runtime.scheduler.ExecutionVertexDeploymentOption;
 import org.apache.flink.util.TestLogger;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -33,6 +34,7 @@ import java.util.stream.Collectors;
 
 import static org.apache.flink.api.common.InputDependencyConstraint.ALL;
 import static org.apache.flink.runtime.io.network.partition.ResultPartitionType.PIPELINED;
+import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.lessThanOrEqualTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
@@ -42,7 +44,12 @@ import static org.junit.Assert.assertThat;
  */
 public class LazyFromSourcesSchedulingStrategyTest extends TestLogger {
 
-	private TestingSchedulerOperations testingSchedulerOperation = new TestingSchedulerOperations();
+	private TestingSchedulerOperations testingSchedulerOperation;
+
+	@Before
+	public void setUp() {
+		testingSchedulerOperation = new TestingSchedulerOperations();
+	}
 
 	/**
 	 * Tests that when start scheduling lazy from sources scheduling strategy will start input vertices in scheduling topology.
@@ -343,6 +350,26 @@ public class LazyFromSourcesSchedulingStrategyTest extends TestLogger {
 		assertLatestScheduledVerticesAreEqualTo(consumers);
 	}
 
+	@Test
+	public void testOnlyCreatedVertexWillBeScheduled() {
+		final TestingSchedulingTopology testingSchedulingTopology = new TestingSchedulingTopology();
+		final TestingSchedulingExecutionVertex v1 = testingSchedulingTopology.newExecutionVertex();
+		final TestingSchedulingExecutionVertex v2 = testingSchedulingTopology.newExecutionVertex();
+
+		testingSchedulerOperation = new TestingSchedulerOperations() {
+			@Override
+			public void allocateSlotsAndDeploy(List<ExecutionVertexDeploymentOption> executionVertexDeploymentOptions) {
+				super.allocateSlotsAndDeploy(executionVertexDeploymentOptions);
+
+				// set v2 to CANCELED so that is should not be scheduled
+				v2.setState(ExecutionState.CANCELED);
+			}
+		};
+		startScheduling(testingSchedulingTopology);
+
+		assertThat(testingSchedulerOperation.getScheduledVertices(), hasSize(1));
+	}
+
 	private LazyFromSourcesSchedulingStrategy startScheduling(TestingSchedulingTopology testingSchedulingTopology) {
 		LazyFromSourcesSchedulingStrategy schedulingStrategy = new LazyFromSourcesSchedulingStrategy(
 			testingSchedulerOperation,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/TestingSchedulingExecutionVertex.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/TestingSchedulingExecutionVertex.java
index 39537dcabf9..9d042a3ca9a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/TestingSchedulingExecutionVertex.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/strategy/TestingSchedulingExecutionVertex.java
@@ -42,7 +42,7 @@ public class TestingSchedulingExecutionVertex implements SchedulingExecutionVert
 
 	private final InputDependencyConstraint inputDependencyConstraint;
 
-	private final ExecutionState executionState;
+	private ExecutionState executionState;
 
 	public TestingSchedulingExecutionVertex(
 			JobVertexID jobVertexId,
@@ -68,6 +68,10 @@ public class TestingSchedulingExecutionVertex implements SchedulingExecutionVert
 		return executionState;
 	}
 
+	public void setState(ExecutionState state) {
+		this.executionState = state;
+	}
+
 	@Override
 	public Iterable<TestingSchedulingResultPartition> getConsumedResults() {
 		return consumedPartitions;
