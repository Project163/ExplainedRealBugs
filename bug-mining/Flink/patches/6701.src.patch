diff --git a/docs/layouts/shortcodes/generated/pulsar_consumer_configuration.html b/docs/layouts/shortcodes/generated/pulsar_consumer_configuration.html
index 4e05b270de4..e206ff4f20f 100644
--- a/docs/layouts/shortcodes/generated/pulsar_consumer_configuration.html
+++ b/docs/layouts/shortcodes/generated/pulsar_consumer_configuration.html
@@ -58,7 +58,7 @@
         </tr>
         <tr>
             <td><h5>pulsar.consumer.deadLetterPolicy.maxRedeliverCount</h5></td>
-            <td style="word-wrap: break-word;">0</td>
+            <td style="word-wrap: break-word;">(none)</td>
             <td>Integer</td>
             <td>The maximum number of times that a message are redelivered before being sent to the dead letter queue.</td>
         </tr>
diff --git a/docs/layouts/shortcodes/generated/pulsar_source_configuration.html b/docs/layouts/shortcodes/generated/pulsar_source_configuration.html
index 3bcdad85e1a..65053e4b0ef 100644
--- a/docs/layouts/shortcodes/generated/pulsar_source_configuration.html
+++ b/docs/layouts/shortcodes/generated/pulsar_source_configuration.html
@@ -8,6 +8,12 @@
         </tr>
     </thead>
     <tbody>
+        <tr>
+            <td><h5>pulsar.source.allowKeySharedOutOfOrderDelivery</h5></td>
+            <td style="word-wrap: break-word;">false</td>
+            <td>Boolean</td>
+            <td>If enabled, it will relax the ordering requirement, allowing the broker to send out-of-order messages in case of failures. This will make it faster for new consumers to join without being stalled by an existing slow consumer.<br />In this case, a single consumer will still receive all the keys, but they may be coming in different orders.</td>
+        </tr>
         <tr>
             <td><h5>pulsar.source.autoCommitCursorInterval</h5></td>
             <td style="word-wrap: break-word;">5000</td>
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/common/utils/PulsarSerdeUtils.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/common/utils/PulsarSerdeUtils.java
index 93609bc720d..ffe041b9bd7 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/common/utils/PulsarSerdeUtils.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/common/utils/PulsarSerdeUtils.java
@@ -27,8 +27,10 @@ import org.apache.flink.util.function.FunctionWithException;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -75,6 +77,32 @@ public final class PulsarSerdeUtils {
         }
     }
 
+    // Common List serialization.
+
+    public static <T> void serializeList(
+            DataOutputStream out,
+            List<T> list,
+            BiConsumerWithException<DataOutputStream, T, IOException> serializer)
+            throws IOException {
+        out.writeInt(list.size());
+        for (T t : list) {
+            serializer.accept(out, t);
+        }
+    }
+
+    public static <T> List<T> deserializeList(
+            DataInputStream in, FunctionWithException<DataInputStream, T, IOException> deserializer)
+            throws IOException {
+        int size = in.readInt();
+        List<T> set = new ArrayList<>(size);
+        for (int i = 0; i < size; i++) {
+            T t = deserializer.apply(in);
+            set.add(t);
+        }
+
+        return set;
+    }
+
     // Common Set serialization.
 
     public static <T> void serializeSet(
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilder.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilder.java
index 1a5d6ea9758..5309dd0eea0 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilder.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilder.java
@@ -33,7 +33,7 @@ import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.range.FullRangeGenerator;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator;
-import org.apache.flink.connector.pulsar.source.enumerator.topic.range.UniformRangeGenerator;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.SplitRangeGenerator;
 import org.apache.flink.connector.pulsar.source.reader.deserializer.PulsarDeserializationSchema;
 
 import org.apache.pulsar.client.api.RegexSubscriptionMode;
@@ -426,8 +426,8 @@ public final class PulsarSourceBuilder<OUT> {
             if (rangeGenerator == null) {
                 LOG.warn(
                         "No range generator provided for key_shared subscription,"
-                                + " we would use the UniformRangeGenerator as the default range generator.");
-                this.rangeGenerator = new UniformRangeGenerator();
+                                + " we would use the SplitRangeGenerator as the default range generator.");
+                this.rangeGenerator = new SplitRangeGenerator();
             }
         } else {
             // Override the range generator.
@@ -501,7 +501,7 @@ public final class PulsarSourceBuilder<OUT> {
 
     // ------------- private helpers  --------------
 
-    /** Helper method for java compiler recognize the generic type. */
+    /** Helper method for java compiler recognizes the generic type. */
     @SuppressWarnings("unchecked")
     private <T extends OUT> PulsarSourceBuilder<T> specialized() {
         return (PulsarSourceBuilder<T>) this;
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceOptions.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceOptions.java
index c80ddd3b1fa..440e96b4f71 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceOptions.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/PulsarSourceOptions.java
@@ -71,7 +71,7 @@ public final class PulsarSourceOptions {
     ///////////////////////////////////////////////////////////////////////////////
     //
     // The configuration for pulsar source part.
-    // All the configuration listed below should have the pulsar.source prefix.
+    // All the configurations listed below should have the pulsar.source prefix.
     //
     ///////////////////////////////////////////////////////////////////////////////
 
@@ -189,10 +189,25 @@ public final class PulsarSourceOptions {
                                             " A possible solution is to adjust the retention settings in Pulsar or ignoring the check result.")
                                     .build());
 
+    public static final ConfigOption<Boolean> PULSAR_ALLOW_KEY_SHARED_OUT_OF_ORDER_DELIVERY =
+            ConfigOptions.key(SOURCE_CONFIG_PREFIX + "allowKeySharedOutOfOrderDelivery")
+                    .booleanType()
+                    .defaultValue(false)
+                    .withDescription(
+                            Description.builder()
+                                    .text(
+                                            "If enabled, it will relax the ordering requirement, allowing the broker to send out-of-order messages in case of failures.")
+                                    .text(
+                                            " This will make it faster for new consumers to join without being stalled by an existing slow consumer.")
+                                    .linebreak()
+                                    .text(
+                                            "In this case, a single consumer will still receive all the keys, but they may be coming in different orders.")
+                                    .build());
+
     ///////////////////////////////////////////////////////////////////////////////
     //
     // The configuration for ConsumerConfigurationData part.
-    // All the configuration listed below should have the pulsar.consumer prefix.
+    // All the configurations listed below should have the pulsar.consumer prefix.
     //
     ///////////////////////////////////////////////////////////////////////////////
 
@@ -548,7 +563,7 @@ public final class PulsarSourceOptions {
     public static final ConfigOption<Integer> PULSAR_MAX_REDELIVER_COUNT =
             ConfigOptions.key(CONSUMER_CONFIG_PREFIX + "deadLetterPolicy.maxRedeliverCount")
                     .intType()
-                    .defaultValue(0)
+                    .noDefaultValue()
                     .withDescription(
                             "The maximum number of times that a message are redelivered before being sent to the dead letter queue.");
 
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarConsumerBuilder.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarConsumerBuilder.java
new file mode 100644
index 00000000000..09e4322af45
--- /dev/null
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarConsumerBuilder.java
@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.connector.pulsar.source.config;
+
+import org.apache.flink.shaded.guava30.com.google.common.base.Strings;
+
+import org.apache.pulsar.client.api.Consumer;
+import org.apache.pulsar.client.api.ConsumerInterceptor;
+import org.apache.pulsar.client.api.DeadLetterPolicy;
+import org.apache.pulsar.client.api.PulsarClient;
+import org.apache.pulsar.client.api.Schema;
+import org.apache.pulsar.client.impl.ConsumerBuilderImpl;
+import org.apache.pulsar.client.impl.ConsumerInterceptors;
+import org.apache.pulsar.client.impl.PulsarClientImpl;
+import org.apache.pulsar.client.impl.conf.ConsumerConfigurationData;
+import org.apache.pulsar.common.naming.TopicName;
+
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+import static org.apache.pulsar.client.util.RetryMessageUtil.DLQ_GROUP_TOPIC_SUFFIX;
+import static org.apache.pulsar.client.util.RetryMessageUtil.MAX_RECONSUMETIMES;
+import static org.apache.pulsar.client.util.RetryMessageUtil.RETRY_GROUP_TOPIC_SUFFIX;
+
+/** Override the default consumer builder for supporting build the custom Key_Shared consumer. */
+public class PulsarConsumerBuilder<T> extends ConsumerBuilderImpl<T> {
+
+    public PulsarConsumerBuilder(PulsarClient client, Schema<T> schema) {
+        super((PulsarClientImpl) client, schema);
+    }
+
+    @Override
+    public CompletableFuture<Consumer<T>> subscribeAsync() {
+        PulsarClientImpl client = super.getClient();
+        ConsumerConfigurationData<T> conf = super.getConf();
+        Schema<T> schema = super.getSchema();
+        List<ConsumerInterceptor<T>> interceptorList = super.getInterceptorList();
+
+        // Override the default subscribeAsync for skipping the subscription validation.
+        if (conf.isRetryEnable()) {
+            TopicName topicFirst = TopicName.get(conf.getTopicNames().iterator().next());
+            String retryLetterTopic =
+                    topicFirst + "-" + conf.getSubscriptionName() + RETRY_GROUP_TOPIC_SUFFIX;
+            String deadLetterTopic =
+                    topicFirst + "-" + conf.getSubscriptionName() + DLQ_GROUP_TOPIC_SUFFIX;
+
+            DeadLetterPolicy deadLetterPolicy = conf.getDeadLetterPolicy();
+            if (deadLetterPolicy == null) {
+                conf.setDeadLetterPolicy(
+                        DeadLetterPolicy.builder()
+                                .maxRedeliverCount(MAX_RECONSUMETIMES)
+                                .retryLetterTopic(retryLetterTopic)
+                                .deadLetterTopic(deadLetterTopic)
+                                .build());
+            } else {
+                if (Strings.isNullOrEmpty(deadLetterPolicy.getRetryLetterTopic())) {
+                    deadLetterPolicy.setRetryLetterTopic(retryLetterTopic);
+                }
+                if (Strings.isNullOrEmpty(deadLetterPolicy.getDeadLetterTopic())) {
+                    deadLetterPolicy.setDeadLetterTopic(deadLetterTopic);
+                }
+            }
+
+            conf.getTopicNames().add(conf.getDeadLetterPolicy().getRetryLetterTopic());
+        }
+
+        if (interceptorList == null || interceptorList.isEmpty()) {
+            return client.subscribeAsync(conf, schema, null);
+        } else {
+            return client.subscribeAsync(conf, schema, new ConsumerInterceptors<>(interceptorList));
+        }
+    }
+}
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarSourceConfigUtils.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarSourceConfigUtils.java
index 0a4dc31e8d3..063d588decc 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarSourceConfigUtils.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/PulsarSourceConfigUtils.java
@@ -21,6 +21,7 @@ package org.apache.flink.connector.pulsar.source.config;
 import org.apache.flink.annotation.Internal;
 import org.apache.flink.connector.pulsar.common.config.PulsarConfigValidator;
 
+import org.apache.pulsar.client.api.BatchReceivePolicy;
 import org.apache.pulsar.client.api.Consumer;
 import org.apache.pulsar.client.api.ConsumerBuilder;
 import org.apache.pulsar.client.api.DeadLetterPolicy;
@@ -30,6 +31,7 @@ import org.apache.pulsar.client.api.Schema;
 import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.concurrent.TimeUnit;
 
 import static java.util.concurrent.TimeUnit.MICROSECONDS;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -68,8 +70,14 @@ import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSA
 @Internal
 public final class PulsarSourceConfigUtils {
 
+    private static final BatchReceivePolicy DISABLED_BATCH_RECEIVE_POLICY =
+            BatchReceivePolicy.builder()
+                    .timeout(0, TimeUnit.MILLISECONDS)
+                    .maxNumMessages(1)
+                    .build();
+
     private PulsarSourceConfigUtils() {
-        // No need to create instance.
+        // No need to create an instance.
     }
 
     public static final PulsarConfigValidator SOURCE_CONFIG_VALIDATOR =
@@ -83,7 +91,7 @@ public final class PulsarSourceConfigUtils {
     /** Create a pulsar consumer builder by using the given Configuration. */
     public static <T> ConsumerBuilder<T> createConsumerBuilder(
             PulsarClient client, Schema<T> schema, SourceConfiguration configuration) {
-        ConsumerBuilder<T> builder = client.newConsumer(schema);
+        ConsumerBuilder<T> builder = new PulsarConsumerBuilder<>(client, schema);
 
         configuration.useOption(PULSAR_SUBSCRIPTION_NAME, builder::subscriptionName);
         configuration.useOption(
@@ -132,6 +140,10 @@ public final class PulsarSourceConfigUtils {
             builder.properties(properties);
         }
 
+        // Flink connector doesn't need any batch receiving behaviours.
+        // Disable the batch-receive timer for the Consumer instance.
+        builder.batchReceivePolicy(DISABLED_BATCH_RECEIVE_POLICY);
+
         return builder;
     }
 
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/SourceConfiguration.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/SourceConfiguration.java
index f957e1a5775..f9e8a65f0fc 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/SourceConfiguration.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/config/SourceConfiguration.java
@@ -34,6 +34,7 @@ import java.time.Duration;
 import java.util.Objects;
 
 import static org.apache.flink.connector.base.source.reader.SourceReaderOptions.ELEMENT_QUEUE_CAPACITY;
+import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_ALLOW_KEY_SHARED_OUT_OF_ORDER_DELIVERY;
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_AUTO_COMMIT_CURSOR_INTERVAL;
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_ENABLE_AUTO_ACKNOWLEDGE_MESSAGE;
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_MAX_FETCH_RECORDS;
@@ -61,6 +62,7 @@ public class SourceConfiguration extends PulsarConfiguration {
     private final String subscriptionName;
     private final SubscriptionType subscriptionType;
     private final SubscriptionMode subscriptionMode;
+    private final boolean allowKeySharedOutOfOrderDelivery;
 
     public SourceConfiguration(Configuration configuration) {
         super(configuration);
@@ -76,6 +78,7 @@ public class SourceConfiguration extends PulsarConfiguration {
         this.subscriptionName = get(PULSAR_SUBSCRIPTION_NAME);
         this.subscriptionType = get(PULSAR_SUBSCRIPTION_TYPE);
         this.subscriptionMode = get(PULSAR_SUBSCRIPTION_MODE);
+        this.allowKeySharedOutOfOrderDelivery = get(PULSAR_ALLOW_KEY_SHARED_OUT_OF_ORDER_DELIVERY);
     }
 
     /** The capacity of the element queue in the source reader. */
@@ -183,6 +186,11 @@ public class SourceConfiguration extends PulsarConfiguration {
         return subscriptionMode;
     }
 
+    /** Whether to enable the out-of-order delivery in Key Shared subscription. */
+    public boolean isAllowKeySharedOutOfOrderDelivery() {
+        return allowKeySharedOutOfOrderDelivery;
+    }
+
     /** Convert the subscription into a readable str. */
     public String getSubscriptionDesc() {
         return getSubscriptionName()
@@ -214,7 +222,8 @@ public class SourceConfiguration extends PulsarConfiguration {
                 && verifyInitialOffsets == that.verifyInitialOffsets
                 && Objects.equals(subscriptionName, that.subscriptionName)
                 && subscriptionType == that.subscriptionType
-                && subscriptionMode == that.subscriptionMode;
+                && subscriptionMode == that.subscriptionMode
+                && allowKeySharedOutOfOrderDelivery == that.allowKeySharedOutOfOrderDelivery;
     }
 
     @Override
@@ -230,6 +239,7 @@ public class SourceConfiguration extends PulsarConfiguration {
                 verifyInitialOffsets,
                 subscriptionName,
                 subscriptionType,
-                subscriptionMode);
+                subscriptionMode,
+                allowKeySharedOutOfOrderDelivery);
     }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializer.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializer.java
index af5e85c1b3b..30b374b45e4 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializer.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializer.java
@@ -41,7 +41,7 @@ public class PulsarSourceEnumStateSerializer
         implements SimpleVersionedSerializer<PulsarSourceEnumState> {
 
     // This version should be bumped after modifying the PulsarSourceEnumState.
-    public static final int CURRENT_VERSION = 1;
+    public static final int CURRENT_VERSION = 2;
 
     public static final PulsarSourceEnumStateSerializer INSTANCE =
             new PulsarSourceEnumStateSerializer();
@@ -71,16 +71,20 @@ public class PulsarSourceEnumStateSerializer
 
     @Override
     public PulsarSourceEnumState deserialize(int version, byte[] serialized) throws IOException {
-        // VERSION 1 deserialization, support VERSION 0 deserialization in the meantime.
+        // VERSION 2 deserialization, support VERSION 0 and 1 deserialization in the meantime.
         try (ByteArrayInputStream bais = new ByteArrayInputStream(serialized);
                 DataInputStream in = new DataInputStream(bais)) {
-            Set<TopicPartition> partitions = deserializeSet(in, deserializePartition(version));
+            Set<TopicPartition> partitions = null;
+            if (version == 2) {
+                partitions = deserializeSet(in, deserializePartition(1));
+            } else {
+                partitions = deserializeSet(in, deserializePartition(0));
+            }
 
             // Only deserialize these fields for backward compatibility.
             if (version == 0) {
-                deserializeSet(in, deserializeSplit(version));
-                deserializeMap(
-                        in, DataInput::readInt, i -> deserializeSet(i, deserializeSplit(version)));
+                deserializeSet(in, deserializeSplit(0));
+                deserializeMap(in, DataInput::readInt, i -> deserializeSet(i, deserializeSplit(0)));
                 deserializeMap(in, DataInput::readInt, i -> deserializeSet(i, DataInput::readUTF));
                 in.readBoolean();
             }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/KeySharedSplitAssigner.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/KeySharedSplitAssigner.java
new file mode 100644
index 00000000000..9ef43476f71
--- /dev/null
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/KeySharedSplitAssigner.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.connector.pulsar.source.enumerator.assigner;
+
+import org.apache.flink.annotation.Internal;
+import org.apache.flink.api.connector.source.SplitEnumeratorContext;
+import org.apache.flink.connector.pulsar.source.enumerator.PulsarSourceEnumState;
+import org.apache.flink.connector.pulsar.source.enumerator.cursor.StopCursor;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
+import org.apache.flink.connector.pulsar.source.split.PulsarPartitionSplit;
+
+import org.apache.pulsar.client.api.SubscriptionType;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+/** This assigner is used for {@link SubscriptionType#Key_Shared} subscription. */
+@Internal
+public class KeySharedSplitAssigner extends SplitAssignerBase {
+
+    public KeySharedSplitAssigner(
+            StopCursor stopCursor,
+            boolean enablePartitionDiscovery,
+            SplitEnumeratorContext<PulsarPartitionSplit> context,
+            PulsarSourceEnumState enumState) {
+        super(stopCursor, enablePartitionDiscovery, context, enumState);
+    }
+
+    @Override
+    public List<TopicPartition> registerTopicPartitions(Set<TopicPartition> fetchedPartitions) {
+        List<TopicPartition> newPartitions = new ArrayList<>();
+
+        for (TopicPartition partition : fetchedPartitions) {
+            boolean shouldAssign = false;
+            if (!appendedPartitions.contains(partition)) {
+                appendedPartitions.add(partition);
+                newPartitions.add(partition);
+                shouldAssign = true;
+            }
+
+            // Reassign the incoming splits when restarting from state.
+            if (shouldAssign || !initialized) {
+                // Calculate the reader id by the current parallelism.
+                int readerId = partitionOwner(partition);
+                PulsarPartitionSplit split = new PulsarPartitionSplit(partition, stopCursor);
+                addSplitToPendingList(readerId, split);
+            }
+        }
+
+        if (!initialized) {
+            initialized = true;
+        }
+
+        return newPartitions;
+    }
+
+    @Override
+    public void addSplitsBack(List<PulsarPartitionSplit> splits, int subtaskId) {
+        if (splits.isEmpty()) {
+            // In case of the task failure. No splits will be put back to the enumerator.
+            for (TopicPartition partition : appendedPartitions) {
+                int readId = partitionOwner(partition);
+                if (readId == subtaskId) {
+                    PulsarPartitionSplit split = new PulsarPartitionSplit(partition, stopCursor);
+                    addSplitToPendingList(subtaskId, split);
+                }
+            }
+        } else {
+            // Manually put all the splits back to the enumerator.
+            for (PulsarPartitionSplit split : splits) {
+                int readerId = partitionOwner(split.getPartition());
+                addSplitToPendingList(readerId, split);
+            }
+        }
+    }
+}
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssigner.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssigner.java
index 1b7b4a6f446..1cc061e2ae6 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssigner.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssigner.java
@@ -19,7 +19,6 @@
 package org.apache.flink.connector.pulsar.source.enumerator.assigner;
 
 import org.apache.flink.annotation.Internal;
-import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.connector.source.SplitEnumeratorContext;
 import org.apache.flink.connector.pulsar.source.enumerator.PulsarSourceEnumState;
 import org.apache.flink.connector.pulsar.source.enumerator.cursor.StopCursor;
@@ -34,7 +33,7 @@ import java.util.Set;
 
 /**
  * This assigner is used for {@link SubscriptionType#Failover}, {@link SubscriptionType#Exclusive}
- * and {@link SubscriptionType#Key_Shared} subscriptions.
+ * subscriptions.
  */
 @Internal
 class NonSharedSplitAssigner extends SplitAssignerBase {
@@ -77,36 +76,4 @@ class NonSharedSplitAssigner extends SplitAssignerBase {
             addSplitToPendingList(readerId, split);
         }
     }
-
-    /**
-     * Returns the index of the target subtask that a specific partition should be assigned to. It's
-     * inspired by the {@code KafkaSourceEnumerator.getSplitOwner()}
-     *
-     * <p>The resulting distribution of partition has the following contract:
-     *
-     * <ul>
-     *   <li>1. Uniformly distributed across subtasks.
-     *   <li>2. Partitions are round-robin distributed (strictly clockwise w.r.t. ascending subtask
-     *       indices) by using the partition id as the offset from a starting index (i.e., the index
-     *       of the subtask which partition 0 of the topic will be assigned to, determined using the
-     *       topic name).
-     * </ul>
-     *
-     * @param partition The Pulsar partition to assign.
-     * @return The id of the reader that owns this partition.
-     */
-    private int partitionOwner(TopicPartition partition) {
-        return calculatePartitionOwner(
-                partition.getTopic(), partition.getPartitionId(), context.currentParallelism());
-    }
-
-    @VisibleForTesting
-    static int calculatePartitionOwner(String topic, int partitionId, int parallelism) {
-        int startIndex = ((topic.hashCode() * 31) & 0x7FFFFFFF) % parallelism;
-        /*
-         * Here, the assumption is that the id of Pulsar partitions are always ascending starting from
-         * 0. Therefore, can be used directly as the offset clockwise from the start index.
-         */
-        return (startIndex + partitionId) % parallelism;
-    }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerBase.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerBase.java
index 32af433acbb..733072ca7e4 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerBase.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerBase.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.connector.pulsar.source.enumerator.assigner;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.connector.source.SplitEnumeratorContext;
 import org.apache.flink.api.connector.source.SplitsAssignment;
 import org.apache.flink.connector.pulsar.source.enumerator.PulsarSourceEnumState;
@@ -99,4 +100,36 @@ abstract class SplitAssignerBase implements SplitAssigner {
                 pendingPartitionSplits.computeIfAbsent(readerId, i -> new HashSet<>());
         splits.add(split);
     }
+
+    /**
+     * Returns the index of the target subtask that a specific partition should be assigned to. It's
+     * inspired by the {@code KafkaSourceEnumerator.getSplitOwner()}
+     *
+     * <p>The resulting distribution of partition has the following contract:
+     *
+     * <ul>
+     *   <li>1. Uniformly distributed across subtasks.
+     *   <li>2. Partitions are round-robin distributed (strictly clockwise w.r.t. ascending subtask
+     *       indices) by using the partition id as the offset from a starting index (i.e., the index
+     *       of the subtask which partition 0 of the topic will be assigned to, determined using the
+     *       topic name).
+     * </ul>
+     *
+     * @param partition The Pulsar partition to assign.
+     * @return The id of the reader that owns this partition.
+     */
+    protected int partitionOwner(TopicPartition partition) {
+        return calculatePartitionOwner(
+                partition.getTopic(), partition.getPartitionId(), context.currentParallelism());
+    }
+
+    @VisibleForTesting
+    static int calculatePartitionOwner(String topic, int partitionId, int parallelism) {
+        int startIndex = ((topic.hashCode() * 31) & 0x7FFFFFFF) % parallelism;
+        /*
+         * Here, the assumption is that the id of Pulsar partitions are always ascending starting from
+         * 0. Therefore, can be used directly as the offset clockwise from the start index.
+         */
+        return (startIndex + partitionId) % parallelism;
+    }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerFactory.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerFactory.java
index 02f8934a6bf..4ade1e561a7 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerFactory.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerFactory.java
@@ -46,12 +46,14 @@ public final class SplitAssignerFactory {
         switch (subscriptionType) {
             case Failover:
             case Exclusive:
-            case Key_Shared:
                 return new NonSharedSplitAssigner(
                         stopCursor, enablePartitionDiscovery, context, enumState);
             case Shared:
                 return new SharedSplitAssigner(
                         stopCursor, enablePartitionDiscovery, context, enumState);
+            case Key_Shared:
+                return new KeySharedSplitAssigner(
+                        stopCursor, enablePartitionDiscovery, context, enumState);
             default:
                 throw new IllegalArgumentException(
                         "We don't support this subscription type: " + subscriptionType);
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/BasePulsarSubscriber.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/BasePulsarSubscriber.java
index d29f7a0d548..0e11996f9a5 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/BasePulsarSubscriber.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/BasePulsarSubscriber.java
@@ -23,6 +23,7 @@ import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode;
 
 import org.apache.pulsar.client.admin.PulsarAdmin;
 import org.apache.pulsar.client.admin.PulsarAdminException;
@@ -31,7 +32,7 @@ import org.apache.pulsar.common.partition.PartitionedTopicMetadata;
 import java.util.ArrayList;
 import java.util.List;
 
-import static java.util.stream.Collectors.toList;
+import static java.util.Collections.singletonList;
 
 /** PulsarSubscriber abstract class to simplify Pulsar admin related operations. */
 public abstract class BasePulsarSubscriber implements PulsarSubscriber {
@@ -49,29 +50,42 @@ public abstract class BasePulsarSubscriber implements PulsarSubscriber {
                 // Return null for skipping the topic metadata query.
                 return null;
             } else {
-                // This method would cause the failure for subscriber.
+                // This method would cause failure for subscribers.
                 throw new IllegalStateException(e);
             }
         }
     }
 
     protected List<TopicPartition> toTopicPartitions(
-            TopicMetadata metadata, List<TopicRange> ranges) {
+            TopicMetadata metadata, List<TopicRange> ranges, KeySharedMode mode) {
         if (!metadata.isPartitioned()) {
             // For non-partitioned topic.
-            return ranges.stream()
-                    .map(range -> new TopicPartition(metadata.getName(), -1, range))
-                    .collect(toList());
+            return toTopicPartitions(metadata.getName(), -1, ranges, mode);
         } else {
+            // For partitioned topic.
             List<TopicPartition> partitions = new ArrayList<>();
             for (int i = 0; i < metadata.getPartitionSize(); i++) {
+                partitions.addAll(toTopicPartitions(metadata.getName(), i, ranges, mode));
+            }
+            return partitions;
+        }
+    }
+
+    protected List<TopicPartition> toTopicPartitions(
+            String topic, int partitionId, List<TopicRange> ranges, KeySharedMode mode) {
+        switch (mode) {
+            case JOIN:
+                return singletonList(new TopicPartition(topic, partitionId, ranges, mode));
+            case SPLIT:
+                List<TopicPartition> partitions = new ArrayList<>(ranges.size());
                 for (TopicRange range : ranges) {
-                    TopicPartition partition = new TopicPartition(metadata.getName(), i, range);
+                    TopicPartition partition =
+                            new TopicPartition(topic, partitionId, singletonList(range), mode);
                     partitions.add(partition);
                 }
-            }
-
-            return partitions;
+                return partitions;
+            default:
+                throw new UnsupportedOperationException(mode + " isn't supported.");
         }
     }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicListSubscriber.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicListSubscriber.java
index 28f525b2d07..127adddc845 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicListSubscriber.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicListSubscriber.java
@@ -22,6 +22,7 @@ import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode;
 
 import org.apache.pulsar.client.admin.PulsarAdmin;
 import org.apache.pulsar.common.naming.TopicName;
@@ -62,9 +63,9 @@ public class TopicListSubscriber extends BasePulsarSubscriber {
         for (String topic : fullTopicNames) {
             TopicMetadata metadata = queryTopicMetadata(pulsarAdmin, topic);
             List<TopicRange> ranges = rangeGenerator.range(metadata, parallelism);
-            List<TopicPartition> list = toTopicPartitions(metadata, ranges);
+            KeySharedMode mode = rangeGenerator.keyShareMode(metadata, parallelism);
 
-            results.addAll(list);
+            results.addAll(toTopicPartitions(metadata, ranges, mode));
         }
 
         for (String partition : partitions) {
@@ -74,10 +75,9 @@ public class TopicListSubscriber extends BasePulsarSubscriber {
 
             TopicMetadata metadata = queryTopicMetadata(pulsarAdmin, name);
             List<TopicRange> ranges = rangeGenerator.range(metadata, parallelism);
+            KeySharedMode mode = rangeGenerator.keyShareMode(metadata, parallelism);
 
-            for (TopicRange range : ranges) {
-                results.add(new TopicPartition(name, index, range));
-            }
+            results.addAll(toTopicPartitions(name, index, ranges, mode));
         }
 
         return results;
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicPatternSubscriber.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicPatternSubscriber.java
index fae2bac7b3e..6173fcaba71 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicPatternSubscriber.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/impl/TopicPatternSubscriber.java
@@ -22,6 +22,7 @@ import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode;
 
 import org.apache.pulsar.client.admin.PulsarAdmin;
 import org.apache.pulsar.client.admin.PulsarAdminException;
@@ -74,7 +75,9 @@ public class TopicPatternSubscriber extends BasePulsarSubscriber {
                             metadata -> {
                                 List<TopicRange> ranges =
                                         rangeGenerator.range(metadata, parallelism);
-                                return toTopicPartitions(metadata, ranges).stream();
+                                KeySharedMode mode =
+                                        rangeGenerator.keyShareMode(metadata, parallelism);
+                                return toTopicPartitions(metadata, ranges, mode).stream();
                             })
                     .collect(toSet());
         } catch (PulsarAdminException e) {
@@ -82,7 +85,7 @@ public class TopicPatternSubscriber extends BasePulsarSubscriber {
                 // Skip the topic metadata query.
                 return Collections.emptySet();
             } else {
-                // This method would cause the failure for subscriber.
+                // This method would cause failure for subscribers.
                 throw new IllegalStateException(e);
             }
         }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartition.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartition.java
index b3035cde848..b25851027a9 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartition.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartition.java
@@ -18,17 +18,25 @@
 
 package org.apache.flink.connector.pulsar.source.enumerator.topic;
 
+import org.apache.flink.annotation.Internal;
 import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.connector.base.source.reader.splitreader.SplitReader;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode;
+
+import org.apache.flink.shaded.guava30.com.google.common.collect.ImmutableList;
 
 import org.apache.pulsar.client.api.Range;
 import org.apache.pulsar.client.api.SubscriptionType;
 
 import java.io.Serializable;
+import java.util.List;
 import java.util.Objects;
 
+import static java.util.stream.Collectors.toList;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils.topicName;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils.topicNameWithPartition;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode.SPLIT;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /**
@@ -39,15 +47,17 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
 public class TopicPartition implements Serializable {
     private static final long serialVersionUID = -1474354741550810953L;
 
+    private static final List<TopicRange> FULL_RANGES = ImmutableList.of(createFullRange());
+
     /**
-     * The topic name of the pulsar. It would be a full topic name, if your don't provide the tenant
+     * The topic name of the pulsar. It would be a full topic name. If you don't provide the tenant
      * and namespace, we would add them automatically.
      */
     private final String topic;
 
     /**
-     * Index of partition for the topic. It would be natural number for partitioned topic with a
-     * non-key_shared subscription.
+     * Index of partition for the topic. It would be a natural number for the partitioned topic with
+     * a non-key_shared subscription.
      */
     private final int partitionId;
 
@@ -56,12 +66,28 @@ public class TopicPartition implements Serializable {
      * TopicRange#createFullRange()} full range for all the subscription type except {@link
      * SubscriptionType#Key_Shared}.
      */
-    private final TopicRange range;
+    private final List<TopicRange> ranges;
+
+    /**
+     * The key share mode for the {@link SubscriptionType#Key_Shared}. It will be {@link
+     * KeySharedMode#JOIN} for other subscriptions.
+     */
+    private final KeySharedMode mode;
+
+    public TopicPartition(String topic, int partitionId) {
+        this(topic, partitionId, FULL_RANGES, SPLIT);
+    }
+
+    public TopicPartition(String topic, int partitionId, List<TopicRange> ranges) {
+        this(topic, partitionId, ranges, SPLIT);
+    }
 
-    public TopicPartition(String topic, int partitionId, TopicRange range) {
+    public TopicPartition(
+            String topic, int partitionId, List<TopicRange> ranges, KeySharedMode mode) {
         this.topic = topicName(checkNotNull(topic));
         this.partitionId = partitionId;
-        this.range = checkNotNull(range);
+        this.ranges = checkNotNull(ranges);
+        this.mode = mode;
     }
 
     public String getTopic() {
@@ -84,12 +110,22 @@ public class TopicPartition implements Serializable {
         }
     }
 
-    public TopicRange getRange() {
-        return range;
+    /** This method is internal used for serialization. */
+    @Internal
+    public List<TopicRange> getRanges() {
+        return ranges;
     }
 
-    public Range getPulsarRange() {
-        return range.toPulsarRange();
+    /** This method is internal used for define key shared subscription. */
+    @Internal
+    public List<Range> getPulsarRanges() {
+        return ranges.stream().map(TopicRange::toPulsarRange).collect(toList());
+    }
+
+    /** This method is internal used for key shared mode. */
+    @Internal
+    public KeySharedMode getMode() {
+        return mode;
     }
 
     @Override
@@ -100,19 +136,21 @@ public class TopicPartition implements Serializable {
         if (o == null || getClass() != o.getClass()) {
             return false;
         }
-        TopicPartition that = (TopicPartition) o;
-        return partitionId == that.partitionId
-                && topic.equals(that.topic)
-                && range.equals(that.range);
+        TopicPartition partition = (TopicPartition) o;
+
+        return partitionId == partition.partitionId
+                && topic.equals(partition.topic)
+                && ranges.equals(partition.ranges)
+                && mode == partition.mode;
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(topic, partitionId, range);
+        return Objects.hash(topic, partitionId, ranges, mode);
     }
 
     @Override
     public String toString() {
-        return getFullTopicName() + "|" + range;
+        return getFullTopicName() + "|" + ranges;
     }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedKeysRangeGenerator.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedKeysRangeGenerator.java
new file mode 100644
index 00000000000..e21147d54b8
--- /dev/null
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedKeysRangeGenerator.java
@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
+
+import org.apache.flink.annotation.PublicEvolving;
+import org.apache.flink.connector.pulsar.sink.writer.message.PulsarMessageBuilder;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.TypedMessageBuilder;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.NONE_KEY;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.keyBytesHash;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.keyHash;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.validateTopicRanges;
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
+/**
+ * Pulsar didn't expose the key hash range method. We have to provide an implementation for
+ * end-user. You can add the keys you want to consume, no need to provide any hash ranges.
+ *
+ * <p>Since the key's hash isn't specified to only one key. The consuming results may contain the
+ * messages with different keys comparing the keys you have defined in this range generator.
+ * Remember to use flink's <code>DataStream.filter()</code> method.
+ *
+ * <p>Usage: <code><pre>
+ * FixedKeysRangeGenerator.builder()
+ *     .supportNullKey()
+ *     .key("someKey")
+ *     .keys(Arrays.asList("key1", "key2"))
+ *     .build()
+ * </pre></code>
+ */
+@PublicEvolving
+public class FixedKeysRangeGenerator implements RangeGenerator {
+    private static final long serialVersionUID = 2372969466289052100L;
+
+    private final List<TopicRange> ranges;
+    private final KeySharedMode sharedMode;
+
+    private FixedKeysRangeGenerator(List<TopicRange> ranges, KeySharedMode sharedMode) {
+        this.ranges = ranges;
+        this.sharedMode = sharedMode;
+    }
+
+    @Override
+    public List<TopicRange> range(TopicMetadata metadata, int parallelism) {
+        return ranges;
+    }
+
+    @Override
+    public KeySharedMode keyShareMode(TopicMetadata metadata, int parallelism) {
+        return sharedMode;
+    }
+
+    public static FixedKeysRangeGeneratorBuilder builder() {
+        return new FixedKeysRangeGeneratorBuilder();
+    }
+
+    /** The builder for {@link FixedKeysRangeGenerator}. */
+    @PublicEvolving
+    public static class FixedKeysRangeGeneratorBuilder {
+
+        private final SortedSet<Integer> keyHashes = new TreeSet<>();
+        private KeySharedMode sharedMode = KeySharedMode.JOIN;
+
+        private FixedKeysRangeGeneratorBuilder() {
+            // No public for builder
+        }
+
+        /**
+         * Some {@link Message} in Pulsar may not have {@link Message#getOrderingKey()} or {@link
+         * Message#getKey()}, use this method for supporting consuming such messages.
+         */
+        public FixedKeysRangeGeneratorBuilder supportNullKey() {
+            keyHashes.add(keyHash(NONE_KEY));
+            return this;
+        }
+
+        /**
+         * If you set the message key by using {@link PulsarMessageBuilder#key(String)} or {@link
+         * TypedMessageBuilder#key(String)}, use this method for supporting consuming such messages.
+         */
+        public FixedKeysRangeGeneratorBuilder key(String key) {
+            keyHashes.add(keyHash(key));
+            return this;
+        }
+
+        /** Same as the {@link #key(String)}, support setting multiple keys in the same time. */
+        public FixedKeysRangeGeneratorBuilder keys(Collection<String> someKeys) {
+            checkNotNull(someKeys);
+            for (String someKey : someKeys) {
+                keyHashes.add(keyHash(someKey));
+            }
+            return this;
+        }
+
+        /**
+         * If you set the message key by using {@link TypedMessageBuilder#keyBytes(byte[])}, use
+         * this method for supporting consuming such messages.
+         */
+        public FixedKeysRangeGeneratorBuilder keyBytes(byte[] keyBytes) {
+            keyHashes.add(keyBytesHash(keyBytes));
+            return this;
+        }
+
+        /**
+         * Pulsar's ordering key is prior to the message key. If you set the ordering key by using
+         * {@link PulsarMessageBuilder#orderingKey(byte[])} or {@link
+         * TypedMessageBuilder#orderingKey(byte[])}, use this method for supporting consuming such
+         * messages.
+         */
+        public FixedKeysRangeGeneratorBuilder orderingKey(byte[] keyBytes) {
+            keyHashes.add(keyHash(keyBytes));
+            return this;
+        }
+
+        /** Override the default {@link KeySharedMode#JOIN} to the mode your have provided. */
+        public FixedKeysRangeGeneratorBuilder keySharedMode(KeySharedMode sharedMode) {
+            this.sharedMode = sharedMode;
+            return this;
+        }
+
+        /** Create the FixedKeysRangeGenerator by the given keys. */
+        public FixedKeysRangeGenerator build() {
+            List<TopicRange> ranges = new ArrayList<>();
+            // Calculate the topic ranges.
+            Integer start = null;
+            Integer next = null;
+            for (Integer hash : keyHashes) {
+                // Start
+                if (start == null) {
+                    start = hash;
+                    next = hash;
+                    continue;
+                }
+
+                // Continue range.
+                if (hash - next == 1) {
+                    next = hash;
+                    continue;
+                }
+
+                // Found one continues topic range.
+                TopicRange range = new TopicRange(start, next);
+                ranges.add(range);
+
+                start = hash;
+                next = hash;
+            }
+
+            // Support the last range.
+            if (start != null) {
+                TopicRange range = new TopicRange(start, next);
+                ranges.add(range);
+            }
+
+            validateTopicRanges(ranges, sharedMode);
+            return new FixedKeysRangeGenerator(ranges, sharedMode);
+        }
+    }
+}
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedRangeGenerator.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedRangeGenerator.java
index 6f82725d8d5..84c41e96e01 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedRangeGenerator.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FixedRangeGenerator.java
@@ -18,23 +18,40 @@
 
 package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
 
+import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
 
 import java.util.List;
 
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.validateTopicRanges;
+
 /** Always return the same range set for all topics. */
+@PublicEvolving
 public class FixedRangeGenerator implements RangeGenerator {
     private static final long serialVersionUID = -3895203007855538734L;
 
     private final List<TopicRange> ranges;
+    private final KeySharedMode sharedMode;
 
     public FixedRangeGenerator(List<TopicRange> ranges) {
+        this(ranges, KeySharedMode.JOIN);
+    }
+
+    public FixedRangeGenerator(List<TopicRange> ranges, KeySharedMode sharedMode) {
+        validateTopicRanges(ranges, sharedMode);
+
         this.ranges = ranges;
+        this.sharedMode = sharedMode;
     }
 
     @Override
     public List<TopicRange> range(TopicMetadata metadata, int parallelism) {
         return ranges;
     }
+
+    @Override
+    public KeySharedMode keyShareMode(TopicMetadata metadata, int parallelism) {
+        return sharedMode;
+    }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FullRangeGenerator.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FullRangeGenerator.java
index 31d5c73d9f6..1ac69e00af9 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FullRangeGenerator.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/FullRangeGenerator.java
@@ -18,23 +18,31 @@
 
 package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
 
+import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
 
 import org.apache.pulsar.client.api.SubscriptionType;
 
-import java.util.Collections;
 import java.util.List;
 
+import static java.util.Collections.singletonList;
+
 /**
  * Default implementation for {@link SubscriptionType#Shared}, {@link SubscriptionType#Failover} and
  * {@link SubscriptionType#Exclusive} subscription.
  */
+@PublicEvolving
 public class FullRangeGenerator implements RangeGenerator {
     private static final long serialVersionUID = -4571731955155036216L;
 
     @Override
     public List<TopicRange> range(TopicMetadata metadata, int parallelism) {
-        return Collections.singletonList(TopicRange.createFullRange());
+        return singletonList(TopicRange.createFullRange());
+    }
+
+    @Override
+    public KeySharedMode keyShareMode(TopicMetadata metadata, int parallelism) {
+        return KeySharedMode.SPLIT;
     }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/RangeGenerator.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/RangeGenerator.java
index 825ebdb1d6d..8bfdcbafb8c 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/RangeGenerator.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/RangeGenerator.java
@@ -51,7 +51,18 @@ public interface RangeGenerator extends Serializable {
      */
     List<TopicRange> range(TopicMetadata metadata, int parallelism);
 
-    /** Initialize some extra resource when bootstrap the source. */
+    /**
+     * Defines the default behavior for Key_Shared subscription in Flink. See {@link KeySharedMode}
+     * for the detailed usage of the key share mode.
+     *
+     * @param metadata The metadata of the topic.
+     * @param parallelism The reader size for this topic.
+     */
+    default KeySharedMode keyShareMode(TopicMetadata metadata, int parallelism) {
+        return KeySharedMode.SPLIT;
+    }
+
+    /** Initialize some extra resources when bootstrap the source. */
     default void open(SourceConfiguration sourceConfiguration) {
         // This method is used for user implementation.
         open(sourceConfiguration, sourceConfiguration);
@@ -62,4 +73,32 @@ public interface RangeGenerator extends Serializable {
     default void open(Configuration configuration, SourceConfiguration sourceConfiguration) {
         // This method is used for user implementation.
     }
+
+    /**
+     * Different Key_Shared mode means different split assignment behaviors. If you only consume a
+     * subset of Pulsar's key hash range, remember to use the {@link KeySharedMode#JOIN} mode which
+     * will subscribe all the range in only one reader. Otherwise, when the ranges can join into a
+     * full Pulsar key hash range (0 ~ 65535) you should use {@link KeySharedMode#SPLIT} for sharing
+     * the splits among all the backend readers.
+     *
+     * <p>In the {@link KeySharedMode#SPLIT} mode. The topic will be subscribed by multiple readers.
+     * But Pulsar has one limit in this situation. That is if a Message can't find the corresponding
+     * reader by the key hash range. No messages will be delivered to the current readers, until
+     * there is a reader which can subscribe to such messages.
+     */
+    @PublicEvolving
+    enum KeySharedMode {
+
+        /**
+         * The topic ranges that the {@link RangeGenerator} generated will be split among the
+         * readers.
+         */
+        SPLIT,
+
+        /**
+         * Assign all the topic ranges to only one reader instance. This is used for partial key
+         * hash range subscription.
+         */
+        JOIN
+    }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/UniformRangeGenerator.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/SplitRangeGenerator.java
similarity index 55%
rename from flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/UniformRangeGenerator.java
rename to flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/SplitRangeGenerator.java
index 814cf9eee1f..17653269bac 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/UniformRangeGenerator.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/SplitRangeGenerator.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
 
+import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
 
@@ -27,27 +28,55 @@ import java.util.ArrayList;
 import java.util.List;
 
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.MAX_RANGE;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.RANGE_SIZE;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.MIN_RANGE;
+import static org.apache.flink.util.Preconditions.checkArgument;
 
 /**
  * This range generator would divide the range by the flink source parallelism. It would be the
  * default implementation for {@link SubscriptionType#Key_Shared} subscription.
  */
-public class UniformRangeGenerator implements RangeGenerator {
-    private static final long serialVersionUID = -7292650922683609268L;
+@PublicEvolving
+public class SplitRangeGenerator implements RangeGenerator {
+    private static final long serialVersionUID = -8682286436352905249L;
+
+    private final int start;
+    private final int end;
+
+    public SplitRangeGenerator() {
+        this(MIN_RANGE, MAX_RANGE);
+    }
+
+    public SplitRangeGenerator(int start, int end) {
+        checkArgument(
+                start >= MIN_RANGE,
+                "Start range should be equal to or great than the min range " + MIN_RANGE);
+        checkArgument(
+                end <= MAX_RANGE, "End range should below or less than the max range " + MAX_RANGE);
+        checkArgument(start <= end, "Start range should be equal to or less than the end range");
+
+        this.start = start;
+        this.end = end;
+    }
 
     @Override
     public List<TopicRange> range(TopicMetadata metadata, int parallelism) {
-        List<TopicRange> results = new ArrayList<>(parallelism);
+        final int range = end - start + 1;
+        final int size = Math.min(range, parallelism);
+        int startRange = start;
 
-        int startRange = 0;
-        for (int i = 1; i < parallelism; i++) {
-            int nextStartRange = i * RANGE_SIZE / parallelism;
+        List<TopicRange> results = new ArrayList<>(size);
+        for (int i = 1; i < size; i++) {
+            int nextStartRange = i * range / size + start;
             results.add(new TopicRange(startRange, nextStartRange - 1));
             startRange = nextStartRange;
         }
-        results.add(new TopicRange(startRange, MAX_RANGE));
+        results.add(new TopicRange(startRange, end));
 
         return results;
     }
+
+    @Override
+    public KeySharedMode keyShareMode(TopicMetadata metadata, int parallelism) {
+        return KeySharedMode.SPLIT;
+    }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/TopicRangeUtils.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/TopicRangeUtils.java
new file mode 100644
index 00000000000..8728bdeee3f
--- /dev/null
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/TopicRangeUtils.java
@@ -0,0 +1,136 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
+
+import org.apache.flink.annotation.PublicEvolving;
+import org.apache.flink.connector.pulsar.sink.writer.message.PulsarMessageBuilder;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode;
+
+import org.apache.pulsar.client.api.KeySharedPolicy;
+import org.apache.pulsar.client.api.Message;
+import org.apache.pulsar.client.api.Range;
+import org.apache.pulsar.client.api.TypedMessageBuilder;
+import org.apache.pulsar.common.util.Murmur3_32Hash;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Base64;
+import java.util.List;
+
+import static java.util.Comparator.comparingLong;
+import static java.util.stream.Collectors.toList;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.MAX_RANGE;
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
+/**
+ * This is the helper class for Pulsar's {@link Range}, used in Key Shared mode. It will be exposed
+ * to the end users for simplifying the implementation of the {@link RangeGenerator}.
+ */
+@PublicEvolving
+public final class TopicRangeUtils {
+    private static final Logger LOG = LoggerFactory.getLogger(TopicRangeUtils.class);
+
+    /** Pulsar would use this as default key if no key was provided. */
+    public static final String NONE_KEY = "NONE_KEY";
+
+    private TopicRangeUtils() {
+        // No public constructor.
+    }
+
+    /** Make sure all the ranges should be valid in Pulsar Key Shared Policy. */
+    public static void validateTopicRanges(List<TopicRange> ranges, KeySharedMode sharedMode) {
+        List<Range> pulsarRanges = ranges.stream().map(TopicRange::toPulsarRange).collect(toList());
+        KeySharedPolicy.stickyHashRange().ranges(pulsarRanges).validate();
+
+        if (!isFullTopicRanges(ranges) && KeySharedMode.SPLIT == sharedMode) {
+            LOG.warn(
+                    "You have provided a partial key hash range with KeySharedMode.SPLIT. "
+                            + "You can't consume any message if there are any messages with keys that are out of the given ranges.");
+        }
+    }
+
+    /** Check if the given topic ranges are full Pulsar range. */
+    public static boolean isFullTopicRanges(List<TopicRange> ranges) {
+        List<TopicRange> sorted =
+                ranges.stream().sorted(comparingLong(TopicRange::getStart)).collect(toList());
+        int start = 0;
+        for (TopicRange range : sorted) {
+            if (start == 0) {
+                if (range.getStart() == 0) {
+                    start = range.getEnd();
+                    continue;
+                } else {
+                    return false;
+                }
+            }
+
+            if (range.getStart() - start != 1) {
+                return false;
+            }
+            start = range.getEnd();
+        }
+
+        return start == MAX_RANGE;
+    }
+
+    /**
+     * Pulsar didn't expose the key hash range method. We have to manually define it here.
+     *
+     * @param key The key of Pulsar's {@link Message}. Pulsar would try to use {@link
+     *     Message#getOrderingKey()} first. If it doesn't exist Pulsar will use {@link
+     *     Message#getKey()} instead. Remember that the {@link Message#getOrderingKey()} could be
+     *     configured by {@link PulsarMessageBuilder#orderingKey(byte[])} and the {@link
+     *     Message#getKey()} could be configured by {@link PulsarMessageBuilder#key(String)}.
+     */
+    public static int keyHash(String key) {
+        checkNotNull(key);
+        return keyHash(key.getBytes(StandardCharsets.UTF_8));
+    }
+
+    /**
+     * This method is a bit of different compared to the {@link #keyHash(byte[])}. We only define
+     * this method when you set the message key by using {@link
+     * TypedMessageBuilder#keyBytes(byte[])}. Because the Pulsar would calculate the message key
+     * hash in a different way.
+     *
+     * <p>It should be <strong>a bug on Pulsar</strong>, but we can't fix it for backward
+     * compatibility.
+     */
+    public static int keyBytesHash(byte[] keyBytes) {
+        String encodedKey = Base64.getEncoder().encodeToString(checkNotNull(keyBytes));
+        byte[] encodedKeyBytes = encodedKey.getBytes(StandardCharsets.UTF_8);
+        return keyHash(encodedKeyBytes);
+    }
+
+    /**
+     * Pulsar didn't expose the key hash range method. We have to manually define it here.
+     *
+     * @param keyBytes The key bytes of Pulsar's {@link Message}. Pulsar would try to use {@link
+     *     Message#getOrderingKey()} first. If it doesn't exist Pulsar will use {@link
+     *     Message#getKey()} instead. Remember that the {@link Message#getOrderingKey()} could be
+     *     configured by {@link PulsarMessageBuilder#orderingKey(byte[])} and the {@link
+     *     Message#getKey()} could be configured by {@link PulsarMessageBuilder#key(String)}.
+     */
+    public static int keyHash(byte[] keyBytes) {
+        int stickyKeyHash = Murmur3_32Hash.getInstance().makeHash(checkNotNull(keyBytes));
+        return stickyKeyHash % TopicRange.RANGE_SIZE;
+    }
+}
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderBase.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderBase.java
index c659a7a4936..b884c576733 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderBase.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderBase.java
@@ -57,6 +57,8 @@ import java.util.concurrent.TimeoutException;
 
 import static org.apache.flink.connector.pulsar.common.utils.PulsarExceptionUtils.sneakyClient;
 import static org.apache.flink.connector.pulsar.source.config.PulsarSourceConfigUtils.createConsumerBuilder;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode.JOIN;
+import static org.apache.pulsar.client.api.KeySharedPolicy.stickyHashRange;
 
 /**
  * The common partition split reader.
@@ -236,9 +238,17 @@ abstract class PulsarPartitionSplitReaderBase<OUT>
 
         // Add KeySharedPolicy for Key_Shared subscription.
         if (sourceConfiguration.getSubscriptionType() == SubscriptionType.Key_Shared) {
-            KeySharedPolicy policy =
-                    KeySharedPolicy.stickyHashRange().ranges(partition.getPulsarRange());
+            KeySharedPolicy policy = stickyHashRange().ranges(partition.getPulsarRanges());
+            // We may enable out of order delivery for speeding up. It was turned off by default.
+            policy.setAllowOutOfOrderDelivery(
+                    sourceConfiguration.isAllowKeySharedOutOfOrderDelivery());
             consumerBuilder.keySharedPolicy(policy);
+
+            if (partition.getMode() == JOIN) {
+                // Override the key shared subscription into exclusive for making it behaviors like
+                // a Pulsar Reader which supports partial key hash ranges.
+                consumerBuilder.subscriptionType(SubscriptionType.Exclusive);
+            }
         }
 
         // Create the consumer configuration by using common utils.
diff --git a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializer.java b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializer.java
index 15f126f66f7..fb88d3d910d 100644
--- a/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializer.java
+++ b/flink-connectors/flink-connector-pulsar/src/main/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializer.java
@@ -21,6 +21,7 @@ package org.apache.flink.connector.pulsar.source.split;
 import org.apache.flink.connector.pulsar.source.enumerator.cursor.StopCursor;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode;
 import org.apache.flink.core.io.SimpleVersionedSerializer;
 
 import org.apache.pulsar.client.api.MessageId;
@@ -31,10 +32,14 @@ import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.util.List;
 
+import static java.util.Collections.singletonList;
 import static org.apache.flink.connector.pulsar.common.utils.PulsarSerdeUtils.deserializeBytes;
+import static org.apache.flink.connector.pulsar.common.utils.PulsarSerdeUtils.deserializeList;
 import static org.apache.flink.connector.pulsar.common.utils.PulsarSerdeUtils.deserializeObject;
 import static org.apache.flink.connector.pulsar.common.utils.PulsarSerdeUtils.serializeBytes;
+import static org.apache.flink.connector.pulsar.common.utils.PulsarSerdeUtils.serializeList;
 import static org.apache.flink.connector.pulsar.common.utils.PulsarSerdeUtils.serializeObject;
 
 /** The {@link SimpleVersionedSerializer serializer} for {@link PulsarPartitionSplit}. */
@@ -45,7 +50,7 @@ public class PulsarPartitionSplitSerializer
             new PulsarPartitionSplitSerializer();
 
     // This version should be bumped after modifying the PulsarPartitionSplit.
-    public static final int CURRENT_VERSION = 0;
+    public static final int CURRENT_VERSION = 1;
 
     private PulsarPartitionSplitSerializer() {
         // Singleton instance.
@@ -136,23 +141,45 @@ public class PulsarPartitionSplitSerializer
 
     public void serializeTopicPartition(DataOutputStream out, TopicPartition partition)
             throws IOException {
-        // VERSION 0 serialization
-        TopicRange range = partition.getRange();
+        // VERSION 1 serialization
         out.writeUTF(partition.getTopic());
         out.writeInt(partition.getPartitionId());
-        out.writeInt(range.getStart());
-        out.writeInt(range.getEnd());
+        serializeList(
+                out,
+                partition.getRanges(),
+                (o, r) -> {
+                    o.writeInt(r.getStart());
+                    o.writeInt(r.getEnd());
+                });
+        out.writeInt(partition.getMode().ordinal());
     }
 
     public TopicPartition deserializeTopicPartition(int version, DataInputStream in)
             throws IOException {
-        // VERSION 0 deserialization
         String topic = in.readUTF();
         int partitionId = in.readInt();
-        int start = in.readInt();
-        int end = in.readInt();
+        List<TopicRange> ranges;
+        KeySharedMode keySharedMode;
+        if (version == 0) {
+            // VERSION 0 deserialization
+            int start = in.readInt();
+            int end = in.readInt();
+            TopicRange range = new TopicRange(start, end);
+            ranges = singletonList(range);
+            keySharedMode = KeySharedMode.SPLIT;
+        } else {
+            // VERSION 1 deserialization
+            ranges =
+                    deserializeList(
+                            in,
+                            i -> {
+                                int start = i.readInt();
+                                int end = i.readInt();
+                                return new TopicRange(start, end);
+                            });
+            keySharedMode = KeySharedMode.values()[in.readInt()];
+        }
 
-        TopicRange range = new TopicRange(start, end);
-        return new TopicPartition(topic, partitionId, range);
+        return new TopicPartition(topic, partitionId, ranges, keySharedMode);
     }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilderTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilderTest.java
index 5825e4e7020..644523a33bc 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilderTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/PulsarSourceBuilderTest.java
@@ -19,7 +19,7 @@
 package org.apache.flink.connector.pulsar.source;
 
 import org.apache.flink.configuration.Configuration;
-import org.apache.flink.connector.pulsar.source.enumerator.topic.range.UniformRangeGenerator;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.range.SplitRangeGenerator;
 
 import org.apache.pulsar.client.api.Schema;
 import org.apache.pulsar.client.api.SubscriptionType;
@@ -73,7 +73,7 @@ class PulsarSourceBuilderTest {
     void rangeGeneratorRequiresKeyShared() {
         PulsarSourceBuilder<String> builder = new PulsarSourceBuilder<>();
         builder.setSubscriptionType(SubscriptionType.Shared);
-        UniformRangeGenerator rangeGenerator = new UniformRangeGenerator();
+        SplitRangeGenerator rangeGenerator = new SplitRangeGenerator();
 
         assertThatThrownBy(() -> builder.setRangeGenerator(rangeGenerator))
                 .isInstanceOf(IllegalArgumentException.class);
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializerTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializerTest.java
index 54687a3277e..a584d67d169 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializerTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumStateSerializerTest.java
@@ -18,16 +18,23 @@
 
 package org.apache.flink.connector.pulsar.source.enumerator;
 
+import org.apache.flink.connector.pulsar.source.enumerator.cursor.StopCursor;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.util.InstantiationUtil;
 
 import org.apache.flink.shaded.guava30.com.google.common.collect.Sets;
 
+import org.apache.pulsar.client.api.MessageId;
 import org.junit.jupiter.api.Test;
 
+import java.io.IOException;
 import java.util.Set;
 
+import static java.util.Collections.singletonList;
 import static org.apache.commons.lang3.RandomStringUtils.randomAlphabetic;
+import static org.apache.commons.lang3.RandomStringUtils.randomNumeric;
 import static org.apache.flink.connector.pulsar.source.enumerator.PulsarSourceEnumStateSerializer.INSTANCE;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -37,19 +44,97 @@ import static org.junit.jupiter.api.Assertions.assertNotSame;
 class PulsarSourceEnumStateSerializerTest {
 
     @Test
-    void serializeAndDeserializePulsarSourceEnumState() throws Exception {
+    void version2SerializeAndDeserialize() throws Exception {
         Set<TopicPartition> partitions =
                 Sets.newHashSet(
-                        new TopicPartition(randomAlphabetic(10), 2, new TopicRange(1, 30)),
-                        new TopicPartition(randomAlphabetic(10), 1, createFullRange()));
+                        new TopicPartition(
+                                randomAlphabetic(10), 2, singletonList(new TopicRange(1, 30))),
+                        new TopicPartition(
+                                randomAlphabetic(10), 1, singletonList(createFullRange())));
 
         PulsarSourceEnumState state = new PulsarSourceEnumState(partitions);
 
         byte[] bytes = INSTANCE.serialize(state);
-        PulsarSourceEnumState state1 = INSTANCE.deserialize(INSTANCE.getVersion(), bytes);
+        PulsarSourceEnumState state1 = INSTANCE.deserialize(2, bytes);
 
         assertEquals(state.getAppendedPartitions(), state1.getAppendedPartitions());
-
         assertNotSame(state, state1);
     }
+
+    @Test
+    void version1Deserialize() throws Exception {
+        // Serialize in version 1 logic.
+        DataOutputSerializer serializer = new DataOutputSerializer(4096);
+        serializer.writeInt(2);
+        serializer.writeUTF("topic1");
+        serializer.writeInt(0);
+        serializer.writeInt(300);
+        serializer.writeInt(4000);
+        serializer.writeUTF("topic2");
+        serializer.writeInt(4);
+        serializer.writeInt(600);
+        serializer.writeInt(8000);
+        byte[] bytes = serializer.getSharedBuffer();
+
+        PulsarSourceEnumState state = INSTANCE.deserialize(1, bytes);
+        Set<TopicPartition> partitions = state.getAppendedPartitions();
+        Set<TopicPartition> expectedPartitions =
+                Sets.newHashSet(
+                        new TopicPartition("topic1", 0, singletonList(new TopicRange(300, 4000))),
+                        new TopicPartition("topic2", 4, singletonList(new TopicRange(600, 8000))));
+
+        assertEquals(partitions, expectedPartitions);
+    }
+
+    @Test
+    void version0Deserialize() throws Exception {
+        DataOutputSerializer serializer = new DataOutputSerializer(4096);
+        // Serialize in version 0 logic.
+        serializer.writeInt(2);
+        serializer.writeUTF("topic3");
+        serializer.writeInt(5);
+        serializer.writeInt(600);
+        serializer.writeInt(2000);
+        serializer.writeUTF("topic4");
+        serializer.writeInt(8);
+        serializer.writeInt(300);
+        serializer.writeInt(1000);
+        serializeVersion0SplitSet(serializer);
+        serializer.writeInt(1);
+        serializer.writeInt(3);
+        serializeVersion0SplitSet(serializer);
+        serializer.writeInt(1);
+        serializer.writeInt(1);
+        serializer.writeInt(1);
+        serializer.writeUTF("some-topic");
+        serializer.writeBoolean(true);
+        byte[] bytes = serializer.getSharedBuffer();
+
+        PulsarSourceEnumState state = INSTANCE.deserialize(0, bytes);
+        Set<TopicPartition> partitions = state.getAppendedPartitions();
+        Set<TopicPartition> expectedPartitions =
+                Sets.newHashSet(
+                        new TopicPartition("topic3", 5, singletonList(new TopicRange(600, 2000))),
+                        new TopicPartition("topic4", 8, singletonList(new TopicRange(300, 1000))));
+
+        assertEquals(partitions, expectedPartitions);
+    }
+
+    private void serializeVersion0SplitSet(DataOutputSerializer serializer) throws IOException {
+        serializer.writeInt(1);
+        serializer.writeUTF("topic" + randomNumeric(2));
+        serializer.writeInt(2);
+        serializer.writeInt(400);
+        serializer.writeInt(5000);
+        byte[] stopCursorBytes = InstantiationUtil.serializeObject(StopCursor.latest());
+        serializer.writeInt(stopCursorBytes.length);
+        serializer.write(stopCursorBytes);
+        serializer.writeBoolean(true);
+        byte[] messageIdBytes = MessageId.latest.toByteArray();
+        serializer.writeInt(messageIdBytes.length);
+        serializer.write(messageIdBytes);
+        serializer.writeBoolean(true);
+        serializer.writeLong(1000);
+        serializer.writeLong(2000);
+    }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumeratorTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumeratorTest.java
index 9c81438d02c..702a567408f 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumeratorTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/PulsarSourceEnumeratorTest.java
@@ -53,7 +53,6 @@ import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSA
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_SUBSCRIPTION_TYPE;
 import static org.apache.flink.connector.pulsar.source.enumerator.PulsarSourceEnumState.initialState;
 import static org.apache.flink.connector.pulsar.source.enumerator.subscriber.PulsarSubscriber.getTopicPatternSubscriber;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.apache.flink.connector.pulsar.testutils.runtime.PulsarRuntimeOperator.DEFAULT_PARTITIONS;
 import static org.apache.flink.shaded.guava30.com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -414,7 +413,7 @@ class PulsarSourceEnumeratorTest extends PulsarTestSuiteBase {
         Set<TopicPartition> allPartitions = new HashSet<>();
         for (String topicName : topics) {
             for (int i = 0; i < DEFAULT_PARTITIONS; i++) {
-                allPartitions.add(new TopicPartition(topicName, i, createFullRange()));
+                allPartitions.add(new TopicPartition(topicName, i));
             }
         }
         return allPartitions;
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssignerTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssignerTest.java
index 58f8d8fc51c..bc2d669aeb9 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssignerTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/NonSharedSplitAssignerTest.java
@@ -36,7 +36,7 @@ import java.util.Optional;
 import java.util.Set;
 
 import static java.util.Collections.singletonList;
-import static org.apache.flink.connector.pulsar.source.enumerator.assigner.NonSharedSplitAssigner.calculatePartitionOwner;
+import static org.apache.flink.connector.pulsar.source.enumerator.assigner.SplitAssignerBase.calculatePartitionOwner;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerTestBase.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerTestBase.java
index e9b7be52def..712ab509e65 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerTestBase.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/assigner/SplitAssignerTestBase.java
@@ -40,7 +40,6 @@ import static java.util.Collections.singleton;
 import static java.util.Collections.singletonList;
 import static org.apache.flink.connector.pulsar.source.enumerator.PulsarSourceEnumState.initialState;
 import static org.apache.flink.connector.pulsar.source.enumerator.cursor.StopCursor.defaultStopCursor;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.assertj.core.api.Assertions.assertThat;
 
 /** Test utils for split assigners. */
@@ -93,7 +92,7 @@ abstract class SplitAssignerTestBase extends TestLogger {
     }
 
     protected Set<TopicPartition> createPartitions(String topic, int partitionId) {
-        TopicPartition p1 = new TopicPartition(topic, partitionId, createFullRange());
+        TopicPartition p1 = new TopicPartition(topic, partitionId);
         return singleton(p1);
     }
 
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/cursor/StopCursorTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/cursor/StopCursorTest.java
index 301368b6f4a..831d9e0eba3 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/cursor/StopCursorTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/cursor/StopCursorTest.java
@@ -43,7 +43,6 @@ import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSA
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_MAX_FETCH_TIME;
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_SUBSCRIPTION_NAME;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils.topicNameWithPartition;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.apache.flink.connector.pulsar.source.reader.deserializer.PulsarDeserializationSchema.flinkSchema;
 import static org.assertj.core.api.Assertions.assertThat;
 
@@ -68,7 +67,7 @@ class StopCursorTest extends PulsarTestSuiteBase {
                         Schema.STRING,
                         randomAlphanumeric(10));
         long currentTimeStamp = System.currentTimeMillis();
-        TopicPartition partition = new TopicPartition(topicName, 0, createFullRange());
+        TopicPartition partition = new TopicPartition(topicName, 0);
         PulsarPartitionSplit split =
                 new PulsarPartitionSplit(
                         partition,
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/PulsarSubscriberTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/PulsarSubscriberTest.java
index f57980e3481..cb8819d2dc9 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/PulsarSubscriberTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/subscriber/PulsarSubscriberTest.java
@@ -37,7 +37,6 @@ import static org.apache.flink.connector.pulsar.source.enumerator.subscriber.Pul
 import static org.apache.flink.connector.pulsar.source.enumerator.subscriber.PulsarSubscriber.getTopicPatternSubscriber;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils.topicName;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils.topicNameWithPartition;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.apache.pulsar.client.api.RegexSubscriptionMode.AllTopics;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -81,8 +80,8 @@ class PulsarSubscriberTest extends PulsarTestSuiteBase {
         Set<TopicPartition> expectedPartitions = new HashSet<>();
 
         for (int i = 0; i < NUM_PARTITIONS_PER_TOPIC; i++) {
-            expectedPartitions.add(new TopicPartition(topic1, i, createFullRange()));
-            expectedPartitions.add(new TopicPartition(topic2, i, createFullRange()));
+            expectedPartitions.add(new TopicPartition(topic1, i));
+            expectedPartitions.add(new TopicPartition(topic2, i));
         }
 
         assertEquals(expectedPartitions, topicPartitions);
@@ -97,7 +96,7 @@ class PulsarSubscriberTest extends PulsarTestSuiteBase {
                 subscriber.getSubscribedTopicPartitions(
                         operator().admin(), new FullRangeGenerator(), NUM_PARALLELISM);
 
-        TopicPartition desiredPartition = new TopicPartition(topic1, 2, createFullRange());
+        TopicPartition desiredPartition = new TopicPartition(topic1, 2);
         assertThat(partitions).hasSize(1).containsExactly(desiredPartition);
     }
 
@@ -108,7 +107,7 @@ class PulsarSubscriberTest extends PulsarTestSuiteBase {
                 subscriber.getSubscribedTopicPartitions(
                         operator().admin(), new FullRangeGenerator(), NUM_PARALLELISM);
 
-        TopicPartition desiredPartition = new TopicPartition(topic4, -1, createFullRange());
+        TopicPartition desiredPartition = new TopicPartition(topic4, -1);
         assertThat(partitions).hasSize(1).containsExactly(desiredPartition);
     }
 
@@ -125,8 +124,8 @@ class PulsarSubscriberTest extends PulsarTestSuiteBase {
 
         Set<TopicPartition> expectedPartitions = new HashSet<>();
 
-        expectedPartitions.add(new TopicPartition(topic4, -1, createFullRange()));
-        expectedPartitions.add(new TopicPartition(topic5, -1, createFullRange()));
+        expectedPartitions.add(new TopicPartition(topic4, -1));
+        expectedPartitions.add(new TopicPartition(topic5, -1));
 
         assertEquals(expectedPartitions, topicPartitions);
     }
@@ -144,8 +143,8 @@ class PulsarSubscriberTest extends PulsarTestSuiteBase {
         Set<TopicPartition> expectedPartitions = new HashSet<>();
 
         for (int i = 0; i < NUM_PARTITIONS_PER_TOPIC; i++) {
-            expectedPartitions.add(new TopicPartition(topic1, i, createFullRange()));
-            expectedPartitions.add(new TopicPartition(topic3, i, createFullRange()));
+            expectedPartitions.add(new TopicPartition(topic1, i));
+            expectedPartitions.add(new TopicPartition(topic3, i));
         }
 
         assertEquals(expectedPartitions, topicPartitions);
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartitionTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartitionTest.java
index 89e7c1f4add..7e5f171116f 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartitionTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/TopicPartitionTest.java
@@ -20,7 +20,6 @@ package org.apache.flink.connector.pulsar.source.enumerator.topic;
 
 import org.junit.jupiter.api.Test;
 
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
 /** Unit tests for {@link TopicPartition}. */
@@ -29,12 +28,12 @@ class TopicPartitionTest {
     @Test
     void topicNameForPartitionedAndNonPartitionedTopic() {
         // For partitioned topic
-        TopicPartition partition = new TopicPartition("test-name", 12, createFullRange());
+        TopicPartition partition = new TopicPartition("test-name", 12);
         assertEquals(
                 partition.getFullTopicName(), "persistent://public/default/test-name-partition-12");
 
         // For non-partitioned topic
-        TopicPartition partition1 = new TopicPartition("test-topic", -1, createFullRange());
+        TopicPartition partition1 = new TopicPartition("test-topic", -1);
         assertEquals(partition1.getFullTopicName(), "persistent://public/default/test-topic");
     }
 }
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/SplitRangeGeneratorTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/SplitRangeGeneratorTest.java
new file mode 100644
index 00000000000..ef182bf9eac
--- /dev/null
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/SplitRangeGeneratorTest.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
+
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicMetadata;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+
+import org.junit.jupiter.api.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** The unit test for {@link SplitRangeGenerator}. */
+class SplitRangeGeneratorTest {
+
+    private static final TopicMetadata METADATA = new TopicMetadata("fake", 10);
+
+    @Test
+    void rangeWithParallelismOne() {
+        SplitRangeGenerator generator = new SplitRangeGenerator(6, 65534);
+        List<TopicRange> ranges = generator.range(METADATA, 1);
+        List<TopicRange> desired = Collections.singletonList(new TopicRange(6, 65534));
+
+        assertThat(ranges).hasSize(1).containsExactlyElementsOf(desired);
+    }
+
+    @Test
+    void rangeBelowTheParallelism() {
+        SplitRangeGenerator generator = new SplitRangeGenerator(3, 10);
+        List<TopicRange> ranges = generator.range(METADATA, 12);
+        List<TopicRange> desired =
+                Arrays.asList(
+                        new TopicRange(3, 3),
+                        new TopicRange(4, 4),
+                        new TopicRange(5, 5),
+                        new TopicRange(6, 6),
+                        new TopicRange(7, 7),
+                        new TopicRange(8, 8),
+                        new TopicRange(9, 9),
+                        new TopicRange(10, 10));
+
+        assertThat(ranges).hasSize(8).containsExactlyElementsOf(desired);
+    }
+
+    @Test
+    void rangeWasDivideWithLastBiggerSize() {
+        SplitRangeGenerator generator = new SplitRangeGenerator(0, 100);
+        List<TopicRange> ranges = generator.range(METADATA, 9);
+        List<TopicRange> desired =
+                Arrays.asList(
+                        new TopicRange(0, 10),
+                        new TopicRange(11, 21),
+                        new TopicRange(22, 32),
+                        new TopicRange(33, 43),
+                        new TopicRange(44, 55),
+                        new TopicRange(56, 66),
+                        new TopicRange(67, 77),
+                        new TopicRange(78, 88),
+                        new TopicRange(89, 100));
+
+        assertThat(ranges).hasSize(9).containsExactlyElementsOf(desired);
+    }
+}
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/TopicRangeUtilsTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/TopicRangeUtilsTest.java
new file mode 100644
index 00000000000..f844aae8f84
--- /dev/null
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/enumerator/topic/range/TopicRangeUtilsTest.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.connector.pulsar.source.enumerator.topic.range;
+
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+
+import org.junit.jupiter.api.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode.JOIN;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.isFullTopicRanges;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.TopicRangeUtils.validateTopicRanges;
+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+/** Test class for {@link TopicRangeUtils}. */
+class TopicRangeUtilsTest {
+
+    @Test
+    void testValidateTopicRanges() {
+        List<TopicRange> ranges1 = Arrays.asList(new TopicRange(1, 2), new TopicRange(2, 3));
+        assertThrows(IllegalArgumentException.class, () -> validateTopicRanges(ranges1, JOIN));
+
+        List<TopicRange> ranges2 = Arrays.asList(new TopicRange(1, 14), new TopicRange(2, 5));
+        assertThrows(IllegalArgumentException.class, () -> validateTopicRanges(ranges2, JOIN));
+
+        List<TopicRange> ranges3 = Arrays.asList(new TopicRange(1, 14), new TopicRange(5, 30));
+        assertThrows(IllegalArgumentException.class, () -> validateTopicRanges(ranges3, JOIN));
+
+        List<TopicRange> ranges4 = Arrays.asList(new TopicRange(1, 14), new TopicRange(15, 30));
+        assertDoesNotThrow(() -> validateTopicRanges(ranges4, JOIN));
+    }
+
+    @Test
+    void testIsFullTopicRanges() {
+        List<TopicRange> ranges1 =
+                Arrays.asList(
+                        new TopicRange(16384, 32767),
+                        new TopicRange(0, 16383),
+                        new TopicRange(32768, 49151),
+                        new TopicRange(49152, 65535));
+        assertTrue(isFullTopicRanges(ranges1));
+
+        List<TopicRange> ranges2 =
+                Arrays.asList(
+                        new TopicRange(32768, 49151),
+                        new TopicRange(0, 16383),
+                        new TopicRange(16384, 32767),
+                        new TopicRange(49152, 65531));
+        assertFalse(isFullTopicRanges(ranges2));
+
+        List<TopicRange> ranges3 =
+                Arrays.asList(
+                        new TopicRange(33, 16383),
+                        new TopicRange(32768, 49151),
+                        new TopicRange(16384, 32767),
+                        new TopicRange(49152, 65535));
+        assertFalse(isFullTopicRanges(ranges3));
+
+        List<TopicRange> ranges4 = Collections.singletonList(TopicRange.createFullRange());
+        assertTrue(isFullTopicRanges(ranges4));
+    }
+}
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderTestBase.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderTestBase.java
index 008cee7d22f..e63424a787d 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderTestBase.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/reader/split/PulsarPartitionSplitReaderTestBase.java
@@ -65,7 +65,6 @@ import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSA
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_MAX_FETCH_TIME;
 import static org.apache.flink.connector.pulsar.source.PulsarSourceOptions.PULSAR_SUBSCRIPTION_NAME;
 import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicNameUtils.topicNameWithPartition;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
 import static org.apache.flink.connector.pulsar.source.reader.deserializer.PulsarDeserializationSchema.flinkSchema;
 import static org.apache.flink.connector.pulsar.testutils.PulsarTestCommonUtils.isAssignableFromParameterContext;
 import static org.apache.flink.connector.pulsar.testutils.extension.TestOrderlinessExtension.PULSAR_SOURCE_READER_SUBSCRIPTION_TYPE_STORE_KEY;
@@ -110,7 +109,7 @@ abstract class PulsarPartitionSplitReaderTestBase extends PulsarTestSuiteBase {
             String topicName,
             int partitionId,
             MessageId startPosition) {
-        TopicPartition partition = new TopicPartition(topicName, partitionId, createFullRange());
+        TopicPartition partition = new TopicPartition(topicName, partitionId);
         PulsarPartitionSplit split =
                 new PulsarPartitionSplit(partition, StopCursor.never(), startPosition, null);
         SplitsAddition<PulsarPartitionSplit> addition = new SplitsAddition<>(singletonList(split));
@@ -127,7 +126,7 @@ abstract class PulsarPartitionSplitReaderTestBase extends PulsarTestSuiteBase {
             String topicName,
             int partitionId,
             MessageId startPosition) {
-        TopicPartition partition = new TopicPartition(topicName, partitionId, createFullRange());
+        TopicPartition partition = new TopicPartition(topicName, partitionId);
         PulsarPartitionSplit split =
                 new PulsarPartitionSplit(partition, StopCursor.never(), null, null);
         SplitsAddition<PulsarPartitionSplit> addition = new SplitsAddition<>(singletonList(split));
diff --git a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializerTest.java b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializerTest.java
index 63350af1f91..3d4ee8860d5 100644
--- a/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializerTest.java
+++ b/flink-connectors/flink-connector-pulsar/src/test/java/org/apache/flink/connector/pulsar/source/split/PulsarPartitionSplitSerializerTest.java
@@ -20,11 +20,17 @@ package org.apache.flink.connector.pulsar.source.split;
 
 import org.apache.flink.connector.pulsar.source.enumerator.cursor.StopCursor;
 import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicPartition;
+import org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange;
+import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.util.InstantiationUtil;
 
+import org.apache.pulsar.client.api.MessageId;
+import org.apache.pulsar.client.api.transaction.TxnID;
 import org.junit.jupiter.api.Test;
 
+import static java.util.Collections.singletonList;
 import static org.apache.commons.lang3.RandomStringUtils.randomAlphabetic;
-import static org.apache.flink.connector.pulsar.source.enumerator.topic.TopicRange.createFullRange;
+import static org.apache.flink.connector.pulsar.source.enumerator.topic.range.RangeGenerator.KeySharedMode.JOIN;
 import static org.apache.flink.connector.pulsar.source.split.PulsarPartitionSplitSerializer.INSTANCE;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotSame;
@@ -33,16 +39,52 @@ import static org.junit.jupiter.api.Assertions.assertNotSame;
 class PulsarPartitionSplitSerializerTest {
 
     @Test
-    void serializeAndDeserializePulsarPartitionSplit() throws Exception {
+    void version1SerializeAndDeserialize() throws Exception {
         PulsarPartitionSplit split =
                 new PulsarPartitionSplit(
-                        new TopicPartition(randomAlphabetic(10), 10, createFullRange()),
+                        new TopicPartition(
+                                randomAlphabetic(10),
+                                10,
+                                singletonList(new TopicRange(400, 5000)),
+                                JOIN),
                         StopCursor.defaultStopCursor());
 
         byte[] bytes = INSTANCE.serialize(split);
-        PulsarPartitionSplit split1 = INSTANCE.deserialize(INSTANCE.getVersion(), bytes);
+        PulsarPartitionSplit split1 = INSTANCE.deserialize(1, bytes);
 
         assertEquals(split, split1);
         assertNotSame(split, split1);
     }
+
+    @Test
+    void version0Deserialize() throws Exception {
+        DataOutputSerializer serializer = new DataOutputSerializer(4096);
+        // Serialize in version 0 logic.
+        serializer.writeUTF("topic44");
+        serializer.writeInt(2);
+        serializer.writeInt(400);
+        serializer.writeInt(5000);
+        byte[] stopCursorBytes = InstantiationUtil.serializeObject(StopCursor.latest());
+        serializer.writeInt(stopCursorBytes.length);
+        serializer.write(stopCursorBytes);
+        serializer.writeBoolean(true);
+        byte[] messageIdBytes = MessageId.latest.toByteArray();
+        serializer.writeInt(messageIdBytes.length);
+        serializer.write(messageIdBytes);
+        serializer.writeBoolean(true);
+        serializer.writeLong(1000);
+        serializer.writeLong(2000);
+        byte[] bytes = serializer.getSharedBuffer();
+
+        PulsarPartitionSplit split = INSTANCE.deserialize(0, bytes);
+        PulsarPartitionSplit expectedSplit =
+                new PulsarPartitionSplit(
+                        new TopicPartition("topic44", 2, singletonList(new TopicRange(400, 5000))),
+                        StopCursor.latest(),
+                        MessageId.latest,
+                        new TxnID(1000, 2000));
+
+        assertEquals(split, expectedSplit);
+        assertNotSame(split, expectedSplit);
+    }
 }
