diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
index 92fe4896496..f9976d245ec 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
@@ -280,7 +280,8 @@ public class NFA<T> {
                                     computationState.getStartTimestamp() + windowTime));
                 }
 
-                sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry());
+                sharedBufferAccessor.releaseNode(
+                        computationState.getPreviousBufferEntry(), computationState.getVersion());
 
                 nfaState.setStateChanged();
             } else {
@@ -337,7 +338,9 @@ public class NFA<T> {
                 } else if (isStopState(newComputationState)) {
                     // reached stop state. release entry for the stop state
                     shouldDiscardPath = true;
-                    sharedBufferAccessor.releaseNode(newComputationState.getPreviousBufferEntry());
+                    sharedBufferAccessor.releaseNode(
+                            newComputationState.getPreviousBufferEntry(),
+                            newComputationState.getVersion());
                 } else {
                     // add new computation state; it will be processed once the next event arrives
                     statesToRetain.add(newComputationState);
@@ -349,7 +352,8 @@ public class NFA<T> {
                 // previous event from
                 // the buffer
                 for (final ComputationState state : statesToRetain) {
-                    sharedBufferAccessor.releaseNode(state.getPreviousBufferEntry());
+                    sharedBufferAccessor.releaseNode(
+                            state.getPreviousBufferEntry(), state.getVersion());
                 }
             } else {
                 newPartialMatches.addAll(statesToRetain);
@@ -379,7 +383,8 @@ public class NFA<T> {
                                         .get(0));
 
                 result.add(materializedMatch);
-                sharedBufferAccessor.releaseNode(match.getPreviousBufferEntry());
+                sharedBufferAccessor.releaseNode(
+                        match.getPreviousBufferEntry(), match.getVersion());
             }
         }
 
@@ -420,7 +425,8 @@ public class NFA<T> {
                         nfaState.getCompletedMatches(), matchedResult, sharedBufferAccessor);
 
                 result.add(sharedBufferAccessor.materializeMatch(matchedResult.get(0)));
-                sharedBufferAccessor.releaseNode(earliestMatch.getPreviousBufferEntry());
+                sharedBufferAccessor.releaseNode(
+                        earliestMatch.getPreviousBufferEntry(), earliestMatch.getVersion());
                 earliestMatch = nfaState.getCompletedMatches().peek();
             }
 
@@ -698,7 +704,8 @@ public class NFA<T> {
 
         if (computationState.getPreviousBufferEntry() != null) {
             // release the shared entry referenced by the current computation state.
-            sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry());
+            sharedBufferAccessor.releaseNode(
+                    computationState.getPreviousBufferEntry(), computationState.getVersion());
         }
 
         return resultingComputationStates;
@@ -722,7 +729,7 @@ public class NFA<T> {
                         startEventId);
         computationStates.add(computationState);
 
-        sharedBufferAccessor.lockNode(previousEntry);
+        sharedBufferAccessor.lockNode(previousEntry, computationState.getVersion());
     }
 
     private State<T> findFinalStateAfterProceed(ConditionContext context, State<T> state, T event) {
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/aftermatch/AfterMatchSkipStrategy.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/aftermatch/AfterMatchSkipStrategy.java
index 8ee02f3cdf3..346a8f9c49e 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/aftermatch/AfterMatchSkipStrategy.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/aftermatch/AfterMatchSkipStrategy.java
@@ -110,7 +110,9 @@ public abstract class AfterMatchSkipStrategy implements Serializable {
             for (ComputationState computationState : matchesToPrune) {
                 if (computationState.getStartEventID() != null
                         && shouldPrune(computationState.getStartEventID(), pruningId)) {
-                    sharedBufferAccessor.releaseNode(computationState.getPreviousBufferEntry());
+                    sharedBufferAccessor.releaseNode(
+                            computationState.getPreviousBufferEntry(),
+                            computationState.getVersion());
                     discardStates.add(computationState);
                 }
             }
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/Lockable.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/Lockable.java
index eca05f4c914..487155511e8 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/Lockable.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/Lockable.java
@@ -69,6 +69,10 @@ public final class Lockable<T> {
         return element;
     }
 
+    int getRefCounter() {
+        return refCounter;
+    }
+
     @Override
     public String toString() {
         return "Lock{" + "refCounter=" + refCounter + '}';
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBuffer.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBuffer.java
index d62d1a80f96..0c071a3d948 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBuffer.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBuffer.java
@@ -22,9 +22,15 @@ import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.state.KeyedStateStore;
 import org.apache.flink.api.common.state.MapState;
 import org.apache.flink.api.common.state.MapStateDescriptor;
+import org.apache.flink.api.common.state.ValueState;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.base.IntSerializer;
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
+import org.apache.flink.cep.nfa.DeweyNumber;
+import org.apache.flink.cep.nfa.NFAState;
+import org.apache.flink.runtime.state.KeyedStateBackend;
+import org.apache.flink.runtime.state.VoidNamespace;
+import org.apache.flink.runtime.state.VoidNamespaceSerializer;
 import org.apache.flink.util.WrappingRuntimeException;
 
 import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;
@@ -55,21 +61,22 @@ import java.util.Map;
  */
 public class SharedBuffer<V> {
 
-    private static final String entriesStateName = "sharedBuffer-entries";
+    private static final String legacyEntriesStateName = "sharedBuffer-entries";
+    private static final String entriesStateName = "sharedBuffer-entries-with-lockable-edges";
     private static final String eventsStateName = "sharedBuffer-events";
     private static final String eventsCountStateName = "sharedBuffer-events-count";
 
-    private MapState<EventId, Lockable<V>> eventsBuffer;
+    private final MapState<EventId, Lockable<V>> eventsBuffer;
     /** The number of events seen so far in the stream per timestamp. */
-    private MapState<Long, Integer> eventsCount;
+    private final MapState<Long, Integer> eventsCount;
 
-    private MapState<NodeId, Lockable<SharedBufferNode>> entries;
+    private final MapState<NodeId, Lockable<SharedBufferNode>> entries;
 
     /** The cache of eventsBuffer State. */
-    private Map<EventId, Lockable<V>> eventsBufferCache = new HashMap<>();
+    private final Map<EventId, Lockable<V>> eventsBufferCache = new HashMap<>();
 
     /** The cache of sharedBufferNode. */
-    private Map<NodeId, Lockable<SharedBufferNode>> entryCache = new HashMap<>();
+    private final Map<NodeId, Lockable<SharedBufferNode>> entryCache = new HashMap<>();
 
     public SharedBuffer(KeyedStateStore stateStore, TypeSerializer<V> valueSerializer) {
         this.eventsBuffer =
@@ -85,7 +92,7 @@ public class SharedBuffer<V> {
                                 entriesStateName,
                                 new NodeId.NodeIdSerializer(),
                                 new Lockable.LockableTypeSerializer<>(
-                                        new SharedBufferNode.SharedBufferNodeSerializer())));
+                                        new SharedBufferNodeSerializer())));
 
         this.eventsCount =
                 stateStore.getMapState(
@@ -95,6 +102,81 @@ public class SharedBuffer<V> {
                                 IntSerializer.INSTANCE));
     }
 
+    public void migrateOldState(
+            KeyedStateBackend<?> stateBackend, ValueState<NFAState> computationStates)
+            throws Exception {
+        stateBackend.applyToAllKeys(
+                VoidNamespace.INSTANCE,
+                VoidNamespaceSerializer.INSTANCE,
+                new MapStateDescriptor<>(
+                        legacyEntriesStateName,
+                        new NodeId.NodeIdSerializer(),
+                        new Lockable.LockableTypeSerializer<>(
+                                new SharedBufferNode.SharedBufferNodeSerializer())),
+                (key, state) -> {
+                    copyEntries(state);
+                    state.entries().forEach(this::lockPredecessorEdges);
+                    state.clear();
+
+                    NFAState nfaState = computationStates.value();
+                    nfaState.getPartialMatches()
+                            .forEach(
+                                    computationState ->
+                                            lockEdges(
+                                                    computationState.getPreviousBufferEntry(),
+                                                    computationState.getVersion()));
+                    nfaState.getCompletedMatches()
+                            .forEach(
+                                    computationState ->
+                                            lockEdges(
+                                                    computationState.getPreviousBufferEntry(),
+                                                    computationState.getVersion()));
+                });
+    }
+
+    private void copyEntries(MapState<NodeId, Lockable<SharedBufferNode>> state) throws Exception {
+        state.entries()
+                .forEach(
+                        e -> {
+                            try {
+                                entries.put(e.getKey(), e.getValue());
+                            } catch (Exception exception) {
+                                throw new RuntimeException(exception);
+                            }
+                        });
+    }
+
+    private void lockPredecessorEdges(Map.Entry<NodeId, Lockable<SharedBufferNode>> e) {
+        SharedBufferNode oldNode = e.getValue().getElement();
+        oldNode.getEdges()
+                .forEach(
+                        edge -> {
+                            SharedBufferEdge oldEdge = edge.getElement();
+                            lockEdges(oldEdge.getTarget(), oldEdge.getDeweyNumber());
+                        });
+    }
+
+    private void lockEdges(NodeId nodeId, DeweyNumber version) {
+
+        if (nodeId == null) {
+            return;
+        }
+
+        try {
+            SharedBufferNode newNode = entries.get(nodeId).getElement();
+            newNode.getEdges()
+                    .forEach(
+                            newEdge -> {
+                                if (version.isCompatibleWith(
+                                        newEdge.getElement().getDeweyNumber())) {
+                                    newEdge.lock();
+                                }
+                            });
+        } catch (Exception exception) {
+            throw new RuntimeException(exception);
+        }
+    }
+
     /**
      * Construct an accessor to deal with this sharedBuffer.
      *
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferAccessor.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferAccessor.java
index 1e6fa618c16..ed4f93a50df 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferAccessor.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferAccessor.java
@@ -27,6 +27,7 @@ import org.apache.commons.lang3.StringUtils;
 import javax.annotation.Nullable;
 
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -92,7 +93,7 @@ public class SharedBufferAccessor<V> implements AutoCloseable {
             final DeweyNumber version) {
 
         if (previousNodeId != null) {
-            lockNode(previousNodeId);
+            lockNode(previousNodeId, version);
         }
 
         NodeId currentNodeId = new NodeId(eventId, getOriginalNameFromInternal(stateName));
@@ -159,9 +160,10 @@ public class SharedBufferAccessor<V> implements AutoCloseable {
                     currentPath.push(currentEntry);
 
                     boolean firstMatch = true;
-                    for (SharedBufferEdge edge : currentEntry.f1.getEdges()) {
+                    for (Lockable<SharedBufferEdge> lockableEdge : currentEntry.f1.getEdges()) {
                         // we can only proceed if the current version is compatible to the version
                         // of this previous relation
+                        final SharedBufferEdge edge = lockableEdge.getElement();
                         final DeweyNumber currentVersion = extractionState.getVersion();
                         if (currentVersion.isCompatibleWith(edge.getDeweyNumber())) {
                             final NodeId target = edge.getTarget();
@@ -224,11 +226,17 @@ public class SharedBufferAccessor<V> implements AutoCloseable {
      * Increases the reference counter for the given entry so that it is not accidentally removed.
      *
      * @param node id of the entry
+     * @param version dewey number of the (potential) edge that locks the given node
      */
-    public void lockNode(final NodeId node) {
+    public void lockNode(final NodeId node, final DeweyNumber version) {
         Lockable<SharedBufferNode> sharedBufferNode = sharedBuffer.getEntry(node);
         if (sharedBufferNode != null) {
             sharedBufferNode.lock();
+            for (Lockable<SharedBufferEdge> edge : sharedBufferNode.getElement().getEdges()) {
+                if (version.isCompatibleWith(edge.getElement().getDeweyNumber())) {
+                    edge.lock();
+                }
+            }
             sharedBuffer.upsertEntry(node, sharedBufferNode);
         }
     }
@@ -238,12 +246,15 @@ public class SharedBufferAccessor<V> implements AutoCloseable {
      * reference counter reaches 0.
      *
      * @param node id of the entry
+     * @param version dewey number of the (potential) edge that locked the given node
      * @throws Exception Thrown if the system cannot access the state.
      */
-    public void releaseNode(final NodeId node) throws Exception {
+    public void releaseNode(final NodeId node, final DeweyNumber version) throws Exception {
         // the stack used to detect all nodes that needs to be released.
         Stack<NodeId> nodesToExamine = new Stack<>();
+        Stack<DeweyNumber> versionsToExamine = new Stack<>();
         nodesToExamine.push(node);
+        versionsToExamine.push(version);
 
         while (!nodesToExamine.isEmpty()) {
             NodeId curNode = nodesToExamine.pop();
@@ -253,17 +264,28 @@ public class SharedBufferAccessor<V> implements AutoCloseable {
                 break;
             }
 
+            DeweyNumber currentVersion = versionsToExamine.pop();
+            List<Lockable<SharedBufferEdge>> edges = curBufferNode.getElement().getEdges();
+            Iterator<Lockable<SharedBufferEdge>> edgesIterator = edges.iterator();
+            while (edgesIterator.hasNext()) {
+                Lockable<SharedBufferEdge> sharedBufferEdge = edgesIterator.next();
+                SharedBufferEdge edge = sharedBufferEdge.getElement();
+                if (currentVersion.isCompatibleWith(edge.getDeweyNumber())) {
+                    if (sharedBufferEdge.release()) {
+                        edgesIterator.remove();
+                        NodeId targetId = edge.getTarget();
+                        if (targetId != null) {
+                            nodesToExamine.push(targetId);
+                            versionsToExamine.push(edge.getDeweyNumber());
+                        }
+                    }
+                }
+            }
+
             if (curBufferNode.release()) {
                 // first release the current node
                 sharedBuffer.removeEntry(curNode);
                 releaseEvent(curNode.getEventId());
-
-                for (SharedBufferEdge sharedBufferEdge : curBufferNode.getElement().getEdges()) {
-                    NodeId targetId = sharedBufferEdge.getTarget();
-                    if (targetId != null) {
-                        nodesToExamine.push(targetId);
-                    }
-                }
             } else {
                 sharedBuffer.upsertEntry(curNode, curBufferNode);
             }
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNode.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNode.java
index 911c49865a4..9f7d97da4bd 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNode.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNode.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.cep.nfa.sharedbuffer;
 
+import org.apache.flink.api.common.state.ValueState;
 import org.apache.flink.api.common.typeutils.CompositeTypeSerializerSnapshot;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
@@ -26,6 +27,7 @@ import org.apache.flink.api.common.typeutils.base.TypeSerializerSingleton;
 import org.apache.flink.cep.nfa.sharedbuffer.SharedBufferEdge.SharedBufferEdgeSerializer;
 import org.apache.flink.core.memory.DataInputView;
 import org.apache.flink.core.memory.DataOutputView;
+import org.apache.flink.runtime.state.KeyedStateBackend;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -37,22 +39,22 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
 /** An entry in {@link SharedBuffer} that allows to store relations between different entries. */
 public class SharedBufferNode {
 
-    private final List<SharedBufferEdge> edges;
+    private final List<Lockable<SharedBufferEdge>> edges;
 
     public SharedBufferNode() {
         edges = new ArrayList<>();
     }
 
-    private SharedBufferNode(List<SharedBufferEdge> edges) {
+    SharedBufferNode(List<Lockable<SharedBufferEdge>> edges) {
         this.edges = edges;
     }
 
-    public List<SharedBufferEdge> getEdges() {
+    public List<Lockable<SharedBufferEdge>> getEdges() {
         return edges;
     }
 
     public void addEdge(SharedBufferEdge edge) {
-        edges.add(edge);
+        edges.add(new Lockable<>(edge, 0));
     }
 
     @Override
@@ -77,7 +79,17 @@ public class SharedBufferNode {
         return Objects.hash(edges);
     }
 
-    /** Serializer for {@link SharedBufferNode}. */
+    /**
+     * Serializer for {@link SharedBufferNode}.
+     *
+     * <p>This serializer had to be deprecated and you cannot directly migrate to the newer version.
+     * The new structure requires additional information from other nodes. The migration happens in
+     * {@link SharedBuffer#migrateOldState(KeyedStateBackend, ValueState)}.
+     *
+     * @deprecated was used in <= 1.12, use {@link
+     *     org.apache.flink.cep.nfa.sharedbuffer.SharedBufferNodeSerializer} instead.
+     */
+    @Deprecated
     public static class SharedBufferNodeSerializer
             extends TypeSerializerSingleton<SharedBufferNode> {
 
@@ -105,7 +117,7 @@ public class SharedBufferNode {
 
         @Override
         public SharedBufferNode copy(SharedBufferNode from) {
-            return new SharedBufferNode(edgesSerializer.copy(from.edges));
+            throw new UnsupportedOperationException("Should not be used");
         }
 
         @Override
@@ -120,13 +132,17 @@ public class SharedBufferNode {
 
         @Override
         public void serialize(SharedBufferNode record, DataOutputView target) throws IOException {
-            edgesSerializer.serialize(record.edges, target);
+            throw new UnsupportedOperationException("We should no longer use it for serialization");
         }
 
         @Override
         public SharedBufferNode deserialize(DataInputView source) throws IOException {
             List<SharedBufferEdge> edges = edgesSerializer.deserialize(source);
-            return new SharedBufferNode(edges);
+            SharedBufferNode node = new SharedBufferNode();
+            for (SharedBufferEdge edge : edges) {
+                node.addEdge(edge);
+            }
+            return node;
         }
 
         @Override
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNodeSerializer.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNodeSerializer.java
new file mode 100644
index 00000000000..f5ec400d889
--- /dev/null
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNodeSerializer.java
@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.cep.nfa.sharedbuffer;
+
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
+import org.apache.flink.api.common.typeutils.base.TypeSerializerSingleton;
+import org.apache.flink.core.memory.DataInputView;
+import org.apache.flink.core.memory.DataOutputView;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
+/** Serializer for {@link SharedBufferNode}. */
+public class SharedBufferNodeSerializer extends TypeSerializerSingleton<SharedBufferNode> {
+
+    private static final long serialVersionUID = -6687780732295439832L;
+
+    private final TypeSerializer<SharedBufferEdge> edgeSerializer;
+
+    public SharedBufferNodeSerializer() {
+        this.edgeSerializer = new SharedBufferEdge.SharedBufferEdgeSerializer();
+    }
+
+    SharedBufferNodeSerializer(TypeSerializer<SharedBufferEdge> edgeSerializer) {
+        this.edgeSerializer = checkNotNull(edgeSerializer);
+    }
+
+    public TypeSerializer<SharedBufferEdge> getEdgeSerializer() {
+        return edgeSerializer;
+    }
+
+    @Override
+    public boolean isImmutableType() {
+        return false;
+    }
+
+    @Override
+    public SharedBufferNode createInstance() {
+        return new SharedBufferNode(new ArrayList<>());
+    }
+
+    @Override
+    public SharedBufferNode copy(SharedBufferNode from) {
+        return new SharedBufferNode(
+                from.getEdges().stream()
+                        .map(
+                                edge ->
+                                        new Lockable<>(
+                                                edgeSerializer.copy(edge.getElement()),
+                                                edge.getRefCounter()))
+                        .collect(Collectors.toList()));
+    }
+
+    @Override
+    public SharedBufferNode copy(SharedBufferNode from, SharedBufferNode reuse) {
+        return copy(from);
+    }
+
+    @Override
+    public int getLength() {
+        return -1;
+    }
+
+    @Override
+    public void serialize(SharedBufferNode record, DataOutputView target) throws IOException {
+        List<Lockable<SharedBufferEdge>> edges = record.getEdges();
+        target.writeInt(edges.size());
+        for (Lockable<SharedBufferEdge> edge : edges) {
+            target.writeInt(edge.getRefCounter());
+            edgeSerializer.serialize(edge.getElement(), target);
+        }
+    }
+
+    @Override
+    public SharedBufferNode deserialize(DataInputView source) throws IOException {
+        int length = source.readInt();
+        List<Lockable<SharedBufferEdge>> edges = new ArrayList<>();
+        for (int i = 0; i < length; i++) {
+            int refCount = source.readInt();
+            SharedBufferEdge edge = edgeSerializer.deserialize(source);
+            edges.add(new Lockable<>(edge, refCount));
+        }
+        return new SharedBufferNode(edges);
+    }
+
+    @Override
+    public SharedBufferNode deserialize(SharedBufferNode reuse, DataInputView source)
+            throws IOException {
+        return deserialize(source);
+    }
+
+    @Override
+    public void copy(DataInputView source, DataOutputView target) throws IOException {
+        int length = source.readInt();
+        target.writeInt(length);
+        for (int i = 0; i < length; i++) {
+            target.writeInt(source.readInt());
+            edgeSerializer.copy(source, target);
+        }
+    }
+
+    @Override
+    public TypeSerializerSnapshot<SharedBufferNode> snapshotConfiguration() {
+        return new SharedBufferNodeSerializerSnapshotV2(this);
+    }
+}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNodeSerializerSnapshotV2.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNodeSerializerSnapshotV2.java
new file mode 100644
index 00000000000..9d963e829b9
--- /dev/null
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferNodeSerializerSnapshotV2.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.cep.nfa.sharedbuffer;
+
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerSnapshot;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+
+/** Serializer configuration snapshot for compatibility and format evolution. */
+public final class SharedBufferNodeSerializerSnapshotV2
+        extends CompositeTypeSerializerSnapshot<SharedBufferNode, SharedBufferNodeSerializer> {
+
+    private static final int VERSION = 1;
+
+    public SharedBufferNodeSerializerSnapshotV2() {
+        super(SharedBufferNodeSerializer.class);
+    }
+
+    public SharedBufferNodeSerializerSnapshotV2(
+            SharedBufferNodeSerializer sharedBufferNodeSerializer) {
+        super(sharedBufferNodeSerializer);
+    }
+
+    @Override
+    protected int getCurrentOuterSnapshotVersion() {
+        return VERSION;
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    protected SharedBufferNodeSerializer createOuterSerializerWithNestedSerializers(
+            TypeSerializer<?>[] nestedSerializers) {
+        return new SharedBufferNodeSerializer(
+                (TypeSerializer<SharedBufferEdge>) nestedSerializers[0]);
+    }
+
+    @Override
+    protected TypeSerializer<?>[] getNestedSerializers(SharedBufferNodeSerializer outerSerializer) {
+        return new TypeSerializer<?>[] {outerSerializer.getEdgeSerializer()};
+    }
+}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CepOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CepOperator.java
index 2ff431449b2..088f7d3d62b 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CepOperator.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/CepOperator.java
@@ -189,6 +189,10 @@ public class CepOperator<IN, KEY, OUT>
                                         EVENT_QUEUE_STATE_NAME,
                                         LongSerializer.INSTANCE,
                                         new ListSerializer<>(inputSerializer)));
+
+        if (context.isRestored()) {
+            partialMatches.migrateOldState(getKeyedStateBackend(), computationStates);
+        }
     }
 
     @Override
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/NFASerializerUpgradeTest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/NFASerializerUpgradeTest.java
index bc6e63f8317..efff323ad0f 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/NFASerializerUpgradeTest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/NFASerializerUpgradeTest.java
@@ -29,6 +29,7 @@ import org.apache.flink.cep.nfa.sharedbuffer.EventId;
 import org.apache.flink.cep.nfa.sharedbuffer.NodeId;
 import org.apache.flink.cep.nfa.sharedbuffer.SharedBufferEdge;
 import org.apache.flink.cep.nfa.sharedbuffer.SharedBufferNode;
+import org.apache.flink.cep.nfa.sharedbuffer.SharedBufferNodeSerializer;
 import org.apache.flink.testutils.migration.MigrationVersion;
 
 import org.hamcrest.Matcher;
@@ -77,12 +78,6 @@ public class NFASerializerUpgradeTest extends TypeSerializerUpgradeTestBase<Obje
                             migrationVersion,
                             SharedBufferEdgeSerializerSetup.class,
                             SharedBufferEdgeSerializerVerifier.class));
-            testSpecifications.add(
-                    new TestSpecification<>(
-                            "shared-buffer-node-serializer",
-                            migrationVersion,
-                            SharedBufferNodeSerializerSetup.class,
-                            SharedBufferNodeSerializerVerifier.class));
             testSpecifications.add(
                     new TestSpecification<>(
                             "nfa-state-serializer",
@@ -294,7 +289,7 @@ public class NFASerializerUpgradeTest extends TypeSerializerUpgradeTestBase<Obje
 
         @Override
         public TypeSerializer<SharedBufferNode> createPriorSerializer() {
-            return new SharedBufferNode.SharedBufferNodeSerializer();
+            return new SharedBufferNodeSerializer();
         }
 
         @Override
@@ -316,7 +311,7 @@ public class NFASerializerUpgradeTest extends TypeSerializerUpgradeTestBase<Obje
 
         @Override
         public TypeSerializer<SharedBufferNode> createUpgradedSerializer() {
-            return new SharedBufferNode.SharedBufferNodeSerializer();
+            return new SharedBufferNodeSerializer();
         }
 
         @Override
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java
index 07077f0b82b..3a6ede035bc 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java
@@ -54,7 +54,9 @@ import java.util.Set;
 import static org.apache.flink.cep.utils.NFATestUtilities.comparePatterns;
 import static org.apache.flink.cep.utils.NFATestUtilities.feedNFA;
 import static org.apache.flink.cep.utils.NFAUtils.compile;
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
 import static org.mockito.Matchers.anyLong;
 
 /**
@@ -3941,4 +3943,33 @@ public class NFAITCase extends TestLogger {
             Mockito.verify(accessor, Mockito.times(1)).advanceTime(2);
         }
     }
+
+    @Test
+    public void testLoopClearing() throws Exception {
+        Pattern<Event, ?> pattern =
+                Pattern.<Event>begin("start", AfterMatchSkipStrategy.skipPastLastEvent())
+                        .times(4)
+                        .where(
+                                new SimpleCondition<Event>() {
+                                    @Override
+                                    public boolean filter(Event value) throws Exception {
+                                        return value.getName().equals("a");
+                                    }
+                                })
+                        .within(Time.milliseconds(3));
+
+        Event a1 = new Event(40, "a", 1.0);
+        Event a2 = new Event(40, "a", 1.0);
+
+        NFA<Event> nfa = compile(pattern, false);
+        TestTimerService timerService = new TestTimerService();
+        NFAState nfaState = nfa.createInitialNFAState();
+        try (SharedBufferAccessor<Event> accessor = sharedBuffer.getAccessor()) {
+            nfa.process(accessor, nfaState, a1, 1, AfterMatchSkipStrategy.noSkip(), timerService);
+            nfa.process(accessor, nfaState, a2, 2, AfterMatchSkipStrategy.noSkip(), timerService);
+            nfa.advanceTime(accessor, nfaState, 4);
+        }
+
+        assertThat(sharedBuffer.getEventsBufferSize(), equalTo(1));
+    }
 }
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferTest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferTest.java
index de71bf0bdf0..bc7ed3fe13b 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferTest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/sharedbuffer/SharedBufferTest.java
@@ -111,44 +111,44 @@ public class SharedBufferTest extends TestLogger {
             NodeId aLoop3 =
                     sharedBufferAccessor.put(
                             "a[]", eventIds[4], aLoop2, DeweyNumber.fromString("1.0"));
-            NodeId b0 =
-                    sharedBufferAccessor.put(
-                            "b", eventIds[5], aLoop3, DeweyNumber.fromString("1.0.0"));
+            DeweyNumber b0Version = DeweyNumber.fromString("1.0.0");
+            NodeId b0 = sharedBufferAccessor.put("b", eventIds[5], aLoop3, b0Version);
             NodeId aLoop4 =
                     sharedBufferAccessor.put(
                             "a[]", eventIds[5], aLoop3, DeweyNumber.fromString("1.1"));
-            NodeId b1 =
-                    sharedBufferAccessor.put(
-                            "b", eventIds[5], aSecondLoop0, DeweyNumber.fromString("2.0.0"));
+            DeweyNumber b1Version = DeweyNumber.fromString("2.0.0");
+            NodeId b1 = sharedBufferAccessor.put("b", eventIds[5], aSecondLoop0, b1Version);
             NodeId aLoop5 =
                     sharedBufferAccessor.put(
                             "a[]", eventIds[6], aLoop4, DeweyNumber.fromString("1.1"));
-            NodeId b3 =
-                    sharedBufferAccessor.put(
-                            "b", eventIds[7], aLoop5, DeweyNumber.fromString("1.1.0"));
+            DeweyNumber b3Version = DeweyNumber.fromString("1.1.0");
+            NodeId b3 = sharedBufferAccessor.put("b", eventIds[7], aLoop5, b3Version);
+            sharedBufferAccessor.lockNode(b0, b0Version);
+            sharedBufferAccessor.lockNode(b1, b1Version);
+            sharedBufferAccessor.lockNode(b3, b3Version);
 
             List<Map<String, List<EventId>>> patterns3 =
-                    sharedBufferAccessor.extractPatterns(b3, DeweyNumber.fromString("1.1.0"));
+                    sharedBufferAccessor.extractPatterns(b3, b3Version);
             assertEquals(1L, patterns3.size());
             assertEquals(expectedPattern3, sharedBufferAccessor.materializeMatch(patterns3.get(0)));
-            sharedBufferAccessor.releaseNode(b3);
+            sharedBufferAccessor.releaseNode(b3, b3Version);
 
             List<Map<String, List<EventId>>> patterns4 =
-                    sharedBufferAccessor.extractPatterns(b3, DeweyNumber.fromString("1.1.0"));
+                    sharedBufferAccessor.extractPatterns(b3, b3Version);
             assertEquals(0L, patterns4.size());
             assertTrue(patterns4.isEmpty());
 
             List<Map<String, List<EventId>>> patterns1 =
-                    sharedBufferAccessor.extractPatterns(b1, DeweyNumber.fromString("2.0.0"));
+                    sharedBufferAccessor.extractPatterns(b1, b1Version);
             assertEquals(1L, patterns1.size());
             assertEquals(expectedPattern1, sharedBufferAccessor.materializeMatch(patterns1.get(0)));
+            sharedBufferAccessor.releaseNode(b1, b1Version);
 
             List<Map<String, List<EventId>>> patterns2 =
-                    sharedBufferAccessor.extractPatterns(b0, DeweyNumber.fromString("1.0.0"));
+                    sharedBufferAccessor.extractPatterns(b0, b0Version);
             assertEquals(1L, patterns2.size());
             assertEquals(expectedPattern2, sharedBufferAccessor.materializeMatch(patterns2.get(0)));
-            sharedBufferAccessor.releaseNode(b1);
-            sharedBufferAccessor.releaseNode(b0);
+            sharedBufferAccessor.releaseNode(b0, b0Version);
 
             for (EventId eventId : eventIds) {
                 sharedBufferAccessor.releaseEvent(eventId);
@@ -192,9 +192,9 @@ public class SharedBufferTest extends TestLogger {
                             "branching", eventIds[4], b1, DeweyNumber.fromString("1.1.0"));
 
             // simulate IGNORE (next event can point to events[2])
-            sharedBufferAccessor.lockNode(b0);
+            sharedBufferAccessor.lockNode(b0, DeweyNumber.fromString("1.0"));
 
-            sharedBufferAccessor.releaseNode(b10);
+            sharedBufferAccessor.releaseNode(b10, DeweyNumber.fromString("1.1.0"));
 
             for (EventId eventId : eventIds) {
                 sharedBufferAccessor.releaseEvent(eventId);
@@ -321,7 +321,7 @@ public class SharedBufferTest extends TestLogger {
             assertEquals(4, sharedBuffer.getSharedBufferNodeCacheSize());
             assertEquals(0, sharedBuffer.getSharedBufferNodeSize());
 
-            sharedBufferAccessor.lockNode(b0);
+            sharedBufferAccessor.lockNode(b0, DeweyNumber.fromString("1.0.0"));
 
             for (EventId eventId : eventIds) {
                 sharedBufferAccessor.releaseEvent(eventId);
@@ -366,7 +366,7 @@ public class SharedBufferTest extends TestLogger {
             }
 
             NodeId lastNode = nodeIds[numberEvents - 1];
-            sharedBufferAccessor.releaseNode(lastNode);
+            sharedBufferAccessor.releaseNode(lastNode, DeweyNumber.fromString("1.0"));
 
             for (int i = 0; i < numberEvents; i++) {
                 sharedBufferAccessor.releaseEvent(eventIds[i]);
