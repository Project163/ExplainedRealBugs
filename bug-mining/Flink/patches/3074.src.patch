diff --git a/flink-core/src/main/java/org/apache/flink/configuration/NettyShuffleEnvironmentOptions.java b/flink-core/src/main/java/org/apache/flink/configuration/NettyShuffleEnvironmentOptions.java
index 699bd90cd5f..b8e470c55d8 100644
--- a/flink-core/src/main/java/org/apache/flink/configuration/NettyShuffleEnvironmentOptions.java
+++ b/flink-core/src/main/java/org/apache/flink/configuration/NettyShuffleEnvironmentOptions.java
@@ -21,6 +21,7 @@ package org.apache.flink.configuration;
 import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.annotation.docs.ConfigGroup;
 import org.apache.flink.annotation.docs.ConfigGroups;
+import org.apache.flink.annotation.docs.Documentation;
 
 import static org.apache.flink.configuration.ConfigOptions.key;
 
@@ -140,6 +141,18 @@ public class NettyShuffleEnvironmentOptions {
 				" help relieve back-pressure caused by unbalanced data distribution among the subpartitions. This value should be" +
 				" increased in case of higher round trip times between nodes and/or larger number of machines in the cluster.");
 
+	/**
+	 * The timeout for requesting exclusive buffers for each channel.
+	 */
+	@Documentation.ExcludeFromDocumentation("This option is purely implementation related, and may be removed as the implementation changes.")
+	public static final ConfigOption<Long> NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS =
+		key("taskmanager.network.memory.exclusive-buffers-request-timeout-ms")
+			.defaultValue(30000L)
+			.withDescription("The timeout for requesting exclusive buffers for each channel. Since the number of maximum buffers and " +
+					"the number of required buffers is not the same for local buffer pools, there may be deadlock cases that the upstream" +
+					"tasks have occupied all the buffers and the downstream tasks are waiting for the exclusive buffers. The timeout breaks" +
+					"the tie by failing the request of exclusive buffers and ask users to increase the number of total buffers.");
+
 	// ------------------------------------------------------------------------
 	//  Netty Options
 	// ------------------------------------------------------------------------
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NettyShuffleServiceFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NettyShuffleServiceFactory.java
index be31fb7d909..1eb60434ed0 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NettyShuffleServiceFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NettyShuffleServiceFactory.java
@@ -92,7 +92,8 @@ public class NettyShuffleServiceFactory implements ShuffleServiceFactory<NettySh
 		NetworkBufferPool networkBufferPool = new NetworkBufferPool(
 			config.numNetworkBuffers(),
 			config.networkBufferSize(),
-			config.networkBuffersPerChannel());
+			config.networkBuffersPerChannel(),
+			config.getRequestSegmentsTimeout());
 
 		registerShuffleMetrics(metricGroup, networkBufferPool);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
index 87f0f06634d..5309249bdb9 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
@@ -18,6 +18,8 @@
 
 package org.apache.flink.runtime.io.network.buffer;
 
+import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.api.common.time.Deadline;
 import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;
 import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.core.memory.MemorySegmentFactory;
@@ -25,12 +27,14 @@ import org.apache.flink.core.memory.MemorySegmentProvider;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.MathUtils;
 
+import org.apache.flink.util.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
 
 import java.io.IOException;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
@@ -73,10 +77,21 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 
 	private final int numberOfSegmentsToRequest;
 
+	private final Duration requestSegmentsTimeout;
+
+	@VisibleForTesting
+	public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize, int numberOfSegmentsToRequest) {
+		this(numberOfSegmentsToAllocate, segmentSize, numberOfSegmentsToRequest, Duration.ofMillis(Integer.MAX_VALUE));
+	}
+
 	/**
 	 * Allocates all {@link MemorySegment} instances managed by this pool.
 	 */
-	public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize, int numberOfSegmentsToRequest) {
+	public NetworkBufferPool(
+		int numberOfSegmentsToAllocate,
+		int segmentSize,
+		int numberOfSegmentsToRequest,
+		Duration requestSegmentsTimeout) {
 
 		this.totalNumberOfMemorySegments = numberOfSegmentsToAllocate;
 		this.memorySegmentSize = segmentSize;
@@ -84,6 +99,11 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 		checkArgument(numberOfSegmentsToRequest > 0, "The number of required buffers should be larger than 0.");
 		this.numberOfSegmentsToRequest = numberOfSegmentsToRequest;
 
+		Preconditions.checkNotNull(requestSegmentsTimeout);
+		checkArgument(requestSegmentsTimeout.toMillis() > 0,
+				"The timeout for requesting exclusive buffers should be positive.");
+		this.requestSegmentsTimeout = requestSegmentsTimeout;
+
 		final long sizeInLong = (long) segmentSize;
 
 		try {
@@ -145,39 +165,13 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 				throw new IllegalStateException("Network buffer pool has already been destroyed.");
 			}
 
-			if (numTotalRequiredBuffers + numberOfSegmentsToRequest > totalNumberOfMemorySegments) {
-				throw new IOException(String.format("Insufficient number of network buffers: " +
-								"required %d, but only %d available. The total number of network " +
-								"buffers is currently set to %d of %d bytes each. You can increase this " +
-								"number by setting the configuration keys '%s', '%s', and '%s'.",
-					numberOfSegmentsToRequest,
-						totalNumberOfMemorySegments - numTotalRequiredBuffers,
-						totalNumberOfMemorySegments,
-						memorySegmentSize,
-						NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_FRACTION.key(),
-						NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_MIN.key(),
-						NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_MAX.key()));
-			}
-
-			this.numTotalRequiredBuffers += numberOfSegmentsToRequest;
-
-			try {
-				redistributeBuffers();
-			} catch (Throwable t) {
-				this.numTotalRequiredBuffers -= numberOfSegmentsToRequest;
-
-				try {
-					redistributeBuffers();
-				} catch (IOException inner) {
-					t.addSuppressed(inner);
-				}
-				ExceptionUtils.rethrowIOException(t);
-			}
+			tryRedistributeBuffers();
 		}
 
 		final List<MemorySegment> segments = new ArrayList<>(numberOfSegmentsToRequest);
 		try {
-			while (segments.size() < numberOfSegmentsToRequest) {
+			final Deadline deadline = Deadline.fromNow(requestSegmentsTimeout);
+			while (true) {
 				if (isDestroyed) {
 					throw new IllegalStateException("Buffer pool is destroyed.");
 				}
@@ -186,6 +180,18 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 				if (segment != null) {
 					segments.add(segment);
 				}
+
+				if (segments.size() >= numberOfSegmentsToRequest) {
+					break;
+				}
+
+				if (!deadline.hasTimeLeft()) {
+					throw new IOException(String.format("Timeout triggered when requesting exclusive buffers: %s, " +
+									" or you may increase the timeout which is %dms by setting the key '%s'.",
+							getConfigDescription(),
+							requestSegmentsTimeout.toMillis(),
+							NettyShuffleEnvironmentOptions.NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS.key()));
+				}
 			}
 		} catch (Throwable e) {
 			try {
@@ -278,16 +284,10 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 			// With dynamic memory management this should become obsolete.
 			if (numTotalRequiredBuffers + numRequiredBuffers > totalNumberOfMemorySegments) {
 				throw new IOException(String.format("Insufficient number of network buffers: " +
-								"required %d, but only %d available. The total number of network " +
-								"buffers is currently set to %d of %d bytes each. You can increase this " +
-								"number by setting the configuration keys '%s', '%s', and '%s'.",
+								"required %d, but only %d available. %s.",
 						numRequiredBuffers,
 						totalNumberOfMemorySegments - numTotalRequiredBuffers,
-						totalNumberOfMemorySegments,
-						memorySegmentSize,
-						NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_FRACTION.key(),
-						NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_MIN.key(),
-						NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_MAX.key()));
+						getConfigDescription()));
 			}
 
 			this.numTotalRequiredBuffers += numRequiredBuffers;
@@ -349,6 +349,34 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 		}
 	}
 
+	// Must be called from synchronized block
+	private void tryRedistributeBuffers() throws IOException {
+		assert Thread.holdsLock(factoryLock);
+
+		if (numTotalRequiredBuffers + numberOfSegmentsToRequest > totalNumberOfMemorySegments) {
+			throw new IOException(String.format("Insufficient number of network buffers: " +
+							"required %d, but only %d available. %s.",
+					numberOfSegmentsToRequest,
+					totalNumberOfMemorySegments - numTotalRequiredBuffers,
+					getConfigDescription()));
+		}
+
+		this.numTotalRequiredBuffers += numberOfSegmentsToRequest;
+
+		try {
+			redistributeBuffers();
+		} catch (Throwable t) {
+			this.numTotalRequiredBuffers -= numberOfSegmentsToRequest;
+
+			try {
+				redistributeBuffers();
+			} catch (IOException inner) {
+				t.addSuppressed(inner);
+			}
+			ExceptionUtils.rethrowIOException(t);
+		}
+	}
+
 	// Must be called from synchronized block
 	private void redistributeBuffers() throws IOException {
 		assert Thread.holdsLock(factoryLock);
@@ -417,4 +445,14 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid
 		assert (totalPartsUsed == totalCapacity);
 		assert (numDistributedMemorySegment == memorySegmentsToDistribute);
 	}
+
+	private String getConfigDescription() {
+		return String.format("The total number of network buffers is currently set to %d of %d bytes each. " +
+						"You can increase this number by setting the configuration keys '%s', '%s', and '%s'",
+				totalNumberOfMemorySegments,
+				memorySegmentSize,
+				NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_FRACTION.key(),
+				NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_MIN.key(),
+				NettyShuffleEnvironmentOptions.NETWORK_BUFFERS_MEMORY_MAX.key());
+	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/NettyShuffleEnvironmentConfiguration.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/NettyShuffleEnvironmentConfiguration.java
index daccd3e6e88..c0803496707 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/NettyShuffleEnvironmentConfiguration.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/NettyShuffleEnvironmentConfiguration.java
@@ -37,6 +37,7 @@ import javax.annotation.Nullable;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
+import java.time.Duration;
 import java.util.Arrays;
 
 /**
@@ -59,6 +60,8 @@ public class NettyShuffleEnvironmentConfiguration {
 	/** Number of extra network buffers to use for each outgoing/incoming gate (result partition/input gate). */
 	private final int floatingNetworkBuffersPerGate;
 
+	private final Duration requestSegmentsTimeout;
+
 	private final boolean isCreditBased;
 
 	private final boolean isNetworkDetailedMetrics;
@@ -74,6 +77,7 @@ public class NettyShuffleEnvironmentConfiguration {
 			int partitionRequestMaxBackoff,
 			int networkBuffersPerChannel,
 			int floatingNetworkBuffersPerGate,
+			Duration requestSegmentsTimeout,
 			boolean isCreditBased,
 			boolean isNetworkDetailedMetrics,
 			@Nullable NettyConfig nettyConfig,
@@ -85,6 +89,7 @@ public class NettyShuffleEnvironmentConfiguration {
 		this.partitionRequestMaxBackoff = partitionRequestMaxBackoff;
 		this.networkBuffersPerChannel = networkBuffersPerChannel;
 		this.floatingNetworkBuffersPerGate = floatingNetworkBuffersPerGate;
+		this.requestSegmentsTimeout = Preconditions.checkNotNull(requestSegmentsTimeout);
 		this.isCreditBased = isCreditBased;
 		this.isNetworkDetailedMetrics = isNetworkDetailedMetrics;
 		this.nettyConfig = nettyConfig;
@@ -117,6 +122,10 @@ public class NettyShuffleEnvironmentConfiguration {
 		return floatingNetworkBuffersPerGate;
 	}
 
+	public Duration getRequestSegmentsTimeout() {
+		return requestSegmentsTimeout;
+	}
+
 	public NettyConfig nettyConfig() {
 		return nettyConfig;
 	}
@@ -171,6 +180,9 @@ public class NettyShuffleEnvironmentConfiguration {
 
 		String[] tempDirs = ConfigurationUtils.parseTempDirectories(configuration);
 
+		Duration requestSegmentsTimeout = Duration.ofMillis(configuration.getLong(
+				NettyShuffleEnvironmentOptions.NETWORK_EXCLUSIVE_BUFFERS_REQUEST_TIMEOUT_MILLISECONDS));
+
 		return new NettyShuffleEnvironmentConfiguration(
 			numberOfNetworkBuffers,
 			pageSize,
@@ -178,6 +190,7 @@ public class NettyShuffleEnvironmentConfiguration {
 			maxRequestBackoff,
 			buffersPerChannel,
 			extraBuffersPerGate,
+			requestSegmentsTimeout,
 			isCreditBased,
 			isNetworkDetailedMetrics,
 			nettyConfig,
@@ -479,6 +492,7 @@ public class NettyShuffleEnvironmentConfiguration {
 		result = 31 * result + partitionRequestMaxBackoff;
 		result = 31 * result + networkBuffersPerChannel;
 		result = 31 * result + floatingNetworkBuffersPerGate;
+		result = 31 * result + requestSegmentsTimeout.hashCode();
 		result = 31 * result + (isCreditBased ? 1 : 0);
 		result = 31 * result + (nettyConfig != null ? nettyConfig.hashCode() : 0);
 		result = 31 * result + Arrays.hashCode(tempDirs);
@@ -502,6 +516,7 @@ public class NettyShuffleEnvironmentConfiguration {
 					this.partitionRequestMaxBackoff == that.partitionRequestMaxBackoff &&
 					this.networkBuffersPerChannel == that.networkBuffersPerChannel &&
 					this.floatingNetworkBuffersPerGate == that.floatingNetworkBuffersPerGate &&
+					this.requestSegmentsTimeout.equals(that.requestSegmentsTimeout) &&
 					this.isCreditBased == that.isCreditBased &&
 					(nettyConfig != null ? nettyConfig.equals(that.nettyConfig) : that.nettyConfig == null) &&
 					Arrays.equals(this.tempDirs, that.tempDirs);
@@ -517,6 +532,7 @@ public class NettyShuffleEnvironmentConfiguration {
 				", partitionRequestMaxBackoff=" + partitionRequestMaxBackoff +
 				", networkBuffersPerChannel=" + networkBuffersPerChannel +
 				", floatingNetworkBuffersPerGate=" + floatingNetworkBuffersPerGate +
+				", requestSegmentsTimeout=" + requestSegmentsTimeout +
 				", isCreditBased=" + isCreditBased +
 				", nettyConfig=" + nettyConfig +
 				", tempDirs=" + Arrays.toString(tempDirs) +
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentBuilder.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentBuilder.java
index 517be70f221..7250136e3ae 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentBuilder.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentBuilder.java
@@ -25,6 +25,8 @@ import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.runtime.taskmanager.NettyShuffleEnvironmentConfiguration;
 import org.apache.flink.runtime.util.EnvironmentInformation;
 
+import java.time.Duration;
+
 /**
  * Builder for the {@link NettyShuffleEnvironment}.
  */
@@ -46,6 +48,8 @@ public class NettyShuffleEnvironmentBuilder {
 
 	private int floatingNetworkBuffersPerGate = 8;
 
+	private Duration requestSegmentsTimeout = Duration.ofMillis(30000L);
+
 	private boolean isCreditBased = true;
 
 	private boolean isNetworkDetailedMetrics = false;
@@ -95,6 +99,10 @@ public class NettyShuffleEnvironmentBuilder {
 		return this;
 	}
 
+	public void setRequestSegmentsTimeout(Duration requestSegmentsTimeout) {
+		this.requestSegmentsTimeout = requestSegmentsTimeout;
+	}
+
 	public NettyShuffleEnvironmentBuilder setIsCreditBased(boolean isCreditBased) {
 		this.isCreditBased = isCreditBased;
 		return this;
@@ -129,6 +137,7 @@ public class NettyShuffleEnvironmentBuilder {
 				partitionRequestMaxBackoff,
 				networkBuffersPerChannel,
 				floatingNetworkBuffersPerGate,
+				requestSegmentsTimeout,
 				isCreditBased,
 				isNetworkDetailedMetrics,
 				nettyConfig,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
index cc6c3a0ea38..42871156b66 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
@@ -28,6 +28,7 @@ import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
 import java.io.IOException;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -476,4 +477,46 @@ public class NetworkBufferPoolTest extends TestLogger {
 			globalPool.destroy();
 		}
 	}
+
+	/**
+	 * Tests {@link NetworkBufferPool#requestMemorySegments()} and verifies it will end exceptionally
+	 * when failing to acquire all the segments in the specific timeout.
+	 */
+	@Test
+	public void testRequestMemorySegmentsTimeout() throws Exception {
+		final int numBuffers = 10;
+		final int numberOfSegmentsToRequest = 2;
+		final Duration requestSegmentsTimeout = Duration.ofMillis(50L);
+
+		NetworkBufferPool globalPool = new NetworkBufferPool(
+				numBuffers,
+				128,
+				numberOfSegmentsToRequest,
+				requestSegmentsTimeout);
+
+		BufferPool localBufferPool = globalPool.createBufferPool(0, numBuffers);
+		for (int i = 0; i < numBuffers; ++i) {
+			localBufferPool.requestBuffer();
+		}
+
+		assertEquals(0, globalPool.getNumberOfAvailableMemorySegments());
+
+		CheckedThread asyncRequest = new CheckedThread() {
+			@Override
+			public void go() throws Exception {
+				globalPool.requestMemorySegments();
+			}
+		};
+
+		asyncRequest.start();
+
+		expectedException.expect(IOException.class);
+		expectedException.expectMessage("Timeout");
+
+		try {
+			asyncRequest.sync();
+		} finally {
+			globalPool.destroy();
+		}
+	}
 }
