diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/common/CommonLookupJoin.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/common/CommonLookupJoin.scala
index bcd6d8e5833..008532d6b29 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/common/CommonLookupJoin.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/nodes/common/CommonLookupJoin.scala
@@ -70,6 +70,42 @@ import scala.collection.mutable
 
 /**
   * Common abstract RelNode for temporal table join which shares most methods.
+  *
+  * For a look join query:
+  *
+  * <pre>
+  * SELECT T.id, T.content, D.age
+  * FROM T JOIN userTable FOR SYSTEM_TIME AS OF T.proctime AS D
+  * ON T.content = concat(D.name, '!') AND D.age = 11 AND T.id = D.id
+  * WHERE D.name LIKE 'Jack%'
+  * </pre>
+  *
+  * The LookJoin physical node encapsulates the following RelNode tree:
+  *
+  * <pre>
+  *      Join (l.name = r.name)
+  *    /     \
+  * RelNode  Calc (concat(name, "!") as name, name LIKE 'Jack%')
+  *           |
+  *        DimTable (lookup-keys: age=11, id=l.id)
+  *     (age, id, name)
+  * </pre>
+  *
+  * The important member fields in LookupJoin:
+  * <ul>
+  *  <li>joinPairs: "0=0" (equal condition of Join)</li>
+  *  <li>joinKeyPairs: empty (left input field index to dim table field index)</li>
+  *  <li>allLookupKeys: [$0=11, $1=l.id] ($0 and $1 is the indexes of age and id in dim table)</li>
+  *  <li>remainingCondition: l.name=r.name</li>
+  * <ul>
+  *
+  * The workflow of lookup join:
+  *
+  * 1) lookup records dimension table using the lookup-keys <br>
+  * 2) project & filter on the lookup-ed records <br>
+  * 3) join left input record and lookup-ed records <br>
+  * 4) only outputs the rows which match to the remainingCondition <br>
+  *
   * @param input  input rel node
   * @param tableSource  the table source to be temporal joined
   * @param tableRowType  the row type of the table source
@@ -87,6 +123,7 @@ abstract class CommonLookupJoin(
   extends SingleRel(cluster, traitSet, input)
   with FlinkRelNode {
 
+  // join key pairs from left input field index to temporal table field index
   val joinKeyPairs: Array[IntPair] = getTemporalTableJoinKeyPairs(joinInfo, calcOnTemporalTable)
   // all potential index keys, mapping from field index in table source to LookupKey
   val allLookupKeys: Map[Int, LookupKey] = analyzeLookupKeys(
@@ -94,6 +131,16 @@ abstract class CommonLookupJoin(
     joinKeyPairs,
     tableSource.getTableSchema,
     calcOnTemporalTable)
+  // remaining condition the filter joined records (left input record X lookup-ed records)
+  val remainingCondition: Option[RexNode] = getRemainingJoinCondition(
+    cluster.getRexBuilder,
+    input.getRowType,
+    tableRowType,
+    calcOnTemporalTable,
+    allLookupKeys.keys.toList.sorted.toArray,
+    joinKeyPairs,
+    joinInfo,
+    allLookupKeys)
 
   if (containsPythonCall(joinInfo.getRemaining(cluster.getRexBuilder))) {
     throw new TableException("Only inner join condition with equality predicates supports the " +
@@ -118,37 +165,42 @@ abstract class CommonLookupJoin(
   }
 
   override def explainTerms(pw: RelWriter): RelWriter = {
-    val remaining = joinInfo.getRemaining(cluster.getRexBuilder)
-    val joinCondition = if (remaining.isAlwaysTrue) {
-      None
-    } else {
-      Some(remaining)
-    }
-
     val inputFieldNames = input.getRowType.getFieldNames.asScala.toArray
     val tableFieldNames = tableSource.getTableSchema.getFieldNames
-    val rightFieldNames = calcOnTemporalTable match {
-      case Some(calc) => calc.getOutputRowType.getFieldNames.asScala.toArray
-      case None => tableFieldNames
-    }
     val resultFieldNames = getRowType.getFieldNames.asScala.toArray
     val lookupableSource = tableSource.asInstanceOf[LookupableTableSource[_]]
     val whereString = calcOnTemporalTable match {
-      case Some(calc) => RelExplainUtil.conditionToString(
-        calc, getExpressionString, preferExpressionFormat(pw))
-      case None => "N/A"
+      case Some(calc) =>
+        RelExplainUtil.conditionToString(calc, getExpressionString, preferExpressionFormat(pw))
+      case None => ""
+    }
+    val lookupKeys = allLookupKeys.map {
+      case (tableField, FieldRefLookupKey(inputField)) =>
+        s"${tableFieldNames(tableField)}=${inputFieldNames(inputField)}"
+      case (tableField, ConstantLookupKey(_, literal)) =>
+        s"${tableFieldNames(tableField)}=${RelExplainUtil.literalToString(literal)}"
+    }.mkString(", ")
+    val selection = calcOnTemporalTable match {
+      case Some(calc) =>
+        val rightSelect = RelExplainUtil.selectionToString(
+          calc,
+          getExpressionString,
+          preferExpressionFormat(pw))
+        inputFieldNames.mkString(", ") + ", " + rightSelect
+      case None =>
+        resultFieldNames.mkString(", ")
     }
 
     super.explainTerms(pw)
       .item("table", tableSource.explainSource())
       .item("joinType", JoinTypeUtil.getFlinkJoinType(joinType))
       .item("async", lookupableSource.isAsyncEnabled)
-      .item("on", joinOnToString(inputFieldNames, rightFieldNames, joinInfo))
-      .itemIf("where", whereString, calcOnTemporalTable.isDefined)
+      .item("lookup", lookupKeys)
+      .itemIf("where", whereString, whereString.nonEmpty)
       .itemIf("joinCondition",
-        joinConditionToString(resultFieldNames, joinCondition),
-        joinCondition.isDefined)
-      .item("select", joinSelectionToString(getRowType))
+        joinConditionToString(resultFieldNames, remainingCondition),
+        remainingCondition.isDefined)
+      .item("select", selection)
   }
 
   // ----------------------------------------------------------------------------------------
@@ -181,16 +233,6 @@ abstract class CommonLookupJoin(
     val lookupFieldNamesInOrder = lookupFieldsInOrder.map(tableSchema.getFieldNames()(_))
     val lookupFieldTypesInOrder = lookupFieldsInOrder
       .map(tableSchema.getFieldDataTypes()(_)).map(fromDataTypeToLogicalType)
-    val remainingCondition = getRemainingJoinCondition(
-      cluster.getRexBuilder,
-      relBuilder,
-      input.getRowType,
-      tableRowType,
-      calcOnTemporalTable,
-      lookupFieldsInOrder,
-      joinKeyPairs,
-      joinInfo,
-      allLookupKeys)
 
     val lookupableTableSource = tableSource.asInstanceOf[LookupableTableSource[_]]
     val leftOuterJoin = joinType == JoinRelType.LEFT
@@ -409,9 +451,11 @@ abstract class CommonLookupJoin(
         expected.getComponentType == classOf[Object])
   }
 
+  /**
+    * Gets the remaining join condition which is used
+    */
   private def getRemainingJoinCondition(
       rexBuilder: RexBuilder,
-      relBuilder: RelBuilder,
       leftRelDataType: RelDataType,
       tableRelDataType: RelDataType,
       calcOnTemporalTable: Option[RexProgram],
@@ -419,29 +463,35 @@ abstract class CommonLookupJoin(
       joinKeyPairs: Array[IntPair],
       joinInfo: JoinInfo,
       allLookupKeys: Map[Int, LookupKey]): Option[RexNode] = {
-    val remainingPairs = joinKeyPairs.filter(p => !checkedLookupFields.contains(p.target))
-    // convert remaining pairs to RexInputRef tuple for building sqlStdOperatorTable.EQUALS calls
-    val remainingAnds = remainingPairs.map { p =>
+
+    // indexes of right key field
+    val rightKeyIndexes = calcOnTemporalTable match {
+      case Some(program) =>
+        checkedLookupFields.map { lookupFieldIndex => // lookupFieldIndex is field index on table
+          program
+            .getOutputRowType.getFieldNames
+            .indexOf(program.getInputRowType.getFieldNames.get(lookupFieldIndex))
+        }
+      case None =>
+        checkedLookupFields
+    }
+    val joinPairs = joinInfo.pairs().asScala.toArray
+    val remainingPairs = joinPairs.filter(p => !rightKeyIndexes.contains(p.target))
+    val joinRowType = getRowType
+    // convert remaining pairs to RexInputRef tuple for building SqlStdOperatorTable.EQUALS calls
+    val remainingEquals = remainingPairs.map { p =>
       val leftFieldType = leftRelDataType.getFieldList.get(p.source).getType
       val leftInputRef = new RexInputRef(p.source, leftFieldType)
-      val rightInputRef = calcOnTemporalTable match {
-        case Some(program) =>
-          val rightKeyIdx = program
-            .getOutputRowType.getFieldNames
-            .indexOf(program.getInputRowType.getFieldNames.get(p.target))
-          new RexInputRef(
-            leftRelDataType.getFieldCount + rightKeyIdx,
-            program.getOutputRowType.getFieldList.get(rightKeyIdx).getType)
-
-        case None =>
-          new RexInputRef(
-            leftRelDataType.getFieldCount + p.target,
-            tableRelDataType.getFieldList.get(p.target).getType)
-      }
-      (leftInputRef, rightInputRef)
+      val rightIndex = leftRelDataType.getFieldCount + p.target
+      val rightFieldType = joinRowType.getFieldList.get(rightIndex).getType
+      val rightInputRef = new RexInputRef(rightIndex, rightFieldType)
+      rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, leftInputRef, rightInputRef)
     }
-    val equiAnds = relBuilder.and(remainingAnds.map(p => relBuilder.equals(p._1, p._2)): _*)
-    val condition = relBuilder.and(equiAnds, joinInfo.getRemaining(rexBuilder))
+    val remainingAnds = remainingEquals ++ joinInfo.nonEquiConditions.asScala
+    // build a new condition
+    val condition = RexUtil.composeConjunction(
+      rexBuilder,
+      remainingAnds.toList.asJava)
     if (condition.isAlwaysTrue) {
       None
     } else {
@@ -660,10 +710,6 @@ abstract class CommonLookupJoin(
   //                              toString Utilities
   // ----------------------------------------------------------------------------------------
 
-  private def joinSelectionToString(resultType: RelDataType): String = {
-    resultType.getFieldNames.asScala.toList.mkString(", ")
-  }
-
   private def joinConditionToString(
       resultFieldNames: Array[String],
       joinCondition: Option[RexNode]): String = joinCondition match {
@@ -671,17 +717,5 @@ abstract class CommonLookupJoin(
       getExpressionString(condition, resultFieldNames.toList, None)
     case None => "N/A"
   }
-
-  private def joinOnToString(
-      inputFieldNames: Array[String],
-      tableFieldNames: Array[String],
-      joinInfo: JoinInfo): String = {
-    val keyPairNames = joinInfo.pairs().asScala.map { p =>
-      s"${inputFieldNames(p.source)}=${
-        if (p.target >= 0 && p.target < tableFieldNames.length) tableFieldNames(p.target) else -1
-      }"
-    }
-    keyPairNames.mkString(", ")
-  }
 }
 
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/RelExplainUtil.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/RelExplainUtil.scala
index 4659f27577c..74212974b35 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/RelExplainUtil.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/RelExplainUtil.scala
@@ -25,16 +25,16 @@ import org.apache.flink.table.planner.functions.aggfunctions.DeclarativeAggregat
 import org.apache.flink.table.planner.functions.utils.TableSqlFunction
 import org.apache.flink.table.planner.plan.nodes.ExpressionFormat
 import org.apache.flink.table.planner.plan.nodes.ExpressionFormat.ExpressionFormat
-
 import com.google.common.collect.ImmutableMap
 import org.apache.calcite.rel.{RelCollation, RelWriter}
 import org.apache.calcite.rel.`type`.RelDataType
 import org.apache.calcite.rel.core.Window.Group
 import org.apache.calcite.rel.core.{AggregateCall, Window}
-import org.apache.calcite.rex.{RexCall, RexInputRef, RexLiteral, RexNode, RexProgram, RexWindowBound}
+import org.apache.calcite.rex.{RexCall, RexDigestIncludeType, RexInputRef, RexLiteral, RexNode, RexProgram, RexWindowBound}
 import org.apache.calcite.sql.SqlKind
 import org.apache.calcite.sql.SqlMatchRecognize.AfterOption
 
+import java.io.{PrintWriter, StringWriter}
 import java.util
 import java.util.{SortedSet => JSortedSet}
 
@@ -67,6 +67,13 @@ object RelExplainUtil {
     fieldIndices.map(fieldNames(_)).mkString(", ")
   }
 
+  /**
+    * Returns the Java string representation of this literal.
+    */
+  def literalToString(literal: RexLiteral): String = {
+    literal.computeDigest(RexDigestIncludeType.NO_TYPE)
+  }
+
   /**
     * Converts [[RelCollation]] to String.
     *
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/join/LookupJoinTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/join/LookupJoinTest.xml
index 202533c4495..6f874ac607b 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/join/LookupJoinTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/batch/sql/join/LookupJoinTest.xml
@@ -53,7 +53,7 @@ HashAggregate(isMerge=[true], groupBy=[b], select=[b, Final_COUNT(count$0) AS EX
 +- Exchange(distribution=[hash[b]])
    +- LocalHashAggregate(groupBy=[b], select=[b, Partial_COUNT(a) AS count$0, Partial_SUM(c) AS sum$1, Partial_SUM(d) AS sum$2])
       +- Calc(select=[b, a, c, d])
-         +- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[>(age, 10)], select=[b, a, c, d, id])
+         +- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], where=[>(age, 10)], select=[b, a, c, d, id])
             +- Calc(select=[b, a, c, d])
                +- HashAggregate(isMerge=[true], groupBy=[a, b], select=[a, b, Final_SUM(sum$0) AS c, Final_SUM(sum$1) AS d])
                   +- Exchange(distribution=[hash[a, b]])
@@ -79,7 +79,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], id=[$4], name=[$5], age=[$
     </Resource>
     <Resource name="planAfter">
       <![CDATA[
-LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], select=[a, b, c, proctime, id, name, age])
+LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], select=[a, b, c, proctime, id, name, age])
 +- Calc(select=[a, b, c, PROCTIME() AS proctime])
    +- BoundedStreamScan(table=[[default_catalog, default_database, T0]], fields=[a, b, c])
 ]]>
@@ -109,7 +109,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], id=[$4], name=[$5], age=[$
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, proctime, id, name, CAST(10) AS age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[=(age, 10)], select=[a, b, c, proctime, id, name])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[age=10, id=a], where=[=(age, 10)], select=[a, b, c, proctime, id, name])
    +- Calc(select=[a, b, c, PROCTIME() AS proctime], where=[>(c, 1000)])
       +- BoundedStreamScan(table=[[default_catalog, default_database, T0]], fields=[a, b, c])
 ]]>
@@ -134,7 +134,7 @@ LogicalProject(a=[$0], b=[$1], proctime=[$2], id=[$3], name=[$4], age=[$5])
     </Resource>
     <Resource name="planAfter">
       <![CDATA[
-LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], select=[a, b, proctime, id, name, age])
+LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], select=[a, b, proctime, id, name, age])
 +- Calc(select=[a, b, PROCTIME() AS proctime], where=[>(c, 1000)])
    +- BoundedStreamScan(table=[[default_catalog, default_database, T0]], fields=[a, b, c])
 ]]>
@@ -157,7 +157,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], id=[$4], name=[$5], age=[$
     </Resource>
     <Resource name="planAfter">
       <![CDATA[
-LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[LeftOuterJoin], async=[false], on=[a=id], select=[a, b, c, proctime, id, name, age])
+LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[LeftOuterJoin], async=[false], lookup=[id=a], select=[a, b, c, proctime, id, name, age])
 +- Calc(select=[a, b, c, PROCTIME() AS proctime])
    +- BoundedStreamScan(table=[[default_catalog, default_database, T0]], fields=[a, b, c])
 ]]>
@@ -185,7 +185,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], id=[$4])
     </Resource>
     <Resource name="planAfter">
       <![CDATA[
-LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[], select=[a, b, c, proctime, id])
+LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], select=[a, b, c, proctime, id])
 +- Calc(select=[a, b, c, PROCTIME() AS proctime])
    +- BoundedStreamScan(table=[[default_catalog, default_database, T0]], fields=[a, b, c])
 ]]>
@@ -258,7 +258,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], id=[$4], name=[$5], age=[$
     </Resource>
     <Resource name="planAfter">
       <![CDATA[
-LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[], select=[a, b, c, proctime, id, name, age])
+LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[], select=[a, b, c, proctime, id, name, age])
 +- Calc(select=[a, b, c, PROCTIME() AS proctime], where=[>(c, 1000)])
    +- BoundedStreamScan(table=[[default_catalog, default_database, T0]], fields=[a, b, c])
 ]]>
@@ -328,7 +328,7 @@ Calc(select=[EXPR$0, EXPR$1, EXPR$2])
       +- LocalHashAggregate(groupBy=[b, b0], select=[b, b0, Partial_COUNT(a) AS count$0, Partial_COUNT(id) AS count$1, Partial_SUM(a0) AS sum$2])
          +- HashJoin(joinType=[InnerJoin], where=[=(a, a0)], select=[b, a, id, a0, b0], build=[right])
             :- Exchange(distribution=[hash[a]], shuffle_mode=[BATCH])
-            :  +- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[>(age, 10)], select=[b, a, id], reuse_id=[1])
+            :  +- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], where=[>(age, 10)], select=[b, a, id], reuse_id=[1])
             :     +- Calc(select=[b, a])
             :        +- HashAggregate(isMerge=[true], groupBy=[a, b], select=[a, b])
             :           +- Exchange(distribution=[hash[a, b]])
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml
index 358f6018324..d8ce0a5c4ac 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.xml
@@ -39,7 +39,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, CAST(10) AS age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[AND(=(age, 10), >(CAST(name), 1000))], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[age=10, id=a], where=[AND(=(age, 10), >(CAST(name), 1000))], select=[a, b, c, proctime, rowtime, id, name, age])
    +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
     </Resource>
@@ -80,7 +80,7 @@ LogicalAggregate(group=[{0}], EXPR$1=[COUNT($1)], EXPR$2=[SUM($2)], EXPR$3=[SUM(
 GroupAggregate(groupBy=[b], select=[b, COUNT_RETRACT(a) AS EXPR$1, SUM_RETRACT(c) AS EXPR$2, SUM_RETRACT(d) AS EXPR$3])
 +- Exchange(distribution=[hash[b]])
    +- Calc(select=[b, a, c, d])
-      +- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[>(age, 10)], select=[b, a, c, d, id])
+      +- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], where=[>(age, 10)], select=[b, a, c, d, id])
          +- Calc(select=[b, a, c, d])
             +- GroupAggregate(groupBy=[a, b], select=[a, b, SUM(c) AS c, SUM(d) AS d])
                +- Exchange(distribution=[hash[a, b]])
@@ -105,7 +105,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], select=[a, b, c, proctime, rowtime, id, name, age])
    +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
     </Resource>
@@ -133,7 +133,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, CAST(10) AS age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[=(age, 10)], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[age=10, id=a], where=[=(age, 10)], select=[a, b, c, proctime, rowtime, id, name, age])
    +- Calc(select=[a, b, c, proctime, rowtime], where=[>(c, 1000)])
       +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
@@ -162,7 +162,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, CAST(_UTF-16LE'AAA':VARCHAR(2147483647) CHARACTER SET "UTF-16LE") AS name, CAST(10) AS age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], where=[AND(=(age, 10), =(name, _UTF-16LE'AAA':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"))], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[age=10, name=_UTF-16LE'AAA', id=a], where=[AND(=(age, 10), =(name, _UTF-16LE'AAA':VARCHAR(2147483647) CHARACTER SET "UTF-16LE"))], select=[a, b, c, proctime, rowtime, id, name, age])
    +- Calc(select=[a, b, c, proctime, rowtime], where=[>(c, 1000)])
       +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
@@ -187,7 +187,7 @@ LogicalProject(a=[$0], b=[$1], proctime=[$2], id=[$3], name=[$4], age=[$5])
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, PROCTIME_MATERIALIZE(proctime) AS proctime, id, name, age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], select=[a, b, proctime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], select=[a, b, proctime, id, name, age])
    +- Calc(select=[a, b, proctime], where=[>(c, 1000)])
       +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
@@ -210,7 +210,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[LeftOuterJoin], async=[false], on=[a=id], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[LeftOuterJoin], async=[false], lookup=[id=a], select=[a, b, c, proctime, rowtime, id, name, age])
    +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
     </Resource>
@@ -237,7 +237,7 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5])
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[a=id], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], select=[a, b, c, proctime, rowtime, id, name, age])
    +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
     </Resource>
@@ -264,9 +264,89 @@ LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], nam
     <Resource name="planAfter">
       <![CDATA[
 Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, age])
-+- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], on=[], select=[a, b, c, proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[], select=[a, b, c, proctime, rowtime, id, name, age])
    +- Calc(select=[a, b, c, proctime, rowtime], where=[>(c, 1000)])
       +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinTemporalTableWithFunctionAndConstantCondition">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM MyTable AS T
+JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D
+ON T.b = concat(D.name, '!') AND D.age = 11
+      ]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], name=[$6], age=[$7])
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{1, 3}])
+   :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]])
+   +- LogicalFilter(condition=[AND(=($cor0.b, CONCAT($1, _UTF-16LE'!')), =($2, 11))])
+      +- LogicalSnapshot(period=[$cor0.proctime])
+         +- LogicalTableScan(table=[[default_catalog, default_database, temporalTest, source: [TestTemporalTable(id, name, age)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, CAST(11) AS age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[age=11], where=[=(age, 11)], joinCondition=[=(b, $f3)], select=[a, b, c, proctime, rowtime, id, name, CAST(11) AS age, CONCAT(name, _UTF-16LE'!') AS $f3])
+   +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinTemporalTableWithMultiFunctionAndConstantCondition">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM MyTable AS T
+JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D
+ON T.a = D.id + 1 AND T.b = concat(D.name, '!') AND D.age = 11
+      ]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], name=[$6], age=[$7])
++- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1, 3}])
+   :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]])
+   +- LogicalFilter(condition=[AND(=($cor0.a, +($0, 1)), =($cor0.b, CONCAT($1, _UTF-16LE'!')), =($2, 11))])
+      +- LogicalSnapshot(period=[$cor0.proctime])
+         +- LogicalTableScan(table=[[default_catalog, default_database, temporalTest, source: [TestTemporalTable(id, name, age)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, CAST(11) AS age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[age=11], where=[=(age, 11)], joinCondition=[AND(=(a, $f3), =(b, $f4))], select=[a, b, c, proctime, rowtime, id, name, CAST(11) AS age, +(id, 1) AS $f3, CONCAT(name, _UTF-16LE'!') AS $f4])
+   +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testJoinTemporalTableWithFunctionAndReferenceCondition">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * FROM MyTable AS T
+JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D
+ON T.a = D.id AND T.b = concat(D.name, '!')
+WHERE D.name LIKE 'Jack%'
+      ]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], proctime=[$3], rowtime=[$4], id=[$5], name=[$6], age=[$7])
++- LogicalFilter(condition=[LIKE($6, _UTF-16LE'Jack%')])
+   +- LogicalCorrelate(correlation=[$cor0], joinType=[inner], requiredColumns=[{0, 1, 3}])
+      :- LogicalTableScan(table=[[default_catalog, default_database, MyTable]])
+      +- LogicalFilter(condition=[AND(=($cor0.a, $0), =($cor0.b, CONCAT($1, _UTF-16LE'!')))])
+         +- LogicalSnapshot(period=[$cor0.proctime])
+            +- LogicalTableScan(table=[[default_catalog, default_database, temporalTest, source: [TestTemporalTable(id, name, age)]]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[a, b, c, PROCTIME_MATERIALIZE(proctime) AS proctime, rowtime, id, name, age])
++- LookupJoin(table=[TestTemporalTable(id, name, age)], joinType=[InnerJoin], async=[false], lookup=[id=a], where=[LIKE(name, _UTF-16LE'Jack%')], joinCondition=[=(b, $f3)], select=[a, b, c, proctime, rowtime, id, name, age, CONCAT(name, _UTF-16LE'!') AS $f3])
+   +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala
index 10eac476ede..d64eb4df4cb 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/join/LookupJoinTest.scala
@@ -355,6 +355,45 @@ class LookupJoinTest extends TableTestBase with Serializable {
     streamUtil.verifyPlan(sql)
   }
 
+  @Test
+  def testJoinTemporalTableWithFunctionAndConstantCondition(): Unit = {
+
+    val sql =
+      """
+        |SELECT * FROM MyTable AS T
+        |JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D
+        |ON T.b = concat(D.name, '!') AND D.age = 11
+      """.stripMargin
+
+    streamUtil.verifyPlan(sql)
+  }
+
+  @Test
+  def testJoinTemporalTableWithMultiFunctionAndConstantCondition(): Unit = {
+
+    val sql =
+      """
+        |SELECT * FROM MyTable AS T
+        |JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D
+        |ON T.a = D.id + 1 AND T.b = concat(D.name, '!') AND D.age = 11
+      """.stripMargin
+
+    streamUtil.verifyPlan(sql)
+  }
+
+  @Test
+  def testJoinTemporalTableWithFunctionAndReferenceCondition(): Unit = {
+    val sql =
+      """
+        |SELECT * FROM MyTable AS T
+        |JOIN temporalTest FOR SYSTEM_TIME AS OF T.proctime AS D
+        |ON T.a = D.id AND T.b = concat(D.name, '!')
+        |WHERE D.name LIKE 'Jack%'
+      """.stripMargin
+
+    streamUtil.verifyPlan(sql)
+  }
+
   // ==========================================================================================
 
   private def expectExceptionThrown(
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala
index f145e2bcd77..e12722db20e 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/LookupJoinITCase.scala
@@ -54,7 +54,9 @@ class LookupJoinITCase extends StreamingTestBase {
   val userData = List(
     (11, 1L, "Julian"),
     (22, 2L, "Jark"),
-    (33, 3L, "Fabian"))
+    (33, 3L, "Fabian"),
+    (11, 4L, "Hello world"),
+    (11, 5L, "Hello world"))
 
   val userTableSource = InMemoryLookupableTableSource.builder()
     .data(userData)
@@ -515,4 +517,26 @@ class LookupJoinITCase extends StreamingTestBase {
     assertEquals(0, userTableSourceWith2Keys.getResourceCounter)
   }
 
+  @Test
+  def testJoinTemporalTableOnMultiKeyFieldsWithUDF(): Unit = {
+    val streamTable = env.fromCollection(data)
+      .toTable(tEnv, 'id, 'len, 'content, 'proctime.proctime)
+    tEnv.registerTable("T", streamTable)
+
+    tEnv.registerTableSource("userTable", userTableSource)
+
+    val sql = "SELECT T.id, T.content, D.age, D.id FROM T JOIN userTable " +
+      "for system_time as of T.proctime AS D " +
+      "ON T.id = D.id + 4 AND T.content = concat(D.name, '!') AND D.age = 11"
+
+    val sink = new TestingAppendSink
+    tEnv.sqlQuery(sql).toAppendStream[Row].addSink(sink)
+    env.execute()
+
+    val expected = Seq(
+      "9,Hello world!,11,5")
+    assertEquals(expected.sorted, sink.getAppendResults.sorted)
+    assertEquals(0, userTableSource.getResourceCounter)
+  }
+
 }
