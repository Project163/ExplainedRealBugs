diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManager.java
index f7bd0c7c4ad..36eab3c5996 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManager.java
@@ -143,6 +143,15 @@ public interface FileMergingSnapshotManager extends Closeable {
     DirectoryStreamStateHandle getManagedDirStateHandle(
             SubtaskKey subtaskKey, CheckpointedStateScope scope);
 
+    /**
+     * Notifies the manager that the checkpoint with the given {@code checkpointId} has been
+     * started.
+     *
+     * @param subtaskKey the subtask key identifying the subtask.
+     * @param checkpointId The ID of the checkpoint that has been started.
+     */
+    void notifyCheckpointStart(SubtaskKey subtaskKey, long checkpointId);
+
     /**
      * Notifies the manager that the checkpoint with the given {@code checkpointId} completed and
      * was committed.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBase.java
index fd50eed7e6c..180ca9c0f8a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBase.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBase.java
@@ -59,6 +59,7 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.stream.Stream;
 
+import static org.apache.flink.runtime.checkpoint.filemerging.FileMergingSnapshotManagerBase.DirectoryHandleWithReferenceTrack.wrap;
 import static org.apache.flink.runtime.checkpoint.filemerging.PhysicalFile.PhysicalFileDeleter;
 
 /** Base implementation of {@link FileMergingSnapshotManager}. */
@@ -133,9 +134,10 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     private final Map<SubtaskKey, Path> managedSharedStateDir = new ConcurrentHashMap<>();
 
     /**
-     * The {@link DirectoryStreamStateHandle} for shared state directories, one for each subtask.
+     * The {@link DirectoryStreamStateHandle} with it ongoing checkpoint reference count for shared
+     * state directories, one for each subtask and job.
      */
-    private final Map<SubtaskKey, DirectoryStreamStateHandle> managedSharedStateDirHandles =
+    private final Map<SubtaskKey, DirectoryHandleWithReferenceTrack> managedSharedStateDirHandles =
             new ConcurrentHashMap<>();
 
     /**
@@ -145,10 +147,10 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     protected Path managedExclusiveStateDir;
 
     /**
-     * The {@link DirectoryStreamStateHandle} for private state directory, one for each task
-     * manager.
+     * The {@link DirectoryStreamStateHandle} with it ongoing checkpoint reference count for private
+     * state directory, one for each taskmanager and job.
      */
-    protected DirectoryStreamStateHandle managedExclusiveStateDirHandle;
+    protected DirectoryHandleWithReferenceTrack managedExclusiveStateDirHandle;
 
     /** The current space statistic, updated on file creation/deletion. */
     protected SpaceStat spaceStat;
@@ -198,7 +200,6 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
             this.checkpointDir = Preconditions.checkNotNull(checkpointBaseDir);
             this.sharedStateDir = Preconditions.checkNotNull(sharedStateDir);
             this.taskOwnedStateDir = Preconditions.checkNotNull(taskOwnedStateDir);
-            this.fileSystemInitiated = true;
             this.shouldSyncAfterClosingLogicalFile = shouldSyncAfterClosingLogicalFile(fileSystem);
             // Initialize the managed exclusive path using id as the child path name.
             // Currently, we use the task-owned directory to place the merged private state.
@@ -206,11 +207,12 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
             // to the FLIP-306, we later consider move these files to the new introduced
             // task-manager-owned directory.
             Path managedExclusivePath = new Path(taskOwnedStateDir, id);
-            createManagedDirectory(managedExclusivePath);
+            boolean newCreated = createManagedDirectory(managedExclusivePath);
             this.managedExclusiveStateDir = managedExclusivePath;
             this.managedExclusiveStateDirHandle =
-                    DirectoryStreamStateHandle.of(managedExclusivePath);
+                    wrap(DirectoryStreamStateHandle.of(managedExclusivePath), newCreated);
             this.writeBufferSize = writeBufferSize;
+            this.fileSystemInitiated = true;
         }
     }
 
@@ -219,10 +221,10 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
         String managedDirName = subtaskKey.getManagedDirName();
         Path managedPath = new Path(sharedStateDir, managedDirName);
         if (!managedSharedStateDir.containsKey(subtaskKey)) {
-            createManagedDirectory(managedPath);
+            boolean newCreated = createManagedDirectory(managedPath);
             managedSharedStateDir.put(subtaskKey, managedPath);
             managedSharedStateDirHandles.put(
-                    subtaskKey, DirectoryStreamStateHandle.of(managedPath));
+                    subtaskKey, wrap(DirectoryStreamStateHandle.of(managedPath), newCreated));
         }
     }
 
@@ -230,6 +232,8 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     public void unregisterSubtask(SubtaskKey subtaskKey) {
         if (managedSharedStateDir.containsKey(subtaskKey)) {
             managedSharedStateDir.remove(subtaskKey);
+            // try clean up before remove
+            managedSharedStateDirHandles.get(subtaskKey).tryCleanupQuietly();
             managedSharedStateDirHandles.remove(subtaskKey);
         }
     }
@@ -492,14 +496,50 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     //  Checkpoint Listener
     // ------------------------------------------------------------------------
 
+    /**
+     * {@link org.apache.flink.streaming.runtime.tasks.SubtaskCheckpointCoordinatorImpl} use this
+     * method let the file merging manager know an ongoing checkpoint may reference the managed
+     * dirs.
+     */
+    @Override
+    public void notifyCheckpointStart(SubtaskKey subtaskKey, long checkpointId) {
+        if (fileSystemInitiated) {
+            managedSharedStateDirHandles.computeIfPresent(
+                    subtaskKey,
+                    (k, v) -> {
+                        v.increaseRefCountWhenCheckpointStart(checkpointId);
+                        return v;
+                    });
+            managedExclusiveStateDirHandle.increaseRefCountWhenCheckpointStart(checkpointId);
+        }
+    }
+
     @Override
     public void notifyCheckpointComplete(SubtaskKey subtaskKey, long checkpointId)
             throws Exception {
-        // does nothing
+        if (fileSystemInitiated) {
+            managedSharedStateDirHandles.computeIfPresent(
+                    subtaskKey,
+                    (k, v) -> {
+                        v.handoverOwnershipWhenCheckpointComplete(checkpointId);
+                        return v;
+                    });
+            managedExclusiveStateDirHandle.handoverOwnershipWhenCheckpointComplete(checkpointId);
+        }
     }
 
     @Override
     public void notifyCheckpointAborted(SubtaskKey subtaskKey, long checkpointId) throws Exception {
+        if (fileSystemInitiated) {
+            managedSharedStateDirHandles.computeIfPresent(
+                    subtaskKey,
+                    (k, v) -> {
+                        v.decreaseRefCountWhenCheckpointAbort(checkpointId);
+                        return v;
+                    });
+            managedExclusiveStateDirHandle.decreaseRefCountWhenCheckpointAbort(checkpointId);
+        }
+
         synchronized (lock) {
             Set<LogicalFile> logicalFilesForCurrentCp = uploadedStates.get(checkpointId);
             if (logicalFilesForCurrentCp == null) {
@@ -515,6 +555,16 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     @Override
     public void notifyCheckpointSubsumed(SubtaskKey subtaskKey, long checkpointId)
             throws Exception {
+        if (fileSystemInitiated) {
+            managedSharedStateDirHandles.computeIfPresent(
+                    subtaskKey,
+                    (k, v) -> {
+                        v.handoverOwnershipWhenCheckpointSubsumed(checkpointId);
+                        return v;
+                    });
+            managedExclusiveStateDirHandle.handoverOwnershipWhenCheckpointSubsumed(checkpointId);
+        }
+
         synchronized (lock) {
             Iterator<Map.Entry<Long, Set<LogicalFile>>> uploadedStatesIterator =
                     uploadedStates.headMap(checkpointId, true).entrySet().iterator();
@@ -708,9 +758,11 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     public DirectoryStreamStateHandle getManagedDirStateHandle(
             SubtaskKey subtaskKey, CheckpointedStateScope scope) {
         if (scope.equals(CheckpointedStateScope.SHARED)) {
-            return managedSharedStateDirHandles.get(subtaskKey);
+            DirectoryHandleWithReferenceTrack handleWithTrack =
+                    managedSharedStateDirHandles.get(subtaskKey);
+            return handleWithTrack != null ? handleWithTrack.getHandle() : null;
         } else {
-            return managedExclusiveStateDirHandle;
+            return managedExclusiveStateDirHandle.getHandle();
         }
     }
 
@@ -725,7 +777,13 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     //  utilities
     // ------------------------------------------------------------------------
 
-    private void createManagedDirectory(Path managedPath) {
+    /**
+     * Create managed directory.
+     *
+     * @param managedPath the path.
+     * @return true if new created.
+     */
+    private boolean createManagedDirectory(Path managedPath) {
         try {
             FileStatus fileStatus = null;
             try {
@@ -736,8 +794,10 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
             if (fileStatus == null) {
                 fs.mkdirs(managedPath);
                 LOG.info("Created a directory {} for checkpoint file-merging.", managedPath);
+                return true;
             } else if (fileStatus.isDir()) {
                 LOG.info("Reusing previous directory {} for checkpoint file-merging.", managedPath);
+                return false;
             } else {
                 throw new FlinkRuntimeException(
                         "The managed path "
@@ -751,7 +811,25 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     }
 
     @Override
-    public void close() throws IOException {}
+    public void close() throws IOException {
+        if (fileSystemInitiated) {
+            quietlyCleanupManagedDir();
+        }
+    }
+
+    private void quietlyCleanupManagedDir() {
+        // Quietly clean up useless shared state dir.
+        managedSharedStateDirHandles.forEach(
+                (subtaskKey, handleWithTrack) -> handleWithTrack.tryCleanupQuietly());
+
+        // Quietly clean up useless exclusive state dir.
+        managedExclusiveStateDirHandle.tryCleanupQuietly();
+    }
+
+    @VisibleForTesting
+    public String getId() {
+        return id;
+    }
 
     // ------------------------------------------------------------------------
     //  restore
@@ -861,4 +939,82 @@ public abstract class FileMergingSnapshotManagerBase implements FileMergingSnaps
     boolean isCheckpointDiscard(long checkpointId) {
         return notifiedCheckpoint.contains(checkpointId);
     }
+
+    /**
+     * This class wrap DirectoryStreamStateHandle with reference count by ongoing checkpoint. If an
+     * ongoing checkpoint which reference the directory handle complete, we will stop tracking the
+     * handle, because the ownership of the handle is handover to JobManager.
+     */
+    protected static class DirectoryHandleWithReferenceTrack {
+
+        private final DirectoryStreamStateHandle directoryHandle;
+        // reference count by ongoing checkpoint
+        private final AtomicLong ongoingRefCount;
+        private boolean tracking;
+
+        DirectoryHandleWithReferenceTrack(DirectoryStreamStateHandle directoryHandle, boolean own) {
+            this.directoryHandle = directoryHandle;
+            this.ongoingRefCount = new AtomicLong(0);
+            this.tracking = own;
+        }
+
+        static DirectoryHandleWithReferenceTrack wrap(
+                DirectoryStreamStateHandle directoryHandle, boolean own) {
+            return new DirectoryHandleWithReferenceTrack(directoryHandle, own);
+        }
+
+        DirectoryStreamStateHandle getHandle() {
+            return directoryHandle;
+        }
+
+        void increaseRefCountWhenCheckpointStart(long checkpointId) {
+            if (tracking) {
+                LOG.debug(
+                        "checkpoint:{} start, increase ref-count to file-merging managed shared dir : {}",
+                        checkpointId,
+                        directoryHandle.getDirectory());
+                ongoingRefCount.incrementAndGet();
+            }
+        }
+
+        void decreaseRefCountWhenCheckpointAbort(long checkpointId) {
+            if (tracking) {
+                LOG.debug(
+                        "checkpoint:{} aborted, decrease ref-count to file-merging managed shared dir : {}",
+                        checkpointId,
+                        directoryHandle.getDirectory());
+                ongoingRefCount.decrementAndGet();
+            }
+        }
+
+        void handoverOwnershipWhenCheckpointComplete(long checkpointId) {
+            if (tracking) {
+                LOG.debug(
+                        "checkpoint:{} complete, handover ownership of file-merging managed shared dir to JobManager : {}",
+                        checkpointId,
+                        directoryHandle.getDirectory());
+                tracking = false;
+            }
+        }
+
+        void handoverOwnershipWhenCheckpointSubsumed(long checkpointId) {
+            if (tracking) {
+                LOG.debug(
+                        "checkpoint:{} subsumed, handover ownership of file-merging managed shared dir to JobManager : {}",
+                        checkpointId,
+                        directoryHandle.getDirectory());
+                tracking = false;
+            }
+        }
+
+        void tryCleanupQuietly() {
+            if (tracking && ongoingRefCount.get() == 0 && directoryHandle != null) {
+                try {
+                    directoryHandle.discardState();
+                } catch (Exception e) {
+                    // ignore
+                }
+            }
+        }
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBuilder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBuilder.java
index 6bf8b2ca0a6..18ec3a4d75e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBuilder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerBuilder.java
@@ -17,10 +17,10 @@
 
 package org.apache.flink.runtime.checkpoint.filemerging;
 
-import org.apache.flink.runtime.metrics.groups.TaskManagerJobMetricGroup;
-import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
+import org.apache.flink.runtime.metrics.groups.TaskManagerJobMetricGroup;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.util.Preconditions;
 
 import javax.annotation.Nullable;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTestBase.java
index 19d18b8c72b..f22a9dcf2f4 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTestBase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/filemerging/FileMergingSnapshotManagerTestBase.java
@@ -22,6 +22,7 @@ import org.apache.flink.api.common.TaskInfo;
 import org.apache.flink.api.common.TaskInfoImpl;
 import org.apache.flink.core.fs.CloseableRegistry;
 import org.apache.flink.core.fs.FSDataInputStream;
+import org.apache.flink.core.fs.FileStatus;
 import org.apache.flink.core.fs.FileSystem;
 import org.apache.flink.core.fs.Path;
 import org.apache.flink.core.fs.local.LocalFileSystem;
@@ -41,7 +42,6 @@ import org.apache.flink.runtime.state.KeyGroupsStateHandle;
 import org.apache.flink.runtime.state.OperatorStateHandle;
 import org.apache.flink.runtime.state.filemerging.FileMergingOperatorStreamStateHandle;
 import org.apache.flink.runtime.state.filemerging.SegmentFileStateHandle;
-import org.apache.flink.runtime.state.filesystem.AbstractFsCheckpointStorageAccess;
 import org.apache.flink.runtime.state.filesystem.FileMergingCheckpointStateOutputStream;
 
 import org.junit.jupiter.api.BeforeEach;
@@ -62,6 +62,8 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Future;
 import java.util.stream.Collectors;
 
+import static org.apache.flink.runtime.state.filesystem.AbstractFsCheckpointStorageAccess.CHECKPOINT_SHARED_STATE_DIR;
+import static org.apache.flink.runtime.state.filesystem.AbstractFsCheckpointStorageAccess.CHECKPOINT_TASK_OWNED_STATE_DIR;
 import static org.assertj.core.api.Assertions.assertThat;
 
 /** Tests for {@link FileMergingSnapshotManager}. */
@@ -77,6 +79,8 @@ public abstract class FileMergingSnapshotManagerTestBase {
     SubtaskKey subtaskKey2;
 
     Path checkpointBaseDir;
+    Path sharedStateDir;
+    Path taskOwnedStateDir;
 
     int writeBufferSize;
 
@@ -88,7 +92,11 @@ public abstract class FileMergingSnapshotManagerTestBase {
                 new SubtaskKey(jobID, operatorID, new TaskInfoImpl("TestingTask", 128, 0, 128, 3));
         subtaskKey2 =
                 new SubtaskKey(jobID, operatorID, new TaskInfoImpl("TestingTask", 128, 1, 128, 3));
+
         checkpointBaseDir = new Path(tempFolder.toString(), jobID.toHexString());
+        sharedStateDir = new Path(checkpointBaseDir, CHECKPOINT_SHARED_STATE_DIR);
+        taskOwnedStateDir = new Path(checkpointBaseDir, CHECKPOINT_TASK_OWNED_STATE_DIR);
+
         writeBufferSize = 4096;
     }
 
@@ -98,21 +106,12 @@ public abstract class FileMergingSnapshotManagerTestBase {
                 (FileMergingSnapshotManagerBase)
                         createFileMergingSnapshotManager(checkpointBaseDir)) {
             fmsm.registerSubtaskForSharedStates(subtaskKey1);
+
+            String expectManagerId = String.format("job_%s_tm_%s", jobID, tmId);
             assertThat(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.EXCLUSIVE))
-                    .isEqualTo(
-                            new Path(
-                                    checkpointBaseDir,
-                                    AbstractFsCheckpointStorageAccess
-                                                    .CHECKPOINT_TASK_OWNED_STATE_DIR
-                                            + "/"
-                                            + String.format("job_%s_tm_%s", jobID, tmId)));
+                    .isEqualTo(new Path(taskOwnedStateDir, expectManagerId));
             assertThat(fmsm.getManagedDir(subtaskKey1, CheckpointedStateScope.SHARED))
-                    .isEqualTo(
-                            new Path(
-                                    checkpointBaseDir,
-                                    AbstractFsCheckpointStorageAccess.CHECKPOINT_SHARED_STATE_DIR
-                                            + "/"
-                                            + subtaskKey1.getManagedDirName()));
+                    .isEqualTo(new Path(sharedStateDir, subtaskKey1.getManagedDirName()));
         }
     }
 
@@ -459,11 +458,16 @@ public abstract class FileMergingSnapshotManagerTestBase {
                         (FileMergingSnapshotManagerBase)
                                 createFileMergingSnapshotManager(checkpointBaseDir);
                 CloseableRegistry closeableRegistry = new CloseableRegistry()) {
+
+            fmsm.notifyCheckpointStart(subtaskKey1, checkpointId);
+
             Map<OperatorID, OperatorSubtaskState> subtaskStatesByOperatorID = new HashMap<>();
             subtaskStatesByOperatorID.put(
                     operatorID, buildOperatorSubtaskState(checkpointId, fmsm, closeableRegistry));
             taskStateSnapshot = new TaskStateSnapshot(subtaskStatesByOperatorID);
             oldSpaceStat = fmsm.spaceStat;
+
+            fmsm.notifyCheckpointComplete(subtaskKey1, checkpointId);
         }
 
         assertThat(taskStateSnapshot).isNotNull();
@@ -512,6 +516,107 @@ public abstract class FileMergingSnapshotManagerTestBase {
         }
     }
 
+    @Test
+    public void testManagedDirCleanup() throws Exception {
+        FileSystem fs = LocalFileSystem.getSharedInstance();
+
+        Path sharedDirOfSubtask1 = new Path(sharedStateDir, subtaskKey1.getManagedDirName());
+        Path sharedDirOfSubtask2 = new Path(sharedStateDir, subtaskKey2.getManagedDirName());
+        Path exclusiveDir;
+
+        // 1. Test clean up managed dir after non checkpoint triggered
+        emptyCheckpointBaseDir();
+        try (FileMergingSnapshotManagerBase fmsm =
+                (FileMergingSnapshotManagerBase)
+                        createFileMergingSnapshotManager(
+                                checkpointBaseDir,
+                                32,
+                                PhysicalFilePool.Type.BLOCKING,
+                                Float.MAX_VALUE)) {
+
+            fmsm.registerSubtaskForSharedStates(subtaskKey1);
+            fmsm.registerSubtaskForSharedStates(subtaskKey2);
+
+            assertThat(fs.exists(sharedDirOfSubtask1)).isTrue();
+            assertThat(fs.exists(sharedDirOfSubtask2)).isTrue();
+            exclusiveDir = new Path(taskOwnedStateDir, fmsm.getId());
+            assertThat(fs.exists(exclusiveDir)).isTrue();
+        }
+        assertThat(fs.exists(sharedDirOfSubtask1)).isFalse();
+        assertThat(fs.exists(sharedDirOfSubtask2)).isFalse();
+        assertThat(fs.exists(exclusiveDir)).isFalse();
+
+        // 2. Test clean up managed dir after all checkpoint abort
+        emptyCheckpointBaseDir();
+        try (FileMergingSnapshotManagerBase fmsm =
+                (FileMergingSnapshotManagerBase)
+                        createFileMergingSnapshotManager(
+                                checkpointBaseDir,
+                                32,
+                                PhysicalFilePool.Type.BLOCKING,
+                                Float.MAX_VALUE)) {
+
+            fmsm.registerSubtaskForSharedStates(subtaskKey1);
+            fmsm.registerSubtaskForSharedStates(subtaskKey2);
+
+            // record reference from checkpoint 1
+            fmsm.notifyCheckpointStart(subtaskKey1, 1L);
+            fmsm.notifyCheckpointStart(subtaskKey2, 1L);
+
+            // checkpoint 1 aborted
+            fmsm.notifyCheckpointAborted(subtaskKey1, 1L);
+            fmsm.notifyCheckpointAborted(subtaskKey2, 1L);
+
+            assertThat(fs.exists(sharedDirOfSubtask1)).isTrue();
+            assertThat(fs.exists(sharedDirOfSubtask2)).isTrue();
+            exclusiveDir = new Path(taskOwnedStateDir, fmsm.getId());
+            assertThat(fs.exists(exclusiveDir)).isTrue();
+        }
+        assertThat(fs.exists(sharedDirOfSubtask1)).isFalse();
+        assertThat(fs.exists(sharedDirOfSubtask2)).isFalse();
+        assertThat(fs.exists(exclusiveDir)).isFalse();
+
+        // 3. Test not clean up managed dir after checkpoint complete
+        emptyCheckpointBaseDir();
+        try (FileMergingSnapshotManagerBase fmsm =
+                (FileMergingSnapshotManagerBase)
+                        createFileMergingSnapshotManager(
+                                checkpointBaseDir,
+                                32,
+                                PhysicalFilePool.Type.BLOCKING,
+                                Float.MAX_VALUE)) {
+
+            fmsm.registerSubtaskForSharedStates(subtaskKey1);
+            fmsm.registerSubtaskForSharedStates(subtaskKey2);
+
+            // record reference from checkpoint 1
+            fmsm.notifyCheckpointStart(subtaskKey1, 1L);
+            fmsm.notifyCheckpointStart(subtaskKey2, 1L);
+
+            // checkpoint 1 complete
+            fmsm.notifyCheckpointComplete(subtaskKey1, 1L);
+            fmsm.notifyCheckpointComplete(subtaskKey2, 1L);
+
+            assertThat(fs.exists(sharedDirOfSubtask1)).isTrue();
+            assertThat(fs.exists(sharedDirOfSubtask2)).isTrue();
+            exclusiveDir = new Path(taskOwnedStateDir, fmsm.getId());
+            assertThat(fs.exists(exclusiveDir)).isTrue();
+        }
+        assertThat(fs.exists(sharedDirOfSubtask1)).isTrue();
+        assertThat(fs.exists(sharedDirOfSubtask2)).isTrue();
+        assertThat(fs.exists(exclusiveDir)).isTrue();
+    }
+
+    private void emptyCheckpointBaseDir() throws IOException {
+        FileSystem fs = checkpointBaseDir.getFileSystem();
+        FileStatus[] sub = fs.listStatus(checkpointBaseDir);
+        if (sub != null) {
+            for (FileStatus subFile : sub) {
+                fs.delete(subFile.getPath(), true);
+            }
+        }
+    }
+
     private OperatorSubtaskState buildOperatorSubtaskState(
             long checkpointId, FileMergingSnapshotManager fmsm, CloseableRegistry closeableRegistry)
             throws Exception {
@@ -576,14 +681,6 @@ public abstract class FileMergingSnapshotManagerTestBase {
             float spaceAmplification)
             throws IOException {
         FileSystem fs = LocalFileSystem.getSharedInstance();
-        Path sharedStateDir =
-                new Path(
-                        checkpointBaseDir,
-                        AbstractFsCheckpointStorageAccess.CHECKPOINT_SHARED_STATE_DIR);
-        Path taskOwnedStateDir =
-                new Path(
-                        checkpointBaseDir,
-                        AbstractFsCheckpointStorageAccess.CHECKPOINT_TASK_OWNED_STATE_DIR);
         if (!fs.exists(checkpointBaseDir)) {
             fs.mkdirs(checkpointBaseDir);
             fs.mkdirs(sharedStateDir);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java
index b97328dc902..cc66faba9b8 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorImpl.java
@@ -314,6 +314,12 @@ class SubtaskCheckpointCoordinatorImpl implements SubtaskCheckpointCoordinator {
             return;
         }
 
+        if (fileMergingSnapshotManager != null) {
+            // notify file merging snapshot manager for managed dir lifecycle management
+            fileMergingSnapshotManager.notifyCheckpointStart(
+                    FileMergingSnapshotManager.SubtaskKey.of(env), metadata.getCheckpointId());
+        }
+
         // if checkpoint has been previously unaligned, but was forced to be aligned (pointwise
         // connection), revert it here so that it can jump over output data
         if (options.getAlignment() == CheckpointOptions.AlignmentType.FORCED_ALIGNED) {
