diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
index ca6083a4750..cc7153d16b7 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.kubernetes.highavailability;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesConfigMap;
@@ -28,7 +29,9 @@ import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.persistence.StringResourceVersion;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
+import org.apache.flink.runtime.state.StateObject;
 import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.InstantiationUtil;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -44,9 +47,12 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
@@ -69,13 +75,82 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
  * the leader could update the store. Then we will completely get rid of the lock-and-release in
  * Zookeeper implementation.
  *
- * @param <T> Type of state
+ * @param <T> Type of the state we're storing.
  */
 public class KubernetesStateHandleStore<T extends Serializable>
         implements StateHandleStore<T, StringResourceVersion> {
 
     private static final Logger LOG = LoggerFactory.getLogger(KubernetesStateHandleStore.class);
 
+    private static <T extends Serializable> StateHandleWithDeleteMarker<T> deserializeStateHandle(
+            String content) throws IOException {
+        checkNotNull(content, "Content should not be null.");
+        final byte[] data = Base64.getDecoder().decode(content);
+        try {
+            return deserialize(data);
+        } catch (IOException | ClassNotFoundException e) {
+            throw new IOException(
+                    String.format(
+                            "Failed to deserialize state handle from ConfigMap data %s.", content),
+                    e);
+        }
+    }
+
+    private static String toBase64(byte[] bytes) {
+        return Base64.getEncoder().encodeToString(bytes);
+    }
+
+    @VisibleForTesting
+    static String serializeStateHandle(StateHandleWithDeleteMarker<?> stateHandle)
+            throws IOException {
+        return toBase64(InstantiationUtil.serializeObject(stateHandle));
+    }
+
+    /**
+     * Wrapper around state object that allows us to implement idempotent {@link
+     * #releaseAndTryRemove(String)} and {@link #releaseAndTryRemoveAll()}.
+     *
+     * @param <T> Type of the state we're storing.
+     */
+    @VisibleForTesting
+    static class StateHandleWithDeleteMarker<T extends Serializable> implements StateObject {
+
+        private final RetrievableStateHandle<T> inner;
+        private final boolean markedForDeletion;
+
+        StateHandleWithDeleteMarker(RetrievableStateHandle<T> inner) {
+            this(inner, false);
+        }
+
+        private StateHandleWithDeleteMarker(
+                RetrievableStateHandle<T> inner, boolean markedForDeletion) {
+            this.inner = inner;
+            this.markedForDeletion = markedForDeletion;
+        }
+
+        @Override
+        public void discardState() throws Exception {
+            inner.discardState();
+        }
+
+        @Override
+        public long getStateSize() {
+            return inner.getStateSize();
+        }
+
+        RetrievableStateHandle<T> getInner() {
+            return inner;
+        }
+
+        boolean isMarkedForDeletion() {
+            return markedForDeletion;
+        }
+
+        StateHandleWithDeleteMarker<T> toDeleting() {
+            return new StateHandleWithDeleteMarker<>(inner, true);
+        }
+    }
+
     private final FlinkKubeClient kubeClient;
 
     private final String configMapName;
@@ -132,31 +207,21 @@ public class KubernetesStateHandleStore<T extends Serializable>
 
         final RetrievableStateHandle<T> storeHandle = storage.store(state);
 
-        final byte[] serializedStoreHandle = serializeOrDiscard(storeHandle);
+        final byte[] serializedStoreHandle =
+                serializeOrDiscard(new StateHandleWithDeleteMarker<>(storeHandle));
 
         // initialize flag to serve the failure case
         boolean discardState = true;
         try {
             // a successful operation will result in the state not being discarded
             discardState =
-                    !kubeClient
-                            .checkAndUpdateConfigMap(
-                                    configMapName,
-                                    c -> {
-                                        if (isValidOperation(c)) {
-                                            if (!c.getData().containsKey(key)) {
-                                                c.getData()
-                                                        .put(
-                                                                key,
-                                                                encodeStateHandle(
-                                                                        serializedStoreHandle));
-                                                return Optional.of(c);
-                                            } else {
-                                                throw new CompletionException(
-                                                        getKeyAlreadyExistException(key));
-                                            }
+                    !updateConfigMap(
+                                    cm -> {
+                                        try {
+                                            return addEntry(cm, key, serializedStoreHandle);
+                                        } catch (Exception e) {
+                                            throw new CompletionException(e);
                                         }
-                                        return Optional.empty();
                                     })
                             .get();
             return storeHandle;
@@ -179,10 +244,6 @@ public class KubernetesStateHandleStore<T extends Serializable>
         }
     }
 
-    private boolean isValidOperation(KubernetesConfigMap c) {
-        return lockIdentity == null || KubernetesLeaderElector.hasLeadership(c, lockIdentity);
-    }
-
     /**
      * Replaces a state handle in ConfigMap and discards the old state handle. Wo do not lock
      * resource version and then replace in Kubernetes. Since the ConfigMap is periodically updated
@@ -204,36 +265,31 @@ public class KubernetesStateHandleStore<T extends Serializable>
         checkNotNull(key, "Key in ConfigMap.");
         checkNotNull(state, "State.");
 
-        final RetrievableStateHandle<T> oldStateHandle = getAndLock(key);
-
         final RetrievableStateHandle<T> newStateHandle = storage.store(state);
 
-        final byte[] serializedStateHandle = serializeOrDiscard(newStateHandle);
+        final byte[] serializedStateHandle =
+                serializeOrDiscard(new StateHandleWithDeleteMarker<>(newStateHandle));
 
         // initialize flags to serve the failure case
         boolean discardOldState = false;
         boolean discardNewState = true;
+        // We don't want to greedily pull the old state handle as we have to do that anyway in
+        // replaceEntry method for check of delete markers.
+        final AtomicReference<RetrievableStateHandle<T>> oldStateHandleRef =
+                new AtomicReference<>();
         try {
-            boolean success =
-                    kubeClient
-                            .checkAndUpdateConfigMap(
-                                    configMapName,
-                                    c -> {
-                                        if (isValidOperation(c)) {
-                                            // Check the existence
-                                            if (c.getData().containsKey(key)) {
-                                                c.getData()
-                                                        .put(
-                                                                key,
-                                                                encodeStateHandle(
-                                                                        serializedStateHandle));
-                                            } else {
-                                                throw new CompletionException(
-                                                        getKeyNotExistException(key));
-                                            }
-                                            return Optional.of(c);
+            final boolean success =
+                    updateConfigMap(
+                                    cm -> {
+                                        try {
+                                            return replaceEntry(
+                                                    cm,
+                                                    key,
+                                                    serializedStateHandle,
+                                                    oldStateHandleRef);
+                                        } catch (NotExistException e) {
+                                            throw new CompletionException(e);
                                         }
-                                        return Optional.empty();
                                     })
                             .get();
 
@@ -257,7 +313,10 @@ public class KubernetesStateHandleStore<T extends Serializable>
             }
 
             if (discardOldState) {
-                oldStateHandle.discardState();
+                Objects.requireNonNull(
+                                oldStateHandleRef.get(),
+                                "state handle should have been set on success")
+                        .discardState();
             }
         }
     }
@@ -277,7 +336,19 @@ public class KubernetesStateHandleStore<T extends Serializable>
                 .getConfigMap(configMapName)
                 .map(
                         configMap -> {
-                            if (configMap.getData().containsKey(key)) {
+                            final String content = configMap.getData().get(key);
+                            if (content != null) {
+                                try {
+                                    final StateHandleWithDeleteMarker<T> stateHandle =
+                                            deserializeStateHandle(content);
+                                    if (stateHandle.isMarkedForDeletion()) {
+                                        return StringResourceVersion.notExisting();
+                                    }
+                                } catch (IOException e) {
+                                    // Any calls to add or replace will try to remove this resource,
+                                    // so we can simply treat it as non-existent.
+                                    return StringResourceVersion.notExisting();
+                                }
                                 return StringResourceVersion.valueOf(
                                         configMap.getResourceVersion());
                             }
@@ -303,7 +374,12 @@ public class KubernetesStateHandleStore<T extends Serializable>
         if (optional.isPresent()) {
             final KubernetesConfigMap configMap = optional.get();
             if (configMap.getData().containsKey(key)) {
-                return deserializeObject(configMap.getData().get(key));
+                final StateHandleWithDeleteMarker<T> result =
+                        deserializeStateHandle(configMap.getData().get(key));
+                if (result.isMarkedForDeletion()) {
+                    throw getKeyMarkedAsDeletedException(key);
+                }
+                return result.getInner();
             } else {
                 throw getKeyNotExistException(key);
             }
@@ -331,11 +407,15 @@ public class KubernetesStateHandleStore<T extends Serializable>
                                     .forEach(
                                             entry -> {
                                                 try {
-                                                    stateHandles.add(
-                                                            new Tuple2<>(
-                                                                    deserializeObject(
-                                                                            entry.getValue()),
-                                                                    entry.getKey()));
+                                                    final StateHandleWithDeleteMarker<T> result =
+                                                            deserializeStateHandle(
+                                                                    entry.getValue());
+                                                    if (!result.isMarkedForDeletion()) {
+                                                        stateHandles.add(
+                                                                new Tuple2<>(
+                                                                        result.getInner(),
+                                                                        entry.getKey()));
+                                                    }
                                                 } catch (IOException e) {
                                                     LOG.warn(
                                                             "ConfigMap {} contained corrupted data. Ignoring the key {}.",
@@ -363,6 +443,18 @@ public class KubernetesStateHandleStore<T extends Serializable>
                         configMap ->
                                 configMap.getData().keySet().stream()
                                         .filter(configMapKeyFilter)
+                                        .filter(
+                                                k -> {
+                                                    try {
+                                                        final String content =
+                                                                Objects.requireNonNull(
+                                                                        configMap.getData().get(k));
+                                                        return !deserializeStateHandle(content)
+                                                                .isMarkedForDeletion();
+                                                    } catch (IOException e) {
+                                                        return false;
+                                                    }
+                                                })
                                         .collect(Collectors.toList()))
                 .orElseThrow(this::getConfigMapNotExistException);
     }
@@ -379,39 +471,52 @@ public class KubernetesStateHandleStore<T extends Serializable>
     public boolean releaseAndTryRemove(String key) throws Exception {
         checkNotNull(key, "Key in ConfigMap.");
         final AtomicReference<RetrievableStateHandle<T>> stateHandleRefer = new AtomicReference<>();
-
-        return kubeClient
-                .checkAndUpdateConfigMap(
-                        configMapName,
+        return updateConfigMap(
                         configMap -> {
-                            if (isValidOperation(configMap)) {
-                                final String content = configMap.getData().remove(key);
-                                if (content != null) {
-                                    try {
-                                        stateHandleRefer.set(deserializeObject(content));
-                                    } catch (IOException e) {
-                                        LOG.warn(
-                                                "Could not retrieve the state handle of {} from ConfigMap {}.",
-                                                key,
-                                                configMapName,
-                                                e);
+                            final String content = configMap.getData().get(key);
+                            if (content != null) {
+                                try {
+                                    final StateHandleWithDeleteMarker<T> result =
+                                            deserializeStateHandle(content);
+                                    if (!result.isMarkedForDeletion()) {
+                                        // Mark the ConfigMap entry as deleting. This basically
+                                        // starts a "removal transaction" that allows us to retry
+                                        // the removal if needed.
+                                        configMap
+                                                .getData()
+                                                .put(
+                                                        key,
+                                                        serializeStateHandle(result.toDeleting()));
                                     }
+                                    stateHandleRefer.set(result.getInner());
+                                } catch (IOException e) {
+                                    logInvalidEntry(key, configMapName, e);
+                                    // Remove entry from the config map as we can't recover from
+                                    // this (the serialization would fail on the retry as well).
+                                    Objects.requireNonNull(configMap.getData().remove(key));
                                 }
                                 return Optional.of(configMap);
                             }
                             return Optional.empty();
                         })
-                .whenComplete(
-                        (succeed, ignore) -> {
-                            if (succeed) {
-                                if (stateHandleRefer.get() != null) {
-                                    try {
-                                        stateHandleRefer.get().discardState();
-                                    } catch (Exception e) {
-                                        throw new CompletionException(e);
-                                    }
+                .thenCompose(
+                        updated -> {
+                            if (updated && stateHandleRefer.get() != null) {
+                                try {
+                                    stateHandleRefer.get().discardState();
+                                    return updateConfigMap(
+                                            configMap -> {
+                                                // Now we can safely commit the "removal
+                                                // transaction" by removing the entry from the
+                                                // ConfigMap.
+                                                configMap.getData().remove(key);
+                                                return Optional.of(configMap);
+                                            });
+                                } catch (Exception e) {
+                                    throw new CompletionException(e);
                                 }
                             }
+                            return CompletableFuture.completedFuture(updated);
                         })
                 .get();
     }
@@ -423,40 +528,40 @@ public class KubernetesStateHandleStore<T extends Serializable>
      */
     @Override
     public void releaseAndTryRemoveAll() throws Exception {
-        final List<RetrievableStateHandle<T>> validStateHandles = new ArrayList<>();
-        kubeClient
-                .checkAndUpdateConfigMap(
-                        configMapName,
-                        c -> {
-                            if (isValidOperation(c)) {
-                                final Map<String, String> updateData = new HashMap<>(c.getData());
-                                c.getData().entrySet().stream()
-                                        .filter(entry -> configMapKeyFilter.test(entry.getKey()))
-                                        .forEach(
-                                                entry -> {
-                                                    try {
-                                                        validStateHandles.add(
-                                                                deserializeObject(
-                                                                        entry.getValue()));
-                                                        updateData.remove(entry.getKey());
-                                                    } catch (IOException e) {
-                                                        LOG.warn(
-                                                                "ConfigMap {} contained corrupted data. Ignoring the key {}.",
-                                                                configMapName,
-                                                                entry.getKey());
-                                                    }
-                                                });
-                                c.getData().clear();
-                                c.getData().putAll(updateData);
-                                return Optional.of(c);
+        final Map<String, RetrievableStateHandle<T>> validStateHandles = new HashMap<>();
+        updateConfigMap(
+                        configMap -> {
+                            final Map<String, String> updateData =
+                                    new HashMap<>(configMap.getData());
+                            for (String key : configMap.getData().keySet()) {
+                                if (configMapKeyFilter.test(key)) {
+                                    try {
+                                        final StateHandleWithDeleteMarker<T> result =
+                                                deserializeStateHandle(
+                                                        Objects.requireNonNull(
+                                                                configMap.getData().get(key)));
+                                        validStateHandles.put(key, result.getInner());
+                                        // Start the "removal transaction" by marking the entries in
+                                        // the ConfigMap as deleting.
+                                        updateData.put(
+                                                key, serializeStateHandle(result.toDeleting()));
+                                    } catch (IOException e) {
+                                        // Just log the invalid entry. It will be implicitly removed
+                                        // because it hasn't been added into the update map.
+                                        logInvalidEntry(key, configMapName, e);
+                                    }
+                                }
                             }
-                            return Optional.empty();
+                            configMap.getData().clear();
+                            configMap.getData().putAll(updateData);
+                            return Optional.of(configMap);
                         })
-                .whenComplete(
-                        (succeed, ignore) -> {
-                            if (succeed) {
+                .thenCompose(
+                        updated -> {
+                            if (updated && !validStateHandles.isEmpty()) {
                                 Exception exception = null;
-                                for (RetrievableStateHandle<T> stateHandle : validStateHandles) {
+                                for (RetrievableStateHandle<T> stateHandle :
+                                        validStateHandles.values()) {
                                     try {
                                         stateHandle.discardState();
                                     } catch (Exception e) {
@@ -469,7 +574,17 @@ public class KubernetesStateHandleStore<T extends Serializable>
                                                     "Could not properly remove all state handles.",
                                                     exception));
                                 }
+                                // Commit the "removal transaction" by removing the entries from the
+                                // ConfigMap.
+                                return updateConfigMap(
+                                        configMap -> {
+                                            for (String key : validStateHandles.keySet()) {
+                                                configMap.getData().remove(key);
+                                            }
+                                            return Optional.of(configMap);
+                                        });
                             }
+                            return CompletableFuture.completedFuture(updated);
                         })
                 .get();
     }
@@ -481,15 +596,10 @@ public class KubernetesStateHandleStore<T extends Serializable>
      */
     @Override
     public void clearEntries() throws Exception {
-        kubeClient
-                .checkAndUpdateConfigMap(
-                        configMapName,
-                        c -> {
-                            if (isValidOperation(c)) {
-                                c.getData().keySet().removeIf(configMapKeyFilter);
-                                return Optional.of(c);
-                            }
-                            return Optional.empty();
+        updateConfigMap(
+                        configMap -> {
+                            configMap.getData().keySet().removeIf(configMapKeyFilter);
+                            return Optional.of(configMap);
                         })
                 .get();
     }
@@ -509,17 +619,88 @@ public class KubernetesStateHandleStore<T extends Serializable>
         return this.getClass().getSimpleName() + "{configMapName='" + configMapName + "'}";
     }
 
-    private RetrievableStateHandle<T> deserializeObject(String content) throws IOException {
-        checkNotNull(content, "Content should not be null.");
+    private boolean isValidOperation(KubernetesConfigMap c) {
+        return lockIdentity == null || KubernetesLeaderElector.hasLeadership(c, lockIdentity);
+    }
 
-        final byte[] data = Base64.getDecoder().decode(content);
+    @VisibleForTesting
+    CompletableFuture<Boolean> updateConfigMap(
+            Function<KubernetesConfigMap, Optional<KubernetesConfigMap>> updateFn) {
+        return kubeClient.checkAndUpdateConfigMap(
+                configMapName,
+                configMap -> {
+                    if (isValidOperation(configMap)) {
+                        return updateFn.apply(configMap);
+                    }
+                    return Optional.empty();
+                });
+    }
 
-        try {
-            return deserialize(data);
-        } catch (IOException | ClassNotFoundException e) {
-            throw new IOException(
-                    "Failed to deserialize state handle from ConfigMap data " + content + '.', e);
+    /**
+     * Adds entry into the ConfigMap. If the entry already exists and contains delete marker, we try
+     * to finish the removal before the actual update.
+     */
+    private Optional<KubernetesConfigMap> addEntry(
+            KubernetesConfigMap configMap, String key, byte[] serializedStateHandle)
+            throws Exception {
+        final String content = configMap.getData().get(key);
+        if (content != null) {
+            try {
+                final StateHandleWithDeleteMarker<T> stateHandle = deserializeStateHandle(content);
+                if (stateHandle.isMarkedForDeletion()) {
+                    // This might be a left-over after the fail-over. As the remove operation is
+                    // idempotent let's try to finish it.
+                    if (!releaseAndTryRemove(key)) {
+                        throw new IllegalStateException(
+                                "Unable to remove the marked as deleting entry.");
+                    }
+                } else {
+                    throw getKeyAlreadyExistException(key);
+                }
+            } catch (IOException e) {
+                // Just log the invalid entry, it will be overridden
+                // by the update code path below.
+                logInvalidEntry(key, configMapName, e);
+            }
         }
+        configMap.getData().put(key, toBase64(serializedStateHandle));
+        return Optional.of(configMap);
+    }
+
+    /**
+     * Replace the entry in the ConfigMap. If the entry already exists and contains delete marker,
+     * we treat it as non-existent and perform the best effort removal.
+     */
+    private Optional<KubernetesConfigMap> replaceEntry(
+            KubernetesConfigMap configMap,
+            String key,
+            byte[] serializedStateHandle,
+            AtomicReference<RetrievableStateHandle<T>> oldStateHandleRef)
+            throws NotExistException {
+        final String content = configMap.getData().get(key);
+        if (content != null) {
+            try {
+                final StateHandleWithDeleteMarker<T> stateHandle = deserializeStateHandle(content);
+                oldStateHandleRef.set(stateHandle.getInner());
+                if (stateHandle.isMarkedForDeletion()) {
+                    final NotExistException exception = getKeyNotExistException(key);
+                    try {
+                        // Try to finish the removal. We don't really care whether this succeeds or
+                        // not, from the "replace" point of view, the entry doesn't exist.
+                        releaseAndTryRemove(key);
+                    } catch (Exception e) {
+                        exception.addSuppressed(e);
+                    }
+                    throw exception;
+                }
+            } catch (IOException e) {
+                // Just log the invalid entry, it will be removed by the update code path below.
+                logInvalidEntry(key, configMapName, e);
+            }
+            configMap.getData().put(key, toBase64(serializedStateHandle));
+            return Optional.of(configMap);
+        }
+        throw getKeyNotExistException(key);
     }
 
     private KubernetesException getConfigMapNotExistException() {
@@ -534,11 +715,20 @@ public class KubernetesStateHandleStore<T extends Serializable>
         return new NotExistException("Could not find " + key + " in ConfigMap " + configMapName);
     }
 
+    private NotExistException getKeyMarkedAsDeletedException(String key) {
+        return new NotExistException(
+                "Already marked for deletion " + key + " in ConfigMap " + configMapName);
+    }
+
     private AlreadyExistException getKeyAlreadyExistException(String key) {
         return new AlreadyExistException(key + " already exists in ConfigMap " + configMapName);
     }
 
-    private String encodeStateHandle(byte[] serializedStoreHandle) {
-        return Base64.getEncoder().encodeToString(serializedStoreHandle);
+    private static void logInvalidEntry(String key, String configMapName, Throwable e) {
+        LOG.warn(
+                "Could not retrieve the state handle of '{}' from ConfigMap '{}'. Removing the entry as we don't have any way to recover.",
+                key,
+                configMapName,
+                e);
     }
 }
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
index d8c6e97d860..9896d49512d 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
@@ -20,12 +20,15 @@ package org.apache.flink.kubernetes.highavailability;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.core.testutils.FlinkMatchers;
+import org.apache.flink.kubernetes.highavailability.KubernetesStateHandleStore.StateHandleWithDeleteMarker;
 import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.resources.KubernetesConfigMap;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesLeaderElector;
 import org.apache.flink.runtime.persistence.PossibleInconsistentStateException;
 import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.persistence.StringResourceVersion;
 import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper;
+import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.concurrent.FutureUtils;
 import org.apache.flink.util.function.FunctionUtils;
@@ -33,6 +36,8 @@ import org.apache.flink.util.function.FunctionUtils;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
@@ -43,23 +48,26 @@ import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
+import static org.hamcrest.Matchers.notNullValue;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 
 /** Tests for {@link KubernetesStateHandleStore} operations. */
 public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTestBase {
 
     private static final String PREFIX = "test-prefix-";
+
     private final String key = PREFIX + JobID.generate();
     private final Predicate<String> filter = k -> k.startsWith(PREFIX);
-    private final TestingLongStateHandleHelper.LongStateHandle state =
-            new TestingLongStateHandleHelper.LongStateHandle(12345L);
-
     private final TestingLongStateHandleHelper longStateStorage =
             new TestingLongStateHandleHelper();
 
+    private TestingLongStateHandleHelper.LongStateHandle state;
+
     @Before
     public void setup() {
         super.setup();
+        state = new TestingLongStateHandleHelper.LongStateHandle(12345L);
         TestingLongStateHandleHelper.clearGlobalState();
     }
 
@@ -89,14 +97,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
     }
 
     @Test
-    public void testAddAlreadyExistingKey() throws Exception {
+    public void testAddAndLockWithExistingKey() throws Exception {
         new Context() {
             {
                 runTest(
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            getLeaderConfigMap().getData().put(key, "existing data");
+                            final TestingLongStateHandleHelper.LongStateHandle oldState =
+                                    addRegularEntry(getLeaderConfigMap(), key, 1337L);
 
                             final KubernetesStateHandleStore<
                                             TestingLongStateHandleHelper.LongStateHandle>
@@ -108,8 +117,11 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                                                     filter,
                                                     LOCK_IDENTITY);
 
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(12345L);
+
                             try {
-                                store.addAndLock(key, state);
+                                store.addAndLock(key, newState);
                                 fail("Exception should be thrown.");
                             } catch (StateHandleStore.AlreadyExistException ex) {
                                 final String msg =
@@ -118,11 +130,54 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                                                 key, LEADER_CONFIGMAP_NAME);
                                 assertThat(ex, FlinkMatchers.containsMessage(msg));
                             }
-                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(1));
-                            assertThat(
-                                    TestingLongStateHandleHelper
-                                            .getDiscardCallCountForStateHandleByIndex(0),
-                                    is(1));
+
+                            // Both initial & new handles should be in the storage (we never clean
+                            // it for testing).
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
+                            // Only the new one (second entry in the store) should have been
+                            // discarded.
+                            assertThat(oldState.isDiscarded(), is(false));
+                            assertThat(newState.isDiscarded(), is(true));
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testAddAndLockWithDeletingEntry() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final TestingLongStateHandleHelper.LongStateHandle oldState =
+                                    addDeletingEntry(getLeaderConfigMap(), key, 1337L);
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(3L);
+                            store.addAndLock(
+                                    key, new TestingLongStateHandleHelper.LongStateHandle(3L));
+
+                            assertThat(store.getAndLock(key).retrieveState().getValue(), is(3L));
+
+                            // Both initial & new handles should be in the storage (we never clean
+                            // it for testing).
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
+                            // Only the old one (first entry in the store) should have been
+                            // discarded.
+                            assertThat(oldState.getNumberOfSuccessfulDiscardCalls(), is(1));
+                            assertThat(newState.getNumberOfSuccessfulDiscardCalls(), is(0));
                         });
             }
         };
@@ -272,6 +327,101 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
         };
     }
 
+    @Test
+    public void testReplaceWithDeletingKey() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final TestingLongStateHandleHelper.LongStateHandle oldState =
+                                    addDeletingEntry(getLeaderConfigMap(), key, 1337);
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(23456L);
+
+                            assertThat(store.exists(key), is(StringResourceVersion.notExisting()));
+                            assertThrows(
+                                    StateHandleStore.NotExistException.class,
+                                    () ->
+                                            store.replace(
+                                                    key,
+                                                    StringResourceVersion.notExisting(),
+                                                    newState));
+
+                            // Both handles should have been stored and discarded.
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
+                            assertThat(oldState.isDiscarded(), is(true));
+                            assertThat(newState.isDiscarded(), is(true));
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testReplaceWithDeletingKeyWithFailingDiscard() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final Exception discardException = new Exception("Unable to discard.");
+                            final TestingLongStateHandleHelper.LongStateHandle oldState =
+                                    addDeletingEntry(
+                                            getLeaderConfigMap(),
+                                            key,
+                                            new TestingLongStateHandleHelper.LongStateHandle(
+                                                    1337,
+                                                    discardIdx -> {
+                                                        throw discardException;
+                                                    }));
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(23456L);
+
+                            assertThat(store.exists(key), is(StringResourceVersion.notExisting()));
+                            final StateHandleStore.NotExistException exception =
+                                    assertThrows(
+                                            StateHandleStore.NotExistException.class,
+                                            () ->
+                                                    store.replace(
+                                                            key,
+                                                            StringResourceVersion.notExisting(),
+                                                            newState));
+                            assertThat(exception.getSuppressed().length, is(1));
+                            assertThat(
+                                    exception.getSuppressed()[0],
+                                    FlinkMatchers.containsCause(discardException));
+
+                            // Only the new handle should have been discarded.
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
+                            assertThat(oldState.isDiscarded(), is(false));
+                            assertThat(newState.isDiscarded(), is(true));
+                        });
+            }
+        };
+    }
+
     @Test
     public void testReplaceWithNoLeadershipAndDiscardState() throws Exception {
         new Context() {
@@ -482,6 +632,36 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
         };
     }
 
+    @Test
+    public void testExistsWithDeletingEntry() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final TestingLongStateHandleHelper.LongStateHandle state =
+                                    addDeletingEntry(getLeaderConfigMap(), key, 1337L);
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+
+                            final StringResourceVersion resourceVersion = store.exists(key);
+                            assertThat(resourceVersion.isExisting(), is(false));
+                            // We don't try to pro-actively remove the entry here.
+                            assertThat(state.isDiscarded(), is(false));
+                        });
+            }
+        };
+    }
+
     @Test
     public void testGetNonExistingKey() throws Exception {
         new Context() {
@@ -725,4 +905,191 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
             }
         };
     }
+
+    @Test
+    public void testReleaseAndTryRemoveIsIdempotent() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+
+                            final RuntimeException discardException =
+                                    new RuntimeException("Test exception.");
+                            store.addAndLock(
+                                    key,
+                                    new TestingLongStateHandleHelper.LongStateHandle(
+                                            2L,
+                                            discardIdx -> {
+                                                if (discardIdx == 0) {
+                                                    throw discardException;
+                                                }
+                                            }));
+
+                            assertThat(store.getAllAndLock().size(), is(1));
+                            assertThat(
+                                    store.getAndLock(key),
+                                    is(notNullValue(RetrievableStateHandle.class)));
+
+                            // First remove attempt should fail when we're discarding the underlying
+                            // state.
+                            final Exception exception =
+                                    assertThrows(
+                                            Exception.class, () -> store.releaseAndTryRemove(key));
+                            assertThat(exception, FlinkMatchers.containsCause(discardException));
+
+                            // Now we should see that the node is "soft-deleted". This means it can
+                            // no longer be accessed by the get methods, but the underlying state
+                            // still exists.
+                            assertThat(store.getAllAndLock().size(), is(0));
+                            assertThrows(Exception.class, () -> store.getAndLock(key));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(0));
+                            assertThat(getLeaderConfigMap().getData().containsKey(key), is(true));
+
+                            // Second retry should succeed and remove the underlying state and the
+                            // reference in config map.
+                            assertThat(store.releaseAndTryRemove(key), is(true));
+                            assertThat(store.getAllAndLock().size(), is(0));
+                            assertThrows(Exception.class, () -> store.getAndLock(key));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(1));
+                            assertThat(getLeaderConfigMap().getData().containsKey(key), is(false));
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testReleaseAndTryRemoveAllIsIdempotent() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderCallbackGrantLeadership();
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+                            final int numKeys = 10;
+
+                            final RuntimeException discardException =
+                                    new RuntimeException("Test exception.");
+                            final List<TestingLongStateHandleHelper.LongStateHandle> states =
+                                    new ArrayList<>();
+                            for (int idx = 0; idx < numKeys; idx++) {
+                                final boolean failFirstDiscard = idx % 2 == 0;
+                                final TestingLongStateHandleHelper.LongStateHandle state =
+                                        new TestingLongStateHandleHelper.LongStateHandle(
+                                                idx + 1,
+                                                discardIdx -> {
+                                                    if (failFirstDiscard && discardIdx == 0) {
+                                                        throw discardException;
+                                                    }
+                                                });
+                                states.add(state);
+                                store.addAndLock(key + "_" + idx, state);
+                            }
+
+                            // All keys should be retrievable
+                            assertThat(store.getAllAndLock().size(), is(numKeys));
+                            for (int idx = 0; idx < numKeys; idx++) {
+                                assertThat(
+                                        store.getAndLock(key + "_" + idx),
+                                        is(notNullValue(RetrievableStateHandle.class)));
+                            }
+
+                            // First remove attempt should fail when we're discarding the underlying
+                            // state.
+                            final Exception exception =
+                                    assertThrows(Exception.class, store::releaseAndTryRemoveAll);
+                            assertThat(exception, FlinkMatchers.containsCause(discardException));
+
+                            // Now we should see that the all nodes are "soft-deleted". This means
+                            // it can no longer be accessed by the get methods, but the underlying
+                            // state still exists.
+                            assertThat(store.getAllAndLock().size(), is(0));
+                            for (int idx = 0; idx < numKeys; idx++) {
+                                final String indexKey = key + "_" + idx;
+                                assertThrows(Exception.class, () -> store.getAndLock(indexKey));
+                                assertThat(
+                                        getLeaderConfigMap().getData().containsKey(indexKey),
+                                        is(true));
+                            }
+                            // Half of the state handles should have been discarded.
+                            assertThat(
+                                    states.stream()
+                                            .filter(
+                                                    TestingLongStateHandleHelper.LongStateHandle
+                                                            ::isDiscarded)
+                                            .count(),
+                                    is((long) numKeys / 2));
+
+                            // Second retry should succeed and remove the underlying state and the
+                            // reference in config map.
+                            store.releaseAndTryRemoveAll();
+                            assertThat(store.getAllAndLock().size(), is(0));
+                            for (int idx = 0; idx < numKeys; idx++) {
+                                final String indexKey = key + "_" + idx;
+                                assertThrows(Exception.class, () -> store.getAndLock(indexKey));
+                                assertThat(
+                                        getLeaderConfigMap().getData().containsKey(indexKey),
+                                        is(false));
+                            }
+                            // All handles should have been discarded.
+                            assertThat(
+                                    states.stream()
+                                            .filter(
+                                                    TestingLongStateHandleHelper.LongStateHandle
+                                                            ::isDiscarded)
+                                            .count(),
+                                    is((long) numKeys));
+                        });
+            }
+        };
+    }
+
+    private TestingLongStateHandleHelper.LongStateHandle addRegularEntry(
+            KubernetesConfigMap configMap, String key, long value) throws IOException {
+        final TestingLongStateHandleHelper.LongStateHandle state =
+                new TestingLongStateHandleHelper.LongStateHandle(value);
+        final String deleting =
+                KubernetesStateHandleStore.serializeStateHandle(
+                        new StateHandleWithDeleteMarker<>(longStateStorage.store(state)));
+        configMap.getData().put(key, deleting);
+        return state;
+    }
+
+    private TestingLongStateHandleHelper.LongStateHandle addDeletingEntry(
+            KubernetesConfigMap configMap, String key, long value) throws IOException {
+        return addDeletingEntry(
+                configMap, key, new TestingLongStateHandleHelper.LongStateHandle(value));
+    }
+
+    private TestingLongStateHandleHelper.LongStateHandle addDeletingEntry(
+            KubernetesConfigMap configMap,
+            String key,
+            TestingLongStateHandleHelper.LongStateHandle state)
+            throws IOException {
+        final String deleting =
+                KubernetesStateHandleStore.serializeStateHandle(
+                        new StateHandleWithDeleteMarker<>(longStateStorage.store(state))
+                                .toDeleting());
+        configMap.getData().put(key, deleting);
+        return state;
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java b/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java
index 4569162a9b7..11592af7765 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java
@@ -53,7 +53,7 @@ public class TestingLongStateHandleHelper
     }
 
     public static int getDiscardCallCountForStateHandleByIndex(int index) {
-        return STATE_STORAGE.get(index).getNumberOfDiscardCalls();
+        return STATE_STORAGE.get(index).getNumberOfSuccessfulDiscardCalls();
     }
 
     public static int getGlobalStorageSize() {
@@ -65,7 +65,9 @@ public class TestingLongStateHandleHelper
     }
 
     public static int getGlobalDiscardCount() {
-        return STATE_STORAGE.stream().mapToInt(LongStateHandle::getNumberOfDiscardCalls).sum();
+        return STATE_STORAGE.stream()
+                .mapToInt(LongStateHandle::getNumberOfSuccessfulDiscardCalls)
+                .sum();
     }
 
     /**
@@ -74,7 +76,8 @@ public class TestingLongStateHandleHelper
      */
     @FunctionalInterface
     public interface PreDiscardCallback extends Serializable {
-        void run(Long value);
+
+        void run(int discardIdx) throws Exception;
     }
 
     /**
@@ -90,9 +93,14 @@ public class TestingLongStateHandleHelper
         private final PreDiscardCallback preDiscardCallback;
 
         private int numberOfDiscardCalls = 0;
+        private int numberOfSuccessfulDiscardCalls = 0;
 
         public LongStateHandle(long value) {
-            this(value, ignored -> {});
+            this(
+                    value,
+                    ignored -> {
+                        // No-op.
+                    });
         }
 
         public LongStateHandle(long value, PreDiscardCallback preDiscardCallback) {
@@ -106,17 +114,26 @@ public class TestingLongStateHandleHelper
 
         @Override
         public void discardState() {
-            preDiscardCallback.run(value);
-
-            numberOfDiscardCalls++;
+            try {
+                preDiscardCallback.run(numberOfDiscardCalls);
+                numberOfSuccessfulDiscardCalls++;
+            } catch (Exception e) {
+                throw new IllegalStateException("Unable to discard.", e);
+            } finally {
+                numberOfDiscardCalls++;
+            }
         }
 
         public int getNumberOfDiscardCalls() {
             return numberOfDiscardCalls;
         }
 
+        public int getNumberOfSuccessfulDiscardCalls() {
+            return numberOfSuccessfulDiscardCalls;
+        }
+
         public boolean isDiscarded() {
-            return numberOfDiscardCalls > 0;
+            return numberOfSuccessfulDiscardCalls > 0;
         }
 
         @Override
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
index d3a23cc3208..dc81131fdf6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
@@ -45,8 +45,6 @@ import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.annotation.Nullable;
-
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
@@ -55,7 +53,6 @@ import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicReference;
 
 import static org.apache.flink.runtime.util.ZooKeeperUtils.generateZookeeperPath;
 import static org.hamcrest.Matchers.empty;
@@ -983,15 +980,18 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
                 "One discardState call should have failed resulting in one node being left, still.",
                 1,
                 ZOOKEEPER.getClient().getChildren().forPath("/").size());
-        assertEquals(0, failingStateHandle.getNumberOfDiscardCalls());
-        assertEquals(1, succeedingStateHandle.getNumberOfDiscardCalls());
+        assertEquals(0, failingStateHandle.getNumberOfSuccessfulDiscardCalls());
+        assertEquals(1, failingStateHandle.getNumberOfDiscardCalls());
+        assertEquals(1, succeedingStateHandle.getNumberOfSuccessfulDiscardCalls());
 
         store.releaseAndTryRemoveAll();
 
         assertTrue(
                 "The second removal attempt should have succeeded with no nodes left.",
                 ZOOKEEPER.getClient().getChildren().forPath("/").isEmpty());
-        assertEquals(1, failingStateHandle.getNumberOfDiscardCalls());
+        assertEquals(1, failingStateHandle.getNumberOfSuccessfulDiscardCalls());
+        assertEquals(2, failingStateHandle.getNumberOfDiscardCalls());
+        assertEquals(1, succeedingStateHandle.getNumberOfSuccessfulDiscardCalls());
         assertEquals(1, succeedingStateHandle.getNumberOfDiscardCalls());
     }
 
@@ -1309,12 +1309,10 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     }
 
     private static TestingLongStateHandleHelper.PreDiscardCallback throwExceptionOnce(
-            @Nullable RuntimeException e) {
-        final AtomicReference<RuntimeException> ref = new AtomicReference<>(e);
-        return ignoredValue -> {
-            final RuntimeException actualException = ref.getAndSet(null);
-            if (actualException != null) {
-                throw actualException;
+            RuntimeException e) {
+        return discardIdx -> {
+            if (discardIdx == 0) {
+                throw e;
             }
         };
     }
