diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
index 94936cdfa13..f555249b726 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
@@ -248,6 +248,9 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
 	protected static class StrictOrderVerifyingSink extends VerifyingSinkBase<StrictOrderVerifyingSink.State> {
 		private Random random = new Random();
 		protected boolean backpressure;
+		private boolean firstOutOfOrder = true;
+		private boolean firstDuplicate = true;
+		private boolean firstLostValue = true;
 
 		protected StrictOrderVerifyingSink(long minCheckpoints) {
 			super(minCheckpoints);
@@ -277,23 +280,39 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
 			long lastRecord = state.lastRecordInPartitions[partition];
 			if (value < lastRecord) {
 				state.numOutOfOrderness++;
-				LOG.debug(
-					"Out of order records current={} and last={} @ {} subtask ({} attempt)",
-					value,
-					lastRecord,
-					getRuntimeContext().getIndexOfThisSubtask(),
-					getRuntimeContext().getAttemptNumber());
+				if (firstOutOfOrder) {
+					LOG.info(
+						"Out of order records current={} and last={} @ {} subtask ({} attempt)",
+						value,
+						lastRecord,
+						getRuntimeContext().getIndexOfThisSubtask(),
+						getRuntimeContext().getAttemptNumber());
+					firstOutOfOrder = false;
+				}
 			} else if (value == lastRecord) {
 				state.numDuplicates++;
-				LOG.debug(
-					"Duplicate record {} @ {} subtask ({} attempt)",
-					value,
-					getRuntimeContext().getIndexOfThisSubtask(),
-					getRuntimeContext().getAttemptNumber());
+				if (firstDuplicate) {
+					LOG.info(
+						"Duplicate record {} @ {} subtask ({} attempt)",
+						value,
+						getRuntimeContext().getIndexOfThisSubtask(),
+						getRuntimeContext().getAttemptNumber());
+					firstDuplicate = false;
+				}
 			} else if (lastRecord != -1) {
 				long expectedValue = lastRecord + parallelism * parallelism;
 				if (value != expectedValue) {
 					state.numLostValues++;
+					if (firstLostValue) {
+						LOG.info(
+							"Lost records current={}, expected={}, and last={} @ {} subtask ({} attempt)",
+							value,
+							expectedValue,
+							lastRecord,
+							getRuntimeContext().getIndexOfThisSubtask(),
+							getRuntimeContext().getAttemptNumber());
+						firstLostValue = false;
+					}
 				}
 			}
 			state.lastRecordInPartitions[partition] = value;
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
index ed4aea570ce..9c39b87ece2 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
@@ -218,12 +218,13 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 				if (split == null) {
 					return Collections.emptyList();
 				}
-				LOG.info("Snapshotted next input {} @ {} subtask (? attempt)", split.nextNumber, split.nextNumber % split.increment);
+				LOG.info("Snapshotted {} @ {} subtask (? attempt)", split, split.nextNumber % split.increment);
 				return singletonList(split);
 			}
 
 			@Override
 			public void notifyCheckpointComplete(long checkpointId) {
+				LOG.info("notifyCheckpointComplete {} @ {} subtask (? attempt)", split.numCompletedCheckpoints, split.nextNumber % split.increment);
 				if (split != null) {
 					split.numCompletedCheckpoints++;
 				}
@@ -236,7 +237,11 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 
 			@Override
 			public void addSplits(List<LongSplit> splits) {
+				if (split != null) {
+					throw new IllegalStateException("Tried to add " + splits + " but already got " + split);
+				}
 				split = Iterables.getOnlyElement(splits);
+				LOG.info("Added split {} @ {} subtask (? attempt)", split, split.nextNumber % split.increment);
 			}
 
 			@Override
@@ -270,6 +275,15 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 			public String splitId() {
 				return String.valueOf(increment);
 			}
+
+			@Override
+			public String toString() {
+				return "LongSplit{" +
+					"increment=" + increment +
+					", nextNumber=" + nextNumber +
+					", numCompletedCheckpoints=" + numCompletedCheckpoints +
+					'}';
+			}
 		}
 
 		private static class LongSplitSplitEnumerator implements SplitEnumerator<LongSplit, List<LongSplit>> {
@@ -295,6 +309,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 
 			@Override
 			public void addSplitsBack(List<LongSplit> splits, int subtaskId) {
+				LOG.info("addSplitsBack {}", splits);
 				unassignedSplits.addAll(splits);
 			}
 
@@ -308,6 +323,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 							.computeIfAbsent(i % numReaders, t -> new ArrayList<>())
 							.add(unassignedSplits.get(i));
 					}
+					LOG.info("Assigning splits {}", assignment);
 					context.assignSplits(new SplitsAssignment<>(assignment));
 					unassignedSplits.clear();
 				}
@@ -315,6 +331,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 
 			@Override
 			public List<LongSplit> snapshotState() throws Exception {
+				LOG.info("snapshotState {}", unassignedSplits);
 				return unassignedSplits;
 			}
 
@@ -625,7 +642,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 			final State state = createState();
 			stateList = context.getOperatorStateStore().getListState(new ListStateDescriptor<>("state", (Class<State>) state.getClass()));
 			this.state = getOnlyElement(stateList.get(), state);
-			LOG.info("Init state {} @ {} subtask ({} attempt)", state, getRuntimeContext().getIndexOfThisSubtask(), getRuntimeContext().getAttemptNumber());
+			LOG.info("Init state {} @ {} subtask ({} attempt)", this.state, getRuntimeContext().getIndexOfThisSubtask(), getRuntimeContext().getAttemptNumber());
 		}
 
 		protected abstract State createState();
