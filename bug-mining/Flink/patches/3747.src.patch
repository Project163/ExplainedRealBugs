diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/TypeInferenceUtil.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/TypeInferenceUtil.java
index 43aaa7f2a98..0638b357df7 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/TypeInferenceUtil.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/TypeInferenceUtil.java
@@ -99,6 +99,14 @@ public final class TypeInferenceUtil {
 			TypeInference typeInference,
 			CallContext callContext,
 			@Nullable DataType outputType) {
+		return adaptArguments(typeInference, callContext, outputType, false);
+	}
+
+	private static AdaptedCallContext adaptArguments(
+			TypeInference typeInference,
+			CallContext callContext,
+			@Nullable DataType outputType,
+			boolean allowUnknownInputTypes) {
 		final List<DataType> actualTypes = callContext.getArgumentDataTypes();
 
 		typeInference.getTypedArguments()
@@ -115,7 +123,8 @@ public final class TypeInferenceUtil {
 		final AdaptedCallContext adaptedCallContext = inferInputTypes(
 			typeInference,
 			callContext,
-			outputType);
+			outputType,
+			allowUnknownInputTypes);
 
 		// final check if the call is valid after casting
 		final List<DataType> expectedTypes = adaptedCallContext.getArgumentDataTypes();
@@ -262,7 +271,10 @@ public final class TypeInferenceUtil {
 				name,
 				functionDefinition,
 				argumentCount);
-			final AdaptedCallContext adaptedContext = adaptArguments(typeInference, callContext, null);
+
+			// We might not be able to infer the input types at this moment, if the surrounding function
+			// does not provide an explicit input type strategy. Skip the check for unknown types in input types.
+			final AdaptedCallContext adaptedContext = adaptArguments(typeInference, callContext, null, true);
 			return typeInference.getInputTypeStrategy()
 				.inferInputTypes(adaptedContext, false)
 				.map(dataTypes -> dataTypes.get(innerCallPosition));
@@ -436,7 +448,8 @@ public final class TypeInferenceUtil {
 	private static AdaptedCallContext inferInputTypes(
 			TypeInference typeInference,
 			CallContext callContext,
-			@Nullable DataType outputType) {
+			@Nullable DataType outputType,
+			boolean allowUnknownInputTypes) {
 
 		final AdaptedCallContext adaptedCallContext = new AdaptedCallContext(callContext, outputType);
 
@@ -447,8 +460,8 @@ public final class TypeInferenceUtil {
 			.inferInputTypes(adaptedCallContext, true)
 			.orElseThrow(() -> new ValidationException("Invalid input arguments."));
 
-		// input must not contain unknown types at this point
-		if (inferredDataTypes.stream().anyMatch(TypeInferenceUtil::isUnknown)) {
+		if (!allowUnknownInputTypes && inferredDataTypes.stream().anyMatch(TypeInferenceUtil::isUnknown)) {
+			// input must not contain unknown types at this point
 			throw new ValidationException("Invalid use of untyped NULL in arguments.");
 		}
 
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTest.java
index 5126f3ee4ab..74b4ea4fccb 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/inference/InputTypeStrategiesTest.java
@@ -352,6 +352,14 @@ public class InputTypeStrategiesTest {
 				.expectSignature("f([<OUTPUT> | INT])")
 				.expectArgumentTypes(DataTypes.BOOLEAN()),
 
+			// surrounding info can not infer input type and does not help inferring a type
+			TestSpec
+				.forStrategy(explicitSequence(DataTypes.BOOLEAN()))
+				.surroundingStrategy(WILDCARD)
+				.calledWithArgumentTypes(DataTypes.NULL())
+				.expectSignature("f(BOOLEAN)")
+				.expectArgumentTypes(DataTypes.BOOLEAN()),
+
 			// surrounding function does not help inferring a type
 			TestSpec
 				.forStrategy(sequence(or(OUTPUT_IF_NULL, explicit(DataTypes.INT()))))
