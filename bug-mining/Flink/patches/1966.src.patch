diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/blob/BlobCache.java b/flink-runtime/src/main/java/org/apache/flink/runtime/blob/BlobCache.java
index c50a8887f85..ccbbdf092d9 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/blob/BlobCache.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/blob/BlobCache.java
@@ -81,7 +81,8 @@ public class BlobCache extends TimerTask implements BlobService {
 	/**
 	 * Job reference counters with a time-to-live (TTL).
 	 */
-	private static class RefCount {
+	@VisibleForTesting
+	static class RefCount {
 		/**
 		 * Number of references to a job.
 		 */
@@ -166,6 +167,9 @@ public class BlobCache extends TimerTask implements BlobService {
 			if (ref == null) {
 				ref = new RefCount();
 				jobRefCounters.put(jobId, ref);
+			} else {
+				// reset cleanup timeout
+				ref.keepUntil = -1;
 			}
 			++ref.references;
 		}
@@ -184,7 +188,7 @@ public class BlobCache extends TimerTask implements BlobService {
 			RefCount ref = jobRefCounters.get(jobId);
 
 			if (ref == null) {
-				LOG.warn("improper use of releaseJob() without a matching number of registerJob() calls");
+				LOG.warn("improper use of releaseJob() without a matching number of registerJob() calls for jobId " + jobId);
 				return;
 			}
 
@@ -484,6 +488,16 @@ public class BlobCache extends TimerTask implements BlobService {
 		return new BlobClient(serverAddress, blobClientConfig);
 	}
 
+	/**
+	 * Returns the job reference counters - for testing purposes only!
+	 *
+	 * @return job reference counters (internal state!)
+	 */
+	@VisibleForTesting
+	Map<JobID, RefCount> getJobRefCounters() {
+		return jobRefCounters;
+	}
+
 	/**
 	 * Returns a file handle to the file associated with the given blob key on the blob
 	 * server.
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/blob/BlobCacheCleanupTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/blob/BlobCacheCleanupTest.java
index afd365b6fc8..7eef0a46d86 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/blob/BlobCacheCleanupTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/blob/BlobCacheCleanupTest.java
@@ -20,7 +20,6 @@ package org.apache.flink.runtime.blob;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.configuration.BlobServerOptions;
-import org.apache.flink.configuration.ConfigConstants;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.util.TestLogger;
 
@@ -37,7 +36,9 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 
+import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThat;
 
 /**
  * A few tests for the deferred ref-counting based cleanup inside the {@link BlobCache}.
@@ -141,6 +142,63 @@ public class BlobCacheCleanupTest extends TestLogger {
 		}
 	}
 
+	/**
+	 * Tests that {@link BlobCache} sets the expected reference counts and cleanup timeouts when
+	 * registering, releasing, and re-registering jobs.
+	 */
+	@Test
+	public void testJobReferences() throws IOException, InterruptedException {
+
+		JobID jobId = new JobID();
+
+		Configuration config = new Configuration();
+		config.setString(BlobServerOptions.STORAGE_DIRECTORY,
+			temporaryFolder.newFolder().getAbsolutePath());
+		config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 3_600_000L); // 1 hour should effectively prevent races
+
+		// NOTE: use fake address - we will not connect to it here
+		InetSocketAddress serverAddress = new InetSocketAddress("localhost", 12345);
+
+		try (BlobCache cache = new BlobCache(serverAddress, config, new VoidBlobStore())) {
+
+			// register once
+			cache.registerJob(jobId);
+			assertEquals(1, cache.getJobRefCounters().get(jobId).references);
+			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil);
+
+			// register a second time
+			cache.registerJob(jobId);
+			assertEquals(2, cache.getJobRefCounters().get(jobId).references);
+			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil);
+
+			// release once
+			cache.releaseJob(jobId);
+			assertEquals(1, cache.getJobRefCounters().get(jobId).references);
+			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil);
+
+			// release a second time
+			long cleanupLowerBound =
+				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL);
+			cache.releaseJob(jobId);
+			assertEquals(0, cache.getJobRefCounters().get(jobId).references);
+			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,
+				greaterThanOrEqualTo(cleanupLowerBound));
+
+			// register again
+			cache.registerJob(jobId);
+			assertEquals(1, cache.getJobRefCounters().get(jobId).references);
+			assertEquals(-1, cache.getJobRefCounters().get(jobId).keepUntil);
+
+			// finally release the job
+			cleanupLowerBound =
+				System.currentTimeMillis() + config.getLong(BlobServerOptions.CLEANUP_INTERVAL);
+			cache.releaseJob(jobId);
+			assertEquals(0, cache.getJobRefCounters().get(jobId).references);
+			assertThat(cache.getJobRefCounters().get(jobId).keepUntil,
+				greaterThanOrEqualTo(cleanupLowerBound));
+		}
+	}
+
 	/**
 	 * Tests that {@link BlobCache} cleans up after calling {@link BlobCache#releaseJob(JobID)}
 	 * but only after preserving the file for a bit longer.
