diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java
index 91e6bd3d714..f54b273faaf 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java
@@ -170,7 +170,6 @@ public class SourceOperator<OUT, SplitT extends SourceSplit> extends AbstractStr
     private int numSplits;
     private final Map<String, Long> splitCurrentWatermarks = new HashMap<>();
     private final Set<String> currentlyPausedSplits = new HashSet<>();
-    private boolean isEmitNextLoopDisabled = false;
 
     private enum OperatingMode {
         READING,
@@ -412,9 +411,6 @@ public class SourceOperator<OUT, SplitT extends SourceSplit> extends AbstractStr
         if (operatingMode != OperatingMode.READING) {
             return emitNextNotReading(output);
         }
-        if (isEmitNextLoopDisabled) {
-            return convertToInternalStatus(sourceReader.pollNext(currentMainOutput));
-        }
 
         InputStatus status;
         do {
@@ -572,11 +568,6 @@ public class SourceOperator<OUT, SplitT extends SourceSplit> extends AbstractStr
         }
     }
 
-    // Configure SourceOperator#emitNext to emit at most one record to the given DataOutput.
-    public void disableEmitNextLoop() {
-        isEmitNextLoopDisabled = true;
-    }
-
     private void handleAddSplitsEvent(AddSplitEvent<SplitT> event) {
         try {
             List<SplitT> newSplits = event.splits(splitSerializer);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java
index 55863fee47e..54988606b15 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskSourceInput.java
@@ -157,9 +157,4 @@ public class StreamTaskSourceInput<T> implements StreamTaskInput<T>, Checkpointa
     public SourceOperator<T, ?> getOperator() {
         return operator;
     }
-
-    // Configure StreamTaskSourceInput#emitNext to emit at most one record to the given DataOutput.
-    public void disableEmitNextLoop() {
-        operator.disableEmitNextLoop();
-    }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java
index 6f1ed44e8a8..b86c0b9d847 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTask.java
@@ -82,14 +82,6 @@ public class MultipleInputStreamTask<OUT>
         StreamConfig configuration = getConfiguration();
         ClassLoader userClassLoader = getUserCodeClassLoader();
 
-        // This is needed for StreamMultipleInputProcessor#processInput to preserve the existing
-        // behavior of choosing an input every time a record is emitted. This behavior is good for
-        // fairness between input consumption. But it can reduce throughput due to added control
-        // flow cost on the per-record code path.
-        for (StreamTaskSourceInput<?> input : operatorChain.getSourceTaskInputs()) {
-            input.disableEmitNextLoop();
-        }
-
         InputConfig[] inputs = configuration.getInputs(userClassLoader);
 
         WatermarkGauge[] watermarkGauges = new WatermarkGauge[inputs.length];
@@ -213,6 +205,15 @@ public class MultipleInputStreamTask<OUT>
         }
     }
 
+    // This is needed for StreamMultipleInputProcessor#processInput to preserve the existing
+    // behavior of choosing an input every time a record is emitted. This behavior is good for
+    // fairness between input consumption. But it can reduce throughput due to added control
+    // flow cost on the per-record code path.
+    @Override
+    public CanEmitBatchOfRecordsChecker getCanEmitBatchOfRecords() {
+        return () -> false;
+    }
+
     private boolean isSynchronous(SnapshotType snapshotType) {
         return snapshotType.isSavepoint() && ((SavepointType) snapshotType).isSynchronous();
     }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
index e62ed44a99c..4658c454b12 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
@@ -21,7 +21,6 @@ import org.apache.flink.annotation.Internal;
 import org.apache.flink.runtime.execution.Environment;
 import org.apache.flink.runtime.io.network.partition.consumer.IndexedInputGate;
 import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
-import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;
 import org.apache.flink.streaming.runtime.io.StreamTwoInputProcessorFactory;
 import org.apache.flink.streaming.runtime.io.checkpointing.CheckpointBarrierHandler;
 import org.apache.flink.streaming.runtime.io.checkpointing.CheckpointedInputGate;
@@ -62,14 +61,6 @@ public class TwoInputStreamTask<IN1, IN2, OUT> extends AbstractTwoInputStreamTas
             List<IndexedInputGate> inputGates2,
             Function<Integer, StreamPartitioner<?>> gatePartitioners) {
 
-        // This is needed for StreamMultipleInputProcessor#processInput to preserve the existing
-        // behavior of choosing an input every time a record is emitted. This behavior is good for
-        // fairness between input consumption. But it can reduce throughput due to added control
-        // flow cost on the per-record code path.
-        for (StreamTaskSourceInput<?> input : operatorChain.getSourceTaskInputs()) {
-            input.disableEmitNextLoop();
-        }
-
         // create an input instance for each input
         checkpointBarrierHandler =
                 InputProcessorUtil.createCheckpointBarrierHandler(
@@ -113,4 +104,13 @@ public class TwoInputStreamTask<IN1, IN2, OUT> extends AbstractTwoInputStreamTas
                         gatePartitioners,
                         getEnvironment().getTaskInfo());
     }
+
+    // This is needed for StreamMultipleInputProcessor#processInput to preserve the existing
+    // behavior of choosing an input every time a record is emitted. This behavior is good for
+    // fairness between input consumption. But it can reduce throughput due to added control
+    // flow cost on the per-record code path.
+    @Override
+    public CanEmitBatchOfRecordsChecker getCanEmitBatchOfRecords() {
+        return () -> false;
+    }
 }
