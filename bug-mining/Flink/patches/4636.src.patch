diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoint.java
new file mode 100644
index 00000000000..24348e168b1
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoint.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.checkpoint;
+
+/**
+ * A checkpoint, pending or completed.
+ */
+public interface Checkpoint {
+	long getCheckpointID();
+
+	void discard() throws Exception;
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
index afc1a6e3784..3ee25d5f3fb 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
@@ -575,7 +575,7 @@ public class CheckpointCoordinator {
 									onTriggerFailure(checkpoint, throwable);
 								}
 							} else {
-								if (checkpoint.isDiscarded()) {
+								if (checkpoint.isDisposed()) {
 									onTriggerFailure(
 										checkpoint,
 										new CheckpointException(
@@ -731,7 +731,7 @@ public class CheckpointCoordinator {
 								if (masterStateCompletableFuture.isDone()) {
 									return;
 								}
-								if (checkpoint.isDiscarded()) {
+								if (checkpoint.isDisposed()) {
 									throw new IllegalStateException(
 										"Checkpoint " + checkpointID + " has been discarded");
 								}
@@ -829,7 +829,7 @@ public class CheckpointCoordinator {
 		try {
 			coordinatorsToCheckpoint.forEach(OperatorCoordinatorCheckpointContext::abortCurrentTriggering);
 
-			if (checkpoint != null && !checkpoint.isDiscarded()) {
+			if (checkpoint != null && !checkpoint.isDisposed()) {
 				int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet();
 				LOG.warn(
 					"Failed to trigger checkpoint {} for job {}. ({} consecutive failed attempts so far)",
@@ -922,7 +922,7 @@ public class CheckpointCoordinator {
 
 			if (checkpoint != null) {
 				Preconditions.checkState(
-					!checkpoint.isDiscarded(),
+					!checkpoint.isDisposed(),
 					"Received message for discarded but non-removed checkpoint " + checkpointId);
 				LOG.info("Decline checkpoint {} by task {} of job {} at {}.",
 					checkpointId,
@@ -989,7 +989,7 @@ public class CheckpointCoordinator {
 
 			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId);
 
-			if (checkpoint != null && !checkpoint.isDiscarded()) {
+			if (checkpoint != null && !checkpoint.isDisposed()) {
 
 				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {
 					case SUCCESS:
@@ -1075,7 +1075,7 @@ public class CheckpointCoordinator {
 			}
 			catch (Exception e1) {
 				// abort the current pending checkpoint if we fails to finalize the pending checkpoint.
-				if (!pendingCheckpoint.isDiscarded()) {
+				if (!pendingCheckpoint.isDisposed()) {
 					abortPendingCheckpoint(
 						pendingCheckpoint,
 						new CheckpointException(
@@ -1087,7 +1087,7 @@ public class CheckpointCoordinator {
 			}
 
 			// the pending checkpoint must be discarded after the finalization
-			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null);
+			Preconditions.checkState(pendingCheckpoint.isDisposed() && completedCheckpoint != null);
 
 			try {
 				completedCheckpointStore.addCheckpoint(completedCheckpoint, checkpointsCleaner, this::scheduleTriggerRequest);
@@ -1670,7 +1670,7 @@ public class CheckpointCoordinator {
 
 		assert(Thread.holdsLock(lock));
 
-		if (!pendingCheckpoint.isDiscarded()) {
+		if (!pendingCheckpoint.isDisposed()) {
 			try {
 				// release resource here
 				pendingCheckpoint.abort(
@@ -1793,7 +1793,7 @@ public class CheckpointCoordinator {
 			synchronized (lock) {
 				// only do the work if the checkpoint is not discarded anyways
 				// note that checkpoint completion discards the pending checkpoint object
-				if (!pendingCheckpoint.isDiscarded()) {
+				if (!pendingCheckpoint.isDisposed()) {
 					LOG.info("Checkpoint {} of job {} expired before completing.",
 						pendingCheckpoint.getCheckpointId(), job);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
index bc6ee9d463b..deac65d4e45 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
@@ -42,11 +42,17 @@ public class CheckpointsCleaner implements Serializable {
 		return numberOfCheckpointsToClean.get();
 	}
 
-	public void cleanCheckpoint(Runnable cleanAction, Runnable postCleanAction, Executor executor) {
+	public void cleanCheckpoint(Checkpoint checkpoint, boolean shouldDiscard, Runnable postCleanAction, Executor executor) {
 		numberOfCheckpointsToClean.incrementAndGet();
 		executor.execute(() -> {
 			try {
-				cleanAction.run();
+				if (shouldDiscard) {
+					try {
+						checkpoint.discard();
+					} catch (Exception e) {
+						LOG.warn("Could not discard completed checkpoint {}.", checkpoint.getCheckpointID(), e);
+					}
+				}
 			} finally {
 				numberOfCheckpointsToClean.decrementAndGet();
 				postCleanAction.run();
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
index 503b1a4820d..88d3e05eee4 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
@@ -66,7 +66,7 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
  * or the metadata file. For a state backend that stores metadata in database tables, the pointer
  * could be the table name and row key. The pointer is encoded as a String.
  */
-public class CompletedCheckpoint implements Serializable {
+public class CompletedCheckpoint implements Serializable, Checkpoint {
 
 	private static final Logger LOG = LoggerFactory.getLogger(CompletedCheckpoint.class);
 
@@ -150,6 +150,7 @@ public class CompletedCheckpoint implements Serializable {
 		return job;
 	}
 
+	@Override
 	public long getCheckpointID() {
 		return checkpointID;
 	}
@@ -235,6 +236,7 @@ public class CompletedCheckpoint implements Serializable {
 		}
 	}
 
+	@Override
 	public void discard() throws Exception {
 		LOG.trace("Executing discard procedure for {}.", this);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorCoordinatorCheckpoints.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorCoordinatorCheckpoints.java
index 8de997a7e4e..135faeaa481 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorCoordinatorCheckpoints.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorCoordinatorCheckpoints.java
@@ -108,7 +108,7 @@ final class OperatorCoordinatorCheckpoints {
 
 			if (result != PendingCheckpoint.TaskAcknowledgeResult.SUCCESS) {
 				final String errorMessage = "Coordinator state not acknowledged successfully: " + result;
-				final Throwable error = checkpoint.isDiscarded() ? checkpoint.getFailureCause() : null;
+				final Throwable error = checkpoint.isDisposed() ? checkpoint.getFailureCause() : null;
 
 				if (error != null) {
 					throw new CheckpointException(errorMessage, CheckpointFailureReason.TRIGGER_CHECKPOINT_FAILURE, error);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
index 0142d70ba29..52c0203d76c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
@@ -31,6 +31,7 @@ import org.apache.flink.runtime.state.CompletedCheckpointStorageLocation;
 import org.apache.flink.runtime.state.StateUtil;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.Preconditions;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -62,7 +63,7 @@ import static org.apache.flink.util.Preconditions.checkState;
  * <p>Note that the pending checkpoint, as well as the successful checkpoint keep the
  * state handles always as serialized values, never as actual values.
  */
-public class PendingCheckpoint {
+public class PendingCheckpoint implements Checkpoint {
 
 	/**
 	 * Result of the {@link PendingCheckpoint#acknowledgedTasks} method.
@@ -111,6 +112,8 @@ public class PendingCheckpoint {
 
 	private int numAcknowledgedTasks;
 
+	private boolean disposed;
+
 	private boolean discarded;
 
 	/** Optional stats tracker callback. */
@@ -164,7 +167,16 @@ public class PendingCheckpoint {
 		return jobId;
 	}
 
+	/**
+	 * @deprecated use {@link #getCheckpointID()}
+	 */
+	@Deprecated
 	public long getCheckpointId() {
+		return getCheckpointID();
+	}
+
+	@Override
+	public long getCheckpointID() {
 		return checkpointId;
 	}
 
@@ -203,23 +215,23 @@ public class PendingCheckpoint {
 	}
 
 	boolean areMasterStatesFullyAcknowledged() {
-		return notYetAcknowledgedMasterStates.isEmpty() && !discarded;
+		return notYetAcknowledgedMasterStates.isEmpty() && !disposed;
 	}
 
 	boolean areCoordinatorsFullyAcknowledged() {
-		return notYetAcknowledgedOperatorCoordinators.isEmpty() && !discarded;
+		return notYetAcknowledgedOperatorCoordinators.isEmpty() && !disposed;
 	}
 
 	boolean areTasksFullyAcknowledged() {
-		return notYetAcknowledgedTasks.isEmpty() && !discarded;
+		return notYetAcknowledgedTasks.isEmpty() && !disposed;
 	}
 
 	public boolean isAcknowledgedBy(ExecutionAttemptID executionAttemptId) {
 		return !notYetAcknowledgedTasks.containsKey(executionAttemptId);
 	}
 
-	public boolean isDiscarded() {
-		return discarded;
+	public boolean isDisposed() {
+		return disposed;
 	}
 
 	/**
@@ -255,7 +267,7 @@ public class PendingCheckpoint {
 	public boolean setCancellerHandle(ScheduledFuture<?> cancellerHandle) {
 		synchronized (lock) {
 			if (this.cancellerHandle == null) {
-				if (!discarded) {
+				if (!disposed) {
 					this.cancellerHandle = cancellerHandle;
 					return true;
 				} else {
@@ -288,7 +300,7 @@ public class PendingCheckpoint {
 	public CompletedCheckpoint finalizeCheckpoint(CheckpointsCleaner checkpointsCleaner, Runnable postCleanup, Executor executor) throws IOException {
 
 		synchronized (lock) {
-			checkState(!isDiscarded(), "checkpoint is discarded");
+			checkState(!isDisposed(), "checkpoint is discarded");
 			checkState(isFullyAcknowledged(), "Pending checkpoint has not been fully acknowledged yet");
 
 			// make sure we fulfill the promise with an exception if something fails
@@ -351,7 +363,7 @@ public class PendingCheckpoint {
 			CheckpointMetrics metrics) {
 
 		synchronized (lock) {
-			if (discarded) {
+			if (disposed) {
 				return TaskAcknowledgeResult.DISCARDED;
 			}
 
@@ -432,7 +444,7 @@ public class PendingCheckpoint {
 			@Nullable ByteStreamStateHandle stateHandle) {
 
 		synchronized (lock) {
-			if (discarded) {
+			if (disposed) {
 				return TaskAcknowledgeResult.DISCARDED;
 			}
 
@@ -469,7 +481,7 @@ public class PendingCheckpoint {
 	public void acknowledgeMasterState(String identifier, @Nullable MasterState state) {
 
 		synchronized (lock) {
-			if (!discarded) {
+			if (!disposed) {
 				if (notYetAcknowledgedMasterStates.remove(identifier) && state != null) {
 					masterStates.add(state);
 				}
@@ -507,25 +519,9 @@ public class PendingCheckpoint {
 		synchronized (lock) {
 			try {
 				numAcknowledgedTasks = -1;
-				if (!discarded && releaseState) {
-					Runnable cleanAction = () -> {
-						// discard the private states.
-						// unregistered shared states are still considered private at this point.
-						try {
-							StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values());
-							targetLocation.disposeOnFailure();
-						} catch (Throwable t) {
-							LOG.warn(
-								"Could not properly dispose the private states in the pending checkpoint {} of job {}.",
-								checkpointId, jobId, t);
-						} finally {
-							operatorStates.clear();
-						}
-					};
-					checkpointsCleaner.cleanCheckpoint(cleanAction, postCleanup, executor);
-				}
+				checkpointsCleaner.cleanCheckpoint(this, releaseState, postCleanup, executor);
 			} finally {
-				discarded = true;
+				disposed = true;
 				notYetAcknowledgedTasks.clear();
 				acknowledgedTasks.clear();
 				cancelCanceller();
@@ -533,6 +529,33 @@ public class PendingCheckpoint {
 		}
 	}
 
+	/**
+	 * Discard state. Must be called after {@link #dispose(boolean, CheckpointsCleaner, Runnable, Executor) dispose}.
+	 */
+	@Override
+	public void discard() {
+		synchronized (lock) {
+			if (discarded) {
+				Preconditions.checkState(disposed, "Checkpoint should be disposed before being discarded");
+				return;
+			} else {
+				discarded = true;
+			}
+		}
+		// discard the private states.
+		// unregistered shared states are still considered private at this point.
+		try {
+			StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values());
+			targetLocation.disposeOnFailure();
+		} catch (Throwable t) {
+			LOG.warn(
+				"Could not properly dispose the private states in the pending checkpoint {} of job {}.",
+				checkpointId, jobId, t);
+		} finally {
+			operatorStates.clear();
+		}
+	}
+
 	private void cancelCanceller() {
 		try {
 			final ScheduledFuture<?> canceller = this.cancellerHandle;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
index 8797362abdc..ac76d705db4 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
@@ -232,15 +232,7 @@ public class ZooKeeperCompletedCheckpointStore implements CompletedCheckpointSto
 			Runnable postCleanup) {
 		try {
 			if (tryRemove(completedCheckpoint.getCheckpointID())) {
-				checkpointsCleaner.cleanCheckpoint(() -> {
-					if (shouldDiscard) {
-						try {
-							completedCheckpoint.discard();
-						} catch (Exception e) {
-							LOG.warn("Could not discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), e);
-						}
-					}
-				}, postCleanup, executor);
+				checkpointsCleaner.cleanCheckpoint(completedCheckpoint, shouldDiscard, postCleanup, executor);
 			}
 		} catch (Exception e) {
 			LOG.warn("Failed to subsume the old checkpoint", e);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java
index 323f6a2726d..450b3913055 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorFailureTest.java
@@ -86,7 +86,7 @@ public class CheckpointCoordinatorFailureTest extends TestLogger {
 
 		PendingCheckpoint pendingCheckpoint = coord.getPendingCheckpoints().values().iterator().next();
 
-		assertFalse(pendingCheckpoint.isDiscarded());
+		assertFalse(pendingCheckpoint.isDisposed());
 
 		final long checkpointId = coord.getPendingCheckpoints().keySet().iterator().next();
 
@@ -121,7 +121,7 @@ public class CheckpointCoordinatorFailureTest extends TestLogger {
 		}
 
 		// make sure that the pending checkpoint has been discarded after we could not complete it
-		assertTrue(pendingCheckpoint.isDiscarded());
+		assertTrue(pendingCheckpoint.isDisposed());
 
 		// make sure that the subtask state has been discarded after we could not complete it.
 		verify(operatorSubtaskState).discardState();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
index 5e5b457cec1..bf999d34797 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
@@ -283,7 +283,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
 			// acknowledge from one of the tasks
 			checkpointCoordinator.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId, attemptID2, checkpointId), TASK_MANAGER_LOCATION_INFO);
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 
 			// decline checkpoint from the other task
@@ -375,7 +375,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			assertEquals(2, checkpoint.getNumberOfNonAcknowledgedTasks());
 			assertEquals(0, checkpoint.getNumberOfAcknowledgedTasks());
 			assertEquals(0, checkpoint.getOperatorStates().size());
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 
 			// check that the vertices received the trigger checkpoint message
@@ -386,18 +386,18 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			checkpointCoordinator.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId, attemptID2, checkpointId), "Unknown location");
 			assertEquals(1, checkpoint.getNumberOfAcknowledgedTasks());
 			assertEquals(1, checkpoint.getNumberOfNonAcknowledgedTasks());
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 
 			// acknowledge the same task again (should not matter)
 			checkpointCoordinator.receiveAcknowledgeMessage(new AcknowledgeCheckpoint(jobId, attemptID2, checkpointId), "Unknown location");
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 
 			// decline checkpoint from the other task, this should cancel the checkpoint
 			// and trigger a new one
 			checkpointCoordinator.receiveDeclineMessage(new DeclineCheckpoint(jobId, attemptID1, checkpointId), TASK_MANAGER_LOCATION_INFO);
-			assertTrue(checkpoint.isDiscarded());
+			assertTrue(checkpoint.isDisposed());
 
 			// the canceler is also removed
 			assertEquals(0, manuallyTriggeredScheduledExecutor.getScheduledTasks().size());
@@ -410,7 +410,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			// decline from the other task, nothing should happen
 			checkpointCoordinator.receiveDeclineMessage(new DeclineCheckpoint(jobId, attemptID1, checkpointId), TASK_MANAGER_LOCATION_INFO);
 			checkpointCoordinator.receiveDeclineMessage(new DeclineCheckpoint(jobId, attemptID2, checkpointId), TASK_MANAGER_LOCATION_INFO);
-			assertTrue(checkpoint.isDiscarded());
+			assertTrue(checkpoint.isDisposed());
 
 			checkpointCoordinator.shutdown(JobStatus.FINISHED);
 		}
@@ -469,7 +469,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			assertEquals(2, checkpoint1.getNumberOfNonAcknowledgedTasks());
 			assertEquals(0, checkpoint1.getNumberOfAcknowledgedTasks());
 			assertEquals(0, checkpoint1.getOperatorStates().size());
-			assertFalse(checkpoint1.isDiscarded());
+			assertFalse(checkpoint1.isDisposed());
 			assertFalse(checkpoint1.areTasksFullyAcknowledged());
 
 			assertNotNull(checkpoint2);
@@ -478,7 +478,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			assertEquals(2, checkpoint2.getNumberOfNonAcknowledgedTasks());
 			assertEquals(0, checkpoint2.getNumberOfAcknowledgedTasks());
 			assertEquals(0, checkpoint2.getOperatorStates().size());
-			assertFalse(checkpoint2.isDiscarded());
+			assertFalse(checkpoint2.isDisposed());
 			assertFalse(checkpoint2.areTasksFullyAcknowledged());
 
 			// check that the vertices received the trigger checkpoint message
@@ -498,7 +498,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			verify(vertex1.getCurrentExecutionAttempt(), times(1)).notifyCheckpointAborted(eq(checkpoint1Id), any(Long.class));
 			verify(vertex2.getCurrentExecutionAttempt(), times(1)).notifyCheckpointAborted(eq(checkpoint1Id), any(Long.class));
 
-			assertTrue(checkpoint1.isDiscarded());
+			assertTrue(checkpoint1.isDisposed());
 
 			// validate that we have only one pending checkpoint left
 			assertEquals(1, checkpointCoordinator.getNumberOfPendingCheckpoints());
@@ -516,7 +516,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			assertEquals(2, checkpointNew.getNumberOfNonAcknowledgedTasks());
 			assertEquals(0, checkpointNew.getNumberOfAcknowledgedTasks());
 			assertEquals(0, checkpointNew.getOperatorStates().size());
-			assertFalse(checkpointNew.isDiscarded());
+			assertFalse(checkpointNew.isDisposed());
 			assertFalse(checkpointNew.areTasksFullyAcknowledged());
 			assertNotEquals(checkpoint1.getCheckpointId(), checkpointNew.getCheckpointId());
 
@@ -524,7 +524,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			// decline from the other task, nothing should happen
 			checkpointCoordinator.receiveDeclineMessage(new DeclineCheckpoint(jobId, attemptID1, checkpoint1Id), TASK_MANAGER_LOCATION_INFO);
 			checkpointCoordinator.receiveDeclineMessage(new DeclineCheckpoint(jobId, attemptID2, checkpoint1Id), TASK_MANAGER_LOCATION_INFO);
-			assertTrue(checkpoint1.isDiscarded());
+			assertTrue(checkpoint1.isDisposed());
 
 			// will not notify abort message again
 			verify(vertex1.getCurrentExecutionAttempt(), times(1)).notifyCheckpointAborted(eq(checkpoint1Id), any(Long.class));
@@ -575,7 +575,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			assertEquals(2, checkpoint.getNumberOfNonAcknowledgedTasks());
 			assertEquals(0, checkpoint.getNumberOfAcknowledgedTasks());
 			assertEquals(0, checkpoint.getOperatorStates().size());
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 
 			// check that the vertices received the trigger checkpoint message
@@ -598,13 +598,13 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			checkpointCoordinator.receiveAcknowledgeMessage(acknowledgeCheckpoint1, TASK_MANAGER_LOCATION_INFO);
 			assertEquals(1, checkpoint.getNumberOfAcknowledgedTasks());
 			assertEquals(1, checkpoint.getNumberOfNonAcknowledgedTasks());
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 			verify(taskOperatorSubtaskStates2, never()).registerSharedStates(any(SharedStateRegistry.class));
 
 			// acknowledge the same task again (should not matter)
 			checkpointCoordinator.receiveAcknowledgeMessage(acknowledgeCheckpoint1, TASK_MANAGER_LOCATION_INFO);
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 			assertFalse(checkpoint.areTasksFullyAcknowledged());
 			verify(subtaskState2, never()).registerSharedStates(any(SharedStateRegistry.class));
 
@@ -613,7 +613,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
 			// the checkpoint is internally converted to a successful checkpoint and the
 			// pending checkpoint object is disposed
-			assertTrue(checkpoint.isDiscarded());
+			assertTrue(checkpoint.isDisposed());
 
 			// the now we should have a completed checkpoint
 			assertEquals(1, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
@@ -765,7 +765,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			// now, the first checkpoint should be confirmed
 			assertEquals(1, checkpointCoordinator.getNumberOfPendingCheckpoints());
 			assertEquals(1, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
-			assertTrue(pending1.isDiscarded());
+			assertTrue(pending1.isDisposed());
 
 			// the first confirm message should be out
 			verify(commitVertex.getCurrentExecutionAttempt(), times(1)).notifyCheckpointComplete(eq(checkpointId1), any(Long.class));
@@ -776,7 +776,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			// now, the second checkpoint should be confirmed
 			assertEquals(0, checkpointCoordinator.getNumberOfPendingCheckpoints());
 			assertEquals(2, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
-			assertTrue(pending2.isDiscarded());
+			assertTrue(pending2.isDisposed());
 
 			// the second commit message should be out
 			verify(commitVertex.getCurrentExecutionAttempt(), times(1)).notifyCheckpointComplete(eq(checkpointId2), any(Long.class));
@@ -923,8 +923,8 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			// now, the second checkpoint should be confirmed, and the first discarded
 			// actually both pending checkpoints are discarded, and the second has been transformed
 			// into a successful checkpoint
-			assertTrue(pending1.isDiscarded());
-			assertTrue(pending2.isDiscarded());
+			assertTrue(pending1.isDisposed());
+			assertTrue(pending2.isDisposed());
 
 			assertEquals(0, checkpointCoordinator.getNumberOfPendingCheckpoints());
 			assertEquals(1, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
@@ -1005,7 +1005,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 			assertEquals(1, checkpointCoordinator.getNumberOfPendingCheckpoints());
 
 			PendingCheckpoint checkpoint = checkpointCoordinator.getPendingCheckpoints().values().iterator().next();
-			assertFalse(checkpoint.isDiscarded());
+			assertFalse(checkpoint.isDisposed());
 
 			OperatorID opID1 = OperatorID.fromJobVertexID(ackVertex1.getJobvertexId());
 
@@ -1017,7 +1017,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
 			// triggers cancelling
 			manuallyTriggeredScheduledExecutor.triggerScheduledTasks();
-			assertTrue("Checkpoint was not canceled by the timeout", checkpoint.isDiscarded());
+			assertTrue("Checkpoint was not canceled by the timeout", checkpoint.isDisposed());
 			assertEquals(0, checkpointCoordinator.getNumberOfPendingCheckpoints());
 			assertEquals(0, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
 
@@ -1173,7 +1173,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		reset(subtaskStateTrigger);
 		checkpointCoordinator.receiveDeclineMessage(new DeclineCheckpoint(jobId, ackAttemptId1, checkpointId), TASK_MANAGER_LOCATION_INFO);
 
-		assertTrue(pendingCheckpoint.isDiscarded());
+		assertTrue(pendingCheckpoint.isDisposed());
 
 		// check that we've cleaned up the already acknowledged state
 		verify(subtaskStateTrigger, times(1)).discardState();
@@ -1251,7 +1251,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		assertEquals(2, pending.getNumberOfNonAcknowledgedTasks());
 		assertEquals(0, pending.getNumberOfAcknowledgedTasks());
 		assertEquals(0, pending.getOperatorStates().size());
-		assertFalse(pending.isDiscarded());
+		assertFalse(pending.isDisposed());
 		assertFalse(pending.areTasksFullyAcknowledged());
 		assertFalse(pending.canBeSubsumed());
 
@@ -1269,13 +1269,13 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		checkpointCoordinator.receiveAcknowledgeMessage(acknowledgeCheckpoint2, TASK_MANAGER_LOCATION_INFO);
 		assertEquals(1, pending.getNumberOfAcknowledgedTasks());
 		assertEquals(1, pending.getNumberOfNonAcknowledgedTasks());
-		assertFalse(pending.isDiscarded());
+		assertFalse(pending.isDisposed());
 		assertFalse(pending.areTasksFullyAcknowledged());
 		assertFalse(savepointFuture.isDone());
 
 		// acknowledge the same task again (should not matter)
 		checkpointCoordinator.receiveAcknowledgeMessage(acknowledgeCheckpoint2, TASK_MANAGER_LOCATION_INFO);
-		assertFalse(pending.isDiscarded());
+		assertFalse(pending.isDisposed());
 		assertFalse(pending.areTasksFullyAcknowledged());
 		assertFalse(savepointFuture.isDone());
 
@@ -1284,7 +1284,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
 		// the checkpoint is internally converted to a successful checkpoint and the
 		// pending checkpoint object is disposed
-		assertTrue(pending.isDiscarded());
+		assertTrue(pending.isDisposed());
 		assertNotNull(savepointFuture.get());
 
 		// the now we should have a completed checkpoint
@@ -1400,7 +1400,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		assertEquals(1, checkpointCoordinator.getNumberOfPendingCheckpoints());
 		assertEquals(1, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
 
-		assertFalse(checkpointCoordinator.getPendingCheckpoints().get(savepointId1).isDiscarded());
+		assertFalse(checkpointCoordinator.getPendingCheckpoints().get(savepointId1).isDisposed());
 		assertFalse(savepointFuture1.isDone());
 
 		CompletableFuture<CompletedCheckpoint> checkpointFuture3 = checkpointCoordinator.triggerCheckpoint(false);
@@ -1420,7 +1420,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
 		assertEquals(1, checkpointCoordinator.getNumberOfPendingCheckpoints());
 		assertEquals(2, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
-		assertFalse(checkpointCoordinator.getPendingCheckpoints().get(savepointId1).isDiscarded());
+		assertFalse(checkpointCoordinator.getPendingCheckpoints().get(savepointId1).isDisposed());
 
 		assertFalse(savepointFuture1.isDone());
 		assertNotNull(savepointFuture2.get());
@@ -2208,7 +2208,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
 		manuallyTriggeredScheduledExecutor.triggerAll();
 		final PendingCheckpoint syncSavepoint = declineSynchronousSavepoint(jobId, coordinator, attemptID1, expectedRootCause);
 
-		assertTrue(syncSavepoint.isDiscarded());
+		assertTrue(syncSavepoint.isDisposed());
 
 		try {
 			savepointFuture.get();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
index 59ac7c419fe..3f21ed38c4e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
@@ -351,7 +351,7 @@ public class PendingCheckpointTest {
 
 		PendingCheckpoint aborted = createPendingCheckpoint(props);
 		aborted.abort(CheckpointFailureReason.CHECKPOINT_DECLINED, null, new CheckpointsCleaner(), () -> {}, Executors.directExecutor());
-		assertTrue(aborted.isDiscarded());
+		assertTrue(aborted.isDisposed());
 		assertFalse(aborted.setCancellerHandle(mock(ScheduledFuture.class)));
 
 		PendingCheckpoint pending = createPendingCheckpoint(props);
