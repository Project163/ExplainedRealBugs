diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriver.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriver.java
index c9e866137a2..fb3516a30ac 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriver.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriver.java
@@ -22,6 +22,7 @@ import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
 import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
 import org.apache.flink.kubernetes.kubeclient.KubernetesSharedWatcher.Watch;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesConfigMap;
+import org.apache.flink.runtime.leaderelection.LeaderInformation;
 import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalDriver;
 import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalEventHandler;
 import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalException;
@@ -32,9 +33,9 @@ import org.slf4j.LoggerFactory;
 
 import java.util.List;
 import java.util.concurrent.Executor;
+import java.util.function.Function;
 
 import static org.apache.flink.kubernetes.utils.KubernetesUtils.checkConfigMaps;
-import static org.apache.flink.kubernetes.utils.KubernetesUtils.getLeaderInformationFromConfigMap;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /**
@@ -60,18 +61,22 @@ public class KubernetesLeaderRetrievalDriver implements LeaderRetrievalDriver {
 
     private final Watch kubernetesWatch;
 
+    private final Function<KubernetesConfigMap, LeaderInformation> leaderInformationExtractor;
+
     public KubernetesLeaderRetrievalDriver(
             FlinkKubeClient kubeClient,
             KubernetesConfigMapSharedWatcher configMapSharedWatcher,
             Executor watchExecutor,
             String configMapName,
             LeaderRetrievalEventHandler leaderRetrievalEventHandler,
+            Function<KubernetesConfigMap, LeaderInformation> leaderInformationExtractor,
             FatalErrorHandler fatalErrorHandler) {
         this.kubeClient = checkNotNull(kubeClient, "Kubernetes client");
         this.configMapName = checkNotNull(configMapName, "ConfigMap name");
         this.leaderRetrievalEventHandler =
                 checkNotNull(leaderRetrievalEventHandler, "LeaderRetrievalEventHandler");
         this.fatalErrorHandler = checkNotNull(fatalErrorHandler);
+        this.leaderInformationExtractor = leaderInformationExtractor;
 
         kubernetesWatch =
                 checkNotNull(configMapSharedWatcher, "ConfigMap Shared Informer")
@@ -106,7 +111,7 @@ public class KubernetesLeaderRetrievalDriver implements LeaderRetrievalDriver {
         public void onModified(List<KubernetesConfigMap> configMaps) {
             final KubernetesConfigMap configMap = checkConfigMaps(configMaps, configMapName);
             leaderRetrievalEventHandler.notifyLeaderAddress(
-                    getLeaderInformationFromConfigMap(configMap));
+                    leaderInformationExtractor.apply(configMap));
         }
 
         @Override
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriverFactory.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriverFactory.java
index afdc434a27a..6efc7345b91 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriverFactory.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderRetrievalDriverFactory.java
@@ -20,6 +20,7 @@ package org.apache.flink.kubernetes.highavailability;
 
 import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
 import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
+import org.apache.flink.kubernetes.utils.KubernetesUtils;
 import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalDriverFactory;
 import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalEventHandler;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
@@ -56,6 +57,7 @@ public class KubernetesLeaderRetrievalDriverFactory implements LeaderRetrievalDr
                 watchExecutor,
                 configMapName,
                 leaderEventHandler,
+                KubernetesUtils::getLeaderInformationFromConfigMap,
                 fatalErrorHandler);
     }
 }
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriver.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriver.java
new file mode 100644
index 00000000000..d667282c03f
--- /dev/null
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriver.java
@@ -0,0 +1,272 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes.highavailability;
+
+import org.apache.flink.kubernetes.configuration.KubernetesLeaderElectionConfiguration;
+import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
+import org.apache.flink.kubernetes.kubeclient.KubernetesSharedWatcher;
+import org.apache.flink.kubernetes.kubeclient.resources.KubernetesConfigMap;
+import org.apache.flink.kubernetes.kubeclient.resources.KubernetesException;
+import org.apache.flink.kubernetes.kubeclient.resources.KubernetesLeaderElector;
+import org.apache.flink.kubernetes.utils.KubernetesUtils;
+import org.apache.flink.runtime.leaderelection.LeaderElectionException;
+import org.apache.flink.runtime.leaderelection.LeaderInformation;
+import org.apache.flink.runtime.leaderelection.LeaderInformationWithComponentId;
+import org.apache.flink.runtime.leaderelection.MultipleComponentLeaderElectionDriver;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.Preconditions;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Function;
+
+import static org.apache.flink.kubernetes.utils.Constants.LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY;
+import static org.apache.flink.kubernetes.utils.KubernetesUtils.checkConfigMaps;
+
+/** {@link MultipleComponentLeaderElectionDriver} for Kubernetes. */
+public class KubernetesMultipleComponentLeaderElectionDriver
+        implements MultipleComponentLeaderElectionDriver {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(KubernetesMultipleComponentLeaderElectionDriver.class);
+
+    private final FlinkKubeClient kubeClient;
+
+    private final String configMapName;
+
+    private final String lockIdentity;
+
+    private final MultipleComponentLeaderElectionDriver.Listener leaderElectionListener;
+
+    private final KubernetesLeaderElector leaderElector;
+
+    // Labels will be used to clean up the ha related ConfigMaps.
+    private final Map<String, String> configMapLabels;
+
+    private final FatalErrorHandler fatalErrorHandler;
+
+    private final KubernetesSharedWatcher.Watch kubernetesWatch;
+
+    private final AtomicBoolean running = new AtomicBoolean(true);
+
+    public KubernetesMultipleComponentLeaderElectionDriver(
+            KubernetesLeaderElectionConfiguration leaderElectionConfiguration,
+            FlinkKubeClient kubeClient,
+            Listener leaderElectionListener,
+            KubernetesConfigMapSharedWatcher configMapSharedWatcher,
+            Executor watchExecutor,
+            FatalErrorHandler fatalErrorHandler) {
+        Preconditions.checkNotNull(leaderElectionConfiguration);
+        this.kubeClient = Preconditions.checkNotNull(kubeClient);
+        this.leaderElectionListener = Preconditions.checkNotNull(leaderElectionListener);
+        this.fatalErrorHandler = Preconditions.checkNotNull(fatalErrorHandler);
+        Preconditions.checkNotNull(configMapSharedWatcher);
+        Preconditions.checkNotNull(watchExecutor);
+
+        this.configMapName = leaderElectionConfiguration.getConfigMapName();
+        this.lockIdentity = leaderElectionConfiguration.getLockIdentity();
+
+        this.leaderElector =
+                kubeClient.createLeaderElector(
+                        leaderElectionConfiguration, new LeaderCallbackHandlerImpl());
+
+        this.configMapLabels =
+                KubernetesUtils.getConfigMapLabels(
+                        leaderElectionConfiguration.getClusterId(),
+                        LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY);
+
+        kubernetesWatch =
+                configMapSharedWatcher.watch(
+                        configMapName, new ConfigMapCallbackHandlerImpl(), watchExecutor);
+
+        leaderElector.run();
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (running.compareAndSet(true, false)) {
+            LOG.info("Closing {}.", this);
+
+            leaderElector.stop();
+            kubernetesWatch.close();
+        }
+    }
+
+    @Override
+    public boolean hasLeadership() {
+        Preconditions.checkState(running.get());
+        final Optional<KubernetesConfigMap> optionalConfigMap =
+                kubeClient.getConfigMap(configMapName);
+
+        if (optionalConfigMap.isPresent()) {
+            return KubernetesLeaderElector.hasLeadership(optionalConfigMap.get(), lockIdentity);
+        } else {
+            fatalErrorHandler.onFatalError(
+                    new KubernetesException(
+                            String.format(
+                                    "ConfigMap %s does not exist. This indicates that somebody has interfered with Flink's operation.",
+                                    configMapName)));
+            return false;
+        }
+    }
+
+    @Override
+    public void publishLeaderInformation(String componentId, LeaderInformation leaderInformation)
+            throws Exception {
+        Preconditions.checkState(running.get());
+
+        kubeClient
+                .checkAndUpdateConfigMap(
+                        configMapName,
+                        updateConfigMapWithLeaderInformation(componentId, leaderInformation))
+                .get();
+
+        LOG.debug(
+                "Successfully wrote leader information {} for leader {} into the config map {}.",
+                leaderInformation,
+                componentId,
+                configMapName);
+    }
+
+    @Override
+    public void deleteLeaderInformation(String componentId) throws Exception {
+        publishLeaderInformation(componentId, LeaderInformation.empty());
+    }
+
+    private Function<KubernetesConfigMap, Optional<KubernetesConfigMap>>
+            updateConfigMapWithLeaderInformation(
+                    String leaderName, LeaderInformation leaderInformation) {
+        final String configMapDataKey = KubernetesUtils.createSingleLeaderKey(leaderName);
+
+        return kubernetesConfigMap -> {
+            if (KubernetesLeaderElector.hasLeadership(kubernetesConfigMap, lockIdentity)) {
+                final Map<String, String> data = kubernetesConfigMap.getData();
+
+                if (leaderInformation.isEmpty()) {
+                    data.remove(configMapDataKey);
+                } else {
+                    data.put(
+                            configMapDataKey,
+                            KubernetesUtils.encodeLeaderInformation(leaderInformation));
+                }
+
+                kubernetesConfigMap.getLabels().putAll(configMapLabels);
+                return Optional.of(kubernetesConfigMap);
+            }
+
+            return Optional.empty();
+        };
+    }
+
+    private static Collection<LeaderInformationWithComponentId> extractLeaderInformation(
+            KubernetesConfigMap configMap) {
+        final Map<String, String> data = configMap.getData();
+
+        final Collection<LeaderInformationWithComponentId> leaderInformationWithLeaderNames =
+                new ArrayList<>();
+
+        for (Map.Entry<String, String> keyValuePair : data.entrySet()) {
+            final String key = keyValuePair.getKey();
+            if (KubernetesUtils.isSingleLeaderKey(key)) {
+                final String leaderName = KubernetesUtils.extractLeaderName(key);
+                final LeaderInformation leaderInformation =
+                        KubernetesUtils.parseLeaderInformationSafely(keyValuePair.getValue())
+                                .orElse(LeaderInformation.empty());
+                leaderInformationWithLeaderNames.add(
+                        LeaderInformationWithComponentId.create(leaderName, leaderInformation));
+            }
+        }
+
+        return leaderInformationWithLeaderNames;
+    }
+
+    private class LeaderCallbackHandlerImpl extends KubernetesLeaderElector.LeaderCallbackHandler {
+        @Override
+        public void isLeader() {
+            leaderElectionListener.isLeader();
+        }
+
+        @Override
+        public void notLeader() {
+            leaderElectionListener.notLeader();
+            leaderElector.run();
+        }
+    }
+
+    private class ConfigMapCallbackHandlerImpl
+            implements FlinkKubeClient.WatchCallbackHandler<KubernetesConfigMap> {
+        @Override
+        public void onAdded(List<KubernetesConfigMap> resources) {
+            // nothing to do
+        }
+
+        @Override
+        public void onModified(List<KubernetesConfigMap> configMaps) {
+            final KubernetesConfigMap configMap = checkConfigMaps(configMaps, configMapName);
+
+            if (KubernetesLeaderElector.hasLeadership(configMap, lockIdentity)) {
+                Collection<LeaderInformationWithComponentId> leaderInformationWithLeaderNames =
+                        extractLeaderInformation(configMap);
+
+                leaderElectionListener.notifyAllKnownLeaderInformation(
+                        leaderInformationWithLeaderNames);
+            }
+        }
+
+        @Override
+        public void onDeleted(List<KubernetesConfigMap> configMaps) {
+            final KubernetesConfigMap configMap = checkConfigMaps(configMaps, configMapName);
+            if (KubernetesLeaderElector.hasLeadership(configMap, lockIdentity)) {
+                fatalErrorHandler.onFatalError(
+                        new LeaderElectionException(
+                                String.format(
+                                        "ConfigMap %s has been deleted externally.",
+                                        configMapName)));
+            }
+        }
+
+        @Override
+        public void onError(List<KubernetesConfigMap> configMaps) {
+            final KubernetesConfigMap configMap = checkConfigMaps(configMaps, configMapName);
+            if (KubernetesLeaderElector.hasLeadership(configMap, lockIdentity)) {
+                fatalErrorHandler.onFatalError(
+                        new LeaderElectionException(
+                                String.format(
+                                        "Error while watching the ConfigMap %s.", configMapName)));
+            }
+        }
+
+        @Override
+        public void handleError(Throwable throwable) {
+            fatalErrorHandler.onFatalError(
+                    new LeaderElectionException(
+                            String.format("Error while watching the ConfigMap %s.", configMapName),
+                            throwable));
+        }
+    }
+}
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriverFactory.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriverFactory.java
new file mode 100644
index 00000000000..7dd10e8ada3
--- /dev/null
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriverFactory.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes.highavailability;
+
+import org.apache.flink.kubernetes.configuration.KubernetesLeaderElectionConfiguration;
+import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
+import org.apache.flink.runtime.leaderelection.MultipleComponentLeaderElectionDriver;
+import org.apache.flink.runtime.leaderelection.MultipleComponentLeaderElectionDriverFactory;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.Preconditions;
+
+import java.util.concurrent.Executor;
+
+/** Factory that instantiates a {@link KubernetesMultipleComponentLeaderElectionDriver}. */
+public class KubernetesMultipleComponentLeaderElectionDriverFactory
+        implements MultipleComponentLeaderElectionDriverFactory {
+    private final FlinkKubeClient kubeClient;
+
+    private final KubernetesLeaderElectionConfiguration kubernetesLeaderElectionConfiguration;
+
+    private final KubernetesConfigMapSharedWatcher configMapSharedWatcher;
+
+    private final Executor watchExecutor;
+
+    private final FatalErrorHandler fatalErrorHandler;
+
+    public KubernetesMultipleComponentLeaderElectionDriverFactory(
+            FlinkKubeClient kubeClient,
+            KubernetesLeaderElectionConfiguration kubernetesLeaderElectionConfiguration,
+            KubernetesConfigMapSharedWatcher configMapSharedWatcher,
+            Executor watchExecutor,
+            FatalErrorHandler fatalErrorHandler) {
+        this.kubeClient = Preconditions.checkNotNull(kubeClient);
+        this.kubernetesLeaderElectionConfiguration =
+                Preconditions.checkNotNull(kubernetesLeaderElectionConfiguration);
+        this.configMapSharedWatcher = Preconditions.checkNotNull(configMapSharedWatcher);
+        this.watchExecutor = Preconditions.checkNotNull(watchExecutor);
+        this.fatalErrorHandler = Preconditions.checkNotNull(fatalErrorHandler);
+    }
+
+    @Override
+    public KubernetesMultipleComponentLeaderElectionDriver create(
+            MultipleComponentLeaderElectionDriver.Listener leaderElectionListener)
+            throws Exception {
+        return new KubernetesMultipleComponentLeaderElectionDriver(
+                kubernetesLeaderElectionConfiguration,
+                kubeClient,
+                leaderElectionListener,
+                configMapSharedWatcher,
+                watchExecutor,
+                fatalErrorHandler);
+    }
+}
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java
new file mode 100644
index 00000000000..158780a7218
--- /dev/null
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java
@@ -0,0 +1,252 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes.highavailability;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.kubernetes.configuration.KubernetesConfigOptions;
+import org.apache.flink.kubernetes.configuration.KubernetesLeaderElectionConfiguration;
+import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
+import org.apache.flink.kubernetes.utils.KubernetesUtils;
+import org.apache.flink.runtime.blob.BlobStoreService;
+import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.highavailability.AbstractHaServices;
+import org.apache.flink.runtime.highavailability.RunningJobsRegistry;
+import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.leaderelection.DefaultLeaderElectionService;
+import org.apache.flink.runtime.leaderelection.DefaultMultipleComponentLeaderElectionService;
+import org.apache.flink.runtime.leaderelection.LeaderElectionService;
+import org.apache.flink.runtime.leaderelection.MultipleComponentLeaderElectionService;
+import org.apache.flink.runtime.leaderretrieval.DefaultLeaderRetrievalService;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalService;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.ExecutorUtils;
+import org.apache.flink.util.FlinkRuntimeException;
+import org.apache.flink.util.concurrent.ExecutorThreadFactory;
+
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.UUID;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.flink.kubernetes.utils.Constants.LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY;
+import static org.apache.flink.kubernetes.utils.Constants.NAME_SEPARATOR;
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
+/** Kubernetes HA services that use a single leader election service per JobManager. */
+public class KubernetesMultipleComponentLeaderElectionHaServices extends AbstractHaServices {
+
+    private final Object lock = new Object();
+
+    private final String clusterId;
+
+    private final FlinkKubeClient kubeClient;
+
+    private final KubernetesConfigMapSharedWatcher configMapSharedWatcher;
+    private final ExecutorService watchExecutorService;
+
+    private final String lockIdentity;
+
+    private final FatalErrorHandler fatalErrorHandler;
+
+    @Nullable
+    @GuardedBy("lock")
+    private DefaultMultipleComponentLeaderElectionService multipleComponentLeaderElectionService =
+            null;
+
+    KubernetesMultipleComponentLeaderElectionHaServices(
+            FlinkKubeClient kubeClient,
+            Executor executor,
+            Configuration config,
+            BlobStoreService blobStoreService,
+            FatalErrorHandler fatalErrorHandler) {
+
+        super(config, executor, blobStoreService);
+        this.kubeClient = checkNotNull(kubeClient);
+        this.clusterId = checkNotNull(config.get(KubernetesConfigOptions.CLUSTER_ID));
+        this.fatalErrorHandler = checkNotNull(fatalErrorHandler);
+
+        this.configMapSharedWatcher =
+                this.kubeClient.createConfigMapSharedWatcher(
+                        KubernetesUtils.getConfigMapLabels(
+                                clusterId, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY));
+        this.watchExecutorService =
+                Executors.newCachedThreadPool(
+                        new ExecutorThreadFactory("config-map-watch-handler"));
+
+        lockIdentity = UUID.randomUUID().toString();
+    }
+
+    @Override
+    protected LeaderElectionService createLeaderElectionService(String leaderName) {
+        final MultipleComponentLeaderElectionService multipleComponentLeaderElectionService =
+                getOrInitializeSingleLeaderElectionService();
+
+        return new DefaultLeaderElectionService(
+                multipleComponentLeaderElectionService.createDriverFactory(leaderName));
+    }
+
+    private DefaultMultipleComponentLeaderElectionService
+            getOrInitializeSingleLeaderElectionService() {
+        synchronized (lock) {
+            if (multipleComponentLeaderElectionService == null) {
+                try {
+
+                    final KubernetesLeaderElectionConfiguration leaderElectionConfiguration =
+                            new KubernetesLeaderElectionConfiguration(
+                                    getClusterConfigMap(), lockIdentity, configuration);
+                    multipleComponentLeaderElectionService =
+                            new DefaultMultipleComponentLeaderElectionService(
+                                    fatalErrorHandler,
+                                    new KubernetesMultipleComponentLeaderElectionDriverFactory(
+                                            kubeClient,
+                                            leaderElectionConfiguration,
+                                            configMapSharedWatcher,
+                                            watchExecutorService,
+                                            fatalErrorHandler));
+                } catch (Exception e) {
+                    throw new FlinkRuntimeException(
+                            "Could not initialize the default single leader election service.", e);
+                }
+            }
+
+            return multipleComponentLeaderElectionService;
+        }
+    }
+
+    @Override
+    protected LeaderRetrievalService createLeaderRetrievalService(String componentId) {
+        return new DefaultLeaderRetrievalService(
+                new KubernetesMultipleComponentLeaderRetrievalDriverFactory(
+                        kubeClient,
+                        configMapSharedWatcher,
+                        watchExecutorService,
+                        getClusterConfigMap(),
+                        componentId));
+    }
+
+    @Override
+    protected CheckpointRecoveryFactory createCheckpointRecoveryFactory() {
+        return new KubernetesCheckpointRecoveryFactory(
+                kubeClient, configuration, ioExecutor, this::getJobSpecificConfigMap, lockIdentity);
+    }
+
+    private String getJobSpecificConfigMap(JobID jobID) {
+        return clusterId + NAME_SEPARATOR + jobID.toString() + NAME_SEPARATOR + "config-map";
+    }
+
+    @Override
+    protected JobGraphStore createJobGraphStore() throws Exception {
+        return KubernetesUtils.createJobGraphStore(
+                configuration, kubeClient, getClusterConfigMap(), lockIdentity);
+    }
+
+    private String getClusterConfigMap() {
+        return clusterId + NAME_SEPARATOR + "cluster-config-map";
+    }
+
+    @Override
+    protected RunningJobsRegistry createRunningJobsRegistry() {
+        return new KubernetesRunningJobsRegistry(kubeClient, getClusterConfigMap(), lockIdentity);
+    }
+
+    @Override
+    public void internalClose() throws Exception {
+        Exception exception = null;
+        try {
+            closeK8sServices();
+        } catch (Exception e) {
+            exception = e;
+        }
+
+        kubeClient.close();
+        ExecutorUtils.gracefulShutdown(5, TimeUnit.SECONDS, this.watchExecutorService);
+
+        ExceptionUtils.tryRethrowException(exception);
+    }
+
+    private void closeK8sServices() throws Exception {
+        Exception exception = null;
+        synchronized (lock) {
+            if (multipleComponentLeaderElectionService != null) {
+                try {
+                    multipleComponentLeaderElectionService.close();
+                } catch (Exception e) {
+                    exception = e;
+                }
+                multipleComponentLeaderElectionService = null;
+            }
+        }
+
+        configMapSharedWatcher.close();
+
+        ExceptionUtils.tryRethrowException(exception);
+    }
+
+    @Override
+    public void internalCleanup() throws Exception {
+        Exception exception = null;
+        // in order to clean up, we first need to stop the services that rely on the config maps
+        try {
+            closeK8sServices();
+        } catch (Exception e) {
+            exception = e;
+        }
+
+        kubeClient
+                .deleteConfigMapsByLabels(
+                        KubernetesUtils.getConfigMapLabels(
+                                clusterId, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY))
+                .get();
+
+        ExceptionUtils.tryRethrowException(exception);
+    }
+
+    @Override
+    public void internalCleanupJobData(JobID jobID) throws Exception {
+        kubeClient.deleteConfigMap(getJobSpecificConfigMap(jobID)).get();
+        // need to delete job specific leader address from leader config map
+    }
+
+    @Override
+    protected String getLeaderPathForResourceManager() {
+        return "resourcemanager";
+    }
+
+    @Override
+    protected String getLeaderPathForDispatcher() {
+        return "dispatcher";
+    }
+
+    @Override
+    protected String getLeaderPathForJobManager(JobID jobID) {
+        return jobID.toString();
+    }
+
+    @Override
+    protected String getLeaderPathForRestServer() {
+        return "restserver";
+    }
+}
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServicesFactory.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServicesFactory.java
new file mode 100644
index 00000000000..444ae69d57b
--- /dev/null
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServicesFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes.highavailability;
+
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.kubernetes.kubeclient.FlinkKubeClientFactory;
+import org.apache.flink.runtime.blob.BlobUtils;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServicesFactory;
+import org.apache.flink.util.FatalExitExceptionHandler;
+
+import java.util.concurrent.Executor;
+
+/** Factory for {@link KubernetesMultipleComponentLeaderElectionHaServices}. */
+public class KubernetesMultipleComponentLeaderElectionHaServicesFactory
+        implements HighAvailabilityServicesFactory {
+    @Override
+    public HighAvailabilityServices createHAServices(Configuration configuration, Executor executor)
+            throws Exception {
+        return new KubernetesMultipleComponentLeaderElectionHaServices(
+                FlinkKubeClientFactory.getInstance()
+                        .fromConfiguration(configuration, "kubernetes-ha-services"),
+                executor,
+                configuration,
+                BlobUtils.createBlobStoreFromConfig(configuration),
+                error ->
+                        FatalExitExceptionHandler.INSTANCE.uncaughtException(
+                                Thread.currentThread(), error));
+    }
+}
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderRetrievalDriverFactory.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderRetrievalDriverFactory.java
new file mode 100644
index 00000000000..134f197d954
--- /dev/null
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderRetrievalDriverFactory.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes.highavailability;
+
+import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
+import org.apache.flink.kubernetes.kubeclient.resources.KubernetesConfigMap;
+import org.apache.flink.kubernetes.utils.KubernetesUtils;
+import org.apache.flink.runtime.leaderelection.LeaderInformation;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalDriver;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalDriverFactory;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalEventHandler;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.Preconditions;
+
+import java.util.Map;
+import java.util.concurrent.Executor;
+
+/**
+ * Factory that instantiates a {@link KubernetesLeaderRetrievalDriver} in single leader election
+ * mode.
+ */
+public class KubernetesMultipleComponentLeaderRetrievalDriverFactory
+        implements LeaderRetrievalDriverFactory {
+
+    private final FlinkKubeClient kubeClient;
+
+    private final KubernetesConfigMapSharedWatcher configMapSharedWatcher;
+
+    private final Executor watchExecutor;
+
+    private final String configMapName;
+
+    private final String componentId;
+
+    public KubernetesMultipleComponentLeaderRetrievalDriverFactory(
+            FlinkKubeClient kubeClient,
+            KubernetesConfigMapSharedWatcher configMapSharedWatcher,
+            Executor watchExecutor,
+            String configMapName,
+            String componentId) {
+        this.kubeClient = Preconditions.checkNotNull(kubeClient);
+        this.configMapSharedWatcher = Preconditions.checkNotNull(configMapSharedWatcher);
+        this.watchExecutor = Preconditions.checkNotNull(watchExecutor);
+        this.configMapName = Preconditions.checkNotNull(configMapName);
+        this.componentId = Preconditions.checkNotNull(componentId);
+    }
+
+    @Override
+    public LeaderRetrievalDriver createLeaderRetrievalDriver(
+            LeaderRetrievalEventHandler leaderEventHandler, FatalErrorHandler fatalErrorHandler) {
+        return new KubernetesLeaderRetrievalDriver(
+                kubeClient,
+                configMapSharedWatcher,
+                watchExecutor,
+                configMapName,
+                leaderEventHandler,
+                this::extractLeaderInformation,
+                fatalErrorHandler);
+    }
+
+    public LeaderInformation extractLeaderInformation(KubernetesConfigMap configMap) {
+        final String configDataLeaderKey = KubernetesUtils.createSingleLeaderKey(componentId);
+
+        final Map<String, String> data = configMap.getData();
+
+        if (data.containsKey(configDataLeaderKey)) {
+            return KubernetesUtils.parseLeaderInformationSafely(data.get(configDataLeaderKey))
+                    .orElse(LeaderInformation.empty());
+        } else {
+            return LeaderInformation.empty();
+        }
+    }
+}
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java
index c9203466329..b1452d254b4 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java
@@ -45,6 +45,7 @@ import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.persistence.filesystem.FileSystemStateStorageHelper;
 import org.apache.flink.runtime.state.SharedStateRegistryFactory;
 import org.apache.flink.util.FlinkRuntimeException;
+import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.StringUtils;
 import org.apache.flink.util.function.FunctionUtils;
 
@@ -70,6 +71,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
@@ -89,6 +91,9 @@ public class KubernetesUtils {
 
     private static final YAMLMapper yamlMapper = new YAMLMapper();
 
+    private static final String LEADER_PREFIX = "org.apache.flink.k8s.leader.";
+    private static final char LEADER_INFORMATION_SEPARATOR = ',';
+
     /**
      * Check whether the port config option is a fixed port. If not, the fallback port will be set
      * to configuration.
@@ -513,5 +518,50 @@ public class KubernetesUtils {
         TASK_MANAGER
     }
 
+    public static String encodeLeaderInformation(LeaderInformation leaderInformation) {
+        Preconditions.checkArgument(leaderInformation.getLeaderSessionID() != null);
+        Preconditions.checkArgument(leaderInformation.getLeaderAddress() != null);
+
+        return leaderInformation.getLeaderSessionID().toString()
+                + LEADER_INFORMATION_SEPARATOR
+                + leaderInformation.getLeaderAddress();
+    }
+
+    public static Optional<LeaderInformation> parseLeaderInformationSafely(String value) {
+        try {
+            return Optional.of(parseLeaderInformation(value));
+        } catch (Throwable throwable) {
+            LOG.debug("Could not parse value {} into LeaderInformation.", value, throwable);
+            return Optional.empty();
+        }
+    }
+
+    private static LeaderInformation parseLeaderInformation(String value) {
+        final int splitIndex = value.indexOf(LEADER_INFORMATION_SEPARATOR);
+
+        Preconditions.checkState(
+                splitIndex >= 0,
+                String.format(
+                        "Expecting '<session_id>%c<leader_address>'",
+                        LEADER_INFORMATION_SEPARATOR));
+
+        final UUID leaderSessionId = UUID.fromString(value.substring(0, splitIndex));
+        final String leaderAddress = value.substring(splitIndex + 1);
+
+        return LeaderInformation.known(leaderSessionId, leaderAddress);
+    }
+
+    public static String createSingleLeaderKey(String componentId) {
+        return LEADER_PREFIX + componentId;
+    }
+
+    public static boolean isSingleLeaderKey(String key) {
+        return key.startsWith(LEADER_PREFIX);
+    }
+
+    public static String extractLeaderName(String key) {
+        return key.substring(LEADER_PREFIX.length());
+    }
+
     private KubernetesUtils() {}
 }
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java
index b11d0c7b477..0887bda4067 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesLeaderElectionAndRetrievalITCase.java
@@ -97,6 +97,7 @@ public class KubernetesLeaderElectionAndRetrievalITCase extends TestLogger {
                             watchExecutorService,
                             configMapName,
                             retrievalEventHandler,
+                            KubernetesUtils::getLeaderInformationFromConfigMap,
                             retrievalEventHandler::handleError);
 
             electionEventHandler.waitForLeader(TIMEOUT);
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriverTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriverTest.java
new file mode 100644
index 00000000000..f05f617ce07
--- /dev/null
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionDriverTest.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes.highavailability;
+
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.kubernetes.configuration.KubernetesConfigOptions;
+import org.apache.flink.kubernetes.configuration.KubernetesLeaderElectionConfiguration;
+import org.apache.flink.kubernetes.kubeclient.FlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.KubernetesConfigMapSharedWatcher;
+import org.apache.flink.kubernetes.kubeclient.TestingFlinkKubeClient;
+import org.apache.flink.kubernetes.kubeclient.resources.KubernetesLeaderElector;
+import org.apache.flink.kubernetes.utils.KubernetesUtils;
+import org.apache.flink.runtime.leaderelection.LeaderElectionEvent;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionListener;
+import org.apache.flink.runtime.util.TestingFatalErrorHandlerExtension;
+import org.apache.flink.testutils.executor.TestExecutorExtension;
+import org.apache.flink.util.TestLoggerExtension;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import static org.apache.flink.kubernetes.utils.Constants.LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY;
+
+@ExtendWith(TestLoggerExtension.class)
+public class KubernetesMultipleComponentLeaderElectionDriverTest {
+
+    private static final String CLUSTER_ID = "test-cluster";
+
+    @RegisterExtension
+    private final TestingFatalErrorHandlerExtension testingFatalErrorHandlerExtension =
+            new TestingFatalErrorHandlerExtension();
+
+    @RegisterExtension
+    private final TestExecutorExtension<ExecutorService> testExecutorExtension =
+            new TestExecutorExtension<>(Executors::newSingleThreadScheduledExecutor);
+
+    @Test
+    public void testElectionDriverGainsLeadership() throws InterruptedException {
+        final Configuration configuration = new Configuration();
+        configuration.setString(KubernetesConfigOptions.CLUSTER_ID, CLUSTER_ID);
+        final KubernetesLeaderElectionConfiguration leaderElectionConfiguration =
+                new KubernetesLeaderElectionConfiguration("foobar", "barfoo", configuration);
+
+        CompletableFuture<KubernetesLeaderElector.LeaderCallbackHandler>
+                leaderCallbackHandlerFuture = new CompletableFuture<>();
+        final FlinkKubeClient flinkKubeClient =
+                TestingFlinkKubeClient.builder()
+                        .setCreateLeaderElectorFunction(
+                                (leaderConfig, callbackHandler) -> {
+                                    leaderCallbackHandlerFuture.complete(callbackHandler);
+                                    return new TestingFlinkKubeClient
+                                            .TestingKubernetesLeaderElector(
+                                            leaderConfig, callbackHandler);
+                                })
+                        .build();
+
+        final KubernetesConfigMapSharedWatcher configMapSharedWatcher =
+                flinkKubeClient.createConfigMapSharedWatcher(
+                        KubernetesUtils.getConfigMapLabels(
+                                CLUSTER_ID, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY));
+
+        final TestingLeaderElectionListener leaderElectionListener =
+                new TestingLeaderElectionListener();
+
+        final KubernetesMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                new KubernetesMultipleComponentLeaderElectionDriver(
+                        leaderElectionConfiguration,
+                        flinkKubeClient,
+                        leaderElectionListener,
+                        configMapSharedWatcher,
+                        testExecutorExtension.getExecutor(),
+                        testingFatalErrorHandlerExtension.getTestingFatalErrorHandler());
+
+        final KubernetesLeaderElector.LeaderCallbackHandler leaderCallbackHandler =
+                leaderCallbackHandlerFuture.join();
+
+        leaderCallbackHandler.isLeader();
+
+        leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);
+    }
+
+    @Test
+    public void testElectionDriverLosesLeadership() throws Exception {}
+
+    @Test
+    public void testPublishLeaderInformation() throws Exception {}
+
+    @Test
+    public void testLeaderInformationChange() throws Exception {}
+
+    @Test
+    public void testLeaderElectionWithMultipleDrivers() throws Exception {}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderElectionEvent.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderElectionEvent.java
new file mode 100644
index 00000000000..c12a5656828
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderElectionEvent.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import java.util.Collection;
+
+/** Leader election event. */
+public abstract class LeaderElectionEvent {
+    public boolean isIsLeaderEvent() {
+        return false;
+    }
+
+    public boolean isNotLeaderEvent() {
+        return false;
+    }
+
+    public boolean isLeaderInformationChangeEvent() {
+        return false;
+    }
+
+    public boolean isAllKnownLeaderInformationEvent() {
+        return false;
+    }
+
+    public IsLeaderEvent asIsLeaderEvent() {
+        return as(IsLeaderEvent.class);
+    }
+
+    public <T> T as(Class<T> clazz) {
+        if (clazz.isAssignableFrom(getClass())) {
+            return clazz.cast(this);
+        } else {
+            throw new IllegalStateException("Cannot cast object.");
+        }
+    }
+
+    public static class IsLeaderEvent extends LeaderElectionEvent {
+        @Override
+        public boolean isIsLeaderEvent() {
+            return true;
+        }
+    }
+
+    public static class NotLeaderEvent extends LeaderElectionEvent {
+        @Override
+        public boolean isNotLeaderEvent() {
+            return true;
+        }
+    }
+
+    public static class LeaderInformationChangeEvent extends LeaderElectionEvent {
+        private final String componentId;
+        private final LeaderInformation leaderInformation;
+
+        LeaderInformationChangeEvent(String componentId, LeaderInformation leaderInformation) {
+            this.componentId = componentId;
+            this.leaderInformation = leaderInformation;
+        }
+
+        public LeaderInformation getLeaderInformation() {
+            return leaderInformation;
+        }
+
+        public String getComponentId() {
+            return componentId;
+        }
+
+        @Override
+        public boolean isLeaderInformationChangeEvent() {
+            return true;
+        }
+    }
+
+    public static class AllKnownLeaderInformationEvent extends LeaderElectionEvent {
+        private final Collection<LeaderInformationWithComponentId>
+                leaderInformationWithComponentIds;
+
+        AllKnownLeaderInformationEvent(
+                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
+            this.leaderInformationWithComponentIds = leaderInformationWithComponentIds;
+        }
+
+        @Override
+        public boolean isAllKnownLeaderInformationEvent() {
+            return true;
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionListener.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionListener.java
new file mode 100644
index 00000000000..9989f078e84
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionListener.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.api.common.time.Deadline;
+import org.apache.flink.util.ExceptionUtils;
+
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Simple {@link MultipleComponentLeaderElectionDriver.Listener} implementation for testing
+ * purposes.
+ */
+public final class TestingLeaderElectionListener
+        implements MultipleComponentLeaderElectionDriver.Listener {
+    private final BlockingQueue<LeaderElectionEvent> leaderElectionEvents =
+            new ArrayBlockingQueue<>(10);
+
+    @Override
+    public void isLeader() {
+        put(new LeaderElectionEvent.IsLeaderEvent());
+    }
+
+    @Override
+    public void notLeader() {
+        put(new LeaderElectionEvent.NotLeaderEvent());
+    }
+
+    @Override
+    public void notifyLeaderInformationChange(
+            String componentId, LeaderInformation leaderInformation) {
+        put(new LeaderElectionEvent.LeaderInformationChangeEvent(componentId, leaderInformation));
+    }
+
+    @Override
+    public void notifyAllKnownLeaderInformation(
+            Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
+        put(
+                new LeaderElectionEvent.AllKnownLeaderInformationEvent(
+                        leaderInformationWithComponentIds));
+    }
+
+    private void put(LeaderElectionEvent leaderElectionEvent) {
+        try {
+            leaderElectionEvents.put(leaderElectionEvent);
+        } catch (InterruptedException e) {
+            ExceptionUtils.rethrow(e);
+        }
+    }
+
+    public <T> T await(Class<T> clazz) throws InterruptedException {
+        while (true) {
+            final LeaderElectionEvent leaderElectionEvent = leaderElectionEvents.take();
+
+            if (clazz.isAssignableFrom(leaderElectionEvent.getClass())) {
+                return clazz.cast(leaderElectionEvent);
+            }
+        }
+    }
+
+    public <T> Optional<T> await(Class<T> clazz, Duration timeout) throws InterruptedException {
+        final Deadline deadline = Deadline.fromNow(timeout);
+
+        while (true) {
+            final Duration timeLeft = deadline.timeLeft();
+
+            if (timeLeft.isNegative()) {
+                return Optional.empty();
+            } else {
+                final Optional<LeaderElectionEvent> optLeaderElectionEvent =
+                        Optional.ofNullable(
+                                leaderElectionEvents.poll(
+                                        timeLeft.toMillis(), TimeUnit.MILLISECONDS));
+
+                if (optLeaderElectionEvent.isPresent()) {
+                    final LeaderElectionEvent leaderElectionEvent = optLeaderElectionEvent.get();
+
+                    if (clazz.isAssignableFrom(leaderElectionEvent.getClass())) {
+                        return Optional.of(clazz.cast(optLeaderElectionEvent));
+                    }
+                } else {
+                    return Optional.empty();
+                }
+            }
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java
index c827bdfe3da..3fb38d72853 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.runtime.leaderelection;
 
-import org.apache.flink.api.common.time.Deadline;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.core.testutils.EachCallbackWrapper;
@@ -43,13 +42,9 @@ import org.junit.jupiter.api.extension.RegisterExtension;
 import java.time.Duration;
 import java.util.Collection;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -69,7 +64,10 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
     public void testElectionDriverGainsLeadershipAtStartup() throws Exception {
         new Context() {
             {
-                runTest(() -> leaderElectionListener.await(IsLeaderEvent.class));
+                runTest(
+                        () ->
+                                leaderElectionListener.await(
+                                        LeaderElectionEvent.IsLeaderEvent.class));
             }
         };
     }
@@ -80,9 +78,9 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
             {
                 runTest(
                         () -> {
-                            leaderElectionListener.await(IsLeaderEvent.class);
+                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);
                             zooKeeperExtension.stop();
-                            leaderElectionListener.await(NotLeaderEvent.class);
+                            leaderElectionListener.await(LeaderElectionEvent.NotLeaderEvent.class);
                         });
             }
         };
@@ -94,7 +92,7 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
             {
                 runTest(
                         () -> {
-                            leaderElectionListener.await(IsLeaderEvent.class);
+                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);
 
                             final String componentId = "retrieved-component";
                             final DefaultLeaderRetrievalService defaultLeaderRetrievalService =
@@ -129,7 +127,7 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
             {
                 runTest(
                         () -> {
-                            leaderElectionListener.await(IsLeaderEvent.class);
+                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);
 
                             final String componentId = "retrieved-component";
                             final DefaultLeaderRetrievalService defaultLeaderRetrievalService =
@@ -170,7 +168,8 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
                         () -> {
                             ElectionDriver otherLeaderElectionDriver = null;
                             try {
-                                leaderElectionListener.await(IsLeaderEvent.class);
+                                leaderElectionListener.await(
+                                        LeaderElectionEvent.IsLeaderEvent.class);
 
                                 otherLeaderElectionDriver =
                                         createLeaderElectionDriver(
@@ -184,7 +183,8 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
 
                                 assertThat(
                                                 leaderElectionListener.await(
-                                                        LeaderInformationChangeEvent.class,
+                                                        LeaderElectionEvent
+                                                                .LeaderInformationChangeEvent.class,
                                                         Duration.ofMillis(50L)))
                                         .isEmpty();
                             } finally {
@@ -203,7 +203,7 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
             {
                 runTest(
                         () -> {
-                            leaderElectionListener.await(IsLeaderEvent.class);
+                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);
 
                             final LeaderInformation leaderInformation =
                                     LeaderInformation.known(UUID.randomUUID(), "foobar");
@@ -217,9 +217,11 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
                                     () -> true,
                                     path);
 
-                            final LeaderInformationChangeEvent leaderInformationChangeEvent =
-                                    leaderElectionListener.await(
-                                            LeaderInformationChangeEvent.class);
+                            final LeaderElectionEvent.LeaderInformationChangeEvent
+                                    leaderInformationChangeEvent =
+                                            leaderElectionListener.await(
+                                                    LeaderElectionEvent.LeaderInformationChangeEvent
+                                                            .class);
 
                             assertThat(leaderInformationChangeEvent.getComponentId())
                                     .isEqualTo(componentId);
@@ -248,8 +250,7 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
                         CompletableFuture.anyOf(
                                 electionDrivers.stream()
                                         .map(ElectionDriver::getLeadershipFuture)
-                                        .collect(Collectors.toList())
-                                        .toArray(new CompletableFuture[0]));
+                                        .toArray(CompletableFuture[]::new));
 
                 // wait for any leader
                 anyLeader.join();
@@ -277,7 +278,7 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
             {
                 runTest(
                         () -> {
-                            leaderElectionListener.await(IsLeaderEvent.class);
+                            leaderElectionListener.await(LeaderElectionEvent.IsLeaderEvent.class);
 
                             final LeaderInformation leaderInformation =
                                     LeaderInformation.known(UUID.randomUUID(), "foobar");
@@ -292,14 +293,17 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
                                     path);
 
                             // wait for the publishing of the leader information
-                            leaderElectionListener.await(LeaderInformationChangeEvent.class);
+                            leaderElectionListener.await(
+                                    LeaderElectionEvent.LeaderInformationChangeEvent.class);
 
                             curatorFramework.asCuratorFramework().delete().forPath(path);
 
                             // wait for the removal of the leader information
-                            final LeaderInformationChangeEvent leaderInformationChangeEvent =
-                                    leaderElectionListener.await(
-                                            LeaderInformationChangeEvent.class);
+                            final LeaderElectionEvent.LeaderInformationChangeEvent
+                                    leaderInformationChangeEvent =
+                                            leaderElectionListener.await(
+                                                    LeaderElectionEvent.LeaderInformationChangeEvent
+                                                            .class);
                             assertThat(leaderInformationChangeEvent.getComponentId())
                                     .isEqualTo(componentId);
                             assertThat(leaderInformationChangeEvent.getLeaderInformation())
@@ -393,175 +397,6 @@ class ZooKeeperMultipleComponentLeaderElectionDriverTest {
         return ZooKeeperUtils.startCuratorFramework(configuration, NoOpFatalErrorHandler.INSTANCE);
     }
 
-    private static final class TestingLeaderElectionListener
-            implements MultipleComponentLeaderElectionDriver.Listener {
-        private final BlockingQueue<LeaderElectionEvent> leaderElectionEvents =
-                new ArrayBlockingQueue<>(10);
-
-        @Override
-        public void isLeader() {
-            put(new IsLeaderEvent());
-        }
-
-        @Override
-        public void notLeader() {
-            put(new NotLeaderEvent());
-        }
-
-        @Override
-        public void notifyLeaderInformationChange(
-                String componentId, LeaderInformation leaderInformation) {
-            put(new LeaderInformationChangeEvent(componentId, leaderInformation));
-        }
-
-        @Override
-        public void notifyAllKnownLeaderInformation(
-                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
-            put(new AllKnownLeaderInformationEvent(leaderInformationWithComponentIds));
-        }
-
-        private void put(LeaderElectionEvent leaderElectionEvent) {
-            try {
-                leaderElectionEvents.put(leaderElectionEvent);
-            } catch (InterruptedException e) {
-                ExceptionUtils.rethrow(e);
-            }
-        }
-
-        public <T> T await(Class<T> clazz) throws InterruptedException {
-            while (true) {
-                final LeaderElectionEvent leaderElectionEvent = leaderElectionEvents.take();
-
-                if (clazz.isAssignableFrom(leaderElectionEvent.getClass())) {
-                    return clazz.cast(leaderElectionEvent);
-                }
-            }
-        }
-
-        public <T> Optional<T> await(Class<T> clazz, Duration timeout) throws InterruptedException {
-            final Deadline deadline = Deadline.fromNow(timeout);
-
-            while (true) {
-                final Duration timeLeft = deadline.timeLeft();
-
-                if (timeLeft.isNegative()) {
-                    return Optional.empty();
-                } else {
-                    final Optional<LeaderElectionEvent> optLeaderElectionEvent =
-                            Optional.ofNullable(
-                                    leaderElectionEvents.poll(
-                                            timeLeft.toMillis(), TimeUnit.MILLISECONDS));
-
-                    if (optLeaderElectionEvent.isPresent()) {
-                        final LeaderElectionEvent leaderElectionEvent =
-                                optLeaderElectionEvent.get();
-
-                        if (clazz.isAssignableFrom(leaderElectionEvent.getClass())) {
-                            return Optional.of(clazz.cast(optLeaderElectionEvent));
-                        }
-                    } else {
-                        return Optional.empty();
-                    }
-                }
-            }
-        }
-    }
-
-    private abstract static class LeaderElectionEvent {
-        boolean isIsLeaderEvent() {
-            return false;
-        }
-
-        boolean isNotLeaderEvent() {
-            return false;
-        }
-
-        boolean isLeaderInformationChangeEvent() {
-            return false;
-        }
-
-        boolean isAllKnownLeaderInformationEvent() {
-            return false;
-        }
-
-        IsLeaderEvent asIsLeaderEvent() {
-            return as(IsLeaderEvent.class);
-        }
-
-        NotLeaderEvent asNotLeaderEvent() {
-            return as(NotLeaderEvent.class);
-        }
-
-        LeaderInformationChangeEvent asLeaderInformationChangeEvent() {
-            return as(LeaderInformationChangeEvent.class);
-        }
-
-        AllKnownLeaderInformationEvent asAllKnownLeaderInformationEvent() {
-            return as(AllKnownLeaderInformationEvent.class);
-        }
-
-        <T> T as(Class<T> clazz) {
-            if (clazz.isAssignableFrom(getClass())) {
-                return clazz.cast(this);
-            } else {
-                throw new IllegalStateException("Cannot cast object.");
-            }
-        }
-    }
-
-    private static class IsLeaderEvent extends LeaderElectionEvent {
-        @Override
-        boolean isIsLeaderEvent() {
-            return true;
-        }
-    }
-
-    private static class NotLeaderEvent extends LeaderElectionEvent {
-        @Override
-        boolean isNotLeaderEvent() {
-            return true;
-        }
-    }
-
-    private static class LeaderInformationChangeEvent extends LeaderElectionEvent {
-        private final String componentId;
-        private final LeaderInformation leaderInformation;
-
-        private LeaderInformationChangeEvent(
-                String componentId, LeaderInformation leaderInformation) {
-            this.componentId = componentId;
-            this.leaderInformation = leaderInformation;
-        }
-
-        @Override
-        boolean isLeaderInformationChangeEvent() {
-            return true;
-        }
-
-        public String getComponentId() {
-            return componentId;
-        }
-
-        public LeaderInformation getLeaderInformation() {
-            return leaderInformation;
-        }
-    }
-
-    private static class AllKnownLeaderInformationEvent extends LeaderElectionEvent {
-        private final Collection<LeaderInformationWithComponentId>
-                leaderInformationWithComponentIds;
-
-        private AllKnownLeaderInformationEvent(
-                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
-            this.leaderInformationWithComponentIds = leaderInformationWithComponentIds;
-        }
-
-        @Override
-        boolean isAllKnownLeaderInformationEvent() {
-            return true;
-        }
-    }
-
     private class Context {
         protected final TestingLeaderElectionListener leaderElectionListener;
         protected final CuratorFrameworkWithUnhandledErrorListener curatorFramework;
