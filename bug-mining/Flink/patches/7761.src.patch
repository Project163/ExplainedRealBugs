diff --git a/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManager.java b/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManager.java
index 1dfdf1e2ff5..ff141d75df2 100644
--- a/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManager.java
+++ b/flink-connectors/flink-connector-base/src/main/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManager.java
@@ -38,7 +38,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
@@ -61,7 +60,6 @@ import static org.apache.flink.configuration.PipelineOptions.ALLOW_UNALIGNED_SOU
 @PublicEvolving
 public abstract class SplitFetcherManager<E, SplitT extends SourceSplit> {
     private static final Logger LOG = LoggerFactory.getLogger(SplitFetcherManager.class);
-    static final String THREAD_NAME_PREFIX = "Source Data Fetcher for ";
 
     private final Consumer<Throwable> errorHandler;
 
@@ -155,7 +153,7 @@ public abstract class SplitFetcherManager<E, SplitT extends SourceSplit> {
         final String taskThreadName = Thread.currentThread().getName();
         this.executors =
                 Executors.newCachedThreadPool(
-                        r -> new Thread(r, THREAD_NAME_PREFIX + taskThreadName));
+                        r -> new Thread(r, "Source Data Fetcher for " + taskThreadName));
         this.closed = false;
     }
 
@@ -271,32 +269,19 @@ public abstract class SplitFetcherManager<E, SplitT extends SourceSplit> {
         // fetcher threads blocking on putting batches into the element queue.
         executors.submit(
                 () -> {
-                    long timeElapsed = System.currentTimeMillis() - startTime;
-                    while (fetchersToShutDown.get() > 0 && timeElapsed < timeoutMs) {
-                        try {
-                            elementsQueue
-                                    .getAvailabilityFuture()
-                                    .thenRun(() -> elementsQueue.poll().recycle())
-                                    .get(timeoutMs - timeElapsed, TimeUnit.MILLISECONDS);
-                        } catch (ExecutionException ee) {
-                            // Ignore the exception and continue.
-                        } catch (Exception e) {
-                            LOG.warn(
-                                    "Received exception when waiting for the fetchers to "
-                                            + "shutdown.",
-                                    e);
-                            break;
-                        }
-                        timeElapsed = System.currentTimeMillis() - startTime;
+                    while (fetchersToShutDown.get() > 0
+                            && System.currentTimeMillis() - startTime < timeoutMs) {
+                        elementsQueue
+                                .getAvailabilityFuture()
+                                .thenRun(() -> elementsQueue.poll().recycle());
                     }
                 });
         executors.shutdown();
-        long timeElapsed = System.currentTimeMillis() - startTime;
-        if (!executors.awaitTermination(timeoutMs - timeElapsed, TimeUnit.NANOSECONDS)) {
+        if (!executors.awaitTermination(timeoutMs, TimeUnit.MILLISECONDS)) {
             LOG.warn(
                     "Failed to close the split fetchers in {} ms. There are still {} split fetchers running",
                     timeoutMs,
-                    fetchersToShutDown.get());
+                    fetchersToShutDown);
         }
     }
 
diff --git a/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManagerTest.java b/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManagerTest.java
index 1a55cfdd6b3..b6964e5cc10 100644
--- a/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManagerTest.java
+++ b/flink-connectors/flink-connector-base/src/test/java/org/apache/flink/connector/base/source/reader/fetcher/SplitFetcherManagerTest.java
@@ -37,10 +37,8 @@ import org.junit.jupiter.api.Timeout;
 import java.io.IOException;
 import java.time.Duration;
 import java.util.ArrayDeque;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.TimeUnit;
 
@@ -102,50 +100,6 @@ class SplitFetcherManagerTest {
         fetcherManager.close(Long.MAX_VALUE);
     }
 
-    /**
-     * This test is somewhat testing the implementation instead of contract. This is because the
-     * test is trying to make sure the element queue draining thread is not tight looping.
-     */
-    @Test
-    public void testCloseBlockingWaitingForFetcherShutdown() throws Exception {
-        final String splitId = "testSplit";
-        // create a reader which blocks on close().
-        final AwaitingReader<Integer, TestingSourceSplit> reader = new AwaitingReader<>();
-        final SplitFetcherManager<Integer, TestingSourceSplit> fetcherManager =
-                createFetcher(splitId, reader, new Configuration());
-        // Now close the fetcher manager. The fetcher should still be running when the fetcher
-        // manager returns.
-        Thread closingThread =
-                new Thread(
-                        () -> {
-                            try {
-                                fetcherManager.close(Long.MAX_VALUE);
-                            } catch (Exception e) {
-                                fail("failed.");
-                                throw new RuntimeException(e);
-                            }
-                        },
-                        "closingThread");
-        closingThread.start();
-
-        waitUntil(
-                () -> findThread(SplitFetcherManager.THREAD_NAME_PREFIX).size() == 2,
-                "The element queue draining thread should have started.");
-        for (Thread t : findThread(SplitFetcherManager.THREAD_NAME_PREFIX)) {
-            assertThat(t.getState().equals(Thread.State.WAITING))
-                    .as("All the executor threads should be in waiting status.");
-        }
-
-        assertThat(fetcherManager.getQueue().getAvailabilityFuture().getNumberOfDependents())
-                .as("The future should have just one dependent stage")
-                .isEqualTo(1);
-        assertThat(fetcherManager.fetchers.size()).isEqualTo(1);
-        reader.triggerThrowException();
-        reader.triggerClose();
-        waitUntil(fetcherManager.fetchers::isEmpty, "The fetcher should be closed now.");
-        closingThread.join();
-    }
-
     @Test
     void testIdleShutdownSplitFetcherWaitsUntilRecordProcessed() throws Exception {
         final String splitId = "testSplit";
@@ -243,16 +197,6 @@ class SplitFetcherManagerTest {
         while (queue.poll() != null) {}
     }
 
-    private static List<Thread> findThread(String keyword) {
-        List<Thread> threads = new ArrayList<>();
-        for (Thread t : Thread.getAllStackTraces().keySet()) {
-            if (t.getName().contains(keyword)) {
-                threads.add(t);
-            }
-        }
-        return threads;
-    }
-
     // ------------------------------------------------------------------------
     //  test mocks
     // ------------------------------------------------------------------------
@@ -265,19 +209,13 @@ class SplitFetcherManagerTest {
 
         private final OneShotLatch inBlocking = new OneShotLatch();
         private final OneShotLatch throwError = new OneShotLatch();
-        private final OneShotLatch closeBlocker = new OneShotLatch();
+
         private volatile boolean isClosed = false;
 
         @SafeVarargs
         AwaitingReader(IOException testError, RecordsWithSplitIds<E>... fetches) {
             this.testError = testError;
             this.fetches = new ArrayDeque<>(Arrays.asList(fetches));
-            this.closeBlocker.trigger();
-        }
-
-        AwaitingReader() {
-            this.testError = new IOException("DummyException");
-            this.fetches = new ArrayDeque<>(Collections.emptyList());
         }
 
         @Override
@@ -304,7 +242,6 @@ class SplitFetcherManagerTest {
 
         @Override
         public void close() throws Exception {
-            closeBlocker.await();
             isClosed = true;
         }
 
@@ -315,9 +252,5 @@ class SplitFetcherManagerTest {
         public void triggerThrowException() {
             throwError.trigger();
         }
-
-        public void triggerClose() {
-            closeBlocker.trigger();
-        }
     }
 }
