diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java
index d0545612b5b..6a9f7792180 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java
@@ -137,27 +137,18 @@ class CheckpointRequestDecider {
 		}
 
 		CheckpointTriggerRequest first = queuedRequests.first();
-		if (first.isForce() || !first.isPeriodic) {
-			return Optional.of(queuedRequests.pollFirst());
-		}
-
-		long nextTriggerDelayMillis = nextTriggerDelayMillis(lastCompletionMs);
-		if (nextTriggerDelayMillis > 0) {
-			return onTooEarly(nextTriggerDelayMillis);
+		if (!first.isForce() && first.isPeriodic) {
+			long nextTriggerDelayMillis = nextTriggerDelayMillis(lastCompletionMs);
+			if (nextTriggerDelayMillis > 0) {
+				queuedRequests.pollFirst().completeExceptionally(new CheckpointException(MINIMUM_TIME_BETWEEN_CHECKPOINTS));
+				rescheduleTrigger.accept(nextTriggerDelayMillis);
+				return Optional.empty();
+			}
 		}
 
 		return Optional.of(queuedRequests.pollFirst());
 	}
 
-	private Optional<CheckpointTriggerRequest> onTooEarly(long nextTriggerDelayMillis) {
-		CheckpointTriggerRequest first = queuedRequests.first();
-		if (first.isPeriodic) {
-			queuedRequests.pollFirst().completeExceptionally(new CheckpointException(MINIMUM_TIME_BETWEEN_CHECKPOINTS));
-			rescheduleTrigger.accept(nextTriggerDelayMillis);
-		}
-		return Optional.empty();
-	}
-
 	private long nextTriggerDelayMillis(long lastCheckpointCompletionRelativeTime) {
 		return lastCheckpointCompletionRelativeTime - clock.relativeTimeMillis() + minPauseBetweenCheckpoints;
 	}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java
index f2a3536adb5..55b19b66795 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java
@@ -66,6 +66,21 @@ public class CheckpointRequestDeciderTest {
 		assertEquals(Optional.of(request), decider.chooseQueuedRequestToExecute(isTriggering, 0));
 	}
 
+
+	@Test
+	public void testNonForcedEnqueueOnTooManyPending() {
+		final int maxPending = 1;
+		final boolean isTriggering = false;
+		final AtomicInteger currentPending = new AtomicInteger(maxPending);
+		CheckpointRequestDecider decider = decider(Integer.MAX_VALUE, maxPending, 1, currentPending);
+
+		CheckpointTriggerRequest request = nonForcedSavepoint();
+		assertFalse(decider.chooseRequestToExecute(request, isTriggering, 0).isPresent());
+
+		currentPending.set(0);
+		assertEquals(Optional.of(request), decider.chooseQueuedRequestToExecute(isTriggering, 0));
+	}
+
 	@Test
 	public void testUserSubmittedPrioritized() {
 		CheckpointTriggerRequest userSubmitted = regularSavepoint();
@@ -84,6 +99,27 @@ public class CheckpointRequestDeciderTest {
 				new CheckpointTriggerRequest[]{savepoint, checkpoint});
 	}
 
+
+	@Test
+	public void testNonForcedUserSubmittedPrioritized() {
+		CheckpointTriggerRequest userSubmitted = nonForcedSavepoint();
+		CheckpointTriggerRequest periodic = nonForcedPeriodicSavepoint();
+		testRequestsOrdering(
+			new CheckpointTriggerRequest[]{periodic, userSubmitted},
+			new CheckpointTriggerRequest[]{userSubmitted, periodic});
+	}
+
+	@Test
+	public void testNonForcedSavepointPrioritized() {
+		CheckpointTriggerRequest savepoint = nonForcedSavepoint();
+		CheckpointTriggerRequest checkpoint = regularCheckpoint();
+		testRequestsOrdering(
+			new CheckpointTriggerRequest[]{checkpoint, savepoint},
+			new CheckpointTriggerRequest[]{savepoint, checkpoint});
+	}
+
+
+
 	@Test
 	public void testQueueSizeLimit() {
 		final int maxQueuedRequests = 10;
@@ -206,6 +242,10 @@ public class CheckpointRequestDeciderTest {
 		return savepointRequest(true, true);
 	}
 
+	private static CheckpointTriggerRequest nonForcedPeriodicSavepoint(){
+		return savepointRequest(false, true);
+	}
+
 	private static CheckpointTriggerRequest nonForcedSavepoint() {
 		return savepointRequest(false, false);
 	}
