diff --git a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/AbstractStateChangeLogger.java b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/AbstractStateChangeLogger.java
index 5b21e15f9f4..87ac1d23abb 100644
--- a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/AbstractStateChangeLogger.java
+++ b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/AbstractStateChangeLogger.java
@@ -17,6 +17,7 @@
 
 package org.apache.flink.state.changelog;
 
+import org.apache.flink.api.common.state.StateTtlConfig;
 import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
 import org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo;
 import org.apache.flink.runtime.state.RegisteredPriorityQueueStateBackendMetaInfo;
@@ -31,6 +32,7 @@ import javax.annotation.Nullable;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.ObjectOutputStream;
 
 import static org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshot.BackendStateType.KEY_VALUE;
 import static org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshot.BackendStateType.PRIORITY_QUEUE;
@@ -52,14 +54,17 @@ abstract class AbstractStateChangeLogger<Key, Value, Ns> implements StateChangeL
     protected final RegisteredStateMetaInfoBase metaInfo;
     private final StateMetaInfoSnapshot.BackendStateType stateType;
     private boolean metaDataWritten = false;
+    private final StateTtlConfig ttlConfig;
 
     public AbstractStateChangeLogger(
             StateChangelogWriter<?> stateChangelogWriter,
             InternalKeyContext<Key> keyContext,
-            RegisteredStateMetaInfoBase metaInfo) {
+            RegisteredStateMetaInfoBase metaInfo,
+            StateTtlConfig ttlConfig) {
         this.stateChangelogWriter = checkNotNull(stateChangelogWriter);
         this.keyContext = checkNotNull(keyContext);
         this.metaInfo = checkNotNull(metaInfo);
+        this.ttlConfig = checkNotNull(ttlConfig);
         if (metaInfo instanceof RegisteredKeyValueStateBackendMetaInfo) {
             this.stateType = KEY_VALUE;
         } else if (metaInfo instanceof RegisteredPriorityQueueStateBackendMetaInfo) {
@@ -148,11 +153,21 @@ abstract class AbstractStateChangeLogger<Key, Value, Ns> implements StateChangeL
                                 out.writeInt(CURRENT_STATE_META_INFO_SNAPSHOT_VERSION);
                                 StateMetaInfoSnapshotReadersWriters.getWriter()
                                         .writeStateMetaInfoSnapshot(metaInfo.snapshot(), out);
+                                writeTtl(out);
                             }));
             metaDataWritten = true;
         }
     }
 
+    private void writeTtl(DataOutputViewStreamWrapper out) throws IOException {
+        out.writeBoolean(ttlConfig.isEnabled());
+        if (ttlConfig.isEnabled()) {
+            try (ObjectOutputStream o = new ObjectOutputStream(out)) {
+                o.writeObject(ttlConfig);
+            }
+        }
+    }
+
     private byte[] serialize(
             StateChangeOperation op,
             Ns ns,
diff --git a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/ChangelogKeyedStateBackend.java b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/ChangelogKeyedStateBackend.java
index 47700914989..2ebf0fe45d7 100644
--- a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/ChangelogKeyedStateBackend.java
+++ b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/ChangelogKeyedStateBackend.java
@@ -124,6 +124,13 @@ public class ChangelogKeyedStateBackend<K>
      */
     private final HashMap<String, InternalKvState<K, ?, ?>> keyValueStatesByName;
 
+    /**
+     * Unwrapped changelog states used for recovery (not wrapped into e.g. TTL).
+     *
+     * <p>WARN: cleared upon recovery completion.
+     */
+    private final HashMap<String, ChangelogState> changelogStates;
+
     private final HashMap<String, ChangelogKeyGroupedPriorityQueue<?>> priorityQueueStatesByName;
 
     private final ExecutionConfig executionConfig;
@@ -190,6 +197,7 @@ public class ChangelogKeyedStateBackend<K>
         this.priorityQueueStatesByName = new HashMap<>();
         this.stateChangelogWriter = stateChangelogWriter;
         this.materializedTo = stateChangelogWriter.initialSequenceNumber();
+        this.changelogStates = new HashMap<>();
         this.completeRestore(initialState);
     }
 
@@ -486,11 +494,15 @@ public class ChangelogKeyedStateBackend<K>
                         state.getValueSerializer(),
                         keyedStateBackend.getKeyContext(),
                         stateChangelogWriter,
-                        meta);
-        return stateFactory.create(
-                state,
-                kvStateChangeLogger,
-                keyedStateBackend /* pass the nested backend as key context so that it get key updates on recovery*/);
+                        meta,
+                        stateDesc.getTtlConfig());
+        IS is =
+                stateFactory.create(
+                        state,
+                        kvStateChangeLogger,
+                        keyedStateBackend /* pass the nested backend as key context so that it get key updates on recovery*/);
+        changelogStates.put(stateDesc.getName(), (ChangelogState) is);
+        return is;
     }
 
     private void completeRestore(Collection<ChangelogStateBackendHandle> stateHandles) {
@@ -504,6 +516,7 @@ public class ChangelogKeyedStateBackend<K>
                 }
             }
         }
+        changelogStates.clear();
     }
 
     @Override
@@ -525,16 +538,19 @@ public class ChangelogKeyedStateBackend<K>
      * @param type state type (the only supported type currently are: {@link
      *     BackendStateType#KEY_VALUE key value}, {@link BackendStateType#PRIORITY_QUEUE priority
      *     queue})
-     * @return an existing state, i.e. the one that was already created
+     * @return an existing state, i.e. the one that was already created. The returned state will not
+     *     apply TTL to the passed values, regardless of the TTL settings. This prevents double
+     *     applying of TTL (recovered values are TTL values if TTL was enabled). The state will,
+     *     however, use TTL serializer if TTL is enabled. WARN: only valid during the recovery.
      * @throws NoSuchElementException if the state wasn't created
      * @throws UnsupportedOperationException if state type is not supported
      */
-    public ChangelogState getExistingState(String name, BackendStateType type)
+    public ChangelogState getExistingStateForRecovery(String name, BackendStateType type)
             throws NoSuchElementException, UnsupportedOperationException {
         ChangelogState state;
         switch (type) {
             case KEY_VALUE:
-                state = (ChangelogState) keyValueStatesByName.get(name);
+                state = changelogStates.get(name);
                 break;
             case PRIORITY_QUEUE:
                 state = priorityQueueStatesByName.get(name);
diff --git a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/KvStateChangeLoggerImpl.java b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/KvStateChangeLoggerImpl.java
index b4b235074ca..2b523690ae6 100644
--- a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/KvStateChangeLoggerImpl.java
+++ b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/KvStateChangeLoggerImpl.java
@@ -17,6 +17,7 @@
 
 package org.apache.flink.state.changelog;
 
+import org.apache.flink.api.common.state.StateTtlConfig;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
 import org.apache.flink.runtime.state.RegisteredStateMetaInfoBase;
@@ -45,8 +46,9 @@ class KvStateChangeLoggerImpl<Key, Value, Ns> extends AbstractStateChangeLogger<
             TypeSerializer<Value> valueSerializer,
             InternalKeyContext<Key> keyContext,
             StateChangelogWriter<?> stateChangelogWriter,
-            RegisteredStateMetaInfoBase metaInfo) {
-        super(stateChangelogWriter, keyContext, metaInfo);
+            RegisteredStateMetaInfoBase metaInfo,
+            StateTtlConfig ttlConfig) {
+        super(stateChangelogWriter, keyContext, metaInfo, ttlConfig);
         this.keySerializer = checkNotNull(keySerializer);
         this.valueSerializer = checkNotNull(valueSerializer);
         this.namespaceSerializer = checkNotNull(namespaceSerializer);
diff --git a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/PriorityQueueStateChangeLoggerImpl.java b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/PriorityQueueStateChangeLoggerImpl.java
index c800d7aade6..b27f0307e7b 100644
--- a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/PriorityQueueStateChangeLoggerImpl.java
+++ b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/PriorityQueueStateChangeLoggerImpl.java
@@ -17,6 +17,7 @@
 
 package org.apache.flink.state.changelog;
 
+import org.apache.flink.api.common.state.StateTtlConfig;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
 import org.apache.flink.runtime.state.RegisteredPriorityQueueStateBackendMetaInfo;
@@ -36,7 +37,7 @@ class PriorityQueueStateChangeLoggerImpl<K, T> extends AbstractStateChangeLogger
             InternalKeyContext<K> keyContext,
             StateChangelogWriter<?> stateChangelogWriter,
             RegisteredPriorityQueueStateBackendMetaInfo<T> meta) {
-        super(stateChangelogWriter, keyContext, meta);
+        super(stateChangelogWriter, keyContext, meta, StateTtlConfig.DISABLED);
         this.serializer = checkNotNull(serializer);
     }
 
diff --git a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/restore/ChangelogBackendLogApplier.java b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/restore/ChangelogBackendLogApplier.java
index bd26dbb9a4c..6eb2d332109 100644
--- a/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/restore/ChangelogBackendLogApplier.java
+++ b/flink-state-backends/flink-statebackend-changelog/src/main/java/org/apache/flink/state/changelog/restore/ChangelogBackendLogApplier.java
@@ -22,9 +22,11 @@ import org.apache.flink.api.common.state.ListStateDescriptor;
 import org.apache.flink.api.common.state.MapStateDescriptor;
 import org.apache.flink.api.common.state.ReducingStateDescriptor;
 import org.apache.flink.api.common.state.StateDescriptor;
+import org.apache.flink.api.common.state.StateTtlConfig;
 import org.apache.flink.api.common.state.ValueStateDescriptor;
 import org.apache.flink.api.common.typeutils.base.ListSerializer;
 import org.apache.flink.api.common.typeutils.base.MapSerializer;
+import org.apache.flink.api.java.typeutils.runtime.DataInputViewStream;
 import org.apache.flink.core.memory.DataInputView;
 import org.apache.flink.core.memory.DataInputViewStreamWrapper;
 import org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo;
@@ -43,6 +45,7 @@ import org.slf4j.LoggerFactory;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.io.ObjectInputStream;
 
 import static org.apache.flink.runtime.state.metainfo.StateMetaInfoSnapshotReadersWriters.StateTypeHint.KEYED_STATE;
 import static org.apache.flink.state.changelog.StateChangeOperation.METADATA;
@@ -91,9 +94,10 @@ class ChangelogBackendLogApplier {
             DataInputView in, ChangelogKeyedStateBackend<?> backend, ClassLoader classLoader)
             throws Exception {
         StateMetaInfoSnapshot snapshot = readStateMetaInfoSnapshot(in, classLoader);
+        StateTtlConfig ttlConfig = readTtlConfig(in);
         switch (snapshot.getBackendStateType()) {
             case KEY_VALUE:
-                restoreKvMetaData(backend, snapshot);
+                restoreKvMetaData(backend, snapshot, ttlConfig);
                 return;
             case PRIORITY_QUEUE:
                 restorePqMetaData(backend, snapshot);
@@ -107,8 +111,25 @@ class ChangelogBackendLogApplier {
         }
     }
 
+    private static StateTtlConfig readTtlConfig(DataInputView in) throws IOException {
+        if (in.readBoolean()) {
+            try {
+                try (ObjectInputStream objectInputStream =
+                        new ObjectInputStream(new DataInputViewStream(in))) {
+                    return (StateTtlConfig) objectInputStream.readObject();
+                }
+            } catch (ClassNotFoundException e) {
+                throw new IOException(e);
+            }
+        } else {
+            return StateTtlConfig.DISABLED;
+        }
+    }
+
     private static void restoreKvMetaData(
-            ChangelogKeyedStateBackend<?> backend, StateMetaInfoSnapshot snapshot)
+            ChangelogKeyedStateBackend<?> backend,
+            StateMetaInfoSnapshot snapshot,
+            StateTtlConfig ttlConfig)
             throws Exception {
         RegisteredKeyValueStateBackendMetaInfo meta =
                 new RegisteredKeyValueStateBackendMetaInfo(snapshot);
@@ -116,7 +137,12 @@ class ChangelogBackendLogApplier {
         // persisted in log before data changes.
         // An alternative solution to load metadata "natively" by the base backends would require
         // base state to be always present, i.e. the 1st checkpoint would have to be "full" always.
-        backend.getOrCreateKeyedState(meta.getNamespaceSerializer(), toStateDescriptor(meta));
+        StateDescriptor stateDescriptor = toStateDescriptor(meta);
+        // todo: support changing ttl (FLINK-23143)
+        if (ttlConfig.isEnabled()) {
+            stateDescriptor.enableTimeToLive(ttlConfig);
+        }
+        backend.getOrCreateKeyedState(meta.getNamespaceSerializer(), stateDescriptor);
     }
 
     private static StateDescriptor toStateDescriptor(RegisteredKeyValueStateBackendMetaInfo meta) {
@@ -167,7 +193,7 @@ class ChangelogBackendLogApplier {
             throws Exception {
         String name = checkNotNull(in.readUTF());
         BackendStateType type = BackendStateType.byCode(in.readByte());
-        ChangelogState state = backend.getExistingState(name, type);
+        ChangelogState state = backend.getExistingStateForRecovery(name, type);
         StateChangeApplier changeApplier = state.getChangeApplier(factory);
         changeApplier.apply(operation, in);
     }
diff --git a/flink-state-backends/flink-statebackend-changelog/src/test/java/org/apache/flink/state/changelog/KvStateChangeLoggerImplTest.java b/flink-state-backends/flink-statebackend-changelog/src/test/java/org/apache/flink/state/changelog/KvStateChangeLoggerImplTest.java
index c52a4240959..bdb771b738a 100644
--- a/flink-state-backends/flink-statebackend-changelog/src/test/java/org/apache/flink/state/changelog/KvStateChangeLoggerImplTest.java
+++ b/flink-state-backends/flink-statebackend-changelog/src/test/java/org/apache/flink/state/changelog/KvStateChangeLoggerImplTest.java
@@ -17,6 +17,7 @@
 
 package org.apache.flink.state.changelog;
 
+import org.apache.flink.api.common.state.StateTtlConfig;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.state.RegisteredKeyValueStateBackendMetaInfo;
@@ -42,7 +43,13 @@ public class KvStateChangeLoggerImplTest extends StateChangeLoggerTestBase<Strin
                 new RegisteredKeyValueStateBackendMetaInfo<>(
                         VALUE, "test", nsSerializer, valueSerializer);
         return new KvStateChangeLoggerImpl<>(
-                keySerializer, nsSerializer, valueSerializer, keyContext, writer, metaInfo);
+                keySerializer,
+                nsSerializer,
+                valueSerializer,
+                keyContext,
+                writer,
+                metaInfo,
+                StateTtlConfig.DISABLED);
     }
 
     @Override
