diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java
index 0de200c5e45..c6fd8cf3199 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java
@@ -36,7 +36,6 @@ import java.io.Closeable;
  */
 public class NetworkActionsLogger {
     private static final Logger LOG = LoggerFactory.getLogger(NetworkActionsLogger.class);
-    private static final boolean ENABLED = LOG.isTraceEnabled();
     private static final boolean INCLUDE_HASH = true;
 
     public static void traceInput(
@@ -46,7 +45,7 @@ public class NetworkActionsLogger {
             InputChannelInfo channelInfo,
             ChannelStatePersister channelStatePersister,
             int sequenceNumber) {
-        if (ENABLED) {
+        if (LOG.isTraceEnabled()) {
             LOG.trace(
                     "[{}] {} {}, seq {}, {} @ {}",
                     taskName,
@@ -60,7 +59,7 @@ public class NetworkActionsLogger {
 
     public static void traceOutput(
             String action, Buffer buffer, String taskName, ResultSubpartitionInfo channelInfo) {
-        if (ENABLED) {
+        if (LOG.isTraceEnabled()) {
             LOG.trace(
                     "[{}] {} {} @ {}",
                     taskName,
@@ -72,7 +71,7 @@ public class NetworkActionsLogger {
 
     public static void traceRecover(
             String action, Buffer buffer, String taskName, InputChannelInfo channelInfo) {
-        if (ENABLED) {
+        if (LOG.isTraceEnabled()) {
             LOG.trace(
                     "[{}] {} {} @ {}",
                     taskName,
@@ -84,7 +83,7 @@ public class NetworkActionsLogger {
 
     public static void traceRecover(
             String action, BufferConsumer bufferConsumer, ResultSubpartitionInfo channelInfo) {
-        if (ENABLED) {
+        if (LOG.isTraceEnabled()) {
             LOG.trace(
                     "{} {} @ {}", action, bufferConsumer.toDebugString(INCLUDE_HASH), channelInfo);
         }
@@ -92,7 +91,7 @@ public class NetworkActionsLogger {
 
     public static void tracePersist(
             String action, Buffer buffer, Object channelInfo, long checkpointId) {
-        if (ENABLED) {
+        if (LOG.isTraceEnabled()) {
             LOG.trace(
                     "{} {}, checkpoint {} @ {}",
                     action,
diff --git a/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/util/LogLevelRule.java b/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/util/LogLevelRule.java
new file mode 100644
index 00000000000..bf416696101
--- /dev/null
+++ b/flink-test-utils-parent/flink-test-utils-junit/src/main/java/org/apache/flink/util/LogLevelRule.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.util;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.config.Configuration;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.apache.logging.slf4j.Log4jLogger;
+import org.junit.rules.ExternalResource;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.slf4j.event.Level;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A rule that sets the log level for specific class/package loggers for a test. Logging
+ * configuration will only be extended when logging is enabled at all (so root logger is not OFF).
+ */
+public class LogLevelRule extends ExternalResource {
+    public static final boolean LOGGING_ENABLED =
+            LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME).isErrorEnabled();
+    private Map<String, Level> testLevels = new HashMap<>();
+    private List<Runnable> resetActions = new ArrayList<>();
+    private static final Map<Level, org.apache.logging.log4j.Level> SLF_TO_LOG4J = new HashMap<>();
+    private LoggerContext log4jContext;
+
+    static {
+        SLF_TO_LOG4J.put(Level.ERROR, org.apache.logging.log4j.Level.ERROR);
+        SLF_TO_LOG4J.put(Level.WARN, org.apache.logging.log4j.Level.WARN);
+        SLF_TO_LOG4J.put(Level.INFO, org.apache.logging.log4j.Level.INFO);
+        SLF_TO_LOG4J.put(Level.DEBUG, org.apache.logging.log4j.Level.DEBUG);
+        SLF_TO_LOG4J.put(Level.TRACE, org.apache.logging.log4j.Level.TRACE);
+    }
+
+    @Override
+    public void before() throws Exception {
+        if (!LOGGING_ENABLED) {
+            return;
+        }
+
+        for (Map.Entry<String, Level> levelEntry : testLevels.entrySet()) {
+            final Logger logger = LoggerFactory.getLogger(levelEntry.getKey());
+            if (logger instanceof Log4jLogger) {
+                setLog4jLevel(levelEntry.getKey(), levelEntry.getValue());
+            } else {
+                throw new UnsupportedOperationException("Cannot change log level of " + logger);
+            }
+        }
+
+        if (log4jContext != null) {
+            log4jContext.updateLoggers();
+        }
+    }
+
+    private void setLog4jLevel(String logger, Level level) {
+        if (log4jContext == null) {
+            log4jContext = (LoggerContext) LogManager.getContext(false);
+        }
+        final Configuration conf = log4jContext.getConfiguration();
+        LoggerConfig loggerConfig = conf.getLoggers().get(logger);
+        if (loggerConfig != null) {
+            final org.apache.logging.log4j.Level oldLevel = loggerConfig.getLevel();
+            loggerConfig.setLevel(SLF_TO_LOG4J.get(level));
+            resetActions.add(() -> loggerConfig.setLevel(oldLevel));
+        } else {
+            conf.addLogger(logger, new LoggerConfig(logger, SLF_TO_LOG4J.get(level), true));
+            resetActions.add(() -> conf.removeLogger(logger));
+        }
+    }
+
+    @Override
+    public void after() {
+        resetActions.forEach(Runnable::run);
+
+        if (log4jContext != null) {
+            log4jContext.updateLoggers();
+        }
+    }
+
+    public LogLevelRule set(Class<?> clazz, Level level) {
+        return set(clazz.getName(), level);
+    }
+
+    public LogLevelRule set(Package logPackage, Level level) {
+        return set(logPackage.getName(), level);
+    }
+
+    public LogLevelRule set(String classOrPackageName, Level level) {
+        testLevels.put(classOrPackageName, level);
+        return this;
+    }
+}
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
index 180a5891c8b..d5825d1947a 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
@@ -49,6 +49,7 @@ import org.apache.flink.configuration.TaskManagerOptions;
 import org.apache.flink.core.io.InputStatus;
 import org.apache.flink.core.io.SimpleVersionedSerializer;
 import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;
 import org.apache.flink.runtime.jobgraph.SavepointConfigOptions;
 import org.apache.flink.runtime.state.FunctionInitializationContext;
 import org.apache.flink.runtime.state.FunctionSnapshotContext;
@@ -60,17 +61,20 @@ import org.apache.flink.streaming.api.functions.co.RichCoFlatMapFunction;
 import org.apache.flink.streaming.api.functions.sink.RichSinkFunction;
 import org.apache.flink.testutils.junit.FailsWithAdaptiveScheduler;
 import org.apache.flink.util.Collector;
+import org.apache.flink.util.LogLevelRule;
 import org.apache.flink.util.TestLogger;
 
 import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;
 import org.apache.flink.shaded.netty4.io.netty.util.internal.PlatformDependent;
 
+import org.junit.ClassRule;
 import org.junit.Rule;
 import org.junit.experimental.categories.Category;
 import org.junit.rules.ErrorCollector;
 import org.junit.rules.TemporaryFolder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.slf4j.event.Level;
 
 import javax.annotation.Nullable;
 
@@ -115,6 +119,10 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 
     @Rule public ErrorCollector collector = new ErrorCollector();
 
+    @ClassRule
+    public static final LogLevelRule NETWORK_LOGGER =
+            new LogLevelRule().set(NetworkActionsLogger.class, Level.TRACE);
+
     @Nullable
     protected File execute(UnalignedSettings settings) throws Exception {
         final File checkpointDir = temp.newFolder();
