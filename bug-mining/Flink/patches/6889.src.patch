diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/optimize/StreamNonDeterministicUpdatePlanVisitor.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/optimize/StreamNonDeterministicUpdatePlanVisitor.java
index 9aff0a7a014..c4c569c82b7 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/optimize/StreamNonDeterministicUpdatePlanVisitor.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/plan/optimize/StreamNonDeterministicUpdatePlanVisitor.java
@@ -259,8 +259,7 @@ public class StreamNonDeterministicUpdatePlanVisitor {
                 // check if it is a non-deterministic function
                 int leftFieldCnt = correlate.inputRel().getRowType().getFieldCount();
                 Optional<String> ndCall =
-                        FlinkRexUtil.getNonDeterministicCallNameInStreaming(
-                                correlate.scan().getCall());
+                        FlinkRexUtil.getNonDeterministicCallName(correlate.scan().getCall());
                 if (ndCall.isPresent()) {
                     // all columns from table function scan cannot satisfy the required determinism
                     List<Integer> unsatisfiedColumns =
@@ -478,8 +477,7 @@ public class StreamNonDeterministicUpdatePlanVisitor {
              * PROCTIME_MATERIALIZE(PROCTIME())) is equal to a normal dynamic temporal function and
              * will be validated in calc node.
              */
-            Optional<String> ndCall =
-                    FlinkRexUtil.getNonDeterministicCallNameInStreaming(join.getCondition());
+            Optional<String> ndCall = FlinkRexUtil.getNonDeterministicCallName(join.getCondition());
             if ((leftInputHasUpdate || rightInputHasUpdate || !innerOrSemi) && ndCall.isPresent()) {
                 // when output has update, the join condition cannot be non-deterministic:
                 // 1. input has update -> output has update
@@ -783,8 +781,7 @@ public class StreamNonDeterministicUpdatePlanVisitor {
                         .collect(Collectors.toList());
         Map<Integer, String> nonDeterministicCols = new HashMap<>();
         for (int index = 0; index < projects.size(); index++) {
-            Optional<String> ndCall =
-                    FlinkRexUtil.getNonDeterministicCallNameInStreaming(projects.get(index));
+            Optional<String> ndCall = FlinkRexUtil.getNonDeterministicCallName(projects.get(index));
             if (ndCall.isPresent()) {
                 nonDeterministicCols.put(index, ndCall.get());
             } // else ignore
@@ -805,7 +802,7 @@ public class StreamNonDeterministicUpdatePlanVisitor {
 
     private void checkNonDeterministicCondition(
             final RexNode condition, final StreamPhysicalRel relatedRel) {
-        Optional<String> ndCall = FlinkRexUtil.getNonDeterministicCallNameInStreaming(condition);
+        Optional<String> ndCall = FlinkRexUtil.getNonDeterministicCallName(condition);
         if (ndCall.isPresent()) {
             throwNonDeterministicConditionError(ndCall.get(), condition, relatedRel);
         }
@@ -923,7 +920,6 @@ public class StreamNonDeterministicUpdatePlanVisitor {
             Arrays.stream(overSpec.getPartition().getFieldIndices())
                     .forEach(allRequiredInputSet::add);
             // add aggCall's input
-            overSpec.getGroups().forEach(OverSpec.GroupSpec::getAggCalls);
             int aggOutputIndex = inputFieldCnt;
             for (OverSpec.GroupSpec groupSpec : overSpec.getGroups()) {
                 for (AggregateCall aggCall : groupSpec.getAggCalls()) {
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUpsertKeys.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUpsertKeys.scala
index d493968d3f7..449be9f42e4 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUpsertKeys.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/metadata/FlinkRelMdUpsertKeys.scala
@@ -32,7 +32,7 @@ import org.apache.calcite.plan.volcano.RelSubset
 import org.apache.calcite.rel.{RelDistribution, RelNode, SingleRel}
 import org.apache.calcite.rel.core.{Aggregate, Calc, Exchange, Filter, Join, JoinInfo, JoinRelType, Project, SetOp, Sort, TableScan, Window}
 import org.apache.calcite.rel.metadata._
-import org.apache.calcite.rex.RexNode
+import org.apache.calcite.rex.{RexNode, RexUtil}
 import org.apache.calcite.util.{Bug, ImmutableBitSet, Util}
 
 import java.util
@@ -237,9 +237,9 @@ class FlinkRelMdUpsertKeys private extends MetadataHandler[UpsertKeys] {
     val rightUniqueKeys = FlinkRelMdUniqueKeys.INSTANCE.getUniqueKeysOfTemporalTable(join)
 
     val remainingConditionNonDeterministic =
-      join.remainingCondition.exists(c => !FlinkRexUtil.isDeterministicInStreaming(c))
+      join.remainingCondition.exists(c => !RexUtil.isDeterministic(c))
     lazy val calcOnTemporalTableNonDeterministic =
-      join.calcOnTemporalTable.exists(p => !FlinkRexUtil.isDeterministicInStreaming(p))
+      join.calcOnTemporalTable.exists(p => !FlinkRexUtil.isDeterministic(p))
 
     val rightUpsertKeys =
       if (remainingConditionNonDeterministic || calcOnTemporalTableNonDeterministic) {
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala
index dba27b0eb2e..4cca5d8b139 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRexUtil.scala
@@ -590,23 +590,13 @@ object FlinkRexUtil {
   }
 
   /**
-   * Returns whether a given expression is deterministic in streaming scenario, differs from
-   * calcite's [[RexUtil]], it considers both non-deterministic and dynamic functions.
+   * Returns the non-deterministic call name for a given expression. Use java [[Optional]] for
+   * scala-free goal.
    */
-  def isDeterministicInStreaming(e: RexNode): Boolean = {
-    !getNonDeterministicCallNameInStreaming(e).isPresent
-  }
-
-  /**
-   * Returns the non-deterministic call name for a given expression in streaming scenario, differs
-   * from calcite's [[RexUtil]], it considers both non-deterministic and dynamic functions. Use java
-   * [[Optional]] for scala-free goal.
-   */
-  def getNonDeterministicCallNameInStreaming(e: RexNode): Optional[String] = try {
+  def getNonDeterministicCallName(e: RexNode): Optional[String] = try {
     val visitor = new RexVisitorImpl[Void](true) {
       override def visitCall(call: RexCall): Void = {
-        // dynamic function call is also non-deterministic to streaming
-        if (!call.getOperator.isDeterministic || call.getOperator.isDynamicFunction) {
+        if (!call.getOperator.isDeterministic) {
           throw new Util.FoundOne(call.getOperator.getName)
         }
         super.visitCall(call)
@@ -621,20 +611,19 @@ object FlinkRexUtil {
   }
 
   /**
-   * Returns whether a given [[RexProgram]] is deterministic in streaming scenario, differs from
-   * calcite's [[RexUtil]], it considers both non-deterministic and dynamic functions.
+   * Returns whether a given [[RexProgram]] is deterministic.
    * @return
-   *   true if any expression of the program is not deterministic in streaming
+   *   false if any expression of the program is not deterministic
    */
-  def isDeterministicInStreaming(rexProgram: RexProgram): Boolean = try {
+  def isDeterministic(rexProgram: RexProgram): Boolean = try {
     if (null != rexProgram.getCondition) {
       val rexCondi = rexProgram.expandLocalRef(rexProgram.getCondition)
-      if (!isDeterministicInStreaming(rexCondi)) {
+      if (!RexUtil.isDeterministic(rexCondi)) {
         return false
       }
     }
     val projects = rexProgram.getProjectList.map(rexProgram.expandLocalRef)
-    projects.forall(isDeterministicInStreaming)
+    projects.forall(RexUtil.isDeterministic)
   }
 
   /**
