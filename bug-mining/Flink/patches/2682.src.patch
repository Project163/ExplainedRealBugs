diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NetworkEnvironment.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NetworkEnvironment.java
index 1363175e96e..d124456c213 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NetworkEnvironment.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/NetworkEnvironment.java
@@ -43,6 +43,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
+import java.util.Optional;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
@@ -233,8 +234,12 @@ public class NetworkEnvironment {
 			int maxNumberOfMemorySegments = partition.getPartitionType().isBounded() ?
 				partition.getNumberOfSubpartitions() * networkBuffersPerChannel +
 					extraNetworkBuffersPerGate : Integer.MAX_VALUE;
+			// If the partition type is back pressure-free, we register with the buffer pool for
+			// callbacks to release memory.
 			bufferPool = networkBufferPool.createBufferPool(partition.getNumberOfSubpartitions(),
-				maxNumberOfMemorySegments);
+				maxNumberOfMemorySegments,
+				partition.getPartitionType().hasBackPressure() ? Optional.empty() : Optional.of(partition));
+
 			partition.registerBufferPool(bufferPool);
 
 			resultPartitionManager.registerResultPartition(partition);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPool.java
index 2927fae1069..511eb65019e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPool.java
@@ -25,12 +25,6 @@ import java.io.IOException;
  */
 public interface BufferPool extends BufferProvider, BufferRecycler {
 
-	/**
-	 * The owner of this buffer pool to be called when memory needs to be released to avoid back
-	 * pressure.
-	 */
-	void setBufferPoolOwner(BufferPoolOwner owner);
-
 	/**
 	 * Destroys this buffer pool.
 	 *
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java
index c90e3025237..de4c8e09e11 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferPoolFactory.java
@@ -19,6 +19,7 @@
 package org.apache.flink.runtime.io.network.buffer;
 
 import java.io.IOException;
+import java.util.Optional;
 
 /**
  * A factory for buffer pools.
@@ -38,6 +39,21 @@ public interface BufferPoolFactory {
 	 */
 	BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers) throws IOException;
 
+	/**
+	 * Tries to create a buffer pool with an optional owner, which is guaranteed to provide at least the
+	 * number of required buffers.
+	 *
+	 * <p>The buffer pool is of dynamic size with at least <tt>numRequiredBuffers</tt> buffers.
+	 *
+	 * @param numRequiredBuffers
+	 * 		minimum number of network buffers in this pool
+	 * @param maxUsedBuffers
+	 * 		maximum number of network buffers this pool offers
+	 * 	@param owner
+	 * 	    the optional owner of this buffer pool to release memory when needed
+	 */
+	BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers, Optional<BufferPoolOwner> owner) throws IOException;
+
 	/**
 	 * Destroy callback for updating factory book keeping.
 	 */
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
index 1596fded6f3..d7bfb603eaf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
@@ -26,10 +26,9 @@ import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.util.ArrayDeque;
+import java.util.Optional;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
-import static org.apache.flink.util.Preconditions.checkNotNull;
-import static org.apache.flink.util.Preconditions.checkState;
 
 /**
  * A buffer pool used to manage a number of {@link Buffer} instances from the
@@ -86,7 +85,7 @@ class LocalBufferPool implements BufferPool {
 
 	private boolean isDestroyed;
 
-	private BufferPoolOwner owner;
+	private final Optional<BufferPoolOwner> owner;
 
 	/**
 	 * Local buffer pool based on the given <tt>networkBufferPool</tt> with a minimal number of
@@ -98,7 +97,7 @@ class LocalBufferPool implements BufferPool {
 	 * 		minimum number of network buffers
 	 */
 	LocalBufferPool(NetworkBufferPool networkBufferPool, int numberOfRequiredMemorySegments) {
-		this(networkBufferPool, numberOfRequiredMemorySegments, Integer.MAX_VALUE);
+		this(networkBufferPool, numberOfRequiredMemorySegments, Integer.MAX_VALUE, Optional.empty());
 	}
 
 	/**
@@ -114,6 +113,27 @@ class LocalBufferPool implements BufferPool {
 	 */
 	LocalBufferPool(NetworkBufferPool networkBufferPool, int numberOfRequiredMemorySegments,
 			int maxNumberOfMemorySegments) {
+		this(networkBufferPool, numberOfRequiredMemorySegments, maxNumberOfMemorySegments, Optional.empty());
+	}
+
+	/**
+	 * Local buffer pool based on the given <tt>networkBufferPool</tt> and <tt>bufferPoolOwner</tt>
+	 * with a minimal and maximal number of network buffers being available.
+	 *
+	 * @param networkBufferPool
+	 * 		global network buffer pool to get buffers from
+	 * @param numberOfRequiredMemorySegments
+	 * 		minimum number of network buffers
+	 * @param maxNumberOfMemorySegments
+	 * 		maximum number of network buffers to allocate
+	 * 	@param owner
+	 * 		the optional owner of this buffer pool to release memory when needed
+	 */
+	LocalBufferPool(
+		NetworkBufferPool networkBufferPool,
+		int numberOfRequiredMemorySegments,
+		int maxNumberOfMemorySegments,
+		Optional<BufferPoolOwner> owner) {
 		checkArgument(maxNumberOfMemorySegments >= numberOfRequiredMemorySegments,
 			"Maximum number of memory segments (%s) should not be smaller than minimum (%s).",
 			maxNumberOfMemorySegments, numberOfRequiredMemorySegments);
@@ -129,6 +149,7 @@ class LocalBufferPool implements BufferPool {
 		this.numberOfRequiredMemorySegments = numberOfRequiredMemorySegments;
 		this.currentPoolSize = numberOfRequiredMemorySegments;
 		this.maxNumberOfMemorySegments = maxNumberOfMemorySegments;
+		this.owner = owner;
 	}
 
 	// ------------------------------------------------------------------------
@@ -176,14 +197,6 @@ class LocalBufferPool implements BufferPool {
 		return Math.max(0, numberOfRequestedMemorySegments - availableMemorySegments.size());
 	}
 
-	@Override
-	public void setBufferPoolOwner(BufferPoolOwner owner) {
-		synchronized (availableMemorySegments) {
-			checkState(this.owner == null, "Buffer pool owner has already been set.");
-			this.owner = checkNotNull(owner);
-		}
-	}
-
 	@Override
 	public Buffer requestBuffer() throws IOException {
 		try {
@@ -222,7 +235,7 @@ class LocalBufferPool implements BufferPool {
 		synchronized (availableMemorySegments) {
 			returnExcessMemorySegments();
 
-			boolean askToRecycle = owner != null;
+			boolean askToRecycle = owner.isPresent();
 
 			// fill availableMemorySegments with at least one element, wait if required
 			while (availableMemorySegments.isEmpty()) {
@@ -240,7 +253,7 @@ class LocalBufferPool implements BufferPool {
 				}
 
 				if (askToRecycle) {
-					owner.releaseMemory(1);
+					owner.get().releaseMemory(1);
 				}
 
 				if (isBlocking) {
@@ -336,6 +349,7 @@ class LocalBufferPool implements BufferPool {
 
 	@Override
 	public void setNumBuffers(int numBuffers) throws IOException {
+		int numExcessBuffers;
 		synchronized (availableMemorySegments) {
 			checkArgument(numBuffers >= numberOfRequiredMemorySegments,
 					"Buffer pool needs at least %s buffers, but tried to set to %s",
@@ -349,11 +363,13 @@ class LocalBufferPool implements BufferPool {
 
 			returnExcessMemorySegments();
 
-			// If there is a registered owner and we have still requested more buffers than our
-			// size, trigger a recycle via the owner.
-			if (owner != null && numberOfRequestedMemorySegments > currentPoolSize) {
-				owner.releaseMemory(numberOfRequestedMemorySegments - currentPoolSize);
-			}
+			numExcessBuffers = numberOfRequestedMemorySegments - currentPoolSize;
+		}
+
+		// If there is a registered owner and we have still requested more buffers than our
+		// size, trigger a recycle via the owner.
+		if (owner.isPresent() && numExcessBuffers > 0) {
+			owner.get().releaseMemory(numExcessBuffers);
 		}
 	}
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
index 1fddb612781..48ce27e90b1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java
@@ -33,6 +33,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -253,6 +254,11 @@ public class NetworkBufferPool implements BufferPoolFactory {
 
 	@Override
 	public BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers) throws IOException {
+		return createBufferPool(numRequiredBuffers, maxUsedBuffers, Optional.empty());
+	}
+
+	@Override
+	public BufferPool createBufferPool(int numRequiredBuffers, int maxUsedBuffers, Optional<BufferPoolOwner> owner) throws IOException {
 		// It is necessary to use a separate lock from the one used for buffer
 		// requests to ensure deadlock freedom for failure cases.
 		synchronized (factoryLock) {
@@ -281,7 +287,7 @@ public class NetworkBufferPool implements BufferPoolFactory {
 			// We are good to go, create a new buffer pool and redistribute
 			// non-fixed size buffers.
 			LocalBufferPool localBufferPool =
-				new LocalBufferPool(this, numRequiredBuffers, maxUsedBuffers);
+				new LocalBufferPool(this, numRequiredBuffers, maxUsedBuffers, owner);
 
 			allBufferPools.add(localBufferPool);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartition.java
index b32f73f8bcc..85fc5602ef3 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartition.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartition.java
@@ -187,12 +187,6 @@ public class ResultPartition implements ResultPartitionWriter, BufferPoolOwner {
 		checkState(this.bufferPool == null, "Bug in result partition setup logic: Already registered buffer pool.");
 
 		this.bufferPool = checkNotNull(bufferPool);
-
-		// If the partition type is back pressure-free, we register with the buffer pool for
-		// callbacks to release memory.
-		if (!partitionType.hasBackPressure()) {
-			bufferPool.setBufferPoolOwner(this);
-		}
 	}
 
 	public JobID getJobId() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
index 8d6be0c4ac8..4e8eec696fc 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
@@ -31,6 +31,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Optional;
 
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.nullValue;
@@ -323,11 +324,11 @@ public class NetworkBufferPoolTest extends TestLogger {
 
 		final List<Buffer> buffers = new ArrayList<>(numBuffers);
 		List<MemorySegment> memorySegments = Collections.emptyList();
-		BufferPool bufferPool = networkBufferPool.createBufferPool(1, numBuffers);
-		// make releaseMemory calls always fail:
-		bufferPool.setBufferPoolOwner(numBuffersToRecycle -> {
-			throw new TestIOException();
-		});
+		BufferPool bufferPool = networkBufferPool.createBufferPool(1, numBuffers,
+			// make releaseMemory calls always fail:
+			Optional.of(numBuffersToRecycle -> {
+				throw new TestIOException();
+		}));
 
 		try {
 			// take all but one buffer
@@ -363,11 +364,10 @@ public class NetworkBufferPoolTest extends TestLogger {
 		final NetworkBufferPool networkBufferPool = new NetworkBufferPool(numBuffers, 128);
 
 		final List<Buffer> buffers = new ArrayList<>(numBuffers);
-		BufferPool bufferPool = networkBufferPool.createBufferPool(1, numBuffers);
-		bufferPool.setBufferPoolOwner(
-			numBuffersToRecycle -> {
+		BufferPool bufferPool = networkBufferPool.createBufferPool(1, numBuffers,
+			Optional.of(numBuffersToRecycle -> {
 				throw new TestIOException();
-			});
+		}));
 
 		try {
 
