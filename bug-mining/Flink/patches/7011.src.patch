diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
index bb14a7d69c5..87b8a11e2aa 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
@@ -51,8 +51,8 @@ import static org.apache.flink.util.concurrent.FutureUtils.assertNoException;
  * will then lazily return the required number of buffers to the {@link NetworkBufferPool} to match
  * its new size.
  *
- * <p>Availability is defined as returning a segment on a subsequent {@link #requestBuffer()}/
- * {@link #requestBufferBuilder()} and heaving a non-blocking {@link
+ * <p>Availability is defined as returning a non-overdraft segment on a subsequent {@link
+ * #requestBuffer()}/ {@link #requestBufferBuilder()} and heaving a non-blocking {@link
  * #requestBufferBuilderBlocking(int)}. In particular,
  *
  * <ul>
@@ -392,14 +392,16 @@ class LocalBufferPool implements BufferPool {
 
     @Nullable
     private MemorySegment requestMemorySegment(int targetChannel) {
-        MemorySegment segment;
+        MemorySegment segment = null;
         synchronized (availableMemorySegments) {
             checkDestroyed();
 
-            if (availableMemorySegments.isEmpty()) {
-                segment = requestOverdraftMemorySegmentFromGlobal();
-            } else {
+            if (!availableMemorySegments.isEmpty()) {
                 segment = availableMemorySegments.poll();
+            } else if (isRequestedSizeReached()) {
+                // Only when the buffer request reaches the upper limit(i.e. current pool size),
+                // requests an overdraft buffer.
+                segment = requestOverdraftMemorySegmentFromGlobal();
             }
 
             if (segment == null) {
@@ -669,6 +671,13 @@ class LocalBufferPool implements BufferPool {
 
             currentPoolSize = Math.min(numBuffers, maxNumberOfMemorySegments);
 
+            // reset overdraft buffers
+            while (numberOfRequestedOverdraftMemorySegments > 0
+                    && numberOfRequestedMemorySegments < currentPoolSize) {
+                numberOfRequestedOverdraftMemorySegments--;
+                numberOfRequestedMemorySegments++;
+            }
+
             returnExcessMemorySegments();
 
             if (isDestroyed) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
index c677cd4905f..956d55e5948 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
@@ -38,8 +38,10 @@ import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
@@ -249,15 +251,187 @@ class LocalBufferPoolTest {
         }
     }
 
+    @Test
+    void testDecreasePoolSize() throws Exception {
+        final int maxMemorySegments = 10;
+        final int requiredMemorySegments = 4;
+        final int maxOverdraftBuffers = 2;
+        final int largePoolSize = 5;
+        final int smallPoolSize = 4;
+        LocalBufferPool bufferPool =
+                new LocalBufferPool(
+                        networkBufferPool,
+                        requiredMemorySegments,
+                        maxMemorySegments,
+                        0,
+                        Integer.MAX_VALUE,
+                        maxOverdraftBuffers);
+        Queue<MemorySegment> buffers = new LinkedList<>();
+
+        // set a larger pool size.
+        bufferPool.setNumBuffers(largePoolSize);
+        assertThat(bufferPool.getNumBuffers()).isEqualTo(largePoolSize);
+
+        // request all buffer.
+        for (int i = 0; i < largePoolSize; i++) {
+            buffers.add(bufferPool.requestMemorySegmentBlocking());
+        }
+        assertThat(bufferPool.isAvailable()).isFalse();
+
+        // request 1 overdraft buffers.
+        buffers.add(bufferPool.requestMemorySegmentBlocking());
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments()).isOne();
+        assertThat(bufferPool.isAvailable()).isFalse();
+
+        // set a small pool size.
+        bufferPool.setNumBuffers(smallPoolSize);
+        assertThat(bufferPool.getNumBuffers()).isEqualTo(smallPoolSize);
+        assertThat(bufferPool.getNumberOfAvailableMemorySegments()).isZero();
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments()).isOne();
+        assertThat(bufferPool.isAvailable()).isFalse();
+        buffers.add(bufferPool.requestMemorySegmentBlocking());
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments()).isEqualTo(2);
+        assertThat(bufferPool.isAvailable()).isFalse();
+
+        // return all overdraft buffers.
+        bufferPool.recycle(buffers.poll());
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments()).isOne();
+        assertThat(bufferPool.isAvailable()).isFalse();
+        bufferPool.recycle(buffers.poll());
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments()).isZero();
+        assertThat(bufferPool.isAvailable()).isFalse();
+
+        // return the excess buffer.
+        bufferPool.recycle(buffers.poll());
+        assertThat(bufferPool.isAvailable()).isFalse();
+        // return non-excess buffers.
+        bufferPool.recycle(buffers.poll());
+        assertThat(bufferPool.getNumberOfAvailableMemorySegments()).isOne();
+        assertThat(bufferPool.isAvailable()).isTrue();
+
+        while (!buffers.isEmpty()) {
+            bufferPool.recycle(buffers.poll());
+        }
+        bufferPool.lazyDestroy();
+    }
+
+    @Test
+    void testIncreasePoolSize() throws Exception {
+        final int maxMemorySegments = 100;
+        final int requiredMemorySegments = 5;
+        final int smallPoolSize = 5;
+        final int maxOverdraftBuffers = 2;
+        // test increase pool size not exceed total buffers.
+        testIncreasePoolSizeInternal(
+                maxMemorySegments,
+                requiredMemorySegments,
+                smallPoolSize,
+                6,
+                maxOverdraftBuffers,
+                1,
+                0,
+                false);
+        // test increase pool size to total buffers.
+        testIncreasePoolSizeInternal(
+                maxMemorySegments,
+                requiredMemorySegments,
+                smallPoolSize,
+                7,
+                maxOverdraftBuffers,
+                0,
+                0,
+                false);
+        // test increase pool size exceed total buffers.
+        testIncreasePoolSizeInternal(
+                maxMemorySegments,
+                requiredMemorySegments,
+                smallPoolSize,
+                8,
+                maxOverdraftBuffers,
+                0,
+                1,
+                true);
+        // test increase pool size exceed total buffers and reach maxMemorySegments.
+        testIncreasePoolSizeInternal(10, 8, 8, 10, maxOverdraftBuffers, 0, 0, false);
+    }
+
+    void testIncreasePoolSizeInternal(
+            int maxMemorySegments,
+            int requiredMemorySegments,
+            int smallPoolSize,
+            int largePoolSize,
+            int maxOverdraftBuffers,
+            int numOverdraftBuffersAfterIncreasePoolSize,
+            int numAvailableBuffersAfterIncreasePoolSize,
+            boolean isAvailableAfterIncreasePoolSize)
+            throws Exception {
+        LocalBufferPool bufferPool =
+                new LocalBufferPool(
+                        networkBufferPool,
+                        requiredMemorySegments,
+                        maxMemorySegments,
+                        0,
+                        Integer.MAX_VALUE,
+                        maxOverdraftBuffers);
+        List<MemorySegment> buffers = new ArrayList<>();
+
+        // set a small pool size.
+        bufferPool.setNumBuffers(smallPoolSize);
+        assertThat(bufferPool.getNumBuffers()).isEqualTo(smallPoolSize);
+
+        // request all buffer.
+        for (int i = 0; i < smallPoolSize; i++) {
+            buffers.add(bufferPool.requestMemorySegmentBlocking());
+        }
+        assertThat(bufferPool.isAvailable()).isFalse();
+
+        // request all overdraft buffers.
+        for (int i = 0; i < maxOverdraftBuffers; i++) {
+            buffers.add(bufferPool.requestMemorySegmentBlocking());
+        }
+        assertThat(bufferPool.requestMemorySegment()).isNull();
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments())
+                .isEqualTo(maxOverdraftBuffers);
+        assertThat(bufferPool.isAvailable()).isFalse();
+
+        // set a large pool size.
+        bufferPool.setNumBuffers(largePoolSize);
+        assertThat(bufferPool.getNumBuffers()).isEqualTo(largePoolSize);
+        assertThat(bufferPool.getNumberOfAvailableMemorySegments())
+                .isEqualTo(numAvailableBuffersAfterIncreasePoolSize);
+        assertThat(bufferPool.getNumberOfRequestedOverdraftMemorySegments())
+                .isEqualTo(numOverdraftBuffersAfterIncreasePoolSize);
+        assertThat(bufferPool.isAvailable()).isEqualTo(isAvailableAfterIncreasePoolSize);
+
+        for (MemorySegment buffer : buffers) {
+            bufferPool.recycle(buffer);
+        }
+        bufferPool.lazyDestroy();
+    }
+
     @Test
     @Timeout(30)
-    void testRequestBuffersOnRecycle() throws Exception {
-        BufferPool bufferPool1 = networkBufferPool.createBufferPool(512, 2048);
+    void testRequestBufferOnRecycleWithOverdraft() throws Exception {
+        testRequestBuffersOnRecycle(true);
+    }
+
+    @Test
+    @Timeout(30)
+    void testRequestBufferOnRecycleWithoutOverdraft() throws Exception {
+        testRequestBuffersOnRecycle(false);
+    }
+
+    private void testRequestBuffersOnRecycle(boolean supportOverdraftBuffer) throws Exception {
+        BufferPool bufferPool1 =
+                networkBufferPool.createBufferPool(
+                        512, 2048, 0, Integer.MAX_VALUE, supportOverdraftBuffer ? 5 : 0);
         List<MemorySegment> segments = new ArrayList<>();
         for (int i = 0; i < 1023; i++) {
             segments.add(bufferPool1.requestMemorySegmentBlocking());
         }
-        BufferPool bufferPool2 = networkBufferPool.createBufferPool(512, 512);
+        BufferPool bufferPool2 =
+                networkBufferPool.createBufferPool(
+                        512, 512, 0, Integer.MAX_VALUE, supportOverdraftBuffer ? 5 : 0);
         List<MemorySegment> segments2 = new ArrayList<>();
         CheckedThread checkedThread =
                 new CheckedThread() {
