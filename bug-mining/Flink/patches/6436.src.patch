diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/HeapBroadcastState.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/HeapBroadcastState.java
index 14e72f4cfdd..78ff61945b4 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/HeapBroadcastState.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/HeapBroadcastState.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.state;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.state.BroadcastState;
 import org.apache.flink.api.common.typeutils.base.MapSerializer;
 import org.apache.flink.core.fs.FSDataOutputStream;
@@ -46,7 +47,7 @@ public class HeapBroadcastState<K, V> implements BackendWritableBroadcastState<K
     private final Map<K, V> backingMap;
 
     /** A serializer that allows to perform deep copies of internal map state. */
-    private final MapSerializer<K, V> internalMapCopySerializer;
+    private MapSerializer<K, V> internalMapCopySerializer;
 
     HeapBroadcastState(RegisteredBroadcastStateBackendMetaInfo<K, V> stateMetaInfo) {
         this(stateMetaInfo, new HashMap<>());
@@ -71,6 +72,9 @@ public class HeapBroadcastState<K, V> implements BackendWritableBroadcastState<K
 
     @Override
     public void setStateMetaInfo(RegisteredBroadcastStateBackendMetaInfo<K, V> stateMetaInfo) {
+        this.internalMapCopySerializer =
+                new MapSerializer<>(
+                        stateMetaInfo.getKeySerializer(), stateMetaInfo.getValueSerializer());
         this.stateMetaInfo = stateMetaInfo;
     }
 
@@ -154,4 +158,9 @@ public class HeapBroadcastState<K, V> implements BackendWritableBroadcastState<K
     public Iterable<Map.Entry<K, V>> immutableEntries() {
         return Collections.unmodifiableSet(backingMap.entrySet());
     }
+
+    @VisibleForTesting
+    public MapSerializer<K, V> getInternalMapCopySerializer() {
+        return internalMapCopySerializer;
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/PartitionableListState.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/PartitionableListState.java
index 12ef958a8f8..7cb363b91c3 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/PartitionableListState.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/PartitionableListState.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.state;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.state.ListState;
 import org.apache.flink.core.fs.FSDataOutputStream;
 import org.apache.flink.core.memory.DataOutputView;
@@ -42,7 +43,7 @@ public final class PartitionableListState<S> implements ListState<S> {
     private final ArrayList<S> internalList;
 
     /** A typeSerializer that allows to perform deep copies of internalList */
-    private final ArrayListSerializer<S> internalListCopySerializer;
+    private ArrayListSerializer<S> internalListCopySerializer;
 
     PartitionableListState(RegisteredOperatorStateBackendMetaInfo<S> stateMetaInfo) {
         this(stateMetaInfo, new ArrayList<S>());
@@ -65,6 +66,8 @@ public final class PartitionableListState<S> implements ListState<S> {
     }
 
     public void setStateMetaInfo(RegisteredOperatorStateBackendMetaInfo<S> stateMetaInfo) {
+        this.internalListCopySerializer =
+                new ArrayListSerializer<>(stateMetaInfo.getPartitionStateSerializer());
         this.stateMetaInfo = stateMetaInfo;
     }
 
@@ -130,4 +133,9 @@ public final class PartitionableListState<S> implements ListState<S> {
             internalList.addAll(values);
         }
     }
+
+    @VisibleForTesting
+    public ArrayListSerializer<S> getInternalListCopySerializer() {
+        return internalListCopySerializer;
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java
index 733f39da47d..aafab4a5f2d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/StateBackendMigrationTestBase.java
@@ -29,6 +29,7 @@ import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.TypeSerializerSchemaCompatibility;
 import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;
 import org.apache.flink.api.common.typeutils.base.IntSerializer;
+import org.apache.flink.api.common.typeutils.base.MapSerializer;
 import org.apache.flink.core.fs.CloseableRegistry;
 import org.apache.flink.core.memory.DataInputView;
 import org.apache.flink.core.memory.DataOutputView;
@@ -853,6 +854,16 @@ public abstract class StateBackendMigrationTestBase<B extends AbstractStateBacke
             state = backend.getListState(newAccessDescriptorAfterRestore);
 
             // make sure that reading and writing each state partition works with the new serializer
+            TypeSerializer internalListCopySerializer =
+                    ((PartitionableListState<?>) state)
+                            .getInternalListCopySerializer()
+                            .getElementSerializer();
+            TypeSerializer previousSerializer = initialAccessDescriptor.getElementSerializer();
+            TypeSerializer newSerializerForRestoredState =
+                    newAccessDescriptorAfterRestore.getElementSerializer();
+            internalCopySerializerTest(
+                    previousSerializer, newSerializerForRestoredState, internalListCopySerializer);
+
             Iterator<TestType> iterator = state.get().iterator();
             assertEquals(new TestType("foo", 13), iterator.next());
             assertEquals(new TestType("bar", 278), iterator.next());
@@ -941,6 +952,17 @@ public abstract class StateBackendMigrationTestBase<B extends AbstractStateBacke
             // the state backend should have decided whether or not it needs to perform state
             // migration;
             // make sure that reading and writing each state partition works with the new serializer
+
+            TypeSerializer internalListCopySerializer =
+                    ((PartitionableListState<?>) state)
+                            .getInternalListCopySerializer()
+                            .getElementSerializer();
+            TypeSerializer previousSerializer = initialAccessDescriptor.getElementSerializer();
+            TypeSerializer newSerializerForRestoredState =
+                    newAccessDescriptorAfterRestore.getElementSerializer();
+            internalCopySerializerTest(
+                    previousSerializer, newSerializerForRestoredState, internalListCopySerializer);
+
             Iterator<TestType> iterator = state.get().iterator();
             assertEquals(new TestType("foo", 13), iterator.next());
             assertEquals(new TestType("bar", 278), iterator.next());
@@ -1084,6 +1106,19 @@ public abstract class StateBackendMigrationTestBase<B extends AbstractStateBacke
             // the state backend should have decided whether or not it needs to perform state
             // migration;
             // make sure that reading and writing each broadcast entry works with the new serializer
+            MapSerializer internalMapCopySerializer =
+                    ((HeapBroadcastState) state).getInternalMapCopySerializer();
+            MapSerializer previousSerializer =
+                    new MapSerializer<>(
+                            initialAccessDescriptor.getKeySerializer(),
+                            internalMapCopySerializer.getValueSerializer());
+            MapSerializer newSerializerForRestoredState =
+                    new MapSerializer(
+                            newAccessDescriptorAfterRestore.getKeySerializer(),
+                            newAccessDescriptorAfterRestore.getValueSerializer());
+            internalCopySerializerTest(
+                    previousSerializer, newSerializerForRestoredState, internalMapCopySerializer);
+
             assertEquals(new TestType("foo", 13), state.get(3));
             assertEquals(new TestType("bar", 278), state.get(5));
             state.put(17, new TestType("new-entry", 777));
@@ -1132,6 +1167,20 @@ public abstract class StateBackendMigrationTestBase<B extends AbstractStateBacke
         }
     }
 
+    public void internalCopySerializerTest(
+            TypeSerializer previousSerializer,
+            TypeSerializer newSerializerForRestoredState,
+            TypeSerializer internalCopySerializer) {
+        StateSerializerProvider testProvider =
+                StateSerializerProvider.fromPreviousSerializerSnapshot(
+                        previousSerializer.snapshotConfiguration());
+        testProvider.registerNewSerializerForRestoredState(newSerializerForRestoredState);
+
+        assertEquals(
+                testProvider.currentSchemaSerializer().getClass(),
+                internalCopySerializer.getClass());
+    }
+
     // -------------------------------------------------------------------------------
     //  Test types, serializers, and serializer snapshots
     // -------------------------------------------------------------------------------
