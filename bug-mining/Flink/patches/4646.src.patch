diff --git a/flink-yarn/src/main/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourceAdapter.java b/flink-yarn/src/main/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourceAdapter.java
deleted file mode 100644
index 5fdc64c2641..00000000000
--- a/flink-yarn/src/main/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourceAdapter.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.yarn;
-
-import org.apache.flink.annotation.VisibleForTesting;
-import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
-import org.apache.flink.util.MathUtils;
-import org.apache.flink.util.Preconditions;
-
-import org.apache.hadoop.yarn.api.records.Resource;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.annotation.Nullable;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.stream.Collectors;
-
-/**
- * Utility class for converting between Flink {@link TaskExecutorProcessSpec} and Yarn {@link Resource}.
- */
-class TaskExecutorProcessSpecContainerResourceAdapter {
-
-	private static final Logger LOG = LoggerFactory.getLogger(TaskExecutorProcessSpecContainerResourceAdapter.class);
-
-	private final int minMemMB;
-	private final int maxMemMB;
-	private final int unitMemMB;
-	private final int minVcore;
-	private final int maxVcore;
-	private final int unitVcore;
-	private final Map<String, Long> externalResourceConfigs;
-	private final Map<TaskExecutorProcessSpec, InternalContainerResource> taskExecutorProcessSpecToContainerResource;
-	private final Map<InternalContainerResource, Set<TaskExecutorProcessSpec>> containerResourceToTaskExecutorProcessSpec;
-	private final Map<Integer, Set<InternalContainerResource>> containerMemoryToContainerResource;
-
-	TaskExecutorProcessSpecContainerResourceAdapter(
-		final int minMemMB,
-		final int minVcore,
-		final int maxMemMB,
-		final int maxVcore,
-		final int unitMemMB,
-		final int unitVcore,
-		final Map<String, Long> externalResourceConfigs) {
-		this.minMemMB = minMemMB;
-		this.minVcore = minVcore;
-		this.maxMemMB = maxMemMB;
-		this.maxVcore = maxVcore;
-		this.unitMemMB = unitMemMB;
-		this.unitVcore = unitVcore;
-		this.externalResourceConfigs = Preconditions.checkNotNull(externalResourceConfigs);
-		taskExecutorProcessSpecToContainerResource = new HashMap<>();
-		containerResourceToTaskExecutorProcessSpec = new HashMap<>();
-		containerMemoryToContainerResource = new HashMap<>();
-	}
-
-	Optional<Resource> tryComputeContainerResource(final TaskExecutorProcessSpec taskExecutorProcessSpec) {
-		final InternalContainerResource internalContainerResource = taskExecutorProcessSpecToContainerResource.computeIfAbsent(
-			Preconditions.checkNotNull(taskExecutorProcessSpec),
-			this::createAndMapContainerResource);
-		if (internalContainerResource != null) {
-			return Optional.of(internalContainerResource.toResource());
-		} else {
-			return Optional.empty();
-		}
-	}
-
-	Set<TaskExecutorProcessSpec> getTaskExecutorProcessSpec(final Resource containerResource, final MatchingStrategy matchingStrategy) {
-		final InternalContainerResource internalContainerResource = new InternalContainerResource(containerResource);
-		return getEquivalentInternalContainerResource(internalContainerResource, matchingStrategy).stream()
-			.flatMap(resource -> containerResourceToTaskExecutorProcessSpec.getOrDefault(resource, Collections.emptySet()).stream())
-			.collect(Collectors.toSet());
-	}
-
-	Set<Resource> getEquivalentContainerResource(final Resource containerResource, final MatchingStrategy matchingStrategy) {
-		final InternalContainerResource internalContainerResource = new InternalContainerResource(containerResource);
-		return getEquivalentInternalContainerResource(internalContainerResource, matchingStrategy).stream()
-			.map(InternalContainerResource::toResource)
-			.collect(Collectors.toSet());
-	}
-
-	private Set<InternalContainerResource> getEquivalentInternalContainerResource(final InternalContainerResource internalContainerResource, final MatchingStrategy matchingStrategy) {
-		// Yarn might ignore the requested vcores, depending on its configurations.
-		// In such cases, we should also not matching vcores.
-		final Set<InternalContainerResource> equivalentInternalContainerResources;
-		switch (matchingStrategy) {
-			case MATCH_VCORE:
-				equivalentInternalContainerResources = Collections.singleton(internalContainerResource);
-				break;
-			case IGNORE_VCORE:
-			default:
-				equivalentInternalContainerResources = containerMemoryToContainerResource
-					.getOrDefault(internalContainerResource.memory, Collections.emptySet());
-				break;
-		}
-		return equivalentInternalContainerResources;
-	}
-
-	@Nullable
-	private InternalContainerResource createAndMapContainerResource(final TaskExecutorProcessSpec taskExecutorProcessSpec) {
-		final InternalContainerResource internalContainerResource = new InternalContainerResource(
-			normalize(taskExecutorProcessSpec.getTotalProcessMemorySize().getMebiBytes(), minMemMB, unitMemMB),
-			normalize(taskExecutorProcessSpec.getCpuCores().getValue().intValue(), minVcore, unitVcore),
-			externalResourceConfigs);
-
-		if (resourceWithinMaxAllocation(internalContainerResource)) {
-			containerResourceToTaskExecutorProcessSpec.computeIfAbsent(internalContainerResource, ignored -> new HashSet<>())
-				.add(taskExecutorProcessSpec);
-			containerMemoryToContainerResource.computeIfAbsent(internalContainerResource.memory, ignored -> new HashSet<>())
-				.add(internalContainerResource);
-			return internalContainerResource;
-		} else {
-			LOG.warn("Requested container resource {} exceeds yarn max allocation {}. Will not allocate resource.",
-				internalContainerResource,
-				new InternalContainerResource(maxMemMB, maxVcore, Collections.emptyMap()));
-			return null;
-		}
-	}
-
-	/**
-	 * Normalize to the minimum integer that is greater or equal to both 'value' and 'minValue',
-	 * and is positive integer multiple of 'unitValue'.
-	 */
-	private int normalize(final int value, final int minValue, final int unitValue) {
-		int rValue = Math.max(value, minValue);
-		return Math.max(MathUtils.divideRoundUp(rValue, unitValue), 1) * unitValue;
-	}
-
-	private boolean resourceWithinMaxAllocation(final InternalContainerResource resource) {
-		return resource.memory <= maxMemMB && resource.vcores <= maxVcore;
-	}
-
-	private static void trySetExternalResources(Map<String, Long> externalResources, Resource resource) {
-		for (Map.Entry<String, Long> externalResource: externalResources.entrySet()) {
-			ResourceInformationReflector.INSTANCE.setResourceInformation(resource, externalResource.getKey(), externalResource.getValue());
-		}
-	}
-
-	enum MatchingStrategy {
-		MATCH_VCORE,
-		IGNORE_VCORE
-	}
-
-	/**
-	 * An {@link InternalContainerResource} corresponds to a {@link Resource}.
-	 * This class is for {@link TaskExecutorProcessSpecContainerResourceAdapter} internal usages only, to overcome the problem that
-	 * hash codes are calculated inconsistently across different {@link Resource} implementations.
-	 */
-	@VisibleForTesting
-	static final class InternalContainerResource {
-		private final int memory;
-		private final int vcores;
-		private final Map<String, Long> externalResources;
-
-		@VisibleForTesting
-		InternalContainerResource(final int memory, final int vcores, final Map<String, Long> externalResources) {
-			this.memory = memory;
-			this.vcores = vcores;
-			this.externalResources = externalResources.entrySet()
-				.stream()
-				.filter(entry -> !entry.getValue().equals(0L))
-				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
-		}
-
-		private InternalContainerResource(final Resource resource) {
-			this(
-				Preconditions.checkNotNull(resource).getMemory(),
-				Preconditions.checkNotNull(resource).getVirtualCores(),
-				ResourceInformationReflector.INSTANCE.getExternalResources(resource));
-		}
-
-		private Resource toResource() {
-			final Resource resource = Resource.newInstance(memory, vcores);
-			trySetExternalResources(externalResources, resource);
-			return resource;
-		}
-
-		@Override
-		public boolean equals(Object obj) {
-			if (obj == this) {
-				return true;
-			} else if (obj instanceof InternalContainerResource) {
-				final InternalContainerResource other = (InternalContainerResource) obj;
-				return this.memory == other.memory && this.vcores == other.vcores && this.externalResources.equals(other.externalResources);
-			}
-			return false;
-		}
-
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = Integer.hashCode(memory);
-			result = prime * result + Integer.hashCode(vcores);
-			result = prime * result + externalResources.hashCode();
-			return result;
-		}
-
-		@Override
-		public String toString() {
-			final StringBuilder sb = new StringBuilder();
-
-			sb.append("<memory:")
-				.append(memory)
-				.append(", vCores:")
-				.append(vcores);
-
-			final Set<String> externalResourceNames = new TreeSet<>(externalResources.keySet());
-			for (String externalResourceName : externalResourceNames) {
-				sb.append(", ")
-					.append(externalResourceName).append(": ")
-					.append(externalResources.get(externalResourceName));
-			}
-
-			sb.append(">");
-			return sb.toString();
-		}
-	}
-}
diff --git a/flink-yarn/src/main/java/org/apache/flink/yarn/Utils.java b/flink-yarn/src/main/java/org/apache/flink/yarn/Utils.java
index 915a184cdcc..ccc258d24fa 100644
--- a/flink-yarn/src/main/java/org/apache/flink/yarn/Utils.java
+++ b/flink-yarn/src/main/java/org/apache/flink/yarn/Utils.java
@@ -21,10 +21,8 @@ package org.apache.flink.yarn;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.runtime.clusterframework.BootstrapTools;
 import org.apache.flink.runtime.clusterframework.ContaineredTaskManagerParameters;
-import org.apache.flink.runtime.externalresource.ExternalResourceUtils;
 import org.apache.flink.runtime.util.HadoopUtils;
 import org.apache.flink.util.StringUtils;
-import org.apache.flink.yarn.configuration.YarnConfigOptions;
 import org.apache.flink.yarn.configuration.YarnResourceManagerDriverConfiguration;
 
 import org.apache.hadoop.conf.Configuration;
@@ -535,30 +533,6 @@ public final class Utils {
 		return resourceDescriptors;
 	}
 
-	static TaskExecutorProcessSpecContainerResourceAdapter createTaskExecutorProcessSpecContainerResourceAdapter(
-		org.apache.flink.configuration.Configuration flinkConfig,
-		YarnConfiguration yarnConfig) {
-
-		Resource unitResource = getUnitResource(yarnConfig);
-
-		return new TaskExecutorProcessSpecContainerResourceAdapter(
-			yarnConfig.getInt(
-				YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_MB,
-				YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB),
-			yarnConfig.getInt(
-				YarnConfiguration.RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES,
-				YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES),
-			yarnConfig.getInt(
-				YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_MB,
-				YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB),
-			yarnConfig.getInt(
-				YarnConfiguration.RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES,
-				YarnConfiguration.DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES),
-			unitResource.getMemory(),
-			unitResource.getVirtualCores(),
-			ExternalResourceUtils.getExternalResources(flinkConfig, YarnConfigOptions.EXTERNAL_RESOURCE_YARN_CONFIG_KEY_SUFFIX));
-	}
-
 	@VisibleForTesting
 	static Resource getUnitResource(YarnConfiguration yarnConfig) {
 		final int unitMemMB, unitVcore;
diff --git a/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java b/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java
index 92bc342049f..c5c4b6206e7 100644
--- a/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java
+++ b/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java
@@ -29,6 +29,7 @@ import org.apache.flink.runtime.clusterframework.ContaineredTaskManagerParameter
 import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.externalresource.ExternalResourceUtils;
 import org.apache.flink.runtime.resourcemanager.active.AbstractResourceManagerDriver;
 import org.apache.flink.runtime.resourcemanager.active.ResourceManagerDriver;
 import org.apache.flink.runtime.resourcemanager.exceptions.ResourceManagerException;
@@ -36,7 +37,6 @@ import org.apache.flink.runtime.webmonitor.history.HistoryServerUtils;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.yarn.configuration.YarnConfigOptions;
-import org.apache.flink.yarn.configuration.YarnConfigOptionsInternal;
 import org.apache.flink.yarn.configuration.YarnResourceManagerDriverConfiguration;
 
 import org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse;
@@ -63,7 +63,6 @@ import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -71,7 +70,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Queue;
-import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.stream.Collectors;
 
@@ -80,8 +78,6 @@ import java.util.stream.Collectors;
  */
 public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<YarnWorkerNode> {
 
-	private static final Priority RM_REQUEST_PRIORITY = Priority.newInstance(1);
-
 	/** Environment variable name of the hostname given by YARN.
 	 * In task executor we use the hostnames given by YARN consistently throughout akka */
 	static final String ENV_FLINK_NODE_ID = "_FLINK_NODE_ID";
@@ -102,8 +98,6 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 	/** Request resource futures, keyed by container's TaskExecutorProcessSpec. */
 	private final Map<TaskExecutorProcessSpec, Queue<CompletableFuture<YarnWorkerNode>>> requestResourceFutures;
 
-	private final TaskExecutorProcessSpecContainerResourceAdapter taskExecutorProcessSpecContainerResourceAdapter;
-
 	private final RegisterApplicationMasterResponseReflector registerApplicationMasterResponseReflector;
 
 	private final YarnResourceManagerClientFactory yarnResourceManagerClientFactory;
@@ -116,7 +110,7 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 	/** Client to communicate with the Node manager and launch TaskExecutor processes. */
 	private NMClientAsync nodeManagerClient;
 
-	private TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy matchingStrategy;
+	private TaskExecutorProcessSpecContainerResourcePriorityAdapter taskExecutorProcessSpecContainerResourcePriorityAdapter;
 
 	public YarnResourceManagerDriver(
 		Configuration flinkConfig,
@@ -144,13 +138,8 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 		yarnHeartbeatIntervalMillis = yarnHeartbeatIntervalMS;
 		containerRequestHeartbeatIntervalMillis = flinkConfig.getInteger(YarnConfigOptions.CONTAINER_REQUEST_HEARTBEAT_INTERVAL_MILLISECONDS);
 
-		this.taskExecutorProcessSpecContainerResourceAdapter = Utils.createTaskExecutorProcessSpecContainerResourceAdapter(flinkConfig, yarnConfig);
 		this.registerApplicationMasterResponseReflector = new RegisterApplicationMasterResponseReflector(log);
 
-		this.matchingStrategy = flinkConfig.getBoolean(YarnConfigOptionsInternal.MATCH_CONTAINER_VCORES) ?
-			TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.MATCH_VCORE :
-			TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.IGNORE_VCORE;
-
 		this.yarnResourceManagerClientFactory = yarnResourceManagerClientFactory;
 		this.yarnNodeManagerClientFactory = yarnNodeManagerClientFactory;
 	}
@@ -171,7 +160,10 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 
 			final RegisterApplicationMasterResponse registerApplicationMasterResponse = registerApplicationMaster();
 			getContainersFromPreviousAttempts(registerApplicationMasterResponse);
-			updateMatchingStrategy(registerApplicationMasterResponse);
+			taskExecutorProcessSpecContainerResourcePriorityAdapter =
+				new TaskExecutorProcessSpecContainerResourcePriorityAdapter(
+					registerApplicationMasterResponse.getMaximumResourceCapability(),
+					ExternalResourceUtils.getExternalResources(flinkConfig, YarnConfigOptions.EXTERNAL_RESOURCE_YARN_CONFIG_KEY_SUFFIX));
 		} catch (Exception e) {
 			throw new ResourceManagerException("Could not start resource manager client.", e);
 		}
@@ -228,21 +220,30 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 
 	@Override
 	public CompletableFuture<YarnWorkerNode> requestResource(TaskExecutorProcessSpec taskExecutorProcessSpec) {
-		final Optional<Resource> containerResourceOptional = getContainerResource(taskExecutorProcessSpec);
+		checkInitialized();
+
 		final CompletableFuture<YarnWorkerNode> requestResourceFuture = new CompletableFuture<>();
 
-		if (containerResourceOptional.isPresent()) {
-			resourceManagerClient.addContainerRequest(getContainerRequest(containerResourceOptional.get()));
+		final Optional<TaskExecutorProcessSpecContainerResourcePriorityAdapter.PriorityAndResource> priorityAndResourceOpt =
+			taskExecutorProcessSpecContainerResourcePriorityAdapter.getPriorityAndResource(taskExecutorProcessSpec);
+
+		if (!priorityAndResourceOpt.isPresent()) {
+			requestResourceFuture.completeExceptionally(
+				new ResourceManagerException(
+					String.format("Could not compute the container Resource from the given TaskExecutorProcessSpec %s. " +
+							"This usually indicates the requested resource is larger than Yarn's max container resource limit.",
+						taskExecutorProcessSpec)));
+		} else {
+			final Priority priority = priorityAndResourceOpt.get().getPriority();
+			final Resource resource = priorityAndResourceOpt.get().getResource();
+			resourceManagerClient.addContainerRequest(getContainerRequest(resource, priority));
 
 			// make sure we transmit the request fast and receive fast news of granted allocations
 			resourceManagerClient.setHeartbeatInterval(containerRequestHeartbeatIntervalMillis);
 
 			requestResourceFutures.computeIfAbsent(taskExecutorProcessSpec, ignore -> new LinkedList<>()).add(requestResourceFuture);
 
-			log.info("Requesting new TaskExecutor container with resource {}.", taskExecutorProcessSpec);
-		} else {
-			requestResourceFuture.completeExceptionally(
-				new ResourceManagerException(String.format("Could not compute the container Resource from the given TaskExecutorProcessSpec %s.", taskExecutorProcessSpec)));
+			log.info("Requesting new TaskExecutor container with resource {}, priority {}.", taskExecutorProcessSpec, priority);
 		}
 
 		return requestResourceFuture;
@@ -260,36 +261,39 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 	//  Internal
 	// ------------------------------------------------------------------------
 
-	private void onContainersOfResourceAllocated(Resource resource, List<Container> containers) {
-		final List<TaskExecutorProcessSpec> pendingTaskExecutorProcessSpecs =
-			taskExecutorProcessSpecContainerResourceAdapter.getTaskExecutorProcessSpec(resource, matchingStrategy).stream()
-				.flatMap(spec -> Collections.nCopies(getNumRequestedNotAllocatedWorkersFor(spec), spec).stream())
-				.collect(Collectors.toList());
+	private void onContainersOfPriorityAllocated(Priority priority, List<Container> containers) {
+		final Optional<TaskExecutorProcessSpecContainerResourcePriorityAdapter.TaskExecutorProcessSpecAndResource> taskExecutorProcessSpecAndResourceOpt =
+			taskExecutorProcessSpecContainerResourcePriorityAdapter.getTaskExecutorProcessSpecAndResource(priority);
+
+		Preconditions.checkState(taskExecutorProcessSpecAndResourceOpt.isPresent(),
+			"Receive %s containers with unrecognized priority %s. This should not happen.",
+			containers.size(), priority.getPriority());
+
+		final TaskExecutorProcessSpec taskExecutorProcessSpec = taskExecutorProcessSpecAndResourceOpt.get().getTaskExecutorProcessSpec();
+		final Resource resource = taskExecutorProcessSpecAndResourceOpt.get().getResource();
 
-		int numPending = pendingTaskExecutorProcessSpecs.size();
-		log.info("Received {} containers with resource {}, {} pending container requests.",
+		final Queue<CompletableFuture<YarnWorkerNode>> pendingRequestResourceFutures =
+			requestResourceFutures.getOrDefault(taskExecutorProcessSpec, new LinkedList<>());
+
+		log.info("Received {} containers with priority {}, {} pending container requests.",
 			containers.size(),
-			resource,
-			numPending);
+			priority,
+			pendingRequestResourceFutures.size());
 
 		final Iterator<Container> containerIterator = containers.iterator();
-		final Iterator<TaskExecutorProcessSpec> pendingTaskExecutorProcessSpecIterator = pendingTaskExecutorProcessSpecs.iterator();
-		final Iterator<AMRMClient.ContainerRequest> pendingRequestsIterator =
-			getPendingRequestsAndCheckConsistency(resource, pendingTaskExecutorProcessSpecs.size()).iterator();
+		final Iterator<AMRMClient.ContainerRequest> pendingContainerRequestIterator =
+			getPendingRequestsAndCheckConsistency(priority, resource, pendingRequestResourceFutures.size()).iterator();
 
 		int numAccepted = 0;
-		while (containerIterator.hasNext() && pendingTaskExecutorProcessSpecIterator.hasNext()) {
-			final TaskExecutorProcessSpec taskExecutorProcessSpec = pendingTaskExecutorProcessSpecIterator.next();
+		while (containerIterator.hasNext() && pendingContainerRequestIterator.hasNext()) {
 			final Container container = containerIterator.next();
-			final AMRMClient.ContainerRequest pendingRequest = pendingRequestsIterator.next();
+			final AMRMClient.ContainerRequest pendingRequest = pendingContainerRequestIterator.next();
 			final ResourceID resourceId = getContainerResourceId(container);
-			final CompletableFuture<YarnWorkerNode> requestResourceFuture =
-				Preconditions.checkNotNull(
-					Preconditions.checkNotNull(
-						requestResourceFutures.get(taskExecutorProcessSpec),
-						"The requestResourceFuture for TasExecutorProcessSpec %s should not be null.", taskExecutorProcessSpec).poll(),
-					"The requestResourceFuture queue for TasExecutorProcessSpec %s should not be empty.", taskExecutorProcessSpec);
-			if (requestResourceFutures.get(taskExecutorProcessSpec).isEmpty()) {
+
+			final CompletableFuture<YarnWorkerNode> requestResourceFuture = pendingRequestResourceFutures.poll();
+			Preconditions.checkState(requestResourceFuture != null);
+
+			if (pendingRequestResourceFutures.isEmpty()) {
 				requestResourceFutures.remove(taskExecutorProcessSpec);
 			}
 
@@ -298,7 +302,6 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 
 			numAccepted++;
 		}
-		numPending -= numAccepted;
 
 		int numExcess = 0;
 		while (containerIterator.hasNext()) {
@@ -307,7 +310,7 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 		}
 
 		log.info("Accepted {} requested containers, returned {} excess containers, {} pending container requests of resource {}.",
-			numAccepted, numExcess, numPending, resource);
+			numAccepted, numExcess, pendingRequestResourceFutures.size(), resource);
 	}
 
 	private int getNumRequestedNotAllocatedWorkers() {
@@ -349,32 +352,21 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 			}, getMainThreadExecutor()));
 	}
 
-	private Collection<AMRMClient.ContainerRequest> getPendingRequestsAndCheckConsistency(Resource resource, int expectedNum) {
-		final Collection<Resource> equivalentResources = taskExecutorProcessSpecContainerResourceAdapter.getEquivalentContainerResource(resource, matchingStrategy);
-		final List<? extends Collection<AMRMClient.ContainerRequest>> matchingRequests =
-			equivalentResources.stream()
-				.flatMap(equivalentResource -> resourceManagerClient.getMatchingRequests(
-					RM_REQUEST_PRIORITY,
-					ResourceRequest.ANY,
-					equivalentResource).stream())
+	private Collection<AMRMClient.ContainerRequest> getPendingRequestsAndCheckConsistency(
+			Priority priority, Resource resource, int expectedNum) {
+		final List<AMRMClient.ContainerRequest> matchingRequests =
+			resourceManagerClient.getMatchingRequests(priority, ResourceRequest.ANY, resource)
+				.stream()
+				.flatMap(Collection::stream)
 				.collect(Collectors.toList());
 
-		final Collection<AMRMClient.ContainerRequest> matchingContainerRequests;
-
-		if (matchingRequests.isEmpty()) {
-			matchingContainerRequests = Collections.emptyList();
-		} else {
-			final Collection<AMRMClient.ContainerRequest> collection = matchingRequests.get(0);
-			matchingContainerRequests = new ArrayList<>(collection);
-		}
-
 		Preconditions.checkState(
-			matchingContainerRequests.size() == expectedNum,
-			"The RMClient's and YarnResourceManagers internal state about the number of pending container requests for resource %s has diverged. " +
+			matchingRequests.size() == expectedNum,
+			"The RMClient's and YarnResourceManagers internal state about the number of pending container requests for priority %s has diverged. " +
 				"Number client's pending container requests %s != Number RM's pending container requests %s.",
-			resource, matchingContainerRequests.size(), expectedNum);
+			priority.getPriority(), matchingRequests.size(), expectedNum);
 
-		return matchingContainerRequests;
+		return matchingRequests;
 	}
 
 	private ContainerLaunchContext createTaskExecutorLaunchContext(
@@ -419,7 +411,14 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 
 	@VisibleForTesting
 	Optional<Resource> getContainerResource(TaskExecutorProcessSpec taskExecutorProcessSpec) {
-		return taskExecutorProcessSpecContainerResourceAdapter.tryComputeContainerResource(taskExecutorProcessSpec);
+		Optional<TaskExecutorProcessSpecContainerResourcePriorityAdapter.PriorityAndResource> opt =
+			taskExecutorProcessSpecContainerResourcePriorityAdapter.getPriorityAndResource(taskExecutorProcessSpec);
+
+		if (!opt.isPresent()) {
+			return Optional.empty();
+		}
+
+		return Optional.of(opt.get().getResource());
 	}
 
 	private RegisterApplicationMasterResponse registerApplicationMaster() throws Exception {
@@ -459,23 +458,6 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 		getResourceEventHandler().onPreviousAttemptWorkersRecovered(recoveredWorkers);
 	}
 
-	private void updateMatchingStrategy(final RegisterApplicationMasterResponse registerApplicationMasterResponse) {
-		final Optional<Set<String>> schedulerResourceTypesOptional =
-			registerApplicationMasterResponseReflector.getSchedulerResourceTypeNames(registerApplicationMasterResponse);
-
-		if (schedulerResourceTypesOptional.isPresent()) {
-			Set<String> types = schedulerResourceTypesOptional.get();
-			log.info("Register application master response contains scheduler resource types: {}.", types);
-			matchingStrategy = types.contains("CPU") ?
-				TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.MATCH_VCORE :
-				TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.IGNORE_VCORE;
-		} else {
-			log.info("Register application master response does not contain scheduler resource types, use '{}'.",
-				YarnConfigOptionsInternal.MATCH_CONTAINER_VCORES.key());
-		}
-		log.info("Container matching strategy: {}.", matchingStrategy);
-	}
-
 	// ------------------------------------------------------------------------
 	//  Utility methods
 	// ------------------------------------------------------------------------
@@ -505,12 +487,12 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 
 	@Nonnull
 	@VisibleForTesting
-	static AMRMClient.ContainerRequest getContainerRequest(Resource containerResource) {
+	static AMRMClient.ContainerRequest getContainerRequest(Resource containerResource, Priority priority) {
 		return new AMRMClient.ContainerRequest(
 			containerResource,
 			null,
 			null,
-			RM_REQUEST_PRIORITY);
+			priority);
 	}
 
 	@VisibleForTesting
@@ -518,8 +500,13 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 		return new ResourceID(container.getId().toString(), container.getNodeId().toString());
 	}
 
-	private Map<Resource, List<Container>> groupContainerByResource(List<Container> containers) {
-		return containers.stream().collect(Collectors.groupingBy(Container::getResource));
+	private Map<Priority, List<Container>> groupContainerByPriority(List<Container> containers) {
+		return containers.stream().collect(Collectors.groupingBy(Container::getPriority));
+	}
+
+	private void checkInitialized() {
+		Preconditions.checkState(taskExecutorProcessSpecContainerResourcePriorityAdapter != null,
+			"Driver not initialized.");
 	}
 
 	// ------------------------------------------------------------------------
@@ -531,6 +518,7 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 		@Override
 		public void onContainersCompleted(List<ContainerStatus> statuses) {
 			runAsyncWithFatalHandler(() -> {
+					checkInitialized();
 					log.debug("YARN ResourceManager reported the following containers completed: {}.", statuses);
 					for (final ContainerStatus containerStatus : statuses) {
 
@@ -544,10 +532,11 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
 		@Override
 		public void onContainersAllocated(List<Container> containers) {
 			runAsyncWithFatalHandler(() -> {
+				checkInitialized();
 				log.info("Received {} containers.", containers.size());
 
-				for (Map.Entry<Resource, List<Container>> entry : groupContainerByResource(containers).entrySet()) {
-					onContainersOfResourceAllocated(entry.getKey(), entry.getValue());
+				for (Map.Entry<Priority, List<Container>> entry : groupContainerByPriority(containers).entrySet()) {
+					onContainersOfPriorityAllocated(entry.getKey(), entry.getValue());
 				}
 
 				// if we are waiting for no further containers, we can go to the
diff --git a/flink-yarn/src/test/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourceAdapterTest.java b/flink-yarn/src/test/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourceAdapterTest.java
deleted file mode 100644
index 4fbe689d9ca..00000000000
--- a/flink-yarn/src/test/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourceAdapterTest.java
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.yarn;
-
-import org.apache.flink.api.common.resources.CPUResource;
-import org.apache.flink.configuration.MemorySize;
-import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
-import org.apache.flink.util.TestLogger;
-
-import org.apache.hadoop.yarn.api.records.Resource;
-import org.apache.hadoop.yarn.api.records.impl.pb.ResourcePBImpl;
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Optional;
-
-import static org.hamcrest.Matchers.contains;
-import static org.hamcrest.Matchers.containsInAnyOrder;
-import static org.hamcrest.Matchers.empty;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-/**
- * Tests for {@link TaskExecutorProcessSpecContainerResourceAdapter}.
- */
-public class TaskExecutorProcessSpecContainerResourceAdapterTest extends TestLogger {
-
-	@Test
-	public void testMatchVcores() {
-		final TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy strategy =
-			TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.MATCH_VCORE;
-		final int minMemMB = 100;
-		final int minVcore = 10;
-		final int unitMemMB = 50;
-		final int unitVcore = 5;
-		final TaskExecutorProcessSpecContainerResourceAdapter adapter =
-			new TaskExecutorProcessSpecContainerResourceAdapter(
-				minMemMB,
-				minVcore,
-				Integer.MAX_VALUE,
-				Integer.MAX_VALUE,
-				unitMemMB,
-				unitVcore,
-				Collections.emptyMap());
-
-		// mem < minMem, vcore < minVcore, should be normalized to [minMem, minVcore]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec1 = new TaskExecutorProcessSpec(
-			new CPUResource(8.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		// mem = minMem, mem % unitMem = 0, vcore = minVcore, vcore % unitVcore = 0, should not be changed
-		final TaskExecutorProcessSpec taskExecutorProcessSpec2 = new TaskExecutorProcessSpec(
-			new CPUResource(10.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		// mem > minMem, mem % unitMem != 0, vcore < minVcore, should be normalized to [n * unitMem, minVcore]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec3 = new TaskExecutorProcessSpec(
-			new CPUResource(8.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		// mem < minMem, vcore > minVcore, vcore % unitVcore != 0, should be normalized to [minMem, n * unitVcore]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec4 = new TaskExecutorProcessSpec(
-			new CPUResource(12.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ofMebiBytes(20),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		final Resource containerResource1 = Resource.newInstance(100, 10);
-		final Resource containerResource2 = Resource.newInstance(150, 10);
-		final Resource containerResource3 = Resource.newInstance(100, 15);
-
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource1, strategy), empty());
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource2, strategy), empty());
-
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec1).get(), is(containerResource1));
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec2).get(), is(containerResource1));
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec3).get(), is(containerResource2));
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec4).get(), is(containerResource3));
-
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource1, strategy), containsInAnyOrder(taskExecutorProcessSpec1, taskExecutorProcessSpec2));
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource2, strategy), contains(taskExecutorProcessSpec3));
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource3, strategy), contains(taskExecutorProcessSpec4));
-	}
-
-	@Test
-	public void testIgnoreVcores() {
-		final TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy strategy =
-			TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.IGNORE_VCORE;
-		final int minMemMB = 100;
-		final int minVcore = 1;
-		final int unitMemMB = 50;
-		final int unitVcore = 1;
-		final TaskExecutorProcessSpecContainerResourceAdapter adapter =
-			new TaskExecutorProcessSpecContainerResourceAdapter(
-				minMemMB,
-				minVcore,
-				Integer.MAX_VALUE,
-				Integer.MAX_VALUE,
-				unitMemMB,
-				unitVcore,
-				Collections.emptyMap());
-
-		// mem < minMem, should be normalized to [minMem, vcore], equivalent to [minMem, 1]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec1 = new TaskExecutorProcessSpec(
-			new CPUResource(5.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		// mem < minMem, should be normalized to [minMem, vcore], equivalent to [minMem, 1]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec2 = new TaskExecutorProcessSpec(
-			new CPUResource(10.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		// mem = minMem, mem % unitMem = 0, should not be changed, equivalent to [mem, 1]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec3 = new TaskExecutorProcessSpec(
-			new CPUResource(5.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ofMebiBytes(25),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		// mem > minMem, mem % unitMem != 0, should be normalized to [n * unitMem, vcore], equivalent to [n * unitMem, 1]
-		final TaskExecutorProcessSpec taskExecutorProcessSpec4 = new TaskExecutorProcessSpec(
-			new CPUResource(5.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ofMebiBytes(30),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		final Resource containerResource1 = Resource.newInstance(100, 5);
-		final Resource containerResource2 = Resource.newInstance(100, 10);
-		final Resource containerResource3 = Resource.newInstance(150, 5);
-
-		final Resource containerResource4 = Resource.newInstance(100, 1);
-		final Resource containerResource5 = Resource.newInstance(150, 1);
-
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec1).get(), is(containerResource1));
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec2).get(), is(containerResource2));
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec3).get(), is(containerResource1));
-		assertThat(adapter.tryComputeContainerResource(taskExecutorProcessSpec4).get(), is(containerResource3));
-
-		assertThat(adapter.getEquivalentContainerResource(containerResource4, strategy), containsInAnyOrder(containerResource1, containerResource2));
-		assertThat(adapter.getEquivalentContainerResource(containerResource5, strategy), contains(containerResource3));
-
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource4, strategy), containsInAnyOrder(taskExecutorProcessSpec1, taskExecutorProcessSpec2, taskExecutorProcessSpec3));
-		assertThat(adapter.getTaskExecutorProcessSpec(containerResource5, strategy), contains(taskExecutorProcessSpec4));
-	}
-
-	@Test
-	public void testMaxLimit() {
-		final int minMemMB = 100;
-		final int minVcore = 1;
-		final int maxMemMB = 1000;
-		final int maxVcore = 10;
-		final int unitMemMB = 100;
-		final int unitVcore = 1;
-		final TaskExecutorProcessSpecContainerResourceAdapter adapter =
-			new TaskExecutorProcessSpecContainerResourceAdapter(
-				minMemMB,
-				minVcore,
-				maxMemMB,
-				maxVcore,
-				unitMemMB,
-				unitVcore,
-				Collections.emptyMap());
-
-		final TaskExecutorProcessSpec taskExecutorProcessSpec1 = new TaskExecutorProcessSpec(
-			new CPUResource(5.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(300),
-			MemorySize.ofMebiBytes(300),
-			MemorySize.ofMebiBytes(300),
-			MemorySize.ofMebiBytes(300),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-		final TaskExecutorProcessSpec taskExecutorProcessSpec2 = new TaskExecutorProcessSpec(
-			new CPUResource(15.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ofMebiBytes(10),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		assertFalse(adapter.tryComputeContainerResource(taskExecutorProcessSpec1).isPresent());
-		assertFalse(adapter.tryComputeContainerResource(taskExecutorProcessSpec2).isPresent());
-	}
-
-	@Test
-	public void testMatchResourceWithDifferentImplementation() {
-		final TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy strategy =
-			TaskExecutorProcessSpecContainerResourceAdapter.MatchingStrategy.IGNORE_VCORE;
-		final int minMemMB = 1;
-		final int minVcore = 1;
-		final int unitMemMB = 1;
-		final int unitVcore = 1;
-
-		final TaskExecutorProcessSpecContainerResourceAdapter adapter =
-			new TaskExecutorProcessSpecContainerResourceAdapter(
-				minMemMB,
-				minVcore,
-				Integer.MAX_VALUE,
-				Integer.MAX_VALUE,
-				unitMemMB,
-				unitVcore,
-				Collections.emptyMap());
-
-		final TaskExecutorProcessSpec taskExecutorProcessSpec = new TaskExecutorProcessSpec(
-			new CPUResource(1.0),
-			MemorySize.ZERO,
-			MemorySize.ZERO,
-			MemorySize.ofMebiBytes(100),
-			MemorySize.ofMebiBytes(200),
-			MemorySize.ofMebiBytes(300),
-			MemorySize.ofMebiBytes(400),
-			MemorySize.ZERO,
-			MemorySize.ZERO);
-
-		Optional<Resource> resourceOpt = adapter.tryComputeContainerResource(taskExecutorProcessSpec);
-		assertTrue(resourceOpt.isPresent());
-		Resource resourceImpl1 = resourceOpt.get();
-
-		Resource resourceImpl2 = new TestingResourceImpl(
-			resourceImpl1.getMemory(),
-			resourceImpl1.getVirtualCores() + 1);
-
-		assertThat(adapter.getEquivalentContainerResource(resourceImpl2, strategy), contains(resourceImpl1));
-		assertThat(adapter.getTaskExecutorProcessSpec(resourceImpl2, strategy), contains(taskExecutorProcessSpec));
-	}
-
-	@Test
-	public void testMatchInternalContainerResourceIgnoresZeroValueExternalResources() {
-		final Map<String, Long> externalResources1 = new HashMap<>();
-		final Map<String, Long> externalResources2 = new HashMap<>();
-
-		externalResources1.put("foo", 0L);
-		externalResources1.put("bar", 1L);
-		externalResources2.put("zoo", 0L);
-		externalResources2.put("bar", 1L);
-
-		final TaskExecutorProcessSpecContainerResourceAdapter.InternalContainerResource internalContainerResource1 =
-			new TaskExecutorProcessSpecContainerResourceAdapter.InternalContainerResource(1024, 1, externalResources1);
-		final TaskExecutorProcessSpecContainerResourceAdapter.InternalContainerResource internalContainerResource2 =
-			new TaskExecutorProcessSpecContainerResourceAdapter.InternalContainerResource(1024, 1, externalResources2);
-
-		assertEquals(internalContainerResource1, internalContainerResource2);
-	}
-
-	private static class TestingResourceImpl extends ResourcePBImpl {
-
-		private TestingResourceImpl(int memory, int vcore) {
-			super();
-			setMemory(memory);
-			setVirtualCores(vcore);
-		}
-
-		@Override
-		public int hashCode() {
-			return super.hashCode() + 678;
-		}
-	}
-}
diff --git a/flink-yarn/src/test/java/org/apache/flink/yarn/TestingRegisterApplicationMasterResponse.java b/flink-yarn/src/test/java/org/apache/flink/yarn/TestingRegisterApplicationMasterResponse.java
index 328ac00a8bb..8a4d179aaad 100644
--- a/flink-yarn/src/test/java/org/apache/flink/yarn/TestingRegisterApplicationMasterResponse.java
+++ b/flink-yarn/src/test/java/org/apache/flink/yarn/TestingRegisterApplicationMasterResponse.java
@@ -21,6 +21,7 @@ package org.apache.flink.yarn;
 import org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse;
 import org.apache.hadoop.yarn.api.protocolrecords.impl.pb.RegisterApplicationMasterResponsePBImpl;
 import org.apache.hadoop.yarn.api.records.Container;
+import org.apache.hadoop.yarn.api.records.Resource;
 
 import java.util.Collections;
 import java.util.EnumSet;
@@ -31,6 +32,7 @@ import java.util.function.Supplier;
  * A Yarn {@link RegisterApplicationMasterResponse} implementation for testing.
  */
 public class TestingRegisterApplicationMasterResponse extends RegisterApplicationMasterResponsePBImpl {
+	private static final Resource MAX_CAPABILITY = Resource.newInstance(1024 * 10000, 10000);
 	private final Supplier<List<Container>> getContainersFromPreviousAttemptsSupplier;
 
 	TestingRegisterApplicationMasterResponse(Supplier<List<Container>> getContainersFromPreviousAttemptsSupplier) {
@@ -53,4 +55,9 @@ public class TestingRegisterApplicationMasterResponse extends RegisterApplicatio
 	public EnumSet getSchedulerResourceTypes() {
 		return EnumSet.copyOf(Collections.<Enum>emptySet());
 	}
+
+	@Override
+	public Resource getMaximumResourceCapability() {
+		return MAX_CAPABILITY;
+	}
 }
diff --git a/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerDriverTest.java b/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerDriverTest.java
index 41e03469fdf..3e3685369db 100644
--- a/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerDriverTest.java
+++ b/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerDriverTest.java
@@ -48,6 +48,7 @@ import org.apache.hadoop.yarn.api.records.LocalResourceVisibility;
 import org.apache.hadoop.yarn.api.records.NodeId;
 import org.apache.hadoop.yarn.api.records.Priority;
 import org.apache.hadoop.yarn.api.records.Resource;
+import org.apache.hadoop.yarn.client.api.AMRMClient;
 import org.apache.hadoop.yarn.client.api.async.AMRMClientAsync;
 import org.apache.hadoop.yarn.client.api.async.NMClientAsync;
 import org.apache.hadoop.yarn.conf.YarnConfiguration;
@@ -79,7 +80,6 @@ import static org.apache.flink.yarn.YarnConfigKeys.FLINK_DIST_JAR;
 import static org.apache.flink.yarn.YarnConfigKeys.FLINK_YARN_FILES;
 import static org.apache.flink.yarn.YarnResourceManagerDriver.ERROR_MESSAGE_ON_SHUTDOWN_REQUEST;
 import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
@@ -91,7 +91,8 @@ import static org.junit.Assert.assertTrue;
  */
 public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase<YarnWorkerNode> {
 	private static final Resource testingResource = Resource.newInstance(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB, YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES);
-	private static final Container testingContainer = createTestingContainerWithResource(testingResource, 0);
+	private static final Priority testingPriority = Priority.newInstance(1);
+	private static final Container testingContainer = createTestingContainerWithResource(testingResource, testingPriority, 1);
 	private static final TaskExecutorProcessSpec testingTaskExecutorProcessSpec =
 		new TaskExecutorProcessSpec(
 			new CPUResource(1),
@@ -231,83 +232,7 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 	}
 
 	@Test
-	public void testStartTaskExecutorProcessVariousSpec_SameContainerResource() throws Exception{
-		final TaskExecutorProcessSpec taskExecutorProcessSpec1 =
-			new TaskExecutorProcessSpec(
-				new CPUResource(1),
-				MemorySize.ZERO,
-				MemorySize.ZERO,
-				MemorySize.ofMebiBytes(100),
-				MemorySize.ZERO,
-				MemorySize.ofMebiBytes(100),
-				MemorySize.ofMebiBytes(100),
-				MemorySize.ZERO,
-				MemorySize.ZERO
-			);
-		final TaskExecutorProcessSpec taskExecutorProcessSpec2 =
-			new TaskExecutorProcessSpec(
-				new CPUResource(1),
-				MemorySize.ZERO,
-				MemorySize.ZERO,
-				MemorySize.ofMebiBytes(99),
-				MemorySize.ZERO,
-				MemorySize.ofMebiBytes(100),
-				MemorySize.ofMebiBytes(100),
-				MemorySize.ZERO,
-				MemorySize.ZERO
-			);
-
-		new Context() {{
-			final String startCommand1 = TaskManagerOptions.TASK_HEAP_MEMORY.key() + "=" + (100L << 20);
-			final String startCommand2 = TaskManagerOptions.TASK_HEAP_MEMORY.key() + "=" + (99L << 20);
-			final CompletableFuture<Void> startContainerAsyncCommandFuture1 = new CompletableFuture<>();
-			final CompletableFuture<Void> startContainerAsyncCommandFuture2 = new CompletableFuture<>();
-			prepareForTestStartTaskExecutorProcessVariousSpec(
-				startCommand1,
-				startCommand2,
-				startContainerAsyncCommandFuture1,
-				startContainerAsyncCommandFuture2,
-				taskExecutorProcessSpec1);
-
-			testingYarnAMRMClientAsyncBuilder.setGetMatchingRequestsFunction(ignored ->
-				Collections.singletonList(ImmutableList.of(
-					YarnResourceManagerDriver.getContainerRequest(((YarnResourceManagerDriver) getDriver()).getContainerResource(taskExecutorProcessSpec1).get()),
-					YarnResourceManagerDriver.getContainerRequest(((YarnResourceManagerDriver) getDriver()).getContainerResource(taskExecutorProcessSpec2).get()))));
-
-			runTest(() -> {
-				final Resource containerResource = ((YarnResourceManagerDriver) getDriver()).getContainerResource(taskExecutorProcessSpec1).get();
-				// Make sure two worker resource spec will be normalized to the same container resource
-				assertEquals(containerResource, ((YarnResourceManagerDriver) getDriver()).getContainerResource(taskExecutorProcessSpec2).get());
-
-				runInMainThread(() -> getDriver().requestResource(taskExecutorProcessSpec1));
-				runInMainThread(() -> getDriver().requestResource(taskExecutorProcessSpec2));
-
-				// Verify both containers requested
-				verifyFutureCompleted(addContainerRequestFutures.get(0));
-				verifyFutureCompleted(addContainerRequestFutures.get(1));
-
-				// Mock that both containers are allocated
-				Container container1 = createTestingContainerWithResource(containerResource);
-				Container container2 = createTestingContainerWithResource(containerResource);
-				resourceManagerClientCallbackHandler.onContainersAllocated(ImmutableList.of(container1, container2));
-
-				// Verify workers with both spec are started.
-				verifyFutureCompleted(startContainerAsyncCommandFuture1);
-				verifyFutureCompleted(startContainerAsyncCommandFuture2);
-
-				// Mock that one container is completed, while the worker is still pending
-				ContainerStatus testingContainerStatus = createTestingContainerCompletedStatus(container1.getId());
-				resourceManagerClientCallbackHandler.onContainersCompleted(Collections.singletonList(testingContainerStatus));
-
-				// Verify that only one more container is requested.
-				verifyFutureCompleted(addContainerRequestFutures.get(2));
-				assertFalse(addContainerRequestFutures.get(3).isDone());
-			});
-		}};
-	}
-
-	@Test
-	public void testStartWorkerVariousSpec_DifferentContainerResource() throws Exception{
+	public void testStartWorkerVariousSpec() throws Exception{
 		final TaskExecutorProcessSpec taskExecutorProcessSpec1 =
 			new TaskExecutorProcessSpec(
 				new CPUResource(1),
@@ -346,14 +271,16 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 				taskExecutorProcessSpec1);
 
 			testingYarnAMRMClientAsyncBuilder.setGetMatchingRequestsFunction(tuple -> {
-				if (tuple.f2.getVirtualCores() == 1) {
-					return Collections.singletonList(
-						Collections.singletonList(YarnResourceManagerDriver.getContainerRequest(((YarnResourceManagerDriver) getDriver()).getContainerResource(taskExecutorProcessSpec1).get())));
-				} else if (tuple.f2.getVirtualCores() == 2) {
-					return Collections.singletonList(
-						Collections.singletonList(YarnResourceManagerDriver.getContainerRequest(((YarnResourceManagerDriver) getDriver()).getContainerResource(taskExecutorProcessSpec2).get())));
+				final Priority priority = tuple.f0;
+				final List<AMRMClient.ContainerRequest> matchingRequests = new ArrayList<>();
+				for (CompletableFuture<AMRMClient.ContainerRequest> addContainerRequestFuture : addContainerRequestFutures) {
+					final AMRMClient.ContainerRequest request = addContainerRequestFuture.getNow(null);
+					if (request != null && priority.equals(request.getPriority())) {
+						assertThat(tuple.f2, is(request.getCapability()));
+						matchingRequests.add(request);
+					}
 				}
-				return null;
+				return Collections.singletonList(matchingRequests);
 			});
 
 			runTest(() -> {
@@ -383,7 +310,7 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 
 				// Verify that only container 1 is requested again
 				verifyFutureCompleted(addContainerRequestFutures.get(2));
-				assertThat(addContainerRequestFutures.get(2).get(), is(containerResource1));
+				assertThat(addContainerRequestFutures.get(2).get().getCapability(), is(containerResource1));
 				assertFalse(addContainerRequestFutures.get(3).isDone());
 			});
 		}};
@@ -393,21 +320,21 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 		return containerLaunchContext.getCommands().stream().anyMatch(str -> str.contains(command));
 	}
 
-	private static Container createTestingContainerWithResource(Resource resource, int containerIdx) {
+	private static Container createTestingContainerWithResource(Resource resource, Priority priority, int containerIdx) {
 		final ContainerId containerId = ContainerId.newInstance(
 			ApplicationAttemptId.newInstance(
 				ApplicationId.newInstance(System.currentTimeMillis(), 1),
 				1),
 			containerIdx);
 		final NodeId nodeId = NodeId.newInstance("container", 1234);
-		return new TestingContainer(containerId, nodeId, resource, Priority.UNDEFINED);
+		return new TestingContainer(containerId, nodeId, resource, priority);
 	}
 
 	private class Context extends ResourceManagerDriverTestBase<YarnWorkerNode>.Context {
 		private final CompletableFuture<Void> stopAndCleanupClusterFuture =  new CompletableFuture<>();
 		private final CompletableFuture<Resource> createTaskManagerContainerFuture = new CompletableFuture<>();
 		private final CompletableFuture<Void> stopContainerAsyncFuture = new CompletableFuture<>();
-		final List<CompletableFuture<Resource>> addContainerRequestFutures = new ArrayList<>();
+		final List<CompletableFuture<AMRMClient.ContainerRequest>> addContainerRequestFutures = new ArrayList<>();
 		final AtomicInteger addContainerRequestFuturesNumCompleted = new AtomicInteger(0);
 		final CompletableFuture<Void> removeContainerRequestFuture = new CompletableFuture<>();
 		final CompletableFuture<Void> releaseAssignedContainerFuture = new CompletableFuture<>();
@@ -436,7 +363,7 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 					.onContainersAllocated(Collections.singletonList(testingContainer));
 			})
 			.setGetMatchingRequestsFunction(ignored ->
-				Collections.singletonList(Collections.singletonList(YarnResourceManagerDriver.getContainerRequest(testingResource))))
+				Collections.singletonList(Collections.singletonList(YarnResourceManagerDriver.getContainerRequest(testingResource, Priority.UNDEFINED))))
 			.setRemoveContainerRequestConsumer((request, handler) -> removeContainerRequestFuture.complete(null))
 			.setReleaseAssignedContainerConsumer((ignored1, ignored2) -> releaseAssignedContainerFuture.complete(null))
 			.setUnregisterApplicationMasterConsumer((ignore1, ignore2, ignore3) -> stopAndCleanupClusterFuture.complete(null))
@@ -533,11 +460,12 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 		@Override
 		protected void validateRequestedResources(Collection<TaskExecutorProcessSpec> taskExecutorProcessSpecs) throws Exception {
 			assertThat(taskExecutorProcessSpecs.size(), is(1));
+			final TaskExecutorProcessSpec taskExecutorProcessSpec = taskExecutorProcessSpecs.iterator().next();
 
 			final Resource resource = createTaskManagerContainerFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS);
 
-			assertThat(resource.getMemory(), is(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB));
-			assertThat(resource.getVirtualCores(), is(YarnConfiguration.DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES));
+			assertThat(resource.getMemory(), is(taskExecutorProcessSpec.getTotalProcessMemorySize().getMebiBytes()));
+			assertThat(resource.getVirtualCores(), is(taskExecutorProcessSpec.getCpuCores().getValue().intValue()));
 			verifyFutureCompleted(removeContainerRequestFuture);
 		}
 
@@ -553,7 +481,7 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 		}
 
 		Container createTestingContainerWithResource(Resource resource) {
-			return YarnResourceManagerDriverTest.createTestingContainerWithResource(resource, containerIdx++);
+			return YarnResourceManagerDriverTest.createTestingContainerWithResource(resource, testingPriority, containerIdx++);
 		}
 
 		<T> void verifyFutureCompleted(CompletableFuture<T> future) throws Exception {
@@ -572,7 +500,7 @@ public class YarnResourceManagerDriverTest extends ResourceManagerDriverTestBase
 			addContainerRequestFutures.add(new CompletableFuture<>());
 
 			testingYarnAMRMClientAsyncBuilder.setAddContainerRequestConsumer((request, ignored) ->
-				addContainerRequestFutures.get(addContainerRequestFuturesNumCompleted.getAndIncrement()).complete(request.getCapability()));
+				addContainerRequestFutures.get(addContainerRequestFuturesNumCompleted.getAndIncrement()).complete(request));
 			testingYarnNMClientAsyncBuilder.setStartContainerAsyncConsumer((ignored1, context, ignored3) -> {
 				if (containsStartCommand(context, startCommand1)) {
 					startContainerAsyncCommandFuture1.complete(null);
