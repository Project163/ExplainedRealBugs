diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactory.java
index c562d93af5c..2c8f2cbea10 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactory.java
@@ -37,8 +37,6 @@ import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static org.apache.flink.runtime.concurrent.FutureUtils.completeFromCallable;
-
 /**
  * Factory for {@link NettyPartitionRequestClient} instances.
  *
@@ -75,12 +73,24 @@ class PartitionRequestClientFactory {
 				return new CompletableFuture<>();
 			});
 			if (isTheFirstOne.get()) {
-				completeFromCallable(clientFuture, () -> connectWithRetries(connectionId));
+				try {
+					clientFuture.complete(connectWithRetries(connectionId));
+				} catch (InterruptedException e) {
+					clientFuture.complete(null); // let others waiting know that they should retry
+					throw e;
+				} catch (Exception e) {
+					clientFuture.completeExceptionally(e);
+				}
 			}
 
 			final NettyPartitionRequestClient client;
 			try {
 				client = clientFuture.get();
+				if (client == null) {
+					// computation failed in another thread - cleanup the map and restart the loop
+					clients.remove(connectionId, clientFuture);
+					continue;
+				}
 			} catch (ExecutionException e) {
 				throw new IOException(e);
 			}
@@ -94,7 +104,7 @@ class PartitionRequestClientFactory {
 		}
 	}
 
-	private NettyPartitionRequestClient connectWithRetries(ConnectionID connectionId) {
+	private NettyPartitionRequestClient connectWithRetries(ConnectionID connectionId) throws InterruptedException {
 		int tried = 0;
 		while (true) {
 			try {
@@ -109,11 +119,13 @@ class PartitionRequestClientFactory {
 		}
 	}
 
-	private NettyPartitionRequestClient connect(ConnectionID connectionId) throws RemoteTransportException {
+	private NettyPartitionRequestClient connect(ConnectionID connectionId) throws RemoteTransportException, InterruptedException {
 		try {
 			Channel channel = nettyClient.connect(connectionId.getAddress()).await().channel();
 			NetworkClientHandler clientHandler = channel.pipeline().get(NetworkClientHandler.class);
 			return new NettyPartitionRequestClient(channel, clientHandler, connectionId, this);
+		} catch (InterruptedException e) {
+			throw e;
 		} catch (Exception e) {
 			throw new RemoteTransportException(
 				"Connecting to remote task manager '" + connectionId.getAddress() +
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NeverCompletingChannelFuture.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NeverCompletingChannelFuture.java
new file mode 100644
index 00000000000..faa1e8151ee
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NeverCompletingChannelFuture.java
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.io.network.netty;
+
+import org.apache.flink.shaded.netty4.io.netty.channel.Channel;
+import org.apache.flink.shaded.netty4.io.netty.channel.ChannelFuture;
+import org.apache.flink.shaded.netty4.io.netty.util.concurrent.Future;
+import org.apache.flink.shaded.netty4.io.netty.util.concurrent.GenericFutureListener;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+@SuppressWarnings({"InfiniteLoopStatement", "BusyWait"})
+class NeverCompletingChannelFuture implements ChannelFuture {
+
+	@Override
+	public Channel channel() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isSuccess() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isCancellable() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Throwable cause() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture addListener(GenericFutureListener<? extends Future<? super Void>> genericFutureListener) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture addListeners(GenericFutureListener<? extends Future<? super Void>>... genericFutureListeners) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture removeListener(GenericFutureListener<? extends Future<? super Void>> genericFutureListener) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture removeListeners(GenericFutureListener<? extends Future<? super Void>>... genericFutureListeners) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture sync() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture syncUninterruptibly() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public ChannelFuture await() throws InterruptedException {
+		while (true) {
+			Thread.sleep(50);
+		}
+	}
+
+	@Override
+	public ChannelFuture awaitUninterruptibly() {
+		while (true) {
+			try {
+				Thread.sleep(50);
+			} catch (InterruptedException e) {
+				// ignore
+			}
+		}
+	}
+
+	@Override
+	public boolean await(long l, TimeUnit timeUnit) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean await(long l) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean awaitUninterruptibly(long l, TimeUnit timeUnit) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean awaitUninterruptibly(long l) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Void getNow() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean cancel(boolean b) {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isCancelled() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isDone() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Void get() throws InterruptedException, ExecutionException {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean isVoid() {
+		throw new UnsupportedOperationException();
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactoryTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactoryTest.java
index 784ca1eb57a..5c736ab2f12 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactoryTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactoryTest.java
@@ -42,6 +42,7 @@ import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -58,6 +59,39 @@ public class PartitionRequestClientFactoryTest {
 
 	private static final int SERVER_PORT = NetUtils.getAvailablePort();
 
+	@Test
+	public void testInterruptsNotCached() throws Exception {
+		ConnectionID connectionId = new ConnectionID(new InetSocketAddress(InetAddress.getLocalHost(), 8080), 0);
+		try (AwaitingNettyClient nettyClient = new AwaitingNettyClient()) {
+			PartitionRequestClientFactory factory = new PartitionRequestClientFactory(nettyClient, 0);
+
+			nettyClient.awaitForInterrupts = true;
+			connectAndInterrupt(factory, connectionId);
+
+			nettyClient.awaitForInterrupts = false;
+			factory.createPartitionRequestClient(connectionId);
+		}
+	}
+
+	private void connectAndInterrupt(PartitionRequestClientFactory factory, ConnectionID connectionId) throws Exception {
+		CompletableFuture<Void> started = new CompletableFuture<>();
+		CompletableFuture<Void> interrupted = new CompletableFuture<>();
+		Thread thread = new Thread(() -> {
+			try {
+				started.complete(null);
+				factory.createPartitionRequestClient(connectionId);
+			} catch (InterruptedException e) {
+				interrupted.complete(null);
+			} catch (Exception e) {
+				interrupted.completeExceptionally(e);
+			}
+		});
+		thread.start();
+		started.get();
+		thread.interrupt();
+		interrupted.get();
+	}
+
 	@Test
 	public void testNettyClientConnectRetry() throws Exception {
 		NettyTestUtil.NettyServerAndClient serverAndClient = createNettyServerAndClient();
@@ -203,6 +237,36 @@ public class PartitionRequestClientFactoryTest {
 		}
 	}
 
+	private class AwaitingNettyClient extends NettyClient implements AutoCloseable {
+		private volatile boolean awaitForInterrupts;
+		private final NettyTestUtil.NettyServerAndClient nettyServerAndClient;
+
+		AwaitingNettyClient() throws Exception {
+			super(null);
+			nettyServerAndClient = createNettyServerAndClient();
+		}
+
+		@Override
+		ChannelFuture connect(InetSocketAddress serverSocketAddress) {
+			if (awaitForInterrupts) {
+				return new NeverCompletingChannelFuture();
+			}
+			try {
+				return nettyServerAndClient.client().connect(serverSocketAddress);
+			} catch (Exception exception) {
+				throw new RuntimeException(exception);
+			}
+		}
+
+		@Override
+		public void close() throws Exception {
+			if (nettyServerAndClient != null) {
+				nettyServerAndClient.client().shutdown();
+				nettyServerAndClient.server().shutdown();
+			}
+		}
+	}
+
 	private static class CountDownLatchOnConnectHandler extends ChannelOutboundHandlerAdapter {
 
 		private final CountDownLatch syncOnConnect;
