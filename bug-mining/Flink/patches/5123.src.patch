diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/WindowDistinctAggregateITCase.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/WindowDistinctAggregateITCase.scala
index f950e3f6d49..6acab090daf 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/WindowDistinctAggregateITCase.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/WindowDistinctAggregateITCase.scala
@@ -733,8 +733,8 @@ object WindowDistinctAggregateITCase {
   def parameters(): util.Collection[Array[java.lang.Object]] = {
     Seq[Array[AnyRef]](
       Array(Boolean.box(true), HEAP_BACKEND),
+      Array(Boolean.box(false), HEAP_BACKEND),
       Array(Boolean.box(true), ROCKSDB_BACKEND),
-      // we only disable SplitDistinct for ROCKSDB, to reduce test time
       Array(Boolean.box(false), ROCKSDB_BACKEND))
   }
 }
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/SlicingWindowAggOperatorBuilder.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/SlicingWindowAggOperatorBuilder.java
index c25da544064..124a8cdde2a 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/SlicingWindowAggOperatorBuilder.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/SlicingWindowAggOperatorBuilder.java
@@ -109,7 +109,7 @@ public class SlicingWindowAggOperatorBuilder {
         final WindowBuffer.Factory bufferFactory =
                 new RecordsWindowBuffer.Factory(keyTypes, inputType);
         final WindowCombineFunction.Factory combinerFactory =
-                new CombineRecordsFunction.Factory(generatedAggregateFunction);
+                new CombineRecordsFunction.Factory(generatedAggregateFunction, inputType);
         final SlicingWindowProcessor<Long> windowProcessor;
         if (assigner instanceof SliceSharedAssigner) {
             windowProcessor =
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/combines/CombineRecordsFunction.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/combines/CombineRecordsFunction.java
index 81b57ea499e..2836c950df4 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/combines/CombineRecordsFunction.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/aggregate/window/combines/CombineRecordsFunction.java
@@ -29,7 +29,9 @@ import org.apache.flink.table.runtime.generated.GeneratedNamespaceAggsHandleFunc
 import org.apache.flink.table.runtime.generated.NamespaceAggsHandleFunction;
 import org.apache.flink.table.runtime.operators.window.state.StateKeyContext;
 import org.apache.flink.table.runtime.operators.window.state.WindowValueState;
+import org.apache.flink.table.runtime.typeutils.RowDataSerializer;
 import org.apache.flink.table.runtime.util.WindowKey;
+import org.apache.flink.table.types.logical.RowType;
 
 import java.util.Iterator;
 
@@ -54,8 +56,11 @@ public final class CombineRecordsFunction implements WindowCombineFunction {
     /** Function used to handle all aggregates. */
     private final NamespaceAggsHandleFunction<Long> aggregator;
 
-    /** Whether to copy input key, because key is reused. */
-    private final boolean requiresCopyKey;
+    /** Whether to copy key and input record, because key and record are reused. */
+    private final boolean requiresCopy;
+
+    /** Serializer to copy record if required. */
+    private final RowDataSerializer recordSerializer;
 
     /** Whether the operator works in event-time mode, used to indicate registering which timer. */
     private final boolean isEventTime;
@@ -65,13 +70,15 @@ public final class CombineRecordsFunction implements WindowCombineFunction {
             StateKeyContext keyContext,
             WindowValueState<Long> accState,
             NamespaceAggsHandleFunction<Long> aggregator,
-            boolean requiresCopyKey,
+            boolean requiresCopy,
+            RowType recordType,
             boolean isEventTime) {
         this.timerService = timerService;
         this.keyContext = keyContext;
         this.accState = accState;
         this.aggregator = aggregator;
-        this.requiresCopyKey = requiresCopyKey;
+        this.requiresCopy = requiresCopy;
+        this.recordSerializer = new RowDataSerializer(recordType);
         this.isEventTime = isEventTime;
     }
 
@@ -79,7 +86,7 @@ public final class CombineRecordsFunction implements WindowCombineFunction {
     public void combine(WindowKey windowKey, Iterator<RowData> records) throws Exception {
         // step 0: set current key for states and timers
         final BinaryRowData key;
-        if (requiresCopyKey) {
+        if (requiresCopy) {
             // the incoming key is reused, we should copy it if state backend doesn't copy it
             key = windowKey.getKey().copy();
         } else {
@@ -100,6 +107,10 @@ public final class CombineRecordsFunction implements WindowCombineFunction {
         // step 3: do accumulate
         while (records.hasNext()) {
             RowData record = records.next();
+            if (requiresCopy) {
+                // the incoming record is reused, we should copy it if state backend doesn't copy it
+                record = recordSerializer.copy(record);
+            }
             if (isAccumulateMsg(record)) {
                 aggregator.accumulate(record);
             } else {
@@ -134,9 +145,12 @@ public final class CombineRecordsFunction implements WindowCombineFunction {
         private static final long serialVersionUID = 1L;
 
         private final GeneratedNamespaceAggsHandleFunction<Long> genAggsHandler;
+        private final RowType recordType;
 
-        public Factory(GeneratedNamespaceAggsHandleFunction<Long> genAggsHandler) {
+        public Factory(
+                GeneratedNamespaceAggsHandleFunction<Long> genAggsHandler, RowType recordType) {
             this.genAggsHandler = genAggsHandler;
+            this.recordType = recordType;
         }
 
         @Override
@@ -152,13 +166,14 @@ public final class CombineRecordsFunction implements WindowCombineFunction {
             aggregator.open(
                     new PerWindowStateDataViewStore(
                             stateBackend, LongSerializer.INSTANCE, runtimeContext));
-            boolean requiresCopyKey = !isStateImmutableInStateBackend(stateBackend);
+            boolean requiresCopy = !isStateImmutableInStateBackend(stateBackend);
             return new CombineRecordsFunction(
                     timerService,
                     stateBackend::setCurrentKey,
                     windowState,
                     aggregator,
-                    requiresCopyKey,
+                    requiresCopy,
+                    recordType,
                     isEventTime);
         }
     }
