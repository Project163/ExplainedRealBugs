diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializer.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializer.java
index 761de50e922..1237a45a61d 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializer.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializer.java
@@ -30,7 +30,9 @@ import javax.annotation.Nullable;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -143,19 +145,37 @@ public final class CommittableCollectorSerializer<CommT>
         @Override
         public CheckpointCommittableManagerImpl<CommT> deserialize(int version, byte[] serialized)
                 throws IOException {
+
             DataInputDeserializer in = new DataInputDeserializer(serialized);
             long checkpointId = in.readLong();
-            List<SubtaskCommittableManager<CommT>> subtasks =
+
+            List<SubtaskCommittableManager<CommT>> subtaskCommittableManagers =
                     SimpleVersionedSerialization.readVersionAndDeserializeList(
                             new SubtaskSimpleVersionedSerializer(checkpointId), in);
+
+            Map<Integer, SubtaskCommittableManager<CommT>> subtasksCommittableManagers =
+                    new HashMap<>(subtaskCommittableManagers.size());
+
+            for (SubtaskCommittableManager<CommT> subtaskCommittableManager :
+                    subtaskCommittableManagers) {
+
+                // check if we already have manager for current
+                // subtaskCommittableManager.getSubtaskId() if yes,
+                // then merge them.
+                SubtaskCommittableManager<CommT> mergedManager =
+                        subtasksCommittableManagers.computeIfPresent(
+                                subtaskId,
+                                (key, manager) -> manager.merge(subtaskCommittableManager));
+
+                // This is new subtaskId, lets add the mapping.
+                if (mergedManager == null) {
+                    subtasksCommittableManagers.put(
+                            subtaskCommittableManager.getSubtaskId(), subtaskCommittableManager);
+                }
+            }
+
             return new CheckpointCommittableManagerImpl<>(
-                    subtasks.stream()
-                            .collect(
-                                    Collectors.toMap(
-                                            SubtaskCommittableManager::getSubtaskId, e -> e)),
-                    subtaskId,
-                    numberOfSubtasks,
-                    checkpointId);
+                    subtasksCommittableManagers, subtaskId, numberOfSubtasks, checkpointId);
         }
     }
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/CommitterOperatorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/CommitterOperatorTest.java
index 9af5b177b4a..7ae860c54e0 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/CommitterOperatorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/CommitterOperatorTest.java
@@ -246,6 +246,14 @@ class CommitterOperatorTest {
                 new CommittableWithLineage<>("1", checkpointId, originalSubtaskId);
         testHarness.processElement(new StreamRecord<>(first));
 
+        // another committable for the same checkpointId but from different subtask.
+        final CommittableSummary<String> committableSummary2 =
+                new CommittableSummary<>(originalSubtaskId + 1, 1, checkpointId, 1, 1, 0);
+        testHarness.processElement(new StreamRecord<>(committableSummary2));
+        final CommittableWithLineage<String> second =
+                new CommittableWithLineage<>("2", checkpointId, originalSubtaskId + 1);
+        testHarness.processElement(new StreamRecord<>(second));
+
         final OperatorSubtaskState snapshot = testHarness.snapshot(checkpointId, 2L);
 
         // Trigger first checkpoint but committer needs retry
@@ -269,12 +277,12 @@ class CommitterOperatorTest {
 
         // Previous committables are immediately committed if possible
         final List<StreamElement> output = fromOutput(restored.getOutput());
-        assertThat(output).hasSize(2);
-        assertThat(committer.getSuccessfulCommits()).isEqualTo(1);
+        assertThat(output).hasSize(3);
+        assertThat(committer.getSuccessfulCommits()).isEqualTo(2);
         SinkV2Assertions.assertThat(toCommittableSummary(output.get(0)))
                 .hasCheckpointId(checkpointId)
-                .hasFailedCommittables(committableSummary.getNumberOfFailedCommittables())
-                .hasOverallCommittables(committableSummary.getNumberOfCommittables())
+                .hasFailedCommittables(0)
+                .hasOverallCommittables(2)
                 .hasPendingCommittables(0);
 
         // Expect the same checkpointId that the original snapshot was made with.
@@ -282,6 +290,10 @@ class CommitterOperatorTest {
                 .isEqualTo(
                         new CommittableWithLineage<>(
                                 first.getCommittable(), checkpointId, subtaskIdAfterRecovery));
+        SinkV2Assertions.assertThat(toCommittableWithLinage(output.get(2)))
+                .isEqualTo(
+                        new CommittableWithLineage<>(
+                                second.getCommittable(), checkpointId, subtaskIdAfterRecovery));
         restored.close();
     }
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializerTest.java
index b69b7a10695..c5ecb35b8b4 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/sink/committables/CommittableCollectorSerializerTest.java
@@ -27,12 +27,15 @@ import org.apache.flink.streaming.api.connector.sink2.CommittableWithLineage;
 import org.apache.flink.streaming.api.connector.sink2.IntegerSerializer;
 import org.apache.flink.streaming.api.connector.sink2.SinkV2Assertions;
 
+import org.apache.flink.shaded.guava30.com.google.common.collect.Streams;
+
+import org.apache.commons.lang3.tuple.Pair;
 import org.junit.jupiter.api.Test;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Iterator;
+import java.util.Collections;
 import java.util.List;
 import java.util.stream.Collectors;
 
@@ -103,11 +106,63 @@ class CommittableCollectorSerializerTest {
 
         // assert original CommittableCollector
         assertCommittableCollector(
-                "Original CommittableCollector", subtaskId, numberOfSubtasks, committableCollector);
+                "Original CommittableCollector",
+                subtaskId,
+                numberOfSubtasks,
+                committableCollector,
+                Arrays.asList(Collections.singletonList(1), Collections.singletonList(2)));
+
+        // assert deserialized CommittableCollector
+        assertCommittableCollector(
+                "Deserialized CommittableCollector",
+                subtaskId,
+                numberOfSubtasks,
+                copy,
+                Arrays.asList(Collections.singletonList(1), Collections.singletonList(2)));
+    }
+
+    @Test
+    public void testCommittablesForSameSubtaskIdV2SerDe() throws IOException {
+
+        int subtaskId = 1;
+        int numberOfSubtasks = 3;
+
+        final CommittableCollectorSerializer<Integer> ccSerializer =
+                new CommittableCollectorSerializer<>(
+                        COMMITTABLE_SERIALIZER, subtaskId, numberOfSubtasks);
+
+        final CommittableCollector<Integer> committableCollector =
+                new CommittableCollector<>(subtaskId, numberOfSubtasks);
+        committableCollector.addMessage(
+                new CommittableSummary<>(subtaskId, numberOfSubtasks, 1L, 1, 1, 0));
+        committableCollector.addMessage(
+                new CommittableSummary<>(subtaskId + 1, numberOfSubtasks, 1L, 1, 1, 0));
+        committableCollector.addMessage(new CommittableWithLineage<>(1, 1L, subtaskId));
+        committableCollector.addMessage(new CommittableWithLineage<>(1, 1L, subtaskId + 1));
+
+        final CommittableCollector<Integer> copy =
+                ccSerializer.deserialize(2, SERIALIZER.serialize(committableCollector));
+
+        // Expect the subtask Id equal to the origin of the collector
+        assertThat(copy.getSubtaskId()).isEqualTo(subtaskId);
+        assertThat(copy.isFinished()).isFalse();
+        assertThat(copy.getNumberOfSubtasks()).isEqualTo(numberOfSubtasks);
+
+        // assert original CommittableCollector
+        assertCommittableCollector(
+                "Original CommittableCollector",
+                subtaskId,
+                numberOfSubtasks,
+                committableCollector,
+                Collections.singletonList(Collections.singletonList(1)));
 
         // assert deserialized CommittableCollector
         assertCommittableCollector(
-                "Deserialized CommittableCollector", subtaskId, numberOfSubtasks, copy);
+                "Deserialized CommittableCollector",
+                subtaskId,
+                numberOfSubtasks,
+                copy,
+                Collections.singletonList(Arrays.asList(1, 1)));
     }
 
     @Test
@@ -134,11 +189,21 @@ class CommittableCollectorSerializerTest {
                 .isEqualTo(committableManager.getCheckpointId());
     }
 
+    /**
+     * @param assertMessageHeading prefix used for assertion fail message.
+     * @param subtaskId subtaskId to get {@link SubtaskCommittableManager} from {@link
+     *     CheckpointCommittableManagerImpl}
+     * @param expectedNumberOfSubtasks expected number of subtasks for {@link CommittableSummary}
+     * @param committableCollector collector to get {@link CheckpointCommittableManager}s from.
+     * @param committablesPerSubtaskPerCheckpoint every of the list element represents expected
+     *     number of pending request per {@link SubtaskCommittableManager}.
+     */
     private void assertCommittableCollector(
             String assertMessageHeading,
             int subtaskId,
-            int numberOfSubtasks,
-            CommittableCollector<Integer> committableCollector) {
+            int expectedNumberOfSubtasks,
+            CommittableCollector<Integer> committableCollector,
+            List<List<Integer>> committablesPerSubtaskPerCheckpoint) {
 
         assertAll(
                 assertMessageHeading,
@@ -146,43 +211,48 @@ class CommittableCollectorSerializerTest {
                     final Collection<CheckpointCommittableManagerImpl<Integer>>
                             checkpointCommittables =
                                     committableCollector.getCheckpointCommittables();
-                    assertThat(checkpointCommittables).hasSize(2);
-
-                    final Iterator<CheckpointCommittableManagerImpl<Integer>> committablesIterator =
-                            checkpointCommittables.iterator();
-                    final CheckpointCommittableManagerImpl<Integer> checkpointCommittableManager1 =
-                            committablesIterator.next();
-                    final SubtaskCommittableManager<Integer> subtaskCommittableManagerCheckpoint1 =
-                            checkpointCommittableManager1.getSubtaskCommittableManager(subtaskId);
-
-                    SinkV2Assertions.assertThat(checkpointCommittableManager1.getSummary())
-                            .hasSubtaskId(subtaskId)
-                            .hasNumberOfSubtasks(numberOfSubtasks);
-                    assertThat(
-                                    subtaskCommittableManagerCheckpoint1
-                                            .getPendingRequests()
-                                            .map(CommitRequestImpl::getCommittable)
-                                            .collect(Collectors.toList()))
-                            .containsExactly(1);
-                    assertThat(subtaskCommittableManagerCheckpoint1.getSubtaskId())
-                            .isEqualTo(subtaskId);
-
-                    final CheckpointCommittableManagerImpl<Integer> checkpointCommittableManager2 =
-                            committablesIterator.next();
-                    final SubtaskCommittableManager<Integer> subtaskCommittableManagerCheckpoint2 =
-                            checkpointCommittableManager2.getSubtaskCommittableManager(subtaskId);
-
-                    SinkV2Assertions.assertThat(checkpointCommittableManager2.getSummary())
-                            .hasSubtaskId(subtaskId)
-                            .hasNumberOfSubtasks(numberOfSubtasks);
-                    assertThat(
-                                    subtaskCommittableManagerCheckpoint2
-                                            .getPendingRequests()
-                                            .map(CommitRequestImpl::getCommittable)
-                                            .collect(Collectors.toList()))
-                            .containsExactly(2);
-                    assertThat(subtaskCommittableManagerCheckpoint2.getSubtaskId())
-                            .isEqualTo(subtaskId);
+                    final int expectedCommittableSize = committablesPerSubtaskPerCheckpoint.size();
+                    assertThat(checkpointCommittables).hasSize(expectedCommittableSize);
+
+                    Streams.zip(
+                                    checkpointCommittables.stream(),
+                                    committablesPerSubtaskPerCheckpoint.stream(),
+                                    Pair::of)
+                            .forEach(
+                                    pair -> {
+                                        CheckpointCommittableManagerImpl<Integer>
+                                                checkpointCommittableManager = pair.getKey();
+                                        List<Integer> expectedPendingRequestCount = pair.getValue();
+
+                                        final SubtaskCommittableManager<Integer>
+                                                subtaskCommittableManager =
+                                                        checkpointCommittableManager
+                                                                .getSubtaskCommittableManager(
+                                                                        subtaskId);
+
+                                        SinkV2Assertions.assertThat(
+                                                        checkpointCommittableManager.getSummary())
+                                                .hasSubtaskId(subtaskId)
+                                                .hasNumberOfSubtasks(expectedNumberOfSubtasks);
+
+                                        assertPendingRequests(
+                                                subtaskCommittableManager,
+                                                expectedPendingRequestCount);
+
+                                        assertThat(subtaskCommittableManager.getSubtaskId())
+                                                .isEqualTo(subtaskId);
+                                    });
                 });
     }
+
+    private void assertPendingRequests(
+            SubtaskCommittableManager<Integer> subtaskCommittableManagerCheckpoint,
+            List<Integer> expectedPendingRequestCount) {
+        assertThat(
+                        subtaskCommittableManagerCheckpoint
+                                .getPendingRequests()
+                                .map(CommitRequestImpl::getCommittable)
+                                .collect(Collectors.toList()))
+                .containsExactlyElementsOf(expectedPendingRequestCount);
+    }
 }
