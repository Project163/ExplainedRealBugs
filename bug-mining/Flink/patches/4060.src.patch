diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
index 9adb587cea8..5334b592c8e 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
@@ -93,16 +93,19 @@ class AlternatingCheckpointBarrierHandler extends CheckpointBarrierHandler {
 
 	@Override
 	public boolean hasInflightData(long checkpointId, int channelIndex) {
-		return activeHandler.hasInflightData(checkpointId, channelIndex);
+		// should only be called for unaligned checkpoint
+		return unalignedHandler.hasInflightData(checkpointId, channelIndex);
 	}
 
 	@Override
 	public CompletableFuture<Void> getAllBarriersReceivedFuture(long checkpointId) {
-		return activeHandler.getAllBarriersReceivedFuture(checkpointId);
+		// should only be called for unaligned checkpoint
+		return unalignedHandler.getAllBarriersReceivedFuture(checkpointId);
 	}
 
 	@Override
 	public Optional<BufferReceivedListener> getBufferReceivedListener() {
+		// should only be used for handling unaligned checkpoints
 		return unalignedHandler.getBufferReceivedListener();
 	}
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java
index 903570c4efd..83833c0e16f 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java
@@ -43,7 +43,6 @@ import java.util.List;
 
 import static java.util.Collections.singletonList;
 import static java.util.Collections.singletonMap;
-import static junit.framework.TestCase.assertTrue;
 import static org.apache.flink.runtime.checkpoint.CheckpointType.CHECKPOINT;
 import static org.apache.flink.runtime.checkpoint.CheckpointType.SAVEPOINT;
 import static org.apache.flink.runtime.io.network.api.serialization.EventSerializer.toBuffer;
@@ -99,22 +98,35 @@ public class AlternatingCheckpointBarrierHandlerTest {
 			assertEquals(type.isSavepoint(), alignedHandler.isCheckpointPending());
 			assertNotEquals(alignedHandler.isCheckpointPending(), unalignedHandler.isCheckpointPending());
 
-			CheckpointBarrierHandler activeHandler;
-			if (type.isSavepoint()) {
-				activeHandler = alignedHandler;
-				assertTrue(barrierHandler.getAllBarriersReceivedFuture(i).isDone());
-			}
-			else {
-				activeHandler = unalignedHandler;
+			if (!type.isSavepoint()) {
 				assertFalse(barrierHandler.getAllBarriersReceivedFuture(i).isDone());
+				assertInflightDataEquals(unalignedHandler, barrierHandler, i, inputGate.getNumberOfInputChannels());
 			}
+		}
+	}
 
-			for (int channelId = 0; channelId < inputGate.getNumberOfInputChannels(); channelId++) {
-				assertEquals(activeHandler.hasInflightData(i, channelId), barrierHandler.hasInflightData(i, channelId));
-			}
+	private static void assertInflightDataEquals(CheckpointBarrierHandler expected, CheckpointBarrierHandler actual, long barrierId, int numChannels) {
+		for (int channelId = 0; channelId < numChannels; channelId++) {
+			assertEquals(expected.hasInflightData(barrierId, channelId), actual.hasInflightData(barrierId, channelId));
 		}
 	}
 
+	@Test
+	public void testHasInflightDataBeforeProcessBarrier() throws Exception {
+		SingleInputGate inputGate = new SingleInputGateBuilder().setNumberOfChannels(2).build();
+		inputGate.setInputChannels(new TestInputChannel(inputGate, 0), new TestInputChannel(inputGate, 1));
+		TestInvokable target = new TestInvokable();
+		CheckpointBarrierAligner alignedHandler = new CheckpointBarrierAligner("test", new InputGate[]{inputGate, inputGate}, singletonMap(inputGate, 0), target);
+		CheckpointBarrierUnaligner unalignedHandler = new CheckpointBarrierUnaligner(new int[]{inputGate.getNumberOfInputChannels()}, ChannelStateWriter.NO_OP, "test", target);
+		AlternatingCheckpointBarrierHandler barrierHandler = new AlternatingCheckpointBarrierHandler(alignedHandler, unalignedHandler, target);
+
+		final long id = 1;
+		unalignedHandler.processBarrier(new CheckpointBarrier(id, 0, new CheckpointOptions(CHECKPOINT, CheckpointStorageLocationReference.getDefault())), 0);
+
+		assertInflightDataEquals(unalignedHandler, barrierHandler, id, inputGate.getNumberOfInputChannels());
+		assertFalse(barrierHandler.getAllBarriersReceivedFuture(id).isDone());
+	}
+
 	@Test
 	public void testEndOfPartition() throws Exception {
 		int totalChannels = 5;
