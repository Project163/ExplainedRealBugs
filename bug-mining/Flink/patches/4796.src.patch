diff --git a/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java b/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java
index 5b94fea2ca2..21b2e6d14bd 100644
--- a/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java
+++ b/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/publisher/polling/PollingRecordPublisher.java
@@ -34,8 +34,10 @@ import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
 
+import static com.amazonaws.services.kinesis.model.ShardIteratorType.AT_TIMESTAMP;
 import static org.apache.flink.streaming.connectors.kinesis.internals.publisher.RecordPublisher.RecordPublisherRunResult.COMPLETE;
 import static org.apache.flink.streaming.connectors.kinesis.internals.publisher.RecordPublisher.RecordPublisherRunResult.INCOMPLETE;
+import static org.apache.flink.streaming.connectors.kinesis.model.SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM;
 
 /**
  * A {@link RecordPublisher} that will read records from Kinesis and forward them to the subscriber.
@@ -106,13 +108,26 @@ public class PollingRecordPublisher implements RecordPublisher {
 		GetRecordsResult result = getRecords(nextShardItr, maxNumberOfRecords);
 
 		RecordBatch recordBatch = new RecordBatch(result.getRecords(), subscribedShard, result.getMillisBehindLatest());
-		SequenceNumber latestSeequenceNumber = consumer.accept(recordBatch);
+		SequenceNumber latestSequenceNumber = consumer.accept(recordBatch);
 
-		nextStartingPosition = StartingPosition.continueFromSequenceNumber(latestSeequenceNumber);
+		nextStartingPosition = getNextStartingPosition(latestSequenceNumber);
 		nextShardItr = result.getNextShardIterator();
 		return nextShardItr == null ? COMPLETE : INCOMPLETE;
 	}
 
+	private StartingPosition getNextStartingPosition(final SequenceNumber latestSequenceNumber) {
+		// When consuming from a timestamp sentinel/AT_TIMESTAMP ShardIteratorType.
+		// If the first RecordBatch is empty, then the latestSequenceNumber would be the timestamp sentinel.
+		// This is because we have not yet received any real sequence numbers on this shard.
+		// In this condition we should retry from the previous starting position (AT_TIMESTAMP).
+		if (SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get().equals(latestSequenceNumber)) {
+			Preconditions.checkState(nextStartingPosition.getShardIteratorType() == AT_TIMESTAMP);
+			return nextStartingPosition;
+		} else {
+			return StartingPosition.continueFromSequenceNumber(latestSequenceNumber);
+		}
+	}
+
 	/**
 	 * Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected
 	 * AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on
diff --git a/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumerTest.java b/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumerTest.java
index 40a599c5f38..20084bab0f4 100644
--- a/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumerTest.java
+++ b/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumerTest.java
@@ -17,6 +17,7 @@
 
 package org.apache.flink.streaming.connectors.kinesis.internals;
 
+import org.apache.flink.streaming.connectors.kinesis.config.ConsumerConfigConstants;
 import org.apache.flink.streaming.connectors.kinesis.internals.publisher.polling.PollingRecordPublisherFactory;
 import org.apache.flink.streaming.connectors.kinesis.metrics.ShardConsumerMetricsReporter;
 import org.apache.flink.streaming.connectors.kinesis.model.SequenceNumber;
@@ -37,8 +38,10 @@ import static org.apache.flink.streaming.connectors.kinesis.model.SentinelSequen
 import static org.apache.flink.streaming.connectors.kinesis.model.SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
 /**
@@ -54,6 +57,21 @@ public class ShardConsumerTest {
 		assertEquals(500, metrics.getMillisBehindLatest());
 	}
 
+	@Test
+	public void testTimestampStartingPositionWithEmptyShard() throws Exception {
+		Properties consumerProperties = new Properties();
+		consumerProperties.setProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP, "2020-11-11T09:14");
+		consumerProperties.setProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT, "yyyy-MM-dd'T'HH:mm");
+		SequenceNumber sequenceNumber = SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get();
+
+		final int numberOfIterations = 3;
+		KinesisProxyInterface kinesis = spy(FakeKinesisBehavioursFactory.emptyShard(numberOfIterations));
+
+		assertNumberOfMessagesReceivedFromKinesis(0, kinesis, sequenceNumber, consumerProperties);
+		verify(kinesis).getShardIterator(any(), eq("AT_TIMESTAMP"), any());
+		verify(kinesis, times(numberOfIterations)).getRecords(any(), anyInt());
+	}
+
 	@Test
 	public void testCorrectNumOfCollectedRecordsAndUpdatedStateWithStartingSequenceNumber() throws Exception {
 		KinesisProxyInterface kinesis = spy(FakeKinesisBehavioursFactory.totalNumOfRecordsAfterNumOfGetRecordsCalls(1000, 9, 500L));
diff --git a/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/testutils/FakeKinesisBehavioursFactory.java b/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/testutils/FakeKinesisBehavioursFactory.java
index af3bdab3e15..e7351ca972d 100644
--- a/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/testutils/FakeKinesisBehavioursFactory.java
+++ b/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/testutils/FakeKinesisBehavioursFactory.java
@@ -85,6 +85,10 @@ public class FakeKinesisBehavioursFactory {
 	//  Behaviours related to fetching records, used mainly in ShardConsumerTest
 	// ------------------------------------------------------------------------
 
+	public static KinesisProxyInterface emptyShard(final int numberOfIterations) {
+		return new SingleShardEmittingZeroRecords(numberOfIterations);
+	}
+
 	public static KinesisProxyInterface totalNumOfRecordsAfterNumOfGetRecordsCalls(
 			final int numOfRecords,
 			final int numOfGetRecordsCalls,
@@ -132,6 +136,32 @@ public class FakeKinesisBehavioursFactory {
 		return new BlockingQueueKinesis(streamsToShardQueues);
 	}
 
+	private static class SingleShardEmittingZeroRecords implements KinesisProxyInterface {
+
+		private int remainingIterators;
+
+		private SingleShardEmittingZeroRecords(int remainingIterators) {
+			this.remainingIterators = remainingIterators;
+		}
+
+		@Override
+		public String getShardIterator(StreamShardHandle shard, String shardIteratorType, Object startingMarker) throws InterruptedException {
+			return String.valueOf(remainingIterators--);
+		}
+
+		@Override
+		public GetRecordsResult getRecords(String shardIterator, int maxRecordsToGet) throws InterruptedException {
+			return new GetRecordsResult()
+				.withMillisBehindLatest(0L)
+				.withNextShardIterator(remainingIterators == 0 ? null : String.valueOf(remainingIterators--));
+		}
+
+		@Override
+		public GetShardListResult getShardList(Map<String, String> streamNamesWithLastSeenShardIds) throws InterruptedException {
+			return null;
+		}
+	}
+
 	private static class SingleShardEmittingFixNumOfRecordsWithExpiredIteratorKinesis extends SingleShardEmittingFixNumOfRecordsKinesis {
 
 		private final long millisBehindLatest;
