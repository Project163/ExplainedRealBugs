diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/BootstrapTools.java b/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/BootstrapTools.java
index 88f2676b4b5..494d1509b56 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/BootstrapTools.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/clusterframework/BootstrapTools.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.clusterframework;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.configuration.AkkaOptions;
 import org.apache.flink.configuration.ConfigConstants;
 import org.apache.flink.configuration.ConfigOption;
@@ -41,7 +42,6 @@ import org.apache.commons.cli.Option;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import java.io.File;
@@ -52,6 +52,7 @@ import java.net.BindException;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Optional;
 import java.util.stream.Stream;
 
 import scala.Some;
@@ -82,92 +83,80 @@ public class BootstrapTools {
 		.build();
 
 	/**
-	 * Starts an ActorSystem with the given configuration listening at the address/ports.
+	 * Starts a remote ActorSystem at given address and specific port range.
 	 * @param configuration The Flink configuration
-	 * @param listeningAddress The address to listen at.
-	 * @param portRangeDefinition The port range to choose a port from.
+	 * @param externalAddress The external address to access the ActorSystem.
+	 * @param externalPortRange The choosing range of the external port to access the ActorSystem.
 	 * @param logger The logger to output log information.
 	 * @return The ActorSystem which has been started
 	 * @throws Exception Thrown when actor system cannot be started in specified port range
 	 */
-	public static ActorSystem startActorSystem(
+	@VisibleForTesting
+	public static ActorSystem startRemoteActorSystem(
 		Configuration configuration,
-		String listeningAddress,
-		String portRangeDefinition,
+		String externalAddress,
+		String externalPortRange,
 		Logger logger) throws Exception {
-		return startActorSystem(
-			configuration,
-			listeningAddress,
-			portRangeDefinition,
-			logger,
-			ForkJoinExecutorConfiguration.fromConfiguration(configuration));
-	}
-
-	/**
-	 * Starts an ActorSystem with the given configuration listening at the address/ports.
-	 *
-	 * @param configuration The Flink configuration
-	 * @param listeningAddress The address to listen at.
-	 * @param portRangeDefinition The port range to choose a port from.
-	 * @param logger The logger to output log information.
-	 * @param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor
-	 * @return The ActorSystem which has been started
-	 * @throws Exception Thrown when actor system cannot be started in specified port range
-	 */
-	public static ActorSystem startActorSystem(
-			Configuration configuration,
-			String listeningAddress,
-			String portRangeDefinition,
-			Logger logger,
-			@Nonnull ActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {
-		return startActorSystem(
+		return startRemoteActorSystem(
 			configuration,
 			AkkaUtils.getFlinkActorSystemName(),
-			listeningAddress,
-			portRangeDefinition,
+			externalAddress,
+			externalPortRange,
+			NetUtils.getWildcardIPAddress(),
+			Optional.empty(),
 			logger,
-			actorSystemExecutorConfiguration);
+			ForkJoinExecutorConfiguration.fromConfiguration(configuration),
+			null);
 	}
 
 	/**
-	 * Starts an ActorSystem with the given configuration listening at the address/ports.
+	 * Starts a remote ActorSystem at given address and specific port range.
 	 *
 	 * @param configuration The Flink configuration
 	 * @param actorSystemName Name of the started {@link ActorSystem}
-	 * @param listeningAddress The address to listen at.
-	 * @param portRangeDefinition The port range to choose a port from.
+	 * @param externalAddress The external address to access the ActorSystem.
+	 * @param externalPortRange The choosing range of the external port to access the ActorSystem.
+	 * @param bindAddress The local address to bind to.
+	 * @param bindPort The local port to bind to. If not present, then the external port will be used.
 	 * @param logger The logger to output log information.
 	 * @param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor
+	 * @param customConfig Custom Akka config to be combined with the config derived from Flink configuration.
 	 * @return The ActorSystem which has been started
 	 * @throws Exception Thrown when actor system cannot be started in specified port range
 	 */
-	public static ActorSystem startActorSystem(
+	public static ActorSystem startRemoteActorSystem(
 			Configuration configuration,
 			String actorSystemName,
-			String listeningAddress,
-			String portRangeDefinition,
+			String externalAddress,
+			String externalPortRange,
+			String bindAddress,
+			@SuppressWarnings("OptionalUsedAsFieldOrParameterType") Optional<Integer> bindPort,
 			Logger logger,
-			@Nonnull ActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {
+			ActorSystemExecutorConfiguration actorSystemExecutorConfiguration,
+			Config customConfig) throws Exception {
 
 		// parse port range definition and create port iterator
 		Iterator<Integer> portsIterator;
 		try {
-			portsIterator = NetUtils.getPortRangeFromString(portRangeDefinition);
+			portsIterator = NetUtils.getPortRangeFromString(externalPortRange);
 		} catch (Exception e) {
-			throw new IllegalArgumentException("Invalid port range definition: " + portRangeDefinition);
+			throw new IllegalArgumentException("Invalid port range definition: " + externalPortRange);
 		}
 
 		while (portsIterator.hasNext()) {
-			final int port = portsIterator.next();
+			final int externalPort = portsIterator.next();
 
 			try {
-				return startActorSystem(
+				return startRemoteActorSystem(
 					configuration,
 					actorSystemName,
-					listeningAddress,
-					port,
+					externalAddress,
+					externalPort,
+					bindAddress,
+					bindPort.orElse(externalPort),
 					logger,
-					actorSystemExecutorConfiguration);
+					actorSystemExecutorConfiguration,
+					customConfig);
 			}
 			catch (Exception e) {
 				// we can continue to try if this contains a netty channel exception
@@ -181,104 +170,115 @@ public class BootstrapTools {
 
 		// if we come here, we have exhausted the port range
 		throw new BindException("Could not start actor system on any port in port range "
-			+ portRangeDefinition);
+			+ externalPortRange);
 	}
 
 	/**
-	 * Starts an Actor System at a specific port.
-	 *
+	 * Starts a remote Actor System at given address and specific port.
 	 * @param configuration The Flink configuration.
-	 * @param listeningAddress The address to listen at.
-	 * @param listeningPort The port to listen at.
+	 * @param actorSystemName Name of the started {@link ActorSystem}
+	 * @param externalAddress The external address to access the ActorSystem.
+	 * @param externalPort The external port to access the ActorSystem.
+	 * @param bindAddress The local address to bind to.
+	 * @param bindPort The local port to bind to.
 	 * @param logger the logger to output log information.
+	 * @param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor
+	 * @param customConfig Custom Akka config to be combined with the config derived from Flink configuration.
 	 * @return The ActorSystem which has been started.
 	 * @throws Exception
 	 */
-	public static ActorSystem startActorSystem(
+	private static ActorSystem startRemoteActorSystem(
 		Configuration configuration,
-		String listeningAddress,
-		int listeningPort,
-		Logger logger) throws Exception {
-		return startActorSystem(
-			configuration,
-			listeningAddress,
-			listeningPort,
-			logger,
-			ForkJoinExecutorConfiguration.fromConfiguration(configuration));
-	}
+		String actorSystemName,
+		String externalAddress,
+		int externalPort,
+		String bindAddress,
+		int bindPort,
+		Logger logger,
+		ActorSystemExecutorConfiguration actorSystemExecutorConfiguration,
+		Config customConfig) throws Exception {
 
-	/**
-	 * Starts an Actor System at a specific port.
-	 * @param configuration The Flink configuration.
-	 * @param listeningAddress The address to listen at.
-	 * @param listeningPort The port to listen at.
-	 * @param logger the logger to output log information.
-	 * @param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor
-	 * @return The ActorSystem which has been started.
-	 * @throws Exception
-	 */
-	public static ActorSystem startActorSystem(
-				Configuration configuration,
-				String listeningAddress,
-				int listeningPort,
-				Logger logger,
-				ActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {
-		return startActorSystem(
-			configuration,
-			AkkaUtils.getFlinkActorSystemName(),
-			listeningAddress,
-			listeningPort,
-			logger,
-			actorSystemExecutorConfiguration);
+		String externalHostPortUrl = NetUtils.unresolvedHostAndPortToNormalizedString(externalAddress, externalPort);
+		String bindHostPortUrl = NetUtils.unresolvedHostAndPortToNormalizedString(bindAddress, bindPort);
+		logger.info("Trying to start actor system, external address {}, bind address {}.", externalHostPortUrl, bindHostPortUrl);
+
+		try {
+			Config akkaConfig = AkkaUtils.getAkkaConfig(
+				configuration,
+				new Some<>(new Tuple2<>(externalAddress, externalPort)),
+				new Some<>(new Tuple2<>(bindAddress, bindPort)),
+				actorSystemExecutorConfiguration.getAkkaConfig());
+
+			if (customConfig != null) {
+				akkaConfig = customConfig.withFallback(akkaConfig);
+			}
+
+			return startActorSystem(akkaConfig, actorSystemName, logger);
+		}
+		catch (Throwable t) {
+			if (t instanceof ChannelException) {
+				Throwable cause = t.getCause();
+				if (cause != null && t.getCause() instanceof BindException) {
+					throw new IOException("Unable to create ActorSystem at address " + bindHostPortUrl +
+						" : " + cause.getMessage(), t);
+				}
+			}
+			throw new Exception("Could not create actor system", t);
+		}
 	}
 
 	/**
-	 * Starts an Actor System at a specific port.
+	 * Starts a local Actor System.
 	 * @param configuration The Flink configuration.
-	 * @param actorSystemName Name of the started {@link ActorSystem}
-	 * @param listeningAddress The address to listen at.
-	 * @param listeningPort The port to listen at.
-	 * @param logger the logger to output log information.
-	 * @param actorSystemExecutorConfiguration configuration for the ActorSystem's underlying executor
+	 * @param actorSystemName Name of the started ActorSystem.
+	 * @param logger The logger to output log information.
+	 * @param actorSystemExecutorConfiguration Configuration for the ActorSystem's underlying executor.
+	 * @param customConfig Custom Akka config to be combined with the config derived from Flink configuration.
 	 * @return The ActorSystem which has been started.
 	 * @throws Exception
 	 */
-	public static ActorSystem startActorSystem(
+	public static ActorSystem startLocalActorSystem(
 		Configuration configuration,
 		String actorSystemName,
-		String listeningAddress,
-		int listeningPort,
 		Logger logger,
-		ActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {
+		ActorSystemExecutorConfiguration actorSystemExecutorConfiguration,
+		Config customConfig) throws Exception {
 
-		String hostPortUrl = NetUtils.unresolvedHostAndPortToNormalizedString(listeningAddress, listeningPort);
-		logger.info("Trying to start actor system at {}", hostPortUrl);
+		logger.info("Trying to start local actor system");
 
 		try {
 			Config akkaConfig = AkkaUtils.getAkkaConfig(
 				configuration,
-				new Some<>(new Tuple2<>(listeningAddress, listeningPort)),
+				scala.Option.empty(),
+				scala.Option.empty(),
 				actorSystemExecutorConfiguration.getAkkaConfig());
 
-			logger.debug("Using akka configuration\n {}", akkaConfig);
-
-			ActorSystem actorSystem = AkkaUtils.createActorSystem(actorSystemName, akkaConfig);
+			if (customConfig != null) {
+				akkaConfig = customConfig.withFallback(akkaConfig);
+			}
 
-			logger.info("Actor system started at {}", AkkaUtils.getAddress(actorSystem));
-			return actorSystem;
+			return startActorSystem(akkaConfig, actorSystemName, logger);
 		}
 		catch (Throwable t) {
-			if (t instanceof ChannelException) {
-				Throwable cause = t.getCause();
-				if (cause != null && t.getCause() instanceof BindException) {
-					throw new IOException("Unable to create ActorSystem at address " + hostPortUrl +
-						" : " + cause.getMessage(), t);
-				}
-			}
 			throw new Exception("Could not create actor system", t);
 		}
 	}
 
+	/**
+	 * Starts an Actor System with given Akka config.
+	 * @param akkaConfig Config of the started ActorSystem.
+	 * @param actorSystemName Name of the started ActorSystem.
+	 * @param logger The logger to output log information.
+	 * @return The ActorSystem which has been started.
+	 */
+	private static ActorSystem startActorSystem(Config akkaConfig, String actorSystemName, Logger logger) {
+		logger.debug("Using akka configuration\n {}", akkaConfig);
+		ActorSystem actorSystem = AkkaUtils.createActorSystem(actorSystemName, akkaConfig);
+
+		logger.info("Actor system started at {}", AkkaUtils.getAddress(actorSystem));
+		return actorSystem;
+	}
+
 	/**
 	 * Writes a Flink YAML config file from a Flink Configuration object.
 	 * @param cfg The Flink config
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
index f66eda823c5..faa5a98fb95 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/entrypoint/ClusterEntrypoint.java
@@ -282,7 +282,7 @@ public abstract class ClusterEntrypoint implements AutoCloseableAsync, FatalErro
 
 	@Nonnull
 	private RpcService createRpcService(Configuration configuration, String bindAddress, String portRange) throws Exception {
-		return AkkaRpcServiceUtils.createRpcService(bindAddress, portRange, configuration);
+		return AkkaRpcServiceUtils.remoteServiceBuilder(configuration, bindAddress, portRange).createAndStart();
 	}
 
 	/**
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/util/MetricUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/util/MetricUtils.java
index cda453d4699..73e33ae8b5d 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/util/MetricUtils.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/util/MetricUtils.java
@@ -136,12 +136,10 @@ public class MetricUtils {
 		final String portRange = configuration.getString(MetricOptions.QUERY_SERVICE_PORT);
 		final int threadPriority = configuration.getInteger(MetricOptions.QUERY_SERVICE_THREAD_PRIORITY);
 
-		return AkkaRpcServiceUtils.createRpcService(
-			hostname,
-			portRange,
-			configuration,
-			METRICS_ACTOR_SYSTEM_NAME,
-			new BootstrapTools.FixedThreadPoolExecutorConfiguration(1, 1, threadPriority));
+		return AkkaRpcServiceUtils.remoteServiceBuilder(configuration, hostname, portRange)
+			.withActorSystemName(METRICS_ACTOR_SYSTEM_NAME)
+			.withActorSystemExecutorConfiguration(new BootstrapTools.FixedThreadPoolExecutorConfiguration(1, 1, threadPriority))
+			.createAndStart();
 	}
 
 	private static void instantiateClassLoaderMetrics(MetricGroup metrics) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
index d760f572cbc..3d00163873c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
@@ -66,8 +66,7 @@ import org.apache.flink.runtime.resourcemanager.StandaloneResourceManagerFactory
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.rpc.RpcUtils;
-import org.apache.flink.runtime.rpc.akka.AkkaRpcService;
-import org.apache.flink.runtime.rpc.akka.AkkaRpcServiceConfiguration;
+import org.apache.flink.runtime.rpc.akka.AkkaRpcServiceUtils;
 import org.apache.flink.runtime.taskexecutor.TaskExecutor;
 import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;
 import org.apache.flink.runtime.util.ExecutorThreadFactory;
@@ -82,8 +81,6 @@ import org.apache.flink.util.ExecutorUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.function.FunctionUtils;
 
-import akka.actor.ActorSystem;
-import com.typesafe.config.Config;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -261,26 +258,30 @@ public class MiniCluster implements JobExecutorService, AutoCloseableAsync {
 				// bring up all the RPC services
 				LOG.info("Starting RPC Service(s)");
 
-				AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration);
-
 				final RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory;
 
 				if (useSingleRpcService) {
 					// we always need the 'commonRpcService' for auxiliary calls
-					commonRpcService = createRpcService(akkaRpcServiceConfig, false, null);
+					commonRpcService = createLocalRpcService(configuration);
 					final CommonRpcServiceFactory commonRpcServiceFactory = new CommonRpcServiceFactory(commonRpcService);
 					taskManagerRpcServiceFactory = commonRpcServiceFactory;
 					dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory;
 				} else {
-					// we always need the 'commonRpcService' for auxiliary calls
-					commonRpcService = createRpcService(akkaRpcServiceConfig, true, null);
 
 					// start a new service per component, possibly with custom bind addresses
 					final String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress();
 					final String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress();
+					final String jobManagerBindPort = miniClusterConfiguration.getJobManagerBindPortRange();
+					final String taskManagerBindPort = miniClusterConfiguration.getTaskManagerBindPortRange();
+
+					dispatcherResourceManagreComponentRpcServiceFactory =
+						new DedicatedRpcServiceFactory(configuration, jobManagerBindAddress, jobManagerBindPort);
+					taskManagerRpcServiceFactory =
+						new DedicatedRpcServiceFactory(configuration, taskManagerBindAddress, taskManagerBindPort);
 
-					dispatcherResourceManagreComponentRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress);
-					taskManagerRpcServiceFactory = new DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress);
+					// we always need the 'commonRpcService' for auxiliary calls
+					// bind to the JobManager address with port 0
+					commonRpcService = createRemoteRpcService(configuration, jobManagerBindAddress, "0");
 				}
 
 				RpcService metricQueryServiceRpcService = MetricUtils.startMetricsRpcService(
@@ -714,35 +715,32 @@ public class MiniCluster implements JobExecutorService, AutoCloseableAsync {
 	}
 
 	/**
-	 * Factory method to instantiate the RPC service.
-	 *
-	 * @param akkaRpcServiceConfig
-	 *            The default RPC timeout for asynchronous "ask" requests.
-	 * @param remoteEnabled
-	 *            True, if the RPC service should be reachable from other (remote) RPC services.
-	 * @param bindAddress
-	 *            The address to bind the RPC service to. Only relevant when "remoteEnabled" is true.
+	 * Factory method to instantiate the remote RPC service.
 	 *
+	 * @param configuration Flink configuration.
+	 * @param bindAddress The address to bind the RPC service to.
+	 * @param bindPortRange The port range to bind the RPC service to.
 	 * @return The instantiated RPC service
 	 */
-	protected RpcService createRpcService(
-			AkkaRpcServiceConfiguration akkaRpcServiceConfig,
-			boolean remoteEnabled,
-			String bindAddress) {
-
-		final Config akkaConfig;
-
-		if (remoteEnabled) {
-			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration(), bindAddress, 0);
-		} else {
-			akkaConfig = AkkaUtils.getAkkaConfig(akkaRpcServiceConfig.getConfiguration());
-		}
-
-		final Config effectiveAkkaConfig = AkkaUtils.testDispatcherConfig().withFallback(akkaConfig);
-
-		final ActorSystem actorSystem = AkkaUtils.createActorSystem(effectiveAkkaConfig);
+	protected RpcService createRemoteRpcService(
+			Configuration configuration,
+			String bindAddress,
+			String bindPortRange) throws Exception {
+		return AkkaRpcServiceUtils.remoteServiceBuilder(configuration, bindAddress, bindPortRange)
+			.withCustomConfig(AkkaUtils.testDispatcherConfig())
+			.createAndStart();
+	}
 
-		return new AkkaRpcService(actorSystem, akkaRpcServiceConfig);
+	/**
+	 * Factory method to instantiate the local RPC service.
+	 *
+	 * @param configuration Flink configuration.
+	 * @return The instantiated RPC service
+	 */
+	protected RpcService createLocalRpcService(Configuration configuration) throws Exception {
+		return AkkaRpcServiceUtils.localServiceBuilder(configuration)
+			.withCustomConfig(AkkaUtils.testDispatcherConfig())
+			.createAndStart();
 	}
 
 	// ------------------------------------------------------------------------
@@ -878,7 +876,7 @@ public class MiniCluster implements JobExecutorService, AutoCloseableAsync {
 	 * Internal factory for {@link RpcService}.
 	 */
 	protected interface RpcServiceFactory {
-		RpcService createRpcService();
+		RpcService createRpcService() throws Exception;
 	}
 
 	/**
@@ -903,17 +901,19 @@ public class MiniCluster implements JobExecutorService, AutoCloseableAsync {
 	 */
 	protected class DedicatedRpcServiceFactory implements RpcServiceFactory {
 
-		private final AkkaRpcServiceConfiguration akkaRpcServiceConfig;
+		private final Configuration configuration;
 		private final String bindAddress;
+		private final String bindPortRange;
 
-		DedicatedRpcServiceFactory(AkkaRpcServiceConfiguration akkaRpcServiceConfig, String bindAddress) {
-			this.akkaRpcServiceConfig = akkaRpcServiceConfig;
+		DedicatedRpcServiceFactory(Configuration configuration, String bindAddress, String bindPortRange) {
+			this.configuration = configuration;
 			this.bindAddress = bindAddress;
+			this.bindPortRange = bindPortRange;
 		}
 
 		@Override
-		public RpcService createRpcService() {
-			final RpcService rpcService = MiniCluster.this.createRpcService(akkaRpcServiceConfig, true, bindAddress);
+		public RpcService createRpcService() throws Exception {
+			final RpcService rpcService = MiniCluster.this.createRemoteRpcService(configuration, bindAddress, bindPortRange);
 
 			synchronized (lock) {
 				rpcServices.add(rpcService);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterConfiguration.java b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterConfiguration.java
index b1341c5f317..f4d6d49e164 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterConfiguration.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniClusterConfiguration.java
@@ -106,6 +106,14 @@ public class MiniClusterConfiguration {
 				configuration.getString(TaskManagerOptions.HOST, "localhost");
 	}
 
+	public String getJobManagerBindPortRange() {
+		return String.valueOf(configuration.getInteger(JobManagerOptions.PORT, 0));
+	}
+
+	public String getTaskManagerBindPortRange() {
+		return configuration.getString(TaskManagerOptions.RPC_PORT);
+	}
+
 	public Time getRpcTimeout() {
 		return AkkaUtils.getTimeoutAsTime(configuration);
 	}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java
index 0c41f053e68..f629ffd31d7 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcService.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.rpc.akka;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.concurrent.FutureUtils;
@@ -106,6 +107,7 @@ public class AkkaRpcService implements RpcService {
 
 	private volatile boolean stopped;
 
+	@VisibleForTesting
 	public AkkaRpcService(final ActorSystem actorSystem, final AkkaRpcServiceConfiguration configuration) {
 		this.actorSystem = checkNotNull(actorSystem, "actor system");
 		this.configuration = checkNotNull(configuration, "akka rpc service configuration");
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java
index 7d9d37f58cb..181c0af74a5 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rpc/akka/AkkaRpcServiceUtils.java
@@ -18,13 +18,14 @@
 
 package org.apache.flink.runtime.rpc.akka;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.configuration.AkkaOptions;
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.clusterframework.BootstrapTools;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServicesUtils;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServicesUtils.AddressResolution;
 import org.apache.flink.runtime.net.SSLUtils;
-import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.util.NetUtils;
 import org.apache.flink.util.Preconditions;
 
@@ -34,11 +35,11 @@ import com.typesafe.config.ConfigFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 
-import java.io.IOException;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.Optional;
 import java.util.concurrent.atomic.AtomicLong;
 
 import static org.apache.flink.util.NetUtils.isValidClientPort;
@@ -68,75 +69,17 @@ public class AkkaRpcServiceUtils {
 	//  RPC instantiation
 	// ------------------------------------------------------------------------
 
-	/**
-	 * Utility method to create RPC service from configuration and hostname, port.
-	 *
-	 * @param hostname   The hostname/address that describes the TaskManager's data location.
-	 * @param portRangeDefinition   The port range to start TaskManager on.
-	 * @param configuration                 The configuration for the TaskManager.
-	 * @return   The rpc service which is used to start and connect to the TaskManager RpcEndpoint .
-	 * @throws IOException      Thrown, if the actor system can not bind to the address
-	 * @throws Exception      Thrown is some other error occurs while creating akka actor system
-	 */
-	public static RpcService createRpcService(
-			String hostname,
-			String portRangeDefinition,
-			Configuration configuration) throws Exception {
-		final ActorSystem actorSystem = BootstrapTools.startActorSystem(configuration, hostname, portRangeDefinition, LOG);
-		return instantiateAkkaRpcService(configuration, actorSystem);
-	}
-
-	/**
-	 * Utility method to create RPC service from configuration and hostname, port.
-	 *
-	 * @param hostname   The hostname/address that describes the TaskManager's data location.
-	 * @param port           If true, the TaskManager will not initiate the TCP network stack.
-	 * @param configuration                 The configuration for the TaskManager.
-	 * @return   The rpc service which is used to start and connect to the TaskManager RpcEndpoint .
-	 * @throws IOException      Thrown, if the actor system can not bind to the address
-	 * @throws Exception      Thrown is some other error occurs while creating akka actor system
-	 */
-	public static RpcService createRpcService(
-			String hostname,
-			int port,
-			Configuration configuration) throws Exception {
-		final ActorSystem actorSystem = BootstrapTools.startActorSystem(configuration, hostname, port, LOG);
-		return instantiateAkkaRpcService(configuration, actorSystem);
+	public static AkkaRpcServiceBuilder remoteServiceBuilder(Configuration configuration, @Nullable String externalAddress, String externalPortRange) {
+		return new AkkaRpcServiceBuilder(configuration, LOG, externalAddress, externalPortRange);
 	}
 
-	/**
-	 * Utility method to create RPC service from configuration and hostname, port.
-	 *
-	 * @param hostname The hostname/address that describes the TaskManager's data location.
-	 * @param portRangeDefinition The port range to start TaskManager on.
-	 * @param configuration The configuration for the TaskManager.
-	 * @param actorSystemName The actor system name of the RpcService.
-	 * @param actorSystemExecutorConfiguration The configuration of the executor of the actor system.
-	 * @return The rpc service which is used to start and connect to the TaskManager RpcEndpoint .
-	 * @throws IOException Thrown, if the actor system can not bind to the address
-	 * @throws Exception Thrown is some other error occurs while creating akka actor system
-	 */
-	public static RpcService createRpcService(
-		String hostname,
-		String portRangeDefinition,
-		Configuration configuration,
-		String actorSystemName,
-		@Nonnull BootstrapTools.ActorSystemExecutorConfiguration actorSystemExecutorConfiguration) throws Exception {
-
-		final ActorSystem actorSystem = BootstrapTools.startActorSystem(
-			configuration,
-			actorSystemName,
-			hostname,
-			portRangeDefinition,
-			LOG,
-			actorSystemExecutorConfiguration);
-
-		return instantiateAkkaRpcService(configuration, actorSystem);
+	@VisibleForTesting
+	public static AkkaRpcServiceBuilder remoteServiceBuilder(Configuration configuration, @Nullable String externalAddress, int externalPort) {
+		return remoteServiceBuilder(configuration, externalAddress, String.valueOf(externalPort));
 	}
 
-	@Nonnull
-	private static RpcService instantiateAkkaRpcService(Configuration configuration, ActorSystem actorSystem) {
-		return new AkkaRpcService(actorSystem, AkkaRpcServiceConfiguration.fromConfiguration(configuration));
+	public static AkkaRpcServiceBuilder localServiceBuilder(Configuration configuration) {
+		return new AkkaRpcServiceBuilder(configuration, LOG);
 	}
 
 	// ------------------------------------------------------------------------
@@ -246,6 +189,113 @@ public class AkkaRpcServiceUtils {
 		return akkaConfig.getBytes(MAXIMUM_FRAME_SIZE_PATH);
 	}
 
+	// ------------------------------------------------------------------------
+	//  RPC service builder
+	// ------------------------------------------------------------------------
+
+	/**
+	 * Builder for {@link AkkaRpcService}.
+	 */
+	public static class AkkaRpcServiceBuilder {
+
+		private final Configuration configuration;
+		private final Logger logger;
+		@Nullable private final String externalAddress;
+		@Nullable private final String externalPortRange;
+
+		private String actorSystemName = AkkaUtils.getFlinkActorSystemName();
+		@Nullable private BootstrapTools.ActorSystemExecutorConfiguration actorSystemExecutorConfiguration = null;
+		@Nullable private Config customConfig = null;
+		private String bindAddress = NetUtils.getWildcardIPAddress();
+		@Nullable private Integer bindPort = null;
+
+		/**
+		 * Builder for creating a remote RPC service.
+		 */
+		private AkkaRpcServiceBuilder(
+			final Configuration configuration,
+			final Logger logger,
+			@Nullable final String externalAddress,
+			final String externalPortRange) {
+			this.configuration = Preconditions.checkNotNull(configuration);
+			this.logger = Preconditions.checkNotNull(logger);
+			this.externalAddress = externalAddress == null ? InetAddress.getLoopbackAddress().getHostAddress() : externalAddress;
+			this.externalPortRange = Preconditions.checkNotNull(externalPortRange);
+		}
+
+		/**
+		 * Builder for creating a local RPC service.
+		 */
+		private AkkaRpcServiceBuilder(
+			final Configuration configuration,
+			final Logger logger) {
+			this.configuration = Preconditions.checkNotNull(configuration);
+			this.logger = Preconditions.checkNotNull(logger);
+			this.externalAddress = null;
+			this.externalPortRange = null;
+		}
+
+		public AkkaRpcServiceBuilder withActorSystemName(final String actorSystemName) {
+			this.actorSystemName = Preconditions.checkNotNull(actorSystemName);
+			return this;
+		}
+
+		public AkkaRpcServiceBuilder withActorSystemExecutorConfiguration(
+			final BootstrapTools.ActorSystemExecutorConfiguration actorSystemExecutorConfiguration) {
+			this.actorSystemExecutorConfiguration = actorSystemExecutorConfiguration;
+			return this;
+		}
+
+		public AkkaRpcServiceBuilder withCustomConfig(final Config customConfig) {
+			this.customConfig = customConfig;
+			return this;
+		}
+
+		public AkkaRpcServiceBuilder withBindAddress(final String bindAddress) {
+			this.bindAddress = Preconditions.checkNotNull(bindAddress);
+			return this;
+		}
+
+		public AkkaRpcServiceBuilder withBindPort(int bindPort) {
+			Preconditions.checkArgument(NetUtils.isValidHostPort(bindPort), "Invalid port number: " + bindPort);
+			this.bindPort = bindPort;
+			return this;
+		}
+
+		public AkkaRpcService createAndStart() throws Exception {
+			if (actorSystemExecutorConfiguration == null) {
+				actorSystemExecutorConfiguration = BootstrapTools.ForkJoinExecutorConfiguration.fromConfiguration(configuration);
+			}
+
+			final ActorSystem actorSystem;
+
+			if (externalAddress == null) {
+				// create local actor system
+				actorSystem = BootstrapTools.startLocalActorSystem(
+					configuration,
+					actorSystemName,
+					logger,
+					actorSystemExecutorConfiguration,
+					customConfig);
+			} else {
+				// create remote actor system
+				actorSystem = BootstrapTools.startRemoteActorSystem(
+					configuration,
+					actorSystemName,
+					externalAddress,
+					externalPortRange,
+					bindAddress,
+					Optional.ofNullable(bindPort),
+					logger,
+					actorSystemExecutorConfiguration,
+					customConfig);
+			}
+
+			return new AkkaRpcService(actorSystem, AkkaRpcServiceConfiguration.fromConfiguration(configuration));
+		}
+
+	}
+
 	// ------------------------------------------------------------------------
 
 	/** This class is not meant to be instantiated. */
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
index 8ed4fe478eb..a62db016d53 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskManagerRunner.java
@@ -422,7 +422,7 @@ public class TaskManagerRunner implements FatalErrorHandler, AutoCloseableAsync
 		final String taskManagerAddress = determineTaskManagerBindAddress(configuration, haServices);
 		final String portRangeDefinition = configuration.getString(TaskManagerOptions.RPC_PORT);
 
-		return AkkaRpcServiceUtils.createRpcService(taskManagerAddress, portRangeDefinition, configuration);
+		return AkkaRpcServiceUtils.remoteServiceBuilder(configuration, taskManagerAddress, portRangeDefinition).createAndStart();
 	}
 
 	private static String determineTaskManagerBindAddress(
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/akka/AkkaUtils.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/akka/AkkaUtils.scala
index 0e20d43f664..efa15c2dbd3 100755
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/akka/AkkaUtils.scala
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/akka/AkkaUtils.scala
@@ -148,7 +148,7 @@ object AkkaUtils {
                     hostname: String,
                     port: Int,
                     executorConfig: Config): Config = {
-    getAkkaConfig(configuration, Some((hostname, port)), executorConfig)
+    getAkkaConfig(configuration, Some((hostname, port)), None, executorConfig)
   }
 
   /**
@@ -191,6 +191,7 @@ object AkkaUtils {
     getAkkaConfig(
       configuration,
       externalAddress,
+      None,
       getForkJoinExecutorConfig(ForkJoinExecutorConfiguration.fromConfiguration(configuration)))
   }
 
@@ -199,28 +200,42 @@ object AkkaUtils {
     * specified, then the actor system will listen on the respective address.
     *
     * @param configuration instance containing the user provided configuration values
-    * @param externalAddress optional tuple of bindAddress and port to be reachable at.
+    * @param externalAddress optional tuple of external address and port to be reachable at.
     *                        If None is given, then an Akka config for local actor system
     *                        will be returned
+    * @param bindAddress optional tuple of bind address and port to be used locally.
+    *                    If None is given, wildcard IP address and the external port wil be used.
+    *                    Take effects only if externalAddress is not None.
     * @param executorConfig config defining the used executor by the default dispatcher
     * @return Akka config
     */
   @throws(classOf[UnknownHostException])
   def getAkkaConfig(configuration: Configuration,
                     externalAddress: Option[(String, Int)],
+                    bindAddress: Option[(String, Int)],
                     executorConfig: Config): Config = {
     val defaultConfig = getBasicAkkaConfig(configuration).withFallback(executorConfig)
 
     externalAddress match {
 
-      case Some((hostname, port)) =>
+      case Some((externalHostname, externalPort)) =>
 
-        val remoteConfig = getRemoteAkkaConfig(configuration,
-          // the wildcard IP lets us bind to all network interfaces
-          NetUtils.getWildcardIPAddress, port,
-          hostname, port)
+        bindAddress match {
 
-        remoteConfig.withFallback(defaultConfig)
+          case Some((bindHostname, bindPort)) =>
+
+            val remoteConfig = getRemoteAkkaConfig(
+              configuration, bindHostname, bindPort, externalHostname, externalPort)
+
+            remoteConfig.withFallback(defaultConfig)
+
+          case None =>
+            val remoteConfig = getRemoteAkkaConfig(configuration,
+              // the wildcard IP lets us bind to all network interfaces
+              NetUtils.getWildcardIPAddress, externalPort, externalHostname, externalPort)
+
+            remoteConfig.withFallback(defaultConfig)
+        }
 
       case None =>
         defaultConfig
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/BootstrapToolsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/BootstrapToolsTest.java
index 9338ac2d925..cee17cac449 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/BootstrapToolsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/clusterframework/BootstrapToolsTest.java
@@ -392,7 +392,7 @@ public class BootstrapToolsTest extends TestLogger {
 							CheckedSupplier.unchecked(() -> {
 								cyclicBarrier.await();
 
-								return BootstrapTools.startActorSystem(
+								return BootstrapTools.startRemoteActorSystem(
 									new Configuration(),
 									"localhost",
 									"0",
@@ -420,7 +420,7 @@ public class BootstrapToolsTest extends TestLogger {
 
 		try {
 			final int port = portOccupier.getLocalPort();
-			BootstrapTools.startActorSystem(new Configuration(), "0.0.0.0", port, LOG);
+			BootstrapTools.startRemoteActorSystem(new Configuration(), "0.0.0.0", String.valueOf(port), LOG);
 			fail("Expected to fail with a BindException");
 		} catch (Exception e) {
 			assertThat(ExceptionUtils.findThrowable(e, BindException.class).isPresent(), is(true));
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorOversizedResponseMessageTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorOversizedResponseMessageTest.java
index 5e607bc8cad..4d0e1f19199 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorOversizedResponseMessageTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/AkkaRpcActorOversizedResponseMessageTest.java
@@ -67,8 +67,8 @@ public class AkkaRpcActorOversizedResponseMessageTest extends TestLogger {
 		final Configuration configuration = new Configuration();
 		configuration.setString(AkkaOptions.FRAMESIZE, FRAMESIZE + " b");
 
-		rpcService1 = AkkaRpcServiceUtils.createRpcService("localhost", 0, configuration);
-		rpcService2 = AkkaRpcServiceUtils.createRpcService("localhost", 0, configuration);
+		rpcService1 = AkkaRpcServiceUtils.remoteServiceBuilder(configuration, "localhost", 0).createAndStart();
+		rpcService2 = AkkaRpcServiceUtils.remoteServiceBuilder(configuration, "localhost", 0).createAndStart();
 	}
 
 	@AfterClass
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/MessageSerializationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/MessageSerializationTest.java
index 0b9d4da2c42..60c8293c53d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/MessageSerializationTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/akka/MessageSerializationTest.java
@@ -59,8 +59,8 @@ public class MessageSerializationTest extends TestLogger {
 		Configuration configuration = new Configuration();
 		configuration.setString(AkkaOptions.FRAMESIZE, maxFrameSize + "b");
 
-		akkaRpcService1 = AkkaRpcServiceUtils.createRpcService("localhost", 0, configuration);
-		akkaRpcService2 = AkkaRpcServiceUtils.createRpcService("localhost", 0, configuration);
+		akkaRpcService1 = AkkaRpcServiceUtils.remoteServiceBuilder(configuration, "localhost", 0).createAndStart();
+		akkaRpcService2 = AkkaRpcServiceUtils.remoteServiceBuilder(configuration, "localhost", 0).createAndStart();
 	}
 
 	@AfterClass
diff --git a/flink-tests/src/test/java/org/apache/flink/test/recovery/JobManagerHAProcessFailureRecoveryITCase.java b/flink-tests/src/test/java/org/apache/flink/test/recovery/JobManagerHAProcessFailureRecoveryITCase.java
index 12621820237..8400bb4c6ac 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/recovery/JobManagerHAProcessFailureRecoveryITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/recovery/JobManagerHAProcessFailureRecoveryITCase.java
@@ -253,7 +253,7 @@ public class JobManagerHAProcessFailureRecoveryITCase extends TestLogger {
 		config.set(TaskManagerOptions.TASK_HEAP_MEMORY, MemorySize.parse("128m"));
 		config.set(TaskManagerOptions.CPU_CORES, 1.0);
 
-		final RpcService rpcService = AkkaRpcServiceUtils.createRpcService("localhost", 0, config);
+		final RpcService rpcService = AkkaRpcServiceUtils.remoteServiceBuilder(config, "localhost", 0).createAndStart();
 
 		try {
 			final Deadline deadline = Deadline.fromNow(TEST_TIMEOUT);
diff --git a/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java b/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java
index 9d1839511ef..4f78c2f830d 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/recovery/ProcessFailureCancelingITCase.java
@@ -123,7 +123,7 @@ public class ProcessFailureCancelingITCase extends TestLogger {
 		config.set(TaskManagerOptions.CPU_CORES, 1.0);
 		config.setInteger(RestOptions.PORT, 0);
 
-		final RpcService rpcService = AkkaRpcServiceUtils.createRpcService("localhost", 0, config);
+		final RpcService rpcService = AkkaRpcServiceUtils.remoteServiceBuilder(config, "localhost", 0).createAndStart();
 		final int jobManagerPort = rpcService.getPort();
 		config.setInteger(JobManagerOptions.PORT, jobManagerPort);
 
