diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java
index 482a5afbd80..6568551ad1c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCache.java
@@ -157,6 +157,12 @@ public class CompletedOperationCache<K extends OperationKey, R> implements AutoC
         return terminationFuture == null;
     }
 
+    /** Returns whether this cache contains an operation under the given operation key. */
+    public boolean containsOperation(final K operationKey) {
+        return registeredOperationTriggers.containsKey(operationKey)
+                || completedOperations.getIfPresent(operationKey) != null;
+    }
+
     /**
      * Returns an optional containing the {@link OperationResult} for the specified key, or an empty
      * optional if no operation is registered under the key.
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java
index 0f1bc6c3659..6f09fc914cc 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/async/CompletedOperationCacheTest.java
@@ -19,6 +19,7 @@
 package org.apache.flink.runtime.rest.handler.async;
 
 import org.apache.flink.configuration.RestOptions;
+import org.apache.flink.core.testutils.FlinkMatchers;
 import org.apache.flink.runtime.rest.messages.TriggerId;
 import org.apache.flink.runtime.util.ManualTicker;
 import org.apache.flink.util.TestLogger;
@@ -155,4 +156,33 @@ public class CompletedOperationCacheTest extends TestLogger {
 
         assertTrue(completedOperationCache.get(TEST_OPERATION_KEY).isPresent());
     }
+
+    @Test
+    public void containsReturnsFalseForUnknownOperation() {
+        assertThat(completedOperationCache.containsOperation(TEST_OPERATION_KEY), is(false));
+    }
+
+    @Test
+    public void containsChecksOnoingOperations() {
+        completedOperationCache.registerOngoingOperation(
+                TEST_OPERATION_KEY, new CompletableFuture<>());
+        assertThat(completedOperationCache.containsOperation(TEST_OPERATION_KEY), is(true));
+    }
+
+    @Test
+    public void containsChecksCompletedOperations() {
+        completedOperationCache.registerOngoingOperation(
+                TEST_OPERATION_KEY, CompletableFuture.completedFuture(null));
+        assertThat(completedOperationCache.containsOperation(TEST_OPERATION_KEY), is(true));
+    }
+
+    @Test
+    public void containsDoesNotMarkResultAsAccessed() {
+        completedOperationCache.registerOngoingOperation(
+                TEST_OPERATION_KEY, CompletableFuture.completedFuture(null));
+        assertThat(completedOperationCache.containsOperation(TEST_OPERATION_KEY), is(true));
+        assertThat(
+                completedOperationCache.closeAsync(),
+                FlinkMatchers.willNotComplete(Duration.ofMillis(10)));
+    }
 }
