diff --git a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkRexBuilder.java b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkRexBuilder.java
index 27ee4ddedcf..a3f0bb87e8e 100644
--- a/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkRexBuilder.java
+++ b/flink-table/flink-table-planner/src/main/java/org/apache/flink/table/planner/calcite/FlinkRexBuilder.java
@@ -18,11 +18,26 @@
 
 package org.apache.flink.table.planner.calcite;
 
+import org.apache.flink.shaded.guava30.com.google.common.collect.ImmutableList;
+
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.rex.RexBuilder;
+import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
+import org.apache.calcite.runtime.FlatLists;
+import org.apache.calcite.sql.fun.SqlStdOperatorTable;
+import org.apache.calcite.sql.type.SqlTypeUtil;
+import org.apache.calcite.tools.RelBuilder;
+import org.apache.calcite.util.Sarg;
 import org.apache.calcite.util.TimestampString;
+import org.apache.calcite.util.Util;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
 
 /** A slim extension over a {@link RexBuilder}. See the overridden methods for more explanation. */
 public final class FlinkRexBuilder extends RexBuilder {
@@ -95,4 +110,120 @@ public final class FlinkRexBuilder extends RexBuilder {
                 return super.makeZeroLiteral(type);
         }
     }
+
+    /**
+     * Convert the conditions into the {@code IN} and fix [CALCITE-4888]: Unexpected {@link RexNode}
+     * when call {@link RelBuilder#in} to create an {@code IN} predicate with a list of varchar
+     * literals which have different length in {@link RexBuilder#makeIn}.
+     *
+     * <p>The bug is because the origin implementation doesn't take {@link
+     * FlinkTypeSystem#shouldConvertRaggedUnionTypesToVarying} into consideration. When this is
+     * true, the behaviour should not padding char. Please see
+     * https://issues.apache.org/jira/browse/CALCITE-4590 and
+     * https://issues.apache.org/jira/browse/CALCITE-2321. Please refer to {@code
+     * org.apache.calcite.rex.RexSimplify.RexSargBuilder#getType} for the correct behaviour.
+     *
+     * <p>Once CALCITE-4888 is fixed, this method (and related methods) should be removed.
+     */
+    @Override
+    @SuppressWarnings("unchecked")
+    public RexNode makeIn(RexNode arg, List<? extends RexNode> ranges) {
+        if (areAssignable(arg, ranges)) {
+            // Fix calcite doesn't check literal whether is NULL here
+            List<RexNode> rangeWithoutNull = new ArrayList<>();
+            boolean containsNull = false;
+            for (RexNode node : ranges) {
+                if (isNull(node)) {
+                    containsNull = true;
+                } else {
+                    rangeWithoutNull.add(node);
+                }
+            }
+            final Sarg sarg = toSarg(Comparable.class, rangeWithoutNull, containsNull);
+            if (sarg != null) {
+                List<RelDataType> distinctTypes =
+                        Util.distinctList(
+                                ranges.stream().map(RexNode::getType).collect(Collectors.toList()));
+                RelDataType commonType = getTypeFactory().leastRestrictive(distinctTypes);
+                return makeCall(
+                        SqlStdOperatorTable.SEARCH,
+                        arg,
+                        makeSearchArgumentLiteral(sarg, commonType));
+            }
+        }
+        return RexUtil.composeDisjunction(
+                this,
+                ranges.stream()
+                        .map(r -> makeCall(SqlStdOperatorTable.EQUALS, arg, r))
+                        .collect(Util.toImmutableList()));
+    }
+
+    private boolean isNull(RexNode node) {
+        if (node instanceof RexLiteral) {
+            return ((RexLiteral) node).isNull();
+        }
+        return false;
+    }
+
+    /** Copied from the {@link RexBuilder} to fix the {@link RexBuilder#makeIn}. */
+    private boolean areAssignable(RexNode arg, List<? extends RexNode> bounds) {
+        for (RexNode bound : bounds) {
+            if (!SqlTypeUtil.inSameFamily(arg.getType(), bound.getType())
+                    && !(arg.getType().isStruct() && bound.getType().isStruct())) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Converts a list of expressions to a search argument, or returns null if not possible.
+     *
+     * <p>Copied from the {@link RexBuilder} to fix the {@link RexBuilder#makeIn}.
+     */
+    @SuppressWarnings("UnstableApiUsage")
+    private static <C extends Comparable<C>> Sarg<C> toSarg(
+            Class<C> clazz, List<? extends RexNode> ranges, boolean containsNull) {
+        if (ranges.isEmpty()) {
+            // Cannot convert an empty list to a Sarg (by this interface, at least)
+            // because we use the type of the first element.
+            return null;
+        }
+        final com.google.common.collect.RangeSet<C> rangeSet =
+                com.google.common.collect.TreeRangeSet.create();
+        for (RexNode range : ranges) {
+            final C value = toComparable(clazz, range);
+            if (value == null) {
+                return null;
+            }
+            rangeSet.add(com.google.common.collect.Range.singleton(value));
+        }
+        return Sarg.of(containsNull, rangeSet);
+    }
+
+    /** Copied from the {@link RexBuilder} to fix the {@link RexBuilder#makeIn}. */
+    @SuppressWarnings("rawtypes")
+    private static <C extends Comparable<C>> C toComparable(Class<C> clazz, RexNode point) {
+        switch (point.getKind()) {
+            case LITERAL:
+                final RexLiteral literal = (RexLiteral) point;
+                return literal.getValueAs(clazz);
+
+            case ROW:
+                final RexCall call = (RexCall) point;
+                final ImmutableList.Builder<Comparable> b = ImmutableList.builder();
+                for (RexNode operand : call.operands) {
+                    //noinspection unchecked
+                    final Comparable value = toComparable(Comparable.class, operand);
+                    if (value == null) {
+                        return null; // not a constant value
+                    }
+                    b.add(value);
+                }
+                return clazz.cast(FlatLists.ofComparable(b.build()));
+
+            default:
+                return null; // not a constant value
+        }
+    }
 }
diff --git a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.xml b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.xml
index 0975f3f2a31..f8d4745254b 100644
--- a/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.xml
+++ b/flink-table/flink-table-planner/src/test/resources/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.xml
@@ -184,6 +184,36 @@ LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
 LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
 +- LogicalFilter(condition=[OR(=($1, 1), SEARCH($0, Sarg[1, 2, 3, 4]))])
    +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testConvertToSearchString">
+    <Resource name="sql">
+      <![CDATA[
+SELECT * from MyTable where e in (
+'CTNBSmokeSensor',
+'H388N',
+'H389N     ',
+'GHL-IRD',
+'JY-BF-20YN',
+'HC809',
+'DH-9908N-AEP',
+'DH-9908N'
+)
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
++- LogicalFilter(condition=[OR(=($4, _UTF-16LE'CTNBSmokeSensor'), =($4, _UTF-16LE'H388N'), =($4, _UTF-16LE'H389N     '), =($4, _UTF-16LE'GHL-IRD'), =($4, _UTF-16LE'JY-BF-20YN'), =($4, _UTF-16LE'HC809'), =($4, _UTF-16LE'DH-9908N-AEP'), =($4, _UTF-16LE'DH-9908N'))])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
+]]>
+    </Resource>
+    <Resource name="optimized rel plan">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
++- LogicalFilter(condition=[SEARCH($4, Sarg[_UTF-16LE'CTNBSmokeSensor':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'DH-9908N':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'DH-9908N-AEP':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'GHL-IRD':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'H388N':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'H389N     ':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'HC809':VARCHAR(15) CHARACTER SET "UTF-16LE", _UTF-16LE'JY-BF-20YN':VARCHAR(15) CHARACTER SET "UTF-16LE"]:VARCHAR(15) CHARACTER SET "UTF-16LE")])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
 ]]>
     </Resource>
   </TestCase>
@@ -377,9 +407,9 @@ LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testConvertToNotIn_WithOr1">
+  <TestCase name="testConvertToNotIn_WithOr2">
     <Resource name="sql">
-      <![CDATA[SELECT * FROM MyTable WHERE (a <> 1 AND a <> 2 AND a <> 3 AND a <> 4) OR b = 1]]>
+      <![CDATA[SELECT * FROM MyTable WHERE a <> 1 AND a <> 2 AND a <> 3 AND a <> 4 OR b = 1]]>
     </Resource>
     <Resource name="ast">
       <![CDATA[
@@ -396,9 +426,47 @@ LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testConvertToNotIn_WithOr2">
+  <TestCase name="testConvertToNotIn_WithOr3">
     <Resource name="sql">
-      <![CDATA[SELECT * FROM MyTable WHERE a <> 1 AND a <> 2 AND a <> 3 AND a <> 4 OR b = 1]]>
+      <![CDATA[SELECT * FROM MyTable WHERE a <> 1 OR a <> 2 OR a <> 3 OR a <> 4 OR b = 1]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
++- LogicalFilter(condition=[OR(<>($0, 1), <>($0, 2), <>($0, 3), <>($0, 4), =($1, 1))])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
+]]>
+    </Resource>
+    <Resource name="optimized rel plan">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
++- LogicalFilter(condition=[OR(<>($0, 1), <>($0, 2), <>($0, 3), <>($0, 4), =($1, 1))])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testConvertToSearchWithMixedType">
+    <Resource name="sql">
+      <![CDATA[SELECT * FROM MyTable WHERE a is null or a = 1 OR a = 2 OR a = 3.0 OR a = 4.0 OR a = 5 OR a = 7 OR a = CAST(8 AS BIGINT)]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
++- LogicalFilter(condition=[OR(IS NULL($0), =($0, 1), =($0, 2), =(CAST($0):DECIMAL(11, 1), 3.0), =(CAST($0):DECIMAL(11, 1), 4.0), =($0, 5), =($0, 7), =(CAST($0):BIGINT, 8))])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
+]]>
+    </Resource>
+    <Resource name="optimized rel plan">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
++- LogicalFilter(condition=[OR(IS NULL($0), =(CAST($0):DECIMAL(11, 1), 3.0), =(CAST($0):DECIMAL(11, 1), 4.0), =(CAST($0):BIGINT, 8), SEARCH($0, Sarg[1, 2, 5, 7]))])
+   +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testConvertToNotIn_WithOr1">
+    <Resource name="sql">
+      <![CDATA[SELECT * FROM MyTable WHERE (a <> 1 AND a <> 2 AND a <> 3 AND a <> 4) OR b = 1]]>
     </Resource>
     <Resource name="ast">
       <![CDATA[
@@ -415,21 +483,21 @@ LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
 ]]>
     </Resource>
   </TestCase>
-  <TestCase name="testConvertToNotIn_WithOr3">
+  <TestCase name="testConvertToSearchStringWithNull">
     <Resource name="sql">
-      <![CDATA[SELECT * FROM MyTable WHERE a <> 1 OR a <> 2 OR a <> 3 OR a <> 4 OR b = 1]]>
+      <![CDATA[SELECT * FROM MyTable WHERE e = 'a' or e = 'b' or e = 'c' or e = 'd' or e = 'e' or e = 'f' or e = NULL or e = 'HELLO WORLD!']]>
     </Resource>
     <Resource name="ast">
       <![CDATA[
 LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
-+- LogicalFilter(condition=[OR(<>($0, 1), <>($0, 2), <>($0, 3), <>($0, 4), =($1, 1))])
++- LogicalFilter(condition=[OR(=($4, _UTF-16LE'a'), =($4, _UTF-16LE'b'), =($4, _UTF-16LE'c'), =($4, _UTF-16LE'd'), =($4, _UTF-16LE'e'), =($4, _UTF-16LE'f'), =($4, null), =($4, _UTF-16LE'HELLO WORLD!'))])
    +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
 ]]>
     </Resource>
     <Resource name="optimized rel plan">
       <![CDATA[
 LogicalProject(a=[$0], b=[$1], c=[$2], d=[$3], e=[$4])
-+- LogicalFilter(condition=[OR(<>($0, 1), <>($0, 2), <>($0, 3), <>($0, 4), =($1, 1))])
++- LogicalFilter(condition=[SEARCH($4, Sarg[_UTF-16LE'HELLO WORLD!':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'a':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'b':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'c':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'd':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'e':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", _UTF-16LE'f':VARCHAR(2147483647) CHARACTER SET "UTF-16LE", null]:VARCHAR(2147483647) CHARACTER SET "UTF-16LE")])
    +- LogicalTableScan(table=[[default_catalog, default_database, MyTable, source: [TestTableSource(a, b, c, d, e)]]])
 ]]>
     </Resource>
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.scala
index ee31eca3580..7afbc67b93c 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/plan/rules/logical/ConvertToNotInOrInRuleTest.scala
@@ -15,6 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.flink.table.planner.plan.rules.logical
 
 import org.apache.flink.api.scala._
@@ -169,4 +170,39 @@ class ConvertToNotInOrInRuleTest extends TableTestBase {
       "SELECT * FROM MyTable WHERE b = 1 OR b = 2 OR (a <> 1 AND a <> 2 AND a <> 3 " +
       "AND a <> 4 AND c = 1) OR b = 3 OR b = 4 OR c = 1")
   }
+
+  @Test
+  def testConvertToSearchString(): Unit = {
+    util.verifyRelPlan(
+      """
+        |SELECT * from MyTable where e in (
+        |'CTNBSmokeSensor',
+        |'H388N',
+        |'H389N     ',
+        |'GHL-IRD',
+        |'JY-BF-20YN',
+        |'HC809',
+        |'DH-9908N-AEP',
+        |'DH-9908N'
+        |)
+        |""".stripMargin
+    )
+  }
+
+  @Test
+  def testConvertToSearchStringWithNull(): Unit = {
+    util.verifyRelPlan(
+      "SELECT * FROM MyTable WHERE " +
+        "e = 'a' or e = 'b' or e = 'c' or e = 'd' or e = 'e' or e = 'f' or e = NULL or e = " +
+        "'HELLO WORLD!'"
+    )
+  }
+
+  @Test
+  def testConvertToSearchWithMixedType(): Unit = {
+    util.verifyRelPlan(
+      "SELECT * FROM MyTable WHERE a is null or a = 1 OR a = 2 OR a = 3.0 OR a = 4.0 OR a = 5" +
+        " OR a = 7 OR a = CAST(8 AS BIGINT)"
+    )
+  }
 }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala
index 4db37ea0a52..ca7db3a67b4 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/CalcITCase.scala
@@ -1454,6 +1454,98 @@ class CalcITCase extends BatchTestBase {
     )
   }
 
+  @Test
+  def testSearch(): Unit = {
+    val myTableDataId = TestValuesTableFactory.registerData(
+      Seq(row("HC809"), row("H389N     "))
+    )
+    val ddl =
+      s"""
+         |CREATE TABLE SimpleTable (
+         |  content STRING
+         |) WITH (
+         |  'connector' = 'values',
+         |  'data-id' = '$myTableDataId',
+         |  'bounded' = 'true'
+         |)
+         |""".stripMargin
+    tEnv.executeSql(ddl)
+    val sql =
+      """
+        |SELECT UPPER(content) from SimpleTable where UPPER(content) in (
+        |'CTNBSmokeSensor',
+        |'H388N',
+        |'H389N     ',
+        |'GHL-IRD',
+        |'JY-BF-20YN',
+        |'HC809',
+        |'DH-9908N-AEP',
+        |'DH-9908N'
+        |)
+        |""".stripMargin
+    checkResult(
+      sql,
+      Seq(row("HC809"), row("H389N     "))
+    )
+  }
+
+  @Test
+  def testSearchWithNull(): Unit = {
+    runQueryWithIn(
+      """
+        |'CTNBSmokeSensor',
+        |'H389N     ',
+        |'GHL-IRD',
+        |'JY-BF-20YN',
+        |'HC809',
+        |'DH-9908N-AEP',
+        |'DH-9908N',
+        | null""".stripMargin
+    )
+  }
+
+  @Test
+  def testSearchWithNull2(): Unit = {
+    runQueryWithIn(
+      """
+        | null,
+        |'CTNBSmokeSensor',
+        |'H389N     ',
+        |'GHL-IRD',
+        |'JY-BF-20YN',
+        |'HC809',
+        |'DH-9908N-AEP',
+        |'DH-9908N'
+        |""".stripMargin
+    )
+  }
+
+  private def runQueryWithIn(inParameter: String): Unit = {
+    val myTableDataId = TestValuesTableFactory.registerData(
+      Seq(row("HC809"), row(null)))
+    val ddl =
+      s"""
+         |CREATE TABLE SimpleTable (
+         |  content String
+         |) WITH (
+         |  'connector' = 'values',
+         |  'data-id' = '$myTableDataId',
+         |  'bounded' = 'true'
+         |)
+         |""".stripMargin
+    tEnv.executeSql(ddl)
+    val sql =
+      s"""
+         |SELECT content from SimpleTable where UPPER(content) in (
+         | $inParameter
+         |)
+         |""".stripMargin
+    checkResult(
+      sql,
+      Seq(row("HC809"))
+    )
+  }
+
   @Test
   def testFilterPushDownWithInterval(): Unit = {
     val schema = TableSchema
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala
index 54ccb7f45ba..1d887a194ea 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/CalcITCase.scala
@@ -593,4 +593,32 @@ class CalcITCase extends StreamingTestBase {
     val result = tEnv.sqlQuery("SELECT * FROM T").execute().collect().toList
     TestBaseUtils.compareResultAsText(result, "42")
   }
+
+  @Test
+  def testSearch(): Unit = {
+    val stream = env.fromElements("HC809", "H389N     ")
+    tEnv.createTemporaryView(
+      "SimpleTable", stream, Schema.newBuilder().column("f0", DataTypes.STRING()).build())
+
+    val sql =
+      """
+        |SELECT upper(f0) from SimpleTable where upper(f0) in (
+        |'CTNBSmokeSensor',
+        |'H388N',
+        |'H389N     ',
+        |'GHL-IRD',
+        |'JY-BF-20YN',
+        |'HC809',
+        |'DH-9908N-AEP',
+        |'DH-9908N'
+        |)
+        |""".stripMargin
+    val result = tEnv.sqlQuery(sql).toAppendStream[Row]
+    val sink = new TestingAppendSink
+    result.addSink(sink)
+    env.execute()
+    val expected =
+      List("HC809", "H389N     ")
+    assertEquals(expected.sorted, sink.getAppendResults.sorted)
+  }
 }
