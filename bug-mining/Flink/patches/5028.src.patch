diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java
index eef4437a735..a70e74d51a9 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java
@@ -69,6 +69,8 @@ public abstract class RecoveredInputChannel extends InputChannel implements Chan
     protected final int networkBuffersPerChannel;
     private boolean exclusiveBuffersAssigned;
 
+    private long lastStoppedCheckpointId = -1;
+
     RecoveredInputChannel(
             SingleInputGate inputGate,
             int channelIndex,
@@ -100,7 +102,14 @@ public abstract class RecoveredInputChannel extends InputChannel implements Chan
     public final InputChannel toInputChannel() throws IOException {
         Preconditions.checkState(
                 stateConsumedFuture.isDone(), "recovered state is not fully consumed");
-        return toInputChannelInternal();
+        final InputChannel inputChannel = toInputChannelInternal();
+        inputChannel.checkpointStopped(lastStoppedCheckpointId);
+        return inputChannel;
+    }
+
+    @Override
+    public void checkpointStopped(long checkpointId) {
+        this.lastStoppedCheckpointId = checkpointId;
     }
 
     protected abstract InputChannel toInputChannelInternal() throws IOException;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java
index 940d3709e64..fe1a241acd6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersisterTest.java
@@ -64,6 +64,41 @@ public class ChannelStatePersisterTest {
         assertFalse(persister.hasBarrierReceived());
     }
 
+    @Test
+    public void testLateBarrierOnCancelledCheckpoint() throws IOException {
+        ChannelStatePersister persister =
+                new ChannelStatePersister(ChannelStateWriter.NO_OP, new InputChannelInfo(0, 0));
+
+        persister.startPersisting(1L, Collections.emptyList());
+        // checkpoint aborted
+        persister.stopPersisting(1L);
+
+        // late barrier
+        persister.checkForBarrier(barrier(1L));
+
+        persister.startPersisting(2L, Collections.emptyList());
+        persister.checkForBarrier(barrier(2L));
+
+        assertTrue(persister.hasBarrierReceived());
+    }
+
+    @Test
+    public void testLateBarrierOnCancelledCheckpointAfterRecover() throws IOException {
+        ChannelStatePersister persister =
+                new ChannelStatePersister(ChannelStateWriter.NO_OP, new InputChannelInfo(0, 0));
+
+        // checkpoint aborted, stopPersisting called on recovered input channel without persister
+        persister.stopPersisting(1L);
+
+        // late barrier
+        persister.checkForBarrier(barrier(1L));
+
+        persister.startPersisting(2L, Collections.emptyList());
+        persister.checkForBarrier(barrier(2L));
+
+        assertTrue(persister.hasBarrierReceived());
+    }
+
     private static Buffer barrier(long id) throws IOException {
         return EventSerializer.toBuffer(
                 new CheckpointBarrier(id, 1L, CheckpointOptions.forCheckpointWithDefaultLocation()),
