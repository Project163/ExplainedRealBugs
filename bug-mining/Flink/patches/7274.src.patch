diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala
index 084b3aa503e..230b09adccc 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/planner/codegen/calls/ScalarOperatorGens.scala
@@ -345,44 +345,83 @@ object ScalarOperatorGens {
     }
   }
 
-  def generateEquals(
+  private def wrapExpressionIfNonEq(
+      isNonEq: Boolean,
+      equalsExpr: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    if (isNonEq) {
+      GeneratedExpression(
+        s"(!${equalsExpr.resultTerm})",
+        equalsExpr.nullTerm,
+        equalsExpr.code,
+        resultType)
+    } else {
+      equalsExpr
+    }
+  }
+
+  private def generateEqualAndNonEqual(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
       right: GeneratedExpression,
+      operator: String,
       resultType: LogicalType): GeneratedExpression = {
+
     checkImplicitConversionValidity(left, right)
+
+    val nonEq = operator match {
+      case "==" => false
+      case "!=" => true
+      case _ => throw new CodeGenException(s"Unsupported boolean comparison '$operator'.")
+    }
     val canEqual = isInteroperable(left.resultType, right.resultType)
+
     if (isCharacterString(left.resultType) && isCharacterString(right.resultType)) {
       generateOperatorIfNotNull(ctx, resultType, left, right)(
-        (leftTerm, rightTerm) => s"$leftTerm.equals($rightTerm)")
+        (leftTerm, rightTerm) => s"${if (nonEq) "!" else ""}$leftTerm.equals($rightTerm)")
     }
     // numeric types
     else if (isNumeric(left.resultType) && isNumeric(right.resultType)) {
-      generateComparison(ctx, "==", left, right, resultType)
+      generateComparison(ctx, operator, left, right, resultType)
     }
     // array types
     else if (isArray(left.resultType) && canEqual) {
-      generateArrayComparison(ctx, left, right, resultType)
+      wrapExpressionIfNonEq(
+        nonEq,
+        generateArrayComparison(ctx, left, right, resultType),
+        resultType)
     }
     // map types
     else if (isMap(left.resultType) && canEqual) {
       val mapType = left.resultType.asInstanceOf[MapType]
-      generateMapComparison(ctx, left, right, mapType.getKeyType, mapType.getValueType, resultType)
+      wrapExpressionIfNonEq(
+        nonEq,
+        generateMapComparison(
+          ctx,
+          left,
+          right,
+          mapType.getKeyType,
+          mapType.getValueType,
+          resultType),
+        resultType)
     }
     // multiset types
     else if (isMultiset(left.resultType) && canEqual) {
       val multisetType = left.resultType.asInstanceOf[MultisetType]
-      generateMapComparison(
-        ctx,
-        left,
-        right,
-        multisetType.getElementType,
-        new IntType(false),
+      wrapExpressionIfNonEq(
+        nonEq,
+        generateMapComparison(
+          ctx,
+          left,
+          right,
+          multisetType.getElementType,
+          new IntType(false),
+          resultType),
         resultType)
     }
     // comparable types of same type
     else if (isComparable(left.resultType) && canEqual) {
-      generateComparison(ctx, "==", left, right, resultType)
+      generateComparison(ctx, operator, left, right, resultType)
     }
     // generic types of same type
     else if (isRaw(left.resultType) && canEqual) {
@@ -399,7 +438,7 @@ object ScalarOperatorGens {
            |  ${left.resultTerm}.ensureMaterialized($ser);
            |  ${right.resultTerm}.ensureMaterialized($ser);
            |  $resultTerm =
-           |    ${left.resultTerm}.getBinarySection().
+           |    ${if (nonEq) "!" else ""}${left.resultTerm}.getBinarySection().
            |    equals(${right.resultTerm}.getBinarySection());
            |}
            |""".stripMargin
@@ -407,43 +446,58 @@ object ScalarOperatorGens {
     }
     // support date/time/timestamp equalTo string.
     // for performance, we cast literal string to literal time.
-    else if (isTimePoint(left.resultType) && isCharacterString(right.resultType)) {
-      if (right.literal) {
-        generateEquals(ctx, left, generateCastLiteral(ctx, right, left.resultType), resultType)
-      } else {
-        generateEquals(
-          ctx,
-          left,
-          generateCast(ctx, right, left.resultType, nullOnFailure = true),
-          resultType)
-      }
-    } else if (isTimePoint(right.resultType) && isCharacterString(left.resultType)) {
-      if (left.literal) {
-        generateEquals(ctx, generateCastLiteral(ctx, left, right.resultType), right, resultType)
-      } else {
-        generateEquals(
-          ctx,
-          generateCast(ctx, left, right.resultType, nullOnFailure = true),
-          right,
-          resultType)
-      }
+    else if (
+      (isTimePoint(left.resultType) && isCharacterString(right.resultType)) || (isTimePoint(
+        right.resultType) && isCharacterString(left.resultType))
+    ) {
+      val (newLeft, newRight) =
+        if (isTimePoint(left.resultType)) (left, right)
+        else (right, left)
+      generateEqualAndNonEqual(
+        ctx,
+        newLeft,
+        if (newRight.literal) {
+          generateCastLiteral(ctx, newRight, newLeft.resultType)
+        } else {
+          generateCast(ctx, newRight, newLeft.resultType, nullOnFailure = true)
+        },
+        operator,
+        resultType
+      )
     }
     // non comparable types
     else {
-      generateOperatorIfNotNull(ctx, resultType, left, right) {
-        if (isReference(left.resultType)) {
-          (leftTerm, rightTerm) => s"$leftTerm.equals($rightTerm)"
-        } else if (isReference(right.resultType)) {
-          (leftTerm, rightTerm) => s"$rightTerm.equals($leftTerm)"
-        } else {
-          throw new CodeGenException(
-            s"Incomparable types: ${left.resultType} and " +
-              s"${right.resultType}")
-        }
+      val (newLeft, newRight) = if (isReference(left.resultType)) {
+        (left, right)
+      } else if (isReference(right.resultType)) {
+        (right, left)
+      } else {
+        throw new CodeGenException(
+          s"Incomparable types: ${left.resultType} and " +
+            s"${right.resultType}")
+      }
+      generateOperatorIfNotNull(ctx, resultType, newLeft, newRight) {
+        (leftTerm, rightTerm) => s"${if (nonEq) "!" else ""}$leftTerm.equals($rightTerm)"
       }
     }
   }
 
+  def generateEquals(
+      ctx: CodeGeneratorContext,
+      left: GeneratedExpression,
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateEqualAndNonEqual(ctx, left, right, "==", resultType)
+  }
+
+  def generateNotEquals(
+      ctx: CodeGeneratorContext,
+      left: GeneratedExpression,
+      right: GeneratedExpression,
+      resultType: LogicalType): GeneratedExpression = {
+    generateEqualAndNonEqual(ctx, left, right, "!=", resultType)
+  }
+
   def generateIsDistinctFrom(
       ctx: CodeGeneratorContext,
       left: GeneratedExpression,
@@ -474,68 +528,6 @@ object ScalarOperatorGens {
     )
   }
 
-  def generateNotEquals(
-      ctx: CodeGeneratorContext,
-      left: GeneratedExpression,
-      right: GeneratedExpression,
-      resultType: LogicalType): GeneratedExpression = {
-    checkImplicitConversionValidity(left, right)
-    if (isCharacterString(left.resultType) && isCharacterString(right.resultType)) {
-      generateOperatorIfNotNull(ctx, resultType, left, right)(
-        (leftTerm, rightTerm) => s"!$leftTerm.equals($rightTerm)")
-    }
-    // numeric types
-    else if (isNumeric(left.resultType) && isNumeric(right.resultType)) {
-      generateComparison(ctx, "!=", left, right, resultType)
-    }
-    // temporal types
-    else if (
-      isTemporal(left.resultType) &&
-      isInteroperable(left.resultType, right.resultType)
-    ) {
-      generateComparison(ctx, "!=", left, right, resultType)
-    }
-    // array types
-    else if (isArray(left.resultType) && isInteroperable(left.resultType, right.resultType)) {
-      val equalsExpr = generateEquals(ctx, left, right, resultType)
-      GeneratedExpression(
-        s"(!${equalsExpr.resultTerm})",
-        equalsExpr.nullTerm,
-        equalsExpr.code,
-        resultType)
-    }
-    // map types
-    else if (isMap(left.resultType) && isInteroperable(left.resultType, right.resultType)) {
-      val equalsExpr = generateEquals(ctx, left, right, resultType)
-      GeneratedExpression(
-        s"(!${equalsExpr.resultTerm})",
-        equalsExpr.nullTerm,
-        equalsExpr.code,
-        resultType)
-    }
-    // comparable types
-    else if (
-      isComparable(left.resultType) &&
-      isInteroperable(left.resultType, right.resultType)
-    ) {
-      generateComparison(ctx, "!=", left, right, resultType)
-    }
-    // non-comparable types
-    else {
-      generateOperatorIfNotNull(ctx, resultType, left, right) {
-        if (isReference(left.resultType)) {
-          (leftTerm, rightTerm) => s"!($leftTerm.equals($rightTerm))"
-        } else if (isReference(right.resultType)) {
-          (leftTerm, rightTerm) => s"!($rightTerm.equals($leftTerm))"
-        } else {
-          throw new CodeGenException(
-            s"Incomparable types: ${left.resultType} and " +
-              s"${right.resultType}")
-        }
-      }
-    }
-  }
-
   /** Generates comparison code for numeric types and comparable types of same type. */
   def generateComparison(
       ctx: CodeGeneratorContext,
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala
index 912b138fda5..44fac362f8f 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/ScalarOperatorsTest.scala
@@ -181,12 +181,21 @@ class ScalarOperatorsTest extends ScalarOperatorsTestBase {
     testSqlApi("'12:34:56' = f21", "TRUE")
     testSqlApi("'13:34:56' = f21", "FALSE")
 
+    testSqlApi("TYPEOF(f22)", "TIMESTAMP(6)")
     testSqlApi("f22 = '1996-11-10 12:34:56'", "TRUE")
     testSqlApi("f22 = '1996-11-10 12:34:57'", "FALSE")
     testSqlApi("f22 = cast(null as string)", "NULL")
     testSqlApi("'1996-11-10 12:34:56' = f22", "TRUE")
     testSqlApi("'1996-11-10 12:34:57' = f22", "FALSE")
     testSqlApi("cast(null as string) = f22", "NULL")
+
+    testSqlApi("TYPEOF(f23)", "TIMESTAMP_LTZ(6)")
+    testSqlApi("f23 = '1996-11-10 12:34:56'", "TRUE")
+    testSqlApi("f23 = '1996-11-10 12:34:57'", "FALSE")
+    testSqlApi("f23 = cast(null as string)", "NULL")
+    testSqlApi("'1996-11-10 12:34:56' = f23", "TRUE")
+    testSqlApi("'1996-11-10 12:34:57' = f23", "FALSE")
+    testSqlApi("cast(null as string) = f23", "NULL")
   }
 
   @Test
@@ -226,6 +235,223 @@ class ScalarOperatorsTest extends ScalarOperatorsTestBase {
       "date_format(f22 + interval '1' second, 'yyyy-MM-dd HH:mm:ss') = cast(f22 as timestamp_ltz)",
       "FALSE")
     testSqlApi("uuid() = cast(f22 as timestamp_ltz)", "NULL")
+
+    testSqlApi("f23 = date_format(f23, 'yyyy-MM-dd HH:mm:ss')", "TRUE")
+    testSqlApi("f23 = date_format(f23 + interval '1' second, 'yyyy-MM-dd HH:mm:ss')", "FALSE")
+    testSqlApi("f23 = uuid()", "NULL")
+    testSqlApi("date_format(f23, 'yyyy-MM-dd HH:mm:ss') = f23", "TRUE")
+    testSqlApi("date_format(f23 + interval '1' second, 'yyyy-MM-dd HH:mm:ss') = f23", "FALSE")
+    testSqlApi("uuid() = f23", "NULL")
+  }
+
+  @Test
+  def testTimePointTypeNotEqualsString(): Unit = {
+    testSqlApi("NOT(f15 = '1996-11-10')", "FALSE")
+    testSqlApi("NOT(f15 = '1996-11-11')", "TRUE")
+    testSqlApi("NOT('1996-11-10' = f15)", "FALSE")
+    testSqlApi("NOT('1996-11-11' = f15)", "TRUE")
+
+    testSqlApi("NOT(f21 = '12:34:56')", "FALSE")
+    testSqlApi("NOT(f21 = '13:34:56')", "TRUE")
+    testSqlApi("NOT('12:34:56' = f21)", "FALSE")
+    testSqlApi("NOT('13:34:56' = f21)", "TRUE")
+
+    testSqlApi("TYPEOF(f22)", "TIMESTAMP(6)")
+    testSqlApi("NOT(f22 = '1996-11-10 12:34:56')", "FALSE")
+    testSqlApi("NOT(f22 = '1996-11-10 12:34:57')", "TRUE")
+    testSqlApi("NOT(f22 = cast(null as string))", "NULL")
+    testSqlApi("NOT('1996-11-10 12:34:56' = f22)", "FALSE")
+    testSqlApi("NOT('1996-11-10 12:34:57' = f22)", "TRUE")
+    testSqlApi("NOT(cast(null as string) = f22)", "NULL")
+
+    testSqlApi("TYPEOF(f23)", "TIMESTAMP_LTZ(6)")
+    testSqlApi("f23 = '1996-11-10 12:34:56'", "TRUE")
+    testSqlApi("f23 = '1996-11-10 12:34:57'", "FALSE")
+    testSqlApi("f23 = cast(null as string)", "NULL")
+    testSqlApi("'1996-11-10 12:34:56' = f23", "TRUE")
+    testSqlApi("'1996-11-10 12:34:57' = f23", "FALSE")
+    testSqlApi("cast(null as string) = f23", "NULL")
+
+    testSqlApi("NOT(f15 = date_format(cast(f15 as timestamp), 'yyyy-MM-dd'))", "FALSE")
+    testSqlApi(
+      "NOT(f15 = date_format(cast(f15 as timestamp) + interval '1' day, 'yyyy-MM-dd'))",
+      "TRUE")
+    testSqlApi("NOT(f15 = uuid())", "NULL")
+    testSqlApi("NOT(date_format(cast(f15 as timestamp), 'yyyy-MM-dd') = f15)", "FALSE")
+    testSqlApi(
+      "NOT(date_format(cast(f15 as timestamp) + interval '1' day, 'yyyy-MM-dd')) = f15",
+      "TRUE")
+    testSqlApi("NOT(uuid() = f15)", "NULL")
+
+    testSqlApi("NOT(f21 = date_format(cast(f21 as timestamp), 'HH:mm:ss'))", "FALSE")
+    testSqlApi(
+      "NOT(f21 = date_format(cast(f21 as timestamp) + interval '1' hour, 'HH:mm:ss'))",
+      "TRUE")
+    testSqlApi("NOT(f21 = uuid())", "NULL")
+    testSqlApi("NOT(date_format(cast(f21 as timestamp), 'HH:mm:ss') = f21)", "FALSE")
+    testSqlApi(
+      "NOT(date_format(cast(f21 as timestamp) + interval '1' hour, 'HH:mm:ss') = f21)",
+      "TRUE")
+    testSqlApi("NOT(uuid() = f21)", "NULL")
+
+    testSqlApi("NOT(f22 = date_format(f22, 'yyyy-MM-dd HH:mm:ss'))", "FALSE")
+    testSqlApi("NOT(f22 = date_format(f22 + interval '1' second, 'yyyy-MM-dd HH:mm:ss'))", "TRUE")
+    testSqlApi("NOT(f22 = uuid())", "NULL")
+    testSqlApi("NOT(date_format(f22, 'yyyy-MM-dd HH:mm:ss') = f22)", "FALSE")
+    testSqlApi("NOT(date_format(f22 + interval '1' second, 'yyyy-MM-dd HH:mm:ss') = f22)", "TRUE")
+    testSqlApi("NOT(uuid() = f22)", "NULL")
+
+    testSqlApi("NOT(cast(f22 as timestamp_ltz) = date_format(f22, 'yyyy-MM-dd HH:mm:ss'))", "FALSE")
+    testSqlApi(
+      "NOT(cast(f22 as timestamp_ltz) = date_format(f22 + interval '1' second, 'yyyy-MM-dd HH:mm:ss'))",
+      "TRUE")
+    testSqlApi("NOT(cast(f22 as timestamp_ltz) = uuid())", "NULL")
+    testSqlApi("NOT(date_format(f22, 'yyyy-MM-dd HH:mm:ss') = cast(f22 as timestamp_ltz))", "FALSE")
+    testSqlApi(
+      "NOT(date_format(f22 + interval '1' second, 'yyyy-MM-dd HH:mm:ss') = cast(f22 as timestamp_ltz))",
+      "TRUE")
+    testSqlApi("NOT(uuid() = cast(f22 as timestamp_ltz))", "NULL")
+
+    testSqlApi("NOT(f23 = date_format(f23, 'yyyy-MM-dd HH:mm:ss'))", "FALSE")
+    testSqlApi("NOT(f23 = date_format(f23 + interval '1' second, 'yyyy-MM-dd HH:mm:ss'))", "TRUE")
+    testSqlApi("NOT(f23 = uuid())", "NULL")
+    testSqlApi("NOT(date_format(f23, 'yyyy-MM-dd HH:mm:ss') = f23)", "FALSE")
+    testSqlApi("NOT(date_format(f23 + interval '1' second, 'yyyy-MM-dd HH:mm:ss') = f23)", "TRUE")
+    testSqlApi("NOT(uuid() = f23)", "NULL")
+  }
+
+  @Test
+  def testMoreEqualAndNonEqual(): Unit = {
+    // character string
+    testSqlApi("f10 = 'String'", "TRUE")
+    testSqlApi("f10 = 'string'", "FALSE")
+    testSqlApi("f10 = NULL", "NULL")
+    testSqlApi("f10 = CAST(NULL AS STRING)", "NULL")
+    testSqlApi("'String' = f10", "TRUE")
+    testSqlApi("'string' = f10", "FALSE")
+    testSqlApi("NULL = f10", "NULL")
+    testSqlApi("CAST(NULL AS STRING) = f10", "NULL")
+
+    testSqlApi("NOT(f10 = 'String')", "FALSE")
+    testSqlApi("NOT(f10 = 'string')", "TRUE")
+    testSqlApi("NOT(f10 = NULL)", "NULL")
+    testSqlApi("NOT(f10 = CAST(NULL AS STRING))", "NULL")
+    testSqlApi("NOT('String' = f10)", "FALSE")
+    testSqlApi("NOT('string' = f10)", "TRUE")
+    testSqlApi("NOT(NULL = f10)", "NULL")
+    testSqlApi("NOT(CAST(NULL AS STRING) = f10)", "NULL")
+
+    // numeric types
+    testSqlApi("f2 = 1", "TRUE")
+    testSqlApi("f2 = 2", "FALSE")
+    testSqlApi("f2 = NULL", "NULL")
+    testSqlApi("f2 = CAST(NULL AS INT)", "NULL")
+    testSqlApi("1 = f2", "TRUE")
+    testSqlApi("2 = f2", "FALSE")
+    testSqlApi("NULL = f2", "NULL")
+    testSqlApi("CAST(NULL AS INT) = f2", "NULL")
+
+    testSqlApi("NOT(f2 = 1)", "FALSE")
+    testSqlApi("NOT(f2 = 2)", "TRUE")
+    testSqlApi("NOT(f2 = NULL)", "NULL")
+    testSqlApi("NOT(f2 = CAST(NULL AS INT))", "NULL")
+    testSqlApi("NOT(1 = f2)", "FALSE")
+    testSqlApi("NOT(2 = f2)", "TRUE")
+    testSqlApi("NOT(NULL = f2)", "NULL")
+    testSqlApi("NOT(CAST(NULL AS INT) = f2)", "NULL")
+
+    // array
+    testSqlApi("f24 = ARRAY['hello', 'world']", "TRUE")
+    testSqlApi("f24 = ARRAY['hello1', 'world']", "FALSE")
+    testSqlApi("f24 = NULL", "NULL")
+    testSqlApi("f24 = CAST(NULL AS ARRAY<STRING>)", "NULL")
+    testSqlApi("ARRAY['hello', 'world'] = f24", "TRUE")
+    testSqlApi("ARRAY['hello1', 'world'] = f24", "FALSE")
+    testSqlApi("NULL = f24", "NULL")
+    testSqlApi("CAST(NULL AS ARRAY<STRING>) = f24", "NULL")
+
+    testSqlApi("NOT(f24 = ARRAY['hello', 'world'])", "FALSE")
+    testSqlApi("NOT(f24 = ARRAY['hello1', 'world'])", "TRUE")
+    testSqlApi("NOT(f24 = NULL)", "NULL")
+    testSqlApi("NOT(f24 = CAST(NULL AS ARRAY<STRING>))", "NULL")
+    testSqlApi("NOT(ARRAY['hello', 'world'] = f24)", "FALSE")
+    testSqlApi("NOT(ARRAY['hello1', 'world'] = f24)", "TRUE")
+    testSqlApi("NOT(NULL = f24)", "NULL")
+    testSqlApi("NOT(CAST(NULL AS ARRAY<STRING>)) = f24", "NULL")
+
+    // map
+    testSqlApi("f25 = MAP['a', 1, 'b', 2]", "TRUE")
+    testSqlApi("f25 = MAP['a', 3, 'b', 2]", "FALSE")
+    testSqlApi("f25 = NULL", "NULL")
+    testSqlApi("f25 = CAST(NULL AS MAP<STRING, INT>)", "NULL")
+    testSqlApi("MAP['a', 1, 'b', 2] = f25", "TRUE")
+    testSqlApi("MAP['a', 3, 'b', 2] = f25", "FALSE")
+    testSqlApi("NULL = f25", "NULL")
+    testSqlApi("CAST(NULL AS MAP<STRING, INT>) = f25", "NULL")
+
+    testSqlApi("NOT(f25 = MAP['a', 1, 'b', 2])", "FALSE")
+    testSqlApi("NOT(f25 = MAP['a', 3, 'b', 2])", "TRUE")
+    testSqlApi("NOT(f25 = NULL)", "NULL")
+    testSqlApi("NOT(f25 = CAST(NULL AS MAP<STRING, INT>))", "NULL")
+    testSqlApi("NOT(MAP['a', 1, 'b', 2] = f25)", "FALSE")
+    testSqlApi("NOT(MAP['a', 3, 'b', 2] = f25)", "TRUE")
+    testSqlApi("NOT(NULL = f25)", "NULL")
+    testSqlApi("NOT(CAST(NULL AS MAP<STRING, INT>) = f25)", "NULL")
+
+    // raw
+    testSqlApi("f27 = f29", "TRUE")
+    testSqlApi("f27 = f28", "FALSE")
+    testSqlApi("f27 = NULL", "NULL")
+    testSqlApi("f29 = f27", "TRUE")
+    testSqlApi("f28 = f27", "FALSE")
+    testSqlApi("NULL = f27", "NULL")
+
+    testSqlApi("NOT(f27 = f29)", "FALSE")
+    testSqlApi("NOT(f27 = f28)", "TRUE")
+    testSqlApi("NOT(f27 = NULL)", "NULL")
+    testSqlApi("NOT(f29 = f27)", "FALSE")
+    testSqlApi("NOT(f28 = f27)", "TRUE")
+    testSqlApi("NOT(NULL = f27)", "NULL")
+
+    // non comparable types
+    testSqlApi("f30 = ROW('abc', 'def')", "TRUE")
+    testSqlApi("f30 = ROW('abc', 'xyz')", "FALSE")
+    testSqlApi("f30 = NULL", "NULL")
+    testSqlApi("f30 = CAST(NULL AS ROW<f0 STRING, f1 STRING>)", "NULL")
+    testSqlApi("ROW('abc', 'def') = f30", "TRUE")
+    testSqlApi("ROW('abc', 'xyz') = f30", "FALSE")
+    testSqlApi("CAST(NULL AS ROW<f0 STRING, f1 STRING>) = f30", "NULL")
+
+    testSqlApi("NOT(f30 = ROW('abc', 'def'))", "FALSE")
+    testSqlApi("NOT(f30 = ROW('abc', 'xyz'))", "TRUE")
+    testSqlApi("NOT(f30 = NULL)", "NULL")
+    testSqlApi("NOT(f30 = CAST(NULL AS ROW<f0 STRING, f1 STRING>))", "NULL")
+    testSqlApi("NOT(ROW('abc', 'def') = f30)", "FALSE")
+    testSqlApi("NOT(ROW('abc', 'xyz') = f30)", "TRUE")
+    testSqlApi("NOT(CAST(NULL AS ROW<f0 STRING, f1 STRING>) = f30)", "NULL")
+
+    // time interval, comparable
+    testSqlApi("f31 = f33", "TRUE")
+    testSqlApi("f31 = f32", "FALSE")
+    testSqlApi("f31 = NULL", "NULL")
+    testSqlApi("f31 = f34", "NULL")
+    testSqlApi("f31 = CAST(NULL AS INTERVAL DAY)", "NULL")
+    testSqlApi("f33 = f31", "TRUE")
+    testSqlApi("f32 = f31", "FALSE")
+    testSqlApi("NULL = f31", "NULL")
+    testSqlApi("f34 = f31", "NULL")
+    testSqlApi("CAST(NULL AS INTERVAL DAY) = f31", "NULL")
+
+    testSqlApi("NOT(f31 = f33)", "FALSE")
+    testSqlApi("NOT(f31 = f32)", "TRUE")
+    testSqlApi("NOT(f31 = NULL)", "NULL")
+    testSqlApi("NOT(f31 = f34)", "NULL")
+    testSqlApi("NOT(f31 = CAST(NULL AS INTERVAL DAY))", "NULL")
+    testSqlApi("NOT(f33 = f31)", "FALSE")
+    testSqlApi("NOT(f32 = f31)", "TRUE")
+    testSqlApi("NOT(NULL = f31)", "NULL")
+    testSqlApi("NOT(f34 = f31)", "NULL")
+    testSqlApi("NOT(CAST(NULL AS INTERVAL DAY) = f31)", "NULL")
   }
 
   @Test
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ExpressionTestBase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ExpressionTestBase.scala
index 48e972d275a..d46ab187b75 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ExpressionTestBase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ExpressionTestBase.scala
@@ -247,6 +247,7 @@ abstract class ExpressionTestBase(isStreaming: Boolean = true) {
       val converter = DataStructureConverters
         .getConverter(resolvedDataType)
         .asInstanceOf[DataStructureConverter[RowData, Row]]
+      converter.open(getClass.getClassLoader)
       converter.toInternalOrNull(testData)
     }
     try {
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala
index b32c5618f45..78d91c3562d 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/expressions/utils/ScalarOperatorsTestBase.scala
@@ -21,13 +21,18 @@ import org.apache.flink.table.api.DataTypes
 import org.apache.flink.table.data.DecimalDataUtils
 import org.apache.flink.table.functions.ScalarFunction
 import org.apache.flink.table.planner.utils.DateTimeTestUtil._
+import org.apache.flink.table.planner.utils.TableConfigUtils
 import org.apache.flink.table.types.AbstractDataType
 import org.apache.flink.types.Row
 
+import java.time.{DayOfWeek, Duration}
+
+import scala.collection.JavaConverters.mapAsJavaMapConverter
+
 abstract class ScalarOperatorsTestBase extends ExpressionTestBase {
 
   override def testData: Row = {
-    val testData = new Row(23)
+    val testData = new Row(35)
     testData.setField(0, 1: Byte)
     testData.setField(1, 1: Short)
     testData.setField(2, 1)
@@ -51,6 +56,22 @@ abstract class ScalarOperatorsTestBase extends ExpressionTestBase {
     testData.setField(20, "who".getBytes())
     testData.setField(21, localTime("12:34:56"))
     testData.setField(22, localDateTime("1996-11-10 12:34:56"))
+    testData.setField(
+      23,
+      localDateTime("1996-11-10 12:34:56")
+        .atZone(TableConfigUtils.getLocalTimeZone(tableConfig))
+        .toInstant)
+    testData.setField(24, Array("hello", "world"))
+    testData.setField(25, Map("a" -> 1, "b" -> 2).asJava)
+    testData.setField(26, Map("a" -> 1, "b" -> 2).asJava)
+    testData.setField(27, DayOfWeek.SUNDAY)
+    testData.setField(28, DayOfWeek.MONDAY)
+    testData.setField(29, DayOfWeek.SUNDAY)
+    testData.setField(30, Row.of("abc", "def"))
+    testData.setField(31, Duration.ofDays(2))
+    testData.setField(32, Duration.ofDays(3))
+    testData.setField(33, Duration.ofDays(2))
+    testData.setField(34, null)
     testData
   }
 
@@ -82,7 +103,23 @@ abstract class ScalarOperatorsTestBase extends ExpressionTestBase {
       DataTypes.FIELD("f19", DataTypes.VARBINARY(200).notNull()),
       DataTypes.FIELD("f20", DataTypes.VARBINARY(200)),
       DataTypes.FIELD("f21", DataTypes.TIME()),
-      DataTypes.FIELD("f22", DataTypes.TIMESTAMP())
+      DataTypes.FIELD("f22", DataTypes.TIMESTAMP()),
+      DataTypes.FIELD("f23", DataTypes.TIMESTAMP_LTZ()),
+      DataTypes.FIELD("f24", DataTypes.ARRAY(DataTypes.STRING())),
+      DataTypes.FIELD("f25", DataTypes.MAP(DataTypes.STRING(), DataTypes.INT())),
+      DataTypes.FIELD("f26", DataTypes.MULTISET(DataTypes.STRING())),
+      DataTypes.FIELD("f27", DataTypes.RAW(classOf[DayOfWeek])),
+      DataTypes.FIELD("f28", DataTypes.RAW(classOf[DayOfWeek])),
+      DataTypes.FIELD("f29", DataTypes.RAW(classOf[DayOfWeek])),
+      DataTypes.FIELD(
+        "f30",
+        DataTypes.ROW(
+          DataTypes.FIELD("f0", DataTypes.STRING()),
+          DataTypes.FIELD("f1", DataTypes.STRING()))),
+      DataTypes.FIELD("f31", DataTypes.INTERVAL(DataTypes.DAY)),
+      DataTypes.FIELD("f32", DataTypes.INTERVAL(DataTypes.DAY)),
+      DataTypes.FIELD("f33", DataTypes.INTERVAL(DataTypes.DAY)),
+      DataTypes.FIELD("f34", DataTypes.INTERVAL(DataTypes.DAY))
     )
   }
 
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MiscITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MiscITCase.scala
index fd5a5a4343e..0f043a307b1 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MiscITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MiscITCase.scala
@@ -32,6 +32,8 @@ import org.apache.flink.types.Row
 import org.assertj.core.api.Assertions.assertThatThrownBy
 import org.junit.jupiter.api.{BeforeEach, Test}
 
+import java.time.DayOfWeek
+
 /** Misc tests. */
 class MiscITCase extends BatchTestBase {
 
@@ -621,4 +623,94 @@ class MiscITCase extends BatchTestBase {
         )).isInstanceOf(classOf[ValidationException])
 
   }
+
+  @Test
+  def testEqualAndNotEqual(): Unit = {
+    // character string
+    checkQuery(
+      Seq((null, 2), ("b", 1)),
+      "SELECT f1 FROM Table1 WHERE f0 <> 'a'",
+      Seq(Tuple1(1))
+    )
+    checkQuery(
+      Seq(("aa", "aa"), ("aa", "bb"), ("aa", null)),
+      "SELECT * FROM Table1 WHERE SUBSTR(f0, 2, 1) <> SUBSTR(f1, 2, 1)",
+      Seq(("aa", "bb"))
+    )
+    checkQuery(
+      Seq(("aa", "aa"), ("aa", "bb"), ("aa", null)),
+      "SELECT * FROM Table1 WHERE SUBSTR(f0, 2, 1) = SUBSTR(f1, 2, 1)",
+      Seq(("aa", "aa"))
+    )
+
+    // raw
+    checkQuery(
+      Seq(
+        (DayOfWeek.SUNDAY, DayOfWeek.SUNDAY),
+        (DayOfWeek.SUNDAY, DayOfWeek.MONDAY),
+        (DayOfWeek.SUNDAY, null)),
+      "SELECT * FROM Table1 WHERE f0 = f1",
+      Seq((DayOfWeek.SUNDAY, DayOfWeek.SUNDAY))
+    )
+    checkQuery(
+      Seq(
+        (DayOfWeek.SUNDAY, DayOfWeek.SUNDAY),
+        (DayOfWeek.SUNDAY, DayOfWeek.MONDAY),
+        (DayOfWeek.SUNDAY, null)),
+      "SELECT * FROM Table1 WHERE f0 <> f1",
+      Seq((DayOfWeek.SUNDAY, DayOfWeek.MONDAY))
+    )
+
+    // multiset
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT t1.ms = t2.ms FROM " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1 LEFT JOIN " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t2 ON t1.f1 = t2.f1",
+      Seq(Tuple1("true"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT t1.ms = t2.ms FROM " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1 LEFT JOIN " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM (SELECT * FROM Table1 LIMIT 2) GROUP BY f1) t2 " +
+        "ON t1.f1 = t2.f1",
+      Seq(Tuple1("false"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT t1.ms = NULL FROM (SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1",
+      Seq(Tuple1("null"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT NULL = t1.ms FROM (SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1",
+      Seq(Tuple1("null"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT NOT(t1.ms = t2.ms) FROM " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1 LEFT JOIN " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t2 ON t1.f1 = t2.f1",
+      Seq(Tuple1("false"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT NOT(t1.ms = t2.ms) FROM " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1 LEFT JOIN " +
+        "(SELECT f1, COLLECT(f0) AS ms FROM (SELECT * FROM Table1 LIMIT 2) GROUP BY f1) t2 " +
+        "ON t1.f1 = t2.f1",
+      Seq(Tuple1("true"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT NOT(t1.ms = NULL) FROM (SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1",
+      Seq(Tuple1("null"))
+    )
+    checkQuery(
+      Seq(("b", 1), ("a", 1), ("b", 1)),
+      "SELECT NOT(NULL = t1.ms) FROM (SELECT f1, COLLECT(f0) AS ms FROM Table1 GROUP BY f1) t1",
+      Seq(Tuple1("null"))
+    )
+  }
 }
