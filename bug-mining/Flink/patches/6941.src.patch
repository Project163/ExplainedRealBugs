diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index d0c98387e5c..8cc529720d8 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -261,6 +261,9 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
      */
     private volatile boolean isRunning;
 
+    /** Flag to mark the task at restoring duration in {@link #restore()}. */
+    private volatile boolean isRestoring;
+
     /** Flag to mark this task as canceled. */
     private volatile boolean canceled;
 
@@ -689,6 +692,7 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
             LOG.debug("Re-restore attempt rejected.");
             return;
         }
+        isRestoring = true;
         closedOperators = false;
         LOG.debug("Initializing {}.", getName());
 
@@ -730,6 +734,7 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
         channelIOExecutor.shutdown();
 
         isRunning = true;
+        isRestoring = false;
     }
 
     private CompletableFuture<Void> restoreGates() throws Exception {
@@ -1563,8 +1568,8 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
      */
     @Override
     public void handleAsyncException(String message, Throwable exception) {
-        if (isRunning) {
-            // only fail if the task is still running
+        if (isRestoring || isRunning) {
+            // only fail if the task is still in restoring or running
             asyncExceptionHandler.handleAsyncException(message, exception);
         }
     }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index 51724eb3113..585cd51ee17 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -402,6 +402,43 @@ public class StreamTaskTest {
         }
     }
 
+    @Test
+    void testHandleAsyncExceptionDuringRestoring() throws Exception {
+        MockEnvironment mockEnvironment = MockEnvironment.builder().build();
+        Throwable expectedException = new RuntimeException("RUNTIME EXCEPTION");
+
+        mockEnvironment.setExpectedExternalFailureCause(AsynchronousException.class);
+        final String expectedErrorMessage = "EXPECTED_ERROR MESSAGE";
+
+        StreamTaskITCase.NoOpStreamTask initThrowExceptionTask =
+                new StreamTaskITCase.NoOpStreamTask(mockEnvironment) {
+
+                    @Override
+                    protected void init() throws Exception {
+                        super.init();
+
+                        // Throw exception during restoring.
+                        CompletableFuture.runAsync(
+                                        () ->
+                                                this.handleAsyncException(
+                                                        expectedErrorMessage, expectedException))
+                                .get();
+                    }
+                };
+        initThrowExceptionTask.restore();
+
+        Optional<? extends Throwable> actualExternalFailureCause =
+                mockEnvironment.getActualExternalFailureCause();
+        final Throwable actualException =
+                actualExternalFailureCause.orElseThrow(
+                        () -> new AssertionError("Expected exceptional completion"));
+
+        assertThat(actualException)
+                .isInstanceOf(AsynchronousException.class)
+                .hasMessage(expectedErrorMessage)
+                .hasCause(expectedException);
+    }
+
     /**
      * This test checks the async exceptions handling wraps the message and cause as an
      * AsynchronousException and propagates this to the environment.
