diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/IgnoreInFlightDataITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/IgnoreInFlightDataITCase.java
index a8bdf6c4c20..55a41a38913 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/IgnoreInFlightDataITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/IgnoreInFlightDataITCase.java
@@ -25,6 +25,7 @@ import org.apache.flink.api.common.typeinfo.Types;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.MemorySize;
 import org.apache.flink.configuration.TaskManagerOptions;
+import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.runtime.state.FunctionInitializationContext;
 import org.apache.flink.runtime.state.FunctionSnapshotContext;
 import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
@@ -34,12 +35,17 @@ import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
 import org.apache.flink.streaming.api.functions.sink.SinkFunction;
 import org.apache.flink.streaming.api.functions.source.SourceFunction;
 import org.apache.flink.test.util.MiniClusterWithClientResource;
+import org.apache.flink.testutils.junit.SharedObjects;
+import org.apache.flink.testutils.junit.SharedReference;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.ClassRule;
+import org.junit.Rule;
 import org.junit.Test;
 
 import java.util.Iterator;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.LockSupport;
 
 import static java.util.Collections.singletonList;
@@ -59,36 +65,80 @@ public class IgnoreInFlightDataITCase extends TestLogger {
                             .setNumberSlotsPerTaskManager(2)
                             .build());
 
+    @Rule public final SharedObjects sharedObjects = SharedObjects.create();
+
+    private static final int PARALLELISM = 3;
+
+    private SharedReference<OneShotLatch> checkpointReachSinkLatch;
+    private SharedReference<AtomicLong> resultBeforeFail;
+    private SharedReference<AtomicLong> result;
+    private SharedReference<AtomicInteger> lastCheckpointValue;
+
     private static Configuration getConfiguration() {
         Configuration config = new Configuration();
         config.set(TaskManagerOptions.MANAGED_MEMORY_SIZE, MemorySize.parse("48m"));
         return config;
     }
 
+    public void setupSharedObjects() {
+        checkpointReachSinkLatch = sharedObjects.add(new OneShotLatch());
+        resultBeforeFail = sharedObjects.add(new AtomicLong());
+        result = sharedObjects.add(new AtomicLong());
+        lastCheckpointValue = sharedObjects.add(new AtomicInteger());
+    }
+
+    /**
+     * This test contains one Source, three Maps and one Sink. The two out of three Map are waiting
+     * until signal from Sink(when the Sink receives the first checkpoint barrier). When Source
+     * emits the data it is able to achieve Sink only via Map-0 because another Maps freeze. When
+     * the checkpoint happens the barrier achieve the Sink also via Map-0 and at this moment there
+     * is situation where some data were emitted from Source but didn't achieve the Sink yet. And
+     * these are exact the data which should become the in-flight data because the Sink already
+     * received the first checkpoint barrier. So, if Source sent at least one record to Map-1 or
+     * Map-2 before checkpoint was triggered it should guarantee that the in-flight data in some
+     * gate Source-Map or Map-Sink will exist. But if Source didn't send anything before the
+     * checkpoint it will fail and it is exactly why this test contains the loop to do more
+     * attempts.
+     */
     @Test
-    public void testIgnoreInFlightDataDuringRecovery() throws Exception {
+    public void testIgnoreInFlightDataDuringRecovery() {
+        while (!executeIgnoreInFlightDataDuringRecovery()) {
+            // This test can fail if the first checkpoint happens before the Source emits some data.
+            // In this case, the test will be restarted until it reach success or the test timeout
+            // happens.
+        }
+    }
+
+    private boolean executeIgnoreInFlightDataDuringRecovery() {
         // given: Stream which will fail after first checkpoint.
+        setupSharedObjects();
         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
-        env.setParallelism(3);
+        env.setParallelism(PARALLELISM);
         env.enableCheckpointing(10);
+        env.disableOperatorChaining();
         env.getCheckpointConfig().enableUnalignedCheckpoints();
         env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);
         env.getCheckpointConfig().setCheckpointIdOfIgnoredInFlightData(1);
-        env.setRestartStrategy(fixedDelayRestart(2, 0));
+        env.setRestartStrategy(fixedDelayRestart(1, 0));
 
-        env.addSource(new NumberSource())
+        env.addSource(new NumberSource(lastCheckpointValue))
                 .shuffle()
                 // map for having parallel execution.
-                .map(new SlowMap())
-                .addSink(new SumFailSink())
+                .map(new SlowMap(checkpointReachSinkLatch))
+                .addSink(new SumFailSink(checkpointReachSinkLatch, resultBeforeFail, result))
                 // one sink for easy calculation.
                 .setParallelism(1);
 
         // when: Job is executed.
-        env.execute("Total sum");
+        try {
+            env.execute("Total sum");
+        } catch (Exception ex) {
+            log.error("Execution failed", ex);
+            return false;
+        }
 
         // Calculate the expected single value after recovery.
-        int sourceValueAfterRestore = NumberSource.lastCheckpointedValue + 1;
+        int sourceValueAfterRestore = lastCheckpointValue.get().intValue() + 1;
 
         // Calculate result in case of normal recovery.
         long resultWithoutIgnoringData = 0;
@@ -98,39 +148,69 @@ public class IgnoreInFlightDataITCase extends TestLogger {
 
         // then: Actual result should be less than the ideal result because some of data was
         // ignored.
-        assertThat(SumFailSink.result, lessThan(resultWithoutIgnoringData));
+        assertThat(result.get().longValue(), lessThan(resultWithoutIgnoringData));
 
         // and: Actual result should be equal to sum of result before fail + source value after
         // recovery.
-        long expectedResult = SumFailSink.resultBeforeFail + sourceValueAfterRestore;
-        assertEquals(expectedResult, SumFailSink.result);
+        long expectedResult = resultBeforeFail.get().longValue() + sourceValueAfterRestore;
+        assertEquals(expectedResult, result.get().longValue());
+
+        return true;
     }
 
     private static class SumFailSink implements SinkFunction<Integer>, CheckpointedFunction {
-        public static long result;
-        public static long resultBeforeFail;
+        private final SharedReference<OneShotLatch> checkpointReachSinkLatch;
+        private final SharedReference<AtomicLong> resultBeforeFail;
+        private final SharedReference<AtomicLong> result;
+
+        public SumFailSink(
+                SharedReference<OneShotLatch> checkpointReachSinkLatch,
+                SharedReference<AtomicLong> resultBeforeFail,
+                SharedReference<AtomicLong> result) {
+            this.checkpointReachSinkLatch = checkpointReachSinkLatch;
+            this.resultBeforeFail = resultBeforeFail;
+            this.result = result;
+        }
 
         @Override
-        public void invoke(Integer value) throws Exception {
-            result += value;
+        public void invoke(Integer value, Context context) throws Exception {
+            result.get().addAndGet(value);
         }
 
         @Override
         public void snapshotState(FunctionSnapshotContext context) throws Exception {
-            resultBeforeFail = result;
+            if (resultBeforeFail.get().longValue() == 0) {
+                resultBeforeFail.get().set(result.get().longValue());
+                sinkCheckpointStarted();
+            }
         }
 
         @Override
         public void initializeState(FunctionInitializationContext context) throws Exception {
-            result = resultBeforeFail;
+            result.get().set(resultBeforeFail.get().longValue());
+        }
+
+        /**
+         * Allow to send data from the awaited map in this case if number of waiters more than 0, we
+         * can be sure that in-flight data exists(at least the data which is processing by waiters
+         * during the waiting will be sent to the sink before the checkpoint barrier would be
+         * handled).
+         */
+        public void sinkCheckpointStarted() {
+            checkpointReachSinkLatch.get().trigger();
         }
     }
 
     private static class NumberSource implements SourceFunction<Integer>, CheckpointedFunction {
 
         private static final long serialVersionUID = 1L;
+        private final SharedReference<AtomicInteger> lastCheckpointValue;
         private ListState<Integer> valueState;
-        public static int lastCheckpointedValue;
+        private boolean isRunning = true;
+
+        public NumberSource(SharedReference<AtomicInteger> lastCheckpointValue) {
+            this.lastCheckpointValue = lastCheckpointValue;
+        }
 
         @Override
         public void run(SourceContext<Integer> ctx) throws Exception {
@@ -138,35 +218,54 @@ public class IgnoreInFlightDataITCase extends TestLogger {
             boolean isRecovered = stateIt.hasNext();
 
             if (isRecovered) {
-                Integer lastValue = stateIt.next();
+                synchronized (ctx.getCheckpointLock()) {
+                    Integer lastValue = stateIt.next();
 
-                // Checking that ListState is recovered correctly.
-                assertEquals(lastCheckpointedValue, lastValue.intValue());
+                    // Checking that ListState is recovered correctly.
+                    assertEquals(lastCheckpointValue.get().intValue(), lastValue.intValue());
 
-                // if it is started after recovery, just send one more value and finish.
-                ctx.collect(lastValue + 1);
+                    // if it is started after recovery, just send one more value and finish.
+                    ctx.collect(lastValue + 1);
+                }
             } else {
                 int next = 0;
-                while (true) {
+                while (isRunning) {
                     synchronized (ctx.getCheckpointLock()) {
-                        next++;
-                        valueState.update(singletonList(next));
-                        ctx.collect(next);
+                        // Emit data by batches to reduce the probability that before the first
+                        // checkpoint will be generated not enough data.
+                        do {
+                            next++;
+                            valueState.update(singletonList(next));
+                            ctx.collect(next);
+                        } while (next % 50 != 0 && isRunning);
                     }
+
+                    // Avoid the huge backpressure.
+                    LockSupport.parkNanos(100000);
                 }
             }
         }
 
         @Override
-        public void cancel() {}
+        public void cancel() {
+            isRunning = false;
+        }
 
         @Override
         public void snapshotState(FunctionSnapshotContext context) throws Exception {
-            if (lastCheckpointedValue > 0) {
+            if (lastCheckpointValue.get().get() > 0) {
                 throw new RuntimeException("Error during snapshot");
             }
 
-            lastCheckpointedValue = valueState.get().iterator().next();
+            Iterator<Integer> integerIterator = valueState.get().iterator();
+
+            if (!integerIterator.hasNext() || integerIterator.next() < PARALLELISM) {
+                // Try to restart task.
+                throw new RuntimeException(
+                        "Not enough data to guarantee the in-flight data were generated before the first checkpoint");
+            }
+
+            lastCheckpointValue.get().set(valueState.get().iterator().next());
         }
 
         @Override
@@ -179,10 +278,19 @@ public class IgnoreInFlightDataITCase extends TestLogger {
 
     private static class SlowMap extends RichMapFunction<Integer, Integer> {
 
+        private final SharedReference<OneShotLatch> checkpointReachSinkLatch;
+
+        public SlowMap(SharedReference<OneShotLatch> checkpointReachSinkLatch) {
+            this.checkpointReachSinkLatch = checkpointReachSinkLatch;
+        }
+
         @Override
         public Integer map(Integer value) throws Exception {
-            // slow down the map in order to have more intermediate data.
-            LockSupport.parkNanos(100000);
+            // Allow working only one subtask until the checkpoint barrier reaches the sink.
+            if (getRuntimeContext().getIndexOfThisSubtask() > 0) {
+                checkpointReachSinkLatch.get().await();
+            }
+
             return value;
         }
     }
