diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValve.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValve.java
index e365df631f0..e55443559c2 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValve.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValve.java
@@ -131,6 +131,16 @@ public class StatusWatermarkValve {
 			// if all input channels of the valve are now idle, we need to output an idle stream
 			// status from the valve (this also marks the valve as idle)
 			if (!InputChannelStatus.hasActiveChannels(channelStatuses)) {
+
+				// now that all input channels are idle and no channels will continue to advance its watermark,
+				// we should "flush" all watermarks across all channels; effectively, this means emitting
+				// the max watermark across all channels as the new watermark. Also, since we already try to advance
+				// the min watermark as channels individually become IDLE, here we only need to perform the flush
+				// if the watermark of the last active channel that just became idle is the current min watermark.
+				if (channelStatuses[channelIndex].watermark == lastOutputWatermark) {
+					findAndOutputMaxWatermarkAcrossAllChannels();
+				}
+
 				lastOutputStreamStatus = StreamStatus.IDLE;
 				outputHandler.handleStreamStatus(lastOutputStreamStatus);
 			} else if (channelStatuses[channelIndex].watermark == lastOutputWatermark) {
@@ -178,6 +188,19 @@ public class StatusWatermarkValve {
 		}
 	}
 
+	private void findAndOutputMaxWatermarkAcrossAllChannels() {
+		long maxWatermark = Long.MIN_VALUE;
+
+		for (InputChannelStatus channelStatus : channelStatuses) {
+			maxWatermark = Math.max(channelStatus.watermark, maxWatermark);
+		}
+
+		if (maxWatermark > lastOutputWatermark) {
+			lastOutputWatermark = maxWatermark;
+			outputHandler.handleWatermark(new Watermark(lastOutputWatermark));
+		}
+	}
+
 	/**
 	 * An {@code InputChannelStatus} keeps track of an input channel's last watermark, stream
 	 * status, and whether or not the channel's current watermark is aligned with the overall
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValveTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValveTest.java
index 4f5e8744aa8..1b6e3bad374 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValveTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/streamstatus/StatusWatermarkValveTest.java
@@ -308,6 +308,48 @@ public class StatusWatermarkValveTest {
 		assertEquals(new Watermark(38), valveOutput.popLastSeenOutput());
 	}
 
+	/**
+	 * Tests that when all inputs become idle, the max watermark across all channels
+	 * is correctly "flushed" from the valve, as well as the stream status IDLE marker.
+	 */
+	@Test
+	public void testAllInputsBecomeIdleFlushMaxWatermarkAndStreamStatus() {
+		BufferedValveOutputHandler valveOutput = new BufferedValveOutputHandler();
+		StatusWatermarkValve valve = new StatusWatermarkValve(3, valveOutput);
+
+		// -------------------------------------------------------------------------------------------
+		// Setup valve for test case:
+		//  channel #1: Watermark 10, ACTIVE
+		//  channel #2: Watermark 5, ACTIVE
+		//  channel #3: Watermark 3, ACTIVE
+		//  Min Watermark across channels = 3 (from channel #3)
+		// -------------------------------------------------------------------------------------------
+
+		valve.inputWatermark(new Watermark(10), 0);
+		assertEquals(null, valveOutput.popLastSeenOutput());
+
+		valve.inputWatermark(new Watermark(5), 1);
+		assertEquals(null, valveOutput.popLastSeenOutput());
+
+		valve.inputWatermark(new Watermark(3), 2);
+		assertEquals(new Watermark(3), valveOutput.popLastSeenOutput());
+
+		// -------------------------------------------------------------------------------------------
+		// Order of becoming IDLE:
+		//  channel #1 ----------------> channel #2 ----------------> channel #3
+		//   |-> (nothing emitted)        |-> (nothing emitted)        |-> Emit Watermark(10) & IDLE
+		// -------------------------------------------------------------------------------------------
+
+		valve.inputStreamStatus(StreamStatus.IDLE, 0);
+		valve.inputStreamStatus(StreamStatus.IDLE, 1);
+		assertEquals(null, valveOutput.popLastSeenOutput());
+
+		valve.inputStreamStatus(StreamStatus.IDLE, 2);
+		assertEquals(new Watermark(10), valveOutput.popLastSeenOutput());
+		assertEquals(StreamStatus.IDLE, valveOutput.popLastSeenOutput());
+		assertEquals(null, valveOutput.popLastSeenOutput());
+	}
+
 	private class BufferedValveOutputHandler implements StatusWatermarkValve.ValveOutputHandler {
 		private BlockingQueue<StreamElement> allOutputs = new LinkedBlockingQueue<>();
 
