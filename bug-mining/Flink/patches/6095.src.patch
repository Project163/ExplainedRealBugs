diff --git a/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java b/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java
index 557397144e0..2cbb5cfb50d 100644
--- a/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java
+++ b/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java
@@ -42,7 +42,6 @@ import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.messages.FlinkJobNotFoundException;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.util.ExceptionUtils;
-import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.concurrent.FutureUtils;
 import org.apache.flink.util.concurrent.ScheduledExecutor;
 
@@ -56,10 +55,12 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -83,6 +84,11 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
 
     public static final JobID ZERO_JOB_ID = new JobID(0, 0);
 
+    private static boolean isCanceledOrFailed(ApplicationStatus applicationStatus) {
+        return applicationStatus == ApplicationStatus.CANCELED
+                || applicationStatus == ApplicationStatus.FAILED;
+    }
+
     private final PackagedProgram application;
 
     private final Collection<JobID> recoveredJobIds;
@@ -148,46 +154,46 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
      */
     private CompletableFuture<Acknowledge> finishBootstrapTasks(
             final DispatcherGateway dispatcherGateway) {
-        boolean shouldShutDownOnFinish =
-                configuration.getBoolean(DeploymentOptions.SHUTDOWN_ON_APPLICATION_FINISH);
-
-        return applicationCompletionFuture
-                .thenApply(
-                        ignored -> {
-                            LOG.info("Application completed SUCCESSFULLY");
-                            return ApplicationStatus.SUCCEEDED;
-                        })
-                .exceptionally(
-                        t -> {
-                            final Optional<ApplicationStatus> applicationStatusOptional =
-                                    extractApplicationStatus(t);
-
-                            if (applicationStatusOptional.isPresent()
-                                    && isCanceledOrFailed(applicationStatusOptional.get())) {
-                                final ApplicationStatus applicationStatus =
-                                        applicationStatusOptional.get();
-                                LOG.info("Application {}: ", applicationStatus, t);
-                                return applicationStatus;
-                            }
-
-                            LOG.warn("Application failed unexpectedly: ", t);
-                            // errorHandler triggers a cluster shutdown. We never prevent shutdown
-                            // in this case as the job likely failed on startup and never reached a
-                            // running state.
-                            this.errorHandler.onFatalError(
-                                    new FlinkException("Application failed unexpectedly.", t));
-                            throw new CompletionException(t);
-                        })
-                .thenCompose(
-                        applicationStatus ->
-                                shouldShutDownOnFinish
-                                        ? dispatcherGateway.shutDownCluster(applicationStatus)
-                                        : CompletableFuture.completedFuture(Acknowledge.get()));
+        final CompletableFuture<Acknowledge> shutdownFuture =
+                applicationCompletionFuture
+                        .handle(
+                                (ignored, t) -> {
+                                    if (t == null) {
+                                        LOG.info("Application completed SUCCESSFULLY");
+                                        return finish(
+                                                dispatcherGateway, ApplicationStatus.SUCCEEDED);
+                                    }
+                                    final Optional<ApplicationStatus> maybeApplicationStatus =
+                                            extractApplicationStatus(t);
+                                    if (maybeApplicationStatus.isPresent()
+                                            && isCanceledOrFailed(maybeApplicationStatus.get())) {
+                                        final ApplicationStatus applicationStatus =
+                                                maybeApplicationStatus.get();
+                                        LOG.info("Application {}: ", applicationStatus, t);
+                                        return finish(dispatcherGateway, applicationStatus);
+                                    }
+                                    if (t instanceof CancellationException) {
+                                        LOG.warn(
+                                                "Application has been cancelled because the {} is being stopped.",
+                                                ApplicationDispatcherBootstrap.class
+                                                        .getSimpleName());
+                                        return CompletableFuture.completedFuture(Acknowledge.get());
+                                    }
+                                    LOG.warn("Application failed unexpectedly: ", t);
+                                    return FutureUtils.<Acknowledge>completedExceptionally(t);
+                                })
+                        .thenCompose(Function.identity());
+        FutureUtils.handleUncaughtException(shutdownFuture, (t, e) -> errorHandler.onFatalError(e));
+        return shutdownFuture;
     }
 
-    private boolean isCanceledOrFailed(ApplicationStatus applicationStatus) {
-        return applicationStatus == ApplicationStatus.CANCELED
-                || applicationStatus == ApplicationStatus.FAILED;
+    private CompletableFuture<Acknowledge> finish(
+            DispatcherGateway dispatcherGateway, ApplicationStatus applicationStatus) {
+        boolean shouldShutDownOnFinish =
+                configuration.getBoolean(DeploymentOptions.SHUTDOWN_ON_APPLICATION_FINISH);
+        return shouldShutDownOnFinish
+                ? dispatcherGateway.shutDownCluster(applicationStatus)
+                : CompletableFuture.completedFuture(Acknowledge.get());
     }
 
     private Optional<ApplicationStatus> extractApplicationStatus(Throwable t) {
@@ -349,7 +355,7 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
     /**
      * If the given {@link JobResult} indicates success, this passes through the {@link JobResult}.
      * Otherwise, this returns a future that is finished exceptionally (potentially with an
-     * exception from the {@link JobResult}.
+     * exception from the {@link JobResult}).
      */
     private CompletableFuture<JobResult> unwrapJobResultException(
             final CompletableFuture<JobResult> jobResult) {
diff --git a/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapITCase.java b/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapITCase.java
new file mode 100644
index 00000000000..a5f204188cb
--- /dev/null
+++ b/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapITCase.java
@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.client.deployment.application;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.api.common.time.Deadline;
+import org.apache.flink.client.cli.ClientOptions;
+import org.apache.flink.client.deployment.application.executors.EmbeddedExecutor;
+import org.apache.flink.client.program.PackagedProgram;
+import org.apache.flink.client.testjar.BlockingJob;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.DeploymentOptions;
+import org.apache.flink.configuration.HighAvailabilityOptions;
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;
+import org.apache.flink.runtime.dispatcher.SessionDispatcherFactory;
+import org.apache.flink.runtime.dispatcher.runner.DefaultDispatcherRunnerFactory;
+import org.apache.flink.runtime.entrypoint.component.DefaultDispatcherResourceManagerComponentFactory;
+import org.apache.flink.runtime.entrypoint.component.DispatcherResourceManagerComponentFactory;
+import org.apache.flink.runtime.highavailability.nonha.embedded.EmbeddedHaServicesWithLeadershipControl;
+import org.apache.flink.runtime.jobmanager.HighAvailabilityMode;
+import org.apache.flink.runtime.jobmaster.JobResult;
+import org.apache.flink.runtime.messages.FlinkJobNotFoundException;
+import org.apache.flink.runtime.minicluster.MiniCluster;
+import org.apache.flink.runtime.minicluster.TestingMiniCluster;
+import org.apache.flink.runtime.minicluster.TestingMiniClusterConfiguration;
+import org.apache.flink.runtime.resourcemanager.StandaloneResourceManagerFactory;
+import org.apache.flink.runtime.rest.JobRestEndpointFactory;
+import org.apache.flink.runtime.testutils.CommonTestUtils;
+import org.apache.flink.testutils.TestingUtils;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.Test;
+import org.junit.jupiter.api.Assertions;
+
+import java.time.Duration;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Supplier;
+
+/** Integration tests related to {@link ApplicationDispatcherBootstrap}. */
+public class ApplicationDispatcherBootstrapITCase extends TestLogger {
+
+    private static final Duration TIMEOUT = Duration.ofMinutes(10);
+
+    private static Supplier<DispatcherResourceManagerComponentFactory>
+            createApplicationModeDispatcherResourceManagerComponentFactorySupplier(
+                    Configuration configuration, PackagedProgram program) {
+        return () -> {
+            final ApplicationDispatcherLeaderProcessFactoryFactory
+                    applicationDispatcherLeaderProcessFactoryFactory =
+                            ApplicationDispatcherLeaderProcessFactoryFactory.create(
+                                    new Configuration(configuration),
+                                    SessionDispatcherFactory.INSTANCE,
+                                    program);
+            return new DefaultDispatcherResourceManagerComponentFactory(
+                    new DefaultDispatcherRunnerFactory(
+                            applicationDispatcherLeaderProcessFactoryFactory),
+                    StandaloneResourceManagerFactory.getInstance(),
+                    JobRestEndpointFactory.INSTANCE);
+        };
+    }
+
+    @Test
+    public void testDispatcherRecoversAfterLosingAndRegainingLeadership() throws Exception {
+        final String blockId = UUID.randomUUID().toString();
+        final Deadline deadline = Deadline.fromNow(TIMEOUT);
+        final Configuration configuration = new Configuration();
+        configuration.set(HighAvailabilityOptions.HA_MODE, HighAvailabilityMode.ZOOKEEPER.name());
+        configuration.set(DeploymentOptions.TARGET, EmbeddedExecutor.NAME);
+        configuration.set(ClientOptions.CLIENT_RETRY_PERIOD, Duration.ofMillis(100));
+        final TestingMiniClusterConfiguration clusterConfiguration =
+                TestingMiniClusterConfiguration.newBuilder()
+                        .setConfiguration(configuration)
+                        .build();
+        final EmbeddedHaServicesWithLeadershipControl haServices =
+                new EmbeddedHaServicesWithLeadershipControl(TestingUtils.defaultExecutor());
+        final TestingMiniCluster.Builder clusterBuilder =
+                TestingMiniCluster.newBuilder(clusterConfiguration)
+                        .setHighAvailabilityServicesSupplier(() -> haServices)
+                        .setDispatcherResourceManagerComponentFactorySupplier(
+                                createApplicationModeDispatcherResourceManagerComponentFactorySupplier(
+                                        clusterConfiguration.getConfiguration(),
+                                        BlockingJob.getProgram(blockId)));
+        try (final MiniCluster cluster = clusterBuilder.build()) {
+
+            // start mini cluster and submit the job
+            cluster.start();
+
+            // wait until job is running
+            awaitJobStatus(
+                    cluster,
+                    ApplicationDispatcherBootstrap.ZERO_JOB_ID,
+                    JobStatus.RUNNING,
+                    deadline);
+
+            // make sure the operator is actually running
+            BlockingJob.awaitRunning(blockId);
+
+            final CompletableFuture<JobResult> firstJobResult =
+                    cluster.requestJobResult(ApplicationDispatcherBootstrap.ZERO_JOB_ID);
+            haServices.revokeDispatcherLeadership();
+            // make sure the leadership is revoked to avoid race conditions
+            Assertions.assertEquals(
+                    ApplicationStatus.UNKNOWN, firstJobResult.get().getApplicationStatus());
+            haServices.grantDispatcherLeadership();
+
+            // job is suspended, wait until it's running
+            awaitJobStatus(
+                    cluster,
+                    ApplicationDispatcherBootstrap.ZERO_JOB_ID,
+                    JobStatus.RUNNING,
+                    deadline);
+
+            // unblock processing so the job can finish
+            BlockingJob.unblock(blockId);
+
+            // and wait for it to actually finish
+            final CompletableFuture<JobResult> secondJobResult =
+                    cluster.requestJobResult(ApplicationDispatcherBootstrap.ZERO_JOB_ID);
+            Assertions.assertTrue(secondJobResult.get().isSuccess());
+            Assertions.assertEquals(
+                    ApplicationStatus.SUCCEEDED, secondJobResult.get().getApplicationStatus());
+
+            // the cluster should shut down automatically once the application completes
+            awaitClusterStopped(cluster, deadline);
+        } finally {
+            BlockingJob.cleanUp(blockId);
+        }
+    }
+
+    private static void awaitClusterStopped(MiniCluster cluster, Deadline deadline)
+            throws Exception {
+        CommonTestUtils.waitUntilCondition(() -> !cluster.isRunning(), deadline);
+    }
+
+    private static void awaitJobStatus(
+            MiniCluster cluster, JobID jobId, JobStatus status, Deadline deadline)
+            throws Exception {
+        CommonTestUtils.waitUntilCondition(
+                () -> {
+                    try {
+                        return cluster.getJobStatus(jobId).get() == status;
+                    } catch (ExecutionException e) {
+                        if (ExceptionUtils.findThrowable(e, FlinkJobNotFoundException.class)
+                                .isPresent()) {
+                            // job may not be yet submitted
+                            return false;
+                        }
+                        throw e;
+                    }
+                },
+                deadline);
+    }
+}
diff --git a/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java b/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java
index 7bd123ce256..4017c2f5c6d 100644
--- a/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java
+++ b/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java
@@ -20,10 +20,9 @@ package org.apache.flink.client.deployment.application;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
-import org.apache.flink.client.cli.CliFrontendTestUtils;
 import org.apache.flink.client.deployment.application.executors.EmbeddedExecutor;
 import org.apache.flink.client.program.PackagedProgram;
-import org.apache.flink.client.program.ProgramInvocationException;
+import org.apache.flink.client.testjar.MultiExecuteJob;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.DeploymentOptions;
 import org.apache.flink.configuration.HighAvailabilityOptions;
@@ -54,12 +53,8 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.EnumSource;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.net.MalformedURLException;
 import java.util.Collections;
 import java.util.Optional;
-import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.ExecutionException;
@@ -67,6 +62,8 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Supplier;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -83,8 +80,9 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
             "org.apache.flink.client.testjar.MultiExecuteJob";
     private static final int TIMEOUT_SECONDS = 10;
 
-    final ScheduledExecutorService executor = Executors.newScheduledThreadPool(4);
-    final ScheduledExecutor scheduledExecutor = new ScheduledExecutorServiceAdapter(executor);
+    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(4);
+    private final ScheduledExecutor scheduledExecutor =
+            new ScheduledExecutorServiceAdapter(executor);
 
     @AfterEach
     public void cleanup() {
@@ -280,7 +278,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         final TestingDispatcherGateway.Builder dispatcherBuilder =
                 canceledJobGatewayBuilder()
                         .setClusterShutdownFunction(
-                                (status) -> {
+                                status -> {
                                     clusterShutdownStatus.complete(status);
                                     return CompletableFuture.completedFuture(Acknowledge.get());
                                 });
@@ -323,7 +321,14 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
 
     @Test
     public void testApplicationIsStoppedWhenStoppingBootstrap() throws Exception {
-        final TestingDispatcherGateway.Builder dispatcherBuilder = runningJobGatewayBuilder();
+        final AtomicBoolean shutdownCalled = new AtomicBoolean(false);
+        final TestingDispatcherGateway.Builder dispatcherBuilder =
+                runningJobGatewayBuilder()
+                        .setClusterShutdownFunction(
+                                status -> {
+                                    shutdownCalled.set(true);
+                                    return CompletableFuture.completedFuture(Acknowledge.get());
+                                });
 
         // we're "listening" on this to be completed to verify that the error handler is called.
         // In production, this will shut down the cluster with an exception.
@@ -342,19 +347,34 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
 
         bootstrap.stop();
 
-        // we call the error handler
-        assertException(errorHandlerFuture, CancellationException.class);
+        // we didn't call the error handler
+        assertFalse(errorHandlerFuture.isDone());
 
-        // we return a future that is completed exceptionally
-        assertException(completionFuture, CancellationException.class);
+        // completion future gets completed normally
+        completionFuture.get();
+
+        // verify that we didn't shut down the cluster
+        assertFalse(shutdownCalled.get());
 
         // verify that the application task is being cancelled
         assertThat(applicationExecutionFuture.isCancelled(), is(true));
+        assertThat(applicationExecutionFuture.isDone(), is(true));
     }
 
     @Test
-    public void testErrorHandlerIsCalledWhenStoppingBootstrap() throws Exception {
-        final TestingDispatcherGateway.Builder dispatcherBuilder = runningJobGatewayBuilder();
+    public void testErrorHandlerIsCalledWhenSubmissionThrowsAnException() throws Exception {
+        final AtomicBoolean shutdownCalled = new AtomicBoolean(false);
+        final TestingDispatcherGateway.Builder dispatcherBuilder =
+                runningJobGatewayBuilder()
+                        .setSubmitFunction(
+                                jobGraph -> {
+                                    throw new FlinkRuntimeException("Nope!");
+                                })
+                        .setClusterShutdownFunction(
+                                status -> {
+                                    shutdownCalled.set(true);
+                                    return CompletableFuture.completedFuture(Acknowledge.get());
+                                });
 
         // we're "listening" on this to be completed to verify that the error handler is called.
         // In production, this will shut down the cluster with an exception.
@@ -369,28 +389,46 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         final CompletableFuture<Acknowledge> completionFuture =
                 bootstrap.getBootstrapCompletionFuture();
 
-        bootstrap.stop();
-
         // we call the error handler
-        assertException(errorHandlerFuture, CancellationException.class);
+        assertException(errorHandlerFuture, FlinkRuntimeException.class);
 
         // we return a future that is completed exceptionally
-        assertException(completionFuture, CancellationException.class);
+        assertException(completionFuture, FlinkRuntimeException.class);
+
+        // and cluster shutdown didn't get called
+        assertFalse(shutdownCalled.get());
     }
 
     @Test
-    public void testErrorHandlerIsCalledWhenSubmissionFails() throws Exception {
+    public void testErrorHandlerIsCalledWhenShutdownCompletesExceptionally() throws Exception {
+        testErrorHandlerIsCalled(
+                () ->
+                        FutureUtils.completedExceptionally(
+                                new FlinkRuntimeException("Test exception.")));
+    }
+
+    @Test
+    public void testErrorHandlerIsCalledWhenShutdownThrowsAnException() throws Exception {
+        testErrorHandlerIsCalled(
+                () -> {
+                    throw new FlinkRuntimeException("Test exception.");
+                });
+    }
+
+    private void testErrorHandlerIsCalled(Supplier<CompletableFuture<Acknowledge>> shutdownFunction)
+            throws Exception {
         final TestingDispatcherGateway.Builder dispatcherBuilder =
                 new TestingDispatcherGateway.Builder()
                         .setSubmitFunction(
-                                jobGraph -> {
-                                    throw new FlinkRuntimeException("Nope!");
-                                })
-                        .setClusterShutdownFunction(
-                                status -> {
-                                    fail("We should not call shutdownCluster()");
-                                    return CompletableFuture.completedFuture(Acknowledge.get());
-                                });
+                                jobGraph -> CompletableFuture.completedFuture(Acknowledge.get()))
+                        .setRequestJobStatusFunction(
+                                jobId -> CompletableFuture.completedFuture(JobStatus.FINISHED))
+                        .setRequestJobResultFunction(
+                                jobId ->
+                                        CompletableFuture.completedFuture(
+                                                createJobResult(
+                                                        jobId, ApplicationStatus.SUCCEEDED)))
+                        .setClusterShutdownFunction(status -> shutdownFunction.get());
 
         // we're "listening" on this to be completed to verify that the error handler is called.
         // In production, this will shut down the cluster with an exception.
@@ -407,10 +445,10 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
                 bootstrap.getBootstrapCompletionFuture();
 
         // we call the error handler
-        assertException(errorHandlerFuture, ApplicationExecutionException.class);
+        assertException(errorHandlerFuture, FlinkRuntimeException.class);
 
         // we return a future that is completed exceptionally
-        assertException(completionFuture, ApplicationExecutionException.class);
+        assertException(completionFuture, FlinkRuntimeException.class);
     }
 
     @Test
@@ -426,16 +464,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
                                 })
                         .build();
 
-        final PackagedProgram program =
-                PackagedProgram.newBuilder()
-                        .setUserClassPaths(
-                                Collections.singletonList(
-                                        new File(CliFrontendTestUtils.getTestJarPath())
-                                                .toURI()
-                                                .toURL()))
-                        .setEntryPointClassName(MULTI_EXECUTE_JOB_CLASS_NAME)
-                        .setArguments(String.valueOf(2), String.valueOf(true))
-                        .build();
+        final PackagedProgram program = getProgram(2);
 
         final Configuration configuration = getConfiguration();
         configuration.set(DeploymentOptions.ATTACHED, true);
@@ -466,7 +495,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         final TestingDispatcherGateway.Builder dispatcherBuilder =
                 finishedJobGatewayBuilder()
                         .setClusterShutdownFunction(
-                                (status) -> {
+                                status -> {
                                     externalShutdownFuture.complete(status);
                                     return CompletableFuture.completedFuture(Acknowledge.get());
                                 });
@@ -497,7 +526,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         final TestingDispatcherGateway.Builder dispatcherBuilder =
                 failedJobGatewayBuilder()
                         .setClusterShutdownFunction(
-                                (status) -> {
+                                status -> {
                                     externalShutdownFuture.complete(status);
                                     return CompletableFuture.completedFuture(Acknowledge.get());
                                 });
@@ -528,7 +557,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         final TestingDispatcherGateway.Builder dispatcherBuilder =
                 canceledJobGatewayBuilder()
                         .setClusterShutdownFunction(
-                                (status) -> {
+                                status -> {
                                     externalShutdownFuture.complete(status);
                                     return CompletableFuture.completedFuture(Acknowledge.get());
                                 });
@@ -550,9 +579,10 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
     }
 
     @Test
-    public void testClusterDoesNotShutdownWhenApplicationStatusUnknown() throws Exception {
+    public void testErrorHandlerIsCalledWhenApplicationStatusIsUnknown() throws Exception {
         // we're "listening" on this to be completed to verify that the cluster
         // is being shut down from the ApplicationDispatcherBootstrap
+        final AtomicBoolean shutdownCalled = new AtomicBoolean(false);
         final TestingDispatcherGateway.Builder dispatcherBuilder =
                 canceledJobGatewayBuilder()
                         .setRequestJobResultFunction(
@@ -561,20 +591,27 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
                                                 createUnknownJobResult(jobID)))
                         .setClusterShutdownFunction(
                                 status -> {
-                                    fail("We should not call shutdownCluster()");
+                                    shutdownCalled.set(true);
                                     return CompletableFuture.completedFuture(Acknowledge.get());
                                 });
 
         final TestingDispatcherGateway dispatcherGateway = dispatcherBuilder.build();
+        final CompletableFuture<Void> errorHandlerFuture = new CompletableFuture<>();
         final ApplicationDispatcherBootstrap bootstrap =
-                createApplicationDispatcherBootstrap(3, dispatcherGateway, scheduledExecutor);
-
-        final CompletableFuture<Acknowledge> applicationFuture =
-                bootstrap.getBootstrapCompletionFuture();
+                createApplicationDispatcherBootstrap(
+                        3,
+                        dispatcherGateway,
+                        scheduledExecutor,
+                        errorHandlerFuture::completeExceptionally);
 
-        final UnsuccessfulExecutionException exception =
-                assertException(applicationFuture, UnsuccessfulExecutionException.class);
-        assertEquals(exception.getStatus(), ApplicationStatus.UNKNOWN);
+        // check that bootstrap shutdown completes exceptionally
+        assertException(
+                bootstrap.getApplicationCompletionFuture(), UnsuccessfulExecutionException.class);
+        // and exception gets propagated to error handler
+        assertException(
+                bootstrap.getApplicationCompletionFuture(), UnsuccessfulExecutionException.class);
+        // and cluster didn't shut down
+        assertFalse(shutdownCalled.get());
     }
 
     @Test
@@ -704,7 +741,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         final TestingDispatcherGateway dispatcherGateway =
                 dispatcherGatewayBuilder(jobStatus)
                         .setClusterShutdownFunction(
-                                (status) -> {
+                                status -> {
                                     fail("Cluster shutdown should not be called");
                                     return CompletableFuture.completedFuture(Acknowledge.get());
                                 })
@@ -832,19 +869,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
     }
 
     private PackagedProgram getProgram(int noOfJobs) throws FlinkException {
-        try {
-            return PackagedProgram.newBuilder()
-                    .setUserClassPaths(
-                            Collections.singletonList(
-                                    new File(CliFrontendTestUtils.getTestJarPath())
-                                            .toURI()
-                                            .toURL()))
-                    .setEntryPointClassName(MULTI_EXECUTE_JOB_CLASS_NAME)
-                    .setArguments(String.valueOf(noOfJobs), Boolean.toString(true))
-                    .build();
-        } catch (ProgramInvocationException | FileNotFoundException | MalformedURLException e) {
-            throw new FlinkException("Could not load the provided entrypoint class.", e);
-        }
+        return MultiExecuteJob.getProgram(noOfJobs, true);
     }
 
     private static JobResult createFailedJobResult(final JobID jobId) {
diff --git a/flink-clients/src/test/java/org/apache/flink/client/testjar/BlockingJob.java b/flink-clients/src/test/java/org/apache/flink/client/testjar/BlockingJob.java
new file mode 100644
index 00000000000..d67c854dcb0
--- /dev/null
+++ b/flink-clients/src/test/java/org/apache/flink/client/testjar/BlockingJob.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.client.testjar;
+
+import org.apache.flink.api.java.ExecutionEnvironment;
+import org.apache.flink.api.java.io.DiscardingOutputFormat;
+import org.apache.flink.client.cli.CliFrontendTestUtils;
+import org.apache.flink.client.program.PackagedProgram;
+import org.apache.flink.client.program.ProgramInvocationException;
+import org.apache.flink.util.FlinkException;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.MalformedURLException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * A testing job whith blocks processing until it gets manually {@link #unblock(String) unblocked}.
+ */
+public class BlockingJob {
+
+    private static final ConcurrentMap<String, CountDownLatch> RUNNING = new ConcurrentHashMap<>();
+    private static final ConcurrentMap<String, CountDownLatch> BLOCKED = new ConcurrentHashMap<>();
+
+    public static PackagedProgram getProgram(String blockId) throws FlinkException {
+        try {
+            return PackagedProgram.newBuilder()
+                    .setUserClassPaths(
+                            Collections.singletonList(
+                                    new File(CliFrontendTestUtils.getTestJarPath())
+                                            .toURI()
+                                            .toURL()))
+                    .setEntryPointClassName(BlockingJob.class.getName())
+                    .setArguments(blockId)
+                    .build();
+        } catch (ProgramInvocationException | FileNotFoundException | MalformedURLException e) {
+            throw new FlinkException("Could not load the provided entrypoint class.", e);
+        }
+    }
+
+    public static void cleanUp(String blockId) {
+        RUNNING.remove(blockId);
+        BLOCKED.remove(blockId);
+    }
+
+    public static void awaitRunning(String blockId) throws InterruptedException {
+        RUNNING.computeIfAbsent(blockId, ignored -> new CountDownLatch(1)).await();
+    }
+
+    public static void unblock(String blockId) {
+        BLOCKED.computeIfAbsent(blockId, ignored -> new CountDownLatch(1)).countDown();
+    }
+
+    public static void main(String[] args) throws Exception {
+        final String blockId = args[0];
+        final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();
+        env.fromCollection(Arrays.asList(1, 2, 3))
+                .map(element -> element + 1)
+                .map(
+                        element -> {
+                            RUNNING.computeIfAbsent(blockId, ignored -> new CountDownLatch(1))
+                                    .countDown();
+                            BLOCKED.computeIfAbsent(blockId, ignored -> new CountDownLatch(1))
+                                    .await();
+                            return element;
+                        })
+                .output(new DiscardingOutputFormat<>());
+        env.execute();
+    }
+}
diff --git a/flink-clients/src/test/java/org/apache/flink/client/testjar/MultiExecuteJob.java b/flink-clients/src/test/java/org/apache/flink/client/testjar/MultiExecuteJob.java
index cb0b4ca4f4f..42296187b85 100644
--- a/flink-clients/src/test/java/org/apache/flink/client/testjar/MultiExecuteJob.java
+++ b/flink-clients/src/test/java/org/apache/flink/client/testjar/MultiExecuteJob.java
@@ -20,8 +20,16 @@ package org.apache.flink.client.testjar;
 
 import org.apache.flink.api.java.ExecutionEnvironment;
 import org.apache.flink.api.java.io.DiscardingOutputFormat;
+import org.apache.flink.client.cli.CliFrontendTestUtils;
+import org.apache.flink.client.program.PackagedProgram;
+import org.apache.flink.client.program.ProgramInvocationException;
+import org.apache.flink.util.FlinkException;
 
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.MalformedURLException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -29,6 +37,22 @@ import java.util.List;
  */
 public class MultiExecuteJob {
 
+    public static PackagedProgram getProgram(int noOfJobs, boolean attached) throws FlinkException {
+        try {
+            return PackagedProgram.newBuilder()
+                    .setUserClassPaths(
+                            Collections.singletonList(
+                                    new File(CliFrontendTestUtils.getTestJarPath())
+                                            .toURI()
+                                            .toURL()))
+                    .setEntryPointClassName(MultiExecuteJob.class.getName())
+                    .setArguments(String.valueOf(noOfJobs), Boolean.toString(attached))
+                    .build();
+        } catch (ProgramInvocationException | FileNotFoundException | MalformedURLException e) {
+            throw new FlinkException("Could not load the provided entrypoint class.", e);
+        }
+    }
+
     public static void main(String[] args) throws Exception {
         int noOfExecutes = Integer.parseInt(args[0]);
         boolean attached = args.length > 1 && Boolean.parseBoolean(args[1]);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
index 2f2c4985d9e..5b095743d0e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
@@ -456,12 +456,13 @@ public class MiniCluster implements AutoCloseableAsync {
             final CompletableFuture<ApplicationStatus> shutDownFuture =
                     dispatcherResourceManagerComponent.getShutDownFuture();
             FutureUtils.assertNoException(
-                    shutDownFuture.thenRun(dispatcherResourceManagerComponent::closeAsync));
+                    shutDownFuture.thenCompose(
+                            applicationStatus ->
+                                    dispatcherResourceManagerComponent.stopApplication(
+                                            applicationStatus, null)));
             shutDownFutures.add(shutDownFuture);
         }
-
-        FutureUtils.assertNoException(
-                FutureUtils.completeAll(shutDownFutures).thenRun(this::closeAsync));
+        FutureUtils.completeAll(shutDownFutures).whenComplete((ignored, exception) -> closeAsync());
     }
 
     @VisibleForTesting
@@ -492,8 +493,8 @@ public class MiniCluster implements AutoCloseableAsync {
                         fatalErrorHandler));
     }
 
-    @Nonnull
-    DispatcherResourceManagerComponentFactory createDispatcherResourceManagerComponentFactory() {
+    protected DispatcherResourceManagerComponentFactory
+            createDispatcherResourceManagerComponentFactory() {
         return DefaultDispatcherResourceManagerComponentFactory.createSessionComponentFactory(
                 StandaloneResourceManagerFactory.getInstance());
     }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobExecutionITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobExecutionITCase.java
index 469f290261a..283fe08d24a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobExecutionITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobExecutionITCase.java
@@ -57,7 +57,8 @@ public class JobExecutionITCase extends TestLogger {
                         .setLocalCommunication(true)
                         .build();
 
-        try (TestingMiniCluster miniCluster = new TestingMiniCluster(miniClusterConfiguration)) {
+        try (TestingMiniCluster miniCluster =
+                TestingMiniCluster.newBuilder(miniClusterConfiguration).build()) {
             miniCluster.start();
 
             miniCluster.submitJob(jobGraph).get();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
index aa3a809df23..62b9fd58ed8 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
@@ -80,12 +80,13 @@ public class LeaderChangeClusterComponentsTest extends TestLogger {
                 new EmbeddedHaServicesWithLeadershipControl(TestingUtils.defaultExecutor());
 
         miniCluster =
-                new TestingMiniCluster(
-                        TestingMiniClusterConfiguration.newBuilder()
-                                .setNumTaskManagers(NUM_TMS)
-                                .setNumSlotsPerTaskManager(SLOTS_PER_TM)
-                                .build(),
-                        () -> highAvailabilityServices);
+                TestingMiniCluster.newBuilder(
+                                TestingMiniClusterConfiguration.newBuilder()
+                                        .setNumTaskManagers(NUM_TMS)
+                                        .setNumSlotsPerTaskManager(SLOTS_PER_TM)
+                                        .build())
+                        .setHighAvailabilityServicesSupplier(() -> highAvailabilityServices)
+                        .build();
 
         miniCluster.start();
     }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/TestingMiniCluster.java b/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/TestingMiniCluster.java
index d0767a62f8d..91b75a6c45d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/TestingMiniCluster.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/TestingMiniCluster.java
@@ -42,26 +42,73 @@ import java.util.function.Supplier;
 /** {@link MiniCluster} extension which allows to set a custom {@link HighAvailabilityServices}. */
 public class TestingMiniCluster extends MiniCluster {
 
+    public static Builder newBuilder(TestingMiniClusterConfiguration configuration) {
+        return new Builder(configuration);
+    }
+
+    /** Builder for {@link TestingMiniCluster}. */
+    public static class Builder {
+
+        private final TestingMiniClusterConfiguration configuration;
+
+        @Nullable private Supplier<HighAvailabilityServices> highAvailabilityServicesSupplier;
+
+        @Nullable
+        private Supplier<DispatcherResourceManagerComponentFactory>
+                dispatcherResourceManagerComponentFactorySupplier;
+
+        public Builder(TestingMiniClusterConfiguration configuration) {
+            this.configuration = configuration;
+        }
+
+        public Builder setHighAvailabilityServicesSupplier(
+                @Nullable Supplier<HighAvailabilityServices> highAvailabilityServicesSupplier) {
+            this.highAvailabilityServicesSupplier = highAvailabilityServicesSupplier;
+            return this;
+        }
+
+        public Builder setDispatcherResourceManagerComponentFactorySupplier(
+                @Nullable
+                        Supplier<DispatcherResourceManagerComponentFactory>
+                                dispatcherResourceManagerComponentFactorySupplier) {
+            this.dispatcherResourceManagerComponentFactorySupplier =
+                    dispatcherResourceManagerComponentFactorySupplier;
+            return this;
+        }
+
+        public TestingMiniCluster build() {
+            return new TestingMiniCluster(
+                    configuration,
+                    highAvailabilityServicesSupplier,
+                    dispatcherResourceManagerComponentFactorySupplier);
+        }
+    }
+
     private final int numberDispatcherResourceManagerComponents;
 
     private final boolean localCommunication;
 
     @Nullable private final Supplier<HighAvailabilityServices> highAvailabilityServicesSupplier;
 
-    public TestingMiniCluster(
+    @Nullable
+    private final Supplier<DispatcherResourceManagerComponentFactory>
+            dispatcherResourceManagerComponentFactorySupplier;
+
+    private TestingMiniCluster(
             TestingMiniClusterConfiguration miniClusterConfiguration,
-            @Nullable Supplier<HighAvailabilityServices> highAvailabilityServicesSupplier) {
+            @Nullable Supplier<HighAvailabilityServices> highAvailabilityServicesSupplier,
+            @Nullable
+                    Supplier<DispatcherResourceManagerComponentFactory>
+                            dispatcherResourceManagerComponentFactorySupplier) {
         super(miniClusterConfiguration);
         this.numberDispatcherResourceManagerComponents =
                 miniClusterConfiguration.getNumberDispatcherResourceManagerComponents();
         this.highAvailabilityServicesSupplier = highAvailabilityServicesSupplier;
+        this.dispatcherResourceManagerComponentFactorySupplier =
+                dispatcherResourceManagerComponentFactorySupplier;
         this.localCommunication = miniClusterConfiguration.isLocalCommunication();
     }
 
-    public TestingMiniCluster(TestingMiniClusterConfiguration miniClusterConfiguration) {
-        this(miniClusterConfiguration, null);
-    }
-
     @Override
     protected boolean useLocalCommunication() {
         return localCommunication;
@@ -77,6 +124,16 @@ public class TestingMiniCluster extends MiniCluster {
         }
     }
 
+    @Override
+    protected DispatcherResourceManagerComponentFactory
+            createDispatcherResourceManagerComponentFactory() {
+        if (dispatcherResourceManagerComponentFactorySupplier != null) {
+            return dispatcherResourceManagerComponentFactorySupplier.get();
+        } else {
+            return super.createDispatcherResourceManagerComponentFactory();
+        }
+    }
+
     @Override
     protected Collection<? extends DispatcherResourceManagerComponent>
             createDispatcherResourceManagerComponents(
diff --git a/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java b/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java
index a41249892db..98e07e7f22c 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java
@@ -27,20 +27,25 @@ import org.apache.flink.configuration.ClusterOptions;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.runtime.dispatcher.DispatcherGateway;
 import org.apache.flink.runtime.execution.Environment;
+import org.apache.flink.runtime.highavailability.zookeeper.CuratorFrameworkWithUnhandledErrorListener;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphBuilder;
 import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
 import org.apache.flink.runtime.jobmaster.JobResult;
+import org.apache.flink.runtime.leaderretrieval.DefaultLeaderRetrievalService;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalListener;
 import org.apache.flink.runtime.minicluster.TestingMiniCluster;
 import org.apache.flink.runtime.minicluster.TestingMiniClusterConfiguration;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.testutils.ZooKeeperTestUtils;
+import org.apache.flink.runtime.util.ZooKeeperUtils;
 import org.apache.flink.util.TestLogger;
 
 import org.apache.curator.test.TestingServer;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -49,10 +54,12 @@ import javax.annotation.Nullable;
 
 import java.io.IOException;
 import java.time.Duration;
+import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
 
 /** Test the election of a new JobManager leader. */
 public class ZooKeeperLeaderElectionITCase extends TestLogger {
@@ -85,6 +92,7 @@ public class ZooKeeperLeaderElectionITCase extends TestLogger {
      * successfully executed.
      */
     @Test
+    @Ignore("FLINK-25235")
     public void testJobExecutionOnClusterWithLeaderChange() throws Exception {
         final int numDispatchers = 3;
         final int numTMs = 2;
@@ -105,9 +113,30 @@ public class ZooKeeperLeaderElectionITCase extends TestLogger {
                         .setNumSlotsPerTaskManager(numSlotsPerTM)
                         .build();
 
-        Deadline timeout = Deadline.fromNow(TEST_TIMEOUT);
+        final Deadline timeout = Deadline.fromNow(TEST_TIMEOUT);
+
+        try (TestingMiniCluster miniCluster =
+                        TestingMiniCluster.newBuilder(miniClusterConfiguration).build();
+                final CuratorFrameworkWithUnhandledErrorListener curatorFramework =
+                        ZooKeeperUtils.startCuratorFramework(
+                                configuration,
+                                exception -> fail("Fatal error in curator framework."))) {
+
+            // We need to watch for resource manager leader changes to avoid race conditions.
+            final DefaultLeaderRetrievalService resourceManagerLeaderRetrieval =
+                    ZooKeeperUtils.createLeaderRetrievalService(
+                            curatorFramework.asCuratorFramework(),
+                            ZooKeeperUtils.getLeaderPathForResourceManager(),
+                            configuration);
+            @SuppressWarnings("unchecked")
+            final CompletableFuture<String>[] resourceManagerLeaderFutures =
+                    (CompletableFuture<String>[]) new CompletableFuture[numDispatchers];
+            for (int i = 0; i < numDispatchers; i++) {
+                resourceManagerLeaderFutures[i] = new CompletableFuture<>();
+            }
+            resourceManagerLeaderRetrieval.start(
+                    new TestLeaderRetrievalListener(resourceManagerLeaderFutures));
 
-        try (TestingMiniCluster miniCluster = new TestingMiniCluster(miniClusterConfiguration)) {
             miniCluster.start();
 
             final int parallelism = numTMs * numSlotsPerTM;
@@ -121,38 +150,39 @@ public class ZooKeeperLeaderElectionITCase extends TestLogger {
                 final DispatcherGateway leaderDispatcherGateway =
                         getNextLeadingDispatcherGateway(
                                 miniCluster, previousLeaderAddress, timeout);
+                // Make sure resource manager has also changed leadership.
+                resourceManagerLeaderFutures[i].get();
                 previousLeaderAddress = leaderDispatcherGateway.getAddress();
-
-                CommonTestUtils.waitUntilCondition(
-                        () ->
-                                leaderDispatcherGateway
-                                                .requestJobStatus(jobGraph.getJobID(), RPC_TIMEOUT)
-                                                .get()
-                                        == JobStatus.RUNNING,
-                        timeout,
-                        50L);
-
+                awaitRunningStatus(leaderDispatcherGateway, jobGraph, timeout);
                 leaderDispatcherGateway.shutDownCluster();
             }
 
             final DispatcherGateway leaderDispatcherGateway =
                     getNextLeadingDispatcherGateway(miniCluster, previousLeaderAddress, timeout);
-            CommonTestUtils.waitUntilCondition(
-                    () ->
-                            leaderDispatcherGateway
-                                            .requestJobStatus(jobGraph.getJobID(), RPC_TIMEOUT)
-                                            .get()
-                                    == JobStatus.RUNNING,
-                    timeout,
-                    50L);
+            // Make sure resource manager has also changed leadership.
+            resourceManagerLeaderFutures[numDispatchers - 1].get();
+            awaitRunningStatus(leaderDispatcherGateway, jobGraph, timeout);
             CompletableFuture<JobResult> jobResultFuture =
                     leaderDispatcherGateway.requestJobResult(jobGraph.getJobID(), RPC_TIMEOUT);
             BlockingOperator.unblock();
 
             assertThat(jobResultFuture.get().isSuccess(), is(true));
+
+            resourceManagerLeaderRetrieval.stop();
         }
     }
 
+    private static void awaitRunningStatus(
+            DispatcherGateway dispatcherGateway, JobGraph jobGraph, Deadline timeout)
+            throws Exception {
+        CommonTestUtils.waitUntilCondition(
+                () ->
+                        dispatcherGateway.requestJobStatus(jobGraph.getJobID(), RPC_TIMEOUT).get()
+                                == JobStatus.RUNNING,
+                timeout,
+                50L);
+    }
+
     private DispatcherGateway getNextLeadingDispatcherGateway(
             TestingMiniCluster miniCluster,
             @Nullable String previousLeaderAddress,
@@ -218,4 +248,24 @@ public class ZooKeeperLeaderElectionITCase extends TestLogger {
             }
         }
     }
+
+    private static class TestLeaderRetrievalListener implements LeaderRetrievalListener {
+
+        private final CompletableFuture<String>[] futures;
+
+        int changeIdx = 0;
+
+        private TestLeaderRetrievalListener(CompletableFuture<String>[] futures) {
+            this.futures = futures;
+        }
+
+        @Override
+        public void notifyLeaderAddress(
+                @Nullable String leaderAddress, @Nullable UUID leaderSessionID) {
+            futures[changeIdx++].complete(leaderAddress);
+        }
+
+        @Override
+        public void handleError(Exception exception) {}
+    }
 }
