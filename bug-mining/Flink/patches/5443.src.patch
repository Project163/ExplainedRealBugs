diff --git a/flink-end-to-end-tests/test-scripts/common.sh b/flink-end-to-end-tests/test-scripts/common.sh
index 2ec1cbdd86c..d8d6ff60251 100644
--- a/flink-end-to-end-tests/test-scripts/common.sh
+++ b/flink-end-to-end-tests/test-scripts/common.sh
@@ -501,7 +501,7 @@ function wait_job_terminal_state {
   echo "Waiting for job ($job) to reach terminal state $expected_terminal_state ..."
 
   while : ; do
-    local N=$(grep -o "Job $job reached globally terminal state .*" $FLINK_LOG_DIR/*$log_file_name*.log | tail -1 || true)
+    local N=$(grep -o "Job $job reached terminal state .*" $FLINK_LOG_DIR/*$log_file_name*.log | tail -1 || true)
     if [[ -z $N ]]; then
       sleep 1
     else
diff --git a/flink-end-to-end-tests/test-scripts/test_kubernetes_application.sh b/flink-end-to-end-tests/test-scripts/test_kubernetes_application.sh
index 7b56ca544dd..4e62a45f52c 100755
--- a/flink-end-to-end-tests/test-scripts/test_kubernetes_application.sh
+++ b/flink-end-to-end-tests/test-scripts/test_kubernetes_application.sh
@@ -59,4 +59,4 @@ wait_rest_endpoint_up_k8s $jm_pod_name
 # The Flink cluster will be destroyed immediately once the job finished or failed. So we check jobmanager logs
 # instead of checking the result
 kubectl logs -f $jm_pod_name >$LOCAL_LOGS_PATH/jobmanager.log
-grep -E "Job [A-Za-z0-9]+ reached globally terminal state FINISHED" $LOCAL_LOGS_PATH/jobmanager.log
+grep -E "Job [A-Za-z0-9]+ reached terminal state FINISHED" $LOCAL_LOGS_PATH/jobmanager.log
diff --git a/flink-end-to-end-tests/test-scripts/test_kubernetes_pyflink_application.sh b/flink-end-to-end-tests/test-scripts/test_kubernetes_pyflink_application.sh
index c41881100d6..87ff03469d1 100755
--- a/flink-end-to-end-tests/test-scripts/test_kubernetes_pyflink_application.sh
+++ b/flink-end-to-end-tests/test-scripts/test_kubernetes_pyflink_application.sh
@@ -111,4 +111,4 @@ wait_rest_endpoint_up_k8s $jm_pod_name
 # The Flink cluster will be destroyed immediately once the job finished or failed. So we check jobmanager logs
 # instead of checking the result
 kubectl logs -f $jm_pod_name >$LOCAL_LOGS_PATH/jobmanager.log
-grep -E "Job [A-Za-z0-9]+ reached globally terminal state FINISHED" $LOCAL_LOGS_PATH/jobmanager.log
+grep -E "Job [A-Za-z0-9]+ reached terminal state FINISHED" $LOCAL_LOGS_PATH/jobmanager.log
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index 70bf6aa55cf..5aae4cdbc64 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -45,7 +45,6 @@ import org.apache.flink.runtime.jobmaster.JobManagerRunner;
 import org.apache.flink.runtime.jobmaster.JobManagerRunnerResult;
 import org.apache.flink.runtime.jobmaster.JobManagerSharedServices;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
-import org.apache.flink.runtime.jobmaster.JobNotFinishedException;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.jobmaster.factories.DefaultJobManagerJobMetricGroupFactory;
 import org.apache.flink.runtime.messages.Acknowledge;
@@ -438,11 +437,10 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
                         jobManagerRunnerResult.getExecutionGraphInfo().getJobId(),
                         jobManagerRunnerResult.getInitializationFailure());
             } else {
-                return jobReachedGloballyTerminalState(
-                        jobManagerRunnerResult.getExecutionGraphInfo());
+                return jobReachedTerminalState(jobManagerRunnerResult.getExecutionGraphInfo());
             }
         } else {
-            return jobReachedGloballyTerminalState(jobManagerRunnerResult.getExecutionGraphInfo());
+            return jobReachedTerminalState(jobManagerRunnerResult.getExecutionGraphInfo());
         }
     }
 
@@ -458,12 +456,7 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
     }
 
     private CleanupJobState jobManagerRunnerFailed(JobID jobId, Throwable throwable) {
-        if (throwable instanceof JobNotFinishedException) {
-            jobNotFinished(jobId);
-        } else {
-            jobMasterFailed(jobId, throwable);
-        }
-
+        jobMasterFailed(jobId, throwable);
         return CleanupJobState.LOCAL;
     }
 
@@ -826,24 +819,25 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
         fatalErrorHandler.onFatalError(throwable);
     }
 
-    protected CleanupJobState jobReachedGloballyTerminalState(
-            ExecutionGraphInfo executionGraphInfo) {
-        ArchivedExecutionGraph archivedExecutionGraph =
+    protected CleanupJobState jobReachedTerminalState(ExecutionGraphInfo executionGraphInfo) {
+        final ArchivedExecutionGraph archivedExecutionGraph =
                 executionGraphInfo.getArchivedExecutionGraph();
         Preconditions.checkArgument(
-                archivedExecutionGraph.getState().isGloballyTerminalState(),
-                "Job %s is in state %s which is not globally terminal.",
+                archivedExecutionGraph.getState().isTerminalState(),
+                "Job %s is in state %s which is not terminal.",
                 archivedExecutionGraph.getJobID(),
                 archivedExecutionGraph.getState());
 
         log.info(
-                "Job {} reached globally terminal state {}.",
+                "Job {} reached terminal state {}.",
                 archivedExecutionGraph.getJobID(),
                 archivedExecutionGraph.getState());
 
         archiveExecutionGraph(executionGraphInfo);
 
-        return CleanupJobState.GLOBAL;
+        return archivedExecutionGraph.getState().isGloballyTerminalState()
+                ? CleanupJobState.GLOBAL
+                : CleanupJobState.LOCAL;
     }
 
     private void archiveExecutionGraph(ExecutionGraphInfo executionGraphInfo) {
@@ -872,10 +866,6 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
                 });
     }
 
-    protected void jobNotFinished(JobID jobId) {
-        log.info("Job {} was not finished by JobManager.", jobId);
-    }
-
     private void jobMasterFailed(JobID jobId, Throwable cause) {
         // we fail fatally in case of a JobMaster failure in order to restart the
         // dispatcher to recover the jobs again. This only works in HA mode, though
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java
index 4b9b4b8a382..83f173db8c7 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/MiniDispatcher.java
@@ -119,12 +119,10 @@ public class MiniDispatcher extends Dispatcher {
     }
 
     @Override
-    protected CleanupJobState jobReachedGloballyTerminalState(
-            ExecutionGraphInfo executionGraphInfo) {
+    protected CleanupJobState jobReachedTerminalState(ExecutionGraphInfo executionGraphInfo) {
         final ArchivedExecutionGraph archivedExecutionGraph =
                 executionGraphInfo.getArchivedExecutionGraph();
-        final CleanupJobState cleanupHAState =
-                super.jobReachedGloballyTerminalState(executionGraphInfo);
+        final CleanupJobState cleanupHAState = super.jobReachedTerminalState(executionGraphInfo);
 
         if (jobCancelled || executionMode == ClusterEntrypoint.ExecutionMode.DETACHED) {
             // shut down if job is cancelled or we don't have to wait for the execution result
@@ -140,12 +138,4 @@ public class MiniDispatcher extends Dispatcher {
 
         return cleanupHAState;
     }
-
-    @Override
-    protected void jobNotFinished(JobID jobId) {
-        super.jobNotFinished(jobId);
-        // shut down since we have done our job
-        log.info("Shutting down cluster because job not finished");
-        shutDownFuture.complete(ApplicationStatus.UNKNOWN);
-    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunner.java
index a3ca2129943..2d75936ca7b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunner.java
@@ -67,8 +67,6 @@ import java.util.function.Supplier;
  * <ul>
  *   <li>{@link JobManagerRunnerResult} to signal an initialization failure of the {@link
  *       JobMasterService} or the completion of a job
- *   <li>{@link JobNotFinishedException} to signal that the job has not been completed by the {@link
- *       JobMasterService}
  *   <li>{@link Exception} to signal an unexpected failure
  * </ul>
  */
@@ -134,7 +132,9 @@ public class JobMasterServiceLeadershipRunner implements JobManagerRunner, Leade
                 jobMasterGatewayFuture.completeExceptionally(
                         new FlinkException(
                                 "JobMasterServiceLeadershipRunner is closed. Therefore, the corresponding JobMaster will never acquire the leadership."));
-                resultFuture.completeExceptionally(new JobNotFinishedException(getJobID()));
+                resultFuture.complete(
+                        JobManagerRunnerResult.forSuccess(
+                                createExecutionGraphInfoWithJobStatus(JobStatus.SUSPENDED)));
 
                 final CompletableFuture<Void> processTerminationFuture =
                         jobMasterServiceProcess.closeAsync();
@@ -225,12 +225,10 @@ public class JobMasterServiceLeadershipRunner implements JobManagerRunner, Leade
                             .thenCompose(jobMasterGateway -> jobMasterGateway.requestJob(timeout));
                 } else {
                     return CompletableFuture.completedFuture(
-                            new ExecutionGraphInfo(
-                                    jobMasterServiceProcessFactory.createArchivedExecutionGraph(
-                                            hasCurrentLeaderBeenCancelled
-                                                    ? JobStatus.CANCELLING
-                                                    : JobStatus.INITIALIZING,
-                                            null)));
+                            createExecutionGraphInfoWithJobStatus(
+                                    hasCurrentLeaderBeenCancelled
+                                            ? JobStatus.CANCELLING
+                                            : JobStatus.INITIALIZING));
                 }
             } else {
                 return resultFuture.thenApply(JobManagerRunnerResult::getExecutionGraphInfo);
@@ -281,6 +279,11 @@ public class JobMasterServiceLeadershipRunner implements JobManagerRunner, Leade
         }
     }
 
+    private ExecutionGraphInfo createExecutionGraphInfoWithJobStatus(JobStatus jobStatus) {
+        return new ExecutionGraphInfo(
+                jobMasterServiceProcessFactory.createArchivedExecutionGraph(jobStatus, null));
+    }
+
     private void jobAlreadyDone() {
         resultFuture.completeExceptionally(new JobNotFinishedException(getJobID()));
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobResult.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobResult.java
index 6ba450a6c9a..cd8bd007fb1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobResult.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobResult.java
@@ -220,12 +220,12 @@ public class JobResult implements Serializable {
         final JobStatus jobStatus = accessExecutionGraph.getState();
 
         checkArgument(
-                jobStatus.isGloballyTerminalState(),
+                jobStatus.isTerminalState(),
                 "The job "
                         + accessExecutionGraph.getJobName()
                         + '('
                         + jobId
-                        + ") is not in a globally "
+                        + ") is not in a "
                         + "terminal state. It is in state "
                         + jobStatus
                         + '.');
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
index dd80410cb86..6fbb07ee249 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
@@ -43,7 +43,6 @@ import org.apache.flink.runtime.jobgraph.JobGraphTestUtils;
 import org.apache.flink.runtime.jobmanager.JobGraphWriter;
 import org.apache.flink.runtime.jobmaster.JobManagerRunner;
 import org.apache.flink.runtime.jobmaster.JobManagerSharedServices;
-import org.apache.flink.runtime.jobmaster.JobNotFinishedException;
 import org.apache.flink.runtime.jobmaster.TestingJobManagerRunner;
 import org.apache.flink.runtime.jobmaster.factories.JobManagerJobMetricGroupFactory;
 import org.apache.flink.runtime.messages.Acknowledge;
@@ -275,8 +274,7 @@ public class DispatcherResourceCleanupTest extends TestLogger {
         // job not finished
         final TestingJobManagerRunner testingJobManagerRunner =
                 jobManagerRunnerFactory.takeCreatedJobManagerRunner();
-        testingJobManagerRunner.completeResultFutureExceptionally(
-                new JobNotFinishedException(jobId));
+        suspendJob(testingJobManagerRunner);
 
         assertThat(cleanupJobFuture.get(), equalTo(jobId));
 
@@ -403,8 +401,7 @@ public class DispatcherResourceCleanupTest extends TestLogger {
         runningJobsRegistry.setJobRunning(jobId);
         final TestingJobManagerRunner testingJobManagerRunner =
                 jobManagerRunnerFactory.takeCreatedJobManagerRunner();
-        testingJobManagerRunner.completeResultFutureExceptionally(
-                new JobNotFinishedException(jobId));
+        suspendJob(testingJobManagerRunner);
 
         // wait until termination JobManagerRunner closeAsync has been called.
         // this is necessary to avoid race conditions with completion of the 1st job and the
@@ -474,7 +471,7 @@ public class DispatcherResourceCleanupTest extends TestLogger {
         TestingJobManagerRunnerFactory jobManagerRunnerFactory = startDispatcherAndSubmitJob();
         TestingJobManagerRunner jobManagerRunner =
                 jobManagerRunnerFactory.takeCreatedJobManagerRunner();
-        jobManagerRunner.completeResultFutureExceptionally(new JobNotFinishedException(jobId));
+        suspendJob(jobManagerRunner);
         try {
             cleanupJobHADataFuture.get(10L, TimeUnit.MILLISECONDS);
             fail("We should not delete the HA data for job.");
@@ -485,11 +482,20 @@ public class DispatcherResourceCleanupTest extends TestLogger {
     }
 
     private void finishJob(TestingJobManagerRunner takeCreatedJobManagerRunner) {
+        terminateJobWithState(takeCreatedJobManagerRunner, JobStatus.FINISHED);
+    }
+
+    private void suspendJob(TestingJobManagerRunner takeCreatedJobManagerRunner) {
+        terminateJobWithState(takeCreatedJobManagerRunner, JobStatus.SUSPENDED);
+    }
+
+    private void terminateJobWithState(
+            TestingJobManagerRunner takeCreatedJobManagerRunner, JobStatus state) {
         takeCreatedJobManagerRunner.completeResultFuture(
                 new ExecutionGraphInfo(
                         new ArchivedExecutionGraphBuilder()
                                 .setJobID(jobId)
-                                .setState(JobStatus.FINISHED)
+                                .setState(state)
                                 .build()));
     }
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
index 58f86ca9e98..4cc63e0cdaa 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
@@ -34,10 +34,12 @@ import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
 import org.apache.flink.runtime.client.JobSubmissionException;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
+import org.apache.flink.runtime.execution.librarycache.LibraryCacheManager;
 import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.executiongraph.ErrorInfo;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
+import org.apache.flink.runtime.highavailability.RunningJobsRegistry;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphBuilder;
@@ -50,15 +52,16 @@ import org.apache.flink.runtime.jobmaster.JobManagerSharedServices;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterService;
 import org.apache.flink.runtime.jobmaster.JobMasterServiceLeadershipRunner;
-import org.apache.flink.runtime.jobmaster.JobNotFinishedException;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.jobmaster.TestingJobManagerRunner;
 import org.apache.flink.runtime.jobmaster.TestingJobMasterService;
 import org.apache.flink.runtime.jobmaster.factories.DefaultJobMasterServiceProcessFactory;
 import org.apache.flink.runtime.jobmaster.factories.JobManagerJobMetricGroupFactory;
+import org.apache.flink.runtime.jobmaster.factories.JobMasterServiceProcessFactory;
 import org.apache.flink.runtime.jobmaster.factories.TestingJobMasterServiceFactory;
 import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;
 import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;
+import org.apache.flink.runtime.leaderelection.LeaderElectionService;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
 import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;
 import org.apache.flink.runtime.messages.Acknowledge;
@@ -685,15 +688,51 @@ public class DispatcherTest extends TestLogger {
 
         assertThat(jobResultFuture.isDone(), is(false));
 
-        dispatcher.closeAsync();
+        dispatcher.close();
+
+        final JobResult jobResult = jobResultFuture.get();
+        assertEquals(jobResult.getApplicationStatus(), ApplicationStatus.UNKNOWN);
+    }
 
+    @Test
+    public void testJobStatusIsShownDuringTermination() throws Exception {
+        final JobID blockingId = new JobID();
+        haServices.setJobMasterLeaderElectionService(
+                blockingId, new TestingLeaderElectionService());
+        final JobManagerRunnerWithBlockingTerminationFactory jobManagerRunnerFactory =
+                new JobManagerRunnerWithBlockingTerminationFactory(blockingId);
+        dispatcher =
+                createAndStartDispatcher(heartbeatServices, haServices, jobManagerRunnerFactory);
+        final DispatcherGateway dispatcherGateway =
+                dispatcher.getSelfGateway(DispatcherGateway.class);
+        final JobGraph blockedJobGraph = JobGraphTestUtils.singleNoOpJobGraph();
+        blockedJobGraph.setJobID(blockingId);
+
+        // Submit two jobs, one blocks forever
+        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
+        dispatcherGateway.submitJob(blockedJobGraph, TIMEOUT).get();
+
+        // Trigger termination
+        final CompletableFuture<Void> terminationFuture = dispatcher.closeAsync();
+
+        // ensure job eventually transitions to SUSPENDED state
         try {
-            jobResultFuture.get();
-            fail("Expected the job result to throw an exception.");
-        } catch (ExecutionException ee) {
-            assertThat(
-                    ExceptionUtils.findThrowable(ee, JobNotFinishedException.class).isPresent(),
-                    is(true));
+            CommonTestUtils.waitUntilCondition(
+                    () -> {
+                        JobStatus status =
+                                dispatcherGateway
+                                        .requestExecutionGraphInfo(jobId, TIMEOUT)
+                                        .get()
+                                        .getArchivedExecutionGraph()
+                                        .getState();
+                        return status == JobStatus.SUSPENDED;
+                    },
+                    Deadline.fromNow(TimeUtils.toDuration(TIMEOUT)),
+                    5L);
+        } finally {
+            // Unblock the termination of the second job
+            jobManagerRunnerFactory.unblockTermination();
+            terminationFuture.get();
         }
     }
 
@@ -837,6 +876,85 @@ public class DispatcherTest extends TestLogger {
         }
     }
 
+    private static final class JobManagerRunnerWithBlockingTerminationFactory
+            implements JobManagerRunnerFactory {
+
+        private final JobID jobIdToBlock;
+        private final CompletableFuture<Void> future;
+
+        public JobManagerRunnerWithBlockingTerminationFactory(JobID jobIdToBlock) {
+            this.jobIdToBlock = jobIdToBlock;
+            this.future = new CompletableFuture<>();
+        }
+
+        @Override
+        public JobManagerRunner createJobManagerRunner(
+                JobGraph jobGraph,
+                Configuration configuration,
+                RpcService rpcService,
+                HighAvailabilityServices highAvailabilityServices,
+                HeartbeatServices heartbeatServices,
+                JobManagerSharedServices jobManagerServices,
+                JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory,
+                FatalErrorHandler fatalErrorHandler,
+                long initializationTimestamp)
+                throws Exception {
+            return new BlockingTerminationJobMangerService(
+                    jobIdToBlock,
+                    future,
+                    new DefaultJobMasterServiceProcessFactory(
+                            jobGraph.getJobID(),
+                            jobGraph.getName(),
+                            jobGraph.getCheckpointingSettings(),
+                            initializationTimestamp,
+                            new TestingJobMasterServiceFactory()),
+                    highAvailabilityServices.getJobManagerLeaderElectionService(
+                            jobGraph.getJobID()),
+                    highAvailabilityServices.getRunningJobsRegistry(),
+                    jobManagerServices
+                            .getLibraryCacheManager()
+                            .registerClassLoaderLease(jobGraph.getJobID()),
+                    fatalErrorHandler);
+        }
+
+        public void unblockTermination() {
+            future.complete(null);
+        }
+    }
+
+    private static final class BlockingTerminationJobMangerService
+            extends JobMasterServiceLeadershipRunner {
+
+        private final JobID jobIdToBlock;
+        private final CompletableFuture<Void> future;
+
+        public BlockingTerminationJobMangerService(
+                JobID jobIdToBlock,
+                CompletableFuture<Void> future,
+                JobMasterServiceProcessFactory jobMasterServiceProcessFactory,
+                LeaderElectionService leaderElectionService,
+                RunningJobsRegistry runningJobsRegistry,
+                LibraryCacheManager.ClassLoaderLease classLoaderLease,
+                FatalErrorHandler fatalErrorHandler) {
+            super(
+                    jobMasterServiceProcessFactory,
+                    leaderElectionService,
+                    runningJobsRegistry,
+                    classLoaderLease,
+                    fatalErrorHandler);
+            this.future = future;
+            this.jobIdToBlock = jobIdToBlock;
+        }
+
+        @Override
+        public CompletableFuture<Void> closeAsync() {
+            if (jobIdToBlock.equals(getJobID())) {
+                return future.whenComplete((r, t) -> super.closeAsync());
+            }
+            return super.closeAsync();
+        }
+    }
+
     private static final class BlockingJobManagerRunnerFactory
             extends TestingJobManagerRunnerFactory {
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java
index a7747098cb1..918d4f3cce0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingDispatcher.java
@@ -65,7 +65,7 @@ class TestingDispatcher extends Dispatcher {
     }
 
     void completeJobExecution(ExecutionGraphInfo executionGraphInfo) {
-        runAsync(() -> jobReachedGloballyTerminalState(executionGraphInfo));
+        runAsync(() -> jobReachedTerminalState(executionGraphInfo));
     }
 
     CompletableFuture<Void> getJobTerminationFuture(@Nonnull JobID jobId, @Nonnull Time timeout) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java
index 34d1fab93c6..9829cd98d5d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterServiceLeadershipRunnerTest.java
@@ -69,6 +69,7 @@ import static org.apache.flink.core.testutils.FlinkMatchers.containsCause;
 import static org.apache.flink.core.testutils.FlinkMatchers.containsMessage;
 import static org.apache.flink.core.testutils.FlinkMatchers.willNotComplete;
 import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -658,13 +659,15 @@ public class JobMasterServiceLeadershipRunnerTest extends TestLogger {
                         "Result future should be completed exceptionally."));
     }
 
-    private void assertJobNotFinished(CompletableFuture<JobManagerRunnerResult> resultFuture) {
-        try {
-            resultFuture.get();
-            fail("Expect exception");
-        } catch (Throwable t) {
-            assertThat(t, containsCause(JobNotFinishedException.class));
-        }
+    private void assertJobNotFinished(CompletableFuture<JobManagerRunnerResult> resultFuture)
+            throws ExecutionException, InterruptedException {
+        final JobManagerRunnerResult jobManagerRunnerResult = resultFuture.get();
+        assertEquals(
+                jobManagerRunnerResult
+                        .getExecutionGraphInfo()
+                        .getArchivedExecutionGraph()
+                        .getState(),
+                JobStatus.SUSPENDED);
     }
 
     public JobMasterServiceLeadershipRunnerBuilder newJobMasterServiceLeadershipRunnerBuilder() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java
index e7440c0b016..863b6b5c832 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java
@@ -22,6 +22,7 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.core.testutils.OneShotLatch;
+import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.messages.webmonitor.JobDetails;
 import org.apache.flink.runtime.scheduler.ExecutionGraphInfo;
@@ -57,9 +58,15 @@ public class TestingJobManagerRunner implements JobManagerRunner {
         this.resultFuture = resultFuture;
         this.terminationFuture = new CompletableFuture<>();
 
+        final ExecutionGraphInfo suspendedExecutionGraphInfo =
+                new ExecutionGraphInfo(
+                        ArchivedExecutionGraph.createFromInitializingJob(
+                                jobId, "TestJob", JobStatus.SUSPENDED, null, null, 0L),
+                        null);
         terminationFuture.whenComplete(
                 (ignored, ignoredThrowable) ->
-                        resultFuture.completeExceptionally(new JobNotFinishedException(jobId)));
+                        resultFuture.complete(
+                                JobManagerRunnerResult.forSuccess(suspendedExecutionGraphInfo)));
     }
 
     @Override
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
index ae0dcb74e9b..0abbb117ff1 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
@@ -21,13 +21,13 @@ package org.apache.flink.runtime.leaderelection;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobSubmissionResult;
 import org.apache.flink.api.common.time.Deadline;
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.execution.Environment;
 import org.apache.flink.runtime.highavailability.nonha.embedded.EmbeddedHaServicesWithLeadershipControl;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphTestUtils;
 import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
-import org.apache.flink.runtime.jobmaster.JobNotFinishedException;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.jobmaster.utils.JobResultUtils;
 import org.apache.flink.runtime.minicluster.TestingMiniCluster;
@@ -35,7 +35,6 @@ import org.apache.flink.runtime.minicluster.TestingMiniClusterConfiguration;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.util.LeaderRetrievalUtils;
-import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.AfterClass;
@@ -45,12 +44,11 @@ import org.junit.Test;
 
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
 
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.notNullValue;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
-import static org.junit.Assert.fail;
 
 /** Tests which verify the cluster behaviour in case of leader changes. */
 public class LeaderChangeClusterComponentsTest extends TestLogger {
@@ -109,14 +107,8 @@ public class LeaderChangeClusterComponentsTest extends TestLogger {
 
         highAvailabilityServices.revokeDispatcherLeadership().get();
 
-        try {
-            jobResultFuture.get();
-            fail("Expected JobNotFinishedException");
-        } catch (ExecutionException ee) {
-            assertThat(
-                    ExceptionUtils.findThrowable(ee, JobNotFinishedException.class).isPresent(),
-                    is(true));
-        }
+        JobResult jobResult = jobResultFuture.get();
+        assertEquals(jobResult.getApplicationStatus(), ApplicationStatus.UNKNOWN);
 
         highAvailabilityServices.grantDispatcherLeadership();
 
@@ -129,7 +121,7 @@ public class LeaderChangeClusterComponentsTest extends TestLogger {
 
         final CompletableFuture<JobResult> jobResultFuture2 = miniCluster.requestJobResult(jobId);
 
-        JobResult jobResult = jobResultFuture2.get();
+        jobResult = jobResultFuture2.get();
 
         JobResultUtils.assertSuccess(jobResult);
     }
