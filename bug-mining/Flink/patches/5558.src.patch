diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java
index 462d141936c..b50399c2d4c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java
@@ -193,7 +193,7 @@ public class SlotPoolImpl implements SlotPool, SlotPoolService {
     }
 
     @VisibleForTesting
-    DualKeyLinkedMap<SlotRequestId, AllocationID, PendingRequest> getPendingRequests() {
+    public DualKeyLinkedMap<SlotRequestId, AllocationID, PendingRequest> getPendingRequests() {
         return pendingRequests;
     }
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
index 475811be590..93d966f456c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
@@ -48,7 +48,9 @@ import org.apache.flink.runtime.scheduler.strategy.SchedulingStrategy;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingStrategyFactory;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
+import org.apache.flink.runtime.topology.Vertex;
 import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.IterableUtils;
 import org.apache.flink.util.concurrent.FutureUtils;
 import org.apache.flink.util.concurrent.ScheduledExecutor;
 
@@ -169,6 +171,13 @@ public class DefaultScheduler extends SchedulerBase implements SchedulerOperatio
         return executionFailureHandler.getNumberOfRestarts();
     }
 
+    @Override
+    protected void cancelAllPendingSlotRequestsInternal() {
+        IterableUtils.toStream(getSchedulingTopology().getVertices())
+                .map(Vertex::getId)
+                .forEach(executionSlotAllocator::cancel);
+    }
+
     @Override
     protected void startSchedulingInternal() {
         log.info(
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
index de61b98ff09..921e79fc019 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
@@ -498,6 +498,7 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
 
     protected void failJob(Throwable cause, long timestamp) {
         incrementVersionsOfAllVertices();
+        cancelAllPendingSlotRequestsInternal();
         executionGraph.failJob(cause, timestamp);
         getJobTerminationFuture().thenRun(() -> archiveGlobalFailure(cause));
     }
@@ -557,6 +558,8 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
                         .collect(Collectors.toSet()));
     }
 
+    protected abstract void cancelAllPendingSlotRequestsInternal();
+
     protected void transitionExecutionGraphState(
             final JobStatus current, final JobStatus newState) {
         executionGraph.transitionState(current, newState);
@@ -604,6 +607,7 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
         final FlinkException cause = new FlinkException("Scheduler is being stopped.");
 
         incrementVersionsOfAllVertices();
+        cancelAllPendingSlotRequestsInternal();
         executionGraph.suspend(cause);
         operatorCoordinatorHandler.disposeAllOperatorCoordinators();
 
@@ -615,6 +619,7 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
         mainThreadExecutor.assertRunningInMainThread();
 
         incrementVersionsOfAllVertices();
+        cancelAllPendingSlotRequestsInternal();
         executionGraph.cancel();
     }
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java
index a13f44cb074..78b71247502 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphRestartTest.java
@@ -101,6 +101,62 @@ public class ExecutionGraphRestartTest extends TestLogger {
         return new TestingSlotPoolImpl(TEST_JOB_ID);
     }
 
+    @Test
+    public void testCancelAllPendingRequestWhileCanceling() throws Exception {
+        try (SlotPoolImpl slotPool = createSlotPoolImpl()) {
+
+            TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();
+            final int NUM_TASKS_EXCEED_SLOT_POOL = 50;
+            // create a graph with task count larger than slot pool
+            JobVertex sender =
+                    ExecutionGraphTestUtils.createJobVertex(
+                            "Task", NUM_TASKS + NUM_TASKS_EXCEED_SLOT_POOL, NoOpInvokable.class);
+            JobGraph graph = JobGraphTestUtils.streamingJobGraph(sender);
+            SchedulerBase scheduler =
+                    SchedulerTestingUtils.newSchedulerBuilder(graph, mainThreadExecutor)
+                            .setExecutionSlotAllocatorFactory(
+                                    createExecutionSlotAllocatorFactory(
+                                            slotPool, taskManagerLocation))
+                            .build();
+            ExecutionGraph executionGraph = scheduler.getExecutionGraph();
+
+            startScheduling(scheduler);
+            assertEquals(NUM_TASKS_EXCEED_SLOT_POOL, slotPool.getPendingRequests().size());
+
+            scheduler.cancel();
+            assertEquals(JobStatus.CANCELLING, executionGraph.getState());
+            assertEquals(0, slotPool.getPendingRequests().size());
+        }
+    }
+
+    @Test
+    public void testCancelAllPendingRequestWhileFailing() throws Exception {
+        try (SlotPoolImpl slotPool = createSlotPoolImpl()) {
+
+            TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();
+            final int NUM_TASKS_EXCEED_SLOT_POOL = 50;
+            // create a graph with task count larger than slot pool
+            JobVertex sender =
+                    ExecutionGraphTestUtils.createJobVertex(
+                            "Task", NUM_TASKS + NUM_TASKS_EXCEED_SLOT_POOL, NoOpInvokable.class);
+            JobGraph graph = JobGraphTestUtils.streamingJobGraph(sender);
+            SchedulerBase scheduler =
+                    SchedulerTestingUtils.newSchedulerBuilder(graph, mainThreadExecutor)
+                            .setExecutionSlotAllocatorFactory(
+                                    createExecutionSlotAllocatorFactory(
+                                            slotPool, taskManagerLocation))
+                            .build();
+            ExecutionGraph executionGraph = scheduler.getExecutionGraph();
+
+            startScheduling(scheduler);
+            assertEquals(NUM_TASKS_EXCEED_SLOT_POOL, slotPool.getPendingRequests().size());
+
+            scheduler.handleGlobalFailure(new Exception("test"));
+            assertEquals(JobStatus.FAILING, executionGraph.getState());
+            assertEquals(0, slotPool.getPendingRequests().size());
+        }
+    }
+
     @Test
     public void testCancelWhileRestarting() throws Exception {
         // We want to manually control the restart and delay
