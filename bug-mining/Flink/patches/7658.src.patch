diff --git a/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/WebFrontendITCase.java b/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/WebFrontendITCase.java
index 7da290ead1d..0f70ba2f5a2 100644
--- a/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/WebFrontendITCase.java
+++ b/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/WebFrontendITCase.java
@@ -32,17 +32,25 @@ import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphBuilder;
 import org.apache.flink.runtime.jobgraph.JobGraphTestUtils;
 import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
+import org.apache.flink.runtime.operators.coordination.CoordinationRequest;
+import org.apache.flink.runtime.rest.messages.job.coordination.ClientCoordinationRequestBody;
 import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
 import org.apache.flink.runtime.webmonitor.testutils.HttpTestClient;
+import org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator;
+import org.apache.flink.streaming.api.operators.collect.CollectCoordinationRequest;
+import org.apache.flink.streaming.api.operators.collect.CollectSinkOperatorCoordinator;
 import org.apache.flink.test.junit5.InjectClusterClient;
 import org.apache.flink.test.junit5.InjectClusterRESTAddress;
 import org.apache.flink.test.junit5.MiniClusterExtension;
+import org.apache.flink.util.SerializedValue;
 import org.apache.flink.util.jackson.JacksonMapperFactory;
 
 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
+import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpMethod;
 import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpResponseStatus;
 
 import org.apache.commons.io.FileUtils;
@@ -55,9 +63,11 @@ import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.URI;
 import java.net.URL;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.time.Duration;
@@ -407,6 +417,63 @@ class WebFrontendITCase {
         BlockingInvokable.reset();
     }
 
+    @Test
+    void testClientCoordinationHandler(
+            @InjectClusterClient ClusterClient<?> clusterClient,
+            @InjectClusterRESTAddress URI restAddress)
+            throws Exception {
+        // this only works if there is no active job at this point
+        assertThat(getRunningJobs(clusterClient).isEmpty());
+
+        // Create a task
+        final JobVertex sender = new JobVertex("Sender");
+        sender.setParallelism(2);
+        sender.setInvokableClass(BlockingInvokable.class);
+
+        String operatorUid = "opId";
+        OperatorID opId = StreamingJobGraphGenerator.generateOperatorID(operatorUid);
+        sender.addOperatorCoordinator(
+                new SerializedValue<>(new CollectSinkOperatorCoordinator.Provider(opId, 10_000)));
+
+        final JobGraph jobGraph = JobGraphTestUtils.streamingJobGraph(sender);
+
+        clusterClient.submitJob(jobGraph).get();
+
+        // wait for job to show up
+        while (getRunningJobs(clusterClient).isEmpty()) {
+            Thread.sleep(10);
+        }
+
+        // wait for tasks to be properly running
+        BlockingInvokable.latch.await();
+
+        SerializedValue<CoordinationRequest> serializedRequest =
+                new SerializedValue<>(new CollectCoordinationRequest("version", 0L));
+        ClientCoordinationRequestBody requestBody =
+                new ClientCoordinationRequestBody(serializedRequest);
+        String json =
+                postAndGetHttpResponse(
+                        "http://localhost:"
+                                + restAddress.getPort()
+                                + "/jobs/"
+                                + jobGraph.getJobID()
+                                + "/coordinators/"
+                                + operatorUid,
+                        OBJECT_MAPPER.writeValueAsString(requestBody));
+
+        JsonNode parsed = OBJECT_MAPPER.readTree(json);
+        assertThat(parsed.get("serializedCoordinationResult")).isNotNull();
+
+        clusterClient.cancel(jobGraph.getJobID()).get();
+
+        // ensure cancellation is finished
+        while (!getRunningJobs(clusterClient).isEmpty()) {
+            Thread.sleep(20);
+        }
+
+        BlockingInvokable.reset();
+    }
+
     @Test
     void testCancelYarn(
             @InjectClusterClient ClusterClient<?> clusterClient,
@@ -503,6 +570,52 @@ class WebFrontendITCase {
                 "Could not get HTTP response in time since the service is still unavailable.");
     }
 
+    private static String postAndGetHttpResponse(String url, String jsonData) throws Exception {
+        final URL u = new URL(url);
+        LOG.info("Accessing URL " + url + " as URL: " + u);
+
+        final Deadline deadline = Deadline.fromNow(Duration.ofSeconds(10L));
+
+        while (deadline.hasTimeLeft()) {
+            HttpURLConnection connection = (HttpURLConnection) u.openConnection();
+            connection.setConnectTimeout(100000);
+            connection.setRequestMethod(HttpMethod.POST.name());
+            connection.setRequestProperty("Content-Type", "application/json");
+            connection.setDoOutput(true);
+
+            try (OutputStream os = connection.getOutputStream()) {
+                byte[] input = jsonData.getBytes(StandardCharsets.UTF_8);
+                os.write(input, 0, input.length);
+            }
+
+            if (Objects.equals(
+                    HttpResponseStatus.SERVICE_UNAVAILABLE,
+                    HttpResponseStatus.valueOf(connection.getResponseCode()))) {
+                // service not available --> Sleep and retry
+                LOG.debug("Web service currently not available. Retrying the request in a bit.");
+                Thread.sleep(100L);
+            } else {
+                InputStream is;
+
+                if (connection.getResponseCode() >= 400) {
+                    // error!
+                    LOG.warn(
+                            "HTTP Response code when connecting to {} was {}",
+                            url,
+                            connection.getResponseCode());
+                    is = connection.getErrorStream();
+                } else {
+                    is = connection.getInputStream();
+                }
+
+                return IOUtils.toString(is, ConfigConstants.DEFAULT_CHARSET);
+            }
+        }
+
+        throw new TimeoutException(
+                "Could not get HTTP response in time since the service is still unavailable.");
+    }
+
     /** Test invokable that allows waiting for all subtasks to be running. */
     public static class BlockingInvokable extends AbstractInvokable {
 
diff --git a/flink-runtime-web/src/test/resources/rest_api_v1.snapshot b/flink-runtime-web/src/test/resources/rest_api_v1.snapshot
index e3b1dd64481..2c3601bf15b 100644
--- a/flink-runtime-web/src/test/resources/rest_api_v1.snapshot
+++ b/flink-runtime-web/src/test/resources/rest_api_v1.snapshot
@@ -1884,7 +1884,7 @@
       "type" : "any"
     }
   }, {
-    "url" : "/jobs/:jobid/coordinators/:operatorid",
+    "url" : "/jobs/:jobid/coordinators/:operatorUid",
     "method" : "POST",
     "status-code" : "200 OK",
     "file-upload" : false,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeaders.java b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeaders.java
index e55ca8998cb..521a09c5abf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeaders.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeaders.java
@@ -21,6 +21,8 @@ package org.apache.flink.runtime.rest.messages.job.coordination;
 import org.apache.flink.annotation.docs.Documentation;
 import org.apache.flink.runtime.rest.HttpMethodWrapper;
 import org.apache.flink.runtime.rest.handler.job.coordination.ClientCoordinationHandler;
+import org.apache.flink.runtime.rest.messages.JobIDPathParameter;
+import org.apache.flink.runtime.rest.messages.OperatorUidPathParameter;
 import org.apache.flink.runtime.rest.messages.RuntimeMessageHeaders;
 
 import org.apache.flink.shaded.netty4.io.netty.handler.codec.http.HttpResponseStatus;
@@ -34,7 +36,8 @@ public class ClientCoordinationHeaders
                 ClientCoordinationResponseBody,
                 ClientCoordinationMessageParameters> {
 
-    public static final String URL = "/jobs/:jobid/coordinators/:operatorid";
+    public static final String URL =
+            "/jobs/:" + JobIDPathParameter.KEY + "/coordinators/:" + OperatorUidPathParameter.KEY;
 
     private static final ClientCoordinationHeaders INSTANCE = new ClientCoordinationHeaders();
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeadersTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeadersTest.java
new file mode 100644
index 00000000000..7047e21d537
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/messages/job/coordination/ClientCoordinationHeadersTest.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.rest.messages.job.coordination;
+
+import org.apache.flink.runtime.rest.messages.JobIDPathParameter;
+import org.apache.flink.runtime.rest.messages.OperatorUidPathParameter;
+
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Tests for {@link ClientCoordinationHeaders}. */
+class ClientCoordinationHeadersTest {
+
+    private final ClientCoordinationHeaders clientCoordinationHeaders =
+            ClientCoordinationHeaders.getInstance();
+
+    @Test
+    void testUrl() {
+        assertThat(clientCoordinationHeaders.getTargetRestEndpointURL())
+                .isEqualTo(
+                        "/jobs/:"
+                                + JobIDPathParameter.KEY
+                                + "/coordinators/:"
+                                + OperatorUidPathParameter.KEY);
+    }
+
+    @Test
+    void testMessageParameters() {
+        assertThat(clientCoordinationHeaders.getUnresolvedMessageParameters())
+                .isInstanceOf(ClientCoordinationMessageParameters.class);
+    }
+}
