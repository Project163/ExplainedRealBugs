diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
index e50cad77417..83714e3fa63 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
@@ -34,12 +34,11 @@ import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.executiongraph.ErrorInfo;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
-import org.apache.flink.runtime.highavailability.RunningJobsRegistry;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobStatus;
 import org.apache.flink.runtime.jobgraph.JobVertex;
-import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.jobmanager.StandaloneJobGraphStore;
 import org.apache.flink.runtime.jobmaster.JobManagerRunner;
 import org.apache.flink.runtime.jobmaster.JobManagerSharedServices;
 import org.apache.flink.runtime.jobmaster.JobNotFinishedException;
@@ -91,7 +90,6 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.ArrayBlockingQueue;
@@ -101,15 +99,12 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.hamcrest.Matchers.contains;
 import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -135,14 +130,8 @@ public class DispatcherTest extends TestLogger {
 
 	private TestingFatalErrorHandler fatalErrorHandler;
 
-	private TestingJobGraphStore jobGraphStore;
-
-	private TestingLeaderElectionService dispatcherLeaderElectionService;
-
 	private TestingLeaderElectionService jobMasterLeaderElectionService;
 
-	private RunningJobsRegistry runningJobsRegistry;
-
 	private CountDownLatch createdJobManagerRunnerLatch;
 
 	private Configuration configuration;
@@ -179,18 +168,14 @@ public class DispatcherTest extends TestLogger {
 
 		fatalErrorHandler = new TestingFatalErrorHandler();
 		heartbeatServices = new HeartbeatServices(1000L, 10000L);
-		jobGraphStore = TestingJobGraphStore.newBuilder().build();
 
-		dispatcherLeaderElectionService = new TestingLeaderElectionService();
 		jobMasterLeaderElectionService = new TestingLeaderElectionService();
 
 		haServices = new TestingHighAvailabilityServices();
-		haServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService);
-		haServices.setJobGraphStore(jobGraphStore);
+		haServices.setJobGraphStore(new StandaloneJobGraphStore());
 		haServices.setJobMasterLeaderElectionService(TEST_JOB_ID, jobMasterLeaderElectionService);
 		haServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());
 		haServices.setResourceManagerLeaderRetriever(new SettableLeaderRetrievalService());
-		runningJobsRegistry = haServices.getRunningJobsRegistry();
 
 		configuration = new Configuration();
 
@@ -203,31 +188,69 @@ public class DispatcherTest extends TestLogger {
 	}
 
 	@Nonnull
-	private TestingDispatcher createAndStartDispatcher(HeartbeatServices heartbeatServices, TestingHighAvailabilityServices haServices, JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {
-		final TestingDispatcher dispatcher = createDispatcher(heartbeatServices, haServices, jobManagerRunnerFactory);
+	private TestingDispatcher createAndStartDispatcher(
+			HeartbeatServices heartbeatServices,
+			TestingHighAvailabilityServices haServices,
+			JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {
+		final TestingDispatcher dispatcher = new TestingDispatcherBuilder()
+			.setHaServices(haServices)
+			.setHeartbeatServices(heartbeatServices)
+			.setJobManagerRunnerFactory(jobManagerRunnerFactory)
+			.build();
 		dispatcher.start();
 
 		return dispatcher;
 	}
 
-	@Nonnull
-	private TestingDispatcher createDispatcher(HeartbeatServices heartbeatServices, TestingHighAvailabilityServices haServices, JobManagerRunnerFactory jobManagerRunnerFactory) throws Exception {
-		TestingResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway();
-		return new TestingDispatcher(
-			rpcService,
-			Dispatcher.DISPATCHER_NAME + '_' + name.getMethodName(),
-			DispatcherId.generate(),
-			Collections.emptyList(),
-			configuration,
-			haServices,
-			() -> CompletableFuture.completedFuture(resourceManagerGateway),
-			blobServer,
-			heartbeatServices,
-			UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
-			null,
-			new MemoryArchivedExecutionGraphStore(),
-			jobManagerRunnerFactory,
-			fatalErrorHandler);
+	private class TestingDispatcherBuilder {
+
+		private Collection<JobGraph> initialJobGraphs = Collections.emptyList();
+
+		private HeartbeatServices heartbeatServices = DispatcherTest.this.heartbeatServices;
+
+		private HighAvailabilityServices haServices = DispatcherTest.this.haServices;
+
+		private JobManagerRunnerFactory jobManagerRunnerFactory = DefaultJobManagerRunnerFactory.INSTANCE;
+
+		TestingDispatcherBuilder setHeartbeatServices(HeartbeatServices heartbeatServices) {
+			this.heartbeatServices = heartbeatServices;
+			return this;
+		}
+
+		TestingDispatcherBuilder setHaServices(HighAvailabilityServices haServices) {
+			this.haServices = haServices;
+			return this;
+		}
+
+		TestingDispatcherBuilder setInitialJobGraphs(Collection<JobGraph> initialJobGraphs) {
+			this.initialJobGraphs = initialJobGraphs;
+			return this;
+		}
+
+		TestingDispatcherBuilder setJobManagerRunnerFactory(JobManagerRunnerFactory jobManagerRunnerFactory) {
+			this.jobManagerRunnerFactory = jobManagerRunnerFactory;
+			return this;
+		}
+
+		TestingDispatcher build() throws Exception {
+			TestingResourceManagerGateway resourceManagerGateway = new TestingResourceManagerGateway();
+
+			return new TestingDispatcher(
+				rpcService,
+				Dispatcher.DISPATCHER_NAME + '_' + name.getMethodName(),
+				DispatcherId.generate(),
+				initialJobGraphs,
+				configuration,
+				haServices,
+				() -> CompletableFuture.completedFuture(resourceManagerGateway),
+				blobServer,
+				heartbeatServices,
+				UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
+				null,
+				new MemoryArchivedExecutionGraphStore(),
+				jobManagerRunnerFactory,
+				fatalErrorHandler);
+		}
 	}
 
 	@After
@@ -257,11 +280,6 @@ public class DispatcherTest extends TestLogger {
 	public void testJobSubmission() throws Exception {
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
 
-		CompletableFuture<UUID> leaderFuture = dispatcherLeaderElectionService.isLeader(UUID.randomUUID());
-
-		// wait for the leader to be elected
-		leaderFuture.get();
-
 		DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		CompletableFuture<Acknowledge> acknowledgeFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT);
@@ -270,7 +288,7 @@ public class DispatcherTest extends TestLogger {
 
 		assertTrue(
 			"jobManagerRunner was not started",
-			dispatcherLeaderElectionService.getStartFuture().isDone());
+			jobMasterLeaderElectionService.getStartFuture().isDone());
 	}
 
 	/**
@@ -281,11 +299,6 @@ public class DispatcherTest extends TestLogger {
 	public void testJobSubmissionWithPartialResourceConfigured() throws Exception {
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
 
-		CompletableFuture<UUID> leaderFuture = dispatcherLeaderElectionService.isLeader(UUID.randomUUID());
-
-		// wait for the leader to be elected
-		leaderFuture.get();
-
 		DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		ResourceSpec resourceSpec = ResourceSpec.newBuilder().setCpuCores(2).build();
@@ -311,29 +324,6 @@ public class DispatcherTest extends TestLogger {
 		}
 	}
 
-	/**
-	 * Tests that the dispatcher takes part in the leader election.
-	 */
-	@Test
-	public void testLeaderElection() throws Exception {
-		CompletableFuture<Void> jobIdsFuture = new CompletableFuture<>();
-		final JobGraphStore jobGraphStore = TestingJobGraphStore.newBuilder()
-			.setJobIdsFunction(
-				(Collection<JobID> jobIds) -> {
-					jobIdsFuture.complete(null);
-					return jobIds;
-				})
-			.build();
-
-		haServices.setJobGraphStore(jobGraphStore);
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		electDispatcher();
-
-		// wait that we asked the JobGraphStore for the stored jobs
-		jobIdsFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
-	}
-
 	/**
 	 * Test that {@link JobResult} is cached when the job finishes.
 	 */
@@ -341,8 +331,6 @@ public class DispatcherTest extends TestLogger {
 	public void testCacheJobExecutionResult() throws Exception {
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		final JobID failedJobId = new JobID();
@@ -368,8 +356,6 @@ public class DispatcherTest extends TestLogger {
 	public void testThrowExceptionIfJobExecutionResultNotFound() throws Exception {
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 		try {
 			dispatcherGateway.requestJob(new JobID(), TIMEOUT).get();
@@ -379,44 +365,6 @@ public class DispatcherTest extends TestLogger {
 		}
 	}
 
-	/**
-	 * Tests that a reelected Dispatcher can recover jobs.
-	 */
-	@Test
-	public void testJobRecovery() throws Exception {
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
-
-		// elect the initial dispatcher as the leader
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		// submit the job to the current leader
-		dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
-
-		// check that the job has been persisted
-		assertThat(jobGraphStore.getJobIds(), contains(jobGraph.getJobID()));
-
-		jobMasterLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		assertThat(runningJobsRegistry.getJobSchedulingStatus(jobGraph.getJobID()), is(RunningJobsRegistry.JobSchedulingStatus.RUNNING));
-
-		// revoke the leadership which will stop all currently running jobs
-		dispatcherLeaderElectionService.notLeader();
-
-		// re-grant the leadership, this should trigger the job recovery
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		// wait until we have recovered the job
-		createdJobManagerRunnerLatch.await();
-
-		// check whether the job has been recovered
-		final Collection<JobID> jobIds = dispatcherGateway.listJobs(TIMEOUT).get();
-
-		assertThat(jobIds, hasSize(1));
-		assertThat(jobIds, contains(jobGraph.getJobID()));
-	}
-
 	/**
 	 * Tests that we can dispose a savepoint.
 	 */
@@ -429,8 +377,6 @@ public class DispatcherTest extends TestLogger {
 
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		assertThat(Files.exists(savepointPath), is(true));
 
 		dispatcherGateway.disposeSavepoint(externalPointer.toString(), TIMEOUT).get();
@@ -466,8 +412,6 @@ public class DispatcherTest extends TestLogger {
 
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
 
 		final CompletableFuture<JobStatus> jobStatusFuture = dispatcherGateway.requestJobStatus(jobGraph.getJobID(), TIMEOUT);
@@ -487,80 +431,20 @@ public class DispatcherTest extends TestLogger {
 	}
 
 	/**
-	 * Tests that the {@link Dispatcher} terminates if it cannot recover jobs ids from
-	 * the {@link JobGraphStore}. See FLINK-8943.
-	 */
-	@Test
-	public void testFatalErrorAfterJobIdRecoveryFailure() throws Exception {
-		final FlinkException testException = new FlinkException("Test exception");
-		final JobGraphStore jobGraphStore = TestingJobGraphStore.newBuilder()
-			.setJobIdsFunction(
-				(Collection<JobID> jobIds) -> {
-					throw testException;
-				})
-			.build();
-
-		haServices.setJobGraphStore(jobGraphStore);
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		electDispatcher();
-
-		// we expect that a fatal error occurred
-		final Throwable error = fatalErrorHandler.getErrorFuture().get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
-
-		assertThat(ExceptionUtils.findThrowableWithMessage(error, testException.getMessage()).isPresent(), is(true));
-
-		fatalErrorHandler.clearError();
-	}
-
-	/**
-	 * Tests that the {@link Dispatcher} terminates if it cannot recover jobs from
-	 * the {@link JobGraphStore}. See FLINK-8943.
-	 */
-	@Test
-	public void testFatalErrorAfterJobRecoveryFailure() throws Exception {
-		final FlinkException testException = new FlinkException("Test exception");
-		final TestingJobGraphStore jobGraphStore = TestingJobGraphStore.newBuilder()
-			.setRecoverJobGraphFunction(
-				(JobID jobId, Map<JobID, JobGraph> jobGraphs) -> {
-					throw testException;
-				})
-			.build();
-
-		haServices.setJobGraphStore(jobGraphStore);
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		dispatcher.waitUntilStarted();
-
-		jobGraphStore.putJobGraph(jobGraph);
-
-		electDispatcher();
-
-		// we expect that a fatal error occurred
-		final Throwable error = fatalErrorHandler.getErrorFuture().get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
-
-		assertThat(ExceptionUtils.findThrowableWithMessage(error, testException.getMessage()).isPresent(), is(true));
-
-		fatalErrorHandler.clearError();
-	}
-
-	/**
-	 * Tests that the {@link Dispatcher} fails fatally if the job submission of a recovered job fails.
+	 * Tests that the {@link Dispatcher} fails fatally if the recoverd jobs cannot be started.
 	 * See FLINK-9097.
 	 */
 	@Test
-	public void testJobSubmissionErrorAfterJobRecovery() throws Exception {
+	public void testFatalErrorIfRecoveredJobsCannotBeStarted() throws Exception {
 		final FlinkException testException = new FlinkException("Test exception");
 
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		dispatcher.waitUntilStarted();
-
 		final JobGraph failingJobGraph = createFailingJobGraph(testException);
 
-		jobGraphStore.putJobGraph(failingJobGraph);
+		dispatcher = new TestingDispatcherBuilder()
+			.setInitialJobGraphs(Collections.singleton(failingJobGraph))
+			.build();
 
-		electDispatcher();
+		dispatcher.start();
 
 		final Throwable error = fatalErrorHandler.getErrorFuture().get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
 
@@ -583,8 +467,6 @@ public class DispatcherTest extends TestLogger {
 			haServices,
 			new BlockingJobManagerRunnerFactory(jobManagerRunnerCreationLatch::await));
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT);
@@ -622,8 +504,6 @@ public class DispatcherTest extends TestLogger {
 				}
 			}));
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT);
@@ -649,14 +529,11 @@ public class DispatcherTest extends TestLogger {
 	@Test
 	public void testPersistedJobGraphWhenDispatcherIsShutDown() throws Exception {
 		final TestingJobGraphStore submittedJobGraphStore = TestingJobGraphStore.newBuilder().build();
+		submittedJobGraphStore.start(null);
 		haServices.setJobGraphStore(submittedJobGraphStore);
 
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, DefaultJobManagerRunnerFactory.INSTANCE);
 
-		// grant leadership and submit a single job
-		final DispatcherId expectedDispatcherId = DispatcherId.generate();
-		dispatcherLeaderElectionService.isLeader(expectedDispatcherId.toUUID()).get();
-
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 		final CompletableFuture<Acknowledge> submissionFuture = dispatcherGateway.submitJob(jobGraph, TIMEOUT);
 		submissionFuture.get();
@@ -668,14 +545,12 @@ public class DispatcherTest extends TestLogger {
 	}
 
 	/**
-	 * Tests that a submitted job is suspended if the Dispatcher loses leadership.
+	 * Tests that a submitted job is suspended if the Dispatcher is terminated.
 	 */
 	@Test
-	public void testJobSuspensionWhenDispatcherLosesLeadership() throws Exception {
+	public void testJobSuspensionWhenDispatcherIsTerminated() throws Exception {
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
 
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
 		DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
@@ -684,7 +559,7 @@ public class DispatcherTest extends TestLogger {
 
 		assertThat(jobResultFuture.isDone(), is(false));
 
-		dispatcherLeaderElectionService.notLeader();
+		dispatcher.closeAsync();
 
 		try {
 			jobResultFuture.get();
@@ -697,7 +572,6 @@ public class DispatcherTest extends TestLogger {
 	@Test
 	public void testShutDownClusterShouldCompleteShutDownFuture() throws Exception {
 		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, DefaultJobManagerRunnerFactory.INSTANCE);
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
 		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
 
 		dispatcherGateway.shutDownCluster().get();
@@ -705,7 +579,7 @@ public class DispatcherTest extends TestLogger {
 		dispatcher.getShutDownFuture().get();
 	}
 
-	private final class BlockingJobManagerRunnerFactory extends TestingJobManagerRunnerFactory {
+	private static final class BlockingJobManagerRunnerFactory extends TestingJobManagerRunnerFactory {
 
 		@Nonnull
 		private final ThrowingRunnable<Exception> jobManagerRunnerCreationLatch;
@@ -722,14 +596,6 @@ public class DispatcherTest extends TestLogger {
 		}
 	}
 
-	private void electDispatcher() {
-		UUID expectedLeaderSessionId = UUID.randomUUID();
-
-		assertNull(dispatcherLeaderElectionService.getConfirmationFuture());
-
-		dispatcherLeaderElectionService.isLeader(expectedLeaderSessionId);
-	}
-
 	private JobGraph createFailingJobGraph(Exception failureCause) {
 		final FailingJobVertex jobVertex = new FailingJobVertex("Failing JobVertex", failureCause);
 		jobVertex.setInvokableClass(NoOpInvokable.class);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
index c1403b642ab..e84a1f7f5dd 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
@@ -43,6 +43,7 @@ import org.junit.Test;
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutorService;
@@ -334,6 +335,45 @@ public class DispatcherLeaderProcessImplTest extends TestLogger {
 		}
 	}
 
+	@Test
+	public void recoverJobs_withRecoveryFailure_failsFatally() throws Exception {
+		final FlinkException testException = new FlinkException("Test exception");
+		jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setRecoverJobGraphFunction(
+				(JobID jobId, Map<JobID, JobGraph> jobGraphs) -> {
+					throw testException;
+				})
+			.setInitialJobGraphs(Collections.singleton(JOB_GRAPH))
+			.build();
+
+		runJobRecoveryFailureTest(testException);
+	}
+
+	@Test
+	public void recoverJobs_withJobIdRecoveryFailure_failsFatally() throws Exception {
+		final FlinkException testException = new FlinkException("Test exception");
+		jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setJobIdsFunction(
+				ignored -> {
+					throw testException;
+				})
+			.build();
+
+		runJobRecoveryFailureTest(testException);
+	}
+
+	private void runJobRecoveryFailureTest(FlinkException testException) throws Exception {
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+
+			// we expect that a fatal error occurred
+			final Throwable error = fatalErrorHandler.getErrorFuture().get();
+			Assert.assertThat(ExceptionUtils.findThrowableWithMessage(error, testException.getMessage()).isPresent(), is(true));
+
+			fatalErrorHandler.clearError();
+		}
+	}
+
 	@Test
 	@Ignore
 	public void onAddedJobGraph_falsePositive_willBeIgnored() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGITCase.java
new file mode 100644
index 00000000000..5f73e6c6436
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGITCase.java
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.runtime.dispatcher.MemoryArchivedExecutionGraphStore;
+import org.apache.flink.runtime.dispatcher.PartialDispatcherServices;
+import org.apache.flink.runtime.dispatcher.VoidHistoryServerArchivist;
+import org.apache.flink.runtime.heartbeat.TestingHeartbeatServices;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServicesBuilder;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
+import org.apache.flink.runtime.minicluster.SessionDispatcherWithUUIDFactory;
+import org.apache.flink.runtime.rpc.TestingRpcServiceResource;
+import org.apache.flink.runtime.testingUtils.TestingUtils;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;
+import org.apache.flink.runtime.testutils.TestingJobGraphStore;
+import org.apache.flink.runtime.util.BlobServerResource;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import java.util.Collection;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.hasSize;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Integration tests for the {@link DispatcherRunnerImplNG}.
+ */
+public class DispatcherRunnerImplNGITCase extends TestLogger {
+
+	private static final Time TIMEOUT = Time.seconds(10L);
+
+	private static final JobID TEST_JOB_ID = new JobID();
+
+	@ClassRule
+	public static TestingRpcServiceResource rpcServiceResource = new TestingRpcServiceResource();
+
+	@ClassRule
+	public static BlobServerResource blobServerResource = new BlobServerResource();
+
+	private JobGraph jobGraph;
+
+	private TestingLeaderElectionService dispatcherLeaderElectionService;
+
+	private TestingFatalErrorHandler fatalErrorHandler;
+
+	private JobGraphStore jobGraphStore;
+
+	private PartialDispatcherServices partialDispatcherServices;
+
+	@Before
+	public void setup() {
+		jobGraph = createJobGraph();
+		dispatcherLeaderElectionService = new TestingLeaderElectionService();
+		fatalErrorHandler = new TestingFatalErrorHandler();
+		jobGraphStore = TestingJobGraphStore.newBuilder().build();
+
+		partialDispatcherServices = new PartialDispatcherServices(
+			new Configuration(),
+			new TestingHighAvailabilityServicesBuilder().build(),
+			CompletableFuture::new,
+			blobServerResource.getBlobServer(),
+			new TestingHeartbeatServices(),
+			UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
+			new MemoryArchivedExecutionGraphStore(),
+			fatalErrorHandler,
+			VoidHistoryServerArchivist.INSTANCE,
+			null);
+	}
+
+	@After
+	public void teardown() throws Exception {
+		if (fatalErrorHandler != null) {
+			fatalErrorHandler.rethrowError();
+		}
+	}
+
+	@Test
+	public void leaderChange_afterJobSubmission_recoversSubmittedJob() throws Exception {
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+			final UUID firstLeaderSessionId = UUID.randomUUID();
+
+			dispatcherLeaderElectionService.isLeader(firstLeaderSessionId);
+
+			final DispatcherGateway firstDispatcherGateway = dispatcherRunner.getDispatcherGateway().get();
+
+			firstDispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
+
+			dispatcherLeaderElectionService.notLeader();
+
+			final UUID secondLeaderSessionId = UUID.randomUUID();
+			dispatcherLeaderElectionService.isLeader(secondLeaderSessionId).get();
+
+			final DispatcherGateway secondDispatcherGateway = dispatcherRunner.getDispatcherGateway().get();
+
+			final Collection<JobID> jobIds = secondDispatcherGateway.listJobs(TIMEOUT).get();
+
+			assertThat(jobIds, hasSize(1));
+			assertThat(jobIds, contains(jobGraph.getJobID()));
+		}
+	}
+
+	private static JobGraph createJobGraph() {
+		final JobVertex testVertex = new JobVertex("testVertex");
+		testVertex.setInvokableClass(NoOpInvokable.class);
+		final JobGraph testJob = new JobGraph(TEST_JOB_ID, "testJob", testVertex);
+		testJob.setAllowQueuedScheduling(true);
+
+		return testJob;
+	}
+
+	private DispatcherRunnerImplNG createDispatcherRunner() throws Exception {
+		final DispatcherRunnerImplNGFactory runnerFactory = DispatcherRunnerImplNGFactory.createSessionRunner(SessionDispatcherWithUUIDFactory.INSTANCE);
+
+		return runnerFactory.createDispatcherRunner(
+			dispatcherLeaderElectionService,
+			fatalErrorHandler,
+			() -> jobGraphStore,
+			TestingUtils.defaultExecutor(),
+			rpcServiceResource.getTestingRpcService(),
+			partialDispatcherServices);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java
index e6eb8002b9d..d8fd33ecc58 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java
@@ -19,6 +19,7 @@
 package org.apache.flink.runtime.dispatcher.runner;
 
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
+import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.dispatcher.DispatcherGateway;
 import org.apache.flink.runtime.dispatcher.DispatcherId;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
@@ -135,6 +136,34 @@ public class DispatcherRunnerImplNGTest extends TestLogger {
 		}
 	}
 
+	@Test
+	public void revokeLeadership_withExistingLeader_stopsLeaderProcess() throws Exception {
+		final UUID leaderSessionId = UUID.randomUUID();
+
+		final CompletableFuture<Void> startFuture = new CompletableFuture<>();
+		final CompletableFuture<Void> stopFuture = new CompletableFuture<>();
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.from(
+			TestingDispatcherLeaderProcess.newBuilder(leaderSessionId)
+				.setStartConsumer(startFuture::complete)
+				.setCloseAsyncSupplier(
+					() -> {
+						stopFuture.complete(null);
+						return FutureUtils.completedVoidFuture();
+					})
+				.build());
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+			testingLeaderElectionService.isLeader(leaderSessionId);
+
+			// wait until the leader process has been started
+			startFuture.get();
+
+			testingLeaderElectionService.notLeader();
+
+			// verify that the leader gets stopped
+			stopFuture.get();
+		}
+	}
+
 	@Test
 	public void grantLeadership_withExistingLeader_waitsForTerminationOfFirstLeader() throws Exception {
 		final UUID firstLeaderSessionId = UUID.randomUUID();
