diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/SegmentPartitionFile.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/SegmentPartitionFile.java
index 164dc33b94d..de3a09defcf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/SegmentPartitionFile.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/file/SegmentPartitionFile.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.io.network.partition.hybrid.tiered.file;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.core.fs.FileStatus;
 import org.apache.flink.core.fs.FileSystem;
 import org.apache.flink.core.fs.Path;
@@ -46,7 +47,7 @@ public class SegmentPartitionFile {
 
     static final String SEGMENT_FILE_PREFIX = "seg-";
 
-    static final String SEGMENT_FINISH_DIR_NAME = "FINISH";
+    @VisibleForTesting public static final String SEGMENT_FINISH_DIR_NAME = "FINISH";
 
     public static SegmentPartitionFileWriter createPartitionFileWriter(
             String dataFilePath, int numSubpartitions) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteCacheManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteCacheManager.java
index f9da0e24ded..fcab5cbf0e4 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteCacheManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteCacheManager.java
@@ -48,13 +48,17 @@ class RemoteCacheManager {
                             partitionId, subpartitionId, storageMemoryManager, partitionFileWriter);
         }
 
-        Arrays.fill(subpartitionSegmentIds, -1);
+        Arrays.fill(subpartitionSegmentIds, SubpartitionRemoteCacheManager.EMPTY_SEGMENT_ID);
     }
 
     // ------------------------------------------------------------------------
     //  Called by RemoteTierProducerAgent
     // ------------------------------------------------------------------------
 
+    boolean hasAnySegmentStarted(int subpartitionId) {
+        return subpartitionCacheDataManagers[subpartitionId].hasAnySegmentStarted();
+    }
+
     void startSegment(int subpartitionId, int segmentId) {
         subpartitionCacheDataManagers[subpartitionId].startSegment(segmentId);
         subpartitionSegmentIds[subpartitionId] = segmentId;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteStorageScanner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteStorageScanner.java
index 64ed0c04c85..813f50edb0b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteStorageScanner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteStorageScanner.java
@@ -187,7 +187,9 @@ public class RemoteStorageScanner implements Runnable {
                 TieredStoragePartitionId partitionId = ids.getKey().f0;
                 TieredStorageSubpartitionId subpartitionId = ids.getKey().f1;
                 int requiredSegmentId = ids.getValue();
-                int maxSegmentId = scannedMaxSegmentIds.getOrDefault(ids.getKey(), -1);
+                int maxSegmentId =
+                        scannedMaxSegmentIds.getOrDefault(
+                                ids.getKey(), SubpartitionRemoteCacheManager.EMPTY_SEGMENT_ID);
                 if (maxSegmentId >= requiredSegmentId
                         && checkSegmentExist(partitionId, subpartitionId, requiredSegmentId)) {
                     scanned = true;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgent.java
index e3cfcb960aa..3dc53169f78 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgent.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgent.java
@@ -114,7 +114,9 @@ public class RemoteTierProducerAgent implements TierProducerAgent {
     @Override
     public void close() {
         for (int subpartitionId = 0; subpartitionId < numSubpartitions; subpartitionId++) {
-            cacheDataManager.finishSegment(subpartitionId);
+            if (cacheDataManager.hasAnySegmentStarted(subpartitionId)) {
+                cacheDataManager.finishSegment(subpartitionId);
+            }
         }
         cacheDataManager.close();
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManager.java
index fd0db0d1ece..e62ba9fe315 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManager.java
@@ -37,6 +37,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 
+import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkState;
 
 /**
@@ -45,8 +46,14 @@ import static org.apache.flink.util.Preconditions.checkState;
  */
 class SubpartitionRemoteCacheManager {
 
+    static final int EMPTY_SEGMENT_ID = -1;
+
     private static final Logger LOG = LoggerFactory.getLogger(SubpartitionRemoteCacheManager.class);
 
+    private static void checkSegmentIdNotEmpty(int segmentId) {
+        checkArgument(segmentId >= 0, "Segment id must be non-negative.");
+    }
+
     private final TieredStoragePartitionId partitionId;
 
     private final int subpartitionId;
@@ -72,7 +79,7 @@ class SubpartitionRemoteCacheManager {
      * thread, so the thread safety should be ensured.
      */
     @GuardedBy("allBuffers")
-    private int segmentId = -1;
+    private int segmentId = EMPTY_SEGMENT_ID;
 
     /**
      * Record the buffer index in the {@link SubpartitionRemoteCacheManager}. Each time a new buffer
@@ -98,8 +105,15 @@ class SubpartitionRemoteCacheManager {
     //  Called by RemoteCacheManager
     // ------------------------------------------------------------------------
 
+    boolean hasAnySegmentStarted() {
+        synchronized (allBuffers) {
+            return segmentId != EMPTY_SEGMENT_ID;
+        }
+    }
+
     void startSegment(int segmentId) {
         synchronized (allBuffers) {
+            checkSegmentIdNotEmpty(segmentId);
             checkState(allBuffers.isEmpty(), "There are un-flushed buffers.");
             this.segmentId = segmentId;
         }
@@ -108,11 +122,13 @@ class SubpartitionRemoteCacheManager {
     void addBuffer(Buffer buffer) {
         Tuple2<Buffer, Integer> toAddBuffer = new Tuple2<>(buffer, bufferIndex++);
         synchronized (allBuffers) {
+            checkArgument(segmentId >= 0, "No segment has been started.");
             allBuffers.add(toAddBuffer);
         }
     }
 
     void finishSegment(int segmentId) {
+        checkSegmentIdNotEmpty(segmentId);
         // Only task thread can modify the segmentId, and the method can only be called by the task
         // thread, so accessing segmentId is not guarded here.
         //noinspection FieldAccessNotGuarded
@@ -167,6 +183,8 @@ class SubpartitionRemoteCacheManager {
                 return;
             }
 
+            checkSegmentIdNotEmpty(segmentId);
+
             PartitionFileWriter.SubpartitionBufferContext subpartitionBufferContext =
                     new PartitionFileWriter.SubpartitionBufferContext(
                             subpartitionId,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgentTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgentTest.java
new file mode 100644
index 00000000000..7d1e8837721
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/RemoteTierProducerAgentTest.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.io.network.partition.hybrid.tiered.tier.remote;
+
+import org.apache.flink.configuration.NettyShuffleEnvironmentOptions;
+import org.apache.flink.runtime.io.network.buffer.BufferBuilderTestUtils;
+import org.apache.flink.runtime.io.network.buffer.BufferCompressor;
+import org.apache.flink.runtime.io.network.partition.ResultPartitionID;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.TestingTieredStorageMemoryManager;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.common.TieredStorageIdMappingUtils;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.common.TieredStoragePartitionId;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.common.TieredStorageSubpartitionId;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.file.PartitionFileWriter;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.file.SegmentPartitionFile;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.storage.TieredStorageMemoryManager;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.storage.TieredStorageResourceRegistry;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.io.TempDir;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.stream.Stream;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Tests for {@link RemoteTierProducerAgent}. */
+class RemoteTierProducerAgentTest {
+
+    @Test
+    void test(@TempDir Path tempDir) throws Exception {
+        final TieredStoragePartitionId partitionId =
+                TieredStorageIdMappingUtils.convertId(new ResultPartitionID());
+        final int numSubpartitions = 10;
+        final int bufferSizeBytes = 1024;
+        final int networkBufferSize = 1024;
+        final int numBytesPerSegment = 4 * bufferSizeBytes;
+
+        final PartitionFileWriter partitionFileWriter =
+                SegmentPartitionFile.createPartitionFileWriter(
+                        String.format("file://%s", tempDir), numSubpartitions);
+        final TieredStorageMemoryManager memoryManager =
+                new TestingTieredStorageMemoryManager.Builder().build();
+        final TieredStorageResourceRegistry resourceRegistry = new TieredStorageResourceRegistry();
+        final BufferCompressor bufferCompressor =
+                new BufferCompressor(
+                        networkBufferSize, NettyShuffleEnvironmentOptions.CompressionCodec.LZ4);
+
+        try (final RemoteTierProducerAgent agent =
+                new RemoteTierProducerAgent(
+                        partitionId,
+                        numSubpartitions,
+                        numBytesPerSegment,
+                        bufferSizeBytes,
+                        false,
+                        partitionFileWriter,
+                        memoryManager,
+                        resourceRegistry,
+                        bufferCompressor)) {
+            final Object bufferOwner = new Object();
+            for (int i = 0; i < numSubpartitions; i += 2) {
+                final TieredStorageSubpartitionId subpartitionId =
+                        new TieredStorageSubpartitionId(i);
+                assertThat(agent.tryStartNewSegment(subpartitionId, 0, 1)).isTrue();
+                assertThat(
+                                agent.tryWrite(
+                                        subpartitionId,
+                                        BufferBuilderTestUtils.buildSomeBuffer(bufferSizeBytes),
+                                        bufferOwner,
+                                        0))
+                        .isTrue();
+            }
+        }
+
+        try (final Stream<Path> files = Files.walk(tempDir)) {
+            final long numFinishedSegments =
+                    files.filter(Files::isRegularFile)
+                            .filter(
+                                    file ->
+                                            SegmentPartitionFile.SEGMENT_FINISH_DIR_NAME.equals(
+                                                    file.getParent().getFileName().toString()))
+                            .count();
+            assertThat(numFinishedSegments)
+                    .withFailMessage("Only every second partition should have a finished segment.")
+                    .isEqualTo(numSubpartitions / 2);
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManagerTest.java
index 6b5716cf73b..62f17c7def5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/tier/remote/SubpartitionRemoteCacheManagerTest.java
@@ -81,7 +81,8 @@ class SubpartitionRemoteCacheManagerTest {
         TieredStoragePartitionId partitionId =
                 TieredStorageIdMappingUtils.convertId(new ResultPartitionID());
         int subpartitionId = 0;
-        int segmentId = 0;
+        int firstSegmentId = 0;
+        int secondSegmentId = 1;
 
         SubpartitionRemoteCacheManager cacheManager =
                 new SubpartitionRemoteCacheManager(
@@ -89,8 +90,9 @@ class SubpartitionRemoteCacheManagerTest {
                         subpartitionId,
                         new TestingTieredStorageMemoryManager.Builder().build(),
                         new TestingPartitionFileWriter.Builder().build());
+        cacheManager.startSegment(firstSegmentId);
         cacheManager.addBuffer(BufferBuilderTestUtils.buildSomeBuffer());
-        assertThatThrownBy(() -> cacheManager.startSegment(segmentId))
+        assertThatThrownBy(() -> cacheManager.startSegment(secondSegmentId))
                 .isInstanceOf(IllegalStateException.class);
     }
 
@@ -117,6 +119,7 @@ class SubpartitionRemoteCacheManagerTest {
         TieredStoragePartitionId partitionId =
                 TieredStorageIdMappingUtils.convertId(new ResultPartitionID());
         int subpartitionId = 0;
+        int segmentId = 0;
 
         AtomicInteger numWrittenBuffers = new AtomicInteger(0);
         PartitionFileWriter partitionFileWriter =
@@ -149,6 +152,7 @@ class SubpartitionRemoteCacheManagerTest {
                 new NetworkBuffer(
                         MemorySegmentFactory.allocateUnpooledSegment(1),
                         FreeingBufferRecycler.INSTANCE);
+        cacheManager.startSegment(segmentId);
         cacheManager.addBuffer(buffer);
         cacheManager.close();
         cacheManager.release();
@@ -183,11 +187,37 @@ class SubpartitionRemoteCacheManagerTest {
                         subpartitionId,
                         new TestingTieredStorageMemoryManager.Builder().build(),
                         partitionFileWriter);
+        cacheManager.startSegment(segmentId);
         cacheManager.addBuffer(BufferBuilderTestUtils.buildSomeBuffer());
         cacheManager.close();
         assertThat(numReceivedBuffers).hasValue(1);
     }
 
+    @Test
+    void testClose_noSegmentHasStarted() {
+        final TieredStoragePartitionId partitionId =
+                TieredStorageIdMappingUtils.convertId(new ResultPartitionID());
+        final int subpartitionId = 0;
+        final AtomicBoolean writeCalled = new AtomicBoolean(false);
+
+        TestingPartitionFileWriter partitionFileWriter =
+                new TestingPartitionFileWriter.Builder()
+                        .setWriteFunction(
+                                (ignoredPartitionId, bufferContexts) -> {
+                                    writeCalled.set(true);
+                                    return FutureUtils.completedVoidFuture();
+                                })
+                        .build();
+        SubpartitionRemoteCacheManager cacheManager =
+                new SubpartitionRemoteCacheManager(
+                        partitionId,
+                        subpartitionId,
+                        new TestingTieredStorageMemoryManager.Builder().build(),
+                        partitionFileWriter);
+        cacheManager.close();
+        assertThat(writeCalled).isFalse();
+    }
+
     @Test
     void testRelease() {
         TieredStoragePartitionId partitionId =
