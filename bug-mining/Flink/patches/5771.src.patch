diff --git a/flink-python/pyflink/common/typeinfo.py b/flink-python/pyflink/common/typeinfo.py
index 95f4ea76ed1..5558fad683e 100644
--- a/flink-python/pyflink/common/typeinfo.py
+++ b/flink-python/pyflink/common/typeinfo.py
@@ -496,6 +496,9 @@ class TupleTypeInfo(TypeInformation):
 
     def __init__(self, field_types: List[TypeInformation]):
         self._field_types = field_types
+        self._need_conversion = [f.need_conversion() if isinstance(f, TypeInformation) else None
+                                 for f in self._field_types]
+        self._need_serialize_any_field = any(self._need_conversion)
         super(TupleTypeInfo, self).__init__()
 
     def get_field_types(self) -> List[TypeInformation]:
@@ -516,6 +519,39 @@ class TupleTypeInfo(TypeInformation):
                 .org.apache.flink.api.java.typeutils.TupleTypeInfo(j_types_array)
         return self._j_typeinfo
 
+    def need_conversion(self):
+        return True
+
+    def to_internal_type(self, obj):
+        if obj is None:
+            return
+        from pyflink.common import Row
+        if self._need_serialize_any_field:
+            # Only calling to_internal_type function for fields that need conversion
+            if isinstance(obj, (list, tuple, Row)):
+                return tuple(
+                    f.to_internal_type(v) if c else v
+                    for f, v, c in zip(self._field_types, obj, self._need_conversion))
+            else:
+                raise ValueError("Unexpected tuple %r with TupleTypeInfo" % obj)
+        else:
+            if isinstance(obj, (list, tuple, Row)):
+                return tuple(obj)
+            else:
+                raise ValueError("Unexpected tuple %r with TupleTypeInfo" % obj)
+
+    def from_internal_type(self, obj):
+        if obj is None or isinstance(obj, (tuple, list)):
+            # it's already converted by pickler
+            return obj
+        if self._need_serialize_any_field:
+            # Only calling from_internal_type function for fields that need conversion
+            values = [f.from_internal_type(v) if c else v
+                      for f, v, c in zip(self._field_types, obj, self._need_conversion)]
+        else:
+            values = obj
+        return tuple(values)
+
     def __eq__(self, other) -> bool:
         if isinstance(other, TupleTypeInfo):
             return self._field_types == other._field_types
diff --git a/flink-python/pyflink/datastream/tests/test_data_stream.py b/flink-python/pyflink/datastream/tests/test_data_stream.py
index e01ea2d146b..b9f647ee677 100644
--- a/flink-python/pyflink/datastream/tests/test_data_stream.py
+++ b/flink-python/pyflink/datastream/tests/test_data_stream.py
@@ -62,11 +62,12 @@ class DataStreamTests(object):
         self.assertEqual(expected, actual)
 
     def test_basic_operations(self):
-        ds = self.env.from_collection([('ab', decimal.Decimal(1)),
-                                       ('bdc', decimal.Decimal(2)),
-                                       ('cfgs', decimal.Decimal(3)),
-                                       ('deeefg', decimal.Decimal(4))],
-                                      type_info=Types.ROW([Types.STRING(), Types.BIG_DEC()]))
+        ds = self.env.from_collection(
+            [('ab', Row('a', decimal.Decimal(1))),
+             ('bdc', Row('b', decimal.Decimal(2))),
+             ('cfgs', Row('c', decimal.Decimal(3))),
+             ('deeefg', Row('d', decimal.Decimal(4)))],
+            type_info=Types.TUPLE([Types.STRING(), Types.ROW([Types.STRING(), Types.BIG_DEC()])]))
 
         class MyMapFunction(MapFunction):
             def map(self, value):
@@ -81,7 +82,7 @@ class DataStreamTests(object):
             def filter(self, value):
                 return value[1] > 2
 
-        (ds.map(lambda i: (i[0], len(i[0]), i[1]),
+        (ds.map(lambda i: (i[0], len(i[0]), i[1][1]),
                 output_type=Types.TUPLE([Types.STRING(), Types.INT(), Types.BIG_DEC()]))
            .flat_map(MyFlatMapFunction(),
                      output_type=Types.TUPLE([Types.STRING(), Types.INT(), Types.BIG_DEC()]))
