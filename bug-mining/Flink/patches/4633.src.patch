diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
index 26d577d7e84..b338f4203af 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
@@ -109,6 +109,8 @@ public class CheckpointCoordinator {
 	/** The executor used for asynchronous calls, like potentially blocking I/O. */
 	private final Executor executor;
 
+	private final CheckpointsCleaner checkpointsCleaner;
+
 	/** Tasks who need to be sent a message when a checkpoint is started. */
 	private final ExecutionVertex[] tasksToTrigger;
 
@@ -217,6 +219,7 @@ public class CheckpointCoordinator {
 		CompletedCheckpointStore completedCheckpointStore,
 		StateBackend checkpointStateBackend,
 		Executor executor,
+		CheckpointsCleaner checkpointsCleaner,
 		ScheduledExecutor timer,
 		SharedStateRegistryFactory sharedStateRegistryFactory,
 		CheckpointFailureManager failureManager) {
@@ -232,6 +235,7 @@ public class CheckpointCoordinator {
 			completedCheckpointStore,
 			checkpointStateBackend,
 			executor,
+			checkpointsCleaner,
 			timer,
 			sharedStateRegistryFactory,
 			failureManager,
@@ -250,6 +254,7 @@ public class CheckpointCoordinator {
 			CompletedCheckpointStore completedCheckpointStore,
 			StateBackend checkpointStateBackend,
 			Executor executor,
+			CheckpointsCleaner checkpointsCleaner,
 			ScheduledExecutor timer,
 			SharedStateRegistryFactory sharedStateRegistryFactory,
 			CheckpointFailureManager failureManager,
@@ -283,6 +288,7 @@ public class CheckpointCoordinator {
 		this.checkpointIdCounter = checkNotNull(checkpointIDCounter);
 		this.completedCheckpointStore = checkNotNull(completedCheckpointStore);
 		this.executor = checkNotNull(executor);
+		this.checkpointsCleaner = checkNotNull(checkpointsCleaner);
 		this.sharedStateRegistryFactory = checkNotNull(sharedStateRegistryFactory);
 		this.sharedStateRegistry = sharedStateRegistryFactory.create(executor);
 		this.isPreferCheckpointForRecovery = chkConfig.isPreferCheckpointForRecovery();
@@ -317,7 +323,8 @@ public class CheckpointCoordinator {
 			this::rescheduleTrigger,
 			this.clock,
 			this.minPauseBetweenCheckpoints,
-			this.pendingCheckpoints::size);
+			this.pendingCheckpoints::size,
+			this.checkpointsCleaner::getNumberOfCheckpointsToClean);
 	}
 
 	// --------------------------------------------------------------------------------------------
@@ -669,7 +676,9 @@ public class CheckpointCoordinator {
 			props,
 			checkpointStorageLocation,
 			executor,
-			onCompletionPromise);
+			onCompletionPromise,
+			checkpointsCleaner,
+			this::scheduleTriggerRequest);
 
 		if (statsTracker != null) {
 			PendingCheckpointStats callback = statsTracker.reportPendingCheckpoint(
@@ -1062,7 +1071,7 @@ public class CheckpointCoordinator {
 
 		try {
 			try {
-				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint();
+				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint(checkpointsCleaner::cleanCheckpoint);
 				failureManager.handleCheckpointSuccess(pendingCheckpoint.getCheckpointId());
 			}
 			catch (Exception e1) {
@@ -1102,7 +1111,7 @@ public class CheckpointCoordinator {
 			}
 		} finally {
 			pendingCheckpoints.remove(checkpointId);
-			timer.execute(this::executeQueuedRequest);
+			scheduleTriggerRequest();
 		}
 
 		rememberRecentCheckpointId(checkpointId);
@@ -1134,6 +1143,10 @@ public class CheckpointCoordinator {
 		sendAcknowledgeMessages(checkpointId, completedCheckpoint.getTimestamp());
 	}
 
+	void scheduleTriggerRequest() {
+		timer.execute(this::executeQueuedRequest);
+	}
+
 	private void sendAcknowledgeMessages(long checkpointId, long timestamp) {
 		// commit tasks
 		for (ExecutionVertex ev : tasksToCommitTo) {
@@ -1396,7 +1409,7 @@ public class CheckpointCoordinator {
 
 		// Load the savepoint as a checkpoint into the system
 		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(
-				job, tasks, checkpointLocation, userClassLoader, allowNonRestored);
+				job, tasks, checkpointLocation, userClassLoader, allowNonRestored, checkpointsCleaner::cleanCheckpoint, this::scheduleTriggerRequest);
 
 		completedCheckpointStore.addCheckpoint(savepoint);
 
@@ -1678,7 +1691,7 @@ public class CheckpointCoordinator {
 				sendAbortedMessages(pendingCheckpoint.getCheckpointId(), pendingCheckpoint.getCheckpointTimestamp());
 				pendingCheckpoints.remove(pendingCheckpoint.getCheckpointId());
 				rememberRecentCheckpointId(pendingCheckpoint.getCheckpointId());
-				timer.execute(this::executeQueuedRequest);
+				scheduleTriggerRequest();
 			}
 		}
 	}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java
index 455766baa05..65270e21b4b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDecider.java
@@ -62,6 +62,7 @@ class CheckpointRequestDecider {
 	private final Clock clock;
 	private final long minPauseBetweenCheckpoints;
 	private final Supplier<Integer> pendingCheckpointsSizeSupplier;
+	private final Supplier<Integer> numberOfCleaningCheckpointsSupplier;
 	private final NavigableSet<CheckpointTriggerRequest> queuedRequests = new TreeSet<>(checkpointTriggerRequestsComparator());
 	private final int maxQueuedRequests;
 
@@ -70,13 +71,15 @@ class CheckpointRequestDecider {
 			Consumer<Long> rescheduleTrigger,
 			Clock clock,
 			long minPauseBetweenCheckpoints,
-			Supplier<Integer> pendingCheckpointsSizeSupplier) {
+			Supplier<Integer> pendingCheckpointsSizeSupplier,
+			Supplier<Integer> numberOfCleaningCheckpointsSupplier) {
 		this(
 			maxConcurrentCheckpointAttempts,
 			rescheduleTrigger,
 			clock,
 			minPauseBetweenCheckpoints,
 			pendingCheckpointsSizeSupplier,
+			numberOfCleaningCheckpointsSupplier,
 			DEFAULT_MAX_QUEUED_REQUESTS
 		);
 	}
@@ -87,6 +90,7 @@ class CheckpointRequestDecider {
 			Clock clock,
 			long minPauseBetweenCheckpoints,
 			Supplier<Integer> pendingCheckpointsSizeSupplier,
+			Supplier<Integer> numberOfCleaningCheckpointsSupplier,
 			int maxQueuedRequests) {
 		Preconditions.checkArgument(maxConcurrentCheckpointAttempts > 0);
 		Preconditions.checkArgument(maxQueuedRequests > 0);
@@ -95,6 +99,7 @@ class CheckpointRequestDecider {
 		this.clock = clock;
 		this.minPauseBetweenCheckpoints = minPauseBetweenCheckpoints;
 		this.pendingCheckpointsSizeSupplier = pendingCheckpointsSizeSupplier;
+		this.numberOfCleaningCheckpointsSupplier = numberOfCleaningCheckpointsSupplier;
 		this.maxQueuedRequests = maxQueuedRequests;
 	}
 
@@ -134,10 +139,10 @@ class CheckpointRequestDecider {
 	 * @return request that should be executed
 	 */
 	private Optional<CheckpointTriggerRequest> chooseRequestToExecute(boolean isTriggering, long lastCompletionMs) {
-		if (isTriggering || queuedRequests.isEmpty()) {
+		if (isTriggering || queuedRequests.isEmpty()
+			|| numberOfCleaningCheckpointsSupplier.get() > maxConcurrentCheckpointAttempts) {
 			return Optional.empty();
 		}
-
 		if (pendingCheckpointsSizeSupplier.get() >= maxConcurrentCheckpointAttempts) {
 			return Optional.of(queuedRequests.first())
 				.filter(CheckpointTriggerRequest::isForce)
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
index 23df6942466..00393afa3d8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
@@ -118,7 +118,9 @@ public class Checkpoints {
 			Map<JobVertexID, ExecutionJobVertex> tasks,
 			CompletedCheckpointStorageLocation location,
 			ClassLoader classLoader,
-			boolean allowNonRestoredState) throws IOException {
+			boolean allowNonRestoredState,
+			CheckpointsCleaningRunner cleanCallback,
+			SerializableRunnable checkpointCleaningFinishedCallback) throws IOException {
 
 		checkNotNull(jobId, "jobId");
 		checkNotNull(tasks, "tasks");
@@ -196,7 +198,9 @@ public class Checkpoints {
 				operatorStates,
 				checkpointMetadata.getMasterStates(),
 				props,
-				location);
+				location,
+				cleanCallback,
+				checkpointCleaningFinishedCallback);
 	}
 
 	private static void throwNonRestoredStateException(String checkpointPointer, OperatorID operatorId) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
new file mode 100644
index 00000000000..bc6ee9d463b
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.checkpoint;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.Serializable;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Delegate class responsible for checkpoints cleaning and counting the number of checkpoints yet
+ * to clean.
+ */
+public class CheckpointsCleaner implements Serializable {
+	private static final Logger LOG = LoggerFactory.getLogger(CheckpointsCleaner.class);
+
+	private final AtomicInteger numberOfCheckpointsToClean;
+
+	public CheckpointsCleaner() {
+		this.numberOfCheckpointsToClean = new AtomicInteger(0);
+	}
+
+	int getNumberOfCheckpointsToClean() {
+		return numberOfCheckpointsToClean.get();
+	}
+
+	public void cleanCheckpoint(Runnable cleanAction, Runnable postCleanAction, Executor executor) {
+		numberOfCheckpointsToClean.incrementAndGet();
+		executor.execute(() -> {
+			try {
+				cleanAction.run();
+			} finally {
+				numberOfCheckpointsToClean.decrementAndGet();
+				postCleanAction.run();
+			}
+		});
+	}
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaningRunner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaningRunner.java
new file mode 100644
index 00000000000..ebcd48717c0
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaningRunner.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.checkpoint;
+
+import java.io.Serializable;
+import java.util.concurrent.Executor;
+
+/**
+ * Interface that allows to run a checkpoint cleaning task and a post checkpoint cleaning task on an {@link Executor}.
+ */
+@FunctionalInterface
+public interface CheckpointsCleaningRunner extends Serializable {
+	void accept(Runnable cleanAction, Runnable postCleanAction, Executor executor);
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
index d79cab42646..5a03e563de6 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
@@ -27,6 +27,7 @@ import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.StateUtil;
 import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.function.ThrowingConsumer;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -40,6 +41,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Executor;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -108,6 +110,11 @@ public class CompletedCheckpoint implements Serializable {
 	@Nullable
 	private transient volatile CompletedCheckpointStats.DiscardCallback discardCallback;
 
+	private final CheckpointsCleaningRunner cleanupCallback;
+
+	private final SerializableRunnable cleanupFinishedCallback;
+
+
 	// ------------------------------------------------------------------------
 
 	public CompletedCheckpoint(
@@ -118,7 +125,9 @@ public class CompletedCheckpoint implements Serializable {
 			Map<OperatorID, OperatorState> operatorStates,
 			@Nullable Collection<MasterState> masterHookStates,
 			CheckpointProperties props,
-			CompletedCheckpointStorageLocation storageLocation) {
+			CompletedCheckpointStorageLocation storageLocation,
+			CheckpointsCleaningRunner cleanupCallback,
+			SerializableRunnable cleanupFinishedCallback) {
 
 		checkArgument(checkpointID >= 0);
 		checkArgument(timestamp >= 0);
@@ -140,6 +149,8 @@ public class CompletedCheckpoint implements Serializable {
 		this.storageLocation = checkNotNull(storageLocation);
 		this.metadataHandle = storageLocation.getMetadataHandle();
 		this.externalPointer = storageLocation.getExternalPointer();
+		this.cleanupCallback = cleanupCallback;
+		this.cleanupFinishedCallback = cleanupFinishedCallback;
 	}
 
 	// ------------------------------------------------------------------------
@@ -210,6 +221,21 @@ public class CompletedCheckpoint implements Serializable {
 	//  Discard and Dispose
 	// ------------------------------------------------------------------------
 
+	/**
+	 * Asynchronously call a discard on the ioExecutor
+	 * (FixedThreadPool of configurable size of default 4*CPU cores)
+	 * and count the number of checkpoints that are waiting to clean.
+	 */
+	void asyncDiscardCheckpointAndCountCheckpoint(ThrowingConsumer<CompletedCheckpoint, Exception> discardCallback, Executor executor){
+		cleanupCallback.accept(() -> {
+			try {
+				discardCallback.accept(this);
+			} catch (Exception e) {
+				LOG.warn("Could not discard completed checkpoint {}.", checkpointID, e);
+			}
+		}, cleanupFinishedCallback, executor);
+	}
+
 	public void discardOnFailedStoring() throws Exception {
 		doDiscard();
 	}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
index ba5b9e929f5..9590156a6a3 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
@@ -125,6 +125,9 @@ public class PendingCheckpoint {
 
 	private CheckpointException failureCause;
 
+	private final SerializableRunnable cleanupFinishedCallback;
+	private final CheckpointsCleaner checkpointsCleaner;
+
 	// --------------------------------------------------------------------------------------------
 
 	public PendingCheckpoint(
@@ -137,7 +140,10 @@ public class PendingCheckpoint {
 			CheckpointProperties props,
 			CheckpointStorageLocation targetLocation,
 			Executor executor,
-			CompletableFuture<CompletedCheckpoint> onCompletionPromise) {
+			CompletableFuture<CompletedCheckpoint> onCompletionPromise,
+			CheckpointsCleaner checkpointsCleaner,
+			SerializableRunnable cleanupFinishedCallback
+		) {
 
 		checkArgument(verticesToConfirm.size() > 0,
 				"Checkpoint needs at least one vertex that commits the checkpoint");
@@ -158,6 +164,8 @@ public class PendingCheckpoint {
 				? Collections.emptySet() : new HashSet<>(operatorCoordinatorsToConfirm);
 		this.acknowledgedTasks = new HashSet<>(verticesToConfirm.size());
 		this.onCompletionPromise = checkNotNull(onCompletionPromise);
+		this.cleanupFinishedCallback = cleanupFinishedCallback;
+		this.checkpointsCleaner = checkpointsCleaner;
 	}
 
 	// --------------------------------------------------------------------------------------------
@@ -291,7 +299,7 @@ public class PendingCheckpoint {
 		return onCompletionPromise;
 	}
 
-	public CompletedCheckpoint finalizeCheckpoint() throws IOException {
+	public CompletedCheckpoint finalizeCheckpoint(CheckpointsCleaningRunner cleanCallback) throws IOException {
 
 		synchronized (lock) {
 			checkState(!isDiscarded(), "checkpoint is discarded");
@@ -316,7 +324,9 @@ public class PendingCheckpoint {
 						operatorStates,
 						masterStates,
 						props,
-						finalizedLocation);
+						finalizedLocation,
+						cleanCallback,
+						cleanupFinishedCallback);
 
 				onCompletionPromise.complete(completed);
 
@@ -521,24 +531,21 @@ public class PendingCheckpoint {
 			try {
 				numAcknowledgedTasks = -1;
 				if (!discarded && releaseState) {
-					executor.execute(new Runnable() {
-						@Override
-						public void run() {
-
-							// discard the private states.
-							// unregistered shared states are still considered private at this point.
-							try {
-								StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values());
-								targetLocation.disposeOnFailure();
-							} catch (Throwable t) {
-								LOG.warn("Could not properly dispose the private states in the pending checkpoint {} of job {}.",
-									checkpointId, jobId, t);
-							} finally {
-								operatorStates.clear();
-							}
+					Runnable cleanAction = () -> {
+						// discard the private states.
+						// unregistered shared states are still considered private at this point.
+						try {
+							StateUtil.bestEffortDiscardAllStateObjects(operatorStates.values());
+							targetLocation.disposeOnFailure();
+						} catch (Throwable t) {
+							LOG.warn(
+								"Could not properly dispose the private states in the pending checkpoint {} of job {}.",
+								checkpointId, jobId, t);
+						} finally {
+							operatorStates.clear();
 						}
-					});
-
+					};
+					checkpointsCleaner.cleanCheckpoint(cleanAction, cleanupFinishedCallback, executor);
 				}
 			} finally {
 				discarded = true;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SerializableRunnable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SerializableRunnable.java
new file mode 100644
index 00000000000..80ac966128a
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SerializableRunnable.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.checkpoint;
+
+import java.io.Serializable;
+
+/**
+ * Serializable version of the Runnable.
+ */
+public interface SerializableRunnable extends Serializable, Runnable {
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
index b4f72b7436d..10123b32f12 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStore.java
@@ -229,14 +229,9 @@ public class ZooKeeperCompletedCheckpointStore implements CompletedCheckpointSto
 	private void tryRemoveCompletedCheckpoint(CompletedCheckpoint completedCheckpoint, ThrowingConsumer<CompletedCheckpoint, Exception> discardCallback) {
 		try {
 			if (tryRemove(completedCheckpoint.getCheckpointID())) {
-				executor.execute(() -> {
-					try {
-						discardCallback.accept(completedCheckpoint);
-					} catch (Exception e) {
-						LOG.warn("Could not discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), e);
-					}
-				});
-
+				// async exec on the ioExecutor (FixedThreadPool of configurable size or default 4*CPU cores)
+				// of CompletedCheckpoint.discardOnSubsume()
+				completedCheckpoint.asyncDiscardCheckpointAndCountCheckpoint(discardCallback, executor);
 			}
 		} catch (Exception e) {
 			LOG.warn("Failed to subsume the old checkpoint", e);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java
index 0eaa2fedc0c..5ca479c21da 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraph.java
@@ -39,6 +39,7 @@ import org.apache.flink.runtime.checkpoint.CheckpointFailureManager;
 import org.apache.flink.runtime.checkpoint.CheckpointIDCounter;
 import org.apache.flink.runtime.checkpoint.CheckpointStatsSnapshot;
 import org.apache.flink.runtime.checkpoint.CheckpointStatsTracker;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaner;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
 import org.apache.flink.runtime.checkpoint.MasterTriggerRestoreHook;
 import org.apache.flink.runtime.checkpoint.OperatorCoordinatorCheckpointContext;
@@ -501,6 +502,7 @@ public class ExecutionGraph implements AccessExecutionGraph {
 			checkpointStore,
 			checkpointStateBackend,
 			ioExecutor,
+			new CheckpointsCleaner(),
 			new ScheduledExecutorServiceAdapter(checkpointCoordinatorTimer),
 			SharedStateRegistry.DEFAULT_FACTORY,
 			failureManager);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraphBuilder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraphBuilder.java
index e246517c23e..5e546ecfccc 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraphBuilder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionGraphBuilder.java
@@ -18,6 +18,15 @@
 
 package org.apache.flink.runtime.executiongraph;
 
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ScheduledExecutorService;
+import javax.annotation.Nullable;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.time.Time;
@@ -58,20 +67,8 @@ import org.apache.flink.runtime.state.StateBackend;
 import org.apache.flink.runtime.state.StateBackendLoader;
 import org.apache.flink.util.DynamicCodeLoadingException;
 import org.apache.flink.util.SerializedValue;
-
 import org.slf4j.Logger;
 
-import javax.annotation.Nullable;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ScheduledExecutorService;
-
-import static org.apache.flink.util.Preconditions.checkNotNull;
-
 /**
  * Utility class to encapsulate the logic of building an {@link ExecutionGraph} from a {@link JobGraph}.
  */
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java
index 91c5ce807bd..5abe6df0bfe 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorMasterHooksTest.java
@@ -33,6 +33,7 @@ import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.memory.MemoryStateBackend;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.junit.Test;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
@@ -269,7 +270,9 @@ public class CheckpointCoordinatorMasterHooksTest {
 				Collections.<OperatorID, OperatorState>emptyMap(),
 				masterHookStates,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation());
+				new TestCompletedCheckpointStorageLocation(),
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 		final ExecutionAttemptID execId = new ExecutionAttemptID();
 		final ExecutionVertex ackVertex = mockExecutionVertex(execId);
 		final CheckpointCoordinator cc = instantiateCheckpointCoordinator(jid, ackVertex);
@@ -320,7 +323,9 @@ public class CheckpointCoordinatorMasterHooksTest {
 				Collections.<OperatorID, OperatorState>emptyMap(),
 				masterHookStates,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation());
+				new TestCompletedCheckpointStorageLocation(),
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		final ExecutionAttemptID execId = new ExecutionAttemptID();
 		final ExecutionVertex ackVertex = mockExecutionVertex(execId);
@@ -449,6 +454,7 @@ public class CheckpointCoordinatorMasterHooksTest {
 			false,
 			false,
 			0);
+		Executor executor = Executors.directExecutor();
 		return new CheckpointCoordinator(
 				jid,
 				chkConfig,
@@ -459,7 +465,8 @@ public class CheckpointCoordinatorMasterHooksTest {
 				new StandaloneCheckpointIDCounter(),
 				new StandaloneCompletedCheckpointStore(10),
 				new MemoryStateBackend(),
-				Executors.directExecutor(),
+				executor,
+				new CheckpointsCleaner(),
 				testingScheduledExecutor,
 				SharedStateRegistry.DEFAULT_FACTORY,
 				new CheckpointFailureManager(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java
index c2140cc3487..fb43c008428 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorRestoringTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTestingUtils.CheckpointCoordinatorBuilder;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
 import org.apache.flink.runtime.executiongraph.Execution;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
@@ -41,6 +42,7 @@ import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.testutils.RecoverableCompletedCheckpointStore;
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.SerializableObject;
 import org.apache.flink.util.TestLogger;
 
@@ -803,7 +805,9 @@ public class CheckpointCoordinatorRestoringTest extends TestLogger {
 			operatorStates,
 			Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		// set up the coordinator and validate the initial state
 		CheckpointCoordinator coord =
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
index 78e53368555..a3207bbe088 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
@@ -58,6 +58,7 @@ import org.apache.flink.runtime.state.memory.MemoryStateBackend;
 import org.apache.flink.runtime.state.memory.NonPersistentMetadataCheckpointStorageLocation;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 import org.apache.flink.runtime.testutils.RecoverableCompletedCheckpointStore;
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.TestLogger;
 
@@ -1994,15 +1995,12 @@ public class CheckpointCoordinatorTest extends TestLogger {
 				.setTimer(manuallyTriggeredScheduledExecutor)
 				.build();
 
-		store.addCheckpoint(new CompletedCheckpoint(
-			new JobID(),
-			0,
-			0,
-			0,
-			Collections.<OperatorID, OperatorState>emptyMap(),
-			Collections.<MasterState>emptyList(),
+		store.addCheckpoint(new CompletedCheckpoint(new JobID(), 0, 0, 0,
+			Collections.<OperatorID, OperatorState>emptyMap(), Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation()));
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback()));
 
 		CheckpointStatsTracker tracker = mock(CheckpointStatsTracker.class);
 		checkpointCoordinator.setCheckpointStatsTracker(tracker);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java
index 6fe7522068b..b22883516e8 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java
@@ -609,6 +609,8 @@ public class CheckpointCoordinatorTestingUtils {
 
 		private Executor ioExecutor = Executors.directExecutor();
 
+		private CheckpointsCleaner checkpointsCleaner = new CheckpointsCleaner();
+
 		private ScheduledExecutor timer = new ManuallyTriggeredScheduledExecutor();
 
 		private SharedStateRegistryFactory sharedStateRegistryFactory =
@@ -720,6 +722,7 @@ public class CheckpointCoordinatorTestingUtils {
 				completedCheckpointStore,
 				checkpointStateBackend,
 				ioExecutor,
+				checkpointsCleaner,
 				timer,
 				sharedStateRegistryFactory,
 				failureManager);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java
index 987d77d58b8..b813d3456c3 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointMetadataLoadingTest.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.checkpoint;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
@@ -30,6 +31,7 @@ import org.apache.flink.runtime.state.StreamStateHandle;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.junit.Test;
 
 import java.io.ByteArrayOutputStream;
@@ -69,7 +71,7 @@ public class CheckpointMetadataLoadingTest {
 		final CompletedCheckpointStorageLocation testSavepoint = createSavepointWithOperatorSubtaskState(checkpointId, operatorId, parallelism);
 		final Map<JobVertexID, ExecutionJobVertex> tasks = createTasks(operatorId, parallelism, parallelism);
 
-		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(jobId, tasks, testSavepoint, cl, false);
+		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(jobId, tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		assertEquals(jobId, loaded.getJobId());
 		assertEquals(checkpointId, loaded.getCheckpointID());
@@ -87,8 +89,8 @@ public class CheckpointMetadataLoadingTest {
 		final Map<JobVertexID, ExecutionJobVertex> tasks = createTasks(operatorId, parallelism, parallelism + 1);
 
 		try {
-			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false);
-			fail("Did not throw expected Exception");
+			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
+				fail("Did not throw expected Exception");
 		} catch (IllegalStateException expected) {
 			assertTrue(expected.getMessage().contains("Max parallelism mismatch"));
 		}
@@ -106,7 +108,7 @@ public class CheckpointMetadataLoadingTest {
 		final Map<JobVertexID, ExecutionJobVertex> tasks = Collections.emptyMap();
 
 		try {
-			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false);
+			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException expected) {
 			assertTrue(expected.getMessage().contains("allowNonRestoredState"));
@@ -124,7 +126,7 @@ public class CheckpointMetadataLoadingTest {
 		final CompletedCheckpointStorageLocation testSavepoint = createSavepointWithOperatorSubtaskState(242L, operatorId, parallelism);
 		final Map<JobVertexID, ExecutionJobVertex> tasks = Collections.emptyMap();
 
-		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, true);
+		final CompletedCheckpoint loaded = Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, true, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		assertTrue(loaded.getOperatorStates().isEmpty());
 	}
@@ -145,7 +147,7 @@ public class CheckpointMetadataLoadingTest {
 		final Map<JobVertexID, ExecutionJobVertex> tasks = Collections.emptyMap();
 
 		try {
-			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false);
+			Checkpoints.loadAndValidateCheckpoint(new JobID(), tasks, testSavepoint, cl, false, new CheckpointsUtils.NoOpCleanCheckpointCallback(), new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException expected) {
 			assertTrue(expected.getMessage().contains("allowNonRestoredState"));
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java
index f8f327091e7..9dd7c120fd1 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointRequestDeciderTest.java
@@ -47,7 +47,7 @@ public class CheckpointRequestDeciderTest {
 
 	@Test
 	public void testForce() {
-		CheckpointRequestDecider decider = decider(1, 1, Integer.MAX_VALUE, new AtomicInteger(1));
+		CheckpointRequestDecider decider = decider(1, 1, Integer.MAX_VALUE, new AtomicInteger(1), new AtomicInteger(0));
 		CheckpointTriggerRequest request = periodicSavepoint();
 		assertEquals(Optional.of(request), decider.chooseRequestToExecute(request, false, 123));
 	}
@@ -57,7 +57,7 @@ public class CheckpointRequestDeciderTest {
 		final int maxPending = 1;
 		final boolean isTriggering = false;
 		final AtomicInteger currentPending = new AtomicInteger(maxPending);
-		CheckpointRequestDecider decider = decider(Integer.MAX_VALUE, maxPending, 1, currentPending);
+		CheckpointRequestDecider decider = decider(Integer.MAX_VALUE, maxPending, 1, currentPending, new AtomicInteger(0));
 
 		CheckpointTriggerRequest request = regularCheckpoint();
 		assertFalse(decider.chooseRequestToExecute(request, isTriggering, 0).isPresent());
@@ -71,7 +71,8 @@ public class CheckpointRequestDeciderTest {
 		final int maxPending = 1;
 		final boolean isTriggering = false;
 		final AtomicInteger currentPending = new AtomicInteger(maxPending);
-		CheckpointRequestDecider decider = decider(Integer.MAX_VALUE, maxPending, 1, currentPending);
+		final AtomicInteger currentCleaning = new AtomicInteger(0);
+		CheckpointRequestDecider decider = decider(Integer.MAX_VALUE, maxPending, 1, currentPending, currentCleaning);
 
 		CheckpointTriggerRequest request = nonForcedSavepoint();
 		assertFalse(decider.chooseRequestToExecute(request, isTriggering, 0).isPresent());
@@ -80,6 +81,22 @@ public class CheckpointRequestDeciderTest {
 		assertEquals(Optional.of(request), decider.chooseQueuedRequestToExecute(isTriggering, 0));
 	}
 
+	@Test
+	public void testEnqueueOnTooManyCleaning() {
+		final boolean isTriggering = false;
+		int maxQueuedRequests = 10;
+		int maxConcurrentCheckpointAttempts = 10;
+		// too many cleaning threshold is currently maxConcurrentCheckpointAttempts
+		AtomicInteger currentCleaning = new AtomicInteger(maxConcurrentCheckpointAttempts + 1);
+		CheckpointRequestDecider decider = decider(maxQueuedRequests, maxConcurrentCheckpointAttempts, 1, new AtomicInteger(0), currentCleaning);
+
+		CheckpointTriggerRequest request = regularCheckpoint();
+		assertFalse(decider.chooseRequestToExecute(request, isTriggering, 0).isPresent());
+
+		// a checkpoint has been cleaned
+		currentCleaning.decrementAndGet();
+		assertEquals(Optional.of(request), decider.chooseQueuedRequestToExecute(isTriggering, 0));
+	}
 	@Test
 	public void testUserSubmittedPrioritized() {
 		CheckpointTriggerRequest userSubmitted = regularSavepoint();
@@ -165,7 +182,7 @@ public class CheckpointRequestDeciderTest {
 	private void testTiming(CheckpointTriggerRequest request, TriggerExpectation expectation) {
 		final long pause = 10;
 		final ManualClock clock = new ManualClock();
-		final CheckpointRequestDecider decider = new CheckpointRequestDecider(1, NO_OP, clock, pause, () -> 0, Integer.MAX_VALUE);
+		final CheckpointRequestDecider decider = new CheckpointRequestDecider(1, NO_OP, clock, pause, () -> 0, () -> 0, Integer.MAX_VALUE);
 
 		final long lastCompletionMs = clock.relativeTimeMillis();
 		final boolean isTriggering = false;
@@ -210,19 +227,19 @@ public class CheckpointRequestDeciderTest {
 	}
 
 	public CheckpointRequestDecider decider(int maxQueuedRequests) {
-		return decider(maxQueuedRequests, 1, 1, new AtomicInteger(0));
+		return decider(maxQueuedRequests, 1, 1, new AtomicInteger(0), new AtomicInteger(0));
 	}
 
-	private CheckpointRequestDecider decider(int maxQueued, int maxPending, int minPause, AtomicInteger currentPending) {
+	private CheckpointRequestDecider decider(int maxQueued, int maxPending, int minPause, AtomicInteger currentPending, AtomicInteger currentCleaning) {
 		ManualClock clock = new ManualClock();
 		clock.advanceTime(1, TimeUnit.DAYS);
-		return new CheckpointRequestDecider(maxPending, NO_OP, clock, minPause, currentPending::get, maxQueued);
+		return new CheckpointRequestDecider(maxPending, NO_OP, clock, minPause, currentPending::get, currentCleaning::get, maxQueued);
 	}
 
 	private static final Consumer<Long> NO_OP = unused -> {
 	};
 
-	private static CheckpointTriggerRequest regularCheckpoint() {
+	static CheckpointTriggerRequest regularCheckpoint() {
 		return checkpointRequest(true);
 	}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java
index ed04b212903..f74e3c39a36 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointStateRestoreTest.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.checkpoint;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTestingUtils.CheckpointCoordinatorBuilder;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.executiongraph.Execution;
@@ -33,6 +34,7 @@ import org.apache.flink.runtime.messages.checkpoint.AcknowledgeCheckpoint;
 import org.apache.flink.runtime.state.KeyGroupRange;
 import org.apache.flink.runtime.state.KeyedStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.SerializableObject;
 
 import org.hamcrest.BaseMatcher;
@@ -238,7 +240,9 @@ public class CheckpointStateRestoreTest {
 			new HashMap<>(checkpointTaskStates),
 			Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		coord.getCheckpointStore().addCheckpoint(checkpoint);
 
@@ -265,7 +269,9 @@ public class CheckpointStateRestoreTest {
 			new HashMap<>(checkpointTaskStates),
 			Collections.<MasterState>emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		coord.getCheckpointStore().addCheckpoint(checkpoint);
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java
index bdde3488754..eee285fd4fd 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointStoreTest.java
@@ -18,11 +18,14 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import java.util.concurrent.Executor;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.Assert;
@@ -48,8 +51,11 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 	/**
 	 * Creates the {@link CompletedCheckpointStore} implementation to be tested.
 	 */
-	protected abstract CompletedCheckpointStore createCompletedCheckpoints(
-			int maxNumberOfCheckpointsToRetain) throws Exception;
+	protected abstract CompletedCheckpointStore createCompletedCheckpoints(int maxNumberOfCheckpointsToRetain, Executor executor) throws Exception;
+
+	protected CompletedCheckpointStore createCompletedCheckpoints(int maxNumberOfCheckpointsToRetain) throws Exception {
+		return createCompletedCheckpoints(maxNumberOfCheckpointsToRetain, Executors.directExecutor());
+	}
 
 	// ---------------------------------------------------------------------------------------------
 
@@ -68,7 +74,7 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 	public void testAddAndGetLatestCheckpoint() throws Exception {
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 		CompletedCheckpointStore checkpoints = createCompletedCheckpoints(4);
-		
+
 		// Empty state
 		assertEquals(0, checkpoints.getNumberOfRetainedCheckpoints());
 		assertEquals(0, checkpoints.getAllCheckpoints().size());
@@ -213,7 +219,7 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 
 		operatorState.registerSharedStates(sharedStateRegistry);
 
-		return new TestCompletedCheckpoint(new JobID(), id, 0, operatorGroupState, props);
+		return new TestCompletedCheckpoint(new JobID(), id, 0, operatorGroupState, props, new CheckpointsCleaner()::cleanCheckpoint);
 	}
 
 	protected void verifyCheckpointRegistered(Collection<OperatorState> operatorStates, SharedStateRegistry registry) {
@@ -260,10 +266,10 @@ public abstract class CompletedCheckpointStoreTest extends TestLogger {
 				long checkpointId,
 				long timestamp,
 				Map<OperatorID, OperatorState> operatorGroupState,
-				CheckpointProperties props) {
+				CheckpointProperties props,
+				CheckpointsCleaningRunner checkpointsCleaningRunner) {
 
-			super(jobId, checkpointId, timestamp, Long.MAX_VALUE, operatorGroupState, null, props,
-					new TestCompletedCheckpointStorageLocation());
+			super(jobId, checkpointId, timestamp, Long.MAX_VALUE, operatorGroupState, null, props, new TestCompletedCheckpointStorageLocation(), checkpointsCleaningRunner, new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 		}
 
 		@Override
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java
index 453deb1469d..7cdf39940a3 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CompletedCheckpointTest.java
@@ -18,15 +18,19 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import java.io.Serializable;
+import java.util.function.Consumer;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.core.testutils.CommonTestUtils;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.state.SharedStateRegistry;
 import org.apache.flink.runtime.state.testutils.EmptyStreamStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -60,14 +64,18 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			new JobID(), 1, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -90,14 +98,18 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			new JobID(), 1, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -124,14 +136,18 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			jobID, 1, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -155,14 +171,18 @@ public class CompletedCheckpointTest {
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		CompletedCheckpoint checkpoint2 = new CompletedCheckpoint(
 			jobID2, 0, 0, 1,
 			new HashMap<>(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		List<CompletedCheckpoint> checkpoints1= new ArrayList<>();
 		checkpoints1.add(checkpoint1);
@@ -184,7 +204,9 @@ public class CompletedCheckpointTest {
 				operatorStates,
 				Collections.emptyList(),
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
-				new TestCompletedCheckpointStorageLocation());
+				new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 		checkpoint.registerSharedStatesAfterRestored(sharedStateRegistry);
@@ -211,7 +233,9 @@ public class CompletedCheckpointTest {
 				operatorStates,
 				Collections.emptyList(),
 				props,
-				location);
+				location,
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 		checkpoint.registerSharedStatesAfterRestored(sharedStateRegistry);
@@ -251,7 +275,9 @@ public class CompletedCheckpointTest {
 					new HashMap<>(operatorStates),
 					Collections.emptyList(),
 					retainProps,
-					retainedLocation);
+					retainedLocation,
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 			checkpoint.discardOnShutdown(status);
 
@@ -272,7 +298,9 @@ public class CompletedCheckpointTest {
 					new HashMap<>(operatorStates),
 					Collections.emptyList(),
 					discardProps,
-					discardLocation);
+					discardLocation,
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 			checkpoint.discardOnShutdown(status);
 
@@ -295,7 +323,9 @@ public class CompletedCheckpointTest {
 			Collections.emptyMap(),
 			Collections.emptyList(),
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new TestCompletedCheckpointStorageLocation());
+			new TestCompletedCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		CompletedCheckpointStats.DiscardCallback callback = mock(CompletedCheckpointStats.DiscardCallback.class);
 		completed.setDiscardCallback(callback);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
index 65c8dd7191f..f60737b0b95 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.checkpoint;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.executiongraph.Execution;
 import org.apache.flink.runtime.executiongraph.ExecutionGraph;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/FailoverStrategyCheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/FailoverStrategyCheckpointCoordinatorTest.java
index ddedf707b05..6059dbe22d5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/FailoverStrategyCheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/FailoverStrategyCheckpointCoordinatorTest.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import java.util.concurrent.Executor;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
@@ -81,8 +82,8 @@ public class FailoverStrategyCheckpointCoordinatorTest extends TestLogger {
 			Collections.emptyList(),
 			new StandaloneCheckpointIDCounter(),
 			new StandaloneCompletedCheckpointStore(1),
-			new MemoryStateBackend(),
-			Executors.directExecutor(),
+			new MemoryStateBackend(), Executors.directExecutor(),
+			new CheckpointsCleaner(),
 			manualThreadExecutor,
 			SharedStateRegistry.DEFAULT_FACTORY,
 			mock(CheckpointFailureManager.class));
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
index 30c1dc2bdd1..eff89e4965a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/PendingCheckpointTest.java
@@ -40,6 +40,7 @@ import org.apache.flink.runtime.state.TestingStreamStateHandle;
 import org.apache.flink.runtime.state.filesystem.FsCheckpointStorageLocation;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.hamcrest.Matchers;
 import org.junit.Assert;
 import org.junit.Rule;
@@ -178,7 +179,7 @@ public class PendingCheckpointTest {
 		assertFalse(future.isDone());
 		pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics());
 		assertTrue(pending.areTasksFullyAcknowledged());
-		pending.finalizeCheckpoint();
+		pending.finalizeCheckpoint(new CheckpointsUtils.NoOpCleanCheckpointCallback());
 		assertTrue(future.isDone());
 
 		// Finalize (missing ACKs)
@@ -187,7 +188,7 @@ public class PendingCheckpointTest {
 
 		assertFalse(future.isDone());
 		try {
-			pending.finalizeCheckpoint();
+			pending.finalizeCheckpoint(new CheckpointsUtils.NoOpCleanCheckpointCallback());
 			fail("Did not throw expected Exception");
 		} catch (IllegalStateException ignored) {
 			// Expected
@@ -263,7 +264,7 @@ public class PendingCheckpointTest {
 			pending.acknowledgeTask(ATTEMPT_ID, null, new CheckpointMetrics());
 			verify(callback, times(1)).reportSubtaskStats(nullable(JobVertexID.class), any(SubtaskStateStats.class));
 
-			pending.finalizeCheckpoint();
+			pending.finalizeCheckpoint(new CheckpointsUtils.NoOpCleanCheckpointCallback());
 			verify(callback, times(1)).reportCompletedCheckpoint(any(String.class));
 		}
 
@@ -560,7 +561,9 @@ public class PendingCheckpointTest {
 			props,
 			location,
 			executor,
-			new CompletableFuture<>());
+			new CompletableFuture<>(),
+			new CheckpointsCleaner(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 	}
 
 	@SuppressWarnings("unchecked")
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java
index 89a369f1a2a..be39b2811ad 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StandaloneCompletedCheckpointStoreTest.java
@@ -18,8 +18,10 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import java.util.concurrent.Executor;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.state.SharedStateRegistry;
 
 import org.junit.Test;
@@ -45,7 +47,7 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 
 	@Override
 	protected CompletedCheckpointStore createCompletedCheckpoints(
-		int maxNumberOfCheckpointsToRetain) throws Exception {
+		int maxNumberOfCheckpointsToRetain, Executor executor) throws Exception {
 
 		return new StandaloneCompletedCheckpointStore(maxNumberOfCheckpointsToRetain);
 	}
@@ -99,7 +101,7 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 	public void testAddCheckpointWithFailedRemove() throws Exception {
 
 		final int numCheckpointsToRetain = 1;
-		CompletedCheckpointStore store = createCompletedCheckpoints(numCheckpointsToRetain);
+		CompletedCheckpointStore store = createCompletedCheckpoints(numCheckpointsToRetain, Executors.directExecutor());
 
 		for (long i = 0; i <= numCheckpointsToRetain; ++i) {
 			CompletedCheckpoint checkpointToAdd = mock(CompletedCheckpoint.class);
@@ -165,7 +167,8 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 			checkpointId,
 			checkpointId,
 			Collections.emptyMap(),
-			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE));
+			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
+			new CheckpointsCleaner()::cleanCheckpoint);
 	}
 
 	private static CompletedCheckpoint savepoint(JobID jobId, long checkpointId) {
@@ -174,6 +177,7 @@ public class StandaloneCompletedCheckpointStoreTest extends CompletedCheckpointS
 			checkpointId,
 			checkpointId,
 			Collections.emptyMap(),
-			CheckpointProperties.forSavepoint(true));
+			CheckpointProperties.forSavepoint(true),
+			new CheckpointsCleaner()::cleanCheckpoint);
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java
index cd57eba831a..d94255963d6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreITCase.java
@@ -18,13 +18,17 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
-import org.apache.flink.runtime.concurrent.Executors;
+import org.apache.flink.api.common.time.Deadline;
+import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.runtime.state.SharedStateRegistry;
+import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.util.ZooKeeperUtils;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;
 import org.apache.flink.runtime.zookeeper.ZooKeeperTestEnvironment;
+import org.apache.flink.util.clock.ManualClock;
 
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
 import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.data.Stat;
@@ -34,12 +38,16 @@ import org.junit.Before;
 import org.junit.Test;
 
 import java.io.Serializable;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.apache.flink.runtime.checkpoint.CheckpointRequestDeciderTest.regularCheckpoint;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -68,7 +76,7 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 	}
 
 	@Override
-	protected ZooKeeperCompletedCheckpointStore createCompletedCheckpoints(int maxNumberOfCheckpointsToRetain) throws Exception {
+	protected ZooKeeperCompletedCheckpointStore createCompletedCheckpoints(int maxNumberOfCheckpointsToRetain, Executor executor) throws Exception {
 		final ZooKeeperStateHandleStore<CompletedCheckpoint> checkpointsInZooKeeper = ZooKeeperUtils.createZooKeeperStateHandleStore(
 			ZOOKEEPER.getClient(),
 			CHECKPOINT_PATH,
@@ -77,7 +85,7 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		return new ZooKeeperCompletedCheckpointStore(
 			maxNumberOfCheckpointsToRetain,
 			checkpointsInZooKeeper,
-			Executors.directExecutor());
+			executor);
 	}
 
 	// ---------------------------------------------------------------------------------------------
@@ -236,8 +244,8 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		final int numberOfCheckpoints = 1;
 		final long waitingTimeout = 50L;
 
-		ZooKeeperCompletedCheckpointStore zkCheckpointStore1 = createCompletedCheckpoints(numberOfCheckpoints);
-		ZooKeeperCompletedCheckpointStore zkCheckpointStore2 = createCompletedCheckpoints(numberOfCheckpoints);
+		CompletedCheckpointStore zkCheckpointStore1 = createCompletedCheckpoints(numberOfCheckpoints);
+		CompletedCheckpointStore zkCheckpointStore2 = createCompletedCheckpoints(numberOfCheckpoints);
 
 		SharedStateRegistry sharedStateRegistry = new SharedStateRegistry();
 
@@ -283,6 +291,51 @@ public class ZooKeeperCompletedCheckpointStoreITCase extends CompletedCheckpoint
 		recoveredTestCheckpoint.awaitDiscard();
 	}
 
+	/**
+	 * FLINK-17073 tests that there is no request triggered when there are too many checkpoints
+	 * waiting to clean and that it resumes when the number of waiting checkpoints as gone below
+	 * the threshold.
+	 *
+	 */
+	@Test
+	public void testChekpointingPausesAndResumeWhenTooManyCheckpoints() throws Exception{
+		ManualClock clock = new ManualClock();
+		clock.advanceTime(1, TimeUnit.DAYS);
+		int maxCleaningCheckpoints = 1;
+		CheckpointsCleaner checkpointsCleaner = new CheckpointsCleaner();
+		CheckpointRequestDecider checkpointRequestDecider =  new CheckpointRequestDecider(maxCleaningCheckpoints, unused ->{}, clock, 1, new AtomicInteger(0)::get, checkpointsCleaner::getNumberOfCheckpointsToClean);
+
+		final int maxCheckpointsToRetain = 1;
+		ManuallyTriggeredScheduledExecutor executor = new ManuallyTriggeredScheduledExecutor();
+		CompletedCheckpointStore checkpointStore = createCompletedCheckpoints(maxCheckpointsToRetain, executor);
+
+		int nbCheckpointsToInject = 3;
+		for (int i = 1; i <= nbCheckpointsToInject; i++) {
+			// add checkpoints to clean, the ManuallyTriggeredScheduledExecutor.execute() just queues the runnables but does not execute them.
+			TestCompletedCheckpoint completedCheckpoint = new TestCompletedCheckpoint(new JobID(), i,
+				i, Collections.emptyMap(), CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.RETAIN_ON_FAILURE),
+				checkpointsCleaner::cleanCheckpoint);
+			checkpointStore.addCheckpoint(completedCheckpoint);
+		}
+
+		int nbCheckpointsSubmittedForCleaning = nbCheckpointsToInject - maxCheckpointsToRetain;
+		// wait for cleaning request submission by checkpointsStore
+		CommonTestUtils.waitUntilCondition(() -> checkpointsCleaner.getNumberOfCheckpointsToClean() == nbCheckpointsSubmittedForCleaning, Deadline.fromNow(Duration.ofSeconds(3)));
+		assertEquals(nbCheckpointsSubmittedForCleaning, checkpointsCleaner.getNumberOfCheckpointsToClean());
+		// checkpointing is on hold because checkpointsCleaner.getNumberOfCheckpointsToClean() > maxCleaningCheckpoints
+		assertFalse(checkpointRequestDecider.chooseRequestToExecute(regularCheckpoint(), false, 0).isPresent());
+
+		//make the executor execute checkpoint requests.
+		executor.triggerAll();
+		// wait for a checkpoint to be cleaned
+		CommonTestUtils.waitUntilCondition(() -> checkpointsCleaner.getNumberOfCheckpointsToClean() < nbCheckpointsSubmittedForCleaning, Deadline.fromNow(Duration.ofSeconds(3)));
+		// some checkpoints were cleaned
+		assertTrue(checkpointsCleaner.getNumberOfCheckpointsToClean() < nbCheckpointsSubmittedForCleaning);
+		// checkpointing is resumed because checkpointsCleaner.getNumberOfCheckpointsToClean() <= maxCleaningCheckpoints
+		assertTrue(checkpointRequestDecider.chooseRequestToExecute(regularCheckpoint(), false, 0).isPresent());
+		checkpointStore.shutdown(JobStatus.FINISHED);
+	}
+
 	static class HeapRetrievableStateHandle<T extends Serializable> implements RetrievableStateHandle<T> {
 
 		private static final long serialVersionUID = -268548467968932L;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java
index a27f429ed62..5355d05c369 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ZooKeeperCompletedCheckpointStoreMockitoTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.runtime.zookeeper.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.zookeeper.ZooKeeperStateHandleStore;
 import org.apache.flink.util.TestLogger;
@@ -97,7 +98,9 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation()));
+				new TestCompletedCheckpointStorageLocation(),
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback()));
 
 		final RetrievableStateHandle<CompletedCheckpoint> retrievableStateHandle2 = mock(RetrievableStateHandle.class);
 		when(retrievableStateHandle2.retrieveState()).then(
@@ -109,7 +112,9 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation())));
+				new TestCompletedCheckpointStorageLocation(),
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback())));
 
 		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, "/foobar1"));
 		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, "/failing1"));
@@ -221,7 +226,9 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-				new TestCompletedCheckpointStorageLocation()));
+				new TestCompletedCheckpointStorageLocation(),
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback()));
 
 		final RetrievableStateHandle<CompletedCheckpoint> retrievableStateHandle2 = mock(RetrievableStateHandle.class);
 		when(retrievableStateHandle2.retrieveState()).then(
@@ -233,7 +240,9 @@ public class ZooKeeperCompletedCheckpointStoreMockitoTest extends TestLogger {
 				new HashMap<>(),
 				null,
 				CheckpointProperties.forSavepoint(true),
-				new TestCompletedCheckpointStorageLocation())));
+				new TestCompletedCheckpointStorageLocation(),
+				new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+				new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback())));
 
 		checkpointsInZooKeeper.add(Tuple2.of(retrievableStateHandle1, "/foobar1"));
 		checkpointsInZooKeeper.add(Tuple2.of(failingRetrievableStateHandle, "/failing1"));
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
index 7863b6639d6..5956d12d0ab 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
@@ -127,6 +127,7 @@ import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;
 import org.apache.flink.runtime.testtasks.BlockingNoOpInvokable;
 import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
+import org.apache.flink.runtime.util.CheckpointsUtils;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.testutils.ClassLoaderUtils;
 import org.apache.flink.util.ExceptionUtils;
@@ -827,7 +828,9 @@ public class JobMasterTest extends TestLogger {
 			Collections.emptyMap(),
 			null,
 			CheckpointProperties.forCheckpoint(CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION),
-			new DummyCheckpointStorageLocation());
+			new DummyCheckpointStorageLocation(),
+			new CheckpointsUtils.NoOpCleanCheckpointCallback(),
+			new CheckpointsUtils.NoOpCheckpointCleaningFinishedCallback());
 
 		final StandaloneCompletedCheckpointStore completedCheckpointStore = new StandaloneCompletedCheckpointStore(1);
 		completedCheckpointStore.addCheckpoint(completedCheckpoint);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/CheckpointsUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/CheckpointsUtils.java
new file mode 100644
index 00000000000..a476c9dc821
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/util/CheckpointsUtils.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.util;
+
+import java.util.concurrent.Executor;
+import org.apache.flink.runtime.checkpoint.CheckpointsCleaningRunner;
+import org.apache.flink.runtime.checkpoint.SerializableRunnable;
+
+public class CheckpointsUtils {
+	public static class NoOpCheckpointCleaningFinishedCallback implements SerializableRunnable {
+
+		@Override public void run() {
+		}
+	}
+
+	public static class NoOpCleanCheckpointCallback implements CheckpointsCleaningRunner {
+
+		@Override public void accept(Runnable cleanAction, Runnable postCleanAction,
+			Executor executor) {
+
+		}
+	}
+}
