diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/DataTypeExtractor.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/DataTypeExtractor.java
index aabeb7056ab..6bf98a1b488 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/DataTypeExtractor.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/DataTypeExtractor.java
@@ -228,7 +228,7 @@ public final class DataTypeExtractor {
 		// main work
 		DataType dataType = extractDataTypeOrRawWithTemplate(template, typeHierarchy, resolvedType);
 		// handle data views
-		dataType =  handleDataViewHints(dataType, clazz);
+		dataType = handleDataViewHints(dataType, clazz);
 		// final work
 		return closestBridging(dataType, clazz);
 	}
@@ -548,12 +548,6 @@ public final class DataTypeExtractor {
 				final DataType fieldDataType = extractDataTypeOrRaw(fieldTemplate, fieldTypeHierarchy, fieldType);
 				fieldDataTypes.put(field.getName(), fieldDataType);
 			} catch (Throwable t) {
-				// special case for fields of data views which are skipped in case of an error
-				if (DataView.class.isAssignableFrom(field.getDeclaringClass())) {
-					fieldDataTypes.put(field.getName(), DataTypes.NULL());
-					continue;
-				}
-
 				throw extractionError(
 					t,
 					"Error in field '%s' of class '%s'.",
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java
index ac03025829e..675911658e8 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/DataTypeExtractorTest.java
@@ -435,6 +435,15 @@ public class DataTypeExtractorTest {
 				.lookupExpects(PojoWithRawSelfReference.class)
 				.expectDataType(getPojoWithRawSelfReferenceDataType()),
 
+			TestSpec
+				.forType(
+					"Data view with invalid list element",
+					AccumulatorWithInvalidDefaultDataView.class)
+				.expectErrorMessage(
+					"Could not extract a data type from '" + ListView.class.getName()
+						+ "<" + Object.class.getName() + ">'. "
+						+ "Please pass the required data type manually or allow RAW types."),
+
 			TestSpec
 				.forType(
 					"Data view with default extraction",
@@ -1105,6 +1114,13 @@ public class DataTypeExtractorTest {
 
 	// --------------------------------------------------------------------------------------------
 
+	/**
+	 * Accumulator with invalid default extraction for data view.
+	 */
+	public static class AccumulatorWithInvalidDefaultDataView {
+		public ListView<Object> listView;
+	}
+
 	/**
 	 * Accumulator with default extraction for data view.
 	 */
diff --git a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java
index e6995b88ca4..40a2e5c5e11 100644
--- a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java
+++ b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/runtime/stream/sql/FunctionITCase.java
@@ -22,10 +22,12 @@ import org.apache.flink.api.common.ExecutionConfig;
 import org.apache.flink.api.java.typeutils.runtime.kryo.KryoSerializer;
 import org.apache.flink.table.annotation.DataTypeHint;
 import org.apache.flink.table.annotation.FunctionHint;
+import org.apache.flink.table.annotation.HintFlag;
 import org.apache.flink.table.annotation.InputGroup;
 import org.apache.flink.table.api.DataTypes;
 import org.apache.flink.table.api.Table;
 import org.apache.flink.table.api.ValidationException;
+import org.apache.flink.table.api.dataview.MapView;
 import org.apache.flink.table.catalog.Catalog;
 import org.apache.flink.table.catalog.CatalogFunction;
 import org.apache.flink.table.catalog.DataTypeFactory;
@@ -52,7 +54,9 @@ import java.time.LocalDateTime;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
+import java.util.stream.Collectors;
 
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -899,8 +903,8 @@ public class FunctionITCase extends StreamingTestBase {
 		);
 
 		final List<Row> sinkData = Arrays.asList(
-			Row.of("Jonathan"),
-			Row.of("Alice")
+			Row.of("Jonathan", "Alice=(Alice, 5), Bob=(Bob, 3), Jonathan=(Jonathan, 8)"),
+			Row.of("Alice", "Alice=(Alice, 5), Bob=(Bob, 3)")
 		);
 
 		TestCollectionTableFactory.reset();
@@ -910,14 +914,14 @@ public class FunctionITCase extends StreamingTestBase {
 			"CREATE TABLE SourceTable(ts TIMESTAMP(3), s STRING, WATERMARK FOR ts AS ts - INTERVAL '1' SECOND) " +
 				"WITH ('connector' = 'COLLECTION')");
 		tEnv().executeSql(
-			"CREATE TABLE SinkTable(s STRING) WITH ('connector' = 'COLLECTION')");
+			"CREATE TABLE SinkTable(s1 STRING, s2 STRING) WITH ('connector' = 'COLLECTION')");
 
-		tEnv().executeSql(
-			"CREATE FUNCTION LongestStringAggregateFunction AS '" + LongestStringAggregateFunction.class.getName() + "'");
+		tEnv().createTemporarySystemFunction("LongestStringAggregateFunction", LongestStringAggregateFunction.class);
+		tEnv().createTemporarySystemFunction("RawMapViewAggregateFunction", RawMapViewAggregateFunction.class);
 
 		tEnv().executeSql(
 			"INSERT INTO SinkTable " +
-			"SELECT LongestStringAggregateFunction(s) " +
+			"SELECT LongestStringAggregateFunction(s), RawMapViewAggregateFunction(s) " +
 			"FROM SourceTable " +
 			"GROUP BY TUMBLE(ts, INTERVAL '1' SECOND)").await();
 
@@ -1231,4 +1235,57 @@ public class FunctionITCase extends StreamingTestBase {
 			return (String) acc.getField(0);
 		}
 	}
+
+	/**
+	 * Aggregate function that tests raw types in map views.
+	 */
+	public static class RawMapViewAggregateFunction
+			extends AggregateFunction<String, RawMapViewAggregateFunction.AccWithRawView> {
+
+		/**
+		 * POJO is invalid and needs to be treated as raw type.
+		 */
+		public static class RawPojo {
+			public String a;
+			public int b;
+
+			public RawPojo(String s) {
+				this.a = s;
+				this.b = s.length();
+			}
+
+			@Override
+			public String toString() {
+				return "(" + a + ", " + b + ')';
+			}
+		}
+
+		/**
+		 * Accumulator with view that maps to raw type.
+		 */
+		public static class AccWithRawView {
+			@DataTypeHint(allowRawGlobally = HintFlag.TRUE)
+			public MapView<String, RawPojo> view = new MapView<>();
+		}
+
+		@Override
+		public AccWithRawView createAccumulator() {
+			return new AccWithRawView();
+		}
+
+		public void accumulate(AccWithRawView acc, String value) throws Exception {
+			if (value != null) {
+				acc.view.put(value, new RawPojo(value));
+			}
+		}
+
+		@Override
+		public String getValue(AccWithRawView acc) {
+			return acc.view.getMap().entrySet()
+				.stream()
+				.map(Objects::toString)
+				.sorted()
+				.collect(Collectors.joining(", "));
+		}
+	}
 }
