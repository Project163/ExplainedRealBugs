diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManager.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManager.java
index b2f83437ccc..31ff108a54e 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManager.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManager.java
@@ -207,17 +207,17 @@ public class KubernetesResourceManager extends ActiveResourceManager<KubernetesW
 					podWorkerResources.get(podName),
 					"Unrecognized pod {}. Pods from previous attempt should have already been added.", podName);
 
-				final int pendingNum = getNumPendingWorkersFor(workerResourceSpec);
+				final int pendingNum = getNumRequestedNotAllocatedWorkersFor(workerResourceSpec);
 				Preconditions.checkState(pendingNum > 0, "Should not receive more workers than requested.");
 
-				notifyNewWorkerAllocated(workerResourceSpec);
+				notifyNewWorkerAllocated(workerResourceSpec, resourceID);
 				final KubernetesWorkerNode worker = new KubernetesWorkerNode(resourceID);
 				workerNodes.put(resourceID, worker);
 
 				log.info("Received new TaskManager pod: {}", podName);
 			}
 			log.info("Received {} new TaskManager pods. Remaining pending pod requests: {}",
-				pods.size() - duplicatePodNum, getNumPendingWorkers());
+				pods.size() - duplicatePodNum, getNumRequestedNotAllocatedWorkers());
 		});
 	}
 
@@ -267,7 +267,7 @@ public class KubernetesResourceManager extends ActiveResourceManager<KubernetesW
 			createKubernetesTaskManagerParameters(workerResourceSpec);
 
 		podWorkerResources.put(parameters.getPodName(), workerResourceSpec);
-		final int pendingWorkerNum = notifyNewWorkerRequested(workerResourceSpec);
+		final int pendingWorkerNum = notifyNewWorkerRequested(workerResourceSpec).getNumNotAllocated();
 
 		log.info("Requesting new TaskManager pod with <{},{}>. Number pending requests {}.",
 			parameters.getTaskManagerMemoryMB(),
@@ -327,7 +327,7 @@ public class KubernetesResourceManager extends ActiveResourceManager<KubernetesW
 			final WorkerResourceSpec workerResourceSpec = entry.getKey();
 			final int requiredTaskManagers = entry.getValue();
 
-			while (requiredTaskManagers > getNumPendingWorkersFor(workerResourceSpec)) {
+			while (requiredTaskManagers > getNumRequestedNotRegisteredWorkersFor(workerResourceSpec)) {
 				requestKubernetesPod(workerResourceSpec);
 			}
 		}
@@ -360,6 +360,8 @@ public class KubernetesResourceManager extends ActiveResourceManager<KubernetesW
 			notifyNewWorkerAllocationFailed(
 				Preconditions.checkNotNull(workerResourceSpec,
 					"Worker resource spec of current attempt pending worker should be known."));
+		} else {
+			notifyAllocatedWorkerStopped(resourceId);
 		}
 	}
 
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerTest.java
index a1d034b0511..8aea7476359 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerTest.java
@@ -54,6 +54,7 @@ import org.apache.flink.runtime.resourcemanager.TaskExecutorRegistration;
 import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;
 import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
 import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerBuilder;
+import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerImpl;
 import org.apache.flink.runtime.resourcemanager.slotmanager.TestingSlotManagerBuilder;
 import org.apache.flink.runtime.resourcemanager.utils.MockResourceManagerRuntimeServices;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
@@ -178,8 +179,12 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 			return super.getMainThreadExecutor();
 		}
 
-		int getNumPendingWorkersForTesting() {
-			return getNumPendingWorkers();
+		int getNumRequestedNotAllocatedWorkersForTesting() {
+			return getNumRequestedNotAllocatedWorkers();
+		}
+
+		int getNumRequestedNotRegisteredWorkersForTesting() {
+			return getNumRequestedNotRegisteredWorkers();
 		}
 	}
 
@@ -232,7 +237,7 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 	}
 
 	@Test
-	public void testTaskManagerPodTerminated() throws Exception {
+	public void testTaskManagerPodTerminatedBeforeRegistration() throws Exception {
 		new Context() {{
 			runTest(() -> {
 				registerSlotRequest();
@@ -272,6 +277,57 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 		}};
 	}
 
+	@Test
+	public void testTaskManagerPodTerminatedAfterRegistration() throws Exception {
+		new Context() {{
+			runTest(() -> {
+				registerSlotRequest();
+				final Pod pod = kubeClient.pods().list().getItems().get(0);
+				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod)));
+				registerTaskExecutor(new ResourceID(pod.getMetadata().getName()));
+
+				// Terminate the pod. Should not request a new pod.
+				terminatePod(pod);
+				resourceManager.onModified(Collections.singletonList(new KubernetesPod(pod)));
+				assertEquals(0, kubeClient.pods().list().getItems().size());
+			});
+		}};
+	}
+
+	@Test
+	public void testTaskManagerPodErrorAfterRegistration() throws Exception {
+		new Context() {{
+			runTest(() -> {
+				registerSlotRequest();
+				final Pod pod = kubeClient.pods().list().getItems().get(0);
+				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod)));
+				registerTaskExecutor(new ResourceID(pod.getMetadata().getName()));
+
+				// Error happens in the pod. Should not request a new pod.
+				terminatePod(pod);
+				resourceManager.onError(Collections.singletonList(new KubernetesPod(pod)));
+				assertEquals(0, kubeClient.pods().list().getItems().size());
+			});
+		}};
+	}
+
+	@Test
+	public void testTaskManagerPodDeletedAfterRegistration() throws Exception {
+		new Context() {{
+			runTest(() -> {
+				registerSlotRequest();
+				final Pod pod = kubeClient.pods().list().getItems().get(0);
+				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod)));
+				registerTaskExecutor(new ResourceID(pod.getMetadata().getName()));
+
+				// Delete the pod. Should not request a new pod.
+				terminatePod(pod);
+				resourceManager.onDeleted(Collections.singletonList(new KubernetesPod(pod)));
+				assertEquals(0, kubeClient.pods().list().getItems().size());
+			});
+		}};
+	}
+
 	@Test
 	public void testGetWorkerNodesFromPreviousAttempts() throws Exception {
 		new Context() {{
@@ -364,7 +420,7 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 	}
 
 	@Test
-	public void testPreviousAttemptPodAdded() throws Exception {
+	public void testPreviousAttemptPodRegistered() throws Exception {
 		new Context() {{
 			runTest(() -> {
 				// Prepare previous attempt pod
@@ -376,11 +432,14 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 				resourceManager.initialize();
 
 				registerSlotRequest();
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotRegisteredWorkersForTesting(), is(1));
 
 				// adding previous attempt pod should not decrease pending worker count
 				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(previousAttemptPod)));
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(1));
+				registerTaskExecutor(new ResourceID(previousAttemptPodName));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotRegisteredWorkersForTesting(), is(1));
 
 				final Optional<Pod> currentAttemptPodOpt = kubeClient.pods().list().getItems().stream()
 					.filter(pod -> pod.getMetadata().getName().contains("-taskmanager-2-1"))
@@ -390,7 +449,9 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 
 				// adding current attempt pod should decrease the pending worker count
 				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(currentAttemptPod)));
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(0));
+				registerTaskExecutor(new ResourceID(currentAttemptPod.getMetadata().getName()));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(0));
+				assertThat(resourceManager.getNumRequestedNotRegisteredWorkersForTesting(), is(0));
 			});
 		}};
 	}
@@ -401,21 +462,21 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 			runTest(() -> {
 				registerSlotRequest();
 				registerSlotRequest();
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(2));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(2));
 
 				assertThat(kubeClient.pods().list().getItems().size(), is(2));
 				final Pod pod1 = kubeClient.pods().list().getItems().get(0);
 				final Pod pod2 = kubeClient.pods().list().getItems().get(1);
 
 				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod1)));
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(1));
 
 				// Adding duplicated pod should not increase pending worker count
 				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod1)));
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(1));
 
 				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod2)));
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(0));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(0));
 			});
 		}};
 	}
@@ -488,13 +549,16 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 
 			runTest(() -> {
 				registerSlotRequest();
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(1));
+				assertThat(resourceManager.getNumRequestedNotRegisteredWorkersForTesting(), is(1));
 
 				final Pod pod = kubeClient.pods().list().getItems().get(0);
 				resourceManager.onAdded(Collections.singletonList(new KubernetesPod(pod)));
 				trigger.complete(null);
 
-				assertThat(resourceManager.getNumPendingWorkersForTesting(), is(0));
+				registerTaskExecutor(new ResourceID(pod.getMetadata().getName()));
+				assertThat(resourceManager.getNumRequestedNotAllocatedWorkersForTesting(), is(0));
+				assertThat(resourceManager.getNumRequestedNotRegisteredWorkersForTesting(), is(0));
 			});
 		}};
 	}
@@ -503,6 +567,7 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 		TestingKubernetesResourceManager resourceManager = null;
 		SlotManager slotManager = null;
 		FlinkKubeClient flinkKubeClient = null;
+		ResourceProfile registerSlotProfile = ResourceProfile.ZERO;
 
 		void runTest(RunnableWithException testMethod) throws Exception {
 			if (slotManager == null) {
@@ -511,6 +576,7 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 				slotManager = SlotManagerBuilder.newBuilder()
 					.setDefaultWorkerResourceSpec(workerResourceSpec)
 					.build();
+				registerSlotProfile = SlotManagerImpl.generateDefaultSlotResourceProfile(workerResourceSpec, 1);
 			}
 
 			if (flinkKubeClient == null) {
@@ -565,15 +631,19 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 
 			final ResourceManagerGateway rmGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class);
 
-			final SlotReport slotReport = new SlotReport(new SlotStatus(new SlotID(resourceID, 1), ResourceProfile.ZERO));
+			final SlotReport slotReport = new SlotReport(new SlotStatus(new SlotID(resourceID, 1), registerSlotProfile));
+
+			final int numSlotsBeforeRegistering = CompletableFuture.supplyAsync(
+				() -> slotManager.getNumberRegisteredSlots(),
+				resourceManager.getMainThreadExecutorForTesting()).get();
 
 			TaskExecutorRegistration taskExecutorRegistration = new TaskExecutorRegistration(
 				resourceID.toString(),
 				resourceID,
 				1234,
 				new HardwareDescription(1, 2L, 3L, 4L),
-				ResourceProfile.ZERO,
-				ResourceProfile.ZERO);
+				registerSlotProfile,
+				registerSlotProfile);
 			CompletableFuture<Integer> numberRegisteredSlotsFuture = rmGateway
 				.registerTaskExecutor(
 					taskExecutorRegistration,
@@ -589,7 +659,7 @@ public class KubernetesResourceManagerTest extends KubernetesTestBase {
 							TIMEOUT);
 					})
 				.handleAsync(
-					(Acknowledge ignored, Throwable throwable) -> slotManager.getNumberRegisteredSlots(),
+					(Acknowledge ignored, Throwable throwable) -> slotManager.getNumberRegisteredSlots() - numSlotsBeforeRegistering,
 					resourceManager.getMainThreadExecutorForTesting());
 			Assert.assertEquals(1, numberRegisteredSlotsFuture.get().intValue());
 		}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ActiveResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ActiveResourceManager.java
index b5c05b71aa6..73f81001f6c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ActiveResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ActiveResourceManager.java
@@ -30,6 +30,7 @@ import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerFactory;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
+import org.apache.flink.runtime.resourcemanager.registration.WorkerRegistration;
 import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcService;
@@ -60,7 +61,11 @@ public abstract class ActiveResourceManager <WorkerType extends ResourceIDRetrie
 	/** Flink configuration uploaded by client. */
 	protected final Configuration flinkClientConfig;
 
-	private final PendingWorkerCounter pendingWorkerCounter;
+	private final PendingWorkerCounter requestedNotAllocatedWorkerCounter;
+	private final PendingWorkerCounter requestedNotRegisteredWorkerCounter;
+
+	/** Maps from worker's resource id to its resource spec. */
+	private final Map<ResourceID, WorkerResourceSpec> allocatedNotRegisteredWorkerResourceSpecs;
 
 	public ActiveResourceManager(
 			Configuration flinkConfig,
@@ -94,7 +99,9 @@ public abstract class ActiveResourceManager <WorkerType extends ResourceIDRetrie
 		// Load the flink config uploaded by flink client
 		this.flinkClientConfig = loadClientConfiguration();
 
-		pendingWorkerCounter = new PendingWorkerCounter();
+		requestedNotAllocatedWorkerCounter = new PendingWorkerCounter();
+		requestedNotRegisteredWorkerCounter = new PendingWorkerCounter();
+		allocatedNotRegisteredWorkerResourceSpecs = new HashMap<>();
 	}
 
 	protected CompletableFuture<Void> getStopTerminationFutureOrCompletedExceptionally(@Nullable Throwable exception) {
@@ -110,12 +117,25 @@ public abstract class ActiveResourceManager <WorkerType extends ResourceIDRetrie
 
 	protected abstract Configuration loadClientConfiguration();
 
-	protected int getNumPendingWorkers() {
-		return pendingWorkerCounter.getTotalNum();
+	@Override
+	protected void onTaskManagerRegistration(WorkerRegistration<WorkerType> workerTypeWorkerRegistration) {
+		notifyAllocatedWorkerRegistered(workerTypeWorkerRegistration.getResourceID());
+	}
+
+	protected int getNumRequestedNotAllocatedWorkers() {
+		return requestedNotAllocatedWorkerCounter.getTotalNum();
+	}
+
+	protected int getNumRequestedNotAllocatedWorkersFor(WorkerResourceSpec workerResourceSpec) {
+		return requestedNotAllocatedWorkerCounter.getNum(workerResourceSpec);
+	}
+
+	protected int getNumRequestedNotRegisteredWorkers() {
+		return requestedNotRegisteredWorkerCounter.getTotalNum();
 	}
 
-	protected int getNumPendingWorkersFor(WorkerResourceSpec workerResourceSpec) {
-		return pendingWorkerCounter.getNum(workerResourceSpec);
+	protected int getNumRequestedNotRegisteredWorkersFor(WorkerResourceSpec workerResourceSpec) {
+		return requestedNotRegisteredWorkerCounter.getNum(workerResourceSpec);
 	}
 
 	/**
@@ -123,17 +143,23 @@ public abstract class ActiveResourceManager <WorkerType extends ResourceIDRetrie
 	 * @param workerResourceSpec resource spec of the requested worker
 	 * @return updated number of pending workers for the given resource spec
 	 */
-	protected int notifyNewWorkerRequested(WorkerResourceSpec workerResourceSpec) {
-		return pendingWorkerCounter.increaseAndGet(workerResourceSpec);
+	protected PendingWorkerNums notifyNewWorkerRequested(WorkerResourceSpec workerResourceSpec) {
+		return new PendingWorkerNums(
+			requestedNotAllocatedWorkerCounter.increaseAndGet(workerResourceSpec),
+			requestedNotRegisteredWorkerCounter.increaseAndGet(workerResourceSpec));
 	}
 
 	/**
 	 * Notify that a worker with the given resource spec has been allocated.
 	 * @param workerResourceSpec resource spec of the requested worker
+	 * @param resourceID id of the allocated resource
 	 * @return updated number of pending workers for the given resource spec
 	 */
-	protected int notifyNewWorkerAllocated(WorkerResourceSpec workerResourceSpec) {
-		return pendingWorkerCounter.decreaseAndGet(workerResourceSpec);
+	protected PendingWorkerNums notifyNewWorkerAllocated(WorkerResourceSpec workerResourceSpec, ResourceID resourceID) {
+		allocatedNotRegisteredWorkerResourceSpecs.put(resourceID, workerResourceSpec);
+		return new PendingWorkerNums(
+			requestedNotAllocatedWorkerCounter.decreaseAndGet(workerResourceSpec),
+			requestedNotRegisteredWorkerCounter.getNum(workerResourceSpec));
 	}
 
 	/**
@@ -141,8 +167,58 @@ public abstract class ActiveResourceManager <WorkerType extends ResourceIDRetrie
 	 * @param workerResourceSpec resource spec of the requested worker
 	 * @return updated number of pending workers for the given resource spec
 	 */
-	protected int notifyNewWorkerAllocationFailed(WorkerResourceSpec workerResourceSpec) {
-		return pendingWorkerCounter.decreaseAndGet(workerResourceSpec);
+	protected PendingWorkerNums notifyNewWorkerAllocationFailed(WorkerResourceSpec workerResourceSpec) {
+		return new PendingWorkerNums(
+			requestedNotAllocatedWorkerCounter.decreaseAndGet(workerResourceSpec),
+			requestedNotRegisteredWorkerCounter.decreaseAndGet(workerResourceSpec));
+	}
+
+	/**
+	 * Notify that a worker with the given resource spec has been registered.
+	 * @param resourceID id of the registered worker resource
+	 */
+	private void notifyAllocatedWorkerRegistered(ResourceID resourceID) {
+		WorkerResourceSpec workerResourceSpec = allocatedNotRegisteredWorkerResourceSpecs.remove(resourceID);
+		if (workerResourceSpec == null) {
+			// ignore workers from previous attempt
+			return;
+		}
+		requestedNotRegisteredWorkerCounter.decreaseAndGet(workerResourceSpec);
+	}
+
+	/**
+	 * Notify that a worker with the given resource spec has been stopped.
+	 * @param resourceID id of the stopped worker resource
+	 */
+	protected void notifyAllocatedWorkerStopped(ResourceID resourceID) {
+		WorkerResourceSpec workerResourceSpec = allocatedNotRegisteredWorkerResourceSpecs.remove(resourceID);
+		if (workerResourceSpec == null) {
+			// ignore already registered workers
+			return;
+		}
+		requestedNotRegisteredWorkerCounter.decreaseAndGet(workerResourceSpec);
+	}
+
+	/**
+	 * Number of workers pending for allocation/registration.
+	 */
+	protected static class PendingWorkerNums {
+
+		private final int numNotAllocated;
+		private final int numNotRegistered;
+
+		private PendingWorkerNums(int numNotAllocated, int numNotRegistered) {
+			this.numNotAllocated = numNotAllocated;
+			this.numNotRegistered = numNotRegistered;
+		}
+
+		public int getNumNotAllocated() {
+			return numNotAllocated;
+		}
+
+		public int getNumNotRegistered() {
+			return numNotRegistered;
+		}
 	}
 
 	/**
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
index 8c83a38177e..0428f89b7f0 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
@@ -404,13 +404,19 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 		final WorkerRegistration<WorkerType> workerTypeWorkerRegistration = taskExecutors.get(taskManagerResourceId);
 
 		if (workerTypeWorkerRegistration.getInstanceID().equals(taskManagerRegistrationId)) {
-			slotManager.registerTaskManager(workerTypeWorkerRegistration, slotReport);
+			if (slotManager.registerTaskManager(workerTypeWorkerRegistration, slotReport)) {
+				onTaskManagerRegistration(workerTypeWorkerRegistration);
+			}
 			return CompletableFuture.completedFuture(Acknowledge.get());
 		} else {
 			return FutureUtils.completedExceptionally(new ResourceManagerException(String.format("Unknown TaskManager registration id %s.", taskManagerRegistrationId)));
 		}
 	}
 
+	protected void onTaskManagerRegistration(WorkerRegistration<WorkerType> workerTypeWorkerRegistration) {
+		// noop
+	}
+
 	@Override
 	public void heartbeatFromTaskManager(final ResourceID resourceID, final TaskExecutorHeartbeatPayload heartbeatPayload) {
 		taskManagerHeartbeatManager.receiveHeartbeat(resourceID, heartbeatPayload);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManager.java
index 3d9c7970c34..6ebbe01e323 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManager.java
@@ -108,8 +108,9 @@ public interface SlotManager extends AutoCloseable {
 	 *
 	 * @param taskExecutorConnection for the new task manager
 	 * @param initialSlotReport for the new task manager
+	 * @return True if the task manager has not been registered before and is registered successfully; otherwise false
 	 */
-	void registerTaskManager(TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport);
+	boolean registerTaskManager(TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport);
 
 	/**
 	 * Unregisters the task manager identified by the given instance id and its associated slots
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManagerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManagerImpl.java
index b02af3ffa3c..f48fd1e26e8 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManagerImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/SlotManagerImpl.java
@@ -427,9 +427,10 @@ public class SlotManagerImpl implements SlotManager {
 	 *
 	 * @param taskExecutorConnection for the new task manager
 	 * @param initialSlotReport for the new task manager
+	 * @return True if the task manager has not been registered before and is registered successfully; otherwise false
 	 */
 	@Override
-	public void registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {
+	public boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {
 		checkInit();
 
 		LOG.debug("Registering TaskManager {} under {} at the SlotManager.", taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());
@@ -437,11 +438,12 @@ public class SlotManagerImpl implements SlotManager {
 		// we identify task managers by their instance id
 		if (taskManagerRegistrations.containsKey(taskExecutorConnection.getInstanceID())) {
 			reportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);
+			return false;
 		} else {
 			if (isMaxSlotNumExceededAfterRegistration(initialSlotReport)) {
 				LOG.info("The total number of slots exceeds the max limitation {}, release the excess resource.", maxSlotNum);
 				resourceActions.releaseResource(taskExecutorConnection.getInstanceID(), new FlinkException("The total number of slots exceeds the max limitation."));
-				return;
+				return false;
 			}
 
 			// first register the TaskManager
@@ -466,6 +468,8 @@ public class SlotManagerImpl implements SlotManager {
 					slotStatus.getResourceProfile(),
 					taskExecutorConnection);
 			}
+
+			return true;
 		}
 
 	}
@@ -1193,7 +1197,7 @@ public class SlotManagerImpl implements SlotManager {
 	}
 
 	@VisibleForTesting
-	static ResourceProfile generateDefaultSlotResourceProfile(WorkerResourceSpec workerResourceSpec, int numSlotsPerWorker) {
+	public static ResourceProfile generateDefaultSlotResourceProfile(WorkerResourceSpec workerResourceSpec, int numSlotsPerWorker) {
 		return ResourceProfile.newBuilder()
 			.setCpuCores(workerResourceSpec.getCpuCores().divide(numSlotsPerWorker))
 			.setTaskHeapMemory(workerResourceSpec.getTaskHeapSize().divide(numSlotsPerWorker))
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TestingSlotManager.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TestingSlotManager.java
index 88f32abb745..590550ad219 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TestingSlotManager.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TestingSlotManager.java
@@ -119,8 +119,8 @@ public class TestingSlotManager implements SlotManager {
 	}
 
 	@Override
-	public void registerTaskManager(TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {
-
+	public boolean registerTaskManager(TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {
+		return true;
 	}
 
 	@Override
diff --git a/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManager.java b/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManager.java
index 26cc5581383..3de7937b055 100755
--- a/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManager.java
+++ b/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManager.java
@@ -375,6 +375,8 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 					final ResourceID resourceId = new ResourceID(containerStatus.getContainerId().toString());
 					final YarnWorkerNode yarnWorkerNode = workerNodeMap.remove(resourceId);
 
+					notifyAllocatedWorkerStopped(resourceId);
+
 					if (yarnWorkerNode != null) {
 						// Container completed unexpectedly ~> start a new one
 						requestYarnContainerIfRequired();
@@ -397,7 +399,7 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 
 			// if we are waiting for no further containers, we can go to the
 			// regular heartbeat interval
-			if (getNumPendingWorkers() <= 0) {
+			if (getNumRequestedNotAllocatedWorkers() <= 0) {
 				resourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis);
 			}
 		});
@@ -410,7 +412,7 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 	private void onContainersOfResourceAllocated(Resource resource, List<Container> containers) {
 		final List<WorkerResourceSpec> pendingWorkerResourceSpecs =
 			workerSpecContainerResourceAdapter.getWorkerSpecs(resource, matchingStrategy).stream()
-				.flatMap(spec -> Collections.nCopies(getNumPendingWorkersFor(spec), spec).stream())
+				.flatMap(spec -> Collections.nCopies(getNumRequestedNotAllocatedWorkersFor(spec), spec).stream())
 				.collect(Collectors.toList());
 
 		int numPending = pendingWorkerResourceSpecs.size();
@@ -429,9 +431,10 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 			final WorkerResourceSpec workerResourceSpec = pendingWorkerSpecIterator.next();
 			final Container container = containerIterator.next();
 			final AMRMClient.ContainerRequest pendingRequest = pendingRequestsIterator.next();
+			final ResourceID resourceId = getContainerResourceId(container);
 
-			notifyNewWorkerAllocated(workerResourceSpec);
-			startTaskExecutorInContainer(container, workerResourceSpec);
+			notifyNewWorkerAllocated(workerResourceSpec, resourceId);
+			startTaskExecutorInContainer(container, workerResourceSpec, resourceId);
 			removeContainerRequest(pendingRequest, workerResourceSpec);
 
 			numAccepted++;
@@ -448,16 +451,17 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 			numAccepted, numExcess, numPending, resource);
 	}
 
-	private void startTaskExecutorInContainer(Container container, WorkerResourceSpec workerResourceSpec) {
-		final String containerIdStr = container.getId().toString();
-		final ResourceID resourceId = new ResourceID(containerIdStr);
+	private static ResourceID getContainerResourceId(Container container) {
+		return new ResourceID(container.getId().toString());
+	}
 
+	private void startTaskExecutorInContainer(Container container, WorkerResourceSpec workerResourceSpec, ResourceID resourceId) {
 		workerNodeMap.put(resourceId, new YarnWorkerNode(container));
 
 		try {
 			// Context information used to start a TaskExecutor Java process
 			ContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(
-				containerIdStr,
+				resourceId.toString(),
 				container.getNodeId().getHost(),
 				TaskExecutorProcessUtils.processSpecFromWorkerResourceSpec(flinkConfig, workerResourceSpec));
 
@@ -476,6 +480,7 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 		// release the failed container
 		workerNodeMap.remove(resourceId);
 		resourceManagerClient.releaseAssignedContainer(containerId);
+		notifyAllocatedWorkerStopped(resourceId);
 		// and ask for a new one
 		requestYarnContainerIfRequired();
 	}
@@ -608,7 +613,7 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 	private void requestYarnContainerIfRequired() {
 		for (Map.Entry<WorkerResourceSpec, Integer> requiredWorkersPerResourceSpec : getRequiredResources().entrySet()) {
 			final WorkerResourceSpec workerResourceSpec = requiredWorkersPerResourceSpec.getKey();
-			while (requiredWorkersPerResourceSpec.getValue() > getNumPendingWorkersFor(workerResourceSpec)) {
+			while (requiredWorkersPerResourceSpec.getValue() > getNumRequestedNotRegisteredWorkersFor(workerResourceSpec)) {
 				final boolean requestContainerSuccess = requestYarnContainer(workerResourceSpec);
 				Preconditions.checkState(requestContainerSuccess,
 					"Cannot request container for worker resource spec {}.", workerResourceSpec);
@@ -624,7 +629,7 @@ public class YarnResourceManager extends ActiveResourceManager<YarnWorkerNode>
 
 			// make sure we transmit the request fast and receive fast news of granted allocations
 			resourceManagerClient.setHeartbeatInterval(containerRequestHeartbeatIntervalMillis);
-			int numPendingWorkers = notifyNewWorkerRequested(workerResourceSpec);
+			int numPendingWorkers = notifyNewWorkerRequested(workerResourceSpec).getNumNotAllocated();
 
 			log.info("Requesting new TaskExecutor container with resource {}. Number pending workers of this resource is {}.",
 				workerResourceSpec,
diff --git a/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerTest.java b/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerTest.java
index dd7995d049d..502201758ae 100755
--- a/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerTest.java
+++ b/flink-yarn/src/test/java/org/apache/flink/yarn/YarnResourceManagerTest.java
@@ -369,9 +369,12 @@ public class YarnResourceManagerTest extends TestLogger {
 	}
 
 	@Test
-	public void testStopWorker() throws Exception {
+	public void testStopWorkerAfterRegistration() throws Exception {
 		new Context() {{
-			final CompletableFuture<Void> addContainerRequestFuture = new CompletableFuture<>();
+			final List<CompletableFuture<Void>> addContainerRequestFutures = new ArrayList<>();
+			addContainerRequestFutures.add(new CompletableFuture<>());
+			addContainerRequestFutures.add(new CompletableFuture<>());
+			final AtomicInteger addContainerRequestFuturesNumCompleted = new AtomicInteger(0);
 			final CompletableFuture<Void> removeContainerRequestFuture = new CompletableFuture<>();
 			final CompletableFuture<Void> releaseAssignedContainerFuture = new CompletableFuture<>();
 			final CompletableFuture<Void> startContainerAsyncFuture = new CompletableFuture<>();
@@ -379,7 +382,8 @@ public class YarnResourceManagerTest extends TestLogger {
 
 			testingYarnAMRMClientAsync.setGetMatchingRequestsFunction(ignored ->
 				Collections.singletonList(Collections.singletonList(resourceManager.getContainerRequest(containerResource))));
-			testingYarnAMRMClientAsync.setAddContainerRequestConsumer((ignored1, ignored2) -> addContainerRequestFuture.complete(null));
+			testingYarnAMRMClientAsync.setAddContainerRequestConsumer((ignored1, ignored2) ->
+				addContainerRequestFutures.get(addContainerRequestFuturesNumCompleted.getAndIncrement()).complete(null));
 			testingYarnAMRMClientAsync.setRemoveContainerRequestConsumer((ignored1, ignored2) -> removeContainerRequestFuture.complete(null));
 			testingYarnAMRMClientAsync.setReleaseAssignedContainerConsumer((ignored1, ignored2) -> releaseAssignedContainerFuture.complete(null));
 			testingYarnNMClientAsync.setStartContainerAsyncConsumer((ignored1, ignored2, ignored3) -> startContainerAsyncFuture.complete(null));
@@ -393,7 +397,7 @@ public class YarnResourceManagerTest extends TestLogger {
 				Container testingContainer = createTestingContainer();
 
 				resourceManager.onContainersAllocated(ImmutableList.of(testingContainer));
-				verifyFutureCompleted(addContainerRequestFuture);
+				verifyFutureCompleted(addContainerRequestFutures.get(0));
 				verifyFutureCompleted(removeContainerRequestFuture);
 				verifyFutureCompleted(startContainerAsyncFuture);
 
@@ -450,6 +454,7 @@ public class YarnResourceManagerTest extends TestLogger {
 
 				verifyFutureCompleted(stopContainerAsyncFuture);
 				verifyFutureCompleted(releaseAssignedContainerFuture);
+				assertFalse(addContainerRequestFutures.get(1).isDone());
 			});
 
 			// It's now safe to access the SlotManager state since the ResourceManager has been stopped.
@@ -458,6 +463,43 @@ public class YarnResourceManagerTest extends TestLogger {
 		}};
 	}
 
+	@Test
+	public void testStopWorkerBeforeRegistration() throws Exception {
+		new Context() {{
+			final List<CompletableFuture<Void>> addContainerRequestFutures = new ArrayList<>();
+			addContainerRequestFutures.add(new CompletableFuture<>());
+			addContainerRequestFutures.add(new CompletableFuture<>());
+			final AtomicInteger addContainerRequestFuturesNumCompleted = new AtomicInteger(0);
+			final CompletableFuture<Void> removeContainerRequestFuture = new CompletableFuture<>();
+			final CompletableFuture<Void> startContainerAsyncFuture = new CompletableFuture<>();
+
+			testingYarnAMRMClientAsync.setGetMatchingRequestsFunction(ignored ->
+				Collections.singletonList(Collections.singletonList(resourceManager.getContainerRequest(containerResource))));
+			testingYarnAMRMClientAsync.setAddContainerRequestConsumer((ignored1, ignored2) ->
+				addContainerRequestFutures.get(addContainerRequestFuturesNumCompleted.getAndIncrement()).complete(null));
+			testingYarnAMRMClientAsync.setRemoveContainerRequestConsumer((ignored1, ignored2) -> removeContainerRequestFuture.complete(null));
+			testingYarnNMClientAsync.setStartContainerAsyncConsumer((ignored1, ignored2, ignored3) -> startContainerAsyncFuture.complete(null));
+
+			runTest(() -> {
+				// Request slot from SlotManager.
+				registerSlotRequest(resourceManager, rmServices, resourceProfile1, taskHost);
+
+				// Callback from YARN when container is allocated.
+				Container testingContainer = createTestingContainer();
+				resourceManager.onContainersAllocated(ImmutableList.of(testingContainer));
+
+				verifyFutureCompleted(addContainerRequestFutures.get(0));
+				verifyFutureCompleted(removeContainerRequestFuture);
+				verifyFutureCompleted(startContainerAsyncFuture);
+
+				ContainerStatus testingContainerStatus = createTestingContainerStatus(testingContainer.getId());
+				resourceManager.onContainersCompleted(ImmutableList.of(testingContainerStatus));
+
+				verifyFutureCompleted(addContainerRequestFutures.get(1));
+			});
+		}};
+	}
+
 	/**
 	 * Tests that application files are deleted when the YARN application master is de-registered.
 	 */
