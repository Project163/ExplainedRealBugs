diff --git a/flink-core/src/main/java/org/apache/flink/core/fs/CloseableRegistry.java b/flink-core/src/main/java/org/apache/flink/core/fs/CloseableRegistry.java
index 1c92f0b5275..fbe285d636e 100644
--- a/flink-core/src/main/java/org/apache/flink/core/fs/CloseableRegistry.java
+++ b/flink-core/src/main/java/org/apache/flink/core/fs/CloseableRegistry.java
@@ -20,6 +20,7 @@ package org.apache.flink.core.fs;
 
 import org.apache.flink.annotation.Internal;
 import org.apache.flink.util.AbstractAutoCloseableRegistry;
+import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.IOUtils;
 
 import javax.annotation.Nonnull;
@@ -73,4 +74,29 @@ public class CloseableRegistry
     public void doClose(List<Closeable> toClose) throws IOException {
         IOUtils.closeAllQuietly(reverse(toClose));
     }
+
+    /**
+     * Unregisters all given {@link Closeable} objects from this registry and closes all objects
+     * that are were actually registered. Suppressed (and collects) all exceptions that happen
+     * during closing and throws only when the all {@link Closeable} objects have been processed.
+     *
+     * @param toUnregisterAndClose closables to unregister and close.
+     * @throws IOException collects all exceptions encountered during closing of the given objects.
+     */
+    public void unregisterAndCloseAll(Closeable... toUnregisterAndClose) throws IOException {
+        IOException suppressed = null;
+        for (Closeable closeable : toUnregisterAndClose) {
+            if (unregisterCloseable(closeable)) {
+                try {
+                    closeable.close();
+                } catch (IOException ex) {
+                    suppressed = ExceptionUtils.firstOrSuppressed(ex, suppressed);
+                }
+            }
+        }
+
+        if (suppressed != null) {
+            throw suppressed;
+        }
+    }
 }
diff --git a/flink-core/src/test/java/org/apache/flink/core/fs/CloseableRegistryTest.java b/flink-core/src/test/java/org/apache/flink/core/fs/CloseableRegistryTest.java
index 5490df98bd0..ab584c0e630 100644
--- a/flink-core/src/test/java/org/apache/flink/core/fs/CloseableRegistryTest.java
+++ b/flink-core/src/test/java/org/apache/flink/core/fs/CloseableRegistryTest.java
@@ -20,9 +20,17 @@ package org.apache.flink.core.fs;
 
 import org.apache.flink.util.AbstractAutoCloseableRegistry;
 
+import org.junit.Assert;
+import org.junit.Test;
+
+import javax.annotation.Nullable;
+
 import java.io.Closeable;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
 
 /** Tests for the {@link CloseableRegistry}. */
 public class CloseableRegistryTest
@@ -55,4 +63,104 @@ public class CloseableRegistryTest
             }
         };
     }
+
+    @Test
+    public void testUnregisterAndCloseAll() throws IOException {
+        try (CloseableRegistry closeableRegistry = new CloseableRegistry()) {
+
+            int exTestSize = 5;
+            int nonExTestSize = 5;
+
+            List<TestClosable> registeredClosableList = new ArrayList<>(exTestSize + nonExTestSize);
+            for (int i = 0; i < nonExTestSize; ++i) {
+                registeredClosableList.add(new TestClosable());
+            }
+
+            unregisterAndCloseAllHelper(registeredClosableList, closeableRegistry, null);
+
+            for (int i = 0; i < exTestSize; ++i) {
+                // Register with exception messages from 1..6
+                registeredClosableList.add(new TestClosable(String.valueOf(1 + i)));
+            }
+
+            unregisterAndCloseAllHelper(
+                    registeredClosableList,
+                    closeableRegistry,
+                    ioex -> {
+                        // Check that error messages and suppressed exceptions are correctly
+                        // reported
+                        int checksum = 0;
+                        checksum += Integer.parseInt(ioex.getMessage());
+                        Throwable[] suppressed = ioex.getSuppressed();
+                        for (Throwable throwable : suppressed) {
+                            checksum += Integer.parseInt(throwable.getMessage());
+                        }
+                        // Checksum is sum from 1..6 = 15
+                        Assert.assertEquals(15, checksum);
+                    });
+
+            // Check that unregistered Closable isn't closed.
+            TestClosable unregisteredClosable = new TestClosable();
+            closeableRegistry.unregisterAndCloseAll(unregisteredClosable);
+            Assert.assertEquals(0, unregisteredClosable.getCallsToClose());
+        }
+    }
+
+    private void unregisterAndCloseAllHelper(
+            List<TestClosable> registeredClosableList,
+            CloseableRegistry closeableRegistry,
+            @Nullable Consumer<IOException> exceptionCheck)
+            throws IOException {
+        for (TestClosable testClosable : registeredClosableList) {
+            closeableRegistry.registerCloseable(testClosable);
+        }
+
+        try {
+            closeableRegistry.unregisterAndCloseAll(
+                    registeredClosableList.toArray(new Closeable[0]));
+            if (exceptionCheck != null) {
+                Assert.fail("Exception expected");
+            }
+        } catch (IOException expected) {
+            if (exceptionCheck != null) {
+                exceptionCheck.accept(expected);
+            }
+        }
+
+        for (TestClosable testClosable : registeredClosableList) {
+            Assert.assertEquals(1, testClosable.getCallsToClose());
+            testClosable.resetCallsToClose();
+        }
+    }
+
+    static class TestClosable implements Closeable {
+
+        private final AtomicInteger callsToClose;
+        private final String exceptionMessageOnClose;
+
+        TestClosable() {
+            this("");
+        }
+
+        TestClosable(String exceptionMessageOnClose) {
+            this.exceptionMessageOnClose = exceptionMessageOnClose;
+            this.callsToClose = new AtomicInteger(0);
+        }
+
+        @Override
+        public void close() throws IOException {
+            callsToClose.incrementAndGet();
+            if (exceptionMessageOnClose != null && exceptionMessageOnClose.length() > 0) {
+                throw new IOException(exceptionMessageOnClose);
+            }
+        }
+
+        public int getCallsToClose() {
+            return callsToClose.get();
+        }
+
+        public void resetCallsToClose() {
+            this.callsToClose.set(0);
+        }
+    }
 }
diff --git a/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloader.java b/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloader.java
index 0d111fd4164..2d64104e2da 100644
--- a/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloader.java
+++ b/flink-state-backends/flink-statebackend-rocksdb/src/main/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloader.java
@@ -35,7 +35,6 @@ import java.io.OutputStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 import java.util.stream.Collectors;
@@ -62,24 +61,13 @@ public class RocksDBStateDownloader extends RocksDBStateDataTransfer {
         CloseableRegistry internalCloser = new CloseableRegistry();
         // Make sure we also react to external close signals.
         closeableRegistry.registerCloseable(internalCloser);
-        List<CompletableFuture<Void>> futures = Collections.emptyList();
         try {
-            try {
-                futures =
-                        transferAllStateDataToDirectoryAsync(downloadRequests, internalCloser)
-                                .collect(Collectors.toList());
-                // Wait until either all futures completed successfully or one failed exceptionally.
-                FutureUtils.waitForAll(futures).get();
-            } finally {
-                // Unregister and close the internal closer. In a failure case, this should
-                // interrupt ongoing downloads.
-                if (closeableRegistry.unregisterCloseable(internalCloser)) {
-                    IOUtils.closeQuietly(internalCloser);
-                }
-            }
+            List<CompletableFuture<Void>> futures =
+                    transferAllStateDataToDirectoryAsync(downloadRequests, internalCloser)
+                            .collect(Collectors.toList());
+            // Wait until either all futures completed successfully or one failed exceptionally.
+            FutureUtils.completeAll(futures).get();
         } catch (Exception e) {
-            // Cleanup on exception: cancel all tasks and delete the created directories
-            futures.forEach(future -> future.cancel(true));
             downloadRequests.stream()
                     .map(StateHandleDownloadSpec::getDownloadDestination)
                     .map(Path::toFile)
@@ -92,6 +80,11 @@ public class RocksDBStateDownloader extends RocksDBStateDataTransfer {
             } else {
                 throw new FlinkRuntimeException("Failed to download data for state handles.", e);
             }
+        } finally {
+            // Unregister and close the internal closer.
+            if (closeableRegistry.unregisterCloseable(internalCloser)) {
+                IOUtils.closeQuietly(internalCloser);
+            }
         }
     }
 
@@ -137,15 +130,16 @@ public class RocksDBStateDownloader extends RocksDBStateDataTransfer {
             CloseableRegistry closeableRegistry)
             throws IOException {
 
-        FSDataInputStream inputStream = null;
-        OutputStream outputStream = null;
+        if (closeableRegistry.isClosed()) {
+            return;
+        }
 
         try {
-            inputStream = remoteFileHandle.openInputStream();
+            FSDataInputStream inputStream = remoteFileHandle.openInputStream();
             closeableRegistry.registerCloseable(inputStream);
 
             Files.createDirectories(restoreFilePath.getParent());
-            outputStream = Files.newOutputStream(restoreFilePath);
+            OutputStream outputStream = Files.newOutputStream(restoreFilePath);
             closeableRegistry.registerCloseable(outputStream);
 
             byte[] buffer = new byte[8 * 1024];
@@ -157,14 +151,12 @@ public class RocksDBStateDownloader extends RocksDBStateDataTransfer {
 
                 outputStream.write(buffer, 0, numBytes);
             }
-        } finally {
-            if (closeableRegistry.unregisterCloseable(inputStream)) {
-                inputStream.close();
-            }
-
-            if (closeableRegistry.unregisterCloseable(outputStream)) {
-                outputStream.close();
-            }
+            closeableRegistry.unregisterAndCloseAll(outputStream, inputStream);
+        } catch (Exception ex) {
+            // Quickly close all open streams. This also stops all concurrent downloads because they
+            // are registered with the same registry.
+            IOUtils.closeQuietly(closeableRegistry);
+            throw new IOException(ex);
         }
     }
 }
diff --git a/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java b/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java
index 2f903644797..5283d5814f4 100644
--- a/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java
+++ b/flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/RocksDBStateDownloaderTest.java
@@ -57,9 +57,9 @@ public class RocksDBStateDownloaderTest extends TestLogger {
     /** Test that the exception arose in the thread pool will rethrow to the main thread. */
     @Test
     public void testMultiThreadRestoreThreadPoolExceptionRethrow() {
-        SpecifiedException expectedException =
+        SpecifiedException expectedCause =
                 new SpecifiedException("throw exception while multi thread restore.");
-        StreamStateHandle stateHandle = new ThrowingStateHandle(expectedException);
+        StreamStateHandle stateHandle = new ThrowingStateHandle(expectedCause);
 
         Map<StateHandleID, StreamStateHandle> stateHandles = new HashMap<>(1);
         stateHandles.put(new StateHandleID("state1"), stateHandle);
@@ -82,7 +82,7 @@ public class RocksDBStateDownloaderTest extends TestLogger {
                     new CloseableRegistry());
             fail();
         } catch (Exception e) {
-            assertEquals(expectedException, e);
+            assertEquals(expectedCause, e.getCause());
         }
     }
 
