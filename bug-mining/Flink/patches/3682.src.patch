diff --git a/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java b/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java
index 60356d4f550..b5c5c7d72b4 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/runtime/leaderelection/ZooKeeperLeaderElectionITCase.java
@@ -18,7 +18,9 @@
 
 package org.apache.flink.test.runtime.leaderelection;
 
+import org.apache.flink.api.common.ExecutionConfig;
 import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.api.common.restartstrategy.RestartStrategies;
 import org.apache.flink.api.common.time.Deadline;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.ClusterOptions;
@@ -46,6 +48,7 @@ import org.junit.rules.TemporaryFolder;
 
 import javax.annotation.Nullable;
 
+import java.io.IOException;
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
 
@@ -141,13 +144,23 @@ public class ZooKeeperLeaderElectionITCase extends TestLogger {
 		return miniCluster.getDispatcherGatewayFuture().get();
 	}
 
-	private JobGraph createJobGraph(int parallelism) {
+	private JobGraph createJobGraph(int parallelism) throws IOException {
 		BlockingOperator.isBlocking = true;
 		final JobVertex vertex = new JobVertex("blocking operator");
 		vertex.setParallelism(parallelism);
 		vertex.setInvokableClass(BlockingOperator.class);
 
-		return new JobGraph("Blocking test job", vertex);
+		JobGraph jobGraph = new JobGraph("Blocking test job", vertex);
+
+		// explicitly allow restarts; this is necessary since the shutdown may result in the job failing and hence being
+		// removed from ZooKeeper. What happens to running jobs if the Dispatcher shuts down in an orderly fashion
+		// is undefined behavior. By allowing restarts we prevent the job from reaching a globally terminal state,
+		// causing it to be recovered by the next Dispatcher.
+		ExecutionConfig executionConfig = new ExecutionConfig();
+		executionConfig.setRestartStrategy(RestartStrategies.fixedDelayRestart(10, Duration.ofSeconds(10).toMillis()));
+		jobGraph.setExecutionConfig(executionConfig);
+
+		return jobGraph;
 	}
 
 	/**
