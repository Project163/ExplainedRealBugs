diff --git a/flink-core/src/main/java/org/apache/flink/api/common/typeutils/base/GenericArraySerializer.java b/flink-core/src/main/java/org/apache/flink/api/common/typeutils/base/GenericArraySerializer.java
index c72132d08f2..c4c11022bd4 100644
--- a/flink-core/src/main/java/org/apache/flink/api/common/typeutils/base/GenericArraySerializer.java
+++ b/flink-core/src/main/java/org/apache/flink/api/common/typeutils/base/GenericArraySerializer.java
@@ -72,7 +72,9 @@ public final class GenericArraySerializer<C> extends TypeSerializer<C[]> {
 		C[] copy = create(from.length);
 
 		for (int i = 0; i < copy.length; i++) {
-			copy[i] = this.componentSerializer.copy(from[i], this.componentSerializer.createInstance());
+			if (from[i] != null) {
+				copy[i] = this.componentSerializer.copy(from[i], this.componentSerializer.createInstance());
+			}
 		}
 
 		return copy;
diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ObjectArrayTypeInfo.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ObjectArrayTypeInfo.java
index 55128e68d53..664350ecc64 100644
--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ObjectArrayTypeInfo.java
+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ObjectArrayTypeInfo.java
@@ -27,7 +27,6 @@ import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
 import org.apache.flink.api.common.typeinfo.TypeInformation;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.common.typeutils.base.GenericArraySerializer;
-import org.apache.flink.api.java.tuple.Tuple;
 
 public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 
@@ -41,7 +40,7 @@ public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 		this.componentType = componentType;
 		this.componentInfo = (TypeInformation<C>) TypeExtractor.createTypeInfo(componentType);
 	}
-	
+
 	private ObjectArrayTypeInfo(Type arrayType, Type componentType, TypeInformation<C> componentInfo) {
 		this.arrayType = arrayType;
 		this.componentType = componentType;
@@ -64,7 +63,7 @@ public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 	public int getArity() {
 		return 1;
 	}
-	
+
 	@Override
 	public int getTotalFields() {
 		return 1;
@@ -73,7 +72,19 @@ public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 	@SuppressWarnings("unchecked")
 	@Override
 	public Class<T> getTypeClass() {
-		return (Class<T>) this.arrayType.getClass();
+		// if arrayType is a Class
+		if (arrayType instanceof Class) {
+			return (Class<T>) arrayType;
+		}
+
+		// if arrayType is a GenericArrayType
+		Class<?> componentClass = (Class<?>) ((ParameterizedType) componentType).getRawType();
+
+		try {
+			return (Class<T>) Class.forName("[L" + componentClass.getName() + ";");
+		} catch (ClassNotFoundException e) {
+			throw new RuntimeException("Cannot create non-generic type class.", e);
+		}
 	}
 
 	public Type getType() {
@@ -83,7 +94,7 @@ public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 	public Type getComponentType() {
 		return this.componentType;
 	}
-	
+
 	public TypeInformation<C> getComponentInfo() {
 		return componentInfo;
 	}
@@ -99,7 +110,7 @@ public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 		// use raw type for serializer if generic array type
 		if (this.componentType instanceof GenericArrayType) {
 			ParameterizedType paramType = (ParameterizedType) ((GenericArrayType) this.componentType).getGenericComponentType();
-			
+
 			return (TypeSerializer<T>) new GenericArraySerializer<C>((Class<C>) paramType.getRawType(),
 					this.componentInfo.createSerializer());
 		} else {
@@ -115,23 +126,23 @@ public class ObjectArrayTypeInfo<T, C> extends TypeInformation<T> {
 	// --------------------------------------------------------------------------------------------
 
 	public static <T, C> ObjectArrayTypeInfo<T, C> getInfoFor(Type type, TypeInformation<C> componentInfo) {
-		
 		// generic array type e.g. for Tuples
 		if (type instanceof GenericArrayType) {
 			GenericArrayType genericArray = (GenericArrayType) type;
 			return new ObjectArrayTypeInfo<T, C>(type, genericArray.getGenericComponentType(), componentInfo);
 		}
 		// for tuples without generics (e.g. generated by the TypeInformation parser)
-		else if (type instanceof Class<?> && ((Class<?>) type).isArray() && componentInfo.isTupleType()
-				&& type != Tuple.class) {
+		// and multidimensional arrays (e.g. in scala)
+		else if (type instanceof Class<?> && ((Class<?>) type).isArray()
+				&& BasicTypeInfo.getInfoFor((Class<?>) type) == null) {
 			return new ObjectArrayTypeInfo<T, C>(type, ((Class<?>) type).getComponentType(), componentInfo);
 		}
-		return getInfoFor(type);
+		throw new InvalidTypesException("The given type is not a valid object array.");
 	}
-	
+
 	@SuppressWarnings("unchecked")
 	public static <T, C> ObjectArrayTypeInfo<T, C> getInfoFor(Type type) {
-		// class type e.g. for custom objects
+		// class type e.g. for POJOs
 		if (type instanceof Class<?> && ((Class<?>) type).isArray() && BasicTypeInfo.getInfoFor((Class<C>) type) == null) {
 			Class<C> array = (Class<C>) type;
 			return new ObjectArrayTypeInfo<T, C>(type, array.getComponentType());
diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
index a1f5dd6fbcd..99292a6398a 100644
--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
@@ -766,6 +766,24 @@ public class TypeExtractor {
 							+ clazz.getCanonicalName() + "'.");
 				}
 			}
+			// check for primitive array
+			else if (typeInfo instanceof PrimitiveArrayTypeInfo) {
+				Type component = null;
+				// check if array at all
+				if (!(type instanceof Class<?> && ((Class<?>) type).isArray() && (component = ((Class<?>) type).getComponentType()) != null)
+						&& !(type instanceof GenericArrayType && (component = ((GenericArrayType) type).getGenericComponentType()) != null)) {
+					throw new InvalidTypesException("Array type expected.");
+				}
+				if (component instanceof TypeVariable<?>) {
+					component = materializeTypeVariable(typeHierarchy, (TypeVariable<?>) component);
+					if (component instanceof TypeVariable) {
+						return;
+					}
+				}
+				if (!(component instanceof Class<?> && ((Class<?>)component).isPrimitive())) {
+					throw new InvalidTypesException("Primitive component expected.");
+				}
+			}
 			// check for basic array
 			else if (typeInfo instanceof BasicArrayTypeInfo<?, ?>) {
 				Type component = null;
diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java
index 6890d0c7cc5..2e04acab03a 100644
--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java
+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeInfoParser.java
@@ -37,19 +37,16 @@ public class TypeInfoParser {
 	private static final String WRITABLE_PACKAGE = "org.apache.hadoop.io";
 
 	private static final Pattern tuplePattern = Pattern.compile("^((" + TUPLE_PACKAGE.replaceAll("\\.", "\\\\.") + "\\.)?Tuple[0-9]+)<");
-	private static final Pattern writablePattern = Pattern.compile("^((" + WRITABLE_PACKAGE.replaceAll("\\.", "\\\\.") + "\\.)?Writable)<([^\\s,>]*)(,|>|$)");
-	private static final Pattern enumPattern = Pattern.compile("^((java\\.lang\\.)?Enum)<([^\\s,>]*)(,|>|$)");
+	private static final Pattern writablePattern = Pattern.compile("^((" + WRITABLE_PACKAGE.replaceAll("\\.", "\\\\.") + "\\.)?Writable)<([^\\s,>]*)(,|>|$|\\[)");
+	private static final Pattern enumPattern = Pattern.compile("^((java\\.lang\\.)?Enum)<([^\\s,>]*)(,|>|$|\\[)");
 	private static final Pattern basicTypePattern = Pattern
-			.compile("^((java\\.lang\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean|Void))(,|>|$)");
-	private static final Pattern basicTypeDatePattern = Pattern.compile("^((java\\.util\\.)?Date)(,|>|$)");
-	private static final Pattern basicType2Pattern = Pattern.compile("^(int|byte|short|char|double|float|long|boolean|void)(,|>|$)");
+			.compile("^((java\\.lang\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean|Void))(,|>|$|\\[)");
+	private static final Pattern basicTypeDatePattern = Pattern.compile("^((java\\.util\\.)?Date)(,|>|$|\\[)");
+	private static final Pattern primitiveTypePattern = Pattern.compile("^(int|byte|short|char|double|float|long|boolean|void)(,|>|$|\\[)");
 	private static final Pattern valueTypePattern = Pattern.compile("^((" + VALUE_PACKAGE.replaceAll("\\.", "\\\\.")
-			+ "\\.)?(String|Int|Byte|Short|Char|Double|Float|Long|Boolean|List|Map|Null))Value(,|>|$)");
-	private static final Pattern basicArrayTypePattern = Pattern
-			.compile("^((java\\.lang\\.)?(String|Integer|Byte|Short|Character|Double|Float|Long|Boolean))\\[\\](,|>|$)");
-	private static final Pattern basicArrayType2Pattern = Pattern.compile("^(int|byte|short|char|double|float|long|boolean)\\[\\](,|>|$)");
-	private static final Pattern pojoGenericObjectPattern = Pattern.compile("^([^\\s,<>]+)(<)?");
-	private static final Pattern fieldPattern = Pattern.compile("^([^\\s,<>]+)=");
+			+ "\\.)?(String|Int|Byte|Short|Char|Double|Float|Long|Boolean|List|Map|Null))Value(,|>|$|\\[)");
+	private static final Pattern pojoGenericObjectPattern = Pattern.compile("^([^\\s,<>\\[]+)(<)?");
+	private static final Pattern fieldPattern = Pattern.compile("^([^\\s,<>\\[]+)=");
 
 	/**
 	 * Generates an instance of <code>TypeInformation</code> by parsing a type
@@ -82,7 +79,6 @@ public class TypeInfoParser {
 	 */
 	@SuppressWarnings("unchecked")
 	public static <X> TypeInformation<X> parse(String infoString) {
-
 		try {
 			if (infoString == null) {
 				throw new IllegalArgumentException("String is null.");
@@ -91,7 +87,12 @@ public class TypeInfoParser {
 			if (clearedString.length() == 0) {
 				throw new IllegalArgumentException("String must not be empty.");
 			}
-			return (TypeInformation<X>) parse(new StringBuilder(clearedString));
+			StringBuilder sb = new StringBuilder(clearedString);
+			TypeInformation<X> ti = (TypeInformation<X>) parse(sb);
+			if (sb.length() > 0) {
+				throw new IllegalArgumentException("String could not be parsed completely.");
+			}
+			return ti;
 		} catch (Exception e) {
 			throw new IllegalArgumentException("String could not be parsed: " + e.getMessage(), e);
 		}
@@ -107,12 +108,10 @@ public class TypeInfoParser {
 
 		final Matcher basicTypeMatcher = basicTypePattern.matcher(infoString);
 		final Matcher basicTypeDateMatcher = basicTypeDatePattern.matcher(infoString);
-		final Matcher basicType2Matcher = basicType2Pattern.matcher(infoString);
 
-		final Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);
+		final Matcher primitiveTypeMatcher = primitiveTypePattern.matcher(infoString);
 
-		final Matcher basicArrayTypeMatcher = basicArrayTypePattern.matcher(infoString);
-		final Matcher basicArrayType2Matcher = basicArrayType2Pattern.matcher(infoString);
+		final Matcher valueTypeMatcher = valueTypePattern.matcher(infoString);
 
 		final Matcher pojoGenericMatcher = pojoGenericObjectPattern.matcher(infoString);
 
@@ -121,6 +120,7 @@ public class TypeInfoParser {
 		}
 
 		TypeInformation<?> returnType = null;
+		boolean isPrimitiveType = false;
 
 		// tuples
 		if (tupleMatcher.find()) {
@@ -131,9 +131,9 @@ public class TypeInfoParser {
 			Class<?> clazz;
 			// check if fully qualified
 			if (className.startsWith(TUPLE_PACKAGE)) {
-				clazz = Class.forName(className);
+				clazz = loadClass(className);
 			} else {
-				clazz = Class.forName(TUPLE_PACKAGE + "." + className);
+				clazz = loadClass(TUPLE_PACKAGE + "." + className);
 			}
 
 			TypeInformation<?>[] types = new TypeInformation<?>[arity];
@@ -148,25 +148,7 @@ public class TypeInfoParser {
 			}
 			// remove '>'
 			sb.deleteCharAt(0);
-
-			// tuple arrays
-			if (sb.length() > 0) {
-				if (sb.length() >= 2 && sb.charAt(0) == '[' && sb.charAt(1) == ']') {
-					Class<?> arrayClazz;
-					// check if fully qualified
-					if (className.startsWith(TUPLE_PACKAGE)) {
-						arrayClazz = Class.forName("[L" + className + ";");
-					} else {
-						arrayClazz = Class.forName("[L" + TUPLE_PACKAGE + "." + className + ";");
-					}
-					sb.delete(0, 2);
-					returnType = ObjectArrayTypeInfo.getInfoFor(arrayClazz, new TupleTypeInfo(clazz, types));
-				} else if (sb.length() < 1 || sb.charAt(0) != '[') {
-					returnType = new TupleTypeInfo(clazz, types);
-				}
-			} else {
-				returnType = new TupleTypeInfo(clazz, types);
-			}
+			returnType = new TupleTypeInfo(clazz, types);
 		}
 		// writable types
 		else if (writableMatcher.find()) {
@@ -184,16 +166,16 @@ public class TypeInfoParser {
 			Class<?> clazz = loadClass(fullyQualifiedName);
 			returnType = new EnumTypeInfo(clazz);
 		}
-		// basic types of classes
+		// basic types
 		else if (basicTypeMatcher.find()) {
 			String className = basicTypeMatcher.group(1);
 			sb.delete(0, className.length());
 			Class<?> clazz;
 			// check if fully qualified
 			if (className.startsWith("java.lang")) {
-				clazz = Class.forName(className);
+				clazz = loadClass(className);
 			} else {
-				clazz = Class.forName("java.lang." + className);
+				clazz = loadClass("java.lang." + className);
 			}
 			returnType = BasicTypeInfo.getInfoFor(clazz);
 		}
@@ -204,38 +186,39 @@ public class TypeInfoParser {
 			Class<?> clazz;
 			// check if fully qualified
 			if (className.startsWith("java.util")) {
-				clazz = Class.forName(className);
+				clazz = loadClass(className);
 			} else {
-				clazz = Class.forName("java.util." + className);
+				clazz = loadClass("java.util." + className);
 			}
 			returnType = BasicTypeInfo.getInfoFor(clazz);
 		}
-		// basic type of primitives
-		else if (basicType2Matcher.find()) {
-			String className = basicType2Matcher.group(1);
-			sb.delete(0, className.length());
+		// primitive types
+		else if (primitiveTypeMatcher.find()) {
+			String keyword = primitiveTypeMatcher.group(1);
+			sb.delete(0, keyword.length());
 
 			Class<?> clazz = null;
-			if (className.equals("int")) {
-				clazz = Integer.class;
-			} else if (className.equals("byte")) {
-				clazz = Byte.class;
-			} else if (className.equals("short")) {
-				clazz = Short.class;
-			} else if (className.equals("char")) {
-				clazz = Character.class;
-			} else if (className.equals("double")) {
-				clazz = Double.class;
-			} else if (className.equals("float")) {
-				clazz = Float.class;
-			} else if (className.equals("long")) {
-				clazz = Long.class;
-			} else if (className.equals("boolean")) {
-				clazz = Boolean.class;
-			} else if (className.equals("void")) {
-				clazz = Void.class;
+			if (keyword.equals("int")) {
+				clazz = int.class;
+			} else if (keyword.equals("byte")) {
+				clazz = byte.class;
+			} else if (keyword.equals("short")) {
+				clazz = short.class;
+			} else if (keyword.equals("char")) {
+				clazz = char.class;
+			} else if (keyword.equals("double")) {
+				clazz = double.class;
+			} else if (keyword.equals("float")) {
+				clazz = float.class;
+			} else if (keyword.equals("long")) {
+				clazz = long.class;
+			} else if (keyword.equals("boolean")) {
+				clazz = boolean.class;
+			} else if (keyword.equals("void")) {
+				clazz = void.class;
 			}
 			returnType = BasicTypeInfo.getInfoFor(clazz);
+			isPrimitiveType = true;
 		}
 		// values
 		else if (valueTypeMatcher.find()) {
@@ -245,50 +228,12 @@ public class TypeInfoParser {
 			Class<?> clazz;
 			// check if fully qualified
 			if (className.startsWith(VALUE_PACKAGE)) {
-				clazz = Class.forName(className + "Value");
+				clazz = loadClass(className + "Value");
 			} else {
-				clazz = Class.forName(VALUE_PACKAGE + "." + className + "Value");
+				clazz = loadClass(VALUE_PACKAGE + "." + className + "Value");
 			}
 			returnType = ValueTypeInfo.getValueTypeInfo((Class<Value>) clazz);
 		}
-		// array of basic classes
-		else if (basicArrayTypeMatcher.find()) {
-			String className = basicArrayTypeMatcher.group(1);
-			sb.delete(0, className.length() + 2);
-
-			Class<?> clazz;
-			if (className.startsWith("java.lang")) {
-				clazz = Class.forName("[L" + className + ";");
-			} else {
-				clazz = Class.forName("[Ljava.lang." + className + ";");
-			}
-			returnType = BasicArrayTypeInfo.getInfoFor(clazz);
-		}
-		// array of primitives
-		else if (basicArrayType2Matcher.find()) {
-			String className = basicArrayType2Matcher.group(1);
-			sb.delete(0, className.length() + 2);
-
-			Class<?> clazz = null;
-			if (className.equals("int")) {
-				clazz = int[].class;
-			} else if (className.equals("byte")) {
-				clazz = byte[].class;
-			} else if (className.equals("short")) {
-				clazz = short[].class;
-			} else if (className.equals("char")) {
-				clazz = char[].class;
-			} else if (className.equals("double")) {
-				clazz = double[].class;
-			} else if (className.equals("float")) {
-				clazz = float[].class;
-			} else if (className.equals("long")) {
-				clazz = long[].class;
-			} else if (className.equals("boolean")) {
-				clazz = boolean[].class;
-			}
-			returnType = PrimitiveArrayTypeInfo.getInfoFor(clazz);
-		}
 		// pojo objects or generic types
 		else if (pojoGenericMatcher.find()) {
 			String fullyQualifiedName = pojoGenericMatcher.group(1);
@@ -296,6 +241,7 @@ public class TypeInfoParser {
 
 			boolean isPojo = pojoGenericMatcher.group(2) != null;
 
+			// pojo
 			if (isPojo) {
 				sb.deleteCharAt(0);
 				Class<?> clazz = loadClass(fullyQualifiedName);
@@ -315,28 +261,107 @@ public class TypeInfoParser {
 					}
 					fields.add(new PojoField(field, parse(sb)));
 				}
+				sb.deleteCharAt(0); // remove '>'
 				returnType = new PojoTypeInfo(clazz, fields);
 			}
+			// generic type
 			else {
-				// custom object array
-				if (fullyQualifiedName.endsWith("[]")) {
-					fullyQualifiedName = fullyQualifiedName.substring(0, fullyQualifiedName.length() - 2);
-					returnType = ObjectArrayTypeInfo.getInfoFor(loadClass("[L" + fullyQualifiedName + ";"));
-				} else {
-					returnType = new GenericTypeInfo(loadClass(fullyQualifiedName));
-				}
+				returnType = new GenericTypeInfo(loadClass(fullyQualifiedName));
 			}
 		}
 
 		if (returnType == null) {
 			throw new IllegalArgumentException("Error at '" + infoString + "'");
-		} else {
-			// remove possible ','
-			if (sb.length() > 0 && sb.charAt(0) == ',') {
-				sb.deleteCharAt(0);
+		}
+
+		// arrays
+		int arrayDimensionCount = 0;
+		while (sb.length() > 1 && sb.charAt(0) == '[' && sb.charAt(1) == ']') {
+			arrayDimensionCount++;
+			sb.delete(0, 2);
+		}
+
+		if (sb.length() > 0 && sb.charAt(0) == '[') {
+			throw new IllegalArgumentException("Closing square bracket missing.");
+		}
+		
+		// construct multidimension array
+		if (arrayDimensionCount > 0) {
+			TypeInformation<?> arrayInfo = null;
+			
+			// first dimension
+			// primitive array
+			if (isPrimitiveType) {
+				if (returnType == BasicTypeInfo.INT_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.BYTE_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.BYTE_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.SHORT_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.SHORT_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.CHAR_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.CHAR_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.DOUBLE_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.DOUBLE_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.FLOAT_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.FLOAT_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.LONG_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.LONG_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.BOOLEAN_TYPE_INFO) {
+					arrayInfo = PrimitiveArrayTypeInfo.BOOLEAN_PRIMITIVE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.VOID_TYPE_INFO) {
+					throw new IllegalArgumentException("Can not create an array of void.");
+				}
+			}
+			// basic array
+			else if (returnType instanceof BasicTypeInfo
+					&& returnType != BasicTypeInfo.DATE_TYPE_INFO) {
+				if (returnType == BasicTypeInfo.INT_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.BYTE_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.BYTE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.SHORT_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.SHORT_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.CHAR_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.CHAR_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.DOUBLE_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.DOUBLE_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.FLOAT_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.FLOAT_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.LONG_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.LONG_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.BOOLEAN_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.BOOLEAN_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.STRING_TYPE_INFO) {
+					arrayInfo = BasicArrayTypeInfo.STRING_ARRAY_TYPE_INFO;
+				} else if (returnType == BasicTypeInfo.VOID_TYPE_INFO) {
+					throw new IllegalArgumentException("Can not create an array of void.");
+				}
+			}
+			// object array
+			else {
+				arrayInfo = ObjectArrayTypeInfo.getInfoFor(loadClass("[L" + returnType.getTypeClass().getName() + ";"),
+						returnType);
+			}
+
+			// further dimensions
+			if (arrayDimensionCount > 1) {
+				String arrayPrefix = "[";
+				for (int i = 1; i < arrayDimensionCount; i++) {
+					arrayPrefix += "[";
+					arrayInfo =  ObjectArrayTypeInfo.getInfoFor(loadClass(arrayPrefix + "L" +
+							returnType.getTypeClass().getName() + ";"), arrayInfo);
+				}
 			}
-			return returnType;
+			returnType = arrayInfo;
 		}
+
+		// remove possible ','
+		if (sb.length() > 0 && sb.charAt(0) == ',') {
+			sb.deleteCharAt(0);
+		}
+
+		// check if end 
+		return returnType;
 	}
 
 	private static Class<?> loadClass(String fullyQualifiedName) {
diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ValueTypeInfo.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ValueTypeInfo.java
index 2e40ff9832f..79a27607a83 100644
--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ValueTypeInfo.java
+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/ValueTypeInfo.java
@@ -126,7 +126,7 @@ public class ValueTypeInfo<T extends Value> extends TypeInformation<T> implement
 	
 	@Override
 	public String toString() {
-		return "ValueType<" + type.getName() + ">";
+		return "ValueType<" + type.getSimpleName() + ">";
 	}
 	
 	// --------------------------------------------------------------------------------------------
diff --git a/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java b/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java
index bc36241b24a..f234ed56860 100644
--- a/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java
+++ b/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java
@@ -314,7 +314,7 @@ public class TypeExtractorTest {
 
 	@SuppressWarnings({ "unchecked", "rawtypes" })
 	@Test
-	public void testCustomType() {
+	public void testPojo() {
 		// use getCrossReturnTypes()
 		RichCrossFunction<?, ?, ?> function = new RichCrossFunction<CustomType, Integer, CustomType>() {
 			private static final long serialVersionUID = 1L;
@@ -363,7 +363,7 @@ public class TypeExtractorTest {
 
 	@SuppressWarnings({ "unchecked", "rawtypes" })
 	@Test
-	public void testTupleWithCustomType() {
+	public void testTupleWithPojo() {
 		// use getMapReturnTypes()
 		RichMapFunction<?, ?> function = new RichMapFunction<Tuple2<Long, CustomType>, Tuple2<Long, CustomType>>() {
 			private static final long serialVersionUID = 1L;
@@ -1660,4 +1660,78 @@ public class TypeExtractorTest {
 		Assert.assertTrue(ti instanceof EnumTypeInfo);
 		Assert.assertEquals(ti.getTypeClass(), MyEnum.class);
 	}
+	
+	public static class MapperWithMultiDimGenericArray<T> implements MapFunction<T[][][], Tuple1<T>[][][]> {
+		private static final long serialVersionUID = 1L;
+
+		@Override
+		public Tuple1<T>[][][] map(T[][][] value) throws Exception {
+			return null;
+		}
+	}
+
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	@Test
+	public void testMultiDimensionalArray() {
+		// tuple array
+		MapFunction<?,?> function = new MapFunction<Tuple2<Integer, Double>[][], Tuple2<Integer, Double>[][]>() {
+			private static final long serialVersionUID = 1L;
+
+			@Override
+			public Tuple2<Integer, Double>[][] map(
+					Tuple2<Integer, Double>[][] value) throws Exception {
+				return null;
+			}
+		};
+		TypeInformation<?> ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("Tuple2<Integer, Double>[][]"));
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<Java Tuple2<Integer, Double>>>", ti.toString());
+
+		// primitive array
+		function = new MapFunction<int[][][], int[][][]>() {
+			private static final long serialVersionUID = 1L;
+
+			@Override
+			public int[][][] map(
+					int[][][] value) throws Exception {
+				return null;
+			}
+		};
+		ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("int[][][]"));
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<int[]>>", ti.toString());
+
+		// basic array
+		function = new MapFunction<Integer[][][], Integer[][][]>() {
+			private static final long serialVersionUID = 1L;
+
+			@Override
+			public Integer[][][] map(
+					Integer[][][] value) throws Exception {
+				return null;
+			}
+		};
+		ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("Integer[][][]"));
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<BasicArrayTypeInfo<Integer>>>", ti.toString());
+
+		// pojo array
+		function = new MapFunction<CustomType[][][], CustomType[][][]>() {
+			private static final long serialVersionUID = 1L;
+
+			@Override
+			public CustomType[][][] map(
+					CustomType[][][] value) throws Exception {
+				return null;
+			}
+		};
+		ti = TypeExtractor.getMapReturnTypes((MapFunction)function, TypeInfoParser.parse("org.apache.flink.api.java.type.extractor.TypeExtractorTest$CustomType<"
+				+ "myField1=String,myField2=int"
+				+ ">[][][]"));
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<"
+				+ "PojoType<org.apache.flink.api.java.type.extractor.TypeExtractorTest.CustomType, fields = [myField1: String, myField2: Integer]>"
+				+ ">>>", ti.toString());
+		
+		// generic array
+		// TODO depends on #315
+		//ti = TypeExtractor.getMapReturnTypes((MapFunction) new MapperWithMultiDimGenericArray<String>(), TypeInfoParser.parse("String[][][]"));
+		//Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<Java Tuple1<String>>>>",);
+	}
 }
diff --git a/flink-java/src/test/java/org/apache/flink/api/java/typeutils/TypeInfoParserTest.java b/flink-java/src/test/java/org/apache/flink/api/java/typeutils/TypeInfoParserTest.java
index e539ada3e2c..c2f3737ac73 100644
--- a/flink-java/src/test/java/org/apache/flink/api/java/typeutils/TypeInfoParserTest.java
+++ b/flink-java/src/test/java/org/apache/flink/api/java/typeutils/TypeInfoParserTest.java
@@ -244,7 +244,7 @@ public class TypeInfoParserTest {
 	@Test
 	public void testLargeMixedTuple() {
 		TypeInformation<?> ti = TypeInfoParser.parse("org.apache.flink.api.java.tuple.Tuple4<Double,java.lang.Class[],StringValue,Tuple1<int>>[]");
-		Assert.assertEquals("ObjectArrayTypeInfo<Java Tuple4<Double, ObjectArrayTypeInfo<GenericType<java.lang.Class>>, ValueType<org.apache.flink.types.StringValue>, Java Tuple1<Integer>>>", ti.toString());
+		Assert.assertEquals("ObjectArrayTypeInfo<Java Tuple4<Double, ObjectArrayTypeInfo<GenericType<java.lang.Class>>, ValueType<StringValue>, Java Tuple1<Integer>>>", ti.toString());
 	}
 	
 	public static enum MyEnum {
@@ -290,4 +290,47 @@ public class TypeInfoParserTest {
 			// right
 		}
 	}
+
+	@Test
+	public void testMultiDimensionalArray() {
+		// tuple
+		TypeInformation<?> ti = TypeInfoParser.parse("Tuple2<Integer, Double>[][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<Java Tuple2<Integer, Double>>>", ti.toString());
+		
+		// pojos
+		ti = TypeInfoParser.parse("org.apache.flink.api.java.typeutils.TypeInfoParserTest$MyPojo<basic=String>[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<"
+				+ "PojoType<org.apache.flink.api.java.typeutils.TypeInfoParserTest.MyPojo, fields = [basic: String]>"
+				+ ">>>", ti.toString());
+		
+		// basic types
+		ti = TypeInfoParser.parse("Float[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<BasicArrayTypeInfo<Float>>>", ti.toString());
+		ti = TypeInfoParser.parse("String[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<BasicArrayTypeInfo<String>>>", ti.toString());
+		ti = TypeInfoParser.parse("Date[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<Date>>>", ti.toString());
+		
+		// primitive types
+		ti = TypeInfoParser.parse("int[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<int[]>>", ti.toString());
+		ti = TypeInfoParser.parse("boolean[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<boolean[]>>", ti.toString());
+		
+		// value types
+		ti = TypeInfoParser.parse("IntValue[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<ValueType<IntValue>>>>", ti.toString());
+		
+		// writable types
+		ti = TypeInfoParser.parse("Writable<org.apache.flink.api.java.typeutils.TypeInfoParserTest$MyWritable>[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<"
+				+ "WritableType<org.apache.flink.api.java.typeutils.TypeInfoParserTest$MyWritable>"
+				+ ">>>", ti.toString());
+		
+		// enum types
+		ti = TypeInfoParser.parse("Enum<org.apache.flink.api.java.typeutils.TypeInfoParserTest$MyEnum>[][][]");
+		Assert.assertEquals("ObjectArrayTypeInfo<ObjectArrayTypeInfo<ObjectArrayTypeInfo<"
+				+ "EnumTypeInfo<org.apache.flink.api.java.typeutils.TypeInfoParserTest$MyEnum>"
+				+ ">>>", ti.toString());
+	}
 }
diff --git a/flink-java/src/test/java/org/apache/flink/api/java/typeutils/runtime/MultidimensionalArraySerializerTest.java b/flink-java/src/test/java/org/apache/flink/api/java/typeutils/runtime/MultidimensionalArraySerializerTest.java
new file mode 100644
index 00000000000..22b6c767d22
--- /dev/null
+++ b/flink-java/src/test/java/org/apache/flink/api/java/typeutils/runtime/MultidimensionalArraySerializerTest.java
@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.api.java.typeutils.runtime;
+
+import org.apache.flink.api.common.typeinfo.TypeInformation;
+import org.apache.flink.api.common.typeutils.SerializerTestInstance;
+import org.apache.flink.api.java.typeutils.TypeExtractor;
+import org.apache.flink.api.java.typeutils.TypeInfoParser;
+import org.junit.Test;
+
+
+/**
+ * A serialization test for multidimensional arrays.
+ */
+public class MultidimensionalArraySerializerTest {
+
+	@Test
+	public void testStringArray() {
+		String[][] array = new String[][]{{null,"b"},{"c","d"},{"e","f"},{"g","h"},null};
+		TypeInformation<String[][]> ti = TypeExtractor.getForClass(String[][].class);
+
+		SerializerTestInstance<String[][]> testInstance = new SerializerTestInstance<String[][]>(ti.createSerializer(), String[][].class, -1, array);
+		testInstance.testAll();
+	}
+
+	@Test
+	public void testPrimitiveArray() {
+		int[][] array = new int[][]{{12,1},{48,42},{23,80},{484,849},{987,4}};
+		TypeInformation<int[][]> ti = TypeExtractor.getForClass(int[][].class);
+
+		SerializerTestInstance<int[][]> testInstance = new SerializerTestInstance<int[][]>(ti.createSerializer(), int[][].class, -1, array);
+		testInstance.testAll();
+	}
+
+	public static class MyPojo {
+		public String field1;
+		public int field2;
+
+		public MyPojo(String field1, int field2) {
+			this.field1 = field1;
+			this.field2 = field2;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (!(obj instanceof MyPojo)) {
+				return false;
+			}
+			MyPojo other = (MyPojo) obj;
+			return ((field1 == null && other.field1 == null) || (field1 != null && field1.equals(other.field1)))
+					&& field2 == other.field2;
+		}
+	}
+
+	@Test
+	public void testObjectArrays() {
+		Integer[][] array = new Integer[][]{{0,1}, null, {null, 42}};
+		TypeInformation<Integer[][]> ti = TypeExtractor.getForClass(Integer[][].class);
+
+		SerializerTestInstance<Integer[][]> testInstance = new SerializerTestInstance<Integer[][]>(ti.createSerializer(), Integer[][].class, -1, array);
+		testInstance.testAll();
+
+		MyPojo[][] array2 = new MyPojo[][]{{new MyPojo(null, 42), new MyPojo("test2", -1)}, {null, null}, null};
+		TypeInformation<MyPojo[][]> ti2 = TypeExtractor.getForClass(MyPojo[][].class);
+
+		SerializerTestInstance<MyPojo[][]> testInstance2 = new SerializerTestInstance<MyPojo[][]>(ti2.createSerializer(), MyPojo[][].class, -1, array2);
+		testInstance2.testAll();
+	}
+
+	public static class MyGenericPojo<T> {
+		public T[][] field;
+
+		public MyGenericPojo() {
+			// nothing to do
+		}
+
+		public MyGenericPojo(T[][] field) {
+			this.field = field;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (!(obj instanceof MyGenericPojo)) {
+				return false;
+			}
+			MyGenericPojo<?> other = (MyGenericPojo<?>) obj;
+			return (field == null && other.field == null) || (field != null && field.length == other.field.length);
+		}
+	}
+
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	@Test
+	public void testGenericObjectArrays() {
+		MyGenericPojo<String>[][] array = (MyGenericPojo<String>[][]) new MyGenericPojo[][]{
+			{ new MyGenericPojo<String>(new String[][]{{"a", "b"},{"c", "d"}}), null}
+		};
+		TypeInformation ti = TypeInfoParser.parse("org.apache.flink.api.java.typeutils.runtime.MultidimensionalArraySerializerTest$MyGenericPojo<field=String[][]>[][]");
+
+		SerializerTestInstance testInstance = new SerializerTestInstance(ti.createSerializer(), MyGenericPojo[][].class, -1, (Object) array);
+		testInstance.testAll();
+	}
+
+}
diff --git a/flink-tests/src/test/scala/org/apache/flink/api/scala/types/TypeInformationGenTest.scala b/flink-tests/src/test/scala/org/apache/flink/api/scala/types/TypeInformationGenTest.scala
index 640890f9d75..89d7c5eddc6 100644
--- a/flink-tests/src/test/scala/org/apache/flink/api/scala/types/TypeInformationGenTest.scala
+++ b/flink-tests/src/test/scala/org/apache/flink/api/scala/types/TypeInformationGenTest.scala
@@ -255,6 +255,54 @@ class TypeInformationGenTest {
     Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, tti.getTypeAt(0))
     Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, tti.getTypeAt(1))
   }
+  
+  @Test
+  def testMultidimensionalArrays(): Unit = {
+    // Tuple
+    {
+      val ti = createTypeInformation[Array[Array[(String, String)]]]
+    
+      Assert.assertTrue(ti.isInstanceOf[ObjectArrayTypeInfo[_, _]])
+      val oati = ti.asInstanceOf[ObjectArrayTypeInfo[_, _]]
+      Assert.assertTrue(oati.getComponentInfo.isInstanceOf[ObjectArrayTypeInfo[_, _]])
+      val oati2 = oati.getComponentInfo.asInstanceOf[ObjectArrayTypeInfo[_, _]]
+      Assert.assertTrue(oati2.getComponentInfo.isTupleType)
+      val tti = oati2.getComponentInfo.asInstanceOf[TupleTypeInfoBase[_]]
+      Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, tti.getTypeAt(0))
+      Assert.assertEquals(BasicTypeInfo.STRING_TYPE_INFO, tti.getTypeAt(1))
+    }
+    
+    // primitives
+    {
+      val ti = createTypeInformation[Array[Array[Int]]]
+    
+      Assert.assertTrue(ti.isInstanceOf[ObjectArrayTypeInfo[_, _]])
+      val oati = ti.asInstanceOf[ObjectArrayTypeInfo[_, _]]
+      Assert.assertEquals(oati.getComponentInfo,
+        PrimitiveArrayTypeInfo.INT_PRIMITIVE_ARRAY_TYPE_INFO)
+    }
+    
+    // basic types
+    {
+      val ti = createTypeInformation[Array[Array[Integer]]]
+    
+      Assert.assertTrue(ti.isInstanceOf[ObjectArrayTypeInfo[_, _]])
+      val oati = ti.asInstanceOf[ObjectArrayTypeInfo[_, _]]
+      Assert.assertEquals(oati.getComponentInfo, BasicArrayTypeInfo.INT_ARRAY_TYPE_INFO)
+    }
+    
+    // pojo
+    {
+      val ti = createTypeInformation[Array[Array[CustomType]]]
+    
+      Assert.assertTrue(ti.isInstanceOf[ObjectArrayTypeInfo[_, _]])
+      val oati = ti.asInstanceOf[ObjectArrayTypeInfo[_, _]]
+      Assert.assertTrue(oati.getComponentInfo.isInstanceOf[ObjectArrayTypeInfo[_, _]])
+      val oati2 = oati.getComponentInfo.asInstanceOf[ObjectArrayTypeInfo[_, _]]
+      val tti = oati2.getComponentInfo.asInstanceOf[PojoTypeInfo[_]]
+      Assert.assertEquals(classOf[CustomType], tti.getTypeClass())
+    }
+  }
 
   @Test
   def testParamertizedCustomObject(): Unit = {
