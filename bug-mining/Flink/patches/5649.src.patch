diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
index d0837837ef8..a939fa9eecd 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
@@ -47,6 +47,7 @@ import org.apache.flink.runtime.entrypoint.component.DefaultDispatcherResourceMa
 import org.apache.flink.runtime.entrypoint.component.DispatcherResourceManagerComponent;
 import org.apache.flink.runtime.entrypoint.component.DispatcherResourceManagerComponentFactory;
 import org.apache.flink.runtime.executiongraph.AccessExecutionGraph;
+import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
@@ -74,6 +75,7 @@ import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.rpc.RpcSystem;
 import org.apache.flink.runtime.rpc.RpcUtils;
+import org.apache.flink.runtime.scheduler.ExecutionGraphInfo;
 import org.apache.flink.runtime.taskexecutor.TaskExecutor;
 import org.apache.flink.runtime.taskexecutor.TaskManagerRunner;
 import org.apache.flink.runtime.webmonitor.retriever.LeaderRetriever;
@@ -689,6 +691,14 @@ public class MiniCluster implements AutoCloseableAsync {
     //  Accessing jobs
     // ------------------------------------------------------------------------
 
+    public CompletableFuture<ArchivedExecutionGraph> getArchivedExecutionGraph(JobID jobId) {
+        return runDispatcherCommand(
+                dispatcherGateway ->
+                        dispatcherGateway
+                                .requestExecutionGraphInfo(jobId, rpcTimeout)
+                                .thenApply(ExecutionGraphInfo::getArchivedExecutionGraph));
+    }
+
     public CompletableFuture<Collection<JobStatusMessage>> listJobs() {
         return runDispatcherCommand(
                 dispatcherGateway ->
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerClusterITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerClusterITCase.java
index 4b28364b8e3..9865395ce5b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerClusterITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveSchedulerClusterITCase.java
@@ -19,19 +19,26 @@
 package org.apache.flink.runtime.scheduler.adaptive;
 
 import org.apache.flink.api.common.ExecutionConfig;
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.restartstrategy.RestartStrategies;
+import org.apache.flink.api.common.time.Deadline;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.JobManagerOptions;
+import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphTestUtils;
 import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.minicluster.MiniCluster;
 import org.apache.flink.runtime.testtasks.OnceBlockingNoOpInvokable;
+import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.testutils.MiniClusterResource;
 import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
 import org.apache.flink.util.TestLogger;
 
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -39,7 +46,6 @@ import java.io.IOException;
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
@@ -51,6 +57,7 @@ public class AdaptiveSchedulerClusterITCase extends TestLogger {
     private static final int NUMBER_SLOTS_PER_TASK_MANAGER = 2;
     private static final int NUMBER_TASK_MANAGERS = 2;
     private static final int PARALLELISM = NUMBER_SLOTS_PER_TASK_MANAGER * NUMBER_TASK_MANAGERS;
+    private static final JobVertexID JOB_VERTEX_ID = new JobVertexID();
 
     private final Configuration configuration = createConfiguration();
 
@@ -73,8 +80,13 @@ public class AdaptiveSchedulerClusterITCase extends TestLogger {
         return configuration;
     }
 
+    @Before
+    public void setUp() {
+        OnceBlockingNoOpInvokable.reset();
+    }
+
     @Test
-    public void testAutomaticScaleDownInCaseOfLostSlots() throws InterruptedException, IOException {
+    public void testAutomaticScaleDownInCaseOfLostSlots() throws Exception {
         final MiniCluster miniCluster = miniClusterResource.getMiniCluster();
         final JobGraph jobGraph = createBlockingJobGraph(PARALLELISM);
 
@@ -82,10 +94,19 @@ public class AdaptiveSchedulerClusterITCase extends TestLogger {
         final CompletableFuture<JobResult> resultFuture =
                 miniCluster.requestJobResult(jobGraph.getJobID());
 
-        OnceBlockingNoOpInvokable.waitUntilOpsAreRunning();
+        waitUntilParallelismForVertexReached(
+                jobGraph.getJobID(),
+                JOB_VERTEX_ID,
+                NUMBER_SLOTS_PER_TASK_MANAGER * NUMBER_TASK_MANAGERS);
 
         miniCluster.terminateTaskManager(0);
 
+        waitUntilParallelismForVertexReached(
+                jobGraph.getJobID(),
+                JOB_VERTEX_ID,
+                NUMBER_SLOTS_PER_TASK_MANAGER * (NUMBER_TASK_MANAGERS - 1));
+        OnceBlockingNoOpInvokable.unblock();
+
         final JobResult jobResult = resultFuture.join();
 
         assertTrue(jobResult.isSuccess());
@@ -94,12 +115,10 @@ public class AdaptiveSchedulerClusterITCase extends TestLogger {
     @Test
     public void testAutomaticScaleUp() throws Exception {
         final MiniCluster miniCluster = miniClusterResource.getMiniCluster();
-        int targetInstanceCount = NUMBER_SLOTS_PER_TASK_MANAGER * (NUMBER_TASK_MANAGERS + 1);
+        int initialInstanceCount = NUMBER_SLOTS_PER_TASK_MANAGER * NUMBER_TASK_MANAGERS;
+        int targetInstanceCount = initialInstanceCount + NUMBER_SLOTS_PER_TASK_MANAGER;
         final JobGraph jobGraph = createBlockingJobGraph(targetInstanceCount);
 
-        // initially only expect NUMBER_TASK_MANAGERS
-        OnceBlockingNoOpInvokable.resetFor(NUMBER_SLOTS_PER_TASK_MANAGER * NUMBER_TASK_MANAGERS);
-
         log.info(
                 "Submitting job with parallelism of "
                         + targetInstanceCount
@@ -108,25 +127,23 @@ public class AdaptiveSchedulerClusterITCase extends TestLogger {
         final CompletableFuture<JobResult> jobResultFuture =
                 miniCluster.requestJobResult(jobGraph.getJobID());
 
-        OnceBlockingNoOpInvokable.waitUntilOpsAreRunning();
+        waitUntilParallelismForVertexReached(
+                jobGraph.getJobID(), JOB_VERTEX_ID, initialInstanceCount);
 
         log.info("Start additional TaskManager to scale up to the full parallelism.");
-        OnceBlockingNoOpInvokable.resetInstanceCount(); // we expect a restart
-        OnceBlockingNoOpInvokable.resetFor(targetInstanceCount);
         miniCluster.startTaskManager();
 
         log.info("Waiting until Invokable is running with higher parallelism");
-        OnceBlockingNoOpInvokable.waitUntilOpsAreRunning();
-
-        assertEquals(targetInstanceCount, OnceBlockingNoOpInvokable.getInstanceCount());
+        waitUntilParallelismForVertexReached(
+                jobGraph.getJobID(), JOB_VERTEX_ID, targetInstanceCount);
+        OnceBlockingNoOpInvokable.unblock();
 
         assertTrue(jobResultFuture.join().isSuccess());
     }
 
     private JobGraph createBlockingJobGraph(int parallelism) throws IOException {
-        final JobVertex blockingOperator = new JobVertex("Blocking operator");
+        final JobVertex blockingOperator = new JobVertex("Blocking operator", JOB_VERTEX_ID);
 
-        OnceBlockingNoOpInvokable.resetFor(parallelism);
         blockingOperator.setInvokableClass(OnceBlockingNoOpInvokable.class);
 
         blockingOperator.setParallelism(parallelism);
@@ -139,4 +156,26 @@ public class AdaptiveSchedulerClusterITCase extends TestLogger {
 
         return jobGraph;
     }
+
+    private void waitUntilParallelismForVertexReached(
+            JobID jobId, JobVertexID jobVertexId, int targetParallelism) throws Exception {
+
+        CommonTestUtils.waitUntilCondition(
+                () -> {
+                    final ArchivedExecutionGraph archivedExecutionGraph =
+                            miniClusterResource
+                                    .getMiniCluster()
+                                    .getArchivedExecutionGraph(jobId)
+                                    .get();
+
+                    if (archivedExecutionGraph.getState() == JobStatus.INITIALIZING) {
+                        // parallelism was not yet determined
+                        return false;
+                    }
+
+                    return archivedExecutionGraph.getAllVertices().get(jobVertexId).getParallelism()
+                            == targetParallelism;
+                },
+                Deadline.fromNow(Duration.ofSeconds(10)));
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testtasks/OnceBlockingNoOpInvokable.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testtasks/OnceBlockingNoOpInvokable.java
index fee64ee335d..37be78c7c42 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/testtasks/OnceBlockingNoOpInvokable.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testtasks/OnceBlockingNoOpInvokable.java
@@ -22,27 +22,25 @@ import org.apache.flink.runtime.execution.Environment;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
 
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
-import java.util.concurrent.atomic.AtomicInteger;
 
 /**
- * Simple {@link AbstractInvokable} which blocks the first time it is run. Moreover, one can wait
- * until n instances of this invokable are running by calling {@link #waitUntilOpsAreRunning()}.
+ * Mimics a task that is doing something until some external condition is fulfilled. {@link
+ * #unblock()} signals that no more work is to be done, unblocking all instances and allowing all
+ * future instances to immediately finish as well.
  *
- * <p>Before using this class it is important to call {@link #resetFor}.
+ * <p>The main use-case is keeping a task running while supporting restarts, until some condition is
+ * met, at which point it should finish.
+ *
+ * <p>Before using this class it is important to call {@link #reset}.
  */
 public class OnceBlockingNoOpInvokable extends AbstractInvokable {
 
-    private static final AtomicInteger instanceCount = new AtomicInteger(0);
-
-    private static volatile CountDownLatch numOpsPending = new CountDownLatch(1);
-
     private static volatile boolean isBlocking = true;
 
-    private final Object lock = new Object();
+    private static final Object lock = new Object();
 
-    private volatile boolean running = true;
+    private static volatile boolean running = true;
 
     public OnceBlockingNoOpInvokable(Environment environment) {
         super(environment);
@@ -50,17 +48,13 @@ public class OnceBlockingNoOpInvokable extends AbstractInvokable {
 
     @Override
     public void invoke() throws Exception {
-
-        instanceCount.incrementAndGet();
-        numOpsPending.countDown();
-
-        synchronized (lock) {
-            while (isBlocking && running) {
-                lock.wait();
+        if (isBlocking) {
+            synchronized (lock) {
+                while (running) {
+                    lock.wait();
+                }
             }
         }
-
-        isBlocking = false;
     }
 
     @Override
@@ -72,20 +66,16 @@ public class OnceBlockingNoOpInvokable extends AbstractInvokable {
         return CompletableFuture.completedFuture(null);
     }
 
-    public static void waitUntilOpsAreRunning() throws InterruptedException {
-        numOpsPending.await();
-    }
-
-    public static int getInstanceCount() {
-        return instanceCount.get();
-    }
-
-    public static void resetInstanceCount() {
-        instanceCount.set(0);
+    public static void unblock() {
+        running = false;
+        isBlocking = false;
+        synchronized (lock) {
+            lock.notifyAll();
+        }
     }
 
-    public static void resetFor(int parallelism) {
-        numOpsPending = new CountDownLatch(parallelism);
+    public static void reset() {
         isBlocking = true;
+        running = true;
     }
 }
