diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentITCase.scala
index ffec38f5045..bf974a90094 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentITCase.scala
@@ -18,10 +18,8 @@
 
 package org.apache.flink.table.api
 
-import org.apache.flink.api.common.RuntimeExecutionMode
 import org.apache.flink.api.common.typeinfo.Types.STRING
 import org.apache.flink.api.scala._
-import org.apache.flink.configuration.ExecutionOptions
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment
 import org.apache.flink.streaming.api.scala.{StreamExecutionEnvironment => ScalaStreamExecutionEnvironment}
 import org.apache.flink.table.api.bridge.java.StreamTableEnvironment
@@ -29,16 +27,16 @@ import org.apache.flink.table.api.bridge.scala.{StreamTableEnvironment => ScalaS
 import org.apache.flink.table.api.config.TableConfigOptions
 import org.apache.flink.table.api.internal.{TableEnvironmentImpl, TableEnvironmentInternal}
 import org.apache.flink.table.catalog._
-import org.apache.flink.table.functions.TestGenericUDF
 import org.apache.flink.table.planner.factories.utils.TestCollectionTableFactory
 import org.apache.flink.table.planner.runtime.utils.TestingAppendSink
 import org.apache.flink.table.planner.utils.TableTestUtil.{readFromResource, replaceStageId}
 import org.apache.flink.table.planner.utils.{TableTestUtil, TestTableSourceSinks, TestTableSourceWithTime}
+import org.apache.flink.test.util.AbstractTestBase
 import org.apache.flink.types.{Row, RowKind}
-import org.apache.flink.util.{CollectionUtil, FileUtils, TestLogger}
+import org.apache.flink.util.{CollectionUtil, FileUtils}
 
-import org.junit.Assert.{assertEquals, assertFalse, assertTrue, fail}
-import org.junit.rules.{ExpectedException, TemporaryFolder}
+import org.junit.Assert.{assertEquals, assertFalse, assertTrue}
+import org.junit.rules.TemporaryFolder
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized
 import org.junit.{Assert, Before, Rule, Test}
@@ -47,21 +45,14 @@ import java.io.{File, FileFilter}
 import java.lang.{Long => JLong}
 import java.util
 
+import scala.annotation.meta.getter
 import scala.collection.mutable
 
 @RunWith(classOf[Parameterized])
-class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends TestLogger {
+class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends AbstractTestBase {
 
-  // used for accurate exception information checking.
-  val expectedException: ExpectedException = ExpectedException.none()
-
-  @Rule
-  def thrown: ExpectedException = expectedException
-
-  private val _tempFolder = new TemporaryFolder()
-
-  @Rule
-  def tempFolder: TemporaryFolder = _tempFolder
+  @(Rule @getter)
+  val tempFolder: TemporaryFolder = new TemporaryFolder()
 
   var tEnv: TableEnvironment = _
 
@@ -84,26 +75,6 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
     TestTableSourceSinks.createPersonCsvTemporaryTable(tEnv, "MyTable")
   }
 
-  @Test
-  def testSetExecutionMode(): Unit = {
-    if (isStreaming) {
-      tEnv.getConfig.set(ExecutionOptions.RUNTIME_MODE, RuntimeExecutionMode.BATCH)
-    } else {
-      tEnv.getConfig.set(ExecutionOptions.RUNTIME_MODE,
-        RuntimeExecutionMode.STREAMING)
-    }
-
-    thrown.expect(classOf[IllegalArgumentException])
-    thrown.expectMessage(
-      "Mismatch between configured runtime mode and actual runtime mode. " +
-        "Currently, the 'execution.runtime-mode' can only be set when instantiating the " +
-        "table environment. Subsequent changes are not supported. " +
-        "Please instantiate a new TableEnvironment if necessary."
-    )
-
-    tEnv.explainSql("select first from MyTable")
-  }
-
   @Test
   def testExecuteTwiceUsingSameTableEnv(): Unit = {
     val sink1Path = TestTableSourceSinks.createCsvTemporarySinkTable(
@@ -158,7 +129,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
       return
     }
 
-    val sinkPath = _tempFolder.newFolder().toString
+    val sinkPath = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink (
@@ -335,7 +306,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
       // Streaming mode not support overwrite for FileSystemTableSink.
       return
     }
-    val sinkPath = _tempFolder.newFolder().toString
+    val sinkPath = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink (
@@ -359,7 +330,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
   @Test
   def testTableDMLSync(): Unit = {
     tEnv.getConfig.set(TableConfigOptions.TABLE_DML_SYNC, Boolean.box(true))
-    val sink1Path = _tempFolder.newFolder().toString
+    val sink1Path = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink1 (
@@ -373,7 +344,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
        """.stripMargin
     )
 
-    val sink2Path = _tempFolder.newFolder().toString
+    val sink2Path = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink2 (
@@ -386,7 +357,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
        """.stripMargin
     )
 
-    val sink3Path = _tempFolder.newFolder().toString
+    val sink3Path = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink3 (
@@ -477,7 +448,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
       // Streaming mode not support overwrite for FileSystemTableSink.
       return
     }
-    val sink1Path = _tempFolder.newFolder().toString
+    val sink1Path = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink1 (
@@ -490,7 +461,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
        """.stripMargin
     )
 
-    val sink2Path = _tempFolder.newFolder().toString
+    val sink2Path = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink2 (
@@ -536,7 +507,7 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
       // Streaming mode not support overwrite for FileSystemTableSink.
       return
     }
-    val sinkPath = _tempFolder.newFolder().toString
+    val sinkPath = tempFolder.newFolder().toString
     tEnv.executeSql(
       s"""
          |create table MySink (
@@ -680,77 +651,6 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
     tableEnv.executeSql("insert into dest2 select x from src").await()
   }
 
-  @Test
-  def testTemporaryOperationListener(): Unit = {
-    val listener = new ListenerCatalog("listener_cat")
-    val currentCat = tEnv.getCurrentCatalog
-    tEnv.registerCatalog(listener.getName, listener)
-    // test temporary table
-    tEnv.executeSql("create temporary table tbl1 (x int)")
-    assertEquals(0, listener.numTempTable)
-    tEnv.executeSql(s"create temporary table ${listener.getName}.`default`.tbl1 (x int)")
-    assertEquals(1, listener.numTempTable)
-    val tableResult = tEnv.asInstanceOf[TableEnvironmentInternal].getCatalogManager
-      .getTable(ObjectIdentifier.of(listener.getName, "default", "tbl1"))
-    assertTrue(tableResult.isPresent)
-    assertEquals(listener.tableComment, tableResult.get().getTable[CatalogBaseTable].getComment)
-    tEnv.executeSql("drop temporary table tbl1")
-    assertEquals(1, listener.numTempTable)
-    tEnv.executeSql(s"drop temporary table ${listener.getName}.`default`.tbl1")
-    assertEquals(0, listener.numTempTable)
-    tEnv.useCatalog(listener.getName)
-    tEnv.executeSql("create temporary table tbl1 (x int)")
-    assertEquals(1, listener.numTempTable)
-    tEnv.executeSql("drop temporary table tbl1")
-    assertEquals(0, listener.numTempTable)
-    tEnv.useCatalog(currentCat)
-
-    // test temporary view
-    tEnv.executeSql("create temporary view v1 as select 1")
-    assertEquals(0, listener.numTempTable)
-    tEnv.executeSql(s"create temporary view ${listener.getName}.`default`.v1 as select 1")
-    assertEquals(1, listener.numTempTable)
-    val viewResult = tEnv.asInstanceOf[TableEnvironmentInternal].getCatalogManager
-      .getTable(ObjectIdentifier.of(listener.getName, "default", "v1"))
-    assertTrue(viewResult.isPresent)
-    assertEquals(listener.tableComment, viewResult.get().getTable[CatalogBaseTable].getComment)
-    tEnv.executeSql("drop temporary view v1")
-    assertEquals(1, listener.numTempTable)
-    tEnv.executeSql(s"drop temporary view ${listener.getName}.`default`.v1")
-    assertEquals(0, listener.numTempTable)
-    tEnv.useCatalog(listener.getName)
-    tEnv.executeSql("create temporary view v1 as select 1")
-    assertEquals(1, listener.numTempTable)
-    tEnv.executeSql("drop temporary view  v1")
-    assertEquals(0, listener.numTempTable)
-    tEnv.useCatalog(currentCat)
-
-    // test temporary function
-    val clzName = "foo.class.name"
-    try {
-      tEnv.executeSql(s"create temporary function func1 as '${clzName}'")
-      fail("Creating a temporary function with invalid class should fail")
-    } catch {
-      case _: Exception => //expected
-    }
-    assertEquals(0, listener.numTempFunc)
-    tEnv.executeSql(
-      s"create temporary function ${listener.getName}.`default`.func1 as '${clzName}'")
-    assertEquals(1, listener.numTempFunc)
-    tEnv.executeSql("drop temporary function if exists func1")
-    assertEquals(1, listener.numTempFunc)
-    tEnv.executeSql(s"drop temporary function ${listener.getName}.`default`.func1")
-    assertEquals(0, listener.numTempFunc)
-    tEnv.useCatalog(listener.getName)
-    tEnv.executeSql(s"create temporary function func1 as '${clzName}'")
-    assertEquals(1, listener.numTempFunc)
-    tEnv.executeSql("drop temporary function func1")
-    assertEquals(0, listener.numTempFunc)
-    tEnv.useCatalog(currentCat)
-
-    listener.close()
-  }
-
   def getPersonData: List[(String, Int, Double, String)] = {
     val data = new mutable.MutableList[(String, Int, Double, String)]
     data.+=(("Mike", 1, 12.3, "Smith"))
@@ -817,38 +717,6 @@ class TableEnvironmentITCase(tableEnvName: String, isStreaming: Boolean) extends
     }
   }
 
-  class ListenerCatalog(name: String)
-    extends GenericInMemoryCatalog(name) with TemporaryOperationListener {
-
-    val tableComment: String = "listener_comment"
-    val funcClzName: String = classOf[TestGenericUDF].getName
-
-    var numTempTable = 0
-    var numTempFunc = 0
-
-    override def onCreateTemporaryTable(tablePath: ObjectPath, table: CatalogBaseTable)
-    : CatalogBaseTable = {
-      numTempTable += 1
-      if (table.isInstanceOf[CatalogTable]) {
-        new CatalogTableImpl(table.getSchema, table.getOptions, tableComment)
-      } else {
-        val view = table.asInstanceOf[CatalogView]
-        new CatalogViewImpl(view.getOriginalQuery, view.getExpandedQuery,
-          view.getSchema, view.getOptions, tableComment)
-      }
-    }
-
-    override def onDropTemporaryTable(tablePath: ObjectPath): Unit = numTempTable -= 1
-
-    override def onCreateTemporaryFunction(functionPath: ObjectPath, function: CatalogFunction)
-    : CatalogFunction = {
-      numTempFunc += 1
-      new CatalogFunctionImpl(funcClzName, function.getFunctionLanguage)
-    }
-
-    override def onDropTemporaryFunction(functionPath: ObjectPath): Unit = numTempFunc -= 1
-  }
-
 }
 
 object TableEnvironmentITCase {
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala
index 69da1938cc8..3f9c9067a20 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala
@@ -18,15 +18,18 @@
 
 package org.apache.flink.table.api
 
+import org.apache.flink.api.common.RuntimeExecutionMode
 import org.apache.flink.api.common.typeinfo.Types.STRING
 import org.apache.flink.api.scala._
-import org.apache.flink.configuration.Configuration
+import org.apache.flink.configuration.{Configuration, ExecutionOptions}
 import org.apache.flink.core.testutils.FlinkAssertions.anyCauseMatches
 import org.apache.flink.streaming.api.environment.LocalStreamEnvironment
 import org.apache.flink.streaming.api.scala.StreamExecutionEnvironment
 import org.apache.flink.table.api.bridge.scala.{StreamTableEnvironment, _}
+import org.apache.flink.table.api.internal.TableEnvironmentInternal
 import org.apache.flink.table.catalog._
 import org.apache.flink.table.factories.{TableFactoryUtil, TableSourceFactoryContextImpl}
+import org.apache.flink.table.functions.TestGenericUDF
 import org.apache.flink.table.module.ModuleEntry
 import org.apache.flink.table.planner.factories.utils.TestCollectionTableFactory._
 import org.apache.flink.table.planner.runtime.stream.sql.FunctionITCase.TestUDF
@@ -39,7 +42,7 @@ import org.apache.flink.types.Row
 import org.apache.calcite.plan.RelOptUtil
 import org.apache.calcite.sql.SqlExplainLevel
 import org.assertj.core.api.Assertions.{assertThat, assertThatThrownBy}
-import org.junit.Assert.{assertEquals, assertFalse, assertTrue}
+import org.junit.Assert.{assertEquals, assertFalse, assertTrue, fail}
 import org.junit.rules.ExpectedException
 import org.junit.{Rule, Test}
 
@@ -1719,6 +1722,99 @@ class TableEnvironmentTest {
       tableResult6.collect())
   }
 
+  @Test
+  def testTemporaryOperationListener(): Unit = {
+    val listener = new ListenerCatalog("listener_cat")
+    val currentCat = tableEnv.getCurrentCatalog
+    tableEnv.registerCatalog(listener.getName, listener)
+    // test temporary table
+    tableEnv.executeSql("create temporary table tbl1 (x int)")
+    assertEquals(0, listener.numTempTable)
+    tableEnv.executeSql(s"create temporary table ${listener.getName}.`default`.tbl1 (x int)")
+    assertEquals(1, listener.numTempTable)
+    val tableResult = tableEnv.asInstanceOf[TableEnvironmentInternal].getCatalogManager
+      .getTable(ObjectIdentifier.of(listener.getName, "default", "tbl1"))
+    assertTrue(tableResult.isPresent)
+    assertEquals(listener.tableComment, tableResult.get().getTable[CatalogBaseTable].getComment)
+    tableEnv.executeSql("drop temporary table tbl1")
+    assertEquals(1, listener.numTempTable)
+    tableEnv.executeSql(s"drop temporary table ${listener.getName}.`default`.tbl1")
+    assertEquals(0, listener.numTempTable)
+    tableEnv.useCatalog(listener.getName)
+    tableEnv.executeSql("create temporary table tbl1 (x int)")
+    assertEquals(1, listener.numTempTable)
+    tableEnv.executeSql("drop temporary table tbl1")
+    assertEquals(0, listener.numTempTable)
+    tableEnv.useCatalog(currentCat)
+
+    // test temporary view
+    tableEnv.executeSql("create temporary view v1 as select 1")
+    assertEquals(0, listener.numTempTable)
+    tableEnv.executeSql(s"create temporary view ${listener.getName}.`default`.v1 as select 1")
+    assertEquals(1, listener.numTempTable)
+    val viewResult = tableEnv.asInstanceOf[TableEnvironmentInternal].getCatalogManager
+      .getTable(ObjectIdentifier.of(listener.getName, "default", "v1"))
+    assertTrue(viewResult.isPresent)
+    assertEquals(listener.tableComment, viewResult.get().getTable[CatalogBaseTable].getComment)
+    tableEnv.executeSql("drop temporary view v1")
+    assertEquals(1, listener.numTempTable)
+    tableEnv.executeSql(s"drop temporary view ${listener.getName}.`default`.v1")
+    assertEquals(0, listener.numTempTable)
+    tableEnv.useCatalog(listener.getName)
+    tableEnv.executeSql("create temporary view v1 as select 1")
+    assertEquals(1, listener.numTempTable)
+    tableEnv.executeSql("drop temporary view  v1")
+    assertEquals(0, listener.numTempTable)
+    tableEnv.useCatalog(currentCat)
+
+    // test temporary function
+    val clzName = "foo.class.name"
+    try {
+      tableEnv.executeSql(s"create temporary function func1 as '${clzName}'")
+      fail("Creating a temporary function with invalid class should fail")
+    } catch {
+      case _: Exception => //expected
+    }
+    assertEquals(0, listener.numTempFunc)
+    tableEnv.executeSql(
+      s"create temporary function ${listener.getName}.`default`.func1 as '${clzName}'")
+    assertEquals(1, listener.numTempFunc)
+    tableEnv.executeSql("drop temporary function if exists func1")
+    assertEquals(1, listener.numTempFunc)
+    tableEnv.executeSql(s"drop temporary function ${listener.getName}.`default`.func1")
+    assertEquals(0, listener.numTempFunc)
+    tableEnv.useCatalog(listener.getName)
+    tableEnv.executeSql(s"create temporary function func1 as '${clzName}'")
+    assertEquals(1, listener.numTempFunc)
+    tableEnv.executeSql("drop temporary function func1")
+    assertEquals(0, listener.numTempFunc)
+    tableEnv.useCatalog(currentCat)
+
+    listener.close()
+  }
+
+  @Test
+  def testSetExecutionMode(): Unit = {
+    tableEnv.executeSql(
+      """
+        |CREATE TABLE MyTable (
+        |  a bigint
+        |) WITH (
+        |  'connector' = 'COLLECTION'
+        |)
+      """.stripMargin
+    )
+
+    tableEnv.getConfig.set(ExecutionOptions.RUNTIME_MODE, RuntimeExecutionMode.BATCH)
+
+    assertThatThrownBy(() => tableEnv.explainSql("select * from MyTable"))
+      .isInstanceOf(classOf[IllegalArgumentException])
+      .hasMessageContaining("Mismatch between configured runtime mode and actual runtime mode. " +
+        "Currently, the 'execution.runtime-mode' can only be set when instantiating the " +
+        "table environment. Subsequent changes are not supported. " +
+        "Please instantiate a new TableEnvironment if necessary.")
+  }
+
   private def checkData(expected: util.Iterator[Row], actual: util.Iterator[Row]): Unit = {
     while (expected.hasNext && actual.hasNext) {
       assertEquals(expected.next(), actual.next())
@@ -1791,4 +1887,37 @@ class TableEnvironmentTest {
     assertEquals(replaceStageId(expected), replaceStageId(actual))
     assertFalse(it.hasNext)
   }
+
+  class ListenerCatalog(name: String)
+    extends GenericInMemoryCatalog(name) with TemporaryOperationListener {
+
+    val tableComment: String = "listener_comment"
+    val funcClzName: String = classOf[TestGenericUDF].getName
+
+    var numTempTable = 0
+    var numTempFunc = 0
+
+    override def onCreateTemporaryTable(tablePath: ObjectPath, table: CatalogBaseTable)
+    : CatalogBaseTable = {
+      numTempTable += 1
+      if (table.isInstanceOf[CatalogTable]) {
+        new CatalogTableImpl(table.getSchema, table.getOptions, tableComment)
+      } else {
+        val view = table.asInstanceOf[CatalogView]
+        new CatalogViewImpl(view.getOriginalQuery, view.getExpandedQuery,
+          view.getSchema, view.getOptions, tableComment)
+      }
+    }
+
+    override def onDropTemporaryTable(tablePath: ObjectPath): Unit = numTempTable -= 1
+
+    override def onCreateTemporaryFunction(functionPath: ObjectPath, function: CatalogFunction)
+    : CatalogFunction = {
+      numTempFunc += 1
+      new CatalogFunctionImpl(funcClzName, function.getFunctionLanguage)
+    }
+
+    override def onDropTemporaryFunction(functionPath: ObjectPath): Unit = numTempFunc -= 1
+  }
+
 }
