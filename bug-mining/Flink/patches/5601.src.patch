diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
index 5d37560bb86..91185ea8ae8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
@@ -23,7 +23,6 @@ import org.apache.flink.runtime.checkpoint.OperatorCoordinatorCheckpointContext;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
 import org.apache.flink.runtime.jobgraph.OperatorID;
-import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.operators.coordination.util.IncompleteFuturesTracker;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
@@ -37,7 +36,6 @@ import org.slf4j.LoggerFactory;
 import javax.annotation.Nullable;
 
 import java.util.Collection;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
@@ -124,7 +122,6 @@ public class OperatorCoordinatorHolder
     private final SubtaskAccess.SubtaskAccessFactory taskAccesses;
     private final OperatorEventValve eventValve;
     private final IncompleteFuturesTracker unconfirmedEvents;
-    private final EventSender eventSender;
 
     private final int operatorParallelism;
     private final int operatorMaxParallelism;
@@ -149,7 +146,6 @@ public class OperatorCoordinatorHolder
 
         this.unconfirmedEvents = new IncompleteFuturesTracker();
         this.eventValve = new OperatorEventValve();
-        this.eventSender = new ValveAndTrackerSender(eventValve, unconfirmedEvents);
     }
 
     public void lazyInitialize(
@@ -386,7 +382,7 @@ public class OperatorCoordinatorHolder
         final SubtaskAccess sta = taskAccesses.getAccessForSubtask(subtask);
 
         final OperatorCoordinator.SubtaskGateway gateway =
-                new SubtaskGatewayImpl(sta, eventSender, mainThreadExecutor);
+                new SubtaskGatewayImpl(sta, eventValve, mainThreadExecutor, unconfirmedEvents);
 
         // We need to do this synchronously here, otherwise we violate the contract that
         // 'subtaskFailed()' will never overtake 'subtaskReady()'.
@@ -576,25 +572,4 @@ public class OperatorCoordinatorHolder
             return userCodeClassLoader;
         }
     }
-
-    // ------------------------------------------------------------------------
-
-    private static final class ValveAndTrackerSender implements EventSender {
-
-        private final OperatorEventValve valve;
-        private final IncompleteFuturesTracker tracker;
-
-        ValveAndTrackerSender(OperatorEventValve valve, IncompleteFuturesTracker tracker) {
-            this.valve = valve;
-            this.tracker = tracker;
-        }
-
-        @Override
-        public void sendEvent(
-                Callable<CompletableFuture<Acknowledge>> sendAction,
-                CompletableFuture<Acknowledge> result) {
-            valve.sendEvent(sendAction, result);
-            tracker.trackFutureWhileIncomplete(result);
-        }
-    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java
index ea6563b1459..3a2063e0f34 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java
@@ -20,10 +20,11 @@ package org.apache.flink.runtime.operators.coordination;
 
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
 import org.apache.flink.runtime.messages.Acknowledge;
+import org.apache.flink.runtime.operators.coordination.util.IncompleteFuturesTracker;
+import org.apache.flink.runtime.util.Runnables;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.SerializedValue;
-import org.apache.flink.util.concurrent.FutureUtils;
 
 import java.io.IOException;
 import java.util.concurrent.Callable;
@@ -43,11 +44,17 @@ class SubtaskGatewayImpl implements OperatorCoordinator.SubtaskGateway {
     private final SubtaskAccess subtaskAccess;
     private final EventSender sender;
     private final Executor sendingExecutor;
+    private final IncompleteFuturesTracker incompleteFuturesTracker;
 
-    SubtaskGatewayImpl(SubtaskAccess subtaskAccess, EventSender sender, Executor sendingExecutor) {
+    SubtaskGatewayImpl(
+            SubtaskAccess subtaskAccess,
+            EventSender sender,
+            Executor sendingExecutor,
+            IncompleteFuturesTracker incompleteFuturesTracker) {
         this.subtaskAccess = subtaskAccess;
         this.sender = sender;
         this.sendingExecutor = sendingExecutor;
+        this.incompleteFuturesTracker = incompleteFuturesTracker;
     }
 
     @Override
@@ -68,9 +75,9 @@ class SubtaskGatewayImpl implements OperatorCoordinator.SubtaskGateway {
         final Callable<CompletableFuture<Acknowledge>> sendAction =
                 subtaskAccess.createEventSendAction(serializedEvent);
 
-        final CompletableFuture<Acknowledge> result = new CompletableFuture<>();
-        FutureUtils.assertNoException(
-                result.handleAsync(
+        final CompletableFuture<Acknowledge> sendResult = new CompletableFuture<>();
+        final CompletableFuture<Acknowledge> result =
+                sendResult.whenCompleteAsync(
                         (success, failure) -> {
                             if (failure != null && subtaskAccess.isStillRunning()) {
                                 String msg =
@@ -78,13 +85,19 @@ class SubtaskGatewayImpl implements OperatorCoordinator.SubtaskGateway {
                                                 EVENT_LOSS_ERROR_MESSAGE,
                                                 evt,
                                                 subtaskAccess.subtaskName());
-                                subtaskAccess.triggerTaskFailover(new FlinkException(msg, failure));
+                                Runnables.assertNoException(
+                                        () ->
+                                                subtaskAccess.triggerTaskFailover(
+                                                        new FlinkException(msg, failure)));
                             }
-                            return null;
                         },
-                        sendingExecutor));
+                        sendingExecutor);
 
-        sendingExecutor.execute(() -> sender.sendEvent(sendAction, result));
+        sendingExecutor.execute(
+                () -> {
+                    sender.sendEvent(sendAction, sendResult);
+                    incompleteFuturesTracker.trackFutureWhileIncomplete(result);
+                });
         return result;
     }
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/Runnables.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/Runnables.java
index 531fcfc70da..5a0dc9896c0 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/util/Runnables.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/Runnables.java
@@ -18,9 +18,21 @@
 
 package org.apache.flink.runtime.util;
 
+import org.apache.flink.util.FatalExitExceptionHandler;
+
 /** Utils related to {@link Runnable}. */
 public class Runnables {
 
+    /**
+     * Asserts that the given {@link Runnable} does not throw exceptions. If the runnable throws
+     * exceptions, then it will call the {@link FatalExitExceptionHandler}.
+     *
+     * @param runnable to assert for no exceptions
+     */
+    public static void assertNoException(Runnable runnable) {
+        withUncaughtExceptionHandler(runnable, FatalExitExceptionHandler.INSTANCE).run();
+    }
+
     /**
      * Guard {@link Runnable} with uncaughtException handler, because {@link
      * java.util.concurrent.ScheduledExecutorService} does not respect the one assigned to executing
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/EventReceivingTasks.java b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/EventReceivingTasks.java
index 05f692f0ad4..e1c58a3f4e6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/EventReceivingTasks.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/EventReceivingTasks.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.operators.coordination;
 
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
 import org.apache.flink.runtime.messages.Acknowledge;
+import org.apache.flink.runtime.operators.coordination.util.IncompleteFuturesTracker;
 import org.apache.flink.util.SerializedValue;
 import org.apache.flink.util.concurrent.Executors;
 import org.apache.flink.util.concurrent.FutureUtils;
@@ -105,7 +106,11 @@ public class EventReceivingTasks implements SubtaskAccess.SubtaskAccessFactory {
 
     public OperatorCoordinator.SubtaskGateway createGatewayForSubtask(int subtask) {
         final SubtaskAccess sta = getAccessForSubtask(subtask);
-        return new SubtaskGatewayImpl(sta, new OperatorEventValve(), Executors.directExecutor());
+        return new SubtaskGatewayImpl(
+                sta,
+                new OperatorEventValve(),
+                Executors.directExecutor(),
+                new IncompleteFuturesTracker());
     }
 
     public void switchTaskToRunning(int subtask) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
index 3d3cddc5aba..cfe31a459be 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
@@ -30,10 +30,13 @@ import org.apache.flink.util.TestLogger;
 import org.junit.After;
 import org.junit.Test;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 
 import java.nio.ByteBuffer;
+import java.util.ArrayDeque;
+import java.util.Queue;
 import java.util.Random;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
@@ -370,6 +373,70 @@ public class OperatorCoordinatorHolderTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testCheckpointFailsIfSendingEventFailedAfterTrigger() throws Exception {
+        CompletableFuture<Acknowledge> eventSendingResult = new CompletableFuture<>();
+        final EventReceivingTasks tasks =
+                EventReceivingTasks.createForRunningTasksWithRpcResult(eventSendingResult);
+        final OperatorCoordinatorHolder holder =
+                createCoordinatorHolder(tasks, TestingOperatorCoordinator::new);
+
+        // Send one event without finishing it.
+        getCoordinator(holder).getSubtaskGateway(0).sendEvent(new TestOperatorEvent(0));
+
+        // Trigger one checkpoint.
+        CompletableFuture<byte[]> checkpointResult = new CompletableFuture<>();
+        holder.checkpointCoordinator(1, checkpointResult);
+        getCoordinator(holder).getLastTriggeredCheckpoint().complete(new byte[0]);
+
+        // Fail the event sending.
+        eventSendingResult.completeExceptionally(new RuntimeException("Artificial"));
+
+        assertTrue(checkpointResult.isCompletedExceptionally());
+    }
+
+    @Test
+    public void testCheckpointFailsIfSendingEventFailedBeforeTrigger() throws Exception {
+        final ReorderableManualExecutorService executor = new ReorderableManualExecutorService();
+        final ComponentMainThreadExecutor mainThreadExecutor =
+                new ComponentMainThreadExecutorServiceAdapter(
+                        (ScheduledExecutorService) executor, Thread.currentThread());
+
+        CompletableFuture<Acknowledge> eventSendingResult = new CompletableFuture<>();
+        final EventReceivingTasks tasks =
+                EventReceivingTasks.createForRunningTasksWithRpcResult(eventSendingResult);
+
+        final OperatorCoordinatorHolder holder =
+                createCoordinatorHolder(tasks, TestingOperatorCoordinator::new, mainThreadExecutor);
+
+        // Send one event without finishing it.
+        getCoordinator(holder).getSubtaskGateway(0).sendEvent(new TestOperatorEvent(0));
+        executor.triggerAll();
+
+        // Finish the event sending. This will insert one runnable that handles
+        // failed events to the executor. And we delay this runnable to
+        // simulates checkpoints triggered before the failure get processed.
+        executor.setDelayNewRunnables(true);
+        eventSendingResult.completeExceptionally(new RuntimeException("Artificial"));
+        executor.setDelayNewRunnables(false);
+
+        // Trigger one checkpoint, the checkpoint should not be confirmed
+        // before the failure get triggered.
+        CompletableFuture<byte[]> checkpointResult = new CompletableFuture<>();
+        holder.checkpointCoordinator(1, checkpointResult);
+        executor.triggerAll();
+        getCoordinator(holder).getLastTriggeredCheckpoint().complete(new byte[0]);
+        executor.triggerAll();
+        assertFalse(checkpointResult.isDone());
+
+        // Then the failure finally get processed by fail the corresponding tasks.
+        executor.executeAllDelayedRunnables();
+        executor.triggerAll();
+
+        // The checkpoint would be finally confirmed.
+        assertTrue(checkpointResult.isCompletedExceptionally());
+    }
+
     // ------------------------------------------------------------------------
     //   test actions
     // ------------------------------------------------------------------------
@@ -446,6 +513,33 @@ public class OperatorCoordinatorHolderTest extends TestLogger {
         return holder;
     }
 
+    private static class ReorderableManualExecutorService
+            extends ManuallyTriggeredScheduledExecutorService {
+
+        private boolean delayNewRunnables;
+
+        private final Queue<Runnable> delayedRunnables = new ArrayDeque<>();
+
+        public void setDelayNewRunnables(boolean delayNewRunnables) {
+            this.delayNewRunnables = delayNewRunnables;
+        }
+
+        @Override
+        public void execute(@Nonnull Runnable command) {
+            if (delayNewRunnables) {
+                delayedRunnables.add(command);
+            } else {
+                super.execute(command);
+            }
+        }
+
+        public void executeAllDelayedRunnables() {
+            while (!delayedRunnables.isEmpty()) {
+                super.execute(delayedRunnables.poll());
+            }
+        }
+    }
+
     // ------------------------------------------------------------------------
     //   test implementations
     // ------------------------------------------------------------------------
