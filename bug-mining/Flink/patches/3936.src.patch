diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClient.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClient.java
index d5a5134cb79..a67a3198bce 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClient.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClient.java
@@ -18,12 +18,11 @@
 
 package org.apache.flink.kubernetes.kubeclient;
 
-import org.apache.flink.configuration.ConfigOption;
 import org.apache.flink.configuration.Configuration;
-import org.apache.flink.configuration.RestOptions;
 import org.apache.flink.kubernetes.configuration.KubernetesConfigOptions;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesPod;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesService;
+import org.apache.flink.kubernetes.utils.Constants;
 import org.apache.flink.kubernetes.utils.KubernetesUtils;
 
 import io.fabric8.kubernetes.api.model.HasMetadata;
@@ -126,20 +125,21 @@ public class Fabric8FlinkKubeClient implements FlinkKubeClient {
 	@Override
 	@Nullable
 	public Endpoint getRestEndpoint(String clusterId) {
-		int restPort = this.flinkConfig.getInteger(RestOptions.PORT);
-		final KubernetesConfigOptions.ServiceExposedType serviceExposedType = flinkConfig.get(KubernetesConfigOptions.REST_SERVICE_EXPOSED_TYPE);
+		final KubernetesService restService = getRestService(clusterId);
+		if (restService == null) {
+			return null;
+		}
+		final Service service = restService.getInternalResource();
+		final int restPort = getRestPortFromExternalService(service);
+
+		final KubernetesConfigOptions.ServiceExposedType serviceExposedType =
+			KubernetesConfigOptions.ServiceExposedType.valueOf(service.getSpec().getType());
 
 		// Return the service.namespace directly when use ClusterIP.
 		if (serviceExposedType == KubernetesConfigOptions.ServiceExposedType.ClusterIP) {
 			return new Endpoint(KubernetesUtils.getInternalServiceName(clusterId) + "." + nameSpace, restPort);
 		}
 
-		KubernetesService restService = getRestService(clusterId);
-		if (restService == null) {
-			return null;
-		}
-		Service service = restService.getInternalResource();
-
 		String address = null;
 
 		if (service.getStatus() != null && (service.getStatus().getLoadBalancer() != null ||
@@ -151,7 +151,6 @@ public class Fabric8FlinkKubeClient implements FlinkKubeClient {
 				}
 			} else {
 				address = this.internalClient.getMasterUrl().getHost();
-				restPort = getServiceNodePort(service, RestOptions.PORT);
 			}
 		} else if (service.getSpec().getExternalIPs() != null && service.getSpec().getExternalIPs().size() > 0) {
 			address = service.getSpec().getExternalIPs().get(0);
@@ -264,17 +263,32 @@ public class Fabric8FlinkKubeClient implements FlinkKubeClient {
 	}
 
 	/**
-	 * To get nodePort of configured ports.
+	 * Get rest port from the external Service.
 	 */
-	private int getServiceNodePort(Service service, ConfigOption<Integer> configPort) {
-		final int port = this.flinkConfig.getInteger(configPort);
-		if (service.getSpec() != null && service.getSpec().getPorts() != null) {
-			for (ServicePort p : service.getSpec().getPorts()) {
-				if (p.getPort() == port) {
-					return p.getNodePort();
-				}
-			}
+	private int getRestPortFromExternalService(Service externalService) {
+		final List<ServicePort> servicePortCandidates = externalService.getSpec().getPorts()
+			.stream()
+			.filter(x -> x.getName().equals(Constants.REST_PORT_NAME))
+			.collect(Collectors.toList());
+
+		if (servicePortCandidates.isEmpty()) {
+			throw new RuntimeException("Failed to find port \"" + Constants.REST_PORT_NAME + "\" in Service \"" +
+				KubernetesUtils.getRestServiceName(this.clusterId) + "\"");
+		}
+
+		final ServicePort externalServicePort = servicePortCandidates.get(0);
+
+		final KubernetesConfigOptions.ServiceExposedType externalServiceType =
+			KubernetesConfigOptions.ServiceExposedType.valueOf(externalService.getSpec().getType());
+
+		switch (externalServiceType) {
+			case ClusterIP:
+			case LoadBalancer:
+				return externalServicePort.getPort();
+			case NodePort:
+				return externalServicePort.getNodePort();
+			default:
+				throw new RuntimeException("Unrecognized Service type: " + externalServiceType);
 		}
-		return port;
 	}
 }
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClientTestBase.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClientTestBase.java
new file mode 100644
index 00000000000..beed8493a63
--- /dev/null
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClientTestBase.java
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.kubernetes;
+
+import org.apache.flink.kubernetes.configuration.KubernetesConfigOptions;
+import org.apache.flink.kubernetes.utils.Constants;
+import org.apache.flink.kubernetes.utils.KubernetesUtils;
+
+import io.fabric8.kubernetes.api.model.LoadBalancerIngress;
+import io.fabric8.kubernetes.api.model.LoadBalancerStatus;
+import io.fabric8.kubernetes.api.model.Service;
+import io.fabric8.kubernetes.api.model.ServiceBuilder;
+import io.fabric8.kubernetes.api.model.ServicePort;
+import io.fabric8.kubernetes.api.model.ServicePortBuilder;
+import io.fabric8.kubernetes.api.model.ServiceStatus;
+import io.fabric8.kubernetes.api.model.ServiceStatusBuilder;
+import org.junit.Before;
+
+import javax.annotation.Nullable;
+
+import java.util.Collections;
+
+/**
+ * Base class for {@link KubernetesClusterDescriptorTest} and
+ * {@link org.apache.flink.kubernetes.kubeclient.Fabric8FlinkKubeClientTest}.
+ */
+public class KubernetesClientTestBase extends KubernetesTestBase {
+
+	protected static final int REST_PORT = 9021;
+	protected static final int NODE_PORT = 31234;
+
+	@Before
+	public void setup() throws Exception {
+		super.setup();
+	}
+
+	protected void mockExpectedServiceFromServerSide(Service expectedService) {
+		final String serviceName = expectedService.getMetadata().getName();
+		final String path = String.format("/api/v1/namespaces/%s/services/%s", NAMESPACE, serviceName);
+		server.expect()
+			.get()
+			.withPath(path)
+			.andReturn(200, expectedService)
+			.always();
+	}
+
+	protected Service buildExternalServiceWithLoadBalancer(@Nullable String hostname, @Nullable String ip) {
+		final ServicePort servicePort = new ServicePortBuilder()
+			.withName(Constants.REST_PORT_NAME)
+			.withPort(REST_PORT)
+			.withNewTargetPort(REST_PORT)
+			.build();
+		final ServiceStatus serviceStatus = new ServiceStatusBuilder()
+			.withLoadBalancer(new LoadBalancerStatus(Collections.singletonList(new LoadBalancerIngress(hostname, ip))))
+			.build();
+
+		return buildExternalService(
+			KubernetesConfigOptions.ServiceExposedType.LoadBalancer,
+			servicePort,
+			serviceStatus);
+	}
+
+	protected Service buildExternalServiceWithNodePort() {
+		final ServicePort servicePort = new ServicePortBuilder()
+			.withName(Constants.REST_PORT_NAME)
+			.withPort(REST_PORT)
+			.withNodePort(NODE_PORT)
+			.withNewTargetPort(REST_PORT)
+			.build();
+
+		final ServiceStatus serviceStatus = new ServiceStatusBuilder()
+			.withLoadBalancer(new LoadBalancerStatus(Collections.emptyList()))
+			.build();
+
+		return buildExternalService(
+			KubernetesConfigOptions.ServiceExposedType.NodePort,
+			servicePort,
+			serviceStatus);
+	}
+
+	protected Service buildExternalServiceWithClusterIP() {
+		final ServicePort servicePort = new ServicePortBuilder()
+			.withName(Constants.REST_PORT_NAME)
+			.withPort(REST_PORT)
+			.withNewTargetPort(REST_PORT)
+			.build();
+
+		return buildExternalService(
+			KubernetesConfigOptions.ServiceExposedType.ClusterIP,
+			servicePort,
+			null);
+	}
+
+	private Service buildExternalService(
+			KubernetesConfigOptions.ServiceExposedType serviceExposedType,
+			ServicePort servicePort,
+			@Nullable ServiceStatus serviceStatus) {
+		final ServiceBuilder serviceBuilder = new ServiceBuilder()
+			.editOrNewMetadata()
+				.withName(KubernetesUtils.getRestServiceName(CLUSTER_ID))
+				.endMetadata()
+			.editOrNewSpec()
+				.withType(serviceExposedType.name())
+				.addNewPortLike(servicePort)
+					.endPort()
+				.endSpec();
+
+		if (serviceStatus != null) {
+			serviceBuilder.withStatus(serviceStatus);
+		}
+
+		return serviceBuilder.build();
+	}
+}
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClusterDescriptorTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClusterDescriptorTest.java
index fdbd0897b16..f298fbcc89b 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClusterDescriptorTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesClusterDescriptorTest.java
@@ -31,17 +31,11 @@ import org.apache.flink.runtime.jobmanager.HighAvailabilityMode;
 
 import io.fabric8.kubernetes.api.model.Container;
 import io.fabric8.kubernetes.api.model.EnvVar;
-import io.fabric8.kubernetes.api.model.LoadBalancerIngress;
-import io.fabric8.kubernetes.api.model.LoadBalancerStatus;
-import io.fabric8.kubernetes.api.model.Service;
-import io.fabric8.kubernetes.api.model.ServiceBuilder;
-import io.fabric8.kubernetes.api.model.ServiceStatusBuilder;
 import io.fabric8.kubernetes.api.model.apps.Deployment;
 import io.fabric8.kubernetes.client.KubernetesClient;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Collections;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.kubernetes.utils.Constants.ENV_FLINK_POD_IP_ADDRESS;
@@ -51,7 +45,7 @@ import static org.junit.Assert.assertTrue;
 /**
  * Tests for the {@link KubernetesClusterDescriptor}.
  */
-public class KubernetesClusterDescriptorTest extends KubernetesTestBase {
+public class KubernetesClusterDescriptorTest extends KubernetesClientTestBase {
 	private static final String MOCK_SERVICE_HOST_NAME = "mock-host-name-of-service";
 	private static final String MOCK_SERVICE_IP = "192.168.0.1";
 
@@ -62,7 +56,7 @@ public class KubernetesClusterDescriptorTest extends KubernetesTestBase {
 	public void setup() throws Exception {
 		super.setup();
 
-		mockGetRestServiceWithLoadBalancer(MOCK_SERVICE_HOST_NAME, MOCK_SERVICE_IP);
+		mockExpectedServiceFromServerSide(buildExternalServiceWithLoadBalancer(MOCK_SERVICE_HOST_NAME, MOCK_SERVICE_IP));
 	}
 
 	@Test
@@ -154,35 +148,8 @@ public class KubernetesClusterDescriptorTest extends KubernetesTestBase {
 
 		assertEquals(CLUSTER_ID, clusterClient.getClusterId());
 		// Both HA and non-HA mode, the web interface should always be the Kubernetes exposed service address.
-		assertEquals(String.format("http://%s:8081", MOCK_SERVICE_IP), clusterClient.getWebInterfaceURL());
+		assertEquals(String.format("http://%s:%d", MOCK_SERVICE_IP, REST_PORT), clusterClient.getWebInterfaceURL());
 
 		return clusterClient;
 	}
-
-	private void mockGetRestServiceWithLoadBalancer(String hostname, String ip) {
-		final String restServiceName = KubernetesUtils.getRestServiceName(CLUSTER_ID);
-
-		final String path = String.format("/api/v1/namespaces/%s/services/%s", NAMESPACE, restServiceName);
-		server.expect()
-			.get()
-			.withPath(path)
-			.andReturn(200, buildMockRestService(hostname, ip))
-			.always();
-	}
-
-	private Service buildMockRestService(String hostname, String ip) {
-		final Service service = new ServiceBuilder()
-			.editOrNewMetadata()
-				.withName(KubernetesUtils.getRestServiceName(CLUSTER_ID))
-				.endMetadata()
-			.editOrNewSpec()
-				.endSpec()
-			.build();
-
-		service.setStatus(new ServiceStatusBuilder()
-			.withLoadBalancer(new LoadBalancerStatus(Collections.singletonList(
-				new LoadBalancerIngress(hostname, ip)))).build());
-
-		return service;
-	}
 }
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClientTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClientTest.java
index 351f7644e60..57737f34120 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClientTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/kubeclient/Fabric8FlinkKubeClientTest.java
@@ -22,7 +22,7 @@ import org.apache.flink.client.deployment.ClusterSpecification;
 import org.apache.flink.configuration.BlobServerOptions;
 import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.configuration.RestOptions;
-import org.apache.flink.kubernetes.KubernetesTestBase;
+import org.apache.flink.kubernetes.KubernetesClientTestBase;
 import org.apache.flink.kubernetes.KubernetesTestUtils;
 import org.apache.flink.kubernetes.configuration.KubernetesConfigOptions;
 import org.apache.flink.kubernetes.configuration.KubernetesConfigOptionsInternal;
@@ -30,37 +30,30 @@ import org.apache.flink.kubernetes.entrypoint.KubernetesSessionClusterEntrypoint
 import org.apache.flink.kubernetes.kubeclient.factory.KubernetesJobManagerFactory;
 import org.apache.flink.kubernetes.kubeclient.parameters.KubernetesJobManagerParameters;
 import org.apache.flink.kubernetes.kubeclient.resources.KubernetesPod;
-import org.apache.flink.kubernetes.utils.KubernetesUtils;
 
 import io.fabric8.kubernetes.api.model.ConfigMap;
 import io.fabric8.kubernetes.api.model.HasMetadata;
-import io.fabric8.kubernetes.api.model.LoadBalancerIngress;
-import io.fabric8.kubernetes.api.model.LoadBalancerStatus;
 import io.fabric8.kubernetes.api.model.OwnerReference;
 import io.fabric8.kubernetes.api.model.Pod;
 import io.fabric8.kubernetes.api.model.PodBuilder;
 import io.fabric8.kubernetes.api.model.Service;
-import io.fabric8.kubernetes.api.model.ServiceBuilder;
-import io.fabric8.kubernetes.api.model.ServiceStatusBuilder;
 import io.fabric8.kubernetes.api.model.apps.Deployment;
 import org.junit.Before;
 import org.junit.Test;
 
-import javax.annotation.Nullable;
-
-import java.util.Collections;
 import java.util.List;
 
+import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests for Fabric implementation of {@link FlinkKubeClient}.
  */
-public class Fabric8FlinkKubeClientTest extends KubernetesTestBase {
-	private static final int REST_PORT = 9081;
+public class Fabric8FlinkKubeClientTest extends KubernetesClientTestBase {
 	private static final int RPC_PORT = 7123;
 	private static final int BLOB_SERVER_PORT = 8346;
 
@@ -178,7 +171,7 @@ public class Fabric8FlinkKubeClientTest extends KubernetesTestBase {
 	@Test
 	public void testServiceLoadBalancerWithNoIP() {
 		final String hostName = "test-host-name";
-		mockRestServiceWithLB(hostName, "");
+		mockExpectedServiceFromServerSide(buildExternalServiceWithLoadBalancer(hostName, ""));
 
 		final Endpoint resultEndpoint = flinkKubeClient.getRestEndpoint(CLUSTER_ID);
 
@@ -188,7 +181,7 @@ public class Fabric8FlinkKubeClientTest extends KubernetesTestBase {
 
 	@Test
 	public void testServiceLoadBalancerEmptyHostAndIP() {
-		mockRestServiceWithLB("", "");
+		mockExpectedServiceFromServerSide(buildExternalServiceWithLoadBalancer("", ""));
 
 		final Endpoint resultEndpoint1 = flinkKubeClient.getRestEndpoint(CLUSTER_ID);
 		assertNull(resultEndpoint1);
@@ -196,12 +189,28 @@ public class Fabric8FlinkKubeClientTest extends KubernetesTestBase {
 
 	@Test
 	public void testServiceLoadBalancerNullHostAndIP() {
-		mockRestServiceWithLB(null, null);
+		mockExpectedServiceFromServerSide(buildExternalServiceWithLoadBalancer(null, null));
 
 		final Endpoint resultEndpoint2 = flinkKubeClient.getRestEndpoint(CLUSTER_ID);
 		assertNull(resultEndpoint2);
 	}
 
+	@Test
+	public void testNodePortService() {
+		mockExpectedServiceFromServerSide(buildExternalServiceWithNodePort());
+
+		final Endpoint resultEndpoint = flinkKubeClient.getRestEndpoint(CLUSTER_ID);
+		assertThat(resultEndpoint.getPort(), is(NODE_PORT));
+	}
+
+	@Test
+	public void testClusterIPService() {
+		mockExpectedServiceFromServerSide(buildExternalServiceWithClusterIP());
+		final Endpoint resultEndpoint = flinkKubeClient.getRestEndpoint(CLUSTER_ID);
+
+		assertThat(resultEndpoint.getPort(), is(REST_PORT));
+	}
+
 	@Test
 	public void testStopAndCleanupCluster() throws Exception {
 		this.flinkKubeClient.createJobManagerComponent(this.kubernetesJobManagerSpecification);
@@ -223,31 +232,4 @@ public class Fabric8FlinkKubeClientTest extends KubernetesTestBase {
 		this.flinkKubeClient.stopAndCleanupCluster(CLUSTER_ID);
 		assertTrue(this.kubeClient.apps().deployments().inNamespace(NAMESPACE).list().getItems().isEmpty());
 	}
-
-	private void mockRestServiceWithLB(@Nullable String hostname, @Nullable String ip) {
-		final String restServiceName = KubernetesUtils.getRestServiceName(CLUSTER_ID);
-
-		final String path = String.format("/api/v1/namespaces/%s/services/%s", NAMESPACE, restServiceName);
-		server.expect()
-			.withPath(path)
-			.andReturn(200, buildMockRestServiceWithLB(hostname, ip))
-			.always();
-
-		final Service resultService = kubeClient.services()
-			.inNamespace(NAMESPACE)
-			.withName(KubernetesUtils.getRestServiceName(CLUSTER_ID))
-			.get();
-		assertNotNull(resultService);
-	}
-
-	private Service buildMockRestServiceWithLB(@Nullable String hostname, @Nullable String ip) {
-		final Service service = new ServiceBuilder()
-			.build();
-
-		service.setStatus(new ServiceStatusBuilder()
-			.withLoadBalancer(new LoadBalancerStatus(Collections.singletonList(
-				new LoadBalancerIngress(hostname, ip)))).build());
-
-		return service;
-	}
 }
