diff --git a/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java b/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java
index 34f93f658eb..23ea740829e 100644
--- a/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java
+++ b/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java
@@ -60,6 +60,13 @@ public final class HybridMemorySegment extends MemorySegment {
      */
     @Nullable private ByteBuffer offHeapBuffer;
 
+    /**
+     * Wrapping is not allowed when the underlying memory is unsafe. Unsafe memory can be actively
+     * released, without reference counting. Therefore, access from wrapped buffers, which may not
+     * be aware of the releasing of memory, could be risky.
+     */
+    private final boolean allowWrap;
+
     /**
      * Creates a new memory segment that represents the memory backing the given direct byte buffer.
      * Note that the given ByteBuffer must be direct {@link
@@ -73,8 +80,26 @@ public final class HybridMemorySegment extends MemorySegment {
      * @throws IllegalArgumentException Thrown, if the given ByteBuffer is not direct.
      */
     HybridMemorySegment(@Nonnull ByteBuffer buffer, @Nullable Object owner) {
+        this(buffer, owner, true);
+    }
+
+    /**
+     * Creates a new memory segment that represents the memory backing the given direct byte buffer.
+     * Note that the given ByteBuffer must be direct {@link
+     * java.nio.ByteBuffer#allocateDirect(int)}, otherwise this method with throw an
+     * IllegalArgumentException.
+     *
+     * <p>The memory segment references the given owner.
+     *
+     * @param buffer The byte buffer whose memory is represented by this memory segment.
+     * @param owner The owner references by this memory segment.
+     * @param allowWrap Whether wrapping {@link ByteBuffer}s from the segment is allowed.
+     * @throws IllegalArgumentException Thrown, if the given ByteBuffer is not direct.
+     */
+    HybridMemorySegment(@Nonnull ByteBuffer buffer, @Nullable Object owner, boolean allowWrap) {
         super(getByteBufferAddress(buffer), buffer.capacity(), owner);
         this.offHeapBuffer = buffer;
+        this.allowWrap = allowWrap;
     }
 
     /**
@@ -88,6 +113,7 @@ public final class HybridMemorySegment extends MemorySegment {
     HybridMemorySegment(byte[] buffer, Object owner) {
         super(buffer, owner);
         this.offHeapBuffer = null;
+        this.allowWrap = true;
     }
 
     // -------------------------------------------------------------------------
@@ -102,6 +128,10 @@ public final class HybridMemorySegment extends MemorySegment {
 
     @Override
     public ByteBuffer wrap(int offset, int length) {
+        if (!allowWrap) {
+            throw new UnsupportedOperationException(
+                    "Wrap is not supported by this segment. This usually indicates that the underlying memory is unsafe, thus transferring of ownership is not allowed.");
+        }
         return wrapInternal(offset, length);
     }
 
diff --git a/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegmentFactory.java b/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegmentFactory.java
index 6a0eff476ff..09874962b10 100644
--- a/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegmentFactory.java
+++ b/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegmentFactory.java
@@ -176,7 +176,7 @@ public final class MemorySegmentFactory {
         long address = MemoryUtils.allocateUnsafe(size);
         ByteBuffer offHeapBuffer = MemoryUtils.wrapUnsafeMemoryWithByteBuffer(address, size);
         MemoryUtils.createMemoryGcCleaner(offHeapBuffer, address, customCleanupAction);
-        return new HybridMemorySegment(offHeapBuffer, owner);
+        return new HybridMemorySegment(offHeapBuffer, owner, false);
     }
 
     /**
diff --git a/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapDirectMemorySegmentTest.java b/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapDirectMemorySegmentTest.java
index c1b9737c8eb..e39295ea911 100644
--- a/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapDirectMemorySegmentTest.java
+++ b/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapDirectMemorySegmentTest.java
@@ -18,12 +18,21 @@
 
 package org.apache.flink.core.memory;
 
+import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
+import java.nio.ByteBuffer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 /** Tests for the {@link HybridMemorySegment} in off-heap mode using direct memory. */
 @RunWith(Parameterized.class)
-public class HybridOffHeapDirectMemorySegmentTest extends HybridOffHeapMemorySegmentTest {
+public class HybridOffHeapDirectMemorySegmentTest extends MemorySegmentTestBase {
 
     public HybridOffHeapDirectMemorySegmentTest(int pageSize) {
         super(pageSize);
@@ -38,4 +47,31 @@ public class HybridOffHeapDirectMemorySegmentTest extends HybridOffHeapMemorySeg
     MemorySegment createSegment(int size, Object owner) {
         return MemorySegmentFactory.allocateUnpooledOffHeapMemory(size, owner);
     }
+
+    @Test
+    public void testHybridHeapSegmentSpecifics() {
+        final int bufSize = 411;
+        HybridMemorySegment seg = (HybridMemorySegment) createSegment(bufSize);
+
+        assertFalse(seg.isFreed());
+        assertTrue(seg.isOffHeap());
+        assertEquals(bufSize, seg.size());
+
+        try {
+            //noinspection ResultOfMethodCallIgnored
+            seg.getArray();
+            fail("should throw an exception");
+        } catch (IllegalStateException e) {
+            // expected
+        }
+
+        ByteBuffer buf1 = seg.wrap(1, 2);
+        ByteBuffer buf2 = seg.wrap(3, 4);
+
+        assertNotSame(buf1, buf2);
+        assertEquals(1, buf1.position());
+        assertEquals(3, buf1.limit());
+        assertEquals(3, buf2.position());
+        assertEquals(7, buf2.limit());
+    }
 }
diff --git a/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapMemorySegmentTest.java b/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapMemorySegmentTest.java
deleted file mode 100644
index c746b481e8b..00000000000
--- a/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapMemorySegmentTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.core.memory;
-
-import org.junit.Test;
-
-import java.nio.ByteBuffer;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/** Tests for the {@link HybridMemorySegment} in off-heap mode. */
-public abstract class HybridOffHeapMemorySegmentTest extends MemorySegmentTestBase {
-
-    HybridOffHeapMemorySegmentTest(int pageSize) {
-        super(pageSize);
-    }
-
-    @Test
-    public void testHybridHeapSegmentSpecifics() {
-        final int bufSize = 411;
-        HybridMemorySegment seg = (HybridMemorySegment) createSegment(bufSize);
-
-        assertFalse(seg.isFreed());
-        assertTrue(seg.isOffHeap());
-        assertEquals(bufSize, seg.size());
-
-        try {
-            //noinspection ResultOfMethodCallIgnored
-            seg.getArray();
-            fail("should throw an exception");
-        } catch (IllegalStateException e) {
-            // expected
-        }
-
-        ByteBuffer buf1 = seg.wrap(1, 2);
-        ByteBuffer buf2 = seg.wrap(3, 4);
-
-        assertNotSame(buf1, buf2);
-        assertEquals(1, buf1.position());
-        assertEquals(3, buf1.limit());
-        assertEquals(3, buf2.position());
-        assertEquals(7, buf2.limit());
-    }
-}
diff --git a/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapUnsafeMemorySegmentTest.java b/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapUnsafeMemorySegmentTest.java
index 111341f74f0..d6663578bee 100644
--- a/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapUnsafeMemorySegmentTest.java
+++ b/flink-core/src/test/java/org/apache/flink/core/memory/HybridOffHeapUnsafeMemorySegmentTest.java
@@ -18,12 +18,13 @@
 
 package org.apache.flink.core.memory;
 
+import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
 /** Tests for the {@link HybridMemorySegment} in off-heap mode using unsafe memory. */
 @RunWith(Parameterized.class)
-public class HybridOffHeapUnsafeMemorySegmentTest extends HybridOffHeapMemorySegmentTest {
+public class HybridOffHeapUnsafeMemorySegmentTest extends MemorySegmentTestBase {
 
     public HybridOffHeapUnsafeMemorySegmentTest(int pageSize) {
         super(pageSize);
@@ -38,4 +39,10 @@ public class HybridOffHeapUnsafeMemorySegmentTest extends HybridOffHeapMemorySeg
     MemorySegment createSegment(int size, Object owner) {
         return MemorySegmentFactory.allocateOffHeapUnsafeMemory(size, owner, () -> {});
     }
+
+    @Override
+    @Test(expected = UnsupportedOperationException.class)
+    public void testByteBufferWrapping() {
+        createSegment(10).wrap(1, 2);
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/memory/MemoryManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/memory/MemoryManagerTest.java
index 9c6fe388ba6..15b380f9de9 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/memory/MemoryManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/memory/MemoryManagerTest.java
@@ -27,12 +27,10 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Random;
-import java.util.stream.Collectors;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
@@ -293,57 +291,6 @@ public class MemoryManagerTest {
         memoryManager.releaseAllMemory(owner2);
     }
 
-    @Test(expected = MemoryAllocationException.class)
-    public void testAllocationFailsIfSegmentsNotGced() throws MemoryAllocationException {
-        List<ByteBuffer> byteBuffers = allocateAndReleaseAllSegmentsButKeepWrappedBufferRefs();
-        // this allocation should fail
-        memoryManager.allocatePages(new Object(), 1);
-        // this should not be reached but keeps the reference to the allocated memory and prevents
-        // its GC
-        byteBuffers.get(0).put(0, (byte) 1);
-    }
-
-    @Test(expected = MemoryReservationException.class)
-    public void testReservationFailsIfSegmentsNotGced()
-            throws MemoryAllocationException, MemoryReservationException {
-        List<ByteBuffer> byteBuffers = allocateAndReleaseAllSegmentsButKeepWrappedBufferRefs();
-        // this allocation should fail
-        memoryManager.reserveMemory(new Object(), MemoryManager.DEFAULT_PAGE_SIZE);
-        // this should not be reached but keeps the reference to the allocated memory and prevents
-        // its GC
-        byteBuffers.get(0).put(0, (byte) 1);
-    }
-
-    @Test
-    public void testAllocationSuccessIfSegmentsGced() throws MemoryAllocationException {
-        allocateAndReleaseAllSegmentsButKeepWrappedBufferRefs();
-        // no reference to the allocated segments at this point, so the memory should be released by
-        // GC
-        // and this allocation should be successful
-        memoryManager.release(memoryManager.allocatePages(new Object(), 1));
-    }
-
-    @Test
-    public void testReservationSuccessIfSegmentsGced()
-            throws MemoryAllocationException, MemoryReservationException {
-        allocateAndReleaseAllSegmentsButKeepWrappedBufferRefs();
-        // no reference to the allocated segments at this point, so the memory should be released by
-        // GC
-        Object owner = new Object();
-        // and this reservation should be successful
-        memoryManager.reserveMemory(owner, MemoryManager.DEFAULT_PAGE_SIZE);
-        memoryManager.releaseMemory(owner, MemoryManager.DEFAULT_PAGE_SIZE);
-    }
-
-    private List<ByteBuffer> allocateAndReleaseAllSegmentsButKeepWrappedBufferRefs()
-            throws MemoryAllocationException {
-        List<MemorySegment> segments = memoryManager.allocatePages(new Object(), NUM_PAGES);
-        List<ByteBuffer> buffers =
-                segments.stream().map(segment -> segment.wrap(0, 1)).collect(Collectors.toList());
-        memoryManager.release(segments);
-        return buffers;
-    }
-
     @Test
     public void testComputeMemorySize() {
         double fraction = 0.6;
