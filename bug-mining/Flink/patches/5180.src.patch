diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java
index 12971ab18ea..af6ce94151a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateCheckpointWriter.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.checkpoint.channel;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter.ChannelStateWriteResult;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;
 import org.apache.flink.runtime.state.AbstractChannelStateHandle;
 import org.apache.flink.runtime.state.AbstractChannelStateHandle.StateContentMetaInfo;
 import org.apache.flink.runtime.state.CheckpointStreamFactory;
@@ -127,15 +128,29 @@ class ChannelStateCheckpointWriter {
     }
 
     void writeInput(InputChannelInfo info, Buffer buffer) throws Exception {
-        write(inputChannelOffsets, info, buffer, !allInputsReceived);
+        write(
+                inputChannelOffsets,
+                info,
+                buffer,
+                !allInputsReceived,
+                "ChannelStateCheckpointWriter#writeInput");
     }
 
     void writeOutput(ResultSubpartitionInfo info, Buffer buffer) throws Exception {
-        write(resultSubpartitionOffsets, info, buffer, !allOutputsReceived);
+        write(
+                resultSubpartitionOffsets,
+                info,
+                buffer,
+                !allOutputsReceived,
+                "ChannelStateCheckpointWriter#writeOutput");
     }
 
     private <K> void write(
-            Map<K, StateContentMetaInfo> offsets, K key, Buffer buffer, boolean precondition)
+            Map<K, StateContentMetaInfo> offsets,
+            K key,
+            Buffer buffer,
+            boolean precondition,
+            String action)
             throws Exception {
         try {
             if (result.isDone()) {
@@ -145,7 +160,10 @@ class ChannelStateCheckpointWriter {
                     () -> {
                         checkState(precondition);
                         long offset = checkpointStream.getPos();
-                        serializer.writeData(dataStream, buffer);
+                        try (AutoCloseable ignored =
+                                NetworkActionsLogger.measureIO(action, buffer)) {
+                            serializer.writeData(dataStream, buffer);
+                        }
                         long size = checkpointStream.getPos() - offset;
                         offsets.computeIfAbsent(key, unused -> new StateContentMetaInfo())
                                 .withDataAdded(offset, size);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java
index 295274a1ada..8329c713f92 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java
@@ -23,10 +23,12 @@ import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
 import org.apache.flink.runtime.checkpoint.StateObjectCollection;
 import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;
 import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;
+import org.apache.flink.runtime.io.network.logger.NetworkActionsLogger;
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.state.AbstractChannelStateHandle;
 import org.apache.flink.runtime.state.StreamStateHandle;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.HashSet;
@@ -195,8 +197,12 @@ class ChannelStateChunkReader {
             RecoveredChannelStateHandler.BufferWithContext<Context> bufferWithContext =
                     stateHandler.getBuffer(channelInfo);
             try {
-                while (length > 0 && bufferWithContext.buffer.isWritable()) {
-                    length -= serializer.readData(source, bufferWithContext.buffer, length);
+                try (Closeable ignored =
+                        NetworkActionsLogger.measureIO(
+                                "ChannelStateChunkReader#readChunk", bufferWithContext.buffer)) {
+                    while (length > 0 && bufferWithContext.buffer.isWritable()) {
+                        length -= serializer.readData(source, bufferWithContext.buffer, length);
+                    }
                 }
                 stateHandler.recover(channelInfo, oldSubtaskIndex, bufferWithContext.context);
             } catch (Exception e) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java
index 531a2455bae..0de200c5e45 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/logger/NetworkActionsLogger.java
@@ -27,6 +27,8 @@ import org.apache.flink.runtime.io.network.partition.consumer.ChannelStatePersis
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.Closeable;
+
 /**
  * Utility class for logging actions that happened in the network stack for debugging purposes.
  *
@@ -99,4 +101,27 @@ public class NetworkActionsLogger {
                     channelInfo);
         }
     }
+
+    private static final long MAX_EXPECTED_IO_TIME_IN_MS = 100L;
+
+    public static Closeable measureIO(String action, Object entity) {
+        if (!LOG.isDebugEnabled()) {
+            // seems to be completely inlined by JIT
+            return NO_MEASURE;
+        }
+        // adds around 100ns in a try-with-resource statement on a i7-9750H CPU @ 2.60GHz
+        long startTime = System.currentTimeMillis();
+        return () -> {
+            long elapsedTime = System.currentTimeMillis() - startTime;
+            if (elapsedTime > MAX_EXPECTED_IO_TIME_IN_MS) {
+                LOG.debug(
+                        "{} {} took unexpected long ({} ms) indicating that the checkpoint storage is overloaded.",
+                        action,
+                        entity,
+                        elapsedTime);
+            }
+        };
+    }
+
+    private static final Closeable NO_MEASURE = () -> {};
 }
