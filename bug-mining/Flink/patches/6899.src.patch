diff --git a/flink-clients/src/test/java/org/apache/flink/client/ClientHeartbeatTest.java b/flink-clients/src/test/java/org/apache/flink/client/ClientHeartbeatTest.java
index d1861450f8d..e37f1dd4056 100644
--- a/flink-clients/src/test/java/org/apache/flink/client/ClientHeartbeatTest.java
+++ b/flink-clients/src/test/java/org/apache/flink/client/ClientHeartbeatTest.java
@@ -23,6 +23,7 @@ import org.apache.flink.client.program.PerJobMiniClusterFactory;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.DeploymentOptions;
 import org.apache.flink.core.execution.JobClient;
+import org.apache.flink.runtime.dispatcher.Dispatcher;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphTestUtils;
 import org.apache.flink.runtime.jobgraph.JobVertex;
@@ -30,7 +31,6 @@ import org.apache.flink.runtime.minicluster.MiniCluster;
 import org.apache.flink.runtime.testutils.WaitingCancelableInvokable;
 
 import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 
 import java.time.Duration;
@@ -68,7 +68,6 @@ public class ClientHeartbeatTest {
     }
 
     @Test
-    @Disabled("Disable until FLINK-30629 is fixed.")
     void testJobRunningIfClientReportHeartbeat() throws Exception {
         JobClient jobClient = submitJob(createConfiguration(true));
 
@@ -93,6 +92,9 @@ public class ClientHeartbeatTest {
 
     private Configuration createConfiguration(boolean shutdownOnAttachedExit) {
         Configuration configuration = new Configuration();
+        configuration.set(
+                Dispatcher.CLIENT_ALIVENESS_CHECK_DURATION,
+                Duration.ofMillis(clientHeartbeatTimeout));
         if (shutdownOnAttachedExit) {
             configuration.setBoolean(DeploymentOptions.ATTACHED, true);
             configuration.setBoolean(DeploymentOptions.SHUTDOWN_IF_ATTACHED, true);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index 83c493a2ad4..1dad8df9ad1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -27,6 +27,8 @@ import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.configuration.BlobServerOptions;
 import org.apache.flink.configuration.CheckpointingOptions;
 import org.apache.flink.configuration.ClusterOptions;
+import org.apache.flink.configuration.ConfigOption;
+import org.apache.flink.configuration.ConfigOptions;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.configuration.PipelineOptions;
@@ -96,6 +98,7 @@ import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 import java.io.IOException;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -125,12 +128,16 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
 public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
         implements DispatcherGateway {
 
+    @VisibleForTesting
+    public static final ConfigOption<Duration> CLIENT_ALIVENESS_CHECK_DURATION =
+            ConfigOptions.key("$internal.dispatcher.client-aliveness-check.interval")
+                    .durationType()
+                    .defaultValue(Duration.ofMinutes(1));
+
     public static final String DISPATCHER_NAME = "dispatcher";
 
     private static final int INITIAL_JOB_MANAGER_RUNNER_REGISTRY_CAPACITY = 16;
 
-    private static final long MAX_JOB_CLIENT_ALIVENESS_CHECK_INTERVAL = 60_000;
-
     private final Configuration configuration;
 
     private final JobGraphWriter jobGraphWriter;
@@ -177,7 +184,10 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
     private final ResourceCleaner globalResourceCleaner;
 
     private final Time webTimeout;
+
     private final Map<JobID, Long> jobClientExpiredTimestamp = new HashMap<>();
+    private final Map<JobID, Long> uninitializedJobClientHeartbeatTimeout = new HashMap<>();
+    private final long jobClientAlivenessCheckInterval;
     private ScheduledFuture<?> jobClientAlivenessCheck;
 
     /** Enum to distinguish between initial job submission and re-submission for recovery. */
@@ -294,6 +304,9 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
                 resourceCleanerFactory.createGlobalResourceCleaner(this.getMainThreadExecutor());
 
         this.webTimeout = Time.milliseconds(configuration.getLong(WebOptions.TIMEOUT));
+
+        this.jobClientAlivenessCheckInterval =
+                configuration.get(CLIENT_ALIVENESS_CHECK_DURATION).toMillis();
     }
 
     // ------------------------------------------------------
@@ -388,8 +401,7 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
                     "Begin to detect the client's aliveness for job {}. The heartbeat timeout is {}",
                     jobID,
                     initialClientHeartbeatTimeout);
-            jobClientExpiredTimestamp.put(
-                    jobID, System.currentTimeMillis() + initialClientHeartbeatTimeout);
+            uninitializedJobClientHeartbeatTimeout.put(jobID, initialClientHeartbeatTimeout);
 
             if (jobClientAlivenessCheck == null) {
                 // Use the client heartbeat timeout as the check interval.
@@ -401,7 +413,7 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
                                                 getMainThreadExecutor()
                                                         .execute(this::checkJobClientAliveness),
                                         0L,
-                                        initialClientHeartbeatTimeout,
+                                        jobClientAlivenessCheckInterval,
                                         TimeUnit.MILLISECONDS);
             }
         }
@@ -1080,6 +1092,8 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
     }
 
     private void checkJobClientAliveness() {
+        setClientHeartbeatTimeoutForInitializedJob();
+
         long currentTimestamp = System.currentTimeMillis();
         Iterator<Map.Entry<JobID, Long>> iterator = jobClientExpiredTimestamp.entrySet().iterator();
         while (iterator.hasNext()) {
@@ -1101,6 +1115,22 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId>
         }
     }
 
+    private void setClientHeartbeatTimeoutForInitializedJob() {
+        Iterator<Map.Entry<JobID, Long>> iterator =
+                uninitializedJobClientHeartbeatTimeout.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<JobID, Long> entry = iterator.next();
+            JobID jobID = entry.getKey();
+            Optional<JobManagerRunner> jobManagerRunnerOptional = getJobManagerRunner(jobID);
+            if (!jobManagerRunnerOptional.isPresent()) {
+                iterator.remove();
+            } else if (jobManagerRunnerOptional.get().isInitialized()) {
+                jobClientExpiredTimestamp.put(jobID, System.currentTimeMillis() + entry.getValue());
+                iterator.remove();
+            }
+        }
+    }
+
     private void registerJobManagerRunnerTerminationFuture(
             JobID jobId, CompletableFuture<Void> jobManagerRunnerTerminationFuture) {
         Preconditions.checkState(!jobManagerRunnerTerminationFutures.containsKey(jobId));
