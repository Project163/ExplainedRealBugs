diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/MailboxOperatorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/MailboxOperatorTest.java
index ad75534a603..2117298601e 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/MailboxOperatorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/operators/MailboxOperatorTest.java
@@ -19,31 +19,25 @@ package org.apache.flink.streaming.runtime.operators;
 
 import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
 import org.apache.flink.api.common.typeutils.base.IntSerializer;
-import org.apache.flink.runtime.jobgraph.OperatorID;
-import org.apache.flink.streaming.api.operators.AbstractStreamOperator;
-import org.apache.flink.streaming.api.operators.AbstractStreamOperatorFactory;
-import org.apache.flink.streaming.api.operators.ChainingStrategy;
 import org.apache.flink.streaming.api.operators.MailboxExecutor;
-import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
-import org.apache.flink.streaming.api.operators.OneInputStreamOperatorFactory;
-import org.apache.flink.streaming.api.operators.StreamOperator;
-import org.apache.flink.streaming.api.operators.StreamOperatorParameters;
-import org.apache.flink.streaming.api.operators.YieldingOperatorFactory;
+import org.apache.flink.streaming.api.operators.StreamMap;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.tasks.OneInputStreamTask;
-import org.apache.flink.streaming.runtime.tasks.OneInputStreamTaskTestHarness;
+import org.apache.flink.streaming.runtime.tasks.StreamTaskMailboxTestHarness;
+import org.apache.flink.streaming.runtime.tasks.StreamTaskMailboxTestHarnessBuilder;
 import org.apache.flink.util.TestLogger;
 import org.apache.flink.util.function.RunnableWithException;
 
 import org.junit.Test;
 
-import java.util.ArrayList;
-import java.util.List;
+import javax.annotation.Nonnull;
+
 import java.util.concurrent.RejectedExecutionException;
-import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertThat;
 
 /**
  * Test to verify that timer triggers are run according to operator precedence (combined with
@@ -53,136 +47,60 @@ public class MailboxOperatorTest extends TestLogger {
 
     @Test
     public void testAvoidTaskStarvation() throws Exception {
-        final OneInputStreamTaskTestHarness<Integer, Integer> testHarness =
-                new OneInputStreamTaskTestHarness<>(
-                        OneInputStreamTask::new,
-                        BasicTypeInfo.INT_TYPE_INFO,
-                        BasicTypeInfo.INT_TYPE_INFO);
-
-        final int maxProcessingElements = 3;
-
-        testHarness
-                .setupOperatorChain(
-                        new OperatorID(), new ReplicatingMailOperatorFactory(maxProcessingElements))
-                .chain(
-                        new OperatorID(),
-                        new ReplicatingMailOperatorFactory(maxProcessingElements),
-                        IntSerializer.INSTANCE)
-                .finish();
-
-        testHarness.invoke();
-        testHarness.waitForTaskRunning();
-
-        for (int i = 0; i < maxProcessingElements; i++) {
-            testHarness.processElement(new StreamRecord<>(0));
-        }
-
-        testHarness.endInput();
-        testHarness.waitForTaskCompletion();
-
-        // with each input two mails should be processed, one of each operator in the chain
-        List<Integer> expected = new ArrayList<>();
-        for (int i = 0; i < maxProcessingElements; i++) {
-            expected.add(i * 2);
-        }
-        List<Integer> numMailsProcessed =
-                testHarness.getOutput().stream()
-                        .map(element -> ((StreamRecord<Integer>) element).getValue())
-                        .collect(Collectors.toList());
-        assertThat(numMailsProcessed, is(expected));
-    }
-
-    private static class ReplicatingMailOperatorFactory
-            extends AbstractStreamOperatorFactory<Integer>
-            implements OneInputStreamOperatorFactory<Integer, Integer>,
-                    YieldingOperatorFactory<Integer> {
-
-        private final int maxProcessingElements;
-
-        private MailboxExecutor mailboxExecutor;
-
-        ReplicatingMailOperatorFactory(final int maxProcessingElements) {
-            this.maxProcessingElements = maxProcessingElements;
-        }
-
-        @Override
-        public void setMailboxExecutor(MailboxExecutor mailboxExecutor) {
-            this.mailboxExecutor = mailboxExecutor;
-        }
-
-        @Override
-        public <Operator extends StreamOperator<Integer>> Operator createStreamOperator(
-                StreamOperatorParameters<Integer> parameters) {
-            ReplicatingMailOperator operator =
-                    new ReplicatingMailOperator(maxProcessingElements, mailboxExecutor);
-            operator.setProcessingTimeService(processingTimeService);
-            operator.setup(
-                    parameters.getContainingTask(),
-                    parameters.getStreamConfig(),
-                    parameters.getOutput());
-            return (Operator) operator;
-        }
-
-        @Override
-        public void setChainingStrategy(ChainingStrategy strategy) {}
-
-        @Override
-        public Class<? extends StreamOperator> getStreamOperatorClass(ClassLoader classLoader) {
-            return ReplicatingMailOperator.class;
-        }
-    }
-
-    private static class ReplicatingMailOperator extends AbstractStreamOperator<Integer>
-            implements OneInputStreamOperator<Integer, Integer> {
-
-        private final int maxProcessingElements;
-
-        private final ReplicatingMail replicatingMail;
-
-        private long numProcessedElements = 0;
-
-        ReplicatingMailOperator(
-                final int maxProcessingElements, final MailboxExecutor mailboxExecutor) {
-            this.maxProcessingElements = maxProcessingElements;
-            this.replicatingMail = new ReplicatingMail(mailboxExecutor);
-        }
-
-        @Override
-        public void processElement(StreamRecord<Integer> upstreamMailCount) throws Exception {
-            if (numProcessedElements >= maxProcessingElements) {
-                return;
+        final int numRecords = 3;
+
+        StreamTaskMailboxTestHarnessBuilder<Integer> builder =
+                new StreamTaskMailboxTestHarnessBuilder<>(
+                                OneInputStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)
+                        .addInput(BasicTypeInfo.INT_TYPE_INFO)
+                        .setupOperatorChain(new StreamMap<>(i1 -> i1))
+                        .chain(new StreamMap<>(i -> i), IntSerializer.INSTANCE)
+                        .finish();
+
+        try (StreamTaskMailboxTestHarness<Integer> testHarness = builder.build()) {
+            final ReplicatingMail mail1 = createReplicatingMail(numRecords, testHarness, 0);
+            final ReplicatingMail mail2 = createReplicatingMail(numRecords, testHarness, 1);
+            for (int i = 0; i < numRecords; i++) {
+                testHarness.processElement(new StreamRecord<>(i));
             }
 
-            // for the very first element, enqueue one mail that replicates itself
-            if (!replicatingMail.hasBeenEnqueued()) {
-                replicatingMail.run();
+            while (testHarness.getOutput().size() < numRecords) {
+                testHarness.processSingleStep();
             }
-            // output how many mails have been processed so far (from upstream and this operator)
-            output.collect(
-                    new StreamRecord<>(
-                            replicatingMail.getMailCount() + upstreamMailCount.getValue()));
 
-            if (++numProcessedElements == maxProcessingElements) {
-                replicatingMail.stop();
-            }
+            final int[] output =
+                    testHarness.getOutput().stream()
+                            .mapToInt(r -> ((StreamRecord<Integer>) r).getValue())
+                            .toArray();
+            assertArrayEquals(output, IntStream.range(0, numRecords).toArray());
+            assertThat(mail1.getMailCount(), equalTo(numRecords + 1));
+            assertThat(mail2.getMailCount(), equalTo(numRecords + 1));
         }
     }
 
+    @Nonnull
+    private ReplicatingMail createReplicatingMail(
+            int numRecords, StreamTaskMailboxTestHarness<Integer> testHarness, int priority) {
+        final MailboxExecutor mailboxExecutor = testHarness.getExecutor(priority);
+        final ReplicatingMail mail1 = new ReplicatingMail(mailboxExecutor, numRecords + 1);
+        mailboxExecutor.submit(mail1, "Initial mail");
+        return mail1;
+    }
+
     private static class ReplicatingMail implements RunnableWithException {
         private int mailCount = -1;
-
-        private boolean stopped = false;
-
         private final MailboxExecutor mailboxExecutor;
+        private final int maxMails;
 
-        ReplicatingMail(final MailboxExecutor mailboxExecutor) {
+        ReplicatingMail(final MailboxExecutor mailboxExecutor, int maxMails) {
             this.mailboxExecutor = mailboxExecutor;
+            this.maxMails = maxMails;
         }
 
         @Override
         public void run() {
             try {
-                if (!stopped) {
+                if (mailCount < maxMails) {
                     mailboxExecutor.execute(this, "Blocking mail" + ++mailCount);
                 }
             } catch (RejectedExecutionException e) {
@@ -190,16 +108,8 @@ public class MailboxOperatorTest extends TestLogger {
             }
         }
 
-        boolean hasBeenEnqueued() {
-            return mailCount > -1;
-        }
-
         int getMailCount() {
             return mailCount;
         }
-
-        void stop() {
-            stopped = true;
-        }
     }
 }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java
index 097f5342e2f..dcdc2bb87b1 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java
@@ -23,6 +23,7 @@ import org.apache.flink.runtime.io.network.partition.consumer.StreamTestSingleIn
 import org.apache.flink.runtime.memory.MemoryManager;
 import org.apache.flink.runtime.state.TestTaskStateManager;
 import org.apache.flink.runtime.taskmanager.TestCheckpointResponder;
+import org.apache.flink.streaming.api.operators.MailboxExecutor;
 
 import java.util.Queue;
 
@@ -123,6 +124,10 @@ public class StreamTaskMailboxTestHarness<OUT> implements AutoCloseable {
         return false;
     }
 
+    public MailboxExecutor getExecutor(int priority) {
+        return streamTask.getMailboxExecutorFactory().createExecutor(priority);
+    }
+
     public void endInput() {
         for (int i = 0; i < inputGates.length; i++) {
             endInput(i);
