diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
index 90aab1de2ef..3b27d95e6e5 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
@@ -60,22 +60,17 @@ class AlternatingCheckpointBarrierHandler extends CheckpointBarrierHandler {
 		if (receivedBarrier.getId() < lastSeenBarrierId) {
 			return;
 		}
+
 		lastSeenBarrierId = receivedBarrier.getId();
 		CheckpointBarrierHandler previousHandler = activeHandler;
 		activeHandler = receivedBarrier.isCheckpoint() ? unalignedHandler : alignedHandler;
-		abortPreviousIfNeeded(receivedBarrier, previousHandler);
-		activeHandler.processBarrier(receivedBarrier, channelIndex);
-	}
-
-	private void abortPreviousIfNeeded(CheckpointBarrier barrier, CheckpointBarrierHandler prevHandler) throws IOException {
-		if (prevHandler != activeHandler && prevHandler.isCheckpointPending() && prevHandler.getLatestCheckpointId() < barrier.getId()) {
-			prevHandler.releaseBlocksAndResetBarriers();
-			notifyAbort(
-				prevHandler.getLatestCheckpointId(),
-				new CheckpointException(
-					format("checkpoint %d subsumed by %d", prevHandler.getLatestCheckpointId(), barrier.getId()),
-					CHECKPOINT_DECLINED_SUBSUMED));
+		if (previousHandler != activeHandler) {
+			previousHandler.abortPendingCheckpoint(
+				lastSeenBarrierId,
+				new CheckpointException(format("checkpoint subsumed by %d", lastSeenBarrierId), CHECKPOINT_DECLINED_SUBSUMED));
 		}
+
+		activeHandler.processBarrier(receivedBarrier, channelIndex);
 	}
 
 	@Override
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java
index dc604a38ddc..01892bc5b72 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java
@@ -92,6 +92,14 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {
 		this.blockedChannels = new boolean[totalNumberOfInputChannels];
 	}
 
+	@Override
+	public void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {
+		if (checkpointId > currentCheckpointId && isCheckpointPending()) {
+			releaseBlocksAndResetBarriers();
+			notifyAbort(currentCheckpointId, exception);
+		}
+	}
+
 	@Override
 	public void releaseBlocksAndResetBarriers() {
 		LOG.debug("{}: End of stream alignment, feeding buffered data back.", taskName);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java
index 37daef62b9a..15382eea085 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java
@@ -52,7 +52,8 @@ public abstract class CheckpointBarrierHandler implements Closeable {
 		this.toNotifyOnCheckpoint = checkNotNull(toNotifyOnCheckpoint);
 	}
 
-	public abstract void releaseBlocksAndResetBarriers();
+	public void releaseBlocksAndResetBarriers() {
+	}
 
 	/**
 	 * Checks whether the channel with the given index is blocked.
@@ -138,4 +139,7 @@ public abstract class CheckpointBarrierHandler implements Closeable {
 	}
 
 	protected abstract boolean isCheckpointPending();
+
+	protected void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {
+	}
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java
index a1d4050abb0..7dbfbaa7967 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java
@@ -75,11 +75,6 @@ public class CheckpointBarrierTracker extends CheckpointBarrierHandler {
 		this.pendingCheckpoints = new ArrayDeque<>();
 	}
 
-	@Override
-	public void releaseBlocksAndResetBarriers() {
-	}
-
-	@Override
 	public void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {
 		final long barrierId = receivedBarrier.getId();
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java
index 0c5dfb72355..f978e72c70a 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java
@@ -118,17 +118,6 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {
 		threadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,	checkNotNull(checkpointCoordinator), this);
 	}
 
-	@Override
-	public void releaseBlocksAndResetBarriers() {
-		if (isCheckpointPending()) {
-			// make sure no additional data is persisted
-			Arrays.fill(hasInflightBuffers, false);
-			// the next barrier that comes must assume it is the first
-			numBarrierConsumed = 0;
-		}
-		threadSafeUnaligner.resetReceivedBarriers(currentConsumedCheckpointId);
-	}
-
 	/**
 	 * We still need to trigger checkpoint via {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}
 	 * while reading the first barrier from one channel, because this might happen
@@ -156,41 +145,46 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {
 	}
 
 	@Override
-	public void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {
-		long cancelledId = cancelBarrier.getCheckpointId();
-		if (LOG.isDebugEnabled()) {
-			LOG.debug("{}: Checkpoint {} canceled, aborting alignment.", taskName, cancelledId);
-		}
+	public void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {
+		threadSafeUnaligner.tryAbortPendingCheckpoint(checkpointId, exception);
 
-		if (currentConsumedCheckpointId >= cancelledId && !isCheckpointPending()) {
-			return;
+		if (checkpointId > currentConsumedCheckpointId) {
+			resetPendingCheckpoint(checkpointId);
 		}
+	}
 
-		if (isCheckpointPending()) {
-			LOG.warn("{}: Received cancellation barrier for checkpoint {} before completing current checkpoint {}. " +
-					"Skipping current checkpoint.",
-				taskName,
+	@Override
+	public void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {
+		final long cancelledId = cancelBarrier.getCheckpointId();
+		boolean shouldAbort = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);
+		if (shouldAbort) {
+			notifyAbort(
 				cancelledId,
-				currentConsumedCheckpointId);
+				new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER));
 		}
 
-		releaseBlocksAndResetBarriers();
-		currentConsumedCheckpointId = cancelledId;
-		threadSafeUnaligner.setCurrentReceivedCheckpointId(currentConsumedCheckpointId);
-		notifyAbortOnCancellationBarrier(cancelledId);
+		if (cancelledId >= currentConsumedCheckpointId) {
+			resetPendingCheckpoint(cancelledId);
+			currentConsumedCheckpointId = cancelledId;
+		}
 	}
 
 	@Override
 	public void processEndOfPartition() throws Exception {
 		threadSafeUnaligner.onChannelClosed();
+		resetPendingCheckpoint(-1L);
+	}
 
+	private void resetPendingCheckpoint(long checkpointId) {
 		if (isCheckpointPending()) {
-			// let the task know we skip a checkpoint
-			notifyAbort(
-				currentConsumedCheckpointId,
-				new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));
-			// no chance to complete this checkpoint
-			releaseBlocksAndResetBarriers();
+			LOG.warn("{}: Received barrier or EndOfPartition(-1) {} before completing current checkpoint {}. " +
+					"Skipping current checkpoint.",
+				taskName,
+				checkpointId,
+				currentConsumedCheckpointId);
+
+			Arrays.fill(hasInflightBuffers, false);
+			numBarrierConsumed = 0;
 		}
 	}
 
@@ -361,15 +355,6 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {
 			checkpointCoordinator.initCheckpoint(barrierId, barrier.getCheckpointOptions());
 		}
 
-		synchronized void resetReceivedBarriers(long checkpointId) {
-			if (checkpointId >= currentReceivedCheckpointId && numBarriersReceived > 0) {
-				// avoid more data being serialized after abortion
-				Arrays.fill(storeNewBuffers, false);
-				// the next barrier that comes must assume it is the first
-				numBarriersReceived = 0;
-			}
-		}
-
 		synchronized CompletableFuture<Void> getAllBarriersReceivedFuture(long checkpointId) {
 			if (checkpointId < currentReceivedCheckpointId) {
 				return FutureUtils.completedVoidFuture();
@@ -380,12 +365,40 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {
 			return allBarriersReceivedFuture;
 		}
 
-		synchronized void onChannelClosed() {
+		synchronized void onChannelClosed() throws IOException {
 			numOpenChannels--;
+
+			if (resetPendingCheckpoint()) {
+				handler.notifyAbort(
+					currentReceivedCheckpointId,
+					new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));
+			}
 		}
 
-		synchronized void setCurrentReceivedCheckpointId(long currentReceivedCheckpointId) {
-			this.currentReceivedCheckpointId = Math.max(currentReceivedCheckpointId, this.currentReceivedCheckpointId);
+		synchronized boolean setCancelledCheckpointId(long cancelledId) {
+			if (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {
+				return false;
+			}
+
+			resetPendingCheckpoint();
+			currentReceivedCheckpointId = cancelledId;
+			return true;
+		}
+
+		synchronized void tryAbortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {
+			if (checkpointId > currentReceivedCheckpointId && resetPendingCheckpoint()) {
+				handler.notifyAbort(currentReceivedCheckpointId, exception);
+			}
+		}
+
+		private boolean resetPendingCheckpoint() {
+			if (numBarriersReceived == 0) {
+				return false;
+			}
+
+			Arrays.fill(storeNewBuffers, false);
+			numBarriersReceived = 0;
+			return true;
 		}
 
 		@VisibleForTesting
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerCancellationTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerCancellationTest.java
index 974e65b3dff..1bb49728526 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerCancellationTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerCancellationTest.java
@@ -70,7 +70,7 @@ public class CheckpointBarrierUnalignerCancellationTest {
 				new Object[]{true, false, Arrays.asList(checkpoint(20), checkpoint(10)), 1, 0},
 				new Object[]{true, true, Arrays.asList(checkpoint(10), cancel(10)), 1, 0},
 				new Object[]{true, true, Arrays.asList(checkpoint(10), cancel(20)), 1, 0},
-				new Object[]{true, true, Arrays.asList(checkpoint(20), cancel(10)), 1, 0},
+				new Object[]{true, false, Arrays.asList(checkpoint(20), cancel(10)), 1, 0},
 		};
 	}
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java
index 3d9a852c398..c6a373cf363 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java
@@ -53,6 +53,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
+import java.util.Random;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -70,6 +71,8 @@ import static org.junit.Assert.assertTrue;
  */
 public class CheckpointBarrierUnalignerTest {
 
+	private static final long DEFAULT_CHECKPOINT_ID = 0L;
+
 	private int sizeCounter = 1;
 
 	private CheckpointedInputGate inputGate;
@@ -512,6 +515,119 @@ public class CheckpointBarrierUnalignerTest {
 		}
 	}
 
+	/**
+	 * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}
+	 * abort the current pending checkpoint triggered by
+	 * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.
+	 */
+	@Test
+	public void testProcessCancellationBarrierAfterNotifyBarrierReceived() throws Exception {
+		final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();
+		final CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(
+			new int[] { 1 }, ChannelStateWriter.NO_OP, "test", invokable);
+
+		ThreadSafeUnaligner unaligner = handler.getThreadSafeUnaligner();
+		// should trigger respective checkpoint
+		unaligner.notifyBarrierReceived(buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));
+
+		assertFalse(handler.isCheckpointPending());
+		assertTrue(unaligner.isCheckpointPending());
+		assertEquals(-1L, handler.getLatestCheckpointId());
+		assertEquals(DEFAULT_CHECKPOINT_ID, unaligner.getCurrentCheckpointId());
+
+		testProcessCancellationBarrier(handler, invokable);
+	}
+
+	/**
+	 * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}
+	 * abort the current pending checkpoint triggered by
+	 * {@link CheckpointBarrierUnaligner#processBarrier(CheckpointBarrier, int)}.
+	 */
+	@Test
+	public void testProcessCancellationBarrierAfterProcessBarrier() throws Exception {
+		final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();
+		final CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(
+			new int[] { 1 }, ChannelStateWriter.NO_OP, "test", invokable);
+
+		// should trigger respective checkpoint
+		handler.processBarrier(buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), 0);
+
+		assertTrue(handler.isCheckpointPending());
+		assertTrue(handler.getThreadSafeUnaligner().isCheckpointPending());
+		assertEquals(DEFAULT_CHECKPOINT_ID, handler.getLatestCheckpointId());
+		assertEquals(DEFAULT_CHECKPOINT_ID, handler.getThreadSafeUnaligner().getCurrentCheckpointId());
+
+		testProcessCancellationBarrier(handler, invokable);
+	}
+
+	@Test
+	public void testProcessCancellationBarrierBeforeProcessAndReceiveBarrier() throws Exception {
+		final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();
+		final CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(
+			new int[] { 1 }, ChannelStateWriter.NO_OP, "test", invokable);
+
+		handler.processCancellationBarrier(new CancelCheckpointMarker(DEFAULT_CHECKPOINT_ID));
+
+		verifyTriggeredCheckpoint(handler, invokable, DEFAULT_CHECKPOINT_ID);
+
+		// it would not trigger checkpoint since the respective cancellation barrier already happened before
+		handler.processBarrier(buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), 0);
+		handler.getThreadSafeUnaligner().notifyBarrierReceived(buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));
+
+		verifyTriggeredCheckpoint(handler, invokable, DEFAULT_CHECKPOINT_ID);
+	}
+
+	private void testProcessCancellationBarrier(
+			CheckpointBarrierUnaligner handler,
+			ValidatingCheckpointInvokable invokable) throws Exception {
+
+		final long cancelledCheckpointId = new Random().nextBoolean() ? DEFAULT_CHECKPOINT_ID : DEFAULT_CHECKPOINT_ID + 1L;
+		// should abort current checkpoint while processing CancelCheckpointMarker
+		handler.processCancellationBarrier(new CancelCheckpointMarker(cancelledCheckpointId));
+		verifyTriggeredCheckpoint(handler, invokable, cancelledCheckpointId);
+
+		final long nextCancelledCheckpointId = cancelledCheckpointId + 1L;
+		// should update current checkpoint id and abort notification while processing CancelCheckpointMarker
+		handler.processCancellationBarrier(new CancelCheckpointMarker(nextCancelledCheckpointId));
+		verifyTriggeredCheckpoint(handler, invokable, nextCancelledCheckpointId);
+	}
+
+	private void verifyTriggeredCheckpoint(
+			CheckpointBarrierUnaligner handler,
+			ValidatingCheckpointInvokable invokable,
+			long currentCheckpointId) {
+
+		assertFalse(handler.isCheckpointPending());
+		assertFalse(handler.getThreadSafeUnaligner().isCheckpointPending());
+		assertEquals(currentCheckpointId, handler.getLatestCheckpointId());
+		assertEquals(currentCheckpointId, handler.getThreadSafeUnaligner().getCurrentCheckpointId());
+		assertEquals(currentCheckpointId, invokable.getAbortedCheckpointId());
+	}
+
+	@Test
+	public void testEndOfStreamWithPendingCheckpoint() throws Exception {
+		final int numberOfChannels = 2;
+		final ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();
+		final CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(
+			new int[] { numberOfChannels }, ChannelStateWriter.NO_OP, "test", invokable);
+
+		ThreadSafeUnaligner unaligner = handler.getThreadSafeUnaligner();
+		// should trigger respective checkpoint
+		unaligner.notifyBarrierReceived(buildCheckpointBarrier(DEFAULT_CHECKPOINT_ID), new InputChannelInfo(0, 0));
+
+		assertTrue(unaligner.isCheckpointPending());
+		assertEquals(DEFAULT_CHECKPOINT_ID, unaligner.getCurrentCheckpointId());
+		assertEquals(numberOfChannels, unaligner.getNumOpenChannels());
+
+		// should abort current checkpoint while processing eof
+		handler.processEndOfPartition();
+
+		assertFalse(unaligner.isCheckpointPending());
+		assertEquals(DEFAULT_CHECKPOINT_ID, unaligner.getCurrentCheckpointId());
+		assertEquals(numberOfChannels - 1 , unaligner.getNumOpenChannels());
+		assertEquals(DEFAULT_CHECKPOINT_ID, invokable.getAbortedCheckpointId());
+	}
+
 	// ------------------------------------------------------------------------
 	//  Utils
 	// ------------------------------------------------------------------------
@@ -620,7 +736,7 @@ public class CheckpointBarrierUnalignerTest {
 			.collect(Collectors.toList());
 	}
 
-	private CheckpointBarrier buildCheckpointBarrier(int id) {
+	private CheckpointBarrier buildCheckpointBarrier(long id) {
 		return new CheckpointBarrier(id, 0, CheckpointOptions.forCheckpointWithDefaultLocation());
 	}
 
@@ -703,6 +819,8 @@ public class CheckpointBarrierUnalignerTest {
 
 		private int totalNumCheckpoints;
 
+		private long abortedCheckpointId;
+
 		ValidatingCheckpointInvokable() throws Exception {
 			super(new DummyEnvironment("test", 1, 0));
 		}
@@ -715,6 +833,11 @@ public class CheckpointBarrierUnalignerTest {
 		protected void processInput(MailboxDefaultAction.Controller controller) {
 		}
 
+		@Override
+		public void abortCheckpointOnBarrier(long checkpointId, Throwable cause) throws IOException {
+			abortedCheckpointId = checkpointId;
+		}
+
 		public void triggerCheckpointOnBarrier(
 				CheckpointMetaData checkpointMetaData,
 				CheckpointOptions checkpointOptions,
@@ -730,5 +853,9 @@ public class CheckpointBarrierUnalignerTest {
 		int getTotalTriggeredCheckpoints() {
 			return totalNumCheckpoints;
 		}
+
+		long getAbortedCheckpointId() {
+			return abortedCheckpointId;
+		}
 	}
 }
