diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandler.java
index 4666ea37601..8d05cff3fb8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandler.java
@@ -23,11 +23,9 @@ import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.rest.handler.async.CompletedOperationCache;
 import org.apache.flink.runtime.rest.handler.async.OperationResult;
-import org.apache.flink.runtime.rest.handler.async.OperationResultStatus;
 import org.apache.flink.runtime.rest.handler.job.AsynchronousJobOperationKey;
 import org.apache.flink.util.concurrent.FutureUtils;
 
-import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.Supplier;
 
@@ -101,26 +99,10 @@ public class DispatcherCachedOperationsHandler {
     private CompletableFuture<Acknowledge> registerOperationIdempotently(
             AsynchronousJobOperationKey operationKey,
             Supplier<CompletableFuture<String>> operation) {
-        Optional<OperationResult<String>> resultOptional = savepointTriggerCache.get(operationKey);
-        if (resultOptional.isPresent()) {
-            return convertToFuture(resultOptional.get());
+        if (!savepointTriggerCache.containsOperation(operationKey)) {
+            savepointTriggerCache.registerOngoingOperation(operationKey, operation.get());
         }
 
-        savepointTriggerCache.registerOngoingOperation(operationKey, operation.get());
-
-        return savepointTriggerCache
-                .get(operationKey)
-                .map(DispatcherCachedOperationsHandler::convertToFuture)
-                // This shouldn't happen as we just registered the operation. We assume it is a
-                // temporary issue with the cache
-                .orElse(CompletableFuture.completedFuture(Acknowledge.get()));
-    }
-
-    private static CompletableFuture<Acknowledge> convertToFuture(OperationResult<String> result) {
-        if (result.getStatus() == OperationResultStatus.FAILURE) {
-            return FutureUtils.completedExceptionally(
-                    new OperationAlreadyFailedException(result.getThrowable()));
-        }
         return CompletableFuture.completedFuture(Acknowledge.get());
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandlerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandlerTest.java
index b9006b38be7..38b3d25a845 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandlerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherCachedOperationsHandlerTest.java
@@ -22,6 +22,7 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.api.java.tuple.Tuple3;
 import org.apache.flink.configuration.RestOptions;
+import org.apache.flink.core.testutils.FlinkMatchers;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.rest.handler.async.CompletedOperationCache;
 import org.apache.flink.runtime.rest.handler.async.OperationResult;
@@ -32,6 +33,7 @@ import org.apache.flink.util.TestLogger;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
@@ -126,19 +128,19 @@ public class DispatcherCachedOperationsHandlerTest extends TestLogger {
     }
 
     @Test
-    public void returnsFailedFutureIfOperationFails()
+    public void retryingCompletedOperationDoesNotMarkCacheEntryAsAccessed()
             throws ExecutionException, InterruptedException {
-        CompletableFuture<Acknowledge> acknowledgeRegisteredOperation =
-                handler.triggerSavepoint(
-                        operationKey, targetDirectory, TriggerSavepointMode.SAVEPOINT, TIMEOUT);
-        savepointLocationFuture.completeExceptionally(new RuntimeException("Expected failure"));
-        CompletableFuture<Acknowledge> failedAcknowledgeFuture =
-                handler.triggerSavepoint(
-                        operationKey, targetDirectory, TriggerSavepointMode.SAVEPOINT, TIMEOUT);
+        handler.triggerSavepoint(
+                        operationKey, targetDirectory, TriggerSavepointMode.SAVEPOINT, TIMEOUT)
+                .get();
+        savepointLocationFuture.complete("");
 
-        assertThat(acknowledgeRegisteredOperation.get(), is(Acknowledge.get()));
-        assertThat(
-                failedAcknowledgeFuture, futureFailedWith(OperationAlreadyFailedException.class));
+        handler.triggerSavepoint(
+                        operationKey, targetDirectory, TriggerSavepointMode.SAVEPOINT, TIMEOUT)
+                .get();
+
+        // should not complete because we wait for the result to be accessed
+        assertThat(cache.closeAsync(), FlinkMatchers.willNotComplete(Duration.ofMillis(10)));
     }
 
     @Test
