diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
index 2e132cd3bbd..5afeac7ca13 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
@@ -25,7 +25,6 @@ import org.apache.flink.runtime.checkpoint.CheckpointMetaData;
 import org.apache.flink.runtime.checkpoint.CheckpointMetricsBuilder;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.execution.Environment;
-import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.operators.coordination.OperatorEvent;
 import org.apache.flink.util.FlinkException;
@@ -40,41 +39,23 @@ import java.util.concurrent.Future;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /**
- * This is the abstract base class for every task that can be executed by a TaskManager. Concrete
- * tasks extend this class, for example the streaming and batch tasks.
- *
- * <p>The TaskManager invokes the {@link #invoke()} method when executing a task. All operations of
- * the task happen in this method (setting up input output stream readers and writers as well as the
- * task's core operation).
- *
- * <p>All classes that extend must offer a constructor {@code MyTask(Environment,
- * TaskStateSnapshot)}. Tasks that are always stateless can, for convenience, also only implement
- * the constructor {@code MyTask(Environment)}.
- *
- * <p><i>Developer note: While constructors cannot be enforced at compile time, we did not yet
- * venture on the endeavor of introducing factories (it is only an internal API after all, and with
- * Java 8, one can use {@code Class::new} almost like a factory lambda.</i>
- *
- * <p><b>NOTE:</b> There is no constructor that accepts and initial task state snapshot and stores
- * it in a variable. That is on purpose, because the AbstractInvokable itself does not need the
- * state snapshot (only subclasses such as StreamTask do need the state) and we do not want to store
- * a reference indefinitely, thus preventing cleanup of the initial state structure by the Garbage
- * Collector.
+ * A base implementation of {@link TaskInvokable}, {@link CheckpointableTask}, and {@link
+ * CoordinatedTask} with most methods throwing {@link UnsupportedOperationException} or doing
+ * nothing.
  *
  * <p>Any subclass that supports recoverable state and participates in checkpointing needs to
- * override {@link #triggerCheckpointAsync(CheckpointMetaData, CheckpointOptions, boolean)}, {@link
+ * override the methods of {@link CheckpointableTask}, such as {@link
+ * #triggerCheckpointAsync(CheckpointMetaData, CheckpointOptions)}, {@link
  * #triggerCheckpointOnBarrier(CheckpointMetaData, CheckpointOptions, CheckpointMetricsBuilder)},
- * {@link #abortCheckpointOnBarrier(long, Throwable)} and {@link
+ * {@link #abortCheckpointOnBarrier(long, CheckpointException)} and {@link
  * #notifyCheckpointCompleteAsync(long)}.
  */
-public abstract class AbstractInvokable {
+public abstract class AbstractInvokable
+        implements TaskInvokable, CheckpointableTask, CoordinatedTask {
 
     /** The environment assigned to this invokable. */
     private final Environment environment;
 
-    /** Flag whether cancellation should interrupt the executing thread. */
-    private volatile boolean shouldInterruptOnCancel = true;
-
     /**
      * Create an Invokable task and set its environment.
      *
@@ -88,62 +69,21 @@ public abstract class AbstractInvokable {
     //  Core methods
     // ------------------------------------------------------------------------
 
-    /**
-     * Starts the execution.
-     *
-     * <p>Must be overwritten by the concrete task implementation. This method is called by the task
-     * manager when the actual execution of the task starts.
-     *
-     * <p>All resources should be cleaned up when the method returns. Make sure to guard the code
-     * with <code>try-finally</code> blocks where necessary.
-     *
-     * @throws Exception Tasks may forward their exceptions for the TaskManager to handle through
-     *     failure/recovery.
-     */
+    @Override
     public abstract void invoke() throws Exception;
 
-    /**
-     * This method is called when a task is canceled either as a result of a user abort or an
-     * execution failure. It can be overwritten to respond to shut down the user code properly.
-     *
-     * @throws Exception thrown if any exception occurs during the execution of the user code
-     * @return a future that is completed when this {@link AbstractInvokable} is fully terminated.
-     *     Note that it may never complete if the invokable is stuck.
-     */
+    @Override
     public Future<Void> cancel() throws Exception {
         // The default implementation does nothing.
         return CompletableFuture.completedFuture(null);
     }
 
-    /**
-     * Cleanup any resources used in {@link #invoke()} OR {@link #restore()}. This method must be
-     * called regardless whether the aforementioned calls succeeded or failed.
-     *
-     * @param throwable iff failure happened during the execution of {@link #restore()} or {@link
-     *     #invoke()}, null otherwise.
-     *     <p>ATTENTION: {@link org.apache.flink.runtime.execution.CancelTaskException
-     *     CancelTaskException} should not be treated as a failure, null must be passed instead.
-     */
+    @Override
     public void cleanUp(@Nullable Throwable throwable) throws Exception {}
 
-    /**
-     * Sets whether the thread that executes the {@link #invoke()} method should be interrupted
-     * during cancellation. This method sets the flag for both the initial interrupt, as well as for
-     * the repeated interrupt. Setting the interruption to false at some point during the
-     * cancellation procedure is a way to stop further interrupts from happening.
-     */
-    public void setShouldInterruptOnCancel(boolean shouldInterruptOnCancel) {
-        this.shouldInterruptOnCancel = shouldInterruptOnCancel;
-    }
-
-    /**
-     * Checks whether the task should be interrupted during cancellation. This method is check both
-     * for the initial interrupt, as well as for the repeated interrupt. Setting the interruption to
-     * false via {@link #setShouldInterruptOnCancel(boolean)} is a way to stop further interrupts
-     * from happening.
-     */
+    @Override
     public boolean shouldInterruptOnCancel() {
-        return shouldInterruptOnCancel;
+        return true;
     }
 
     // ------------------------------------------------------------------------
@@ -217,20 +157,7 @@ public abstract class AbstractInvokable {
     //  Checkpointing Methods
     // ------------------------------------------------------------------------
 
-    /**
-     * This method is called to trigger a checkpoint, asynchronously by the checkpoint coordinator.
-     *
-     * <p>This method is called for tasks that start the checkpoints by injecting the initial
-     * barriers, i.e., the source tasks. In contrast, checkpoints on downstream operators, which are
-     * the result of receiving checkpoint barriers, invoke the {@link
-     * #triggerCheckpointOnBarrier(CheckpointMetaData, CheckpointOptions, CheckpointMetricsBuilder)}
-     * method.
-     *
-     * @param checkpointMetaData Meta data for about this checkpoint
-     * @param checkpointOptions Options for performing this checkpoint
-     * @return future with value of {@code false} if the checkpoint was not carried out, {@code
-     *     true} otherwise
-     */
+    @Override
     public CompletableFuture<Boolean> triggerCheckpointAsync(
             CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions) {
         throw new UnsupportedOperationException(
@@ -238,15 +165,7 @@ public abstract class AbstractInvokable {
                         "triggerCheckpointAsync not supported by %s", this.getClass().getName()));
     }
 
-    /**
-     * This method is called when a checkpoint is triggered as a result of receiving checkpoint
-     * barriers on all input streams.
-     *
-     * @param checkpointMetaData Meta data for about this checkpoint
-     * @param checkpointOptions Options for performing this checkpoint
-     * @param checkpointMetrics Metrics about this checkpoint
-     * @throws Exception Exceptions thrown as the result of triggering a checkpoint are forwarded.
-     */
+    @Override
     public void triggerCheckpointOnBarrier(
             CheckpointMetaData checkpointMetaData,
             CheckpointOptions checkpointOptions,
@@ -258,16 +177,7 @@ public abstract class AbstractInvokable {
                         this.getClass().getName()));
     }
 
-    /**
-     * Aborts a checkpoint as the result of receiving possibly some checkpoint barriers, but at
-     * least one {@link org.apache.flink.runtime.io.network.api.CancelCheckpointMarker}.
-     *
-     * <p>This requires implementing tasks to forward a {@link
-     * org.apache.flink.runtime.io.network.api.CancelCheckpointMarker} to their outputs.
-     *
-     * @param checkpointId The ID of the checkpoint to be aborted.
-     * @param cause The reason why the checkpoint was aborted during alignment
-     */
+    @Override
     public void abortCheckpointOnBarrier(long checkpointId, CheckpointException cause)
             throws IOException {
         throw new UnsupportedOperationException(
@@ -275,13 +185,7 @@ public abstract class AbstractInvokable {
                         "abortCheckpointOnBarrier not supported by %s", this.getClass().getName()));
     }
 
-    /**
-     * Invoked when a checkpoint has been completed, i.e., when the checkpoint coordinator has
-     * received the notification from all participating tasks.
-     *
-     * @param checkpointId The ID of the checkpoint that is complete.
-     * @return future that completes when the notification has been processed by the task.
-     */
+    @Override
     public Future<Void> notifyCheckpointCompleteAsync(long checkpointId) {
         throw new UnsupportedOperationException(
                 String.format(
@@ -289,15 +193,7 @@ public abstract class AbstractInvokable {
                         this.getClass().getName()));
     }
 
-    /**
-     * Invoked when a checkpoint has been aborted, i.e., when the checkpoint coordinator has
-     * received a decline message from one task and try to abort the targeted checkpoint by
-     * notification.
-     *
-     * @param checkpointId The ID of the checkpoint that is aborted.
-     * @param latestCompletedCheckpointId The ID of the latest completed checkpoint.
-     * @return future that completes when the notification has been processed by the task.
-     */
+    @Override
     public Future<Void> notifyCheckpointAbortAsync(
             long checkpointId, long latestCompletedCheckpointId) {
         throw new UnsupportedOperationException(
@@ -306,28 +202,17 @@ public abstract class AbstractInvokable {
                         this.getClass().getName()));
     }
 
+    @Override
     public void dispatchOperatorEvent(OperatorID operator, SerializedValue<OperatorEvent> event)
             throws FlinkException {
         throw new UnsupportedOperationException(
                 "dispatchOperatorEvent not supported by " + getClass().getName());
     }
 
-    /**
-     * This method can be called before {@link #invoke()} to restore an invokable object for the
-     * last valid state, if it has it.
-     *
-     * <p>Every implementation determinate what should be restored by itself. (nothing happens by
-     * default).
-     *
-     * @throws Exception Tasks may forward their exceptions for the TaskManager to handle through
-     *     failure/recovery.
-     */
+    @Override
     public void restore() throws Exception {}
 
-    /**
-     * @return true if blocking input such as {@link InputGate#getNext()} is used (as opposed to
-     *     {@link InputGate#pollNext()}. To be removed together with the DataSet API.
-     */
+    @Override
     public boolean isUsingNonBlockingInput() {
         return false;
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/CheckpointableTask.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/CheckpointableTask.java
new file mode 100644
index 00000000000..1e0644d1a8b
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/CheckpointableTask.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.runtime.jobgraph.tasks;
+
+import org.apache.flink.annotation.Internal;
+import org.apache.flink.runtime.checkpoint.CheckpointException;
+import org.apache.flink.runtime.checkpoint.CheckpointMetaData;
+import org.apache.flink.runtime.checkpoint.CheckpointMetricsBuilder;
+import org.apache.flink.runtime.checkpoint.CheckpointOptions;
+
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
+
+/**
+ * A task that participates in checkpointing.
+ *
+ * @see TaskInvokable
+ * @see AbstractInvokable
+ */
+@Internal
+public interface CheckpointableTask {
+
+    /**
+     * This method is called to trigger a checkpoint, asynchronously by the checkpoint coordinator.
+     *
+     * <p>This method is called for tasks that start the checkpoints by injecting the initial
+     * barriers, i.e., the source tasks. In contrast, checkpoints on downstream operators, which are
+     * the result of receiving checkpoint barriers, invoke the {@link
+     * #triggerCheckpointOnBarrier(CheckpointMetaData, CheckpointOptions, CheckpointMetricsBuilder)}
+     * method.
+     *
+     * @param checkpointMetaData Meta data for about this checkpoint
+     * @param checkpointOptions Options for performing this checkpoint
+     * @return future with value of {@code false} if the checkpoint was not carried out, {@code
+     *     true} otherwise
+     */
+    CompletableFuture<Boolean> triggerCheckpointAsync(
+            CheckpointMetaData checkpointMetaData, CheckpointOptions checkpointOptions);
+
+    /**
+     * This method is called when a checkpoint is triggered as a result of receiving checkpoint
+     * barriers on all input streams.
+     *
+     * @param checkpointMetaData Meta data for about this checkpoint
+     * @param checkpointOptions Options for performing this checkpoint
+     * @param checkpointMetrics Metrics about this checkpoint
+     * @throws IOException Exceptions thrown as the result of triggering a checkpoint are forwarded.
+     */
+    void triggerCheckpointOnBarrier(
+            CheckpointMetaData checkpointMetaData,
+            CheckpointOptions checkpointOptions,
+            CheckpointMetricsBuilder checkpointMetrics)
+            throws IOException;
+
+    /**
+     * Invoked when a checkpoint has been completed, i.e., when the checkpoint coordinator has
+     * received the notification from all participating tasks.
+     *
+     * @param checkpointId The ID of the checkpoint that is complete.
+     * @return future that completes when the notification has been processed by the task.
+     */
+    Future<Void> notifyCheckpointCompleteAsync(long checkpointId);
+
+    /**
+     * Invoked when a checkpoint has been aborted, i.e., when the checkpoint coordinator has
+     * received a decline message from one task and try to abort the targeted checkpoint by
+     * notification.
+     *
+     * @param checkpointId The ID of the checkpoint that is aborted.
+     * @param latestCompletedCheckpointId The ID of the latest completed checkpoint.
+     * @return future that completes when the notification has been processed by the task.
+     */
+    Future<Void> notifyCheckpointAbortAsync(long checkpointId, long latestCompletedCheckpointId);
+
+    /**
+     * Aborts a checkpoint as the result of receiving possibly some checkpoint barriers, but at
+     * least one {@link org.apache.flink.runtime.io.network.api.CancelCheckpointMarker}.
+     *
+     * <p>This requires implementing tasks to forward a {@link
+     * org.apache.flink.runtime.io.network.api.CancelCheckpointMarker} to their outputs.
+     *
+     * @param checkpointId The ID of the checkpoint to be aborted.
+     * @param cause The reason why the checkpoint was aborted during alignment
+     */
+    void abortCheckpointOnBarrier(long checkpointId, CheckpointException cause) throws IOException;
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/CoordinatedTask.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/CoordinatedTask.java
new file mode 100644
index 00000000000..af338b7eb87
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/CoordinatedTask.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.runtime.jobgraph.tasks;
+
+import org.apache.flink.annotation.Internal;
+import org.apache.flink.runtime.jobgraph.OperatorID;
+import org.apache.flink.runtime.operators.coordination.OperatorCoordinator;
+import org.apache.flink.runtime.operators.coordination.OperatorEvent;
+import org.apache.flink.util.FlinkException;
+import org.apache.flink.util.SerializedValue;
+
+/**
+ * An task that is coordinated, i.e. contains operators coordinated by {@link OperatorCoordinator}.
+ */
+@Internal
+public interface CoordinatedTask {
+    void dispatchOperatorEvent(OperatorID operator, SerializedValue<OperatorEvent> event)
+            throws FlinkException;
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java
new file mode 100644
index 00000000000..17d0ffee402
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.flink.runtime.jobgraph.tasks;
+
+import org.apache.flink.annotation.Internal;
+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
+
+import javax.annotation.Nullable;
+
+import java.util.concurrent.Future;
+
+/**
+ * An invokable part of the task.
+ *
+ * <p>The TaskManager first calls the {@link #restore} method when executing a task. If the call
+ * succeeds and the task isn't cancelled then TM proceeds to {@link #invoke()}. All operations of
+ * the task happen in these two methods (setting up input output stream readers and writers as well
+ * as the task's core operation).
+ *
+ * <p>After that, {@link #cleanUp(Throwable)} is called (regardless of an failures or cancellations
+ * during the above calls).
+ *
+ * <p>Implementations must have a constructor with a single argument of type {@link
+ * org.apache.flink.runtime.execution.Environment}.
+ *
+ * <p><i>Developer note: While constructors cannot be enforced at compile time, we did not yet
+ * venture on the endeavor of introducing factories (it is only an internal API after all, and with
+ * Java 8, one can use {@code Class::new} almost like a factory lambda.</i>
+ *
+ * @see CheckpointableTask
+ * @see CoordinatedTask
+ * @see AbstractInvokable
+ */
+@Internal
+public interface TaskInvokable {
+
+    /**
+     * Starts the execution.
+     *
+     * <p>This method is called by the task manager when the actual execution of the task starts.
+     *
+     * <p>All resources should be cleaned up by calling {@link #cleanUp(Throwable)} ()} after the
+     * method returns.
+     */
+    void invoke() throws Exception;
+
+    /**
+     * This method can be called before {@link #invoke()} to restore an invokable object for the
+     * last valid state, if it has it.
+     *
+     * <p>If {@link #invoke()} is not called after this method for some reason (e.g. task
+     * cancellation); then all resources should be cleaned up by calling {@link #cleanUp(Throwable)}
+     * ()} after the method returns.
+     */
+    void restore() throws Exception;
+
+    /**
+     * Cleanup any resources used in {@link #invoke()} OR {@link #restore()}. This method must be
+     * called regardless whether the aforementioned calls succeeded or failed.
+     *
+     * @param throwable iff failure happened during the execution of {@link #restore()} or {@link
+     *     #invoke()}, null otherwise.
+     *     <p>ATTENTION: {@link org.apache.flink.runtime.execution.CancelTaskException
+     *     CancelTaskException} should not be treated as a failure.
+     */
+    void cleanUp(@Nullable Throwable throwable) throws Exception;
+
+    /**
+     * This method is called when a task is canceled either as a result of a user abort or an
+     * execution failure. It can be overwritten to respond to shut down the user code properly.
+     *
+     * @return a future that is completed when this {@link AbstractInvokable} is fully terminated.
+     *     Note that it may never complete if the invokable is stuck.
+     */
+    Future<Void> cancel() throws Exception;
+
+    /**
+     * @return true if blocking input such as {@link InputGate#getNext()} is used (as opposed to
+     *     {@link InputGate#pollNext()}. To be removed together with the DataSet API.
+     */
+    boolean isUsingNonBlockingInput();
+
+    /**
+     * Checks whether the task should be interrupted during cancellation. This method is check both
+     * for the initial interrupt, as well as for the repeated interrupt. If this method returns true
+     * then no further interrupts will happen.
+     */
+    boolean shouldInterruptOnCancel();
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
index 551e246b83f..76f00840672 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
@@ -59,8 +59,10 @@ import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.jobgraph.IntermediateDataSetID;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
-import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
+import org.apache.flink.runtime.jobgraph.tasks.CheckpointableTask;
+import org.apache.flink.runtime.jobgraph.tasks.CoordinatedTask;
 import org.apache.flink.runtime.jobgraph.tasks.InputSplitProvider;
+import org.apache.flink.runtime.jobgraph.tasks.TaskInvokable;
 import org.apache.flink.runtime.jobgraph.tasks.TaskOperatorEventGateway;
 import org.apache.flink.runtime.memory.MemoryManager;
 import org.apache.flink.runtime.metrics.groups.TaskMetricGroup;
@@ -125,7 +127,7 @@ import static org.apache.flink.util.Preconditions.checkState;
  * to consume input data, produce its results (intermediate result partitions) and communicate with
  * the JobManager.
  *
- * <p>The Flink operators (implemented as subclasses of {@link AbstractInvokable} have only data
+ * <p>The Flink operators (implemented as subclasses of {@link TaskInvokable} have only data
  * readers, writers, and certain event callbacks. The task connects those to the network stack and
  * actor messages, and tracks the state of the execution and handles exceptions.
  *
@@ -273,7 +275,7 @@ public class Task
      * The invokable of this task, if initialized. All accesses must copy the reference and check
      * for null, as this field is cleared as part of the disposal logic.
      */
-    @Nullable private volatile AbstractInvokable invokable;
+    @Nullable private volatile TaskInvokable invokable;
 
     /** The current execution state of the task. */
     private volatile ExecutionState executionState = ExecutionState.CREATED;
@@ -508,7 +510,7 @@ public class Task
 
     @Nullable
     @VisibleForTesting
-    AbstractInvokable getInvokable() {
+    TaskInvokable getInvokable() {
         return invokable;
     }
 
@@ -616,7 +618,7 @@ public class Task
         // all resource acquisitions and registrations from here on
         // need to be undone in the end
         Map<String, Future<Path>> distributedCacheEntries = new HashMap<>();
-        AbstractInvokable invokable = null;
+        TaskInvokable invokable = null;
 
         try {
             // ----------------------------
@@ -920,7 +922,7 @@ public class Task
         }
     }
 
-    private void restoreAndInvoke(AbstractInvokable finalInvokable) throws Exception {
+    private void restoreAndInvoke(TaskInvokable finalInvokable) throws Exception {
         try {
             runWithSystemExitMonitoring(finalInvokable::restore);
 
@@ -1021,7 +1023,7 @@ public class Task
     }
 
     private void closeAllInputGates() {
-        AbstractInvokable invokable = this.invokable;
+        TaskInvokable invokable = this.invokable;
         if (invokable == null || !invokable.isUsingNonBlockingInput()) {
             // Cleanup resources instead of invokable if it is null, or prevent it from being
             // blocked on input, or interrupt if it is already blocked. Not needed for StreamTask
@@ -1181,7 +1183,7 @@ public class Task
                     // we need to cancel the invokable
 
                     // copy reference to guard against concurrent null-ing out the reference
-                    final AbstractInvokable invokable = this.invokable;
+                    final TaskInvokable invokable = this.invokable;
 
                     if (invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {
                         this.failureCause = cause;
@@ -1316,14 +1318,15 @@ public class Task
             final long checkpointTimestamp,
             final CheckpointOptions checkpointOptions) {
 
-        final AbstractInvokable invokable = this.invokable;
+        final TaskInvokable invokable = this.invokable;
         final CheckpointMetaData checkpointMetaData =
                 new CheckpointMetaData(
                         checkpointID, checkpointTimestamp, System.currentTimeMillis());
 
-        if (executionState == ExecutionState.RUNNING && invokable != null) {
+        if (executionState == ExecutionState.RUNNING) {
+            checkState(invokable instanceof CheckpointableTask, "invokable is not checkpointable");
             try {
-                invokable
+                ((CheckpointableTask) invokable)
                         .triggerCheckpointAsync(checkpointMetaData, checkpointOptions)
                         .handle(
                                 (triggerResult, exception) -> {
@@ -1396,11 +1399,12 @@ public class Task
     }
 
     public void notifyCheckpointComplete(final long checkpointID) {
-        final AbstractInvokable invokable = this.invokable;
+        final TaskInvokable invokable = this.invokable;
 
-        if (executionState == ExecutionState.RUNNING && invokable != null) {
+        if (executionState == ExecutionState.RUNNING) {
+            checkState(invokable instanceof CheckpointableTask, "invokable is not checkpointable");
             try {
-                invokable.notifyCheckpointCompleteAsync(checkpointID);
+                ((CheckpointableTask) invokable).notifyCheckpointCompleteAsync(checkpointID);
             } catch (RejectedExecutionException ex) {
                 // This may happen if the mailbox is closed. It means that the task is shutting
                 // down, so we just ignore it.
@@ -1424,11 +1428,13 @@ public class Task
 
     public void notifyCheckpointAborted(
             final long checkpointID, final long latestCompletedCheckpointId) {
-        final AbstractInvokable invokable = this.invokable;
+        final TaskInvokable invokable = this.invokable;
 
-        if (executionState == ExecutionState.RUNNING && invokable != null) {
+        if (executionState == ExecutionState.RUNNING) {
+            checkState(invokable instanceof CheckpointableTask, "invokable is not checkpointable");
             try {
-                invokable.notifyCheckpointAbortAsync(checkpointID, latestCompletedCheckpointId);
+                ((CheckpointableTask) invokable)
+                        .notifyCheckpointAbortAsync(checkpointID, latestCompletedCheckpointId);
             } catch (RejectedExecutionException ex) {
                 // This may happen if the mailbox is closed. It means that the task is shutting
                 // down, so we just ignore it.
@@ -1462,7 +1468,7 @@ public class Task
      */
     public void deliverOperatorEvent(OperatorID operator, SerializedValue<OperatorEvent> evt)
             throws FlinkException {
-        final AbstractInvokable invokable = this.invokable;
+        final TaskInvokable invokable = this.invokable;
         final ExecutionState currentState = this.executionState;
 
         if (invokable == null
@@ -1471,16 +1477,18 @@ public class Task
             throw new TaskNotRunningException("Task is not running, but in state " + currentState);
         }
 
-        try {
-            invokable.dispatchOperatorEvent(operator, evt);
-        } catch (Throwable t) {
-            ExceptionUtils.rethrowIfFatalErrorOrOOM(t);
+        if (invokable instanceof CoordinatedTask) {
+            try {
+                ((CoordinatedTask) invokable).dispatchOperatorEvent(operator, evt);
+            } catch (Throwable t) {
+                ExceptionUtils.rethrowIfFatalErrorOrOOM(t);
 
-            if (getExecutionState() == ExecutionState.RUNNING
-                    || getExecutionState() == ExecutionState.INITIALIZING) {
-                FlinkException e = new FlinkException("Error while handling operator event", t);
-                failExternally(e);
-                throw e;
+                if (getExecutionState() == ExecutionState.RUNNING
+                        || getExecutionState() == ExecutionState.INITIALIZING) {
+                    FlinkException e = new FlinkException("Error while handling operator event", t);
+                    failExternally(e);
+                    throw e;
+                }
             }
         }
     }
@@ -1489,7 +1497,7 @@ public class Task
     //  Utilities
     // ------------------------------------------------------------------------
 
-    private void cancelInvokable(AbstractInvokable invokable) {
+    private void cancelInvokable(TaskInvokable invokable) {
         // in case of an exception during execution, we still call "cancel()" on the task
         if (invokable != null && invokableHasBeenCanceled.compareAndSet(false, true)) {
             try {
@@ -1551,18 +1559,18 @@ public class Task
      * @throws Throwable Forwards all exceptions that happen during initialization of the task. Also
      *     throws an exception if the task class misses the necessary constructor.
      */
-    private static AbstractInvokable loadAndInstantiateInvokable(
+    private static TaskInvokable loadAndInstantiateInvokable(
             ClassLoader classLoader, String className, Environment environment) throws Throwable {
 
-        final Class<? extends AbstractInvokable> invokableClass;
+        final Class<? extends TaskInvokable> invokableClass;
         try {
             invokableClass =
-                    Class.forName(className, true, classLoader).asSubclass(AbstractInvokable.class);
+                    Class.forName(className, true, classLoader).asSubclass(TaskInvokable.class);
         } catch (Throwable t) {
             throw new Exception("Could not load the task's invokable class.", t);
         }
 
-        Constructor<? extends AbstractInvokable> statelessCtor;
+        Constructor<? extends TaskInvokable> statelessCtor;
 
         try {
             statelessCtor = invokableClass.getConstructor(Environment.class);
@@ -1612,14 +1620,14 @@ public class Task
         /** Time to wait after cancellation and interruption before releasing network resources. */
         private final long taskCancellationTimeout;
 
-        private final AbstractInvokable invokable;
+        private final TaskInvokable invokable;
         private final Thread executer;
         private final String taskName;
 
         TaskCanceler(
                 Logger logger,
                 long taskCancellationTimeout,
-                AbstractInvokable invokable,
+                TaskInvokable invokable,
                 Thread executer,
                 String taskName) {
             this.logger = logger;
@@ -1676,7 +1684,7 @@ public class Task
         private final Logger log;
 
         /** The invokable task. */
-        private final AbstractInvokable task;
+        private final TaskInvokable task;
 
         /** The executing task thread that we wait for to terminate. */
         private final Thread executerThread;
@@ -1689,7 +1697,7 @@ public class Task
 
         TaskInterrupter(
                 Logger log,
-                AbstractInvokable task,
+                TaskInvokable task,
                 Thread executerThread,
                 String taskName,
                 long interruptIntervalMillis) {
