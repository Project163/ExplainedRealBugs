diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java
index 2089aa24152..e154e5e693e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/SavepointCoordinator.java
@@ -197,11 +197,6 @@ public class SavepointCoordinator extends CheckpointCoordinator {
 
 			LOG.info("Savepoint: {}@{}", checkpoint.getCheckpointID(), checkpoint.getTimestamp());
 
-			// Sanity check to ensure that the parallelism has not been changed. If the tasks have
-			// lower parallelism than the savepoint tasks, this will be noticed during reset, but
-			// the other way around (higher parallelism than savepoint tasks) might go unnoticed.
-			Map<JobVertexID, IntValue> vertexParallelism = new HashMap<>();
-
 			// Set the initial state of all tasks
 			for (StateForTask state : checkpoint.getStates()) {
 				ExecutionJobVertex vertex = tasks.get(state.getOperatorId());
@@ -214,28 +209,10 @@ public class SavepointCoordinator extends CheckpointCoordinator {
 					throw new IllegalStateException(msg);
 				}
 
-				IntValue parallelism = vertexParallelism.get(vertex.getJobVertexId());
-
-				if (parallelism == null) {
-					parallelism = new IntValue(vertex.getParallelism());
-					vertexParallelism.put(vertex.getJobVertexId(), parallelism);
-				}
-
 				Execution exec = vertex.getTaskVertices()[state.getSubtask()]
 						.getCurrentExecutionAttempt();
 
 				exec.setInitialState(state.getState(), recoveryTimestamp);
-
-				parallelism.setValue(parallelism.getValue() - 1);
-			}
-
-			// If the parallelism matches, each count is 0
-			for (IntValue parallelism : vertexParallelism.values()) {
-				if (parallelism.getValue() != 0) {
-					throw new IllegalStateException("Parallelism mismatch between savepoint " +
-							"tasks and new program. This indicates that the program has been " +
-							"changed after the savepoint.");
-				}
 			}
 
 			// Reset the checkpoint ID counter
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/SavepointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/SavepointCoordinatorTest.java
index 4dc9c5c0838..4f9ae600db5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/SavepointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/SavepointCoordinatorTest.java
@@ -259,22 +259,8 @@ public class SavepointCoordinatorTest {
 		String savepointPath = Await.result(savepointPathFuture, FiniteDuration.Zero());
 		assertNotNull(savepointPath);
 
-		// Change parallelism higher than original (subtask without matching state)
-		for (int i = 0; i < jobVertices.length; i++) {
-			jobVertices[i] = mockExecutionJobVertex(jobId, jobVertices[i].getJobVertexId(), 8);
-		}
-
-		try {
-			// Rollback
-			coordinator.restoreSavepoint(
-					createExecutionJobVertexMap(jobVertices),
-					savepointPath);
-			fail("Did not throw expected Exception after rollback with parallelism mismatch.");
-		}
-		catch (Exception ignored) {
-		}
-
-		// Change parallelism lower than original (state without matching subtask)
+		// Change parallelism lower than original (state without matching subtask). The
+		// other way around (subtask without matching state) is OK.
 		for (int i = 0; i < jobVertices.length; i++) {
 			jobVertices[i] = mockExecutionJobVertex(jobId, jobVertices[i].getJobVertexId(), 2);
 		}
