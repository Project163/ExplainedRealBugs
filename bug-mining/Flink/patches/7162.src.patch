diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java
index bd88fb89954..84cbf467359 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java
@@ -896,12 +896,13 @@ public class StreamingJobGraphGenerator {
             Integer vertexID,
             List<StreamEdge> chainedOutputs,
             Optional<OperatorChainInfo> operatorChainInfo) {
+        List<ChainedSourceInfo> chainedSourceInfos =
+                operatorChainInfo
+                        .map(chainInfo -> getChainedSourcesByVertexId(vertexID, chainInfo))
+                        .orElse(Collections.emptyList());
         final String operatorName =
                 nameWithChainedSourcesInfo(
-                        streamGraph.getStreamNode(vertexID).getOperatorName(),
-                        operatorChainInfo
-                                .map(chain -> chain.getChainedSources().values())
-                                .orElse(Collections.emptyList()));
+                        streamGraph.getStreamNode(vertexID).getOperatorName(), chainedSourceInfos);
         if (chainedOutputs.size() > 1) {
             List<String> outputChainedNames = new ArrayList<>();
             for (StreamEdge chainable : chainedOutputs) {
@@ -915,6 +916,14 @@ public class StreamingJobGraphGenerator {
         }
     }
 
+    private List<ChainedSourceInfo> getChainedSourcesByVertexId(
+            Integer vertexId, OperatorChainInfo chainInfo) {
+        return streamGraph.getStreamNode(vertexId).getInEdges().stream()
+                .map(inEdge -> chainInfo.getChainedSources().get(inEdge.getSourceId()))
+                .filter(Objects::nonNull)
+                .collect(Collectors.toList());
+    }
+
     private ResourceSpec createChainedMinResources(
             Integer vertexID, List<StreamEdge> chainedOutputs) {
         ResourceSpec minResources = streamGraph.getStreamNode(vertexID).getMinResources();
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java
index eeca72d60c8..df08caa840c 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java
@@ -108,7 +108,6 @@ import org.apache.flink.streaming.runtime.partitioner.ForwardPartitioner;
 import org.apache.flink.streaming.runtime.partitioner.RebalancePartitioner;
 import org.apache.flink.streaming.runtime.partitioner.RescalePartitioner;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
-import org.apache.flink.streaming.runtime.tasks.MultipleInputStreamTask;
 import org.apache.flink.streaming.runtime.tasks.SourceOperatorStreamTask;
 import org.apache.flink.streaming.util.TestAnyModeReadingStreamOperator;
 import org.apache.flink.util.AbstractID;
@@ -135,6 +134,7 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -1655,28 +1655,51 @@ class StreamingJobGraphGeneratorTest {
     @Test
     void testNamingOfChainedMultipleInputs() {
         String[] sources = new String[] {"source-1", "source-2", "source-3"};
-        JobGraph graph = createGraphWithMultipleInputs(true, sources);
-        JobVertex head = graph.getVerticesSortedTopologicallyFromSources().iterator().next();
-        assertThat(sources).allMatch(source -> head.getOperatorPrettyName().contains(source));
+        String sink = "sink";
+        JobGraph graph = createGraphWithMultipleInputs(true, sink, sources);
+        Iterator<JobVertex> iterator = graph.getVerticesSortedTopologicallyFromSources().iterator();
+
+        JobVertex multipleVertex = iterator.next();
+        assertThat(multipleVertex.getName())
+                .isEqualTo("mit [Source: source-1, Source: source-2, Source: source-3]");
+        assertThat(multipleVertex.getOperatorPrettyName())
+                .isEqualTo("mit [Source: source-1, Source: source-2, Source: source-3]\n");
+
+        JobVertex sinkVertex = iterator.next();
+        assertThat(sinkVertex.getName()).isEqualTo("Sink: sink");
+        assertThat(sinkVertex.getOperatorPrettyName()).isEqualTo("Sink: sink\n");
     }
 
     @Test
     void testNamingOfNonChainedMultipleInputs() {
         String[] sources = new String[] {"source-1", "source-2", "source-3"};
-        JobGraph graph = createGraphWithMultipleInputs(false, sources);
-        JobVertex head =
-                Iterables.find(
-                        graph.getVertices(),
-                        vertex ->
-                                vertex.getInvokableClassName()
-                                        .equals(MultipleInputStreamTask.class.getName()));
-        assertThat(head.getName()).withFailMessage(head.getName()).doesNotContain("source-1");
-        assertThat(head.getOperatorPrettyName())
-                .withFailMessage(head.getOperatorPrettyName())
-                .doesNotContain("source-1");
-    }
-
-    public JobGraph createGraphWithMultipleInputs(boolean chain, String... inputNames) {
+        String sink = "sink";
+        JobGraph graph = createGraphWithMultipleInputs(false, sink, sources);
+        Iterator<JobVertex> iterator = graph.getVerticesSortedTopologicallyFromSources().iterator();
+
+        JobVertex source1 = iterator.next();
+        assertThat(source1.getName()).isEqualTo("Source: source-1");
+        assertThat(source1.getOperatorPrettyName()).isEqualTo("Source: source-1\n");
+
+        JobVertex source2 = iterator.next();
+        assertThat(source2.getName()).isEqualTo("Source: source-2");
+        assertThat(source2.getOperatorPrettyName()).isEqualTo("Source: source-2\n");
+
+        JobVertex source3 = iterator.next();
+        assertThat(source3.getName()).isEqualTo("Source: source-3");
+        assertThat(source3.getOperatorPrettyName()).isEqualTo("Source: source-3\n");
+
+        JobVertex multipleVertex = iterator.next();
+        assertThat(multipleVertex.getName()).isEqualTo("mit");
+        assertThat(multipleVertex.getOperatorPrettyName()).isEqualTo("mit\n");
+
+        JobVertex sinkVertex = iterator.next();
+        assertThat(sinkVertex.getName()).isEqualTo("Sink: sink");
+        assertThat(sinkVertex.getOperatorPrettyName()).isEqualTo("Sink: sink\n");
+    }
+
+    public JobGraph createGraphWithMultipleInputs(
+            boolean chain, String sinkName, String... inputNames) {
         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
         MultipleInputTransformation<Long> transform =
                 new MultipleInputTransformation<>(
@@ -1693,6 +1716,10 @@ class StreamingJobGraphGeneratorTest {
         transform.setChainingStrategy(
                 chain ? ChainingStrategy.HEAD_WITH_SOURCES : ChainingStrategy.NEVER);
 
+        DataStream<Long> dataStream = new DataStream<>(env, transform);
+        // do not chain with sink operator.
+        dataStream.rebalance().addSink(new DiscardingSink<>()).name(sinkName);
+
         env.addOperator(transform);
 
         return StreamingJobGraphGenerator.createJobGraph(env.getStreamGraph());
