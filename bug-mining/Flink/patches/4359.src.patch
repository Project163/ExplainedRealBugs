diff --git a/flink-python/pyflink/table/table_result.py b/flink-python/pyflink/table/table_result.py
index 2dfb02ffb2a..e9f2abe269d 100644
--- a/flink-python/pyflink/table/table_result.py
+++ b/flink-python/pyflink/table/table_result.py
@@ -134,8 +134,10 @@ class TableResult(object):
         """
         Print the result contents as tableau form to client console.
 
-        NOTE: please make sure the result data to print should be small.
-        Because all data will be collected to local first, and then print them to console.
+        For streaming mode, this method guarantees end-to-end exactly-once record delivery
+        which requires the checkpointing mechanism to be enabled.
+        By default, checkpointing is disabled. To enable checkpointing, set checkpointing properties
+        (see ExecutionCheckpointingOptions) through `TableConfig#getConfiguration()`.
 
         .. versionadded:: 1.11.0
         """
diff --git a/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/CliTableauResultView.java b/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/CliTableauResultView.java
index dc81872f453..74126c765c0 100644
--- a/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/CliTableauResultView.java
+++ b/flink-table/flink-sql-client/src/main/java/org/apache/flink/table/client/cli/CliTableauResultView.java
@@ -25,15 +25,6 @@ import org.apache.flink.table.client.gateway.Executor;
 import org.apache.flink.table.client.gateway.ResultDescriptor;
 import org.apache.flink.table.client.gateway.SqlExecutionException;
 import org.apache.flink.table.client.gateway.TypedResult;
-import org.apache.flink.table.types.logical.BigIntType;
-import org.apache.flink.table.types.logical.DecimalType;
-import org.apache.flink.table.types.logical.IntType;
-import org.apache.flink.table.types.logical.LocalZonedTimestampType;
-import org.apache.flink.table.types.logical.LogicalType;
-import org.apache.flink.table.types.logical.SmallIntType;
-import org.apache.flink.table.types.logical.TimeType;
-import org.apache.flink.table.types.logical.TimestampType;
-import org.apache.flink.table.types.logical.TinyIntType;
 import org.apache.flink.table.utils.PrintUtils;
 import org.apache.flink.types.Row;
 
@@ -54,7 +45,6 @@ import java.util.stream.Stream;
  */
 public class CliTableauResultView implements AutoCloseable {
 
-	private static final int NULL_COLUMN_WIDTH = CliStrings.NULL_COLUMN.length();
 	private static final int DEFAULT_COLUMN_WIDTH = 20;
 	private static final String CHANGEFLAG_COLUMN_NAME = "+/-";
 
@@ -183,11 +173,12 @@ public class CliTableauResultView implements AutoCloseable {
 		List<TableColumn> columns = resultDescriptor.getResultSchema().getTableColumns();
 		String[] fieldNames =
 				Stream.concat(
-						Stream.of("+/-"),
+						Stream.of(CHANGEFLAG_COLUMN_NAME),
 						columns.stream().map(TableColumn::getName)
 				).toArray(String[]::new);
 
-		int[] colWidths = columnWidthsByType(columns, true);
+		int[] colWidths = PrintUtils.columnWidthsByType(
+				columns, DEFAULT_COLUMN_WIDTH, CliStrings.NULL_COLUMN, CHANGEFLAG_COLUMN_NAME);
 		String borderline = PrintUtils.genBorderLine(colWidths);
 
 		// print filed names
@@ -227,98 +218,4 @@ public class CliTableauResultView implements AutoCloseable {
 			}
 		}
 	}
-
-	/**
-	 * Try to infer column width based on column types. In streaming case, we will have an
-	 * endless result set, thus couldn't determine column widths based on column values.
-	 */
-	private int[] columnWidthsByType(List<TableColumn> columns, boolean includeChangeflag) {
-		// fill width with field names first
-		int[] colWidths = columns.stream()
-				.mapToInt(col -> col.getName().length())
-				.toArray();
-
-		// determine proper column width based on types
-		for (int i = 0; i < columns.size(); ++i) {
-			LogicalType type = columns.get(i).getType().getLogicalType();
-			int len;
-			switch (type.getTypeRoot()) {
-				case TINYINT:
-					len = TinyIntType.PRECISION + 1; // extra for negative value
-					break;
-				case SMALLINT:
-					len = SmallIntType.PRECISION + 1; // extra for negative value
-					break;
-				case INTEGER:
-					len = IntType.PRECISION + 1; // extra for negative value
-					break;
-				case BIGINT:
-					len = BigIntType.PRECISION + 1; // extra for negative value
-					break;
-				case DECIMAL:
-					len = ((DecimalType) type).getPrecision() + 2; // extra for negative value and decimal point
-					break;
-				case BOOLEAN:
-					len = 5; // "true" or "false"
-					break;
-				case DATE:
-					len = 10; // e.g. 9999-12-31
-					break;
-				case TIME_WITHOUT_TIME_ZONE:
-					int precision = ((TimeType) type).getPrecision();
-					len = precision == 0 ? 8 : precision + 9; // 23:59:59[.999999999]
-					break;
-				case TIMESTAMP_WITHOUT_TIME_ZONE:
-					precision = ((TimestampType) type).getPrecision();
-					len = timestampTypeColumnWidth(precision);
-					break;
-				case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
-					precision = ((LocalZonedTimestampType) type).getPrecision();
-					len = timestampTypeColumnWidth(precision);
-					break;
-				default:
-					len = DEFAULT_COLUMN_WIDTH;
-			}
-
-			// adjust column width with potential null values
-			colWidths[i] = Math.max(colWidths[i], Math.max(len, NULL_COLUMN_WIDTH));
-		}
-
-		// add an extra column for change flag if necessary
-		if (includeChangeflag) {
-			int[] ret = new int[columns.size() + 1];
-			ret[0] = CHANGEFLAG_COLUMN_NAME.length();
-			System.arraycopy(colWidths, 0, ret, 1, columns.size());
-			return ret;
-		} else {
-			return colWidths;
-		}
-	}
-
-	/**
-	 * Here we consider two popular class for timestamp: LocalDateTime and java.sql.Timestamp.
-	 *
-	 * <p>According to LocalDateTime's comment, the string output will be one of the following
-	 * ISO-8601 formats:
-	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss}</li>
-	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss.SSS}</li>
-	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss.SSSSSS}</li>
-	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSS}</li>
-	 *
-	 * <p>And for java.sql.Timestamp, the number of digits after point will be precision except
-	 * when precision is 0. In that case, the format would be 'uuuu-MM-dd HH:mm:ss.0'
-	 */
-	int timestampTypeColumnWidth(int precision) {
-		int base = 19; // length of uuuu-MM-dd HH:mm:ss
-		if (precision == 0) {
-			return base + 2; // consider java.sql.Timestamp
-		} else if (precision <= 3) {
-			return base + 4;
-		} else if (precision <= 6) {
-			return base + 7;
-		} else {
-			return base + 10;
-		}
-	}
-
 }
diff --git a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/TableResult.java b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/TableResult.java
index f6c1a793d2e..17b03cbd1c8 100644
--- a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/TableResult.java
+++ b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/TableResult.java
@@ -131,14 +131,29 @@ public interface TableResult {
 	 *      it... // collect same data
 	 *  }
 	 * }</pre>
+	 *
+	 * <p>For streaming mode, this method guarantees end-to-end exactly-once record delivery
+	 * which requires the checkpointing mechanism to be enabled.
+	 * By default, checkpointing is disabled. To enable checkpointing, set checkpointing properties
+	 * (see ExecutionCheckpointingOptions) through {@link TableConfig#getConfiguration()}.
+	 *
+	 * <p>In order to fetch result to local, you can call either {@link #collect()} and {@link #print()}.
+	 * But, they can't be called both on the same {@link TableResult} instance,
+	 * because the result can only be accessed once.
 	 */
 	CloseableIterator<Row> collect();
 
 	/**
 	 * Print the result contents as tableau form to client console.
 	 *
-	 * <p><strong>NOTE:</strong> please make sure the result data to print should be small.
-	 * Because all data will be collected to local first, and then print them to console.
+	 * <p>For streaming mode, this method guarantees end-to-end exactly-once record delivery
+	 * which requires the checkpointing mechanism to be enabled.
+	 * By default, checkpointing is disabled. To enable checkpointing, set checkpointing properties
+	 * (see ExecutionCheckpointingOptions) through {@link TableConfig#getConfiguration()}.
+	 *
+	 * <p>In order to fetch result to local, you can call either {@link #collect()} and {@link #print()}.
+	 * But, they can't be called both on the same {@link TableResult} instance,
+	 * because the result can only be accessed once.
 	 */
 	void print();
 }
diff --git a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java
index b2e1784b736..05c578b280c 100644
--- a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java
+++ b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableEnvironmentImpl.java
@@ -704,7 +704,7 @@ public class TableEnvironmentImpl implements TableEnvironmentInternal {
 					.tableSchema(operation.getTableSchema())
 					.data(resultProvider.getResultIterator())
 					.setPrintStyle(TableResultImpl.PrintStyle.tableau(
-							PrintUtils.MAX_COLUMN_WIDTH, PrintUtils.NULL_COLUMN, isStreamingMode))
+							PrintUtils.MAX_COLUMN_WIDTH, PrintUtils.NULL_COLUMN, true, isStreamingMode))
 					.build();
 		} catch (Exception e) {
 			throw new TableException("Failed to execute sql", e);
@@ -1090,7 +1090,7 @@ public class TableEnvironmentImpl implements TableEnvironmentInternal {
 						headers,
 						types).build())
 				.data(Arrays.stream(rows).map(Row::of).collect(Collectors.toList()))
-				.setPrintStyle(TableResultImpl.PrintStyle.tableau(Integer.MAX_VALUE, "", false))
+				.setPrintStyle(TableResultImpl.PrintStyle.tableau(Integer.MAX_VALUE, "", false, false))
 				.build();
 	}
 
diff --git a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableResultImpl.java b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableResultImpl.java
index 4461f9d4a58..71fb8d6f8b4 100644
--- a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableResultImpl.java
+++ b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/internal/TableResultImpl.java
@@ -94,9 +94,16 @@ class TableResultImpl implements TableResult {
 		if (printStyle instanceof TableauStyle) {
 			int maxColumnWidth = ((TableauStyle) printStyle).getMaxColumnWidth();
 			String nullColumn = ((TableauStyle) printStyle).getNullColumn();
+			boolean deriveColumnWidthByType =  ((TableauStyle) printStyle).isDeriveColumnWidthByType();
 			boolean printRowKind = ((TableauStyle) printStyle).isPrintRowKind();
 			PrintUtils.printAsTableauForm(
-					getTableSchema(), it, new PrintWriter(System.out), maxColumnWidth, nullColumn, printRowKind);
+					getTableSchema(),
+					it,
+					new PrintWriter(System.out),
+					maxColumnWidth,
+					nullColumn,
+					deriveColumnWidthByType,
+					printRowKind);
 		} else if (printStyle instanceof RawContentStyle) {
 			while (it.hasNext()) {
 				System.out.println(String.join(",", PrintUtils.rowToString(it.next())));
@@ -118,7 +125,7 @@ class TableResultImpl implements TableResult {
 		private TableSchema tableSchema = null;
 		private ResultKind resultKind = null;
 		private CloseableIterator<Row> data = null;
-		private PrintStyle printStyle = PrintStyle.tableau(Integer.MAX_VALUE, PrintUtils.NULL_COLUMN, false);
+		private PrintStyle printStyle = PrintStyle.tableau(Integer.MAX_VALUE, PrintUtils.NULL_COLUMN, false, false);
 
 		private Builder() {
 		}
@@ -199,13 +206,18 @@ class TableResultImpl implements TableResult {
 	 */
 	public interface PrintStyle {
 		/**
-		 * Create a tableau print style with given max column width, null column and change mode indicator,
+		 * Create a tableau print style with given max column width, null column, change mode indicator
+		 * and a flag to indicate whether the column width is derived from type (true) or content (false),
 		 * which prints the result schema and content as tableau form.
 		 */
-		static PrintStyle tableau(int maxColumnWidth, String nullColumn, boolean printRowKind) {
+		static PrintStyle tableau(
+				int maxColumnWidth,
+				String nullColumn,
+				boolean deriveColumnWidthByType,
+				boolean printRowKind) {
 			Preconditions.checkArgument(maxColumnWidth > 0, "maxColumnWidth should be greater than 0");
 			Preconditions.checkNotNull(nullColumn, "nullColumn should not be null");
-			return new TableauStyle(maxColumnWidth, nullColumn, printRowKind);
+			return new TableauStyle(maxColumnWidth, nullColumn, deriveColumnWidthByType, printRowKind);
 		}
 
 		/**
@@ -222,17 +234,32 @@ class TableResultImpl implements TableResult {
 	 * print the result schema and content as tableau form.
 	 */
 	private static final class TableauStyle implements PrintStyle {
-
+		/**
+		 * A flag to indicate whether the column width is derived from type (true) or content (false).
+		 */
+		private final boolean deriveColumnWidthByType;
 		private final int maxColumnWidth;
 		private final String nullColumn;
+		/**
+		 * A flag to indicate whether print row kind info.
+		 */
 		private final boolean printRowKind;
 
-		private TableauStyle(int maxColumnWidth, String nullColumn, boolean printRowKind) {
+		private TableauStyle(
+				int maxColumnWidth,
+				String nullColumn,
+				boolean deriveColumnWidthByType,
+				boolean printRowKind) {
+			this.deriveColumnWidthByType = deriveColumnWidthByType;
 			this.maxColumnWidth = maxColumnWidth;
 			this.nullColumn = nullColumn;
 			this.printRowKind = printRowKind;
 		}
 
+		public boolean isDeriveColumnWidthByType() {
+			return deriveColumnWidthByType;
+		}
+
 		int getMaxColumnWidth() {
 			return maxColumnWidth;
 		}
diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PrintUtils.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PrintUtils.java
index 58bdee6698d..12b8af18d49 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PrintUtils.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PrintUtils.java
@@ -19,20 +19,30 @@
 package org.apache.flink.table.utils;
 
 import org.apache.flink.annotation.Internal;
-import org.apache.flink.table.api.DataTypes;
 import org.apache.flink.table.api.TableColumn;
 import org.apache.flink.table.api.TableSchema;
+import org.apache.flink.table.types.logical.BigIntType;
+import org.apache.flink.table.types.logical.DecimalType;
+import org.apache.flink.table.types.logical.IntType;
+import org.apache.flink.table.types.logical.LocalZonedTimestampType;
+import org.apache.flink.table.types.logical.LogicalType;
+import org.apache.flink.table.types.logical.SmallIntType;
+import org.apache.flink.table.types.logical.TimeType;
+import org.apache.flink.table.types.logical.TimestampType;
+import org.apache.flink.table.types.logical.TinyIntType;
 import org.apache.flink.types.Row;
 import org.apache.flink.util.StringUtils;
 
 import com.ibm.icu.lang.UCharacter;
 import com.ibm.icu.lang.UProperty;
 
+import javax.annotation.Nullable;
+
 import java.io.PrintWriter;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
@@ -45,6 +55,7 @@ public class PrintUtils {
 	public static final int MAX_COLUMN_WIDTH = 30;
 	public static final String NULL_COLUMN = "(NULL)";
 	private static final String COLUMN_TRUNCATED_FLAG = "...";
+	private static final String ROW_KIND_COLUMN = "op";
 
 	private PrintUtils() {
 	}
@@ -66,22 +77,36 @@ public class PrintUtils {
 			TableSchema tableSchema,
 			Iterator<Row> it,
 			PrintWriter printWriter) {
-		printAsTableauForm(tableSchema, it, printWriter, MAX_COLUMN_WIDTH, NULL_COLUMN, false);
+		printAsTableauForm(tableSchema, it, printWriter, MAX_COLUMN_WIDTH, NULL_COLUMN, false, false);
 	}
 
 	/**
 	 * Displays the result in a tableau form.
 	 *
+	 * <p><b>NOTE:</b> please make sure the data to print is small enough to be stored in java heap memory
+	 * if the column width is derived from content (`deriveColumnWidthByType` is false).
+	 *
 	 * <p>For example: (printRowKind is true)
-	 * +-------------+-------------+---------+-------------+
-	 * | row_kind | boolean_col | int_col | varchar_col |
-	 * +-------------+-------------+---------+-------------+
-	 * |       +I |        true |       1 |         abc |
-	 * |       -U |       false |       2 |         def |
-	 * |       +U |       false |       3 |         def |
-	 * |       -D |      (NULL) |  (NULL) |      (NULL) |
-	 * +-------------+-------------+---------+-------------+
+	 * <pre>
+	 * +----+-------------+---------+-------------+
+	 * | op | boolean_col | int_col | varchar_col |
+	 * +----+-------------+---------+-------------+
+	 * | +I |        true |       1 |         abc |
+	 * | -U |       false |       2 |         def |
+	 * | +U |       false |       3 |         def |
+	 * | -D |      (NULL) |  (NULL) |      (NULL) |
+	 * +----+-------------+---------+-------------+
 	 * 4 rows in result
+	 * </pre>
+	 *
+	 * @param tableSchema The schema of the data to print
+	 * @param it The iterator for the data to print
+	 * @param printWriter The writer to write to
+	 * @param maxColumnWidth The max width of a column
+	 * @param nullColumn The string representation of a null value
+	 * @param deriveColumnWidthByType A flag to indicate whether the column width
+	 *        is derived from type (true) or content (false).
+	 * @param printRowKind A flag to indicate whether print row kind info
 	 */
 	public static void printAsTableauForm(
 			TableSchema tableSchema,
@@ -89,47 +114,64 @@ public class PrintUtils {
 			PrintWriter printWriter,
 			int maxColumnWidth,
 			String nullColumn,
+			boolean deriveColumnWidthByType,
 			boolean printRowKind) {
-		List<String[]> rows = new ArrayList<>();
-
-		// fill field names first
-		final List<TableColumn> columns;
+		final List<TableColumn> columns = tableSchema.getTableColumns();
+		String[] columnNames = columns.stream().map(TableColumn::getName).toArray(String[]::new);
 		if (printRowKind) {
-			columns = Stream.concat(
-					Stream.of(TableColumn.of("row_kind", DataTypes.STRING())),
-					tableSchema.getTableColumns().stream()
-			).collect(Collectors.toList());
-		} else {
-			columns = tableSchema.getTableColumns();
+			columnNames = Stream.concat(Stream.of(ROW_KIND_COLUMN), Arrays.stream(columnNames)).toArray(String[]::new);
 		}
 
-		rows.add(columns.stream().map(TableColumn::getName).toArray(String[]::new));
-		while (it.hasNext()) {
-			rows.add(rowToString(it.next(), nullColumn, printRowKind));
+		final int[] colWidths;
+		if (deriveColumnWidthByType) {
+			colWidths = columnWidthsByType(
+					columns,
+					maxColumnWidth,
+					nullColumn,
+					printRowKind ? ROW_KIND_COLUMN : null);
+		} else {
+			final List<Row> rows = new ArrayList<>();
+			final List<String[]> content = new ArrayList<>();
+			content.add(columnNames);
+			while (it.hasNext()) {
+				Row row = it.next();
+				rows.add(row);
+				content.add(rowToString(row, nullColumn, printRowKind));
+			}
+			colWidths = columnWidthsByContent(columnNames, content, maxColumnWidth);
+			it = rows.iterator();
 		}
 
-		int[] colWidths = columnWidthsByContent(columns, rows, maxColumnWidth);
-		String borderline = genBorderLine(colWidths);
-
-		// print field names
+		final String borderline = PrintUtils.genBorderLine(colWidths);
+		// print border line
 		printWriter.println(borderline);
-		printSingleRow(colWidths, rows.get(0), printWriter);
+		// print field names
+		PrintUtils.printSingleRow(colWidths, columnNames, printWriter);
+		// print border line
 		printWriter.println(borderline);
+		printWriter.flush();
+
+		long numRows = 0;
+		while (it.hasNext()) {
+			String[] cols = rowToString(it.next(), nullColumn, printRowKind);
 
-		// print content
-		if (rows.size() > 1) {
-			rows.subList(1, rows.size()).forEach(row -> printSingleRow(colWidths, row, printWriter));
+			// print content
+			printSingleRow(colWidths, cols, printWriter);
+			numRows++;
+		}
+
+		if (numRows > 0) {
+			// print border line
 			printWriter.println(borderline);
 		}
 
-		int numRows = rows.size() - 1;
 		final String rowTerm;
 		if (numRows > 1) {
 			rowTerm = "rows";
 		} else {
 			rowTerm = "row";
 		}
-		printWriter.println((rows.size() - 1) + " " + rowTerm + " in set");
+		printWriter.println(numRows + " " + rowTerm + " in set");
 		printWriter.flush();
 	}
 
@@ -154,12 +196,22 @@ public class PrintUtils {
 		return fields.toArray(new String[0]);
 	}
 
+	public static String genBorderLine(int[] colWidths) {
+		StringBuilder sb = new StringBuilder();
+		sb.append("+");
+		for (int width : colWidths) {
+			sb.append(EncodingUtils.repeat('-', width + 1));
+			sb.append("-+");
+		}
+		return sb.toString();
+	}
+
 	private static int[] columnWidthsByContent(
-			List<TableColumn> columns,
+			String[] columnNames,
 			List<String[]> rows,
 			int maxColumnWidth) {
 		// fill width with field names first
-		int[] colWidths = columns.stream().mapToInt(col -> col.getName().length()).toArray();
+		final int[] colWidths = Stream.of(columnNames).mapToInt(String::length).toArray();
 
 		// fill column width with real data
 		for (String[] row : rows) {
@@ -176,14 +228,102 @@ public class PrintUtils {
 		return colWidths;
 	}
 
-	public static String genBorderLine(int[] colWidths) {
-		StringBuilder sb = new StringBuilder();
-		sb.append("+");
-		for (int width : colWidths) {
-			sb.append(EncodingUtils.repeat('-', width + 1));
-			sb.append("-+");
+	/**
+	 * Try to derive column width based on column types.
+	 * If result set is not small enough to be stored in java heap memory,
+	 * we can't determine column widths based on column values.
+	 */
+	public static int[] columnWidthsByType(
+			List<TableColumn> columns,
+			int maxColumnWidth,
+			String nullColumn,
+			@Nullable String rowKindColumn) {
+		// fill width with field names first
+		final int[] colWidths = columns.stream()
+				.mapToInt(col -> col.getName().length())
+				.toArray();
+
+		// determine proper column width based on types
+		for (int i = 0; i < columns.size(); ++i) {
+			LogicalType type = columns.get(i).getType().getLogicalType();
+			int len;
+			switch (type.getTypeRoot()) {
+				case TINYINT:
+					len = TinyIntType.PRECISION + 1; // extra for negative value
+					break;
+				case SMALLINT:
+					len = SmallIntType.PRECISION + 1; // extra for negative value
+					break;
+				case INTEGER:
+					len = IntType.PRECISION + 1; // extra for negative value
+					break;
+				case BIGINT:
+					len = BigIntType.PRECISION + 1; // extra for negative value
+					break;
+				case DECIMAL:
+					len = ((DecimalType) type).getPrecision() + 2; // extra for negative value and decimal point
+					break;
+				case BOOLEAN:
+					len = 5; // "true" or "false"
+					break;
+				case DATE:
+					len = 10; // e.g. 9999-12-31
+					break;
+				case TIME_WITHOUT_TIME_ZONE:
+					int precision = ((TimeType) type).getPrecision();
+					len = precision == 0 ? 8 : precision + 9; // 23:59:59[.999999999]
+					break;
+				case TIMESTAMP_WITHOUT_TIME_ZONE:
+					precision = ((TimestampType) type).getPrecision();
+					len = timestampTypeColumnWidth(precision);
+					break;
+				case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
+					precision = ((LocalZonedTimestampType) type).getPrecision();
+					len = timestampTypeColumnWidth(precision);
+					break;
+				default:
+					len = maxColumnWidth;
+			}
+
+			// adjust column width with potential null values
+			colWidths[i] = Math.max(colWidths[i], Math.max(len, nullColumn.length()));
+		}
+
+		// add an extra column for row kind if necessary
+		if (rowKindColumn != null) {
+			final int[] ret = new int[columns.size() + 1];
+			ret[0] = rowKindColumn.length();
+			System.arraycopy(colWidths, 0, ret, 1, columns.size());
+			return ret;
+		} else {
+			return colWidths;
+		}
+	}
+
+	/**
+	 * Here we consider two popular class for timestamp: LocalDateTime and java.sql.Timestamp.
+	 *
+	 * <p>According to LocalDateTime's comment, the string output will be one of the following
+	 * ISO-8601 formats:
+	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss}</li>
+	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss.SSS}</li>
+	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss.SSSSSS}</li>
+	 *  <li>{@code uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSS}</li>
+	 *
+	 * <p>And for java.sql.Timestamp, the number of digits after point will be precision except
+	 * when precision is 0. In that case, the format would be 'uuuu-MM-dd HH:mm:ss.0'
+	 */
+	private static int timestampTypeColumnWidth(int precision) {
+		int base = 19; // length of uuuu-MM-dd HH:mm:ss
+		if (precision == 0) {
+			return base + 2; // consider java.sql.Timestamp
+		} else if (precision <= 3) {
+			return base + 4;
+		} else if (precision <= 6) {
+			return base + 7;
+		} else {
+			return base + 10;
 		}
-		return sb.toString();
 	}
 
 	public static void printSingleRow(int[] colWidths, String[] cols, PrintWriter printWriter) {
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/utils/PrintUtilsTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/utils/PrintUtilsTest.java
index cb63b5c3b56..869303860c8 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/utils/PrintUtilsTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/utils/PrintUtilsTest.java
@@ -85,9 +85,9 @@ public class PrintUtilsTest {
 				new PrintWriter(outContent));
 
 		assertEquals(
-				"+---------+-----+--------+---------+----------------+-----------+\n" +
-				"| boolean | int | bigint | varchar | decimal(10, 5) | timestamp |\n" +
-				"+---------+-----+--------+---------+----------------+-----------+\n" +
+				"+---------+-----+--------+---------+----------------+-----------+" + System.lineSeparator() +
+				"| boolean | int | bigint | varchar | decimal(10, 5) | timestamp |" + System.lineSeparator() +
+				"+---------+-----+--------+---------+----------------+-----------+" + System.lineSeparator() +
 				"0 row in set" + System.lineSeparator(),
 				outContent.toString());
 	}
@@ -100,12 +100,32 @@ public class PrintUtilsTest {
 				new PrintWriter(outContent),
 				PrintUtils.MAX_COLUMN_WIDTH,
 				"",
+				true, // derive column width by type
 				true);
 
 		assertEquals(
-				"+----------+---------+-----+--------+---------+----------------+-----------+\n" +
-				"| row_kind | boolean | int | bigint | varchar | decimal(10, 5) | timestamp |\n" +
-				"+----------+---------+-----+--------+---------+----------------+-----------+\n" +
+				"+----+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
+				"| op | boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |" + System.lineSeparator() +
+				"+----+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
+				"0 row in set" + System.lineSeparator(),
+				outContent.toString());
+	}
+
+	@Test
+	public void testPrintWithEmptyResultAndDeriveColumnWidthByContent() {
+		PrintUtils.printAsTableauForm(
+				getSchema(),
+				Collections.<Row>emptyList().iterator(),
+				new PrintWriter(outContent),
+				PrintUtils.MAX_COLUMN_WIDTH,
+				"",
+				false, // derive column width by content
+				false);
+
+		assertEquals(
+				"+---------+-----+--------+---------+----------------+-----------+" + System.lineSeparator() +
+				"| boolean | int | bigint | varchar | decimal(10, 5) | timestamp |" + System.lineSeparator() +
+				"+---------+-----+--------+---------+----------------+-----------+" + System.lineSeparator() +
 				"0 row in set" + System.lineSeparator(),
 				outContent.toString());
 	}
@@ -124,18 +144,18 @@ public class PrintUtilsTest {
 		// Because the length of `これは日本語をテストするた` plus the length of `...` is 29,
 		// no more Japanese character can be added to the line.
 		assertEquals(
-				"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+\n" +
-				"| boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |\n" +
-				"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+\n" +
-				"|  (NULL) |           1 |                    2 |                            abc |           1.23 |      2020-03-01 18:39:14.0 |\n" +
-				"|   false |      (NULL) |                    0 |                                |              1 |      2020-03-01 18:39:14.1 |\n" +
-				"|    true |  2147483647 |               (NULL) |                        abcdefg |     1234567890 |     2020-03-01 18:39:14.12 |\n" +
-				"|   false | -2147483648 |  9223372036854775807 |                         (NULL) |    12345.06789 |    2020-03-01 18:39:14.123 |\n" +
-				"|    true |         100 | -9223372036854775808 |                     abcdefg111 |         (NULL) | 2020-03-01 18:39:14.123456 |\n" +
-				"|  (NULL) |          -1 |                   -1 | abcdefghijklmnopqrstuvwxyza... |   -12345.06789 |                     (NULL) |\n" +
-				"|  (NULL) |          -1 |                   -1 |                   这是一段中文 |   -12345.06789 |      2020-03-04 18:39:14.0 |\n" +
-				"|  (NULL) |          -1 |                   -1 |  これは日本語をテストするた... |   -12345.06789 |      2020-03-04 18:39:14.0 |\n" +
-				"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+\n" +
+				"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
+				"| boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |" + System.lineSeparator() +
+				"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
+				"|  (NULL) |           1 |                    2 |                            abc |           1.23 |      2020-03-01 18:39:14.0 |" + System.lineSeparator() +
+				"|   false |      (NULL) |                    0 |                                |              1 |      2020-03-01 18:39:14.1 |" + System.lineSeparator() +
+				"|    true |  2147483647 |               (NULL) |                        abcdefg |     1234567890 |     2020-03-01 18:39:14.12 |" + System.lineSeparator() +
+				"|   false | -2147483648 |  9223372036854775807 |                         (NULL) |    12345.06789 |    2020-03-01 18:39:14.123 |" + System.lineSeparator() +
+				"|    true |         100 | -9223372036854775808 |                     abcdefg111 |         (NULL) | 2020-03-01 18:39:14.123456 |" + System.lineSeparator() +
+				"|  (NULL) |          -1 |                   -1 | abcdefghijklmnopqrstuvwxyza... |   -12345.06789 |                     (NULL) |" + System.lineSeparator() +
+				"|  (NULL) |          -1 |                   -1 |                   这是一段中文 |   -12345.06789 |      2020-03-04 18:39:14.0 |" + System.lineSeparator() +
+				"|  (NULL) |          -1 |                   -1 |  これは日本語をテストするた... |   -12345.06789 |      2020-03-04 18:39:14.0 |" + System.lineSeparator() +
+				"+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
 				"8 rows in set" + System.lineSeparator(),
 				outContent.toString());
 	}
@@ -148,6 +168,7 @@ public class PrintUtilsTest {
 				new PrintWriter(outContent),
 				PrintUtils.MAX_COLUMN_WIDTH,
 				"",
+				true, // derive column width by type
 				true);
 
 		// note: the expected result may look irregular because every CJK(Chinese/Japanese/Korean) character's
@@ -157,22 +178,45 @@ public class PrintUtilsTest {
 		// Because the length of `これは日本語をテストするた` plus the length of `...` is 29,
 		// no more Japanese character can be added to the line.
 		assertEquals(
-				"+----------+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+\n" +
-				"| row_kind | boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |\n" +
-				"+----------+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+\n" +
-				"|       +I |         |           1 |                    2 |                            abc |           1.23 |      2020-03-01 18:39:14.0 |\n" +
-				"|       +I |   false |             |                    0 |                                |              1 |      2020-03-01 18:39:14.1 |\n" +
-				"|       -D |    true |  2147483647 |                      |                        abcdefg |     1234567890 |     2020-03-01 18:39:14.12 |\n" +
-				"|       +I |   false | -2147483648 |  9223372036854775807 |                                |    12345.06789 |    2020-03-01 18:39:14.123 |\n" +
-				"|       +I |    true |         100 | -9223372036854775808 |                     abcdefg111 |                | 2020-03-01 18:39:14.123456 |\n" +
-				"|       -U |         |          -1 |                   -1 | abcdefghijklmnopqrstuvwxyza... |   -12345.06789 |                            |\n" +
-				"|       +U |         |          -1 |                   -1 |                   这是一段中文 |   -12345.06789 |      2020-03-04 18:39:14.0 |\n" +
-				"|       -D |         |          -1 |                   -1 |  これは日本語をテストするた... |   -12345.06789 |      2020-03-04 18:39:14.0 |\n" +
-				"+----------+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+\n" +
+				"+----+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
+				"| op | boolean |         int |               bigint |                        varchar | decimal(10, 5) |                  timestamp |" + System.lineSeparator() +
+				"+----+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
+				"| +I |         |           1 |                    2 |                            abc |           1.23 |      2020-03-01 18:39:14.0 |" + System.lineSeparator() +
+				"| +I |   false |             |                    0 |                                |              1 |      2020-03-01 18:39:14.1 |" + System.lineSeparator() +
+				"| -D |    true |  2147483647 |                      |                        abcdefg |     1234567890 |     2020-03-01 18:39:14.12 |" + System.lineSeparator() +
+				"| +I |   false | -2147483648 |  9223372036854775807 |                                |    12345.06789 |    2020-03-01 18:39:14.123 |" + System.lineSeparator() +
+				"| +I |    true |         100 | -9223372036854775808 |                     abcdefg111 |                | 2020-03-01 18:39:14.123456 |" + System.lineSeparator() +
+				"| -U |         |          -1 |                   -1 | abcdefghijklmnopqrstuvwxyza... |   -12345.06789 |                            |" + System.lineSeparator() +
+				"| +U |         |          -1 |                   -1 |                   这是一段中文 |   -12345.06789 |      2020-03-04 18:39:14.0 |" + System.lineSeparator() +
+				"| -D |         |          -1 |                   -1 |  これは日本語をテストするた... |   -12345.06789 |      2020-03-04 18:39:14.0 |" + System.lineSeparator() +
+				"+----+---------+-------------+----------------------+--------------------------------+----------------+----------------------------+" + System.lineSeparator() +
 				"8 rows in set" + System.lineSeparator(),
 				outContent.toString());
 	}
 
+	@Test
+	public void testPrintWithMultipleRowsAndDeriveColumnWidthByContent() {
+		PrintUtils.printAsTableauForm(
+				getSchema(),
+				getData().subList(0, 3).iterator(),
+				new PrintWriter(outContent),
+				PrintUtils.MAX_COLUMN_WIDTH,
+				"",
+				false, // derive column width by content
+				true);
+
+		assertEquals(
+				"+----+---------+------------+--------+---------+----------------+------------------------+" + System.lineSeparator() +
+				"| op | boolean |        int | bigint | varchar | decimal(10, 5) |              timestamp |" + System.lineSeparator() +
+				"+----+---------+------------+--------+---------+----------------+------------------------+" + System.lineSeparator() +
+				"| +I |         |          1 |      2 |     abc |           1.23 |  2020-03-01 18:39:14.0 |" + System.lineSeparator() +
+				"| +I |   false |            |      0 |         |              1 |  2020-03-01 18:39:14.1 |" + System.lineSeparator() +
+				"| -D |    true | 2147483647 |        | abcdefg |     1234567890 | 2020-03-01 18:39:14.12 |" + System.lineSeparator() +
+				"+----+---------+------------+--------+---------+----------------+------------------------+" + System.lineSeparator() +
+				"3 rows in set" + System.lineSeparator(),
+				outContent.toString());
+	}
+
 	private TableSchema getSchema() {
 		return TableSchema.builder()
 				.field("boolean", DataTypes.BOOLEAN())
diff --git a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala
index a4c6734384b..a73d87a25d5 100644
--- a/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala
+++ b/flink-table/flink-table-planner/src/main/scala/org/apache/flink/table/api/internal/TableEnvImpl.scala
@@ -44,10 +44,12 @@ import org.apache.flink.table.types.{AbstractDataType, DataType}
 import org.apache.flink.table.util.JavaScalaConversionUtil
 import org.apache.flink.table.utils.PrintUtils
 import org.apache.flink.types.Row
+
 import org.apache.calcite.jdbc.CalciteSchemaBuilder.asRootSchema
 import org.apache.calcite.sql.parser.SqlParser
 import org.apache.calcite.tools.FrameworkConfig
 import org.apache.commons.lang3.StringUtils
+
 import _root_.java.lang.{Iterable => JIterable, Long => JLong}
 import _root_.java.util.function.{Function => JFunction, Supplier => JSupplier}
 import _root_.java.util.{Optional, Collections => JCollections, HashMap => JHashMap, List => JList, Map => JMap}
@@ -598,7 +600,7 @@ abstract class TableEnvImpl(
         .tableSchema(tableSchema)
         .data(selectResultProvider.getResultIterator)
         .setPrintStyle(
-          PrintStyle.tableau(PrintUtils.MAX_COLUMN_WIDTH, PrintUtils.NULL_COLUMN, false))
+          PrintStyle.tableau(PrintUtils.MAX_COLUMN_WIDTH, PrintUtils.NULL_COLUMN, true, false))
         .build
     } catch {
       case e: Exception =>
