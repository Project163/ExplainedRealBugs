diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
index 2db9d8bd53a..0779caedeae 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
@@ -681,7 +681,8 @@ public class JobMaster extends PermanentlyFencedRpcEndpoint<JobMasterId>
                             unresolvedTaskManagerLocation.getExternalAddress(),
                             throwable.getMessage());
             log.error(errMsg);
-            return CompletableFuture.completedFuture(new RegistrationResponse.Decline(errMsg));
+            return CompletableFuture.completedFuture(
+                    new RegistrationResponse.Failure(new FlinkException(errMsg, throwable)));
         }
 
         final ResourceID taskManagerId = taskManagerLocation.getResourceID();
@@ -695,7 +696,7 @@ public class JobMaster extends PermanentlyFencedRpcEndpoint<JobMasterId>
                     .handleAsync(
                             (TaskExecutorGateway taskExecutorGateway, Throwable throwable) -> {
                                 if (throwable != null) {
-                                    return new RegistrationResponse.Decline(throwable.getMessage());
+                                    return new RegistrationResponse.Failure(throwable);
                                 }
 
                                 slotPoolService.registerTaskManager(taskManagerId);
@@ -1153,7 +1154,10 @@ public class JobMaster extends PermanentlyFencedRpcEndpoint<JobMasterId>
 
     private class ResourceManagerConnection
             extends RegisteredRpcConnection<
-                    ResourceManagerId, ResourceManagerGateway, JobMasterRegistrationSuccess> {
+                    ResourceManagerId,
+                    ResourceManagerGateway,
+                    JobMasterRegistrationSuccess,
+                    RegistrationResponse.Rejection> {
         private final JobID jobID;
 
         private final ResourceID jobManagerResourceID;
@@ -1180,10 +1184,16 @@ public class JobMaster extends PermanentlyFencedRpcEndpoint<JobMasterId>
 
         @Override
         protected RetryingRegistration<
-                        ResourceManagerId, ResourceManagerGateway, JobMasterRegistrationSuccess>
+                        ResourceManagerId,
+                        ResourceManagerGateway,
+                        JobMasterRegistrationSuccess,
+                        RegistrationResponse.Rejection>
                 generateRegistration() {
             return new RetryingRegistration<
-                    ResourceManagerId, ResourceManagerGateway, JobMasterRegistrationSuccess>(
+                    ResourceManagerId,
+                    ResourceManagerGateway,
+                    JobMasterRegistrationSuccess,
+                    RegistrationResponse.Rejection>(
                     log,
                     getRpcService(),
                     "ResourceManager",
@@ -1221,6 +1231,9 @@ public class JobMaster extends PermanentlyFencedRpcEndpoint<JobMasterId>
                     });
         }
 
+        @Override
+        protected void onRegistrationRejection(RegistrationResponse.Rejection rejection) {}
+
         @Override
         protected void onRegistrationFailure(final Throwable failure) {
             handleJobMasterError(failure);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegisteredRpcConnection.java b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegisteredRpcConnection.java
index dcce2a618e6..8378a5b3341 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegisteredRpcConnection.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegisteredRpcConnection.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.runtime.registration;
 
-import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.rpc.RpcGateway;
 
 import org.slf4j.Logger;
@@ -44,9 +43,13 @@ import static org.apache.flink.util.Preconditions.checkState;
  * @param <F> The type of the fencing token
  * @param <G> The type of the gateway to connect to.
  * @param <S> The type of the successful registration responses.
+ * @param <R> The type of the registration rejection responses.
  */
 public abstract class RegisteredRpcConnection<
-        F extends Serializable, G extends RpcGateway, S extends RegistrationResponse.Success> {
+        F extends Serializable,
+        G extends RpcGateway,
+        S extends RegistrationResponse.Success,
+        R extends RegistrationResponse.Rejection> {
 
     private static final AtomicReferenceFieldUpdater<RegisteredRpcConnection, RetryingRegistration>
             REGISTRATION_UPDATER =
@@ -71,7 +74,7 @@ public abstract class RegisteredRpcConnection<
     private final Executor executor;
 
     /** The Registration of this RPC connection. */
-    private volatile RetryingRegistration<F, G, S> pendingRegistration;
+    private volatile RetryingRegistration<F, G, S, R> pendingRegistration;
 
     /** The gateway to register, it's null until the registration is completed. */
     private volatile G targetGateway;
@@ -99,7 +102,7 @@ public abstract class RegisteredRpcConnection<
                 !isConnected() && pendingRegistration == null,
                 "The RPC connection is already started");
 
-        final RetryingRegistration<F, G, S> newRegistration = createNewRegistration();
+        final RetryingRegistration<F, G, S, R> newRegistration = createNewRegistration();
 
         if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {
             newRegistration.startRegistration();
@@ -122,13 +125,13 @@ public abstract class RegisteredRpcConnection<
         if (closed) {
             return false;
         } else {
-            final RetryingRegistration<F, G, S> currentPendingRegistration = pendingRegistration;
+            final RetryingRegistration<F, G, S, R> currentPendingRegistration = pendingRegistration;
 
             if (currentPendingRegistration != null) {
                 currentPendingRegistration.cancel();
             }
 
-            final RetryingRegistration<F, G, S> newRegistration = createNewRegistration();
+            final RetryingRegistration<F, G, S, R> newRegistration = createNewRegistration();
 
             if (REGISTRATION_UPDATER.compareAndSet(
                     this, currentPendingRegistration, newRegistration)) {
@@ -154,11 +157,18 @@ public abstract class RegisteredRpcConnection<
      * This method generate a specific Registration, for example TaskExecutor Registration at the
      * ResourceManager.
      */
-    protected abstract RetryingRegistration<F, G, S> generateRegistration();
+    protected abstract RetryingRegistration<F, G, S, R> generateRegistration();
 
     /** This method handle the Registration Response. */
     protected abstract void onRegistrationSuccess(S success);
 
+    /**
+     * This method handles the Registration rejection.
+     *
+     * @param rejection rejection containing additional information about the rejection
+     */
+    protected abstract void onRegistrationRejection(R rejection);
+
     /** This method handle the Registration failure. */
     protected abstract void onRegistrationFailure(Throwable failure);
 
@@ -229,13 +239,15 @@ public abstract class RegisteredRpcConnection<
     //  Internal methods
     // ------------------------------------------------------------------------
 
-    private RetryingRegistration<F, G, S> createNewRegistration() {
-        RetryingRegistration<F, G, S> newRegistration = checkNotNull(generateRegistration());
+    private RetryingRegistration<F, G, S, R> createNewRegistration() {
+        RetryingRegistration<F, G, S, R> newRegistration = checkNotNull(generateRegistration());
 
-        CompletableFuture<Tuple2<G, S>> future = newRegistration.getFuture();
+        CompletableFuture<RetryingRegistration.RetryingRegistrationResult<G, S, R>> future =
+                newRegistration.getFuture();
 
         future.whenCompleteAsync(
-                (Tuple2<G, S> result, Throwable failure) -> {
+                (RetryingRegistration.RetryingRegistrationResult<G, S, R> result,
+                        Throwable failure) -> {
                     if (failure != null) {
                         if (failure instanceof CancellationException) {
                             // we ignore cancellation exceptions because they originate from
@@ -250,8 +262,16 @@ public abstract class RegisteredRpcConnection<
                             onRegistrationFailure(failure);
                         }
                     } else {
-                        targetGateway = result.f0;
-                        onRegistrationSuccess(result.f1);
+                        if (result.isSuccess()) {
+                            targetGateway = result.getGateway();
+                            onRegistrationSuccess(result.getSuccess());
+                        } else if (result.isRejection()) {
+                            onRegistrationRejection(result.getRejection());
+                        } else {
+                            throw new IllegalArgumentException(
+                                    String.format(
+                                            "Unknown retrying registration response: %s.", result));
+                        }
                     }
                 },
                 executor);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationConnectionListener.java b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationConnectionListener.java
index def5ed4f789..f016c427da7 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationConnectionListener.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationConnectionListener.java
@@ -23,7 +23,7 @@ package org.apache.flink.runtime.registration;
  * RegisteredRpcConnection} have to implement this interface.
  */
 public interface RegistrationConnectionListener<
-        T extends RegisteredRpcConnection<?, ?, S>, S extends RegistrationResponse.Success> {
+        T extends RegisteredRpcConnection<?, ?, S, ?>, S extends RegistrationResponse.Success> {
 
     /**
      * This method is called by the {@link RegisteredRpcConnection} when the registration is
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationResponse.java b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationResponse.java
index f868ff65bb3..e905884f272 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationResponse.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RegistrationResponse.java
@@ -18,6 +18,8 @@
 
 package org.apache.flink.runtime.registration;
 
+import org.apache.flink.util.SerializedThrowable;
+
 import java.io.Serializable;
 
 /** Base class for responses given to registration attempts from {@link RetryingRegistration}. */
@@ -42,30 +44,57 @@ public abstract class RegistrationResponse implements Serializable {
 
     // ----------------------------------------------------------------------------
 
-    /** A rejected (declined) registration. */
-    public static final class Decline extends RegistrationResponse {
+    /**
+     * A registration failure.
+     *
+     * <p>A failure indicates a temporary problem which can be solved by retrying the connection
+     * attempt. That's why the {@link RetryingRegistration} will retry the registration with the
+     * target upon receiving a {@link Failure} response. Consequently, the target should answer with
+     * a {@link Failure} if a temporary failure has occurred.
+     */
+    public static final class Failure extends RegistrationResponse {
         private static final long serialVersionUID = 1L;
 
-        /** The rejection reason. */
-        private final String reason;
+        /** The failure reason. */
+        private final SerializedThrowable reason;
 
         /**
-         * Creates a new rejection message.
+         * Creates a new failure message.
          *
-         * @param reason The reason for the rejection.
+         * @param reason The reason for the failure.
          */
-        public Decline(String reason) {
-            this.reason = reason != null ? reason : "(unknown)";
+        public Failure(Throwable reason) {
+            this.reason = new SerializedThrowable(reason);
         }
 
-        /** Gets the reason for the rejection. */
-        public String getReason() {
+        /** Gets the reason for the failure. */
+        public SerializedThrowable getReason() {
             return reason;
         }
 
         @Override
         public String toString() {
-            return "Registration Declined (" + reason + ')';
+            return "Registration Failure (" + reason + ')';
+        }
+    }
+
+    // ----------------------------------------------------------------------------
+
+    /**
+     * A rejected (declined) registration.
+     *
+     * <p>A rejection indicates a permanent problem which prevents the registration between the
+     * target and the caller which cannot be solved by retrying the connection. Consequently, the
+     * {@link RetryingRegistration} will stop when it receives a {@link Rejection} response from the
+     * target. Moreover, a target should respond with {@link Rejection} if it realizes that it
+     * cannot work with the caller.
+     */
+    public static class Rejection extends RegistrationResponse {
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        public String toString() {
+            return "Registration Rejected";
         }
     }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RetryingRegistration.java b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RetryingRegistration.java
index 7d90886dd64..ec20dbf5aea 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RetryingRegistration.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/registration/RetryingRegistration.java
@@ -18,14 +18,16 @@
 
 package org.apache.flink.runtime.registration;
 
-import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.rpc.FencedRpcGateway;
 import org.apache.flink.runtime.rpc.RpcGateway;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.Preconditions;
 
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+
 import java.io.Serializable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
@@ -45,9 +47,13 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
  * @param <F> The type of the fencing token
  * @param <G> The type of the gateway to connect to.
  * @param <S> The type of the successful registration responses.
+ * @param <R> The type of the registration rejection responses.
  */
 public abstract class RetryingRegistration<
-        F extends Serializable, G extends RpcGateway, S extends RegistrationResponse.Success> {
+        F extends Serializable,
+        G extends RpcGateway,
+        S extends RegistrationResponse.Success,
+        R extends RegistrationResponse.Rejection> {
 
     // ------------------------------------------------------------------------
     // Fields
@@ -65,7 +71,7 @@ public abstract class RetryingRegistration<
 
     private final F fencingToken;
 
-    private final CompletableFuture<Tuple2<G, S>> completionFuture;
+    private final CompletableFuture<RetryingRegistrationResult<G, S, R>> completionFuture;
 
     private final RetryingRegistrationConfiguration retryingRegistrationConfiguration;
 
@@ -97,7 +103,7 @@ public abstract class RetryingRegistration<
     //  completion and cancellation
     // ------------------------------------------------------------------------
 
-    public CompletableFuture<Tuple2<G, S>> getFuture() {
+    public CompletableFuture<RetryingRegistrationResult<G, S, R>> getFuture() {
         return completionFuture;
     }
 
@@ -221,18 +227,31 @@ public abstract class RetryingRegistration<
                             (RegistrationResponse result) -> {
                                 if (!isCanceled()) {
                                     if (result instanceof RegistrationResponse.Success) {
-                                        // registration successful!
+                                        log.debug(
+                                                "Registration with {} at {} was successful.",
+                                                targetName,
+                                                targetAddress);
                                         S success = (S) result;
-                                        completionFuture.complete(Tuple2.of(gateway, success));
+                                        completionFuture.complete(
+                                                RetryingRegistrationResult.success(
+                                                        gateway, success));
+                                    } else if (result instanceof RegistrationResponse.Rejection) {
+                                        log.debug(
+                                                "Registration with {} at {} was rejected.",
+                                                targetName,
+                                                targetAddress);
+                                        R rejection = (R) result;
+                                        completionFuture.complete(
+                                                RetryingRegistrationResult.rejection(rejection));
                                     } else {
-                                        // registration refused or unknown
-                                        if (result instanceof RegistrationResponse.Decline) {
-                                            RegistrationResponse.Decline decline =
-                                                    (RegistrationResponse.Decline) result;
+                                        // registration failure
+                                        if (result instanceof RegistrationResponse.Failure) {
+                                            RegistrationResponse.Failure failure =
+                                                    (RegistrationResponse.Failure) result;
                                             log.info(
-                                                    "Registration at {} was declined: {}",
+                                                    "Registration failure at {} occurred.",
                                                     targetName,
-                                                    decline.getReason());
+                                                    failure.getReason());
                                         } else {
                                             log.error(
                                                     "Received unknown response to registration attempt: {}",
@@ -324,4 +343,58 @@ public abstract class RetryingRegistration<
     private void startRegistrationLater(final long delay) {
         rpcService.scheduleRunnable(this::startRegistration, delay, TimeUnit.MILLISECONDS);
     }
+
+    static final class RetryingRegistrationResult<G, S, R> {
+        @Nullable private final G gateway;
+
+        @Nullable private final S success;
+
+        @Nullable private final R rejection;
+
+        private RetryingRegistrationResult(
+                @Nullable G gateway, @Nullable S success, @Nullable R rejection) {
+            this.gateway = gateway;
+            this.success = success;
+            this.rejection = rejection;
+        }
+
+        boolean isSuccess() {
+            return success != null && gateway != null;
+        }
+
+        boolean isRejection() {
+            return rejection != null;
+        }
+
+        public G getGateway() {
+            Preconditions.checkState(isSuccess());
+            return gateway;
+        }
+
+        public R getRejection() {
+            Preconditions.checkState(isRejection());
+            return rejection;
+        }
+
+        public S getSuccess() {
+            Preconditions.checkState(isSuccess());
+            return success;
+        }
+
+        static <
+                        G extends RpcGateway,
+                        S extends RegistrationResponse.Success,
+                        R extends RegistrationResponse.Rejection>
+                RetryingRegistrationResult<G, S, R> success(G gateway, S success) {
+            return new RetryingRegistrationResult<>(gateway, success, null);
+        }
+
+        static <
+                        G extends RpcGateway,
+                        S extends RegistrationResponse.Success,
+                        R extends RegistrationResponse.Rejection>
+                RetryingRegistrationResult<G, S, R> rejection(R rejection) {
+            return new RetryingRegistrationResult<>(null, null, rejection);
+        }
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
index af45b0d46b0..b306fdc23d1 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
@@ -392,7 +392,8 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                                                         + "This indicates that a JobMaster leader change has happened.",
                                                 leadingJobMasterId, jobMasterId);
                                 log.debug(declineMessage);
-                                return new RegistrationResponse.Decline(declineMessage);
+                                return new RegistrationResponse.Failure(
+                                        new FlinkException(declineMessage));
                             }
                         },
                         getMainThreadExecutor());
@@ -414,7 +415,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                                     jobManagerAddress);
                         }
 
-                        return new RegistrationResponse.Decline(throwable.getMessage());
+                        return new RegistrationResponse.Failure(throwable);
                     } else {
                         return registrationResponse;
                     }
@@ -440,7 +441,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                     if (taskExecutorGatewayFuture == taskExecutorGatewayFutures.get(resourceId)) {
                         taskExecutorGatewayFutures.remove(resourceId);
                         if (throwable != null) {
-                            return new RegistrationResponse.Decline(throwable.getMessage());
+                            return new RegistrationResponse.Failure(throwable);
                         } else {
                             return registerTaskExecutorInternal(
                                     taskExecutorGateway, taskExecutorRegistration);
@@ -449,8 +450,8 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                         log.debug(
                                 "Ignoring outdated TaskExecutorGateway connection for {}.",
                                 resourceId.getStringWithMetadata());
-                        return new RegistrationResponse.Decline(
-                                "Decline outdated task executor registration.");
+                        return new RegistrationResponse.Failure(
+                                new FlinkException("Decline outdated task executor registration."));
                     }
                 },
                 getMainThreadExecutor());
@@ -943,7 +944,8 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                             + "not recognize it",
                     taskExecutorResourceId.getStringWithMetadata(),
                     taskExecutorAddress);
-            return new RegistrationResponse.Decline("unrecognized TaskExecutor");
+            return new RegistrationResponse.Failure(
+                    new FlinkException("unrecognized TaskExecutor"));
         } else {
             WorkerRegistration<WorkerType> registration =
                     new WorkerRegistration<>(
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java
index 40b6aa6f4f6..124ba3f111a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/DefaultJobLeaderService.java
@@ -230,7 +230,11 @@ public class DefaultJobLeaderService implements JobLeaderService {
         /** Rpc connection to the job leader. */
         @GuardedBy("lock")
         @Nullable
-        private RegisteredRpcConnection<JobMasterId, JobMasterGateway, JMTMRegistrationSuccess>
+        private RegisteredRpcConnection<
+                        JobMasterId,
+                        JobMasterGateway,
+                        JMTMRegistrationSuccess,
+                        RegistrationResponse.Rejection>
                 rpcConnection;
 
         /** Leader id of the current job leader. */
@@ -371,7 +375,10 @@ public class DefaultJobLeaderService implements JobLeaderService {
         /** Rpc connection for the job manager <--> task manager connection. */
         private final class JobManagerRegisteredRpcConnection
                 extends RegisteredRpcConnection<
-                        JobMasterId, JobMasterGateway, JMTMRegistrationSuccess> {
+                        JobMasterId,
+                        JobMasterGateway,
+                        JMTMRegistrationSuccess,
+                        RegistrationResponse.Rejection> {
 
             JobManagerRegisteredRpcConnection(
                     Logger log, String targetAddress, JobMasterId jobMasterId, Executor executor) {
@@ -379,7 +386,11 @@ public class DefaultJobLeaderService implements JobLeaderService {
             }
 
             @Override
-            protected RetryingRegistration<JobMasterId, JobMasterGateway, JMTMRegistrationSuccess>
+            protected RetryingRegistration<
+                            JobMasterId,
+                            JobMasterGateway,
+                            JMTMRegistrationSuccess,
+                            RegistrationResponse.Rejection>
                     generateRegistration() {
                 return new DefaultJobLeaderService.JobManagerRetryingRegistration(
                         LOG,
@@ -413,6 +424,9 @@ public class DefaultJobLeaderService implements JobLeaderService {
                 }
             }
 
+            @Override
+            protected void onRegistrationRejection(RegistrationResponse.Rejection rejection) {}
+
             @Override
             protected void onRegistrationFailure(Throwable failure) {
                 // filter out old registration attempts
@@ -435,7 +449,11 @@ public class DefaultJobLeaderService implements JobLeaderService {
 
     /** Retrying registration for the job manager <--> task manager connection. */
     private static final class JobManagerRetryingRegistration
-            extends RetryingRegistration<JobMasterId, JobMasterGateway, JMTMRegistrationSuccess> {
+            extends RetryingRegistration<
+                    JobMasterId,
+                    JobMasterGateway,
+                    JMTMRegistrationSuccess,
+                    RegistrationResponse.Rejection> {
 
         private final String taskManagerRpcAddress;
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnection.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnection.java
index 8baaea29c60..69bc9ab21c1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnection.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnection.java
@@ -39,7 +39,10 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
 /** The connection between a TaskExecutor and the ResourceManager. */
 public class TaskExecutorToResourceManagerConnection
         extends RegisteredRpcConnection<
-                ResourceManagerId, ResourceManagerGateway, TaskExecutorRegistrationSuccess> {
+                ResourceManagerId,
+                ResourceManagerGateway,
+                TaskExecutorRegistrationSuccess,
+                RegistrationResponse.Rejection> {
 
     private final RpcService rpcService;
 
@@ -74,7 +77,10 @@ public class TaskExecutorToResourceManagerConnection
 
     @Override
     protected RetryingRegistration<
-                    ResourceManagerId, ResourceManagerGateway, TaskExecutorRegistrationSuccess>
+                    ResourceManagerId,
+                    ResourceManagerGateway,
+                    TaskExecutorRegistrationSuccess,
+                    RegistrationResponse.Rejection>
             generateRegistration() {
         return new TaskExecutorToResourceManagerConnection.ResourceManagerRegistration(
                 log,
@@ -95,6 +101,9 @@ public class TaskExecutorToResourceManagerConnection
         registrationListener.onRegistrationSuccess(this, success);
     }
 
+    @Override
+    protected void onRegistrationRejection(RegistrationResponse.Rejection rejection) {}
+
     @Override
     protected void onRegistrationFailure(Throwable failure) {
         log.info("Failed to register at resource manager {}.", getTargetAddress(), failure);
@@ -108,7 +117,10 @@ public class TaskExecutorToResourceManagerConnection
 
     private static class ResourceManagerRegistration
             extends RetryingRegistration<
-                    ResourceManagerId, ResourceManagerGateway, TaskExecutorRegistrationSuccess> {
+                    ResourceManagerId,
+                    ResourceManagerGateway,
+                    TaskExecutorRegistrationSuccess,
+                    RegistrationResponse.Rejection> {
 
         private final TaskExecutorRegistration taskExecutorRegistration;
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RegisteredRpcConnectionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RegisteredRpcConnectionTest.java
index 20992be0a95..7373e862c72 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RegisteredRpcConnectionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RegisteredRpcConnectionTest.java
@@ -18,9 +18,11 @@
 
 package org.apache.flink.runtime.registration;
 
+import org.apache.flink.runtime.registration.RetryingRegistrationTest.TestRegistrationRejection;
 import org.apache.flink.runtime.registration.RetryingRegistrationTest.TestRegistrationSuccess;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.rpc.TestingRpcService;
+import org.apache.flink.types.Either;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.After;
@@ -33,9 +35,11 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 
+import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -79,7 +83,12 @@ public class RegisteredRpcConnectionTest extends TestLogger {
             connection.start();
 
             // wait for connection established
-            final String actualConnectionId = connection.getConnectionFuture().get();
+            final Either<TestRegistrationSuccess, TestRegistrationRejection> connectionResult =
+                    connection.getConnectionFuture().get();
+
+            assertTrue(connectionResult.isLeft());
+
+            final String actualConnectionId = connectionResult.left().getCorrelationId();
 
             // validate correct invocation and result
             assertTrue(connection.isConnected());
@@ -135,6 +144,39 @@ public class RegisteredRpcConnectionTest extends TestLogger {
         assertNull(connection.getTargetGateway());
     }
 
+    @Test
+    public void testRpcConnectionRejectionCallsOnRegistrationRejection() {
+        TestRegistrationGateway testRegistrationGateway =
+                DefaultTestRegistrationGateway.newBuilder()
+                        .setRegistrationFunction(
+                                (uuid, aLong) ->
+                                        CompletableFuture.completedFuture(
+                                                new TestRegistrationRejection(
+                                                        TestRegistrationRejection.RejectionReason
+                                                                .REJECTED)))
+                        .build();
+
+        rpcService.registerGateway(testRegistrationGateway.getAddress(), testRegistrationGateway);
+
+        TestRpcConnection connection =
+                new TestRpcConnection(
+                        testRegistrationGateway.getAddress(),
+                        UUID.randomUUID(),
+                        rpcService.getExecutor(),
+                        rpcService);
+        connection.start();
+
+        final Either<TestRegistrationSuccess, TestRegistrationRejection> connectionResult =
+                connection.getConnectionFuture().join();
+
+        assertTrue(connectionResult.isRight());
+        final TestRegistrationRejection registrationRejection = connectionResult.right();
+
+        assertThat(
+                registrationRejection.getRejectionReason(),
+                is(TestRegistrationRejection.RejectionReason.REJECTED));
+    }
+
     @Test
     public void testRpcConnectionClose() throws Exception {
         final String testRpcConnectionEndpointAddress = "<TestRpcConnectionEndpointAddress>";
@@ -188,13 +230,23 @@ public class RegisteredRpcConnectionTest extends TestLogger {
                         rpcService);
         connection.start();
 
-        final String actualConnectionId1 = connection.getConnectionFuture().get();
+        final Either<TestRegistrationSuccess, TestRegistrationRejection> firstConnectionResult =
+                connection.getConnectionFuture().get();
+
+        assertTrue(firstConnectionResult.isLeft());
+
+        final String actualConnectionId1 = firstConnectionResult.left().getCorrelationId();
 
         assertEquals(actualConnectionId1, connectionId1);
 
         assertTrue(connection.tryReconnect());
 
-        final String actualConnectionId2 = connection.getConnectionFuture().get();
+        final Either<TestRegistrationSuccess, TestRegistrationRejection> secondConnectionResult =
+                connection.getConnectionFuture().get();
+
+        assertTrue(secondConnectionResult.isLeft());
+
+        final String actualConnectionId2 = secondConnectionResult.left().getCorrelationId();
 
         assertEquals(actualConnectionId2, connectionId2);
     }
@@ -205,13 +257,17 @@ public class RegisteredRpcConnectionTest extends TestLogger {
 
     private static class TestRpcConnection
             extends RegisteredRpcConnection<
-                    UUID, TestRegistrationGateway, TestRegistrationSuccess> {
+                    UUID,
+                    TestRegistrationGateway,
+                    TestRegistrationSuccess,
+                    TestRegistrationRejection> {
 
         private final Object lock = new Object();
 
         private final RpcService rpcService;
 
-        private CompletableFuture<String> connectionFuture;
+        private CompletableFuture<Either<TestRegistrationSuccess, TestRegistrationRejection>>
+                connectionFuture;
 
         public TestRpcConnection(
                 String targetAddress,
@@ -231,7 +287,8 @@ public class RegisteredRpcConnectionTest extends TestLogger {
         protected RetryingRegistration<
                         UUID,
                         TestRegistrationGateway,
-                        RetryingRegistrationTest.TestRegistrationSuccess>
+                        RetryingRegistrationTest.TestRegistrationSuccess,
+                        RetryingRegistrationTest.TestRegistrationRejection>
                 generateRegistration() {
             return new RetryingRegistrationTest.TestRetryingRegistration(
                     rpcService, getTargetAddress(), getTargetLeaderId());
@@ -241,7 +298,14 @@ public class RegisteredRpcConnectionTest extends TestLogger {
         protected void onRegistrationSuccess(
                 RetryingRegistrationTest.TestRegistrationSuccess success) {
             synchronized (lock) {
-                connectionFuture.complete(success.getCorrelationId());
+                connectionFuture.complete(Either.Left(success));
+            }
+        }
+
+        @Override
+        protected void onRegistrationRejection(TestRegistrationRejection rejection) {
+            synchronized (lock) {
+                connectionFuture.complete(Either.Right(rejection));
             }
         }
 
@@ -261,7 +325,8 @@ public class RegisteredRpcConnectionTest extends TestLogger {
             return super.tryReconnect();
         }
 
-        public CompletableFuture<String> getConnectionFuture() {
+        public CompletableFuture<Either<TestRegistrationSuccess, TestRegistrationRejection>>
+                getConnectionFuture() {
             synchronized (lock) {
                 return connectionFuture;
             }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RetryingRegistrationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RetryingRegistrationTest.java
index 9a61ea01e10..8072b03508e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RetryingRegistrationTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/registration/RetryingRegistrationTest.java
@@ -18,11 +18,11 @@
 
 package org.apache.flink.runtime.registration;
 
-import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.rpc.TestingRpcService;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
+import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.After;
@@ -91,18 +91,25 @@ public class RetryingRegistrationTest extends TestLogger {
                     new TestRetryingRegistration(rpcService, testEndpointAddress, leaderId);
             registration.startRegistration();
 
-            CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future =
-                    registration.getFuture();
+            CompletableFuture<
+                            RetryingRegistration.RetryingRegistrationResult<
+                                    TestRegistrationGateway,
+                                    TestRegistrationSuccess,
+                                    TestRegistrationRejection>>
+                    future = registration.getFuture();
             assertNotNull(future);
 
             // multiple accesses return the same future
             assertEquals(future, registration.getFuture());
 
-            Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success =
-                    future.get(10L, TimeUnit.SECONDS);
+            RetryingRegistration.RetryingRegistrationResult<
+                            TestRegistrationGateway,
+                            TestRegistrationSuccess,
+                            TestRegistrationRejection>
+                    registrationResponse = future.get(10L, TimeUnit.SECONDS);
 
             // validate correct invocation and result
-            assertEquals(testId, success.f1.getCorrelationId());
+            assertEquals(testId, registrationResponse.getSuccess().getCorrelationId());
             assertEquals(leaderId, testGateway.getInvocations().take().leaderId());
         } finally {
             testGateway.stop();
@@ -173,8 +180,11 @@ public class RetryingRegistrationTest extends TestLogger {
 
             registration.startRegistration();
 
-            Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success =
-                    registration.getFuture().get(10L, TimeUnit.SECONDS);
+            RetryingRegistration.RetryingRegistrationResult<
+                            TestRegistrationGateway,
+                            TestRegistrationSuccess,
+                            TestRegistrationRejection>
+                    registrationResponse = registration.getFuture().get(10L, TimeUnit.SECONDS);
 
             // measure the duration of the registration --> should be longer than the error delay
             long duration = System.currentTimeMillis() - start;
@@ -184,7 +194,7 @@ public class RetryingRegistrationTest extends TestLogger {
                     duration > TestRetryingRegistration.DELAY_ON_ERROR);
 
             // validate correct invocation and result
-            assertEquals(testId, success.f1.getCorrelationId());
+            assertEquals(testId, registrationResponse.getSuccess().getCorrelationId());
             assertEquals(leaderId, testGateway.getInvocations().take().leaderId());
         } finally {
             testGateway.stop();
@@ -224,16 +234,23 @@ public class RetryingRegistrationTest extends TestLogger {
             long started = System.nanoTime();
             registration.startRegistration();
 
-            CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future =
-                    registration.getFuture();
-            Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success =
-                    future.get(10L, TimeUnit.SECONDS);
+            CompletableFuture<
+                            RetryingRegistration.RetryingRegistrationResult<
+                                    TestRegistrationGateway,
+                                    TestRegistrationSuccess,
+                                    TestRegistrationRejection>>
+                    future = registration.getFuture();
+            RetryingRegistration.RetryingRegistrationResult<
+                            TestRegistrationGateway,
+                            TestRegistrationSuccess,
+                            TestRegistrationRejection>
+                    registrationResponse = future.get(10L, TimeUnit.SECONDS);
 
             long finished = System.nanoTime();
             long elapsedMillis = (finished - started) / 1000000;
 
             // validate correct invocation and result
-            assertEquals(testId, success.f1.getCorrelationId());
+            assertEquals(testId, registrationResponse.getSuccess().getCorrelationId());
             assertEquals(leaderId, testGateway.getInvocations().take().leaderId());
 
             // validate that some retry-delay / back-off behavior happened
@@ -244,7 +261,7 @@ public class RetryingRegistrationTest extends TestLogger {
     }
 
     @Test
-    public void testDecline() throws Exception {
+    public void testFailure() throws Exception {
         final String testId = "qui a coupe le fromage";
         final String testEndpointAddress = "<test-address>";
         final UUID leaderId = UUID.randomUUID();
@@ -252,7 +269,7 @@ public class RetryingRegistrationTest extends TestLogger {
         ManualResponseTestRegistrationGateway testGateway =
                 new ManualResponseTestRegistrationGateway(
                         null, // timeout
-                        new RegistrationResponse.Decline("no reason "),
+                        new RegistrationResponse.Failure(new FlinkException("no reason")),
                         null, // timeout
                         new TestRegistrationSuccess(testId) // success
                         );
@@ -266,16 +283,23 @@ public class RetryingRegistrationTest extends TestLogger {
             long started = System.nanoTime();
             registration.startRegistration();
 
-            CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future =
-                    registration.getFuture();
-            Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success =
-                    future.get(10L, TimeUnit.SECONDS);
+            CompletableFuture<
+                            RetryingRegistration.RetryingRegistrationResult<
+                                    TestRegistrationGateway,
+                                    TestRegistrationSuccess,
+                                    TestRegistrationRejection>>
+                    future = registration.getFuture();
+            RetryingRegistration.RetryingRegistrationResult<
+                            TestRegistrationGateway,
+                            TestRegistrationSuccess,
+                            TestRegistrationRejection>
+                    registrationResponse = future.get(10L, TimeUnit.SECONDS);
 
             long finished = System.nanoTime();
             long elapsedMillis = (finished - started) / 1000000;
 
             // validate correct invocation and result
-            assertEquals(testId, success.f1.getCorrelationId());
+            assertEquals(testId, registrationResponse.getSuccess().getCorrelationId());
             assertEquals(leaderId, testGateway.getInvocations().take().leaderId());
 
             // validate that some retry-delay / back-off behavior happened
@@ -289,6 +313,31 @@ public class RetryingRegistrationTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testRegistrationRejection() {
+        final TestRegistrationGateway testRegistrationGateway =
+                new ManualResponseTestRegistrationGateway(
+                        new TestRegistrationRejection(
+                                TestRegistrationRejection.RejectionReason.REJECTED));
+
+        rpcService.registerGateway(testRegistrationGateway.getAddress(), testRegistrationGateway);
+
+        final TestRetryingRegistration testRetryingRegistration =
+                new TestRetryingRegistration(
+                        rpcService, testRegistrationGateway.getAddress(), UUID.randomUUID());
+
+        testRetryingRegistration.startRegistration();
+
+        final RetryingRegistration.RetryingRegistrationResult<
+                        TestRegistrationGateway, TestRegistrationSuccess, TestRegistrationRejection>
+                response = testRetryingRegistration.getFuture().join();
+
+        assertTrue(response.isRejection());
+        assertThat(
+                response.getRejection().getRejectionReason(),
+                is(TestRegistrationRejection.RejectionReason.REJECTED));
+    }
+
     @Test
     @SuppressWarnings("unchecked")
     public void testRetryOnError() throws Exception {
@@ -314,15 +363,20 @@ public class RetryingRegistrationTest extends TestLogger {
         long started = System.nanoTime();
         registration.startRegistration();
 
-        CompletableFuture<Tuple2<TestRegistrationGateway, TestRegistrationSuccess>> future =
-                registration.getFuture();
-        Tuple2<TestRegistrationGateway, TestRegistrationSuccess> success =
-                future.get(10, TimeUnit.SECONDS);
+        CompletableFuture<
+                        RetryingRegistration.RetryingRegistrationResult<
+                                TestRegistrationGateway,
+                                TestRegistrationSuccess,
+                                TestRegistrationRejection>>
+                future = registration.getFuture();
+        RetryingRegistration.RetryingRegistrationResult<
+                        TestRegistrationGateway, TestRegistrationSuccess, TestRegistrationRejection>
+                registrationResponse = future.get(10, TimeUnit.SECONDS);
 
         long finished = System.nanoTime();
         long elapsedMillis = (finished - started) / 1000000;
 
-        assertEquals(testId, success.f1.getCorrelationId());
+        assertEquals(testId, registrationResponse.getSuccess().getCorrelationId());
 
         // validate that some retry-delay / back-off behavior happened
         assertTrue(
@@ -379,8 +433,34 @@ public class RetryingRegistrationTest extends TestLogger {
         }
     }
 
+    static class TestRegistrationRejection extends RegistrationResponse.Rejection {
+
+        private final RejectionReason rejectionReason;
+
+        /**
+         * Creates a new rejection message.
+         *
+         * @param rejectionReason
+         */
+        public TestRegistrationRejection(RejectionReason rejectionReason) {
+            this.rejectionReason = rejectionReason;
+        }
+
+        public RejectionReason getRejectionReason() {
+            return rejectionReason;
+        }
+
+        enum RejectionReason {
+            REJECTED;
+        }
+    }
+
     static class TestRetryingRegistration
-            extends RetryingRegistration<UUID, TestRegistrationGateway, TestRegistrationSuccess> {
+            extends RetryingRegistration<
+                    UUID,
+                    TestRegistrationGateway,
+                    TestRegistrationSuccess,
+                    TestRegistrationRejection> {
 
         // we use shorter timeouts here to speed up the tests
         static final long INITIAL_TIMEOUT = 20;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java
index 77e87c319da..1639feb7fdf 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java
@@ -244,7 +244,7 @@ public class ResourceManagerJobMasterTest extends TestLogger {
                         jobMasterGateway.getAddress(),
                         jobId,
                         TIMEOUT);
-        assertTrue(unMatchedLeaderFuture.get() instanceof RegistrationResponse.Decline);
+        assertTrue(unMatchedLeaderFuture.get() instanceof RegistrationResponse.Failure);
     }
 
     /** Test receive registration with invalid address from job master. */
@@ -262,7 +262,7 @@ public class ResourceManagerJobMasterTest extends TestLogger {
                         TIMEOUT);
         assertTrue(
                 invalidAddressFuture.get(5, TimeUnit.SECONDS)
-                        instanceof RegistrationResponse.Decline);
+                        instanceof RegistrationResponse.Failure);
     }
 
     /**
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java
index 9ddd06eb766..cd2b2d0e6b0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java
@@ -390,7 +390,7 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
                 registerTaskExecutor(rmGateway, invalidAddress);
         assertTrue(
                 invalidAddressFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS)
-                        instanceof RegistrationResponse.Decline);
+                        instanceof RegistrationResponse.Failure);
     }
 
     private CompletableFuture<RegistrationResponse> registerTaskExecutor(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
index 14fe8829d6a..5b46b9adf7c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
@@ -689,7 +689,7 @@ public class ActiveResourceManagerTest extends TestLogger {
                                     registerTaskExecutor(ResourceID.generate());
                             assertThat(
                                     registerTaskExecutorFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),
-                                    instanceOf(RegistrationResponse.Decline.class));
+                                    instanceOf(RegistrationResponse.Failure.class));
                         });
             }
         };
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
index 7211a72ec10..f45acdc3cca 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
@@ -72,7 +72,7 @@ import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.runtime.query.KvStateRegistry;
 import org.apache.flink.runtime.registration.RegistrationResponse;
-import org.apache.flink.runtime.registration.RegistrationResponse.Decline;
+import org.apache.flink.runtime.registration.RegistrationResponse.Failure;
 import org.apache.flink.runtime.registration.RetryingRegistrationConfiguration;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerId;
 import org.apache.flink.runtime.resourcemanager.TaskExecutorRegistration;
@@ -1353,7 +1353,9 @@ public class TaskExecutorTest extends TestLogger {
                         } else {
                             secondRegistration.trigger();
                             return CompletableFuture.completedFuture(
-                                    new Decline("Only the first registration should succeed."));
+                                    new Failure(
+                                            new FlinkException(
+                                                    "Only the first registration should succeed.")));
                         }
                     });
             rpc.registerGateway(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnectionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnectionTest.java
index 038af408c86..998d44a4113 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnectionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToResourceManagerConnectionTest.java
@@ -156,7 +156,7 @@ public class TaskExecutorToResourceManagerConnectionTest extends TestLogger {
     }
 
     private class TestRegistrationConnectionListener<
-                    T extends RegisteredRpcConnection<?, ?, S>,
+                    T extends RegisteredRpcConnection<?, ?, S, ?>,
                     S extends RegistrationResponse.Success>
             implements RegistrationConnectionListener<T, S> {
 
