diff --git a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java
index 6fd491082d5..992acbbd529 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java
@@ -18,8 +18,8 @@
 
 package org.apache.flink.test.streaming.runtime;
 
-import org.apache.flink.configuration.ExecutionOptions;
 import org.apache.flink.core.execution.JobClient;
+import org.apache.flink.runtime.io.network.api.writer.RecordWriter;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
 import org.apache.flink.streaming.api.functions.sink.SinkFunction;
@@ -28,14 +28,12 @@ import org.apache.flink.test.util.AbstractTestBase;
 import org.apache.flink.testutils.junit.SharedObjects;
 import org.apache.flink.testutils.junit.SharedReference;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
 import java.util.ArrayList;
 
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertTrue;
 
 /** Tests for {@link StreamExecutionEnvironment#setBufferTimeout(long)}. */
 public class BufferTimeoutITCase extends AbstractTestBase {
@@ -43,12 +41,10 @@ public class BufferTimeoutITCase extends AbstractTestBase {
     @Rule public final SharedObjects sharedObjects = SharedObjects.create();
 
     /**
-     * The test verifies that it is possible to disable buffer flushing. It emits a single record,
-     * which should not fill an entire buffer, thus it should not never reach the sink. We check the
-     * sink has not seen any records after 2 times the default buffer timeout.
+     * The test verifies that it is possible to disable explicit buffer flushing. It checks that
+     * OutputFlasher thread would not be started when the task is running. But this doesn't
+     * guarantee that the unfinished buffers can not be flushed by another events.
      */
-    // TODO: should be fixed in FLINK-24800.
-    @Ignore
     @Test
     public void testDisablingBufferTimeout() throws Exception {
         final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
@@ -74,7 +70,7 @@ public class BufferTimeoutITCase extends AbstractTestBase {
                         new SinkFunction<Integer>() {
 
                             @Override
-                            public void invoke(Integer value, Context context) throws Exception {
+                            public void invoke(Integer value, Context context) {
                                 results.get().add(value);
                             }
                         })
@@ -84,7 +80,14 @@ public class BufferTimeoutITCase extends AbstractTestBase {
         CommonTestUtils.waitForAllTaskRunning(
                 miniClusterResource.getMiniCluster(), jobClient.getJobID(), false);
 
-        Thread.sleep(2 * ExecutionOptions.BUFFER_TIMEOUT.defaultValue().toMillis());
-        assertThat(results.get().size(), equalTo(0));
+        assertTrue(
+                RecordWriter.DEFAULT_OUTPUT_FLUSH_THREAD_NAME + " thread is unexpectedly running",
+                Thread.getAllStackTraces().keySet().stream()
+                        .noneMatch(
+                                thread ->
+                                        thread.getName()
+                                                .startsWith(
+                                                        RecordWriter
+                                                                .DEFAULT_OUTPUT_FLUSH_THREAD_NAME)));
     }
 }
