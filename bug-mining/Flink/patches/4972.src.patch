diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java
index 2a922a84c19..f9f70a75854 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java
@@ -32,7 +32,6 @@ import org.apache.flink.runtime.io.network.api.serialization.RecordDeserializer.
 import org.apache.flink.runtime.io.network.api.serialization.SpillingAdaptiveSpanningRecordDeserializer;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
-import org.apache.flink.runtime.io.network.partition.consumer.InputChannel;
 import org.apache.flink.runtime.plugable.DeserializationDelegate;
 import org.apache.flink.runtime.plugable.NonReusingDeserializationDelegate;
 import org.apache.flink.streaming.api.watermark.Watermark;
@@ -40,16 +39,17 @@ import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;
 import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
-
-import javax.annotation.Nonnull;
+import org.apache.flink.util.Preconditions;
 
 import java.io.IOException;
 import java.util.HashMap;
-import java.util.List;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.toMap;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
 
@@ -73,21 +73,20 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
 
     private final DeserializationDelegate<StreamElement> deserializationDelegate;
 
-    private final RecordDeserializer<DeserializationDelegate<StreamElement>>[] recordDeserializers;
+    private final Map<InputChannelInfo, RecordDeserializer<DeserializationDelegate<StreamElement>>>
+            recordDeserializers;
+    private final Map<InputChannelInfo, Integer> flattenedChannelIndices;
 
     /** Valve that controls how watermarks and stream statuses are forwarded. */
     private final StatusWatermarkValve statusWatermarkValve;
 
     private final int inputIndex;
 
-    private final Map<InputChannelInfo, Integer> channelIndexes;
-
-    private int lastChannel = UNSPECIFIED;
+    private InputChannelInfo lastChannel = null;
 
     private RecordDeserializer<DeserializationDelegate<StreamElement>> currentRecordDeserializer =
             null;
 
-    @SuppressWarnings("unchecked")
     public StreamTaskNetworkInput(
             CheckpointedInputGate checkpointedInputGate,
             TypeSerializer<?> inputSerializer,
@@ -101,29 +100,21 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
 
         // Initialize one deserializer per input channel
         this.recordDeserializers =
-                new SpillingAdaptiveSpanningRecordDeserializer
-                        [checkpointedInputGate.getNumberOfInputChannels()];
-        for (int i = 0; i < recordDeserializers.length; i++) {
-            recordDeserializers[i] =
-                    new SpillingAdaptiveSpanningRecordDeserializer<>(
-                            ioManager.getSpillingDirectoriesPaths());
+                checkpointedInputGate.getChannelInfos().stream()
+                        .collect(
+                                toMap(
+                                        identity(),
+                                        unused ->
+                                                new SpillingAdaptiveSpanningRecordDeserializer<>(
+                                                        ioManager.getSpillingDirectoriesPaths())));
+
+        this.flattenedChannelIndices = new HashMap<>();
+        for (InputChannelInfo i : checkpointedInputGate.getChannelInfos()) {
+            flattenedChannelIndices.put(i, flattenedChannelIndices.size());
         }
 
         this.statusWatermarkValve = checkNotNull(statusWatermarkValve);
         this.inputIndex = inputIndex;
-        this.channelIndexes = getChannelIndexes(checkpointedInputGate);
-    }
-
-    @Nonnull
-    private static Map<InputChannelInfo, Integer> getChannelIndexes(
-            CheckpointedInputGate checkpointedInputGate) {
-        int index = 0;
-        List<InputChannelInfo> channelInfos = checkpointedInputGate.getChannelInfos();
-        Map<InputChannelInfo, Integer> channelIndexes = new HashMap<>(channelInfos.size());
-        for (InputChannelInfo channelInfo : channelInfos) {
-            channelIndexes.put(channelInfo, index++);
-        }
-        return channelIndexes;
     }
 
     @VisibleForTesting
@@ -133,15 +124,32 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
             StatusWatermarkValve statusWatermarkValve,
             int inputIndex,
             RecordDeserializer<DeserializationDelegate<StreamElement>>[] recordDeserializers) {
+        Preconditions.checkArgument(
+                checkpointedInputGate.getChannelInfos().stream()
+                                .map(InputChannelInfo::getGateIdx)
+                                .distinct()
+                                .count()
+                        <= 1);
+        Preconditions.checkArgument(
+                checkpointedInputGate.getNumberOfInputChannels() == recordDeserializers.length);
 
         this.checkpointedInputGate = checkpointedInputGate;
         this.deserializationDelegate =
                 new NonReusingDeserializationDelegate<>(
                         new StreamElementSerializer<>(inputSerializer));
-        this.recordDeserializers = recordDeserializers;
+        this.recordDeserializers =
+                checkpointedInputGate.getChannelInfos().stream()
+                        .collect(
+                                toMap(
+                                        identity(),
+                                        info -> recordDeserializers[info.getInputChannelIdx()]));
+        this.flattenedChannelIndices = new HashMap<>();
+        for (InputChannelInfo i : checkpointedInputGate.getChannelInfos()) {
+            flattenedChannelIndices.put(i, flattenedChannelIndices.size());
+        }
+
         this.statusWatermarkValve = statusWatermarkValve;
         this.inputIndex = inputIndex;
-        this.channelIndexes = getChannelIndexes(checkpointedInputGate);
     }
 
     @Override
@@ -155,7 +163,7 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
                     result = currentRecordDeserializer.getNextRecord(deserializationDelegate);
                 } catch (IOException e) {
                     throw new IOException(
-                            String.format("Can't get next record for channel %d", lastChannel), e);
+                            String.format("Can't get next record for channel %s", lastChannel), e);
                 }
                 if (result.isBufferConsumed()) {
                     currentRecordDeserializer.getCurrentBuffer().recycleBuffer();
@@ -195,12 +203,15 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
         if (recordOrMark.isRecord()) {
             output.emitRecord(recordOrMark.asRecord());
         } else if (recordOrMark.isWatermark()) {
-            statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), lastChannel, output);
+            statusWatermarkValve.inputWatermark(
+                    recordOrMark.asWatermark(), flattenedChannelIndices.get(lastChannel), output);
         } else if (recordOrMark.isLatencyMarker()) {
             output.emitLatencyMarker(recordOrMark.asLatencyMarker());
         } else if (recordOrMark.isStreamStatus()) {
             statusWatermarkValve.inputStreamStatus(
-                    recordOrMark.asStreamStatus(), lastChannel, output);
+                    recordOrMark.asStreamStatus(),
+                    flattenedChannelIndices.get(lastChannel),
+                    output);
         } else {
             throw new UnsupportedOperationException("Unknown type of StreamElement");
         }
@@ -214,14 +225,14 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
         if (event.getClass() == EndOfPartitionEvent.class) {
             // release the record deserializer immediately,
             // which is very valuable in case of bounded stream
-            releaseDeserializer(channelIndexes.get(bufferOrEvent.getChannelInfo()));
+            releaseDeserializer(bufferOrEvent.getChannelInfo());
         }
     }
 
     private void processBuffer(BufferOrEvent bufferOrEvent) throws IOException {
-        lastChannel = channelIndexes.get(bufferOrEvent.getChannelInfo());
-        checkState(lastChannel != StreamTaskInput.UNSPECIFIED);
-        currentRecordDeserializer = recordDeserializers[lastChannel];
+        lastChannel = bufferOrEvent.getChannelInfo();
+        checkState(lastChannel != null);
+        currentRecordDeserializer = recordDeserializers.get(lastChannel);
         checkState(
                 currentRecordDeserializer != null,
                 "currentRecordDeserializer has already been released");
@@ -245,17 +256,14 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
     @Override
     public CompletableFuture<Void> prepareSnapshot(
             ChannelStateWriter channelStateWriter, long checkpointId) throws IOException {
-        for (int channelIndex = 0; channelIndex < recordDeserializers.length; channelIndex++) {
-            RecordDeserializer<?> deserializer = recordDeserializers[channelIndex];
-            if (deserializer != null) {
-                final InputChannel channel = checkpointedInputGate.getChannel(channelIndex);
-
-                channelStateWriter.addInputData(
-                        checkpointId,
-                        channel.getChannelInfo(),
-                        ChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,
-                        deserializer.getUnconsumedBuffer());
-            }
+        for (Map.Entry<InputChannelInfo, RecordDeserializer<DeserializationDelegate<StreamElement>>>
+                e : recordDeserializers.entrySet()) {
+
+            channelStateWriter.addInputData(
+                    checkpointId,
+                    e.getKey(),
+                    ChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,
+                    e.getValue().getUnconsumedBuffer());
         }
         return checkpointedInputGate.getAllBarriersReceivedFuture(checkpointId);
     }
@@ -263,16 +271,16 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
     @Override
     public void close() throws IOException {
         // release the deserializers . this part should not ever fail
-        for (int channelIndex = 0; channelIndex < recordDeserializers.length; channelIndex++) {
-            releaseDeserializer(channelIndex);
+        for (InputChannelInfo channelInfo : new HashSet<>(recordDeserializers.keySet())) {
+            releaseDeserializer(channelInfo);
         }
 
         // cleanup the resources of the checkpointed input gate
         checkpointedInputGate.close();
     }
 
-    private void releaseDeserializer(int channelIndex) {
-        RecordDeserializer<?> deserializer = recordDeserializers[channelIndex];
+    private void releaseDeserializer(InputChannelInfo channelInfo) {
+        RecordDeserializer<?> deserializer = recordDeserializers.get(channelInfo);
         if (deserializer != null) {
             // recycle buffers and clear the deserializer.
             Buffer buffer = deserializer.getCurrentBuffer();
@@ -281,7 +289,7 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
             }
             deserializer.clear();
 
-            recordDeserializers[channelIndex] = null;
+            recordDeserializers.remove(channelInfo);
         }
     }
 }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
index ee094b135b2..20a4a6c406f 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
@@ -65,7 +65,6 @@ import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
@@ -164,7 +163,6 @@ public class StreamTaskNetworkInputTest {
         // send EndOfPartitionEvent and ensure that deserializer has been released
         inputGate.sendEvent(EndOfPartitionEvent.INSTANCE, channelId);
         input.emitNext(output);
-        assertNull(deserializers[channelId]);
 
         // now snapshot all inflight buffers
         CompletableFuture<Void> completableFuture =
@@ -203,7 +201,6 @@ public class StreamTaskNetworkInputTest {
             assertNotNull(deserializers[i]);
             inputGate.sendEvent(EndOfPartitionEvent.INSTANCE, i);
             input.emitNext(output);
-            assertNull(deserializers[i]);
             assertTrue(copiedDeserializers[i].isCleared());
         }
     }
