diff --git a/flink-queryable-state/flink-queryable-state-client-java/src/main/java/org/apache/flink/queryablestate/client/QueryableStateClient.java b/flink-queryable-state/flink-queryable-state-client-java/src/main/java/org/apache/flink/queryablestate/client/QueryableStateClient.java
index b2c3b37fc4e..8bf601f0a2a 100644
--- a/flink-queryable-state/flink-queryable-state-client-java/src/main/java/org/apache/flink/queryablestate/client/QueryableStateClient.java
+++ b/flink-queryable-state/flink-queryable-state-client-java/src/main/java/org/apache/flink/queryablestate/client/QueryableStateClient.java
@@ -45,6 +45,7 @@ import org.apache.flink.queryablestate.network.Client;
 import org.apache.flink.queryablestate.network.messages.MessageSerializer;
 import org.apache.flink.queryablestate.network.stats.DisabledKvStateRequestStats;
 import org.apache.flink.util.FlinkRuntimeException;
+import org.apache.flink.util.LambdaUtil;
 import org.apache.flink.util.NetUtils;
 import org.apache.flink.util.Preconditions;
 
@@ -292,8 +293,13 @@ public class QueryableStateClient {
             return FutureUtils.getFailedFuture(e);
         }
 
+        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
         return getKvState(jobId, queryableStateName, key.hashCode(), serializedKeyAndNamespace)
-                .thenApply(stateResponse -> createState(stateResponse, stateDescriptor));
+                .thenApply(
+                        stateResponse ->
+                                LambdaUtil.withContextClassLoader(
+                                        contextLoader,
+                                        () -> createState(stateResponse, stateDescriptor)));
     }
 
     private <T, S extends State> S createState(
diff --git a/flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/itcases/AbstractQueryableStateTestBase.java b/flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/itcases/AbstractQueryableStateTestBase.java
index 63fedfa1638..7c15a22e63c 100644
--- a/flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/itcases/AbstractQueryableStateTestBase.java
+++ b/flink-queryable-state/flink-queryable-state-runtime/src/test/java/org/apache/flink/queryablestate/itcases/AbstractQueryableStateTestBase.java
@@ -393,7 +393,10 @@ public abstract class AbstractQueryableStateTestBase extends TestLogger {
         env.setRestartStrategy(RestartStrategies.fixedDelayRestart(Integer.MAX_VALUE, 1000L));
 
         // Custom serializer is not needed, it's used just to check if serialization works.
-        env.getConfig().addDefaultKryoSerializer(Byte.class, createSerializer(userClassLoader));
+        env.getConfig()
+                .addDefaultKryoSerializer(
+                        Byte.class,
+                        (Serializer<?> & Serializable) createSerializer(userClassLoader));
 
         // Here we *force* using Kryo, to check if custom serializers are handled correctly WRT
         // classloading
@@ -1386,6 +1389,7 @@ public abstract class AbstractQueryableStateTestBase extends TestLogger {
         if (!resultFuture.isDone()) {
             CompletableFuture<S> expected =
                     client.getKvState(jobId, queryName, key, keyTypeInfo, stateDescriptor);
+            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
             expected.whenCompleteAsync(
                     (result, throwable) -> {
                         if (throwable != null) {
@@ -1396,17 +1400,20 @@ public abstract class AbstractQueryableStateTestBase extends TestLogger {
                                                     instanceof UnknownKeyOrNamespaceException)) {
                                 resultFuture.completeExceptionally(throwable.getCause());
                             } else if (deadline.hasTimeLeft()) {
-                                getKvStateIgnoringCertainExceptions(
-                                        deadline,
-                                        resultFuture,
-                                        client,
-                                        jobId,
-                                        queryName,
-                                        key,
-                                        keyTypeInfo,
-                                        stateDescriptor,
-                                        failForUnknownKeyOrNamespace,
-                                        executor);
+                                LambdaUtil.withContextClassLoader(
+                                        contextLoader,
+                                        () ->
+                                                getKvStateIgnoringCertainExceptions(
+                                                        deadline,
+                                                        resultFuture,
+                                                        client,
+                                                        jobId,
+                                                        queryName,
+                                                        key,
+                                                        keyTypeInfo,
+                                                        stateDescriptor,
+                                                        failForUnknownKeyOrNamespace,
+                                                        executor));
                             }
                         } else {
                             resultFuture.complete(result);
