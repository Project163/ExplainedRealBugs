diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/JobManagerProfiler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/JobManagerProfiler.java
deleted file mode 100644
index 4c4a20e52cf..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/JobManagerProfiler.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling;
-
-import org.apache.flink.runtime.executiongraph.ExecutionGraph;
-import org.apache.flink.api.common.JobID;
-
-/**
- * This interface must be implemented by profiling components
- * for the job manager.
- * 
- */
-public interface JobManagerProfiler {
-
-	/**
-	 * Registers the given {@link ExecutionGraph} for profiling.
-	 * 
-	 * @param executionGraph
-	 *        the {@link ExecutionGraph} to register for profiling
-	 */
-	void registerProfilingJob(ExecutionGraph executionGraph);
-
-	/**
-	 * Unregisters the given {@link ExecutionGraph} from profiling. Calling this
-	 * method will also unregister all of the job's registered listeners.
-	 * 
-	 * @param executionGraph the {@link ExecutionGraph} to unregister.
-	 */
-	void unregisterProfilingJob(ExecutionGraph executionGraph);
-
-	/**
-	 * Registers the given {@link ProfilingListener} object to receive
-	 * profiling data for the job with the given job ID.
-	 * 
-	 * @param jobID
-	 *        the ID of the job to receive profiling data for
-	 * @param profilingListener
-	 *        the {@link ProfilingListener} object to register
-	 */
-	void registerForProfilingData(JobID jobID, ProfilingListener profilingListener);
-
-	/**
-	 * Unregisters the given {@link ProfilingListener} object from receiving
-	 * profiling data issued by the job manager's profiling component.
-	 * 
-	 * @param jobID
-	 *        the ID of the job the {@link ProfilingListener} object has originally been registered for
-	 * @param profilingListener
-	 *        the {@link ProfilingListener} object to unregister
-	 */
-	void unregisterFromProfilingData(JobID jobID, ProfilingListener profilingListener);
-
-	/**
-	 * Shuts done the job manager's profiling component
-	 * and stops all its internal processes.
-	 */
-	void shutdown();
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingException.java
deleted file mode 100644
index f3148d90be8..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingException.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling;
-
-/**
- * A profiling exception is thrown if an error occur during profiling execution.
- * 
- */
-public class ProfilingException extends Exception {
-
-	/**
-	 * Generated serialVersionUID.
-	 */
-	private static final long serialVersionUID = -3282996556813630561L;
-
-	/**
-	 * Constructs a new profiling exception with the given error message.
-	 * 
-	 * @param errorMsg
-	 *        The error message to be included in the exception.
-	 */
-	public ProfilingException(String errorMsg) {
-		super(errorMsg);
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingListener.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingListener.java
deleted file mode 100644
index b3116ed5d06..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingListener.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling;
-
-import org.apache.flink.runtime.profiling.types.ProfilingEvent;
-
-public interface ProfilingListener {
-
-	void processProfilingEvents(ProfilingEvent profilingEvent);
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingUtils.java
deleted file mode 100644
index 95211bea4fa..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/ProfilingUtils.java
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.net.InetAddress;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.flink.runtime.instance.InstanceConnectionInfo;
-import org.apache.flink.util.StringUtils;
-
-/**
- * This class contains utility functions to load and configure Nephele's
- * profiling component.
- * 
- */
-public class ProfilingUtils {
-
-	/**
-	 * The logging instance used to report problems.
-	 */
-	private static final Logger LOG = LoggerFactory.getLogger(ProfilingUtils.class);
-
-	/**
-	 * The key to check the job manager's profiling component should be enabled.
-	 */
-	public static final String ENABLE_PROFILING_KEY = "jobmanager.profiling.enable";
-
-	/**
-	 * The class name of the job manager's profiling component to load if progiling is enabled.
-	 */
-	public static final String JOBMANAGER_CLASSNAME_KEY = "jobmanager.profiling.classname";
-
-	/**
-	 * The class name of the task manager's profiling component to load if profiling is enabled.
-	 */
-	public static final String TASKMANAGER_CLASSNAME_KEY = "taskmanager.profiling.classname";
-
-	/**
-	 * The key to check whether job profiling should be enabled for a specific job.
-	 */
-	public static final String PROFILE_JOB_KEY = "job.profiling.enable";
-
-	/**
-	 * The key to check the port of the job manager's profiling RPC server.
-	 */
-	public static final String JOBMANAGER_RPC_PORT_KEY = "jobmanager.profiling.rpc.port";
-
-	/**
-	 * The default network port the job manager's profiling component starts its RPC server on.
-	 */
-	public static final int JOBMANAGER_DEFAULT_RPC_PORT = 6124;
-
-	/**
-	 * Key to interval in which a task manager is supposed to send profiling data to the job manager.
-	 */
-	public static final String TASKMANAGER_REPORTINTERVAL_KEY = "taskmanager.profiling.reportinterval";
-
-	/**
-	 * Default interval which the task manager uses to report profiling data to the job manager.
-	 */
-	public static final int DEFAULT_TASKMANAGER_REPORTINTERVAL = 2;
-
-	/**
-	 * Creates an instance of the job manager's profiling component.
-	 * 
-	 * @param profilerClassName
-	 *        the class name of the profiling component to load
-	 * @param jobManagerBindAddress
-	 *        the address the job manager's RPC server is bound to
-	 * @return an instance of the job manager profiling component or <code>null</code> if an error occurs
-	 */
-	@SuppressWarnings("unchecked")
-	public static JobManagerProfiler loadJobManagerProfiler(String profilerClassName, InetAddress jobManagerBindAddress) {
-
-		final Class<? extends JobManagerProfiler> profilerClass;
-		try {
-			profilerClass = (Class<? extends JobManagerProfiler>) Class.forName(profilerClassName);
-		} catch (ClassNotFoundException e) {
-			LOG.error("Cannot find class " + profilerClassName + ": " + StringUtils.stringifyException(e));
-			return null;
-		}
-
-		JobManagerProfiler profiler = null;
-		
-		try {
-			
-			final Constructor<JobManagerProfiler> constr = (Constructor<JobManagerProfiler>) profilerClass.getConstructor(InetAddress.class);
-			profiler = constr.newInstance(jobManagerBindAddress);
-		
-		} catch(InvocationTargetException e) {
-			LOG.error("Cannot create profiler: " + StringUtils.stringifyException(e));
-			return null;
-		} catch (NoSuchMethodException e) {
-			LOG.error("Cannot create profiler: " + StringUtils.stringifyException(e));
-			return null;
-		} catch (InstantiationException e) {
-			LOG.error("Cannot create profiler: " + StringUtils.stringifyException(e));
-			return null;
-		} catch (IllegalAccessException e) {
-			LOG.error("Cannot create profiler: " + StringUtils.stringifyException(e));
-			return null;
-		} catch (IllegalArgumentException e) {
-			LOG.error("Cannot create profiler: " + StringUtils.stringifyException(e));
-			return null;
-		}
-
-		return profiler;
-	}
-
-	/**
-	 * Creates an instance of the task manager's profiling component.
-	 * 
-	 * @param profilerClassName
-	 *        the class name of the profiling component to load
-	 * @return an instance of the task manager profiling component or <code>null</code> if an error occurs
-	 */
-	@SuppressWarnings("unchecked")
-	public static TaskManagerProfiler loadTaskManagerProfiler(String profilerClassName, InetAddress jobManagerAddress,
-			InstanceConnectionInfo instanceConnectionInfo) {
-
-		final Class<? extends TaskManagerProfiler> profilerClass;
-		try {
-			profilerClass = (Class<? extends TaskManagerProfiler>) Class.forName(profilerClassName);
-		} catch (ClassNotFoundException e) {
-			LOG.error("Cannot find class " + profilerClassName + ": " + StringUtils.stringifyException(e));
-			return null;
-		}
-
-		Constructor<? extends TaskManagerProfiler> constructor = null;
-		try {
-			constructor = profilerClass.getConstructor(InetAddress.class, InstanceConnectionInfo.class);
-		} catch (SecurityException e1) {
-			LOG.error("Security exception while retrieving constructor for class " + profilerClass.getCanonicalName()
-					+ ".", e1);
-			return null;
-		} catch (NoSuchMethodException e1) {
-			LOG.error("Class " + profilerClass.getCanonicalName() + " does not have a constructor taking a " +
-					"InetAddress and InstanceConnectionInfo parameter.", e1);
-			return null;
-		}
-
-		TaskManagerProfiler profiler = null;
-		try {
-			profiler = constructor.newInstance(jobManagerAddress, instanceConnectionInfo);
-		} catch (IllegalArgumentException e) {
-			LOG.error("IllegalArgumentException while creating object of class " + profilerClass.getCanonicalName() +
-							".", e);
-		} catch (InstantiationException e) {
-			LOG.error("Could not instantiate object of class " + profilerClass.getCanonicalName() + ".",e);
-		} catch (IllegalAccessException e) {
-			LOG.error("IllegalAccessException while creating object of class " + profilerClass.getCanonicalName() + ".",
-					e);
-		} catch (InvocationTargetException e) {
-			LOG.error("InvocationTargetException while creating object of class " + profilerClass.getCanonicalName() +
-							".", e);
-		}
-
-		return profiler;
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/TaskManagerProfiler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/TaskManagerProfiler.java
deleted file mode 100644
index 709a05c090a..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/TaskManagerProfiler.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling;
-
-import org.apache.flink.configuration.Configuration;
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.runtime.taskmanager.Task;
-
-/**
- * This interface must be implemented by profiling components
- * for the task manager manager.
- */
-public interface TaskManagerProfiler {
-
-	/**
-	 * Registers a {@link org.apache.flink.runtime.taskmanager.Task} object for profiling.
-	 * 
-	 * @param task
-	 *        task to be register a profiling listener for
-	 * @param jobConfiguration
-	 *        the job configuration sent with the task
-	 */
-	void registerTask(Task task, Configuration jobConfiguration);
-
-	/**
-	 * Unregisters all previously registered {@link org.apache.flink.runtime.taskmanager.Task}
-	 * objects for the vertex identified by the given ID.
-	 * 
-	 * @param id
-	 *        the ID of the vertex to unregister the
-	 *        {@link org.apache.flink.runtime.taskmanager.Task} objects for
-	 */
-	void unregisterTask(ExecutionAttemptID id);
-
-	/**
-	 * Shuts done the task manager's profiling component
-	 * and stops all its internal processes.
-	 */
-	void shutdown();
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/EnvironmentThreadSet.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/EnvironmentThreadSet.java
deleted file mode 100644
index d5ce1375520..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/EnvironmentThreadSet.java
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl;
-
-import java.lang.management.ThreadInfo;
-import java.lang.management.ThreadMXBean;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
-import org.apache.flink.runtime.profiling.impl.types.InternalExecutionVertexThreadProfilingData;
-
-public class EnvironmentThreadSet {
-
-	private static final long NANO_TO_MILLISECONDS = 1000 * 1000;
-
-	private static final long PERCENT = 100;
-
-	
-
-	private final Thread mainThread;
-
-	private final JobVertexID vertexId;
-	
-	private final int subtask;
-	
-	private final ExecutionAttemptID executionId;
-
-	private final Map<Thread, CPUUtilizationSnapshot> userThreads = new HashMap<Thread, CPUUtilizationSnapshot>();
-
-	private CPUUtilizationSnapshot mainThreadSnapshot;
-
-	
-	public EnvironmentThreadSet(ThreadMXBean tmx, Thread mainThread, JobVertexID vertexId, int subtask, ExecutionAttemptID executionId) {
-		this.mainThread = mainThread;
-		this.vertexId = vertexId;
-		this.subtask = subtask;
-		this.executionId = executionId;
-
-		this.mainThreadSnapshot = createCPUUtilizationSnapshot(tmx, mainThread, System.currentTimeMillis());
-	}
-
-	public Thread getMainThread() {
-		return this.mainThread;
-	}
-
-	public void addUserThread(ThreadMXBean tmx, Thread thread) {
-		synchronized (this.userThreads) {
-			this.userThreads.put(thread, createCPUUtilizationSnapshot(tmx, thread, System.currentTimeMillis()));
-		}
-	}
-
-	public void removeUserThread(Thread thread) {
-		synchronized (this.userThreads) {
-			this.userThreads.remove(thread);
-		}
-	}
-
-	public int getNumberOfUserThreads() {
-		synchronized (this.userThreads) {
-			return this.userThreads.size();
-		}
-	}
-
-	private CPUUtilizationSnapshot createCPUUtilizationSnapshot(ThreadMXBean tmx, Thread thread, long timestamp) {
-		final long threadId = thread.getId();
-
-		final ThreadInfo threadInfo = tmx.getThreadInfo(threadId);
-		if(threadInfo == null) {
-			return null;
-		}
-
-		return new CPUUtilizationSnapshot(timestamp,
-				tmx.getThreadCpuTime(threadId) / NANO_TO_MILLISECONDS,
-				tmx.getThreadUserTime(threadId) / NANO_TO_MILLISECONDS,
-				threadInfo.getWaitedTime(),
-				threadInfo.getBlockedTime());
-	}
-
-	public InternalExecutionVertexThreadProfilingData captureCPUUtilization(JobID jobID, ThreadMXBean tmx, long timestamp) {
-
-		synchronized (this.userThreads) {
-
-			// Calculate utilization for main thread first
-			final CPUUtilizationSnapshot newMainThreadSnapshot = createCPUUtilizationSnapshot(tmx, this.mainThread, timestamp);
-			if(newMainThreadSnapshot == null) {
-				return null;
-			}
-			
-			final long mainInterval = newMainThreadSnapshot.getTimestamp() - this.mainThreadSnapshot.getTimestamp();
-
-			if (mainInterval == 0) {
-				return null;
-			}
-
-			long cputime = newMainThreadSnapshot.getTotalCPUTime() - this.mainThreadSnapshot.getTotalCPUTime();
-			long usrtime = newMainThreadSnapshot.getTotalCPUUserTime() - this.mainThreadSnapshot.getTotalCPUUserTime();
-			long systime = cputime - usrtime;
-			long waitime = newMainThreadSnapshot.getTotalCPUWaitTime() - this.mainThreadSnapshot.getTotalCPUWaitTime();
-			long blktime = newMainThreadSnapshot.getTotalCPUBlockTime()
-				- this.mainThreadSnapshot.getTotalCPUBlockTime();
-
-			int sumUsrTime = (int) ((usrtime * PERCENT) / mainInterval);
-			int sumSysTime = (int) ((systime * PERCENT) / mainInterval);
-			int sumBlkTime = (int) ((blktime * PERCENT) / mainInterval);
-			int sumWaiTime = (int) ((waitime * PERCENT) / mainInterval);
-
-			// Update snapshot
-			this.mainThreadSnapshot = newMainThreadSnapshot;
-
-			if (!this.userThreads.isEmpty()) {
-
-				final Iterator<Thread> it = this.userThreads.keySet().iterator();
-				int divisor = this.userThreads.size();
-				while (it.hasNext()) {
-
-					final Thread userThread = it.next();
-					final CPUUtilizationSnapshot newUtilizationSnaphot = createCPUUtilizationSnapshot(tmx, userThread,
-						timestamp);
-					final CPUUtilizationSnapshot oldUtilizationSnapshot = this.userThreads.get(userThread);
-
-					long interval = newUtilizationSnaphot.getTimestamp() - oldUtilizationSnapshot.getTimestamp();
-
-					if (interval == 0) {
-						--divisor;
-						continue;
-					}
-
-					cputime = newUtilizationSnaphot.getTotalCPUTime() - oldUtilizationSnapshot.getTotalCPUTime();
-					usrtime = newUtilizationSnaphot.getTotalCPUUserTime() - oldUtilizationSnapshot.getTotalCPUUserTime();
-					systime = cputime - usrtime;
-					waitime = newUtilizationSnaphot.getTotalCPUWaitTime() - oldUtilizationSnapshot.getTotalCPUWaitTime();
-					blktime = newUtilizationSnaphot.getTotalCPUBlockTime() - oldUtilizationSnapshot.getTotalCPUBlockTime();
-
-					sumUsrTime += (int) ((usrtime * PERCENT) / interval);
-					sumSysTime += (int) ((systime * PERCENT) / interval);
-					sumBlkTime += (int) ((blktime * PERCENT) / interval);
-					sumWaiTime += (int) ((waitime * PERCENT) / interval);
-
-					// Update snapshot
-					this.userThreads.put(userThread, newUtilizationSnaphot);
-				}
-
-				sumUsrTime /= (divisor + 1);
-				sumSysTime /= (divisor + 1);
-				sumBlkTime /= (divisor + 1);
-				sumWaiTime /= (divisor + 1);
-			}
-
-			return new InternalExecutionVertexThreadProfilingData(jobID, this.vertexId, this.subtask, this.executionId,
-					(int) mainInterval, sumUsrTime, sumSysTime, sumBlkTime, sumWaiTime);
-		}
-	}
-	
-	// --------------------------------------------------------------------------------------------
-	
-	private class CPUUtilizationSnapshot {
-
-		private final long timestamp;
-
-		private final long totalCPUTime;
-
-		private final long totalCPUUserTime;
-
-		private final long totalCPUWaitTime;
-
-		private final long totalCPUBlockTime;
-
-		public CPUUtilizationSnapshot(long timestamp, long totalCPUTime, long totalCPUUserTime, long totalCPUWaitTime,
-				long totalCPUBlockTime) {
-			this.timestamp = timestamp;
-			this.totalCPUTime = totalCPUTime;
-			this.totalCPUUserTime = totalCPUUserTime;
-			this.totalCPUWaitTime = totalCPUWaitTime;
-			this.totalCPUBlockTime = totalCPUBlockTime;
-		}
-
-		public long getTimestamp() {
-			return this.timestamp;
-		}
-
-		public long getTotalCPUTime() {
-			return this.totalCPUTime;
-		}
-
-		public long getTotalCPUUserTime() {
-			return this.totalCPUUserTime;
-		}
-
-		public long getTotalCPUWaitTime() {
-			return this.totalCPUWaitTime;
-		}
-
-		public long getTotalCPUBlockTime() {
-			return this.totalCPUBlockTime;
-		}
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/InstanceProfiler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/InstanceProfiler.java
deleted file mode 100644
index d97301710cb..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/InstanceProfiler.java
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling.impl;
-
-import java.io.BufferedReader;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.flink.runtime.profiling.ProfilingException;
-import org.apache.flink.runtime.profiling.impl.types.InternalInstanceProfilingData;
-import org.apache.flink.util.StringUtils;
-
-public class InstanceProfiler {
-
-	static final String PROC_MEMINFO = "/proc/meminfo";
-
-	static final String PROC_STAT = "/proc/stat";
-
-	static final String PROC_NET_DEV = "/proc/net/dev";
-
-	private static final String LOOPBACK_INTERFACE_NAME = "lo";
-
-	private static final Pattern CPU_PATTERN = Pattern
-		.compile("^cpu\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+).+$");
-
-	private static final Pattern NETWORK_PATTERN = Pattern
-		.compile("^\\s*(\\w+):\\s*(\\d+)\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+(\\d+).+$");
-
-	private static final Pattern MEMORY_PATTERN = Pattern.compile("^\\w+:\\s*(\\d+)\\s+kB$");
-
-	private static final int PERCENT = 100;
-
-	private final String instancePath;
-
-	private long lastTimestamp = 0;
-
-	// CPU related variables
-	private long lastCpuUser = 0;
-
-	private long lastCpuNice = 0;
-
-	private long lastCpuSys = 0;
-
-	private long lastCpuIdle = 0;
-
-	private long lastCpuIOWait = 0;
-
-	private long lastCpuIrq = 0;
-
-	private long lastCpuSoftirq = 0;
-
-	// Network related variables
-	private long lastReceivedBytes = 0;
-
-	private long lastTramsmittedBytes = 0;
-
-	private long firstTimestamp;
-
-	public InstanceProfiler(String instancePath)
-																			throws ProfilingException {
-
-		this.instancePath = instancePath;
-		this.firstTimestamp = System.currentTimeMillis();
-		// Initialize counters by calling generateProfilingData once and ignore the return value
-		generateProfilingData(this.firstTimestamp);
-	}
-
-	public InternalInstanceProfilingData generateProfilingData(long timestamp) throws ProfilingException {
-
-		final long profilingInterval = timestamp - lastTimestamp;
-
-		final InternalInstanceProfilingData profilingData = new InternalInstanceProfilingData(
-			this.instancePath, (int) profilingInterval);
-
-		updateCPUUtilization(profilingData);
-		updateMemoryUtilization(profilingData);
-		updateNetworkUtilization(profilingData);
-
-		// Update timestamp
-		this.lastTimestamp = timestamp;
-
-		return profilingData;
-	}
-
-	private void updateMemoryUtilization(InternalInstanceProfilingData profilingData) throws ProfilingException {
-
-		BufferedReader in = null;
-
-		try {
-
-			in = new BufferedReader(new FileReader(PROC_MEMINFO));
-
-			long freeMemory = 0;
-			long totalMemory = 0;
-			long bufferedMemory = 0;
-			long cachedMemory = 0;
-			long cachedSwapMemory = 0;
-
-			int count = 0;
-			String output;
-			while ((output = in.readLine()) != null) {
-
-				switch (count) {
-				case 0: // Total memory
-					totalMemory = extractMemoryValue(output);
-					break;
-				case 1: // Free memory
-					freeMemory = extractMemoryValue(output);
-					break;
-				case 2: // Buffers
-					bufferedMemory = extractMemoryValue(output);
-					break;
-				case 3: // Cache
-					cachedMemory = extractMemoryValue(output);
-					break;
-				case 4:
-					cachedSwapMemory = extractMemoryValue(output);
-					break;
-				default:
-					break;
-				}
-
-				++count;
-			}
-
-			profilingData.setTotalMemory(totalMemory);
-			profilingData.setFreeMemory(freeMemory);
-			profilingData.setBufferedMemory(bufferedMemory);
-			profilingData.setCachedMemory(cachedMemory);
-			profilingData.setCachedSwapMemory(cachedSwapMemory);
-
-		} catch (IOException ioe) {
-			throw new ProfilingException("Error while reading network utilization: "
-				+ StringUtils.stringifyException(ioe));
-		} finally {
-			if (in != null) {
-				try {
-					in.close();
-				} catch (IOException e) {
-				}
-			}
-		}
-
-	}
-
-	private long extractMemoryValue(String line) throws ProfilingException {
-
-		final Matcher matcher = MEMORY_PATTERN.matcher(line);
-		if (!matcher.matches()) {
-			throw new ProfilingException("Cannot extract memory data for profiling from line " + line);
-		}
-
-		return Long.parseLong(matcher.group(1));
-	}
-
-	private void updateNetworkUtilization(InternalInstanceProfilingData profilingData) throws ProfilingException {
-
-		BufferedReader in = null;
-
-		try {
-
-			in = new BufferedReader(new FileReader(PROC_NET_DEV));
-
-			long receivedSum = 0;
-			long transmittedSum = 0;
-
-			String output;
-			while ((output = in.readLine()) != null) {
-				final Matcher networkMatcher = NETWORK_PATTERN.matcher(output);
-				if (!networkMatcher.matches()) {
-					continue;
-				}
-				/*
-				 * Extract information according to
-				 * http://linuxdevcenter.com/pub/a/linux/2000/11/16/LinuxAdmin.html
-				 */
-
-				if (LOOPBACK_INTERFACE_NAME.equals(networkMatcher.group(1))) {
-					continue;
-				}
-
-				receivedSum += Long.parseLong(networkMatcher.group(2));
-				transmittedSum += Long.parseLong(networkMatcher.group(3));
-			}
-
-			in.close();
-			in = null;
-
-			profilingData.setReceivedBytes(receivedSum - this.lastReceivedBytes);
-			profilingData.setTransmittedBytes(transmittedSum - this.lastTramsmittedBytes);
-
-			// Store values for next call
-			this.lastReceivedBytes = receivedSum;
-			this.lastTramsmittedBytes = transmittedSum;
-
-		} catch (IOException ioe) {
-			throw new ProfilingException("Error while reading network utilization: "
-				+ StringUtils.stringifyException(ioe));
-		} catch (NumberFormatException nfe) {
-			throw new ProfilingException("Error while reading network utilization: "
-				+ StringUtils.stringifyException(nfe));
-		} finally {
-			if (in != null) {
-				try {
-					in.close();
-				} catch (IOException e) {
-				}
-			}
-		}
-	}
-
-	private void updateCPUUtilization(InternalInstanceProfilingData profilingData) throws ProfilingException {
-
-		BufferedReader in = null;
-
-		try {
-
-			in = new BufferedReader(new FileReader(PROC_STAT));
-			final String output = in.readLine();
-			if (output == null) {
-				throw new ProfilingException("Cannot read CPU utilization, return value is null");
-			}
-
-			in.close();
-			in = null;
-
-			final Matcher cpuMatcher = CPU_PATTERN.matcher(output);
-			if (!cpuMatcher.matches()) {
-				throw new ProfilingException("Cannot extract CPU utilization from output \"" + output + "\"");
-			}
-
-			/*
-			 * Extract the information from the read line according to
-			 * http://www.linuxhowtos.org/System/procstat.htm
-			 */
-
-			final long cpuUser = Long.parseLong(cpuMatcher.group(1));
-			final long cpuNice = Long.parseLong(cpuMatcher.group(2));
-			final long cpuSys = Long.parseLong(cpuMatcher.group(3));
-			final long cpuIdle = Long.parseLong(cpuMatcher.group(4));
-			final long cpuIOWait = Long.parseLong(cpuMatcher.group(5));
-			final long cpuIrq = Long.parseLong(cpuMatcher.group(6));
-			final long cpuSoftirq = Long.parseLong(cpuMatcher.group(7));
-
-			// Calculate deltas
-			final long deltaCpuUser = cpuUser - this.lastCpuUser;
-			final long deltaCpuNice = cpuNice - this.lastCpuNice;
-			final long deltaCpuSys = cpuSys - this.lastCpuSys;
-			final long deltaCpuIdle = cpuIdle - this.lastCpuIdle;
-			final long deltaCpuIOWait = cpuIOWait - this.lastCpuIOWait;
-			final long deltaCpuIrq = cpuIrq - this.lastCpuIrq;
-			final long deltaCpuSoftirq = cpuSoftirq - this.lastCpuSoftirq;
-			final long deltaSum = deltaCpuUser + deltaCpuNice + deltaCpuSys + deltaCpuIdle + deltaCpuIOWait
-				+ deltaCpuIrq + deltaCpuSoftirq;
-
-			// TODO: Fix deltaSum = 0 situation
-
-			// Set the percentage values for the profiling data object
-			/*
-			 * profilingData.setIdleCPU((int)((deltaCpuIdle*PERCENT)/deltaSum));
-			 * profilingData.setUserCPU((int)((deltaCpuUser*PERCENT)/deltaSum));
-			 * profilingData.setSystemCPU((int)((deltaCpuSys*PERCENT)/deltaSum));
-			 * profilingData.setIoWaitCPU((int)((deltaCpuIOWait*PERCENT)/deltaSum));
-			 * profilingData.setHardIrqCPU((int)((deltaCpuIrq*PERCENT)/deltaSum));
-			 * profilingData.setSoftIrqCPU((int)((deltaCpuSoftirq*PERCENT)/deltaSum));
-			 */
-			// TODO: bad quick fix
-			if (deltaSum > 0) {
-				profilingData.setIdleCPU((int) ((deltaCpuIdle * PERCENT) / deltaSum));
-				profilingData.setUserCPU((int) ((deltaCpuUser * PERCENT) / deltaSum));
-				profilingData.setSystemCPU((int) ((deltaCpuSys * PERCENT) / deltaSum));
-				profilingData.setIoWaitCPU((int) ((deltaCpuIOWait * PERCENT) / deltaSum));
-				profilingData.setHardIrqCPU((int) ((deltaCpuIrq * PERCENT) / deltaSum));
-				profilingData.setSoftIrqCPU((int) ((deltaCpuSoftirq * PERCENT) / deltaSum));
-			} else {
-				profilingData.setIdleCPU((int) (deltaCpuIdle));
-				profilingData.setUserCPU((int) (deltaCpuUser));
-				profilingData.setSystemCPU((int) (deltaCpuSys));
-				profilingData.setIoWaitCPU((int) (deltaCpuIOWait));
-				profilingData.setHardIrqCPU((int) (deltaCpuIrq));
-				profilingData.setSoftIrqCPU((int) (deltaCpuSoftirq));
-			}
-			// Store values for next call
-			this.lastCpuUser = cpuUser;
-			this.lastCpuNice = cpuNice;
-			this.lastCpuSys = cpuSys;
-			this.lastCpuIdle = cpuIdle;
-			this.lastCpuIOWait = cpuIOWait;
-			this.lastCpuIrq = cpuIrq;
-			this.lastCpuSoftirq = cpuSoftirq;
-
-		} catch (IOException ioe) {
-			throw new ProfilingException("Error while reading CPU utilization: " + StringUtils.stringifyException(ioe));
-		} catch (NumberFormatException nfe) {
-			throw new ProfilingException("Error while reading CPU utilization: " + StringUtils.stringifyException(nfe));
-		} finally {
-			if (in != null) {
-				try {
-					in.close();
-				} catch (IOException e) {
-				}
-			}
-		}
-
-	}
-
-	/**
-	 * @return InternalInstanceProfilingData ProfilingData for the instance from execution-start to currentTime
-	 * @throws ProfilingException
-	 */
-	public InternalInstanceProfilingData generateCheckpointProfilingData() throws ProfilingException {
-		final long profilingInterval = System.currentTimeMillis() - this.firstTimestamp;
-
-		final InternalInstanceProfilingData profilingData = new InternalInstanceProfilingData(
-			this.instancePath, (int) profilingInterval);
-
-		updateCPUUtilization(profilingData);
-		updateMemoryUtilization(profilingData);
-		updateNetworkUtilization(profilingData);
-
-		return profilingData;
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/JobProfilingData.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/JobProfilingData.java
deleted file mode 100644
index ce7db251f12..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/JobProfilingData.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl;
-
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.flink.runtime.executiongraph.ExecutionGraph;
-import org.apache.flink.runtime.executiongraph.ExecutionVertex;
-import org.apache.flink.runtime.instance.Instance;
-import org.apache.flink.runtime.instance.SimpleSlot;
-import org.apache.flink.runtime.profiling.impl.types.InternalInstanceProfilingData;
-import org.apache.flink.runtime.profiling.types.InstanceSummaryProfilingEvent;
-
-public class JobProfilingData {
-
-	private final ExecutionGraph executionGraph;
-
-	private final long profilingStart;
-
-	private final Map<String, InternalInstanceProfilingData> collectedInstanceProfilingData = new
-			HashMap<String, InternalInstanceProfilingData>();
-
-	
-	public JobProfilingData(ExecutionGraph executionGraph) {
-		this.executionGraph = executionGraph;
-		this.profilingStart = System.currentTimeMillis();
-	}
-
-	
-	public long getProfilingStart() {
-		return this.profilingStart;
-	}
-
-	public ExecutionGraph getExecutionGraph() {
-		return this.executionGraph;
-	}
-
-	public boolean addIfInstanceIsAllocatedByJob(InternalInstanceProfilingData instanceProfilingData) {
-
-		for (ExecutionVertex executionVertex : this.executionGraph.getAllExecutionVertices()) {
-			SimpleSlot slot = executionVertex.getCurrentAssignedResource();
-			if (slot != null && slot.getInstance().getPath().equals(
-					instanceProfilingData.getInstancePath()))
-			{
-				this.collectedInstanceProfilingData.put(instanceProfilingData.getInstancePath(), instanceProfilingData);
-				return true;
-			}
-		}
-
-		return false;
-	}
-
-	public InstanceSummaryProfilingEvent getInstanceSummaryProfilingData(long timestamp) {
-
-		final Set<Instance> tempSet = new HashSet<Instance>();
-		
-		for (ExecutionVertex executionVertex : this.executionGraph.getAllExecutionVertices()) {
-			SimpleSlot slot = executionVertex.getCurrentAssignedResource();
-			if (slot != null) {
-				tempSet.add(slot.getInstance());
-			}
-		}
-
-		// Now compare the size of the collected data set and the allocated instance set.
-		// If their sizes are equal we can issue an instance summary.
-		if (tempSet.size() != this.collectedInstanceProfilingData.size()) {
-			return null;
-		}
-
-		return constructInstanceSummary(timestamp);
-	}
-
-	private InstanceSummaryProfilingEvent constructInstanceSummary(long timestamp) {
-
-		final int numberOfInstances = this.collectedInstanceProfilingData.size();
-		
-		final Iterator<String> instanceIterator = this.collectedInstanceProfilingData.keySet().iterator();
-
-		long freeMemorySum = 0;
-		long totalMemorySum = 0;
-		long bufferedMemorySum = 0;
-		long cachedMemorySum = 0;
-		long cachedSwapMemorySum = 0;
-
-		int ioWaitCPUSum = 0;
-		int idleCPUSum = 0;
-		int profilingIntervalSum = 0;
-		int systemCPUSum = 0;
-		int hardIrqCPUSum = 0;
-		int softIrqCPUSum = 0;
-
-		int userCPUSum = 0;
-		long receivedBytesSum = 0;
-		long transmittedBytesSum = 0;
-
-		// Sum up the individual values
-		while (instanceIterator.hasNext()) {
-
-			final InternalInstanceProfilingData profilingData = this.collectedInstanceProfilingData.get(instanceIterator.next());
-
-			freeMemorySum += profilingData.getFreeMemory();
-			ioWaitCPUSum += profilingData.getIOWaitCPU();
-			idleCPUSum += profilingData.getIdleCPU();
-			profilingIntervalSum += profilingData.getProfilingInterval();
-			systemCPUSum += profilingData.getSystemCPU();
-			hardIrqCPUSum += profilingData.getHardIrqCPU();
-			softIrqCPUSum += profilingData.getSoftIrqCPU();
-			totalMemorySum += profilingData.getTotalMemory();
-			userCPUSum += profilingData.getUserCPU();
-			receivedBytesSum += profilingData.getReceivedBytes();
-			transmittedBytesSum += profilingData.getTransmittedBytes();
-			bufferedMemorySum += profilingData.getBufferedMemory();
-			cachedMemorySum += profilingData.getCachedMemory();
-			cachedSwapMemorySum += profilingData.getCachedSwapMemory();
-		}
-
-		final InstanceSummaryProfilingEvent instanceSummary = new InstanceSummaryProfilingEvent(
-				profilingIntervalSum / numberOfInstances,
-				ioWaitCPUSum / numberOfInstances,
-				idleCPUSum / numberOfInstances,
-				userCPUSum / numberOfInstances,
-				systemCPUSum / numberOfInstances,
-				hardIrqCPUSum / numberOfInstances,
-				softIrqCPUSum / numberOfInstances,
-				totalMemorySum / numberOfInstances,
-				freeMemorySum / numberOfInstances,
-				bufferedMemorySum / numberOfInstances,
-				cachedMemorySum / numberOfInstances,
-				cachedSwapMemorySum / numberOfInstances,
-				receivedBytesSum / numberOfInstances,
-				transmittedBytesSum / numberOfInstances,
-				this.executionGraph.getJobID(), timestamp, (timestamp - this.profilingStart));
-
-		this.collectedInstanceProfilingData.clear();
-
-		return instanceSummary;
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalExecutionVertexProfilingData.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalExecutionVertexProfilingData.java
deleted file mode 100644
index 98ccfcfcac0..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalExecutionVertexProfilingData.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
-
-public abstract class InternalExecutionVertexProfilingData implements InternalProfilingData {
-
-	private final JobID jobId;
-	
-	private final JobVertexID vertexId;
-	
-	private int subtask;
-	
-	private final ExecutionAttemptID executionId;
-
-	
-	public InternalExecutionVertexProfilingData() {
-		this.jobId = new JobID();
-		this.vertexId = new JobVertexID();
-		this.executionId = new ExecutionAttemptID();
-		this.subtask = -1;
-	}
-
-	
-	public InternalExecutionVertexProfilingData(JobID jobId, JobVertexID vertexId, int subtask, ExecutionAttemptID executionId) {
-		this.jobId = jobId;
-		this.vertexId = vertexId;
-		this.subtask = subtask;
-		this.executionId = executionId;
-	}
-
-	// --------------------------------------------------------------------------------------------
-	
-	public JobID getJobID() {
-		return this.jobId;
-	}
-	
-	public JobVertexID getVertexId() {
-		return vertexId;
-	}
-	
-	public int getSubtask() {
-		return subtask;
-	}
-	
-	public ExecutionAttemptID getExecutionAttemptId() {
-		return this.executionId;
-	}
-	
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public void read(DataInputView in) throws IOException {
-		this.jobId.read(in);
-		this.vertexId.read(in);
-		this.executionId.read(in);
-		this.subtask = in.readInt();
-	}
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-		this.jobId.write(out);
-		this.vertexId.write(out);
-		this.executionId.write(out);
-		out.writeInt(this.subtask);
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalExecutionVertexThreadProfilingData.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalExecutionVertexThreadProfilingData.java
deleted file mode 100644
index 92ce916895d..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalExecutionVertexThreadProfilingData.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
-
-public class InternalExecutionVertexThreadProfilingData extends InternalExecutionVertexProfilingData {
-
-	private int profilingInterval = 0;
-
-	private int userTime = 0;
-
-	private int systemTime = 0;
-
-	private int blockedTime = 0;
-
-	private int waitedTime = 0;
-
-	public InternalExecutionVertexThreadProfilingData(JobID jobID, JobVertexID vertexId, int subtask, ExecutionAttemptID executionId,
-			int profilingInterval, int userTime, int systemTime, int blockedTime, int waitedTime)
-	{
-		super(jobID, vertexId, subtask, executionId);
-
-		this.profilingInterval = profilingInterval;
-		this.userTime = userTime;
-		this.systemTime = systemTime;
-		this.blockedTime = blockedTime;
-		this.waitedTime = waitedTime;
-	}
-
-	public InternalExecutionVertexThreadProfilingData() {}
-
-	@Override
-	public void read(DataInputView in) throws IOException {
-		super.read(in);
-
-		this.profilingInterval = in.readInt();
-		this.userTime = in.readInt();
-		this.systemTime = in.readInt();
-		this.blockedTime = in.readInt();
-		this.waitedTime = in.readInt();
-	}
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-		super.write(out);
-
-		out.writeInt(this.profilingInterval);
-		out.writeInt(this.userTime);
-		out.writeInt(this.systemTime);
-		out.writeInt(this.blockedTime);
-		out.writeInt(this.waitedTime);
-	}
-
-	public int getBlockedTime() {
-		return this.blockedTime;
-	}
-
-	public int getProfilingInterval() {
-		return this.profilingInterval;
-	}
-
-	public int getSystemTime() {
-		return this.systemTime;
-	}
-
-	public int getUserTime() {
-		return this.userTime;
-	}
-
-	public int getWaitedTime() {
-		return this.waitedTime;
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalInstanceProfilingData.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalInstanceProfilingData.java
deleted file mode 100644
index 145d11c4f6c..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalInstanceProfilingData.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-
-public class InternalInstanceProfilingData implements InternalProfilingData {
-
-	private String instancePath;
-
-	private int profilingInterval;
-
-	private int ioWaitCPU;
-
-	private int idleCPU;
-
-	private int userCPU;
-
-	private int systemCPU;
-
-	private int hardIrqCPU;
-
-	private int softIrqCPU;
-
-	private long totalMemory;
-
-	private long freeMemory;
-
-	private long bufferedMemory;
-
-	private long cachedMemory;
-
-	private long cachedSwapMemory;
-
-	private long receivedBytes;
-
-	private long transmittedBytes;
-
-	public InternalInstanceProfilingData() {
-		this.freeMemory = -1;
-		this.ioWaitCPU = -1;
-		this.idleCPU = -1;
-		this.instancePath = "";
-		this.profilingInterval = -1;
-		this.systemCPU = -1;
-		this.totalMemory = -1;
-		this.bufferedMemory = -1;
-		this.cachedMemory = -1;
-		this.cachedSwapMemory = -1;
-		this.userCPU = -1;
-		this.receivedBytes = -1;
-		this.transmittedBytes = -1;
-	}
-
-	public InternalInstanceProfilingData(String instancePath, int profilingInterval) {
-
-		this.instancePath = instancePath;
-		this.profilingInterval = profilingInterval;
-		this.freeMemory = -1;
-		this.ioWaitCPU = -1;
-		this.idleCPU = -1;
-		this.systemCPU = -1;
-		this.totalMemory = -1;
-		this.bufferedMemory = -1;
-		this.cachedMemory = -1;
-		this.cachedSwapMemory = -1;
-		this.userCPU = -1;
-		this.receivedBytes = -1;
-		this.transmittedBytes = -1;
-	}
-
-	public long getFreeMemory() {
-		return this.freeMemory;
-	}
-
-	public int getIOWaitCPU() {
-		return this.ioWaitCPU;
-	}
-
-	public int getIdleCPU() {
-		return this.idleCPU;
-	}
-
-	public int getHardIrqCPU() {
-		return this.hardIrqCPU;
-	}
-
-	public int getSoftIrqCPU() {
-		return this.softIrqCPU;
-	}
-
-	public String getInstancePath() {
-		return this.instancePath;
-	}
-
-	public int getProfilingInterval() {
-		return this.profilingInterval;
-	}
-
-	public int getSystemCPU() {
-		return this.systemCPU;
-	}
-
-	public long getTotalMemory() {
-		return this.totalMemory;
-	}
-
-	public long getBufferedMemory() {
-		return this.bufferedMemory;
-	}
-
-	public long getCachedMemory() {
-		return this.cachedMemory;
-	}
-
-	public long getCachedSwapMemory() {
-		return this.cachedSwapMemory;
-	}
-
-	public int getUserCPU() {
-		return this.userCPU;
-	}
-
-	public long getReceivedBytes() {
-		return this.receivedBytes;
-	}
-
-	public long getTransmittedBytes() {
-		return this.transmittedBytes;
-	}
-
-	@Override
-	public void read(DataInputView in) throws IOException {
-
-		this.freeMemory = in.readLong();
-		this.ioWaitCPU = in.readInt();
-		this.idleCPU = in.readInt();
-		this.instancePath = in.readUTF();
-		this.profilingInterval = in.readInt();
-		this.systemCPU = in.readInt();
-		this.totalMemory = in.readLong();
-		this.bufferedMemory = in.readLong();
-		this.cachedMemory = in.readLong();
-		this.cachedSwapMemory = in.readLong();
-		this.userCPU = in.readInt();
-		this.receivedBytes = in.readLong();
-		this.transmittedBytes = in.readLong();
-		this.hardIrqCPU = in.readInt();
-		this.softIrqCPU = in.readInt();
-
-	}
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-
-		out.writeLong(this.freeMemory);
-		out.writeInt(this.ioWaitCPU);
-		out.writeInt(this.idleCPU);
-		out.writeUTF(instancePath);
-		out.writeInt(this.profilingInterval);
-		out.writeInt(this.systemCPU);
-		out.writeLong(this.totalMemory);
-		out.writeLong(this.bufferedMemory);
-		out.writeLong(this.cachedMemory);
-		out.writeLong(this.cachedSwapMemory);
-		out.writeInt(this.userCPU);
-		out.writeLong(this.receivedBytes);
-		out.writeLong(this.transmittedBytes);
-		out.writeInt(this.hardIrqCPU);
-		out.writeInt(this.softIrqCPU);
-
-	}
-
-	public void setFreeMemory(long freeMemory) {
-		this.freeMemory = freeMemory;
-	}
-
-	public void setIoWaitCPU(int ioWaitCPU) {
-		this.ioWaitCPU = ioWaitCPU;
-	}
-
-	public void setIdleCPU(int idleCPU) {
-		this.idleCPU = idleCPU;
-	}
-
-	public void setSystemCPU(int systemCPU) {
-		this.systemCPU = systemCPU;
-	}
-
-	public void setHardIrqCPU(int hardIrqCPU) {
-		this.hardIrqCPU = hardIrqCPU;
-	}
-
-	public void setSoftIrqCPU(int softIrqCPU) {
-		this.softIrqCPU = softIrqCPU;
-	}
-
-	public void setTotalMemory(long totalMemory) {
-		this.totalMemory = totalMemory;
-	}
-
-	public void setBufferedMemory(long bufferedMemory) {
-		this.bufferedMemory = bufferedMemory;
-	}
-
-	public void setCachedMemory(long cachedMemory) {
-		this.cachedMemory = cachedMemory;
-	}
-
-	public void setCachedSwapMemory(long cachedSwapMemory) {
-		this.cachedSwapMemory = cachedSwapMemory;
-	}
-
-	public void setUserCPU(int userCPU) {
-		this.userCPU = userCPU;
-	}
-
-	public void setReceivedBytes(long receivedBytes) {
-		this.receivedBytes = receivedBytes;
-	}
-
-	public void setTransmittedBytes(long transmittedBytes) {
-		this.transmittedBytes = transmittedBytes;
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalProfilingData.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalProfilingData.java
deleted file mode 100644
index c6f53d1eac4..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/InternalProfilingData.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl.types;
-
-import org.apache.flink.core.io.IOReadableWritable;
-
-public interface InternalProfilingData extends IOReadableWritable {}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/ProfilingDataContainer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/ProfilingDataContainer.java
deleted file mode 100644
index b233b84b51e..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/impl/types/ProfilingDataContainer.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.impl.types;
-
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Iterator;
-import java.util.Queue;
-
-import org.apache.flink.core.io.IOReadableWritable;
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.util.StringUtils;
-
-public class ProfilingDataContainer implements IOReadableWritable {
-
-	private final Queue<InternalProfilingData> queuedProfilingData = new ArrayDeque<InternalProfilingData>();
-
-	public void addProfilingData(InternalProfilingData profilingData) {
-
-		if (profilingData == null) {
-			return;
-		}
-
-		this.queuedProfilingData.add(profilingData);
-	}
-
-	public void clear() {
-		this.queuedProfilingData.clear();
-	}
-
-	@SuppressWarnings("unchecked")
-	@Override
-	public void read(DataInputView in) throws IOException {
-
-		final int numberOfRecords = in.readInt();
-		for (int i = 0; i < numberOfRecords; i++) {
-			final String className = StringUtils.readNullableString(in);
-
-			Class<? extends InternalProfilingData> clazz;
-			try {
-				clazz = (Class<? extends InternalProfilingData>) Class.forName(className);
-			} catch (Exception e) {
-				throw new IOException(e);
-			}
-
-			InternalProfilingData profilingData ;
-			try {
-				profilingData = clazz.newInstance();
-			} catch (Exception e) {
-				throw new IOException(e);
-			}
-
-			// Restore internal state
-			profilingData.read(in);
-
-			this.queuedProfilingData.add(profilingData);
-		}
-	}
-
-	public int size() {
-		return this.queuedProfilingData.size();
-	}
-
-	public boolean isEmpty() {
-		return this.queuedProfilingData.isEmpty();
-	}
-
-	public Iterator<InternalProfilingData> getIterator() {
-		return this.queuedProfilingData.iterator();
-	}
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-
-		// Write the number of records
-		out.writeInt(this.queuedProfilingData.size());
-		// Write the records themselves
-		for (InternalProfilingData profilingData : this.queuedProfilingData) {
-			StringUtils.writeNullableString(profilingData.getClass().getName(), out);
-			profilingData.write(out);
-		}
-	}
-
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/InstanceProfilingEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/InstanceProfilingEvent.java
deleted file mode 100644
index 7de9252109e..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/InstanceProfilingEvent.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.api.common.JobID;
-
-/**
- * Instance profiling events are a special subclass of profiling events. They contain profiling information about the
- * utilization of a particular instance during a job execution.
- */
-public abstract class InstanceProfilingEvent extends ProfilingEvent {
-
-	private static final long serialVersionUID = 5964092674722506040L;
-
-	/**
-	 * The interval of time this profiling event covers in milliseconds.
-	 */
-	private int profilingInterval;
-
-	/**
-	 * The percentage of time the CPU(s) spent in state IOWAIT during the profiling interval.
-	 */
-	private int ioWaitCPU;
-
-	/**
-	 * The percentage of time the CPU(s) spent in state IDLE during the profiling interval.
-	 */
-	private int idleCPU;
-
-	/**
-	 * The percentage of time the CPU(s) spent in state USER during the profiling interval.
-	 */
-	private int userCPU;
-
-	/**
-	 * The percentage of time the CPU(s) spent in state SYSTEM during the profiling interval.
-	 */
-	private int systemCPU;
-
-	/**
-	 * The percentage of time the CPU(s) spent in state HARD_IRQ during the profiling interval.
-	 */
-	private int hardIrqCPU;
-
-	/**
-	 * The percentage of time the CPU(s) spent in state SOFT_IRQ during the profiling interval.
-	 */
-	private int softIrqCPU;
-
-	/**
-	 * The total amount of this instance's main memory in bytes.
-	 */
-	private long totalMemory;
-
-	/**
-	 * The free amount of this instance's main memory in bytes.
-	 */
-	private long freeMemory;
-
-	/**
-	 * The amount of main memory the instance uses for file buffers.
-	 */
-	private long bufferedMemory;
-
-	/**
-	 * The amount of main memory the instance uses as cache memory.
-	 */
-	private long cachedMemory;
-
-	/**
-	 * The amount of main memory the instance uses for cached swaps.
-	 */
-	private long cachedSwapMemory;
-
-	/**
-	 * The number of bytes received via network during the profiling interval.
-	 */
-	private long receivedBytes;
-
-	/**
-	 * The number of bytes transmitted via network during the profiling interval.
-	 */
-	private long transmittedBytes;
-
-	/**
-	 * Constructs a new instance profiling event.
-	 * 
-	 * @param profilingInterval
-	 *        the interval of time this profiling event covers in milliseconds
-	 * @param ioWaitCPU
-	 *        the percentage of time the CPU(s) spent in state IOWAIT during the profiling interval
-	 * @param idleCPU
-	 *        the percentage of time the CPU(s) spent in state IDLE during the profiling interval
-	 * @param userCPU
-	 *        the percentage of time the CPU(s) spent in state USER during the profiling interval
-	 * @param systemCPU
-	 *        the percentage of time the CPU(s) spent in state SYSTEM during the profiling interval
-	 * @param hardIrqCPU
-	 *        the percentage of time the CPU(s) spent in state HARD_IRQ during the profiling interval
-	 * @param softIrqCPU
-	 *        the percentage of time the CPU(s) spent in state SOFT_IRQ during the profiling interval
-	 * @param totalMemory
-	 *        the total amount of this instance's main memory in bytes
-	 * @param freeMemory
-	 *        the free amount of this instance's main memory in bytes
-	 * @param bufferedMemory
-	 *        the amount of main memory the instance uses for file buffers
-	 * @param cachedMemory
-	 *        the amount of main memory the instance uses as cache memory
-	 * @param cachedSwapMemory
-	 *        The amount of main memory the instance uses for cached swaps
-	 * @param receivedBytes
-	 *        the number of bytes received via network during the profiling interval
-	 * @param transmittedBytes
-	 *        the number of bytes transmitted via network during the profiling interval
-	 * @param jobID
-	 *        the ID of this job this profiling event belongs to
-	 * @param timestamp
-	 *        the time stamp of this profiling event's creation
-	 * @param profilingTimestamp
-	 *        the time stamp relative to the beginning of the job's execution
-	 */
-	public InstanceProfilingEvent(final int profilingInterval, final int ioWaitCPU, final int idleCPU,
-			final int userCPU, final int systemCPU, final int hardIrqCPU, final int softIrqCPU, final long totalMemory,
-			final long freeMemory, final long bufferedMemory, final long cachedMemory, final long cachedSwapMemory,
-			final long receivedBytes, final long transmittedBytes, final JobID jobID, final long timestamp,
-			final long profilingTimestamp) {
-
-		super(jobID, timestamp, profilingTimestamp);
-
-		this.profilingInterval = profilingInterval;
-
-		this.ioWaitCPU = ioWaitCPU;
-		this.idleCPU = idleCPU;
-		this.userCPU = userCPU;
-		this.systemCPU = systemCPU;
-		this.hardIrqCPU = hardIrqCPU;
-		this.softIrqCPU = softIrqCPU;
-
-		this.totalMemory = totalMemory;
-		this.freeMemory = freeMemory;
-		this.bufferedMemory = bufferedMemory;
-		this.cachedMemory = cachedMemory;
-		this.cachedSwapMemory = cachedSwapMemory;
-
-		this.receivedBytes = receivedBytes;
-		this.transmittedBytes = transmittedBytes;
-	}
-
-	/**
-	 * Default constructor for serialization/deserialization.
-	 */
-	public InstanceProfilingEvent() {
-		super();
-	}
-
-	// --------------------------------------------------------------------------------------------
-	
-	/**
-	 * Returns the interval of time this profiling event covers in milliseconds.
-	 * 
-	 * @return the interval of time this profiling event covers in milliseconds
-	 */
-	public final int getProfilingInterval() {
-		return this.profilingInterval;
-	}
-
-	/**
-	 * Returns the total amount of memory of the corresponding instance.
-	 * 
-	 * @return the total amount of memory in bytes
-	 */
-	public final long getTotalMemory() {
-		return this.totalMemory;
-	}
-
-	/**
-	 * Returns the amount of free memory of the corresponding instance.
-	 * 
-	 * @return the amount of free memory in bytes.
-	 */
-	public final long getFreeMemory() {
-		return this.freeMemory;
-	}
-
-	/**
-	 * Returns the amount of memory, in bytes, used for file buffers.
-	 * 
-	 * @return the amount of memory used for file buffers in bytes
-	 */
-	public final long getBufferedMemory() {
-		return this.bufferedMemory;
-	}
-
-	/**
-	 * Returns the amount of memory, in bytes, used as cache memory.
-	 * 
-	 * @return the amount of memory used as cache memory in bytes
-	 */
-	public final long getCachedMemory() {
-		return this.cachedMemory;
-	}
-
-	/**
-	 * Returns the amount of swap, in bytes, used as cache memory.
-	 * 
-	 * @return the amount of, in bytes, used as cache memory
-	 */
-	public final long getCachedSwapMemory() {
-		return this.cachedSwapMemory;
-	}
-
-	/**
-	 * Returns the percentage of time the CPU(s) spent in state USER during the profiling interval.
-	 * 
-	 * @return the percentage of time the CPU(s) spent in state USER during the profiling interval
-	 */
-	public final int getUserCPU() {
-		return this.userCPU;
-	}
-
-	/**
-	 * Returns the percentage of time the CPU(s) spent in state SYSTEM during the profiling interval.
-	 * 
-	 * @return the percentage of time the CPU(s) spent in state SYSTEM during the profiling interval
-	 */
-	public final int getSystemCPU() {
-		return this.systemCPU;
-	}
-
-	/**
-	 * Returns the percentage of time the CPU(s) spent in state IDLE during the profiling interval. Prior to Linux
-	 * 2.5.41, this includes IO-wait time.
-	 * 
-	 * @return the percentage of time the CPU(s) spent in state IDLE during the profiling interval
-	 */
-	public final int getIdleCPU() {
-		return this.idleCPU;
-	}
-
-	/**
-	 * Returns the percentage of time the CPU(s) spent in state IOWAIT during the profiling interval. Prior to Linux
-	 * 2.5.41, included in idle.
-	 * 
-	 * @return the percentage of time the CPU(s) spent in state IOWAIT during the profiling interval.
-	 */
-	public final int getIOWaitCPU() {
-		return this.ioWaitCPU;
-	}
-
-	/**
-	 * Returns the percentage of time the CPU(s) spent in state HARD_IRQ during the profiling interval.
-	 * 
-	 * @return the percentage of time the CPU(s) spent in state HARD_IRQ during the profiling interval
-	 */
-	public final int getHardIrqCPU() {
-		return this.hardIrqCPU;
-	}
-
-	/**
-	 * Returns the percentage of time the CPU(s) spent in state SOFT_IRQ during the profiling interval.
-	 * 
-	 * @return the percentage of time the CPU(s) spent in state SOFT_IRQ during the profiling interval
-	 */
-	public final int getSoftIrqCPU() {
-		return this.softIrqCPU;
-	}
-
-	/**
-	 * Returns the number of bytes received via network during the profiling interval.
-	 * 
-	 * @return the number of bytes received via network during the profiling interval
-	 */
-	public final long getReceivedBytes() {
-		return this.receivedBytes;
-	}
-
-	/**
-	 * Returns the number of bytes transmitted via network during the profiling interval.
-	 * 
-	 * @return the number of bytes transmitted via network during the profiling interval
-	 */
-	public final long getTransmittedBytes() {
-		return this.transmittedBytes;
-	}
-
-	// --------------------------------------------------------------------------------------------
-	//  Serialization
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public void read(final DataInputView in) throws IOException {
-		super.read(in);
-
-		this.profilingInterval = in.readInt();
-
-		this.ioWaitCPU = in.readInt();
-		this.idleCPU = in.readInt();
-		this.userCPU = in.readInt();
-		this.systemCPU = in.readInt();
-		this.hardIrqCPU = in.readInt();
-		this.softIrqCPU = in.readInt();
-
-		this.totalMemory = in.readLong();
-		this.freeMemory = in.readLong();
-		this.bufferedMemory = in.readLong();
-		this.cachedMemory = in.readLong();
-		this.cachedSwapMemory = in.readLong();
-
-		this.receivedBytes = in.readLong();
-		this.transmittedBytes = in.readLong();
-	}
-
-
-	@Override
-	public void write(final DataOutputView out) throws IOException {
-		super.write(out);
-
-		out.writeInt(this.profilingInterval);
-
-		out.writeInt(this.ioWaitCPU);
-		out.writeInt(this.idleCPU);
-		out.writeInt(this.userCPU);
-		out.writeInt(this.systemCPU);
-		out.writeInt(this.hardIrqCPU);
-		out.writeInt(this.softIrqCPU);
-
-		out.writeLong(totalMemory);
-		out.writeLong(freeMemory);
-		out.writeLong(bufferedMemory);
-		out.writeLong(cachedMemory);
-		out.writeLong(cachedSwapMemory);
-
-		out.writeLong(receivedBytes);
-		out.writeLong(transmittedBytes);
-	}
-
-
-	// --------------------------------------------------------------------------------------------
-	//  Utilities
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public boolean equals(final Object obj) {
-		if (obj instanceof InstanceProfilingEvent) {
-			final InstanceProfilingEvent other = (InstanceProfilingEvent) obj;
-			
-			return super.equals(obj) &&
-					profilingInterval == other.profilingInterval &&
-					ioWaitCPU == other.ioWaitCPU &&
-					idleCPU == other.idleCPU &&
-					userCPU == other.userCPU &&
-					systemCPU == other.systemCPU &&
-					hardIrqCPU == other.hardIrqCPU &&
-					softIrqCPU == other.softIrqCPU &&
-					totalMemory == other.totalMemory &&
-					freeMemory == other.freeMemory  &&
-					bufferedMemory == other.bufferedMemory &&
-					cachedMemory == other.cachedMemory &&
-					cachedSwapMemory == other.cachedSwapMemory &&
-					receivedBytes == other.receivedBytes &&
-					transmittedBytes == other.transmittedBytes;
-		}
-		else {
-			return false;
-		}
-	}
-
-
-	@Override
-	public int hashCode() {
-		long hashCode = getJobID().hashCode() + getTimestamp() + getProfilingTimestamp();
-		hashCode += this.profilingInterval + this.ioWaitCPU + this.idleCPU + this.userCPU + this.systemCPU
-			+ this.hardIrqCPU + this.softIrqCPU;
-		hashCode += (this.totalMemory + this.freeMemory + this.bufferedMemory + this.cachedMemory + this.cachedSwapMemory);
-		hashCode ^= hashCode >>> 32;
-		return (int) hashCode;
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/InstanceSummaryProfilingEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/InstanceSummaryProfilingEvent.java
deleted file mode 100644
index 4bb052df3a8..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/InstanceSummaryProfilingEvent.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.types;
-
-import org.apache.flink.api.common.JobID;
-
-/**
- * Instance summary profiling events summarize the profiling events of all instances involved in computing a job.
- */
-public final class InstanceSummaryProfilingEvent extends InstanceProfilingEvent {
-
-	private static final long serialVersionUID = 1L;
-
-	/**
-	 * Constructs a new instance summary profiling event.
-	 * 
-	 * @param profilingInterval
-	 *        the interval of time this profiling event covers in milliseconds
-	 * @param ioWaitCPU
-	 *        the percentage of time the CPU(s) spent in state IOWAIT during the profiling interval
-	 * @param idleCPU
-	 *        the percentage of time the CPU(s) spent in state IDLE during the profiling interval
-	 * @param userCPU
-	 *        the percentage of time the CPU(s) spent in state USER during the profiling interval
-	 * @param systemCPU
-	 *        the percentage of time the CPU(s) spent in state SYSTEM during the profiling interval
-	 * @param hardIrqCPU
-	 *        the percentage of time the CPU(s) spent in state HARD_IRQ during the profiling interval
-	 * @param softIrqCPU
-	 *        the percentage of time the CPU(s) spent in state SOFT_IRQ during the profiling interval
-	 * @param totalMemory
-	 *        the total amount of this instance's main memory in bytes
-	 * @param freeMemory
-	 *        the free amount of this instance's main memory in bytes
-	 * @param bufferedMemory
-	 *        the amount of main memory the instance uses for file buffers
-	 * @param cachedMemory
-	 *        the amount of main memory the instance uses as cache memory
-	 * @param cachedSwapMemory
-	 *        The amount of main memory the instance uses for cached swaps
-	 * @param receivedBytes
-	 *        the number of bytes received via network during the profiling interval
-	 * @param transmittedBytes
-	 *        the number of bytes transmitted via network during the profiling interval
-	 * @param jobID
-	 *        the ID of this job this profiling event belongs to
-	 * @param timestamp
-	 *        the time stamp of this profiling event's creation
-	 * @param profilingTimestamp
-	 *        the time stamp relative to the beginning of the job's execution
-	 */
-	public InstanceSummaryProfilingEvent(final int profilingInterval, final int ioWaitCPU, final int idleCPU,
-			final int userCPU, final int systemCPU, final int hardIrqCPU, final int softIrqCPU, final long totalMemory,
-			final long freeMemory, final long bufferedMemory, final long cachedMemory, final long cachedSwapMemory,
-			final long receivedBytes, final long transmittedBytes, final JobID jobID,
-			final long timestamp, final long profilingTimestamp) {
-		super(profilingInterval, ioWaitCPU, idleCPU, userCPU, systemCPU, hardIrqCPU, softIrqCPU, totalMemory,
-			freeMemory, bufferedMemory, cachedMemory, cachedSwapMemory, receivedBytes, transmittedBytes, jobID,
-			timestamp, profilingTimestamp);
-	}
-
-	/**
-	 * Default constructor for serialization/deserialization.
-	 */
-	public InstanceSummaryProfilingEvent() {
-		super();
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		return (obj instanceof InstanceSummaryProfilingEvent) && super.equals(obj);
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/ProfilingEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/ProfilingEvent.java
deleted file mode 100644
index 13a9a9968d1..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/ProfilingEvent.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.event.job.AbstractEvent;
-import org.apache.flink.api.common.JobID;
-
-import com.google.common.base.Preconditions;
-
-/**
- * A profiling event is a special type of event. It is intended to transport profiling data of a Nephele job to external
- * components.
- */
-public abstract class ProfilingEvent extends AbstractEvent {
-
-	private static final long serialVersionUID = 1L;
-
-	/** The ID of the job the profiling data belongs to. */
-	private final JobID jobID;
-
-	/** The profiling time stamp. */
-	private long profilingTimestamp;
-
-	/**
-	 * Constructs a new profiling event.
-	 * 
-	 * @param jobID
-	 *        the ID of the job this profiling events belongs to
-	 * @param timestamp
-	 *        the time stamp of the event
-	 * @param profilingTimestamp
-	 *        the time stamp of the profiling data
-	 */
-	public ProfilingEvent(JobID jobID, long timestamp, long profilingTimestamp) {
-		super(timestamp);
-
-		Preconditions.checkNotNull(jobID);
-		this.jobID = jobID;
-		this.profilingTimestamp = profilingTimestamp;
-	}
-
-	/**
-	 * Default constructor for serialization/deserialization.
-	 */
-	public ProfilingEvent() {
-		super();
-		this.jobID = new JobID();
-	}
-
-	// --------------------------------------------------------------------------------------------
-	
-	/**
-	 * Returns the ID of the job this profiling information belongs to.
-	 * 
-	 * @return the ID of the job this profiling information belongs to
-	 */
-	public JobID getJobID() {
-		return this.jobID;
-	}
-
-	/**
-	 * Returns the timestamp of this profiling information. The timestamp denotes
-	 * the time period in milliseconds between the creation of this profiling information
-	 * and the start of the corresponding vertex's execution.
-	 * 
-	 * @return the timestamp of this profiling information.
-	 */
-	public long getProfilingTimestamp() {
-		return this.profilingTimestamp;
-	}
-
-	// --------------------------------------------------------------------------------------------
-	//  Serialization
-	// --------------------------------------------------------------------------------------------
-
-	@Override
-	public void read(DataInputView in) throws IOException {
-		super.read(in);
-
-		this.jobID.read(in);
-		this.profilingTimestamp = in.readLong();
-	}
-
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-		super.write(out);
-
-		this.jobID.write(out);
-		out.writeLong(this.profilingTimestamp);
-	}
-
-	// --------------------------------------------------------------------------------------------
-	// Utilities
-	// --------------------------------------------------------------------------------------------
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof ProfilingEvent) {
-			final ProfilingEvent other = (ProfilingEvent) obj;
-			
-			return super.equals(obj) && this.profilingTimestamp == other.profilingTimestamp &&
-					this.jobID.equals(other.jobID);
-		}
-		else {
-			return false;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		return this.jobID.hashCode() ^ ((int) (profilingTimestamp >>> 32)) ^ ((int) (profilingTimestamp)) ^
-				super.hashCode();
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/SingleInstanceProfilingEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/SingleInstanceProfilingEvent.java
deleted file mode 100644
index e07f144103d..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/SingleInstanceProfilingEvent.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.types.StringValue;
-
-import com.google.common.base.Preconditions;
-
-/**
- * A single instance profiling event encapsulates profiling information for one particular instance.
- */
-public final class SingleInstanceProfilingEvent extends InstanceProfilingEvent {
-
-	private static final long serialVersionUID = 1L;
-	
-	private String instanceName;
-
-	/**
-	 * Constructs a new instance profiling event.
-	 * 
-	 * @param profilingInterval
-	 *        the interval of time this profiling event covers in milliseconds
-	 * @param ioWaitCPU
-	 *        the percentage of time the CPU(s) spent in state IOWAIT during the profiling interval
-	 * @param idleCPU
-	 *        the percentage of time the CPU(s) spent in state IDLE during the profiling interval
-	 * @param userCPU
-	 *        the percentage of time the CPU(s) spent in state USER during the profiling interval
-	 * @param systemCPU
-	 *        the percentage of time the CPU(s) spent in state SYSTEM during the profiling interval
-	 * @param hardIrqCPU
-	 *        the percentage of time the CPU(s) spent in state HARD_IRQ during the profiling interval
-	 * @param softIrqCPU
-	 *        the percentage of time the CPU(s) spent in state SOFT_IRQ during the profiling interval
-	 * @param totalMemory
-	 *        the total amount of this instance's main memory in bytes
-	 * @param freeMemory
-	 *        the free amount of this instance's main memory in bytes
-	 * @param bufferedMemory
-	 *        the amount of main memory the instance uses for file buffers
-	 * @param cachedMemory
-	 *        the amount of main memory the instance uses as cache memory
-	 * @param cachedSwapMemory
-	 *        The amount of main memory the instance uses for cached swaps
-	 * @param receivedBytes
-	 *        the number of bytes received via network during the profiling interval
-	 * @param transmittedBytes
-	 *        the number of bytes transmitted via network during the profiling interval
-	 * @param jobID
-	 *        the ID of this job this profiling event belongs to
-	 * @param timestamp
-	 *        the time stamp of this profiling event's creation
-	 * @param profilingTimestamp
-	 *        the time stamp relative to the beginning of the job's execution
-	 * @param instanceName
-	 *        the name of the instance this profiling event refers to
-	 */
-	public SingleInstanceProfilingEvent(final int profilingInterval, final int ioWaitCPU, final int idleCPU,
-			final int userCPU, final int systemCPU, final int hardIrqCPU, final int softIrqCPU, final long totalMemory,
-			final long freeMemory, final long bufferedMemory, final long cachedMemory, final long cachedSwapMemory,
-			final long receivedBytes, final long transmittedBytes, final JobID jobID, final long timestamp,
-			final long profilingTimestamp, final String instanceName)
-	{
-		super(profilingInterval, ioWaitCPU, idleCPU, userCPU, systemCPU, hardIrqCPU, softIrqCPU, totalMemory,
-			freeMemory, bufferedMemory, cachedMemory, cachedSwapMemory, receivedBytes, transmittedBytes, jobID,
-			timestamp, profilingTimestamp);
-
-		Preconditions.checkNotNull(instanceName);
-		this.instanceName = instanceName;
-	}
-
-	/**
-	 * Default constructor for serialization/deserialization.
-	 */
-	public SingleInstanceProfilingEvent() {
-		super();
-	}
-
-	// --------------------------------------------------------------------------------------------
-	
-	/**
-	 * Returns the name of the instance.
-	 * 
-	 * @return the name of the instance
-	 */
-	public String getInstanceName() {
-		return this.instanceName;
-	}
-
-	// --------------------------------------------------------------------------------------------
-	//  Serialization
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public void read(DataInputView in) throws IOException {
-		super.read(in);
-		this.instanceName = StringValue.readString(in);
-	}
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-		super.write(out);
-		StringValue.writeString(this.instanceName, out);
-	}
-	
-	// --------------------------------------------------------------------------------------------
-	//  Utilities
-	// --------------------------------------------------------------------------------------------
-
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof SingleInstanceProfilingEvent) {
-			SingleInstanceProfilingEvent other = (SingleInstanceProfilingEvent) obj;
-			return super.equals(obj) && this.instanceName.equals(other.instanceName);
-			
-		}
-		else {
-			return false;
-		}
-	}
-	
-	@Override
-	public int hashCode() {
-		return super.hashCode() + 31*instanceName.hashCode();
-	}
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/ThreadProfilingEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/ThreadProfilingEvent.java
deleted file mode 100644
index 08b932a81d4..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/ThreadProfilingEvent.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
-
-/**
- * Through this interface it is possible to access profiling data about the CPU utilization
- * of the corresponding execution thread during its execution.
- */
-public class ThreadProfilingEvent extends VertexProfilingEvent {
-
-	private static final long serialVersionUID = -3006867830244444710L;
-
-	private int userTime;
-
-	private int systemTime;
-
-	private int blockedTime;
-
-	private int waitedTime;
-
-	public ThreadProfilingEvent(int userTime, int systemTime, int blockedTime, int waitedTime,
-			JobVertexID vertexId, int subtask, ExecutionAttemptID executionId,
-			int profilingInterval, JobID jobID, long timestamp, long profilingTimestamp)
-	{
-		super(vertexId, subtask, executionId, profilingInterval, jobID, timestamp, profilingTimestamp);
-
-		this.userTime = userTime;
-		this.systemTime = systemTime;
-		this.blockedTime = blockedTime;
-		this.waitedTime = waitedTime;
-	}
-
-	public ThreadProfilingEvent() {
-		super();
-	}
-	
-	// --------------------------------------------------------------------------------------------
-
-	/**
-	 * Returns the percentage of time the execution thread spent in
-	 * user mode in the given profiling interval.
-	 * 
-	 * @return the percentage of time spent in user mode
-	 */
-	public int getUserTime() {
-		return this.userTime;
-	}
-
-	/**
-	 * Returns the percentage of time the execution thread spent in
-	 * system mode in the given profiling interval.
-	 * 
-	 * @return the percentage of time spent in system mode
-	 */
-	public int getSystemTime() {
-		return this.systemTime;
-	}
-
-	/**
-	 * Returns the percentage of time the execution thread has been
-	 * blocked to enter or reenter a monitor in the given profiling interval.
-	 * 
-	 * @return the percentage of time the thread has been blocked
-	 */
-	public int getBlockedTime() {
-		return this.blockedTime;
-	}
-
-	/**
-	 * Returns the percentage of time the execution thread spent in
-	 * either <code>WAITING</code> or <code>TIMED_WAITING</code> state in the given profiling interval.
-	 * 
-	 * @return the percentage of time the thread spent waiting
-	 */
-	public int getWaitedTime() {
-		return this.waitedTime;
-	}
-
-	// --------------------------------------------------------------------------------------------
-	//  Serialization
-	// --------------------------------------------------------------------------------------------
-
-	@Override
-	public void read(DataInputView in) throws IOException {
-		super.read(in);
-
-		this.userTime = in.readInt();
-		this.systemTime = in.readInt();
-		this.blockedTime = in.readInt();
-		this.waitedTime = in.readInt();
-	}
-
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-		super.write(out);
-
-		out.writeInt(this.userTime);
-		out.writeInt(this.systemTime);
-		out.writeInt(this.blockedTime);
-		out.writeInt(this.waitedTime);
-	}
-
-
-	// --------------------------------------------------------------------------------------------
-	//  Utilities
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof ThreadProfilingEvent) {
-			final ThreadProfilingEvent other = (ThreadProfilingEvent) obj;
-			
-			return this.userTime == other.userTime &&
-					this.systemTime == other.systemTime &&
-					this.blockedTime == other.blockedTime &&
-					this.waitedTime == other.waitedTime && 
-					super.equals(obj);
-		}
-		else {
-			return false;
-		}
-	}
-	
-	// hash code is inherited from the superclass
-}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/VertexProfilingEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/VertexProfilingEvent.java
deleted file mode 100644
index fc1875812c2..00000000000
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/profiling/types/VertexProfilingEvent.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling.types;
-
-import java.io.IOException;
-
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
-
-/**
- * This interface is a base interface for profiling data which
- * pertains to the execution of tasks.
- */
-public abstract class VertexProfilingEvent extends ProfilingEvent {
-
-	private static final long serialVersionUID = -5364961557518174880L;
-
-	private final JobVertexID vertexId;
-	
-	private int subtask;
-	
-	private final ExecutionAttemptID executionId;
-
-	private int profilingInterval;
-
-	
-	public VertexProfilingEvent(JobVertexID vertexId, int subtask, ExecutionAttemptID executionId,
-			int profilingInterval, JobID jobID, long timestamp, long profilingTimestamp)
-	{
-		super(jobID, timestamp, profilingTimestamp);
-
-		this.vertexId = vertexId;
-		this.subtask = subtask;
-		this.executionId = executionId;
-		this.profilingInterval = profilingInterval;
-	}
-
-	public VertexProfilingEvent() {
-		super();
-		this.vertexId = new JobVertexID();
-		this.executionId = new ExecutionAttemptID();
-	}
-	
-	// --------------------------------------------------------------------------------------------
-
-	/**
-	 * Returns the ID of the vertex this profiling information
-	 * belongs to.
-	 * 
-	 * @return the ID of the vertex this profiling information belongs to
-	 */
-	public JobVertexID getVertexID() {
-		return this.vertexId;
-	}
-
-	/**
-	 * The interval in milliseconds to which the rest
-	 * of the profiling data relates to.
-	 * 
-	 * @return the profiling interval given in milliseconds
-	 */
-	public int getProfilingInterval() {
-		return this.profilingInterval;
-	}
-	
-	public int getSubtask() {
-		return subtask;
-	}
-	
-	public ExecutionAttemptID getExecutionId() {
-		return executionId;
-	}
-
-	// --------------------------------------------------------------------------------------------
-	//  Serialization
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public void read(DataInputView in) throws IOException {
-		super.read(in);
-
-		this.vertexId.read(in);
-		this.executionId.read(in);
-		this.subtask = in.readInt();
-		this.profilingInterval = in.readInt();
-	}
-
-
-	@Override
-	public void write(DataOutputView out) throws IOException {
-		super.write(out);
-
-		this.vertexId.write(out);
-		this.executionId.write(out);
-		out.writeInt(subtask);
-		out.writeInt(this.profilingInterval);
-	}
-
-	// --------------------------------------------------------------------------------------------
-	//  Utilities
-	// --------------------------------------------------------------------------------------------
-	
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof VertexProfilingEvent) {
-			final VertexProfilingEvent other = (VertexProfilingEvent) obj;
-			
-			return super.equals(other) && this.subtask == other.subtask &&
-					this.profilingInterval == other.profilingInterval &&
-					this.vertexId.equals(other.vertexId) &&
-					this.executionId.equals(other.executionId);
-		}
-		else {
-			return false;
-		}
-	}
-	
-	@Override
-	public int hashCode() {
-		return super.hashCode() ^ vertexId.hashCode() ^ (31*subtask) ^ executionId.hashCode();
-	}
-}
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala
index 15a9446e531..75463fdf472 100644
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManager.scala
@@ -53,11 +53,8 @@ import org.apache.flink.runtime.jobmanager.scheduler.{Scheduler => FlinkSchedule
 import org.apache.flink.runtime.messages.JobManagerMessages._
 import org.apache.flink.runtime.messages.RegistrationMessages._
 import org.apache.flink.runtime.messages.TaskManagerMessages.{SendStackTrace, Heartbeat}
-import org.apache.flink.runtime.profiling.ProfilingUtils
 import org.apache.flink.util.{ExceptionUtils, InstantiationUtil}
 
-import org.slf4j.LoggerFactory
-
 import akka.actor._
 
 import scala.concurrent._
@@ -98,7 +95,6 @@ class JobManager(val flinkConfiguration: Configuration,
                  val libraryCacheManager: BlobLibraryCacheManager,
                  val archive: ActorRef,
                  val accumulatorManager: AccumulatorManager,
-                 val profiler: Option[ActorRef],
                  val defaultExecutionRetries: Int,
                  val delayBetweenRetries: Long,
                  val timeout: FiniteDuration)
@@ -124,7 +120,6 @@ class JobManager(val flinkConfiguration: Configuration,
     }
 
     archive ! PoisonPill
-    profiler.foreach( ref => ref ! PoisonPill )
 
     for((e,_) <- currentJobs.values) {
       e.fail(new Exception("The JobManager is shutting down."))
@@ -935,7 +930,7 @@ object JobManager {
 
   /**
    * Create the job manager components as (instanceManager, scheduler, libraryCacheManager,
-   *              archiverProps, accumulatorManager, profiler, defaultExecutionRetries,
+   *              archiverProps, accumulatorManager, defaultExecutionRetries,
    *              delayBetweenRetries, timeout)
    *
    * @param configuration The configuration from which to parse the config values.
@@ -943,15 +938,13 @@ object JobManager {
    */
   def createJobManagerComponents(configuration: Configuration) :
     (InstanceManager, FlinkScheduler, BlobLibraryCacheManager,
-      Props, AccumulatorManager, Option[Props], Int, Long, FiniteDuration, Int) = {
+      Props, AccumulatorManager, Int, Long, FiniteDuration, Int) = {
 
     val timeout: FiniteDuration = AkkaUtils.getTimeout(configuration)
 
     val archiveCount = configuration.getInteger(ConfigConstants.JOB_MANAGER_WEB_ARCHIVE_COUNT,
       ConfigConstants.DEFAULT_JOB_MANAGER_WEB_ARCHIVE_COUNT)
 
-    val profilingEnabled = configuration.getBoolean(ProfilingUtils.PROFILE_JOB_KEY, false)
-
     val cleanupInterval = configuration.getLong(
       ConfigConstants.LIBRARY_CACHE_MANAGER_CLEANUP_INTERVAL,
       ConfigConstants.DEFAULT_LIBRARY_CACHE_MANAGER_CLEANUP_INTERVAL) * 1000
@@ -978,12 +971,6 @@ object JobManager {
 
     val archiveProps: Props = Props(classOf[MemoryArchivist], archiveCount)
 
-    val profilerProps: Option[Props] = if (profilingEnabled) {
-      Some(Props(classOf[JobManagerProfiler]))
-    } else {
-      None
-    }
-
     val accumulatorManager: AccumulatorManager = new AccumulatorManager(Math.min(1, archiveCount))
 
     var blobServer: BlobServer = null
@@ -1018,7 +1005,7 @@ object JobManager {
     }
 
     (instanceManager, scheduler, libraryCacheManager, archiveProps, accumulatorManager,
-      profilerProps, executionRetries, delayBetweenRetries, timeout, archiveCount)
+      executionRetries, delayBetweenRetries, timeout, archiveCount)
   }
 
   /**
@@ -1052,12 +1039,9 @@ object JobManager {
                             archiverActorName: Option[String]): (ActorRef, ActorRef) = {
 
     val (instanceManager, scheduler, libraryCacheManager, archiveProps, accumulatorManager,
-      profilerProps, executionRetries, delayBetweenRetries,
+      executionRetries, delayBetweenRetries,
       timeout, _) = createJobManagerComponents(configuration)
 
-    val profiler: Option[ActorRef] =
-                 profilerProps.map( props => actorSystem.actorOf(props, PROFILER_NAME) )
-
     // start the archiver wither with the given name, or without (avoid name conflicts)
     val archiver: ActorRef = archiverActorName match {
       case Some(actorName) => actorSystem.actorOf(archiveProps, actorName)
@@ -1065,7 +1049,7 @@ object JobManager {
     }
 
     val jobManagerProps = Props(classOf[JobManager], configuration, instanceManager, scheduler,
-        libraryCacheManager, archiver, accumulatorManager, profiler, executionRetries,
+        libraryCacheManager, archiver, accumulatorManager, executionRetries,
         delayBetweenRetries, timeout)
 
     val jobManager: ActorRef = jobMangerActorName match {
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManagerProfiler.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManagerProfiler.scala
deleted file mode 100644
index dd3a1b7cd01..00000000000
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/jobmanager/JobManagerProfiler.scala
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.jobmanager
-
-import akka.actor.Actor
-import org.apache.flink.runtime.{ActorSynchronousLogging, ActorLogMessages}
-import org.apache.flink.runtime.messages.JobManagerProfilerMessages.ReportProfilingData
-import org.apache.flink.runtime.profiling.impl.types.{InternalInstanceProfilingData, InternalExecutionVertexThreadProfilingData}
-
-import scala.collection.convert.WrapAsScala
-
-/**
- * Basic skeleton for the JobManager profiler. Currently, it simply logs the received messages.
- */
-class JobManagerProfiler
-  extends Actor
-  with ActorLogMessages
-  with ActorSynchronousLogging
-  with WrapAsScala {
-  override def receiveWithLogMessages: Receive = {
-    case ReportProfilingData(profilingContainer) =>
-      profilingContainer.getIterator foreach {
-        case x: InternalExecutionVertexThreadProfilingData =>
-          log.info(s"Received InternalExecutionVertexThreadProfilingData $x.")
-        case x: InternalInstanceProfilingData =>
-          log.info(s"Received InternalInstanceProfilingData $x.")
-        case x =>
-          log.error(s"Received unknown profiling data: ${x.getClass.getName}" )
-      }
-  }
-
-  /**
-   * Handle unmatched messages with an exception.
-   */
-  override def unhandled(message: Any): Unit = {
-    // let the actor crash
-    throw new RuntimeException("Received unknown message " + message)
-  }
-}
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/messages/JobManagerProfilerMessages.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/messages/JobManagerProfilerMessages.scala
deleted file mode 100644
index 85e0fc34456..00000000000
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/messages/JobManagerProfilerMessages.scala
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.messages
-
-import org.apache.flink.runtime.profiling.impl.types.ProfilingDataContainer
-
-/**
- * This object contains the job manager profiler messages
- */
-object JobManagerProfilerMessages {
-
-  /**
-   * Reports profiling data to the profiler.
-   * @param profilingDataContainer
-   */
-  case class ReportProfilingData(profilingDataContainer: ProfilingDataContainer)
-
-}
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/messages/TaskManagerProfilerMessages.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/messages/TaskManagerProfilerMessages.scala
deleted file mode 100644
index 0662d48ad93..00000000000
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/messages/TaskManagerProfilerMessages.scala
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.messages
-
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID
-import org.apache.flink.runtime.taskmanager.Task
-
-object TaskManagerProfilerMessages {
-
-  /**
-   * Requests to monitor the specified [[task]].
-   *
-   * @param task
-   */
-  case class MonitorTask(task: Task)
-
-  /**
-   * Requests to unmonitor the task associated to [[executionID]].
-   *
-   * @param executionID
-   */
-  case class UnmonitorTask(executionID: ExecutionAttemptID)
-
-  /**
-   * Registers the sender as a profiling event listener.
-   */
-  case object RegisterProfilingListener
-
-  /**
-   * Unregisters the sender as a profiling event listener.
-   */
-  case object UnregisterProfilingListener
-
-  /**
-   * Makes the task manager profiling the running tasks.
-   */
-  case object ProfileTasks
-
-}
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManagerProfiler.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManagerProfiler.scala
deleted file mode 100644
index f0079f85e5b..00000000000
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManagerProfiler.scala
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.taskmanager
-
-import java.lang.management.ManagementFactory
-import java.util.concurrent.TimeUnit
-
-import akka.actor.{Cancellable, ActorRef, Actor, ActorLogging}
-import org.apache.flink.runtime.{ActorSynchronousLogging, ActorLogMessages}
-import org.apache.flink.runtime.execution.{RuntimeEnvironment, ExecutionState}
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID
-import org.apache.flink.runtime.jobgraph.JobVertexID
-import org.apache.flink.runtime.messages.ExecutionGraphMessages.ExecutionStateChanged
-import org.apache.flink.runtime.messages.JobManagerProfilerMessages.ReportProfilingData
-import org.apache.flink.runtime.messages.TaskManagerProfilerMessages._
-import org.apache.flink.runtime.profiling.ProfilingException
-import org.apache.flink.runtime.profiling.impl.types.ProfilingDataContainer
-import org.apache.flink.runtime.profiling.impl.{EnvironmentThreadSet, InstanceProfiler}
-
-import scala.concurrent.duration.FiniteDuration
-
-/**
- * Actor which is responsible for profiling task threads on the [[TaskManager]]. The monitoring
- * is triggered by the self-addressed message [[ProfileTasks]] which is scheduled to be sent
- * repeatedly.
- *
- * @param instancePath Akka URL to [[TaskManager]] instance
- * @param reportInterval Interval of profiling action
- */
-class TaskManagerProfiler(val instancePath: String, val reportInterval: Int)
-   extends Actor with ActorLogMessages with ActorSynchronousLogging {
-
-  import context.dispatcher
-
-  val tmx = ManagementFactory.getThreadMXBean
-  val instanceProfiler = new InstanceProfiler(instancePath)
-  val listeners = scala.collection.mutable.Set[ActorRef]()
-  val environments = scala.collection.mutable.HashMap[ExecutionAttemptID, RuntimeEnvironment]()
-  val monitoredThreads = scala.collection.mutable.HashMap[RuntimeEnvironment,
-    EnvironmentThreadSet]()
-
-  var monitoringScheduler: Option[Cancellable] = None
-
-  if (tmx.isThreadContentionMonitoringSupported) {
-    tmx.setThreadContentionMonitoringEnabled(true)
-  } else {
-    throw new ProfilingException("The thread contention monitoring is not supported.")
-  }
-
-
-  override def receiveWithLogMessages: Receive = {
-    case MonitorTask(task) =>
-      task.registerExecutionListener(self)
-      environments += task.getExecutionId -> task.getEnvironment
-
-    case UnmonitorTask(executionAttemptID) =>
-      environments.remove(executionAttemptID)
-
-    case RegisterProfilingListener =>
-      listeners += sender
-      if (monitoringScheduler.isEmpty) {
-        startMonitoring()
-      }
-
-    case UnregisterProfilingListener =>
-      listeners -= sender
-      if (listeners.isEmpty) {
-        stopMonitoring()
-      }
-
-    case ProfileTasks =>
-      val timestamp = System.currentTimeMillis()
-
-      val profilingDataContainer = new ProfilingDataContainer()
-
-      for ((env, set) <- monitoredThreads) {
-        val threadProfilingData = set.captureCPUUtilization(env.getJobID, tmx, timestamp)
-
-        if (threadProfilingData != null) {
-          profilingDataContainer.addProfilingData(threadProfilingData)
-        }
-
-        if (monitoredThreads.nonEmpty) {
-          val instanceProfilingData = try {
-            Some(instanceProfiler.generateProfilingData(timestamp))
-          } catch {
-            case e: ProfilingException =>
-              log.error("Error while retrieving instance profiling data.", e)
-              None
-          }
-
-          instanceProfilingData foreach {
-            profilingDataContainer.addProfilingData(_)
-          }
-
-          if (!profilingDataContainer.isEmpty) {
-            for (listener <- listeners) {
-              listener ! ReportProfilingData(profilingDataContainer)
-            }
-          }
-
-          profilingDataContainer.clear()
-        }
-      }
-
-    case ExecutionStateChanged(_, vertexID, _, _, subtaskIndex, executionID, newExecutionState,
-    _, _) =>
-      import ExecutionState._
-
-      environments.get(executionID) match {
-        case Some(environment) =>
-          newExecutionState match {
-            case RUNNING => registerMainThreadForCPUProfiling(environment, vertexID,
-              subtaskIndex, executionID)
-            case FINISHED | CANCELING | CANCELED | FAILED =>
-              unregisterMainThreadFromCPUProfiling(environment)
-            case _ =>
-          }
-        case None =>
-          log.warn(s"Could not find environment for execution id $executionID.")
-      }
-  }
-
-  /**
-   * Handle unmatched messages with an exception.
-   */
-  override def unhandled(message: Any): Unit = {
-    // let the actor crash
-    throw new RuntimeException("Received unknown message " + message)
-  }
-
-  def startMonitoring(): Unit = {
-    val interval = new FiniteDuration(reportInterval, TimeUnit.MILLISECONDS)
-    val delay = new FiniteDuration((reportInterval * Math.random()).toLong, TimeUnit.MILLISECONDS)
-
-    // schedule ProfileTasks message to be sent repeatedly to oneself
-    monitoringScheduler = Some(context.system.scheduler.schedule(delay, interval, self,
-      ProfileTasks))
-  }
-
-  def stopMonitoring(): Unit = {
-    monitoringScheduler.foreach {
-      _.cancel()
-    }
-    monitoringScheduler = None
-  }
-
-  def registerMainThreadForCPUProfiling(environment: RuntimeEnvironment, vertexID: JobVertexID,
-                                        subtask: Int,
-                                        executionID: ExecutionAttemptID): Unit = {
-    monitoredThreads += environment -> new EnvironmentThreadSet(tmx,
-      environment.getExecutingThread, vertexID,
-      subtask, executionID)
-  }
-
-  def unregisterMainThreadFromCPUProfiling(environment: RuntimeEnvironment): Unit = {
-    monitoredThreads.remove(environment) match {
-      case Some(set) =>
-        if (set.getMainThread != environment.getExecutingThread) {
-          log.error(s"The thread ${environment.getExecutingThread.getName} is not the main thread" +
-            s" of this environment.")
-        }
-      case None =>
-    }
-  }
-}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/profiling/impl/InstanceProfilerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/profiling/impl/InstanceProfilerTest.java
deleted file mode 100644
index 85a4a3708c3..00000000000
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/profiling/impl/InstanceProfilerTest.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.flink.runtime.profiling.impl;
-
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.when;
-import static org.mockito.MockitoAnnotations.initMocks;
-import static org.powermock.api.mockito.PowerMockito.whenNew;
-
-import java.io.BufferedReader;
-import java.io.FileReader;
-import java.net.InetAddress;
-
-import org.apache.flink.runtime.instance.InstanceConnectionInfo;
-import org.apache.flink.runtime.profiling.ProfilingException;
-import org.apache.flink.runtime.profiling.impl.types.InternalInstanceProfilingData;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.powermock.api.mockito.PowerMockito;
-import org.powermock.core.classloader.annotations.PrepareForTest;
-import org.powermock.modules.junit4.PowerMockRunner;
-
-/**
- */
-@RunWith(PowerMockRunner.class)
-@PrepareForTest(InstanceProfiler.class)
-public class InstanceProfilerTest {
-
-	@Mock
-	private InstanceConnectionInfo infoMock;
-
-	@Mock
-	private InetAddress addressMock;
-
-	@Mock
-	private BufferedReader cpuBufferMock;
-
-	@Mock
-	private BufferedReader networkBufferMock;
-
-	@Mock
-	private BufferedReader memoryBufferMock;
-
-	@Mock
-	private FileReader cpuReaderMock;
-
-	@Mock
-	private FileReader networkReaderMock;
-
-	@Mock
-	private FileReader memoryReaderMock;
-
-	// object under test
-	InstanceProfiler out;
-
-	@Before
-	public void setUp() throws Exception {
-		initMocks(this);
-		when(this.infoMock.address()).thenReturn(this.addressMock);
-		when(this.addressMock.getHostAddress()).thenReturn("192.168.1.1");
-
-		whenNew(FileReader.class).withArguments(InstanceProfiler.PROC_STAT).thenReturn(this.cpuReaderMock);
-		whenNew(BufferedReader.class).withArguments(this.cpuReaderMock).thenReturn(this.cpuBufferMock);
-
-		when(this.cpuBufferMock.readLine()).thenReturn(
-			"cpu  222875 20767 209704 3782096 209864 0 1066 0 0 0"
-			);
-
-		whenNew(FileReader.class).withArguments(InstanceProfiler.PROC_NET_DEV).thenReturn(this.networkReaderMock);
-		whenNew(BufferedReader.class).withArguments(this.networkReaderMock).thenReturn(this.networkBufferMock);
-
-		when(this.networkBufferMock.readLine())
-			.thenReturn(
-				"  eth0: 364729203  286442    0    0    0     0          0      1060 14483806  191563    0    0    0     0       0          0",
-				(String) null,
-				"  eth0: 364729203  286442    0    0    0     0          0      1060 14483806  191563    0    0    0     0       0          0",
-				(String) null,
-				"  eth0: 364729203  286442    0    0    0     0          0      1060 14483806  191563    0    0    0     0       0          0",
-				(String) null
-			);
-
-		whenNew(FileReader.class).withArguments(InstanceProfiler.PROC_MEMINFO).thenReturn(this.memoryReaderMock);
-		whenNew(BufferedReader.class).withArguments(this.memoryReaderMock).thenReturn(this.memoryBufferMock);
-
-		when(this.memoryBufferMock.readLine()).thenReturn(
-			"MemTotal:        8052956 kB",
-			"MemFree:         3999880 kB",
-			"Buffers:           77216 kB",
-			"Cached:          1929640 kB",
-			null,
-			"MemTotal:        8052956 kB",
-			"MemFree:         3999880 kB",
-			"Buffers:           77216 kB",
-			"Cached:          1929640 kB",
-			null,
-			"MemTotal:        8052956 kB",
-			"MemFree:         3999880 kB",
-			"Buffers:           77216 kB",
-			"Cached:          1929640 kB",
-			null
-			);
-
-		PowerMockito.mockStatic(System.class);
-		when(System.currentTimeMillis()).thenReturn(0L);
-
-		this.out = new InstanceProfiler("InstanceProfilerTest");
-	}
-
-	@Test
-	public void shouldHaveNetworkTraffic() {
-
-		try {
-			final InternalInstanceProfilingData generateProfilingData = out.generateProfilingData(0L);
-			assertEquals(0L, generateProfilingData.getReceivedBytes());
-			assertEquals(0L, generateProfilingData.getTransmittedBytes());
-		} catch (ProfilingException e) {
-			fail(e.getMessage());
-		}
-	}
-
-	@Test
-	public void shouldHaveMemSettingsMeasured() {
-
-		try {
-			final InternalInstanceProfilingData generateProfilingData = out.generateProfilingData(0L);
-
-			final long totalMemory = generateProfilingData.getTotalMemory();
-			assertThat(totalMemory, is(equalTo(8052956L)));
-
-			long freeMemory = generateProfilingData.getFreeMemory();
-			assertThat(freeMemory, is(equalTo(3999880L)));
-
-			long buffers = generateProfilingData.getBufferedMemory();
-			assertThat(buffers, is(equalTo(77216L)));
-
-			long cached = generateProfilingData.getCachedMemory();
-			assertThat(cached, is(equalTo(1929640L)));
-		} catch (ProfilingException e) {
-			fail(e.getMessage());
-		}
-	}
-
-	@Test
-	public void shouldMeasureCPUUtilization() {
-
-		try {
-			final InternalInstanceProfilingData generateProfilingData = out.generateProfilingData(0L);
-
-			assertEquals(0L, generateProfilingData.getUserCPU());
-			assertEquals(0L, generateProfilingData.getIdleCPU());
-			assertEquals(0L, generateProfilingData.getSystemCPU());
-			assertEquals(0L, generateProfilingData.getHardIrqCPU());
-			assertEquals(0L, generateProfilingData.getSoftIrqCPU());
-			assertEquals(0L, generateProfilingData.getIOWaitCPU());
-		} catch (ProfilingException e) {
-			fail(e.getMessage());
-		}
-	}
-}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/profiling/types/ProfilingTypesTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/profiling/types/ProfilingTypesTest.java
deleted file mode 100644
index c3c75ce5aa9..00000000000
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/profiling/types/ProfilingTypesTest.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.profiling.types;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
-import org.apache.flink.runtime.testutils.CommonTestUtils;
-import org.apache.flink.runtime.testutils.ManagementTestUtils;
-import org.junit.Test;
-
-/**
- * This test checks the proper serialization and deserialization of profiling events.
- */
-public class ProfilingTypesTest {
-
-	private static final int PROFILING_INTERVAL = 4321;
-
-	private static final int IOWAIT_CPU = 10;
-
-	private static final int IDLE_CPU = 11;
-
-	private static final int USER_CPU = 12;
-
-	private static final int SYSTEM_CPU = 13;
-
-	private static final int HARD_IRQ_CPU = 14;
-
-	private static final int SOFT_IRQ_CPU = 15;
-
-	private static final long TOTAL_MEMORY = 10001L;
-
-	private static final long FREE_MEMORY = 10002L;
-
-	private static final long BUFFERED_MEMORY = 10003L;
-
-	private static final long CACHED_MEMORY = 10004L;
-
-	private static final long CACHED_SWAP_MEMORY = 10005L;
-
-	private static final long RECEIVED_BYTES = 100006L;
-
-	private static final long TRANSMITTED_BYTES = 100007L;
-
-	private static final long TIMESTAMP = 100008L;
-
-	private static final long PROFILING_TIMESTAMP = 100009L;
-
-	private static final String INSTANCE_NAME = "Test Instance";
-
-	private static final int USER_TIME = 17;
-
-	private static final int SYSTEM_TIME = 18;
-
-	private static final int BLOCKED_TIME = 19;
-
-	private static final int WAITED_TIME = 20;
-
-	/**
-	 * Tests serialization/deserialization for {@link InstanceSummaryProfilingEvent}.
-	 */
-	@Test
-	public void testInstanceSummaryProfilingEvent() {
-
-		final InstanceSummaryProfilingEvent orig = new InstanceSummaryProfilingEvent(PROFILING_INTERVAL, IOWAIT_CPU,
-			IDLE_CPU, USER_CPU, SYSTEM_CPU, HARD_IRQ_CPU, SOFT_IRQ_CPU, TOTAL_MEMORY, FREE_MEMORY, BUFFERED_MEMORY,
-			CACHED_MEMORY, CACHED_SWAP_MEMORY, RECEIVED_BYTES, TRANSMITTED_BYTES, new JobID(), TIMESTAMP,
-			PROFILING_TIMESTAMP);
-
-		final InstanceSummaryProfilingEvent copy = (InstanceSummaryProfilingEvent) ManagementTestUtils.createCopy(orig);
-
-		assertEquals(orig.getProfilingInterval(), copy.getProfilingInterval());
-		assertEquals(orig.getIOWaitCPU(), copy.getIOWaitCPU());
-		assertEquals(orig.getIdleCPU(), copy.getIdleCPU());
-		assertEquals(orig.getUserCPU(), copy.getUserCPU());
-		assertEquals(orig.getSystemCPU(), copy.getSystemCPU());
-		assertEquals(orig.getHardIrqCPU(), copy.getHardIrqCPU());
-		assertEquals(orig.getSoftIrqCPU(), copy.getSoftIrqCPU());
-		assertEquals(orig.getTotalMemory(), copy.getTotalMemory());
-		assertEquals(orig.getFreeMemory(), copy.getFreeMemory());
-		assertEquals(orig.getBufferedMemory(), copy.getBufferedMemory());
-		assertEquals(orig.getCachedMemory(), copy.getCachedMemory());
-		assertEquals(orig.getCachedSwapMemory(), copy.getCachedSwapMemory());
-		assertEquals(orig.getReceivedBytes(), copy.getReceivedBytes());
-		assertEquals(orig.getTransmittedBytes(), copy.getTransmittedBytes());
-		assertEquals(orig.getJobID(), copy.getJobID());
-		assertEquals(orig.getTimestamp(), copy.getTimestamp());
-		assertEquals(orig.getProfilingTimestamp(), copy.getProfilingTimestamp());
-		assertEquals(orig.hashCode(), copy.hashCode());
-		assertTrue(orig.equals(copy));
-	}
-
-	/**
-	 * Tests serialization/deserialization for {@link SingleInstanceProfilingEvent}.
-	 */
-	@Test
-	public void testSingleInstanceProfilingEvent() {
-		try {
-			final SingleInstanceProfilingEvent orig = new SingleInstanceProfilingEvent(PROFILING_INTERVAL, IOWAIT_CPU,
-				IDLE_CPU, USER_CPU, SYSTEM_CPU, HARD_IRQ_CPU, SOFT_IRQ_CPU, TOTAL_MEMORY, FREE_MEMORY, BUFFERED_MEMORY,
-				CACHED_MEMORY, CACHED_SWAP_MEMORY, RECEIVED_BYTES, TRANSMITTED_BYTES, new JobID(), TIMESTAMP,
-				PROFILING_TIMESTAMP, INSTANCE_NAME);
-	
-			final SingleInstanceProfilingEvent copy = (SingleInstanceProfilingEvent) CommonTestUtils.createCopyWritable(orig);
-	
-			assertEquals(orig.getProfilingInterval(), copy.getProfilingInterval());
-			assertEquals(orig.getIOWaitCPU(), copy.getIOWaitCPU());
-			assertEquals(orig.getIdleCPU(), copy.getIdleCPU());
-			assertEquals(orig.getUserCPU(), copy.getUserCPU());
-			assertEquals(orig.getSystemCPU(), copy.getSystemCPU());
-			assertEquals(orig.getHardIrqCPU(), copy.getHardIrqCPU());
-			assertEquals(orig.getSoftIrqCPU(), copy.getSoftIrqCPU());
-			assertEquals(orig.getTotalMemory(), copy.getTotalMemory());
-			assertEquals(orig.getFreeMemory(), copy.getFreeMemory());
-			assertEquals(orig.getBufferedMemory(), copy.getBufferedMemory());
-			assertEquals(orig.getCachedMemory(), copy.getCachedMemory());
-			assertEquals(orig.getCachedSwapMemory(), copy.getCachedSwapMemory());
-			assertEquals(orig.getReceivedBytes(), copy.getReceivedBytes());
-			assertEquals(orig.getTransmittedBytes(), copy.getTransmittedBytes());
-			assertEquals(orig.getJobID(), copy.getJobID());
-			assertEquals(orig.getTimestamp(), copy.getTimestamp());
-			assertEquals(orig.getProfilingTimestamp(), copy.getProfilingTimestamp());
-			assertEquals(orig.getInstanceName(), copy.getInstanceName());
-			assertEquals(orig.hashCode(), copy.hashCode());
-			assertTrue(orig.equals(copy));
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-			fail(e.getMessage());
-		}
-
-	}
-
-	/**
-	 * Tests serialization/deserialization for {@link ThreadProfilingEvent}.
-	 */
-	@Test
-	public void testThreadProfilingEvent() {
-
-		final ThreadProfilingEvent orig = new ThreadProfilingEvent(USER_TIME, SYSTEM_TIME, BLOCKED_TIME, WAITED_TIME,
-			new JobVertexID(), 17, new ExecutionAttemptID(), PROFILING_INTERVAL, new JobID(), TIMESTAMP, PROFILING_TIMESTAMP);
-
-		final ThreadProfilingEvent copy = (ThreadProfilingEvent) ManagementTestUtils.createCopy(orig);
-
-		assertEquals(orig.getUserTime(), copy.getUserTime());
-		assertEquals(orig.getSystemTime(), copy.getSystemTime());
-		assertEquals(orig.getBlockedTime(), copy.getBlockedTime());
-		assertEquals(orig.getWaitedTime(), copy.getWaitedTime());
-		assertEquals(orig.getVertexID(), copy.getVertexID());
-		assertEquals(orig.getProfilingInterval(), copy.getProfilingInterval());
-		assertEquals(orig.getJobID(), copy.getJobID());
-		assertEquals(orig.getTimestamp(), copy.getTimestamp());
-		assertEquals(orig.getProfilingTimestamp(), copy.getProfilingTimestamp());
-		assertEquals(orig.hashCode(), copy.hashCode());
-		assertTrue(orig.equals(copy));
-	}
-}
diff --git a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingCluster.scala b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingCluster.scala
index f87e151baaf..9f9fe931777 100644
--- a/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingCluster.scala
+++ b/flink-runtime/src/test/scala/org/apache/flink/runtime/testingUtils/TestingCluster.scala
@@ -49,7 +49,7 @@ class TestingCluster(userConfiguration: Configuration, singleActorSystem: Boolea
 
   override def startJobManager(actorSystem: ActorSystem): ActorRef = {
 
-    val (instanceManager, scheduler, libraryCacheManager, _, accumulatorManager, _,
+    val (instanceManager, scheduler, libraryCacheManager, _, accumulatorManager,
     executionRetries, delayBetweenRetries,
     timeout, archiveCount) = JobManager.createJobManagerComponents(configuration)
 
@@ -57,7 +57,7 @@ class TestingCluster(userConfiguration: Configuration, singleActorSystem: Boolea
     val archive = actorSystem.actorOf(testArchiveProps, JobManager.ARCHIVE_NAME)
 
     val jobManagerProps = Props(new JobManager(configuration, instanceManager, scheduler,
-      libraryCacheManager, archive, accumulatorManager, None, executionRetries,
+      libraryCacheManager, archive, accumulatorManager, executionRetries,
       delayBetweenRetries, timeout) with TestingJobManager)
 
     actorSystem.actorOf(jobManagerProps, JobManager.JOB_MANAGER_NAME)
diff --git a/flink-test-utils/src/main/scala/org/apache/flink/test/util/ForkableFlinkMiniCluster.scala b/flink-test-utils/src/main/scala/org/apache/flink/test/util/ForkableFlinkMiniCluster.scala
index ddfffeec952..05093b51a72 100644
--- a/flink-test-utils/src/main/scala/org/apache/flink/test/util/ForkableFlinkMiniCluster.scala
+++ b/flink-test-utils/src/main/scala/org/apache/flink/test/util/ForkableFlinkMiniCluster.scala
@@ -71,7 +71,7 @@ class ForkableFlinkMiniCluster(userConfiguration: Configuration, singleActorSyst
 
   override def startJobManager(actorSystem: ActorSystem): ActorRef = {
 
-    val (instanceManager, scheduler, libraryCacheManager, _, accumulatorManager, _,
+    val (instanceManager, scheduler, libraryCacheManager, _, accumulatorManager,
     executionRetries, delayBetweenRetries,
     timeout, archiveCount) = JobManager.createJobManagerComponents(configuration)
 
@@ -79,7 +79,7 @@ class ForkableFlinkMiniCluster(userConfiguration: Configuration, singleActorSyst
     val archive = actorSystem.actorOf(testArchiveProps, JobManager.ARCHIVE_NAME)
 
     val jobManagerProps = Props(new JobManager(configuration, instanceManager, scheduler,
-      libraryCacheManager, archive, accumulatorManager, None, executionRetries,
+      libraryCacheManager, archive, accumulatorManager, executionRetries,
       delayBetweenRetries, timeout) with TestingJobManager)
 
     val jobManager = actorSystem.actorOf(jobManagerProps, JobManager.JOB_MANAGER_NAME)
diff --git a/flink-yarn/src/main/scala/org/apache/flink/yarn/ApplicationMaster.scala b/flink-yarn/src/main/scala/org/apache/flink/yarn/ApplicationMaster.scala
index 06e16dcb6b2..7884edd1296 100644
--- a/flink-yarn/src/main/scala/org/apache/flink/yarn/ApplicationMaster.scala
+++ b/flink-yarn/src/main/scala/org/apache/flink/yarn/ApplicationMaster.scala
@@ -32,7 +32,7 @@ import org.apache.flink.yarn.Messages.StartYarnSession
 import org.apache.hadoop.security.UserGroupInformation
 import org.apache.hadoop.yarn.api.ApplicationConstants.Environment
 import org.apache.hadoop.yarn.conf.YarnConfiguration
-import org.slf4j.LoggerFactory
+
 
 import scala.io.Source
 
@@ -228,18 +228,14 @@ object ApplicationMaster {
     // start all the components inside the job manager
     LOG.debug("Starting JobManager components")
     val (instanceManager, scheduler, libraryCacheManager, archiveProps, accumulatorManager,
-                   profilerProps, executionRetries, delayBetweenRetries,
+                   executionRetries, delayBetweenRetries,
                    timeout, _) = JobManager.createJobManagerComponents(configuration)
 
-    // start the profiler, if needed
-    val profiler: Option[ActorRef] =
-      profilerProps.map( props => jobManagerSystem.actorOf(props, JobManager.PROFILER_NAME) )
-
     // start the archiver
     val archiver: ActorRef = jobManagerSystem.actorOf(archiveProps, JobManager.ARCHIVE_NAME)
 
     val jobManagerProps = Props(new JobManager(configuration, instanceManager, scheduler,
-      libraryCacheManager, archiver, accumulatorManager, profiler, executionRetries,
+      libraryCacheManager, archiver, accumulatorManager, executionRetries,
       delayBetweenRetries, timeout) with ApplicationMasterActor)
 
     LOG.debug("Starting JobManager actor")
