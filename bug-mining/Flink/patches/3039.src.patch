diff --git a/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerTest.java b/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerTest.java
index 617ad4133c2..8a71d13e1ce 100644
--- a/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerTest.java
+++ b/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerTest.java
@@ -42,10 +42,8 @@ import org.apache.flink.runtime.clusterframework.ContainerSpecification;
 import org.apache.flink.runtime.clusterframework.ContaineredTaskManagerParameters;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
-import org.apache.flink.runtime.concurrent.ScheduledExecutor;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.heartbeat.TestingHeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
 import org.apache.flink.runtime.instance.HardwareDescription;
@@ -319,7 +317,6 @@ public class MesosResourceManagerTest extends TestLogger {
 		 */
 		class MockResourceManagerRuntimeServices {
 
-			public final ScheduledExecutor scheduledExecutor;
 			public final TestingHighAvailabilityServices highAvailabilityServices;
 			public final HeartbeatServices heartbeatServices;
 			public final MetricRegistry metricRegistry;
@@ -332,11 +329,10 @@ public class MesosResourceManagerTest extends TestLogger {
 			public UUID rmLeaderSessionId;
 
 			MockResourceManagerRuntimeServices() throws Exception {
-				scheduledExecutor = mock(ScheduledExecutor.class);
 				highAvailabilityServices = new TestingHighAvailabilityServices();
 				rmLeaderElectionService = new TestingLeaderElectionService();
 				highAvailabilityServices.setResourceManagerLeaderElectionService(rmLeaderElectionService);
-				heartbeatServices = new TestingHeartbeatServices(5L, 5L, scheduledExecutor);
+				heartbeatServices = new HeartbeatServices(5L, 5L);
 				metricRegistry = mock(MetricRegistryImpl.class);
 				slotManager = mock(SlotManager.class);
 				slotManagerStarted = new CompletableFuture<>();
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatListener.java b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatListener.java
index 01a4754dfb1..be99050f5a1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatListener.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatListener.java
@@ -20,8 +20,6 @@ package org.apache.flink.runtime.heartbeat;
 
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 
-import java.util.concurrent.CompletableFuture;
-
 /**
  * Interface for the interaction with the {@link HeartbeatManager}. The heartbeat listener is used
  * for the following things:
@@ -54,11 +52,10 @@ public interface HeartbeatListener<I, O> {
 	void reportPayload(ResourceID resourceID, I payload);
 
 	/**
-	 * Retrieves the payload value for the next heartbeat message. Since the operation can happen
-	 * asynchronously, the result is returned wrapped in a future.
+	 * Retrieves the payload value for the next heartbeat message.
 	 *
 	 * @param resourceID Resource ID identifying the receiver of the payload
-	 * @return Future containing the next payload for heartbeats
+	 * @return The payload for the next heartbeat
 	 */
-	CompletableFuture<O> retrievePayload(ResourceID resourceID);
+	O retrievePayload(ResourceID resourceID);
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerImpl.java
index 15a3757ab35..fdb78a25d55 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerImpl.java
@@ -27,9 +27,7 @@ import org.slf4j.Logger;
 import javax.annotation.concurrent.ThreadSafe;
 
 import java.util.Collection;
-import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
@@ -57,16 +55,13 @@ public class HeartbeatManagerImpl<I, O> implements HeartbeatManager<I, O> {
 	private final HeartbeatListener<I, O> heartbeatListener;
 
 	/** Executor service used to run heartbeat timeout notifications. */
-	private final ScheduledExecutor scheduledExecutor;
+	private final ScheduledExecutor mainThreadExecutor;
 
 	protected final Logger log;
 
 	/** Map containing the heartbeat monitors associated with the respective resource ID. */
 	private final ConcurrentHashMap<ResourceID, HeartbeatManagerImpl.HeartbeatMonitor<O>> heartbeatTargets;
 
-	/** Execution context used to run future callbacks. */
-	private final Executor executor;
-
 	/** Running state of the heartbeat manager. */
 	protected volatile boolean stopped;
 
@@ -74,17 +69,15 @@ public class HeartbeatManagerImpl<I, O> implements HeartbeatManager<I, O> {
 			long heartbeatTimeoutIntervalMs,
 			ResourceID ownResourceID,
 			HeartbeatListener<I, O> heartbeatListener,
-			Executor executor,
-			ScheduledExecutor scheduledExecutor,
+			ScheduledExecutor mainThreadExecutor,
 			Logger log) {
 		Preconditions.checkArgument(heartbeatTimeoutIntervalMs > 0L, "The heartbeat timeout has to be larger than 0.");
 
 		this.heartbeatTimeoutIntervalMs = heartbeatTimeoutIntervalMs;
 		this.ownResourceID = Preconditions.checkNotNull(ownResourceID);
 		this.heartbeatListener = Preconditions.checkNotNull(heartbeatListener, "heartbeatListener");
-		this.scheduledExecutor = Preconditions.checkNotNull(scheduledExecutor);
+		this.mainThreadExecutor = Preconditions.checkNotNull(mainThreadExecutor);
 		this.log = Preconditions.checkNotNull(log);
-		this.executor = Preconditions.checkNotNull(executor);
 		this.heartbeatTargets = new ConcurrentHashMap<>(16);
 
 		stopped = false;
@@ -98,10 +91,6 @@ public class HeartbeatManagerImpl<I, O> implements HeartbeatManager<I, O> {
 		return ownResourceID;
 	}
 
-	Executor getExecutor() {
-		return executor;
-	}
-
 	HeartbeatListener<I, O> getHeartbeatListener() {
 		return heartbeatListener;
 	}
@@ -123,7 +112,7 @@ public class HeartbeatManagerImpl<I, O> implements HeartbeatManager<I, O> {
 				HeartbeatManagerImpl.HeartbeatMonitor<O> heartbeatMonitor = new HeartbeatManagerImpl.HeartbeatMonitor<>(
 					resourceID,
 					heartbeatTarget,
-					scheduledExecutor,
+					mainThreadExecutor,
 					heartbeatListener,
 					heartbeatTimeoutIntervalMs);
 
@@ -174,6 +163,10 @@ public class HeartbeatManagerImpl<I, O> implements HeartbeatManager<I, O> {
 		}
 	}
 
+	ScheduledExecutor getMainThreadExecutor() {
+		return mainThreadExecutor;
+	}
+
 	//----------------------------------------------------------------------------------------------
 	// HeartbeatTarget methods
 	//----------------------------------------------------------------------------------------------
@@ -202,21 +195,7 @@ public class HeartbeatManagerImpl<I, O> implements HeartbeatManager<I, O> {
 					heartbeatListener.reportPayload(requestOrigin, heartbeatPayload);
 				}
 
-				CompletableFuture<O> futurePayload = heartbeatListener.retrievePayload(requestOrigin);
-
-				if (futurePayload != null) {
-					CompletableFuture<Void> sendHeartbeatFuture = futurePayload.thenAcceptAsync(
-						retrievedPayload ->	heartbeatTarget.receiveHeartbeat(getOwnResourceID(), retrievedPayload),
-						executor);
-
-					sendHeartbeatFuture.exceptionally((Throwable failure) -> {
-							log.warn("Could not send heartbeat to target with id {}.", requestOrigin, failure);
-
-							return null;
-						});
-				} else {
-					heartbeatTarget.receiveHeartbeat(ownResourceID, null);
-				}
+				heartbeatTarget.receiveHeartbeat(getOwnResourceID(), heartbeatListener.retrievePayload(requestOrigin));
 			}
 		}
 	}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerSenderImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerSenderImpl.java
index e3b939c068b..a61fe341928 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerSenderImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerSenderImpl.java
@@ -23,9 +23,6 @@ import org.apache.flink.runtime.concurrent.ScheduledExecutor;
 
 import org.slf4j.Logger;
 
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -37,25 +34,24 @@ import java.util.concurrent.TimeUnit;
  */
 public class HeartbeatManagerSenderImpl<I, O> extends HeartbeatManagerImpl<I, O> implements Runnable {
 
-	private final ScheduledFuture<?> triggerFuture;
+	private final long heartbeatPeriod;
 
-	public HeartbeatManagerSenderImpl(
+	HeartbeatManagerSenderImpl(
 			long heartbeatPeriod,
 			long heartbeatTimeout,
 			ResourceID ownResourceID,
 			HeartbeatListener<I, O> heartbeatListener,
-			Executor executor,
-			ScheduledExecutor scheduledExecutor,
+			ScheduledExecutor mainThreadExecutor,
 			Logger log) {
 		super(
 			heartbeatTimeout,
 			ownResourceID,
 			heartbeatListener,
-			executor,
-			scheduledExecutor,
+			mainThreadExecutor,
 			log);
 
-		triggerFuture = scheduledExecutor.scheduleAtFixedRate(this, 0L, heartbeatPeriod, TimeUnit.MILLISECONDS);
+		this.heartbeatPeriod = heartbeatPeriod;
+		mainThreadExecutor.schedule(this, 0L, TimeUnit.MILLISECONDS);
 	}
 
 	@Override
@@ -63,30 +59,17 @@ public class HeartbeatManagerSenderImpl<I, O> extends HeartbeatManagerImpl<I, O>
 		if (!stopped) {
 			log.debug("Trigger heartbeat request.");
 			for (HeartbeatMonitor<O> heartbeatMonitor : getHeartbeatTargets()) {
-				CompletableFuture<O> futurePayload = getHeartbeatListener().retrievePayload(heartbeatMonitor.getHeartbeatTargetId());
-				final HeartbeatTarget<O> heartbeatTarget = heartbeatMonitor.getHeartbeatTarget();
-
-				if (futurePayload != null) {
-					CompletableFuture<Void> requestHeartbeatFuture = futurePayload.thenAcceptAsync(
-						payload -> heartbeatTarget.requestHeartbeat(getOwnResourceID(), payload),
-						getExecutor());
-
-					requestHeartbeatFuture.exceptionally(
-						(Throwable failure) -> {
-							log.warn("Could not request the heartbeat from target {}.", heartbeatTarget, failure);
-
-							return null;
-						});
-				} else {
-					heartbeatTarget.requestHeartbeat(getOwnResourceID(), null);
-				}
+				requestHeartbeat(heartbeatMonitor);
 			}
+
+			getMainThreadExecutor().schedule(this, heartbeatPeriod, TimeUnit.MILLISECONDS);
 		}
 	}
 
-	@Override
-	public void stop() {
-			triggerFuture.cancel(true);
-			super.stop();
+	private void requestHeartbeat(HeartbeatMonitor<O> heartbeatMonitor) {
+		O payload = getHeartbeatListener().retrievePayload(heartbeatMonitor.getHeartbeatTargetId());
+		final HeartbeatTarget<O> heartbeatTarget = heartbeatMonitor.getHeartbeatTarget();
+
+		heartbeatTarget.requestHeartbeat(getOwnResourceID(), payload);
 	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatServices.java
index d87f7a8934b..ed1c2f94a8c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatServices.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/heartbeat/HeartbeatServices.java
@@ -52,7 +52,7 @@ public class HeartbeatServices {
 	 * @param resourceId Resource Id which identifies the owner of the heartbeat manager
 	 * @param heartbeatListener Listener which will be notified upon heartbeat timeouts for registered
 	 *                          targets
-	 * @param scheduledExecutor Scheduled executor to be used for scheduling heartbeat timeouts
+	 * @param mainThreadExecutor Scheduled executor to be used for scheduling heartbeat timeouts
 	 * @param log Logger to be used for the logging
 	 * @param <I> Type of the incoming payload
 	 * @param <O> Type of the outgoing payload
@@ -61,15 +61,14 @@ public class HeartbeatServices {
 	public <I, O> HeartbeatManager<I, O> createHeartbeatManager(
 		ResourceID resourceId,
 		HeartbeatListener<I, O> heartbeatListener,
-		ScheduledExecutor scheduledExecutor,
+		ScheduledExecutor mainThreadExecutor,
 		Logger log) {
 
 		return new HeartbeatManagerImpl<>(
 			heartbeatTimeout,
 			resourceId,
 			heartbeatListener,
-			scheduledExecutor,
-			scheduledExecutor,
+			mainThreadExecutor,
 			log);
 	}
 
@@ -79,7 +78,8 @@ public class HeartbeatServices {
 	 * @param resourceId Resource Id which identifies the owner of the heartbeat manager
 	 * @param heartbeatListener Listener which will be notified upon heartbeat timeouts for registered
 	 *                          targets
-	 * @param scheduledExecutor Scheduled executor to be used for scheduling heartbeat timeouts
+	 * @param mainThreadExecutor Scheduled executor to be used for scheduling heartbeat timeouts and
+	 *                           periodically send heartbeat requests
 	 * @param log Logger to be used for the logging
 	 * @param <I> Type of the incoming payload
 	 * @param <O> Type of the outgoing payload
@@ -88,7 +88,7 @@ public class HeartbeatServices {
 	public <I, O> HeartbeatManager<I, O> createHeartbeatManagerSender(
 		ResourceID resourceId,
 		HeartbeatListener<I, O> heartbeatListener,
-		ScheduledExecutor scheduledExecutor,
+		ScheduledExecutor mainThreadExecutor,
 		Logger log) {
 
 		return new HeartbeatManagerSenderImpl<>(
@@ -96,8 +96,7 @@ public class HeartbeatServices {
 			heartbeatTimeout,
 			resourceId,
 			heartbeatListener,
-			scheduledExecutor,
-			scheduledExecutor,
+			mainThreadExecutor,
 			log);
 	}
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
index aeab67f46b1..ae903fe6c27 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java
@@ -85,7 +85,6 @@ import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.InstantiationUtil;
-import org.apache.flink.util.Preconditions;
 
 import org.slf4j.Logger;
 
@@ -139,11 +138,9 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 
 	private final BlobWriter blobWriter;
 
-	private final JobManagerJobMetricGroupFactory jobMetricGroupFactory;
-
-	private final HeartbeatManager<AccumulatorReport, AllocatedSlotReport> taskManagerHeartbeatManager;
+	private final HeartbeatServices heartbeatServices;
 
-	private final HeartbeatManager<Void, Void> resourceManagerHeartbeatManager;
+	private final JobManagerJobMetricGroupFactory jobMetricGroupFactory;
 
 	private final ScheduledExecutorService scheduledExecutorService;
 
@@ -175,6 +172,10 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 
 	// -------- Mutable fields ---------
 
+	private HeartbeatManager<AccumulatorReport, AllocatedSlotReport> taskManagerHeartbeatManager;
+
+	private HeartbeatManager<Void, Void> resourceManagerHeartbeatManager;
+
 	private SchedulerNG schedulerNG;
 
 	@Nullable
@@ -215,8 +216,6 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 
 		super(rpcService, AkkaRpcServiceUtils.createRandomName(JOB_MANAGER_NAME));
 
-		final JobMasterGateway selfGateway = getSelfGateway(JobMasterGateway.class);
-
 		this.jobMasterConfiguration = checkNotNull(jobMasterConfiguration);
 		this.resourceId = checkNotNull(resourceId);
 		this.jobGraph = checkNotNull(jobGraph);
@@ -228,20 +227,9 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 		this.fatalErrorHandler = checkNotNull(fatalErrorHandler);
 		this.userCodeLoader = checkNotNull(userCodeLoader);
 		this.schedulerNGFactory = checkNotNull(schedulerNGFactory);
+		this.heartbeatServices = checkNotNull(heartbeatServices);
 		this.jobMetricGroupFactory = checkNotNull(jobMetricGroupFactory);
 
-		this.taskManagerHeartbeatManager = heartbeatServices.createHeartbeatManagerSender(
-			resourceId,
-			new TaskManagerHeartbeatListener(selfGateway),
-			rpcService.getScheduledExecutor(),
-			log);
-
-		this.resourceManagerHeartbeatManager = heartbeatServices.createHeartbeatManager(
-				resourceId,
-				new ResourceManagerHeartbeatListener(),
-				rpcService.getScheduledExecutor(),
-				log);
-
 		final String jobName = jobGraph.getName();
 		final JobID jid = jobGraph.getJobID();
 
@@ -340,9 +328,6 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 			disconnectTaskManager(taskManagerResourceId, cause);
 		}
 
-		taskManagerHeartbeatManager.stop();
-		resourceManagerHeartbeatManager.stop();
-
 		// make sure there is a graceful exit
 		suspendExecution(new FlinkException("JobManager is shutting down."));
 
@@ -709,6 +694,8 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 	}
 
 	private void startJobMasterServices() throws Exception {
+		startHeartbeatServices();
+
 		// start the slot pool make sure the slot pool now accepts messages for this leader
 		slotPool.start(getFencingToken(), getAddress(), getMainThreadExecutor());
 		scheduler.start(getMainThreadExecutor());
@@ -772,9 +759,37 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 		// disconnect from resource manager:
 		closeResourceManagerConnection(cause);
 
+		stopHeartbeatServices();
+
 		return Acknowledge.get();
 	}
 
+	private void stopHeartbeatServices() {
+		if (taskManagerHeartbeatManager != null) {
+			taskManagerHeartbeatManager.stop();
+			taskManagerHeartbeatManager = null;
+		}
+
+		if (resourceManagerHeartbeatManager != null) {
+			resourceManagerHeartbeatManager.stop();
+			resourceManagerHeartbeatManager = null;
+		}
+	}
+
+	private void startHeartbeatServices() {
+		taskManagerHeartbeatManager = heartbeatServices.createHeartbeatManagerSender(
+			resourceId,
+			new TaskManagerHeartbeatListener(),
+			getMainThreadExecutor(),
+			log);
+
+		resourceManagerHeartbeatManager = heartbeatServices.createHeartbeatManager(
+			resourceId,
+			new ResourceManagerHeartbeatListener(),
+			getMainThreadExecutor(),
+			log);
+	}
+
 	private void assignScheduler(
 			SchedulerNG newScheduler,
 			JobManagerJobMetricGroup newJobManagerJobMetricGroup) {
@@ -1105,29 +1120,26 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 
 	private class TaskManagerHeartbeatListener implements HeartbeatListener<AccumulatorReport, AllocatedSlotReport> {
 
-		private final JobMasterGateway jobMasterGateway;
-
-		private TaskManagerHeartbeatListener(JobMasterGateway jobMasterGateway) {
-			this.jobMasterGateway = Preconditions.checkNotNull(jobMasterGateway);
-		}
-
 		@Override
 		public void notifyHeartbeatTimeout(ResourceID resourceID) {
-			jobMasterGateway.disconnectTaskManager(
+			validateRunsInMainThread();
+			disconnectTaskManager(
 				resourceID,
 				new TimeoutException("Heartbeat of TaskManager with id " + resourceID + " timed out."));
 		}
 
 		@Override
 		public void reportPayload(ResourceID resourceID, AccumulatorReport payload) {
+			validateRunsInMainThread();
 			for (AccumulatorSnapshot snapshot : payload.getAccumulatorSnapshots()) {
 				schedulerNG.updateAccumulators(snapshot);
 			}
 		}
 
 		@Override
-		public CompletableFuture<AllocatedSlotReport> retrievePayload(ResourceID resourceID) {
-			return callAsync(() -> slotPool.createAllocatedSlotReport(resourceID), RpcUtils.INF_TIMEOUT);
+		public AllocatedSlotReport retrievePayload(ResourceID resourceID) {
+			validateRunsInMainThread();
+			return slotPool.createAllocatedSlotReport(resourceID);
 		}
 	}
 
@@ -1135,15 +1147,14 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 
 		@Override
 		public void notifyHeartbeatTimeout(final ResourceID resourceId) {
-			runAsync(() -> {
-				log.info("The heartbeat of ResourceManager with id {} timed out.", resourceId);
+			validateRunsInMainThread();
+			log.info("The heartbeat of ResourceManager with id {} timed out.", resourceId);
 
-				if (establishedResourceManagerConnection != null && establishedResourceManagerConnection.getResourceManagerResourceID().equals(resourceId)) {
-					reconnectToResourceManager(
-						new JobMasterException(
-							String.format("The heartbeat of ResourceManager with id %s timed out.", resourceId)));
-				}
-			});
+			if (establishedResourceManagerConnection != null && establishedResourceManagerConnection.getResourceManagerResourceID().equals(resourceId)) {
+				reconnectToResourceManager(
+					new JobMasterException(
+						String.format("The heartbeat of ResourceManager with id %s timed out.", resourceId)));
+			}
 		}
 
 		@Override
@@ -1152,8 +1163,8 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast
 		}
 
 		@Override
-		public CompletableFuture<Void> retrievePayload(ResourceID resourceID) {
-			return CompletableFuture.completedFuture(null);
+		public Void retrievePayload(ResourceID resourceID) {
+			return null;
 		}
 	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
index 441cbbda41d..0ed9247c32e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
@@ -120,11 +120,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 	/** High availability services for leader retrieval and election. */
 	private final HighAvailabilityServices highAvailabilityServices;
 
-	/** The heartbeat manager with task managers. */
-	private final HeartbeatManager<SlotReport, Void> taskManagerHeartbeatManager;
-
-	/** The heartbeat manager with job managers. */
-	private final HeartbeatManager<Void, Void> jobManagerHeartbeatManager;
+	private final HeartbeatServices heartbeatServices;
 
 	/** Registry to use for metrics. */
 	private final MetricRegistry metricRegistry;
@@ -142,6 +138,12 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 	/** The service to elect a ResourceManager leader. */
 	private LeaderElectionService leaderElectionService;
 
+	/** The heartbeat manager with task managers. */
+	private HeartbeatManager<SlotReport, Void> taskManagerHeartbeatManager;
+
+	/** The heartbeat manager with job managers. */
+	private HeartbeatManager<Void, Void> jobManagerHeartbeatManager;
+
 	/**
 	 * Represents asynchronous state clearing work.
 	 *
@@ -167,6 +169,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
 		this.resourceId = checkNotNull(resourceId);
 		this.highAvailabilityServices = checkNotNull(highAvailabilityServices);
+		this.heartbeatServices = checkNotNull(heartbeatServices);
 		this.slotManager = checkNotNull(slotManager);
 		this.metricRegistry = checkNotNull(metricRegistry);
 		this.jobLeaderIdService = checkNotNull(jobLeaderIdService);
@@ -174,18 +177,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 		this.fatalErrorHandler = checkNotNull(fatalErrorHandler);
 		this.jobManagerMetricGroup = checkNotNull(jobManagerMetricGroup);
 
-		this.taskManagerHeartbeatManager = heartbeatServices.createHeartbeatManagerSender(
-			resourceId,
-			new TaskManagerHeartbeatListener(),
-			rpcService.getScheduledExecutor(),
-			log);
-
-		this.jobManagerHeartbeatManager = heartbeatServices.createHeartbeatManagerSender(
-			resourceId,
-			new JobManagerHeartbeatListener(),
-			rpcService.getScheduledExecutor(),
-			log);
-
 		this.jobManagerRegistrations = new HashMap<>(4);
 		this.jmResourceIdRegistrations = new HashMap<>(4);
 		this.taskExecutors = new HashMap<>(8);
@@ -249,9 +240,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 	private void stopResourceManagerServices() throws Exception {
 		Exception exception = null;
 
-		taskManagerHeartbeatManager.stop();
-
-		jobManagerHeartbeatManager.stop();
+		stopHeartbeatServices();
 
 		try {
 			slotManager.close();
@@ -933,6 +922,8 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
 			setFencingToken(newResourceManagerId);
 
+			startHeartbeatServices();
+
 			slotManager.start(getFencingToken(), getMainThreadExecutor(), new ResourceActionsImpl());
 
 			return prepareLeadershipAsync().thenApply(ignored -> true);
@@ -955,9 +946,37 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 				setFencingToken(null);
 
 				slotManager.suspend();
+
+				stopHeartbeatServices();
 			});
 	}
 
+	private void startHeartbeatServices() {
+		taskManagerHeartbeatManager = heartbeatServices.createHeartbeatManagerSender(
+			resourceId,
+			new TaskManagerHeartbeatListener(),
+			getMainThreadExecutor(),
+			log);
+
+		jobManagerHeartbeatManager = heartbeatServices.createHeartbeatManagerSender(
+			resourceId,
+			new JobManagerHeartbeatListener(),
+			getMainThreadExecutor(),
+			log);
+	}
+
+	private void stopHeartbeatServices() {
+		if (taskManagerHeartbeatManager != null) {
+			taskManagerHeartbeatManager.stop();
+			taskManagerHeartbeatManager = null;
+		}
+
+		if (jobManagerHeartbeatManager != null) {
+			jobManagerHeartbeatManager.stop();
+			jobManagerHeartbeatManager = null;
+		}
+	}
+
 	/**
 	 * Handles error occurring in the leader election service.
 	 *
@@ -1103,36 +1122,31 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
 		@Override
 		public void notifyHeartbeatTimeout(final ResourceID resourceID) {
-			runAsync(new Runnable() {
-				@Override
-				public void run() {
-					log.info("The heartbeat of TaskManager with id {} timed out.", resourceID);
+			validateRunsInMainThread();
+			log.info("The heartbeat of TaskManager with id {} timed out.", resourceID);
 
-					closeTaskManagerConnection(
-							resourceID,
-							new TimeoutException("The heartbeat of TaskManager with id " + resourceID + "  timed out."));
-				}
-			});
+			closeTaskManagerConnection(
+				resourceID,
+				new TimeoutException("The heartbeat of TaskManager with id " + resourceID + "  timed out."));
 		}
 
 		@Override
-		public void reportPayload(final ResourceID resourceID, final SlotReport slotReport) {
-			runAsync(() -> {
-				final WorkerRegistration<WorkerType> workerRegistration = taskExecutors.get(resourceID);
+		public void reportPayload(final ResourceID resourceID, final SlotReport payload) {
+			validateRunsInMainThread();
+			final WorkerRegistration<WorkerType> workerRegistration = taskExecutors.get(resourceID);
 
-				if (workerRegistration == null) {
-					log.debug("Received slot report from TaskManager {} which is no longer registered.", resourceID);
-				} else {
-					InstanceID instanceId = workerRegistration.getInstanceID();
+			if (workerRegistration == null) {
+				log.debug("Received slot report from TaskManager {} which is no longer registered.", resourceID);
+			} else {
+				InstanceID instanceId = workerRegistration.getInstanceID();
 
-					slotManager.reportSlotStatus(instanceId, slotReport);
-				}
-			});
+				slotManager.reportSlotStatus(instanceId, payload);
+			}
 		}
 
 		@Override
-		public CompletableFuture<Void> retrievePayload(ResourceID resourceID) {
-			return CompletableFuture.completedFuture(null);
+		public Void retrievePayload(ResourceID resourceID) {
+			return null;
 		}
 	}
 
@@ -1140,19 +1154,18 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
 		@Override
 		public void notifyHeartbeatTimeout(final ResourceID resourceID) {
-			runAsync(() -> {
-				log.info("The heartbeat of JobManager with id {} timed out.", resourceID);
+			validateRunsInMainThread();
+			log.info("The heartbeat of JobManager with id {} timed out.", resourceID);
 
-				if (jmResourceIdRegistrations.containsKey(resourceID)) {
-					JobManagerRegistration jobManagerRegistration = jmResourceIdRegistrations.get(resourceID);
+			if (jmResourceIdRegistrations.containsKey(resourceID)) {
+				JobManagerRegistration jobManagerRegistration = jmResourceIdRegistrations.get(resourceID);
 
-					if (jobManagerRegistration != null) {
-						closeJobManagerConnection(
-							jobManagerRegistration.getJobID(),
-							new TimeoutException("The heartbeat of JobManager with id " + resourceID + " timed out."));
-					}
+				if (jobManagerRegistration != null) {
+					closeJobManagerConnection(
+						jobManagerRegistration.getJobID(),
+						new TimeoutException("The heartbeat of JobManager with id " + resourceID + " timed out."));
 				}
-			});
+			}
 		}
 
 		@Override
@@ -1161,8 +1174,8 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 		}
 
 		@Override
-		public CompletableFuture<Void> retrievePayload(ResourceID resourceID) {
-			return CompletableFuture.completedFuture(null);
+		public Void retrievePayload(ResourceID resourceID) {
+			return null;
 		}
 	}
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java
index 5f3f485c2aa..1e958420b3a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutor.java
@@ -150,11 +150,7 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 	/** The task manager configuration. */
 	private final TaskManagerConfiguration taskManagerConfiguration;
 
-	/** The heartbeat manager for job manager in the task manager. */
-	private final HeartbeatManager<AllocatedSlotReport, AccumulatorReport> jobManagerHeartbeatManager;
-
-	/** The heartbeat manager for resource manager in the task manager. */
-	private final HeartbeatManager<Void, SlotReport> resourceManagerHeartbeatManager;
+	private final HeartbeatServices heartbeatServices;
 
 	/** The fatal error handler to use in case of a fatal error. */
 	private final FatalErrorHandler fatalErrorHandler;
@@ -201,6 +197,12 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 
 	private FileCache fileCache;
 
+	/** The heartbeat manager for job manager in the task manager. */
+	private HeartbeatManager<AllocatedSlotReport, AccumulatorReport> jobManagerHeartbeatManager;
+
+	/** The heartbeat manager for resource manager in the task manager. */
+	private HeartbeatManager<Void, SlotReport> resourceManagerHeartbeatManager;
+
 	// --------- resource manager --------
 
 	@Nullable
@@ -233,6 +235,7 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 		checkArgument(taskManagerConfiguration.getNumberSlots() > 0, "The number of slots has to be larger than 0.");
 
 		this.taskManagerConfiguration = checkNotNull(taskManagerConfiguration);
+		this.heartbeatServices = checkNotNull(heartbeatServices);
 		this.taskExecutorServices = checkNotNull(taskExecutorServices);
 		this.haServices = checkNotNull(haServices);
 		this.fatalErrorHandler = checkNotNull(fatalErrorHandler);
@@ -251,20 +254,6 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 
 		this.jobManagerConnections = new HashMap<>(4);
 
-		final ResourceID resourceId = taskExecutorServices.getTaskManagerLocation().getResourceID();
-
-		this.jobManagerHeartbeatManager = heartbeatServices.createHeartbeatManager(
-			resourceId,
-			new JobManagerHeartbeatListener(),
-			rpcService.getScheduledExecutor(),
-			log);
-
-		this.resourceManagerHeartbeatManager = heartbeatServices.createHeartbeatManager(
-			resourceId,
-			new ResourceManagerHeartbeatListener(),
-			rpcService.getScheduledExecutor(),
-			log);
-
 		this.hardwareDescription = HardwareDescription.extractFromSystem(
 			taskExecutorServices.getMemoryManager().getMemorySize());
 
@@ -299,6 +288,8 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 
 	private void startTaskExecutorServices() throws Exception {
 		try {
+			startHeartbeatServices();
+
 			// start by connecting to the ResourceManager
 			resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());
 
@@ -345,10 +336,6 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 			}
 		}
 
-		jobManagerHeartbeatManager.stop();
-
-		resourceManagerHeartbeatManager.stop();
-
 		try {
 			stopTaskExecutorServices();
 		} catch (Exception e) {
@@ -395,9 +382,38 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 		// it will call close() recursively from the parent to children
 		taskManagerMetricGroup.close();
 
+		stopHeartbeatServices();
+
 		ExceptionUtils.tryRethrowException(exception);
 	}
 
+	private void startHeartbeatServices() {
+		final ResourceID resourceId = taskExecutorServices.getTaskManagerLocation().getResourceID();
+		jobManagerHeartbeatManager = heartbeatServices.createHeartbeatManager(
+			resourceId,
+			new JobManagerHeartbeatListener(),
+			getMainThreadExecutor(),
+			log);
+
+		resourceManagerHeartbeatManager = heartbeatServices.createHeartbeatManager(
+			resourceId,
+			new ResourceManagerHeartbeatListener(),
+			getMainThreadExecutor(),
+			log);
+	}
+
+	private void stopHeartbeatServices() {
+		if (jobManagerHeartbeatManager != null) {
+			jobManagerHeartbeatManager.stop();
+			jobManagerHeartbeatManager = null;
+		}
+
+		if (resourceManagerHeartbeatManager != null) {
+			resourceManagerHeartbeatManager.stop();
+			resourceManagerHeartbeatManager = null;
+		}
+	}
+
 	// ======================================================================
 	//  RPC methods
 	// ======================================================================
@@ -1668,30 +1684,30 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 
 		@Override
 		public void notifyHeartbeatTimeout(final ResourceID resourceID) {
-			runAsync(() -> {
-				log.info("The heartbeat of JobManager with id {} timed out.", resourceID);
+			validateRunsInMainThread();
+			log.info("The heartbeat of JobManager with id {} timed out.", resourceID);
 
-				if (jobManagerConnections.containsKey(resourceID)) {
-					JobManagerConnection jobManagerConnection = jobManagerConnections.get(resourceID);
+			if (jobManagerConnections.containsKey(resourceID)) {
+				JobManagerConnection jobManagerConnection = jobManagerConnections.get(resourceID);
 
-					if (jobManagerConnection != null) {
-						closeJobManagerConnection(
-							jobManagerConnection.getJobID(),
-							new TimeoutException("The heartbeat of JobManager with id " + resourceID + " timed out."));
+				if (jobManagerConnection != null) {
+					closeJobManagerConnection(
+						jobManagerConnection.getJobID(),
+						new TimeoutException("The heartbeat of JobManager with id " + resourceID + " timed out."));
 
-						jobLeaderService.reconnect(jobManagerConnection.getJobID());
-					}
+					jobLeaderService.reconnect(jobManagerConnection.getJobID());
 				}
-			});
+			}
 		}
 
 		@Override
 		public void reportPayload(ResourceID resourceID, AllocatedSlotReport allocatedSlotReport) {
-			runAsync(() -> syncSlotsWithSnapshotFromJobMaster(allocatedSlotReport));
+			validateRunsInMainThread();
+			syncSlotsWithSnapshotFromJobMaster(allocatedSlotReport);
 		}
 
 		@Override
-		public CompletableFuture<AccumulatorReport> retrievePayload(ResourceID resourceID) {
+		public AccumulatorReport retrievePayload(ResourceID resourceID) {
 			validateRunsInMainThread();
 			JobManagerConnection jobManagerConnection = jobManagerConnections.get(resourceID);
 			if (jobManagerConnection != null) {
@@ -1704,9 +1720,9 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 					Task task = allTasks.next();
 					accumulatorSnapshots.add(task.getAccumulatorRegistry().getSnapshot());
 				}
-				return CompletableFuture.completedFuture(new AccumulatorReport(accumulatorSnapshots));
+				return new AccumulatorReport(accumulatorSnapshots);
 			} else {
-				return CompletableFuture.completedFuture(new AccumulatorReport(Collections.emptyList()));
+				return new AccumulatorReport(Collections.emptyList());
 			}
 		}
 	}
@@ -1715,17 +1731,16 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 
 		@Override
 		public void notifyHeartbeatTimeout(final ResourceID resourceId) {
-			runAsync(() -> {
-				// first check whether the timeout is still valid
-				if (establishedResourceManagerConnection != null && establishedResourceManagerConnection.getResourceManagerResourceId().equals(resourceId)) {
-					log.info("The heartbeat of ResourceManager with id {} timed out.", resourceId);
+			validateRunsInMainThread();
+			// first check whether the timeout is still valid
+			if (establishedResourceManagerConnection != null && establishedResourceManagerConnection.getResourceManagerResourceId().equals(resourceId)) {
+				log.info("The heartbeat of ResourceManager with id {} timed out.", resourceId);
 
-					reconnectToResourceManager(new TaskManagerException(
-						String.format("The heartbeat of ResourceManager with id %s timed out.", resourceId)));
-				} else {
-					log.debug("Received heartbeat timeout for outdated ResourceManager id {}. Ignoring the timeout.", resourceId);
-				}
-			});
+				reconnectToResourceManager(new TaskManagerException(
+					String.format("The heartbeat of ResourceManager with id %s timed out.", resourceId)));
+			} else {
+				log.debug("Received heartbeat timeout for outdated ResourceManager id {}. Ignoring the timeout.", resourceId);
+			}
 		}
 
 		@Override
@@ -1734,10 +1749,9 @@ public class TaskExecutor extends RpcEndpoint implements TaskExecutorGateway {
 		}
 
 		@Override
-		public CompletableFuture<SlotReport> retrievePayload(ResourceID resourceID) {
-			return callAsync(
-					() -> taskSlotTable.createSlotReport(getResourceID()),
-					taskManagerConfiguration.getTimeout());
+		public SlotReport retrievePayload(ResourceID resourceID) {
+			validateRunsInMainThread();
+			return taskSlotTable.createSlotReport(getResourceID());
 		}
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerTest.java
index f8bfa9443cb..ab1ec071fc7 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/HeartbeatManagerTest.java
@@ -20,15 +20,19 @@ package org.apache.flink.runtime.heartbeat;
 
 import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
-import org.apache.flink.runtime.concurrent.Executors;
 import org.apache.flink.runtime.concurrent.ScheduledExecutor;
 import org.apache.flink.runtime.concurrent.ScheduledExecutorServiceAdapter;
+import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.util.TestLogger;
 
+import org.hamcrest.Matcher;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ScheduledExecutorService;
@@ -36,15 +40,18 @@ import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.hamcrest.Matchers.greaterThanOrEqualTo;
+import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.atLeast;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
@@ -62,40 +69,40 @@ public class HeartbeatManagerTest extends TestLogger {
 	 * {@link HeartbeatListener}.
 	 */
 	@Test
-	public void testRegularHeartbeat() {
-		long heartbeatTimeout = 1000L;
+	public void testRegularHeartbeat() throws InterruptedException {
+		final long heartbeatTimeout = 1000L;
 		ResourceID ownResourceID = new ResourceID("foobar");
 		ResourceID targetResourceID = new ResourceID("barfoo");
-		@SuppressWarnings("unchecked")
-		HeartbeatListener<Object, Object> heartbeatListener = mock(HeartbeatListener.class);
-		ScheduledExecutor scheduledExecutor = mock(ScheduledExecutor.class);
-
-		Object expectedObject = new Object();
-
-		when(heartbeatListener.retrievePayload(any(ResourceID.class))).thenReturn(CompletableFuture.completedFuture(expectedObject));
-
-		HeartbeatManagerImpl<Object, Object> heartbeatManager = new HeartbeatManagerImpl<>(
+		final int outputPayload = 42;
+		final ArrayBlockingQueue<String> reportedPayloads = new ArrayBlockingQueue<>(2);
+		final TestingHeartbeatListener<String, Integer> heartbeatListener = new TestingHeartbeatListenerBuilder<String, Integer>()
+			.setReportPayloadConsumer((ignored, payload) -> reportedPayloads.offer(payload))
+			.setRetrievePayloadFunction((ignored) -> outputPayload)
+			.createNewTestingHeartbeatListener();
+
+		HeartbeatManagerImpl<String, Integer> heartbeatManager = new HeartbeatManagerImpl<>(
 			heartbeatTimeout,
 			ownResourceID,
 			heartbeatListener,
-			Executors.directExecutor(),
-			scheduledExecutor,
+			TestingUtils.defaultScheduledExecutor(),
 			LOG);
 
-		@SuppressWarnings("unchecked")
-		HeartbeatTarget<Object> heartbeatTarget = mock(HeartbeatTarget.class);
+		final ArrayBlockingQueue<Integer> reportedPayloadsHeartbeatTarget = new ArrayBlockingQueue<>(2);
+		final TestingHeartbeatTarget<Integer> heartbeatTarget = new TestingHeartbeatTargetBuilder<Integer>()
+			.setReceiveHeartbeatConsumer((ignoredA, payload) -> reportedPayloadsHeartbeatTarget.offer(payload))
+			.createTestingHeartbeatTarget();
 
 		heartbeatManager.monitorTarget(targetResourceID, heartbeatTarget);
 
-		heartbeatManager.requestHeartbeat(targetResourceID, expectedObject);
+		final String inputPayload1 = "foobar";
+		heartbeatManager.requestHeartbeat(targetResourceID, inputPayload1);
 
-		verify(heartbeatListener, times(1)).reportPayload(targetResourceID, expectedObject);
-		verify(heartbeatListener, times(1)).retrievePayload(any(ResourceID.class));
-		verify(heartbeatTarget, times(1)).receiveHeartbeat(ownResourceID, expectedObject);
+		assertThat(reportedPayloads.take(), is(inputPayload1));
+		assertThat(reportedPayloadsHeartbeatTarget.take(), is(outputPayload));
 
-		heartbeatManager.receiveHeartbeat(targetResourceID, expectedObject);
-
-		verify(heartbeatListener, times(2)).reportPayload(targetResourceID, expectedObject);
+		final String inputPayload2 = "barfoo";
+		heartbeatManager.receiveHeartbeat(targetResourceID, inputPayload2);
+		assertThat(reportedPayloads.take(), is(inputPayload2));
 	}
 
 	/**
@@ -121,7 +128,6 @@ public class HeartbeatManagerTest extends TestLogger {
 			heartbeatTimeout,
 			ownResourceID,
 			heartbeatListener,
-			Executors.directExecutor(),
 			scheduledExecutor,
 			LOG);
 
@@ -150,7 +156,7 @@ public class HeartbeatManagerTest extends TestLogger {
 
 		ResourceID ownResourceID = new ResourceID("foobar");
 		ResourceID targetResourceID = new ResourceID("barfoo");
-		TestingHeartbeatListener heartbeatListener = new TestingHeartbeatListener(payload);
+		SimpleTestingHeartbeatListener heartbeatListener = new SimpleTestingHeartbeatListener(payload);
 		ScheduledExecutorService scheduledExecutorService = mock(ScheduledExecutorService.class);
 		ScheduledFuture<?> scheduledFuture = mock(ScheduledFuture.class);
 
@@ -162,7 +168,6 @@ public class HeartbeatManagerTest extends TestLogger {
 			heartbeatTimeout,
 			ownResourceID,
 			heartbeatListener,
-			Executors.directExecutor(),
 			new ScheduledExecutorServiceAdapter(new ScheduledThreadPoolExecutor(1)),
 			LOG);
 
@@ -197,53 +202,57 @@ public class HeartbeatManagerTest extends TestLogger {
 	public void testHeartbeatCluster() throws Exception {
 		long heartbeatTimeout = 100L;
 		long heartbeatPeriod = 20L;
-		Object object = new Object();
-		Object object2 = new Object();
-		ResourceID resourceID = new ResourceID("foobar");
-		ResourceID resourceID2 = new ResourceID("barfoo");
-		@SuppressWarnings("unchecked")
-		HeartbeatListener<Object, Object> heartbeatListener = mock(HeartbeatListener.class);
-
-		when(heartbeatListener.retrievePayload(any(ResourceID.class))).thenReturn(CompletableFuture.completedFuture(object));
-
-		TestingHeartbeatListener heartbeatListener2 = new TestingHeartbeatListener(object2);
-
-		CompletableFuture<ResourceID> futureTimeout = heartbeatListener2.getTimeoutFuture();
-
-		HeartbeatManagerImpl<Object, Object> heartbeatManager = new HeartbeatManagerImpl<>(
+		ResourceID resourceIdTarget = new ResourceID("foobar");
+		ResourceID resourceIDSender = new ResourceID("barfoo");
+		final int targetPayload = 42;
+		final AtomicInteger numReportPayloadCallsTarget = new AtomicInteger(0);
+		final TestingHeartbeatListener<String, Integer> heartbeatListenerTarget = new TestingHeartbeatListenerBuilder<String, Integer>()
+			.setRetrievePayloadFunction(ignored -> targetPayload)
+			.setReportPayloadConsumer((ignoredA, ignoredB) -> numReportPayloadCallsTarget.incrementAndGet())
+			.createNewTestingHeartbeatListener();
+
+		final String senderPayload = "1337";
+		final CompletableFuture<ResourceID> targetHeartbeatTimeoutFuture = new CompletableFuture<>();
+		final AtomicInteger numReportPayloadCallsSender = new AtomicInteger(0);
+		final TestingHeartbeatListener<Integer, String> heartbeatListenerSender = new TestingHeartbeatListenerBuilder<Integer, String>()
+			.setRetrievePayloadFunction(ignored -> senderPayload)
+			.setNotifyHeartbeatTimeoutConsumer(targetHeartbeatTimeoutFuture::complete)
+			.setReportPayloadConsumer((ignoredA, ignoredB) -> numReportPayloadCallsSender.incrementAndGet())
+			.createNewTestingHeartbeatListener();
+
+		HeartbeatManagerImpl<String, Integer> heartbeatManagerTarget = new HeartbeatManagerImpl<>(
 			heartbeatTimeout,
-			resourceID,
-			heartbeatListener,
-			Executors.directExecutor(),
-			new ScheduledExecutorServiceAdapter(new ScheduledThreadPoolExecutor(1)),
+			resourceIdTarget,
+			heartbeatListenerTarget,
+			TestingUtils.defaultScheduledExecutor(),
 			LOG);
 
-		HeartbeatManagerSenderImpl<Object, Object> heartbeatManager2 = new HeartbeatManagerSenderImpl<>(
+		HeartbeatManagerSenderImpl<Integer, String> heartbeatManagerSender = new HeartbeatManagerSenderImpl<>(
 			heartbeatPeriod,
 			heartbeatTimeout,
-			resourceID2,
-			heartbeatListener2,
-			Executors.directExecutor(),
-			new ScheduledExecutorServiceAdapter(new ScheduledThreadPoolExecutor(1)),
+			resourceIDSender,
+			heartbeatListenerSender,
+			TestingUtils.defaultScheduledExecutor(),
 			LOG);
 
-		heartbeatManager.monitorTarget(resourceID2, heartbeatManager2);
-		heartbeatManager2.monitorTarget(resourceID, heartbeatManager);
+		heartbeatManagerTarget.monitorTarget(resourceIDSender, heartbeatManagerSender);
+		heartbeatManagerSender.monitorTarget(resourceIdTarget, heartbeatManagerTarget);
 
 		Thread.sleep(2 * heartbeatTimeout);
 
-		assertFalse(futureTimeout.isDone());
+		assertFalse(targetHeartbeatTimeoutFuture.isDone());
 
-		heartbeatManager.stop();
+		heartbeatManagerTarget.stop();
 
-		ResourceID timeoutResourceID = futureTimeout.get(2 * heartbeatTimeout, TimeUnit.MILLISECONDS);
+		ResourceID timeoutResourceID = targetHeartbeatTimeoutFuture.get(2 * heartbeatTimeout, TimeUnit.MILLISECONDS);
 
-		assertEquals(resourceID, timeoutResourceID);
+		assertThat(timeoutResourceID, is(resourceIdTarget));
 
 		int numberHeartbeats = (int) (2 * heartbeatTimeout / heartbeatPeriod);
 
-		verify(heartbeatListener, atLeast(numberHeartbeats / 2)).reportPayload(resourceID2, object2);
-		assertTrue(heartbeatListener2.getNumberHeartbeatReports() >= numberHeartbeats / 2);
+		final Matcher<Integer> numberHeartbeatsMatcher = greaterThanOrEqualTo(numberHeartbeats / 2);
+		assertThat(numReportPayloadCallsTarget.get(), is(numberHeartbeatsMatcher));
+		assertThat(numReportPayloadCallsSender.get(), is(numberHeartbeatsMatcher));
 	}
 
 	/**
@@ -257,13 +266,12 @@ public class HeartbeatManagerTest extends TestLogger {
 		ResourceID targetID = new ResourceID("target");
 		Object object = new Object();
 
-		TestingHeartbeatListener heartbeatListener = new TestingHeartbeatListener(object);
+		SimpleTestingHeartbeatListener heartbeatListener = new SimpleTestingHeartbeatListener(object);
 
 		HeartbeatManager<Object, Object> heartbeatManager = new HeartbeatManagerImpl<>(
 			heartbeatTimeout,
 			resourceID,
 			heartbeatListener,
-			Executors.directExecutor(),
 			new ScheduledExecutorServiceAdapter(new ScheduledThreadPoolExecutor(1)),
 			LOG);
 
@@ -297,7 +305,6 @@ public class HeartbeatManagerTest extends TestLogger {
 			heartbeatTimeout,
 			resourceId,
 			heartbeatListener,
-			Executors.directExecutor(),
 			mock(ScheduledExecutor.class),
 			LOG);
 
@@ -325,7 +332,6 @@ public class HeartbeatManagerTest extends TestLogger {
 			heartbeatTimeout,
 			resourceId,
 			heartbeatListener,
-			Executors.directExecutor(),
 			mock(ScheduledExecutor.class),
 			LOG);
 
@@ -349,23 +355,35 @@ public class HeartbeatManagerTest extends TestLogger {
 	 * {@link HeartbeatManagerImpl}.
 	 */
 	@Test
-	public void testHeartbeatManagerTargetPayload() {
+	public void testHeartbeatManagerTargetPayload() throws Exception {
 		final long heartbeatTimeout = 100L;
 
 		final ResourceID someTargetId = ResourceID.generate();
 		final ResourceID specialTargetId = ResourceID.generate();
-		final TargetDependentHeartbeatReceiver someHeartbeatTarget = new TargetDependentHeartbeatReceiver();
-		final TargetDependentHeartbeatReceiver specialHeartbeatTarget = new TargetDependentHeartbeatReceiver();
 
-		final int defaultResponse = 0;
-		final int specialResponse = 1;
+		final Map<ResourceID, Integer> payloads = new HashMap<>(2);
+		payloads.put(someTargetId, 0);
+		payloads.put(specialTargetId, 1);
+
+		final CompletableFuture<Integer> someHeartbeatPayloadFuture = new CompletableFuture<>();
+		final TestingHeartbeatTarget<Integer> someHeartbeatTarget = new TestingHeartbeatTargetBuilder<Integer>()
+			.setReceiveHeartbeatConsumer((ignored, payload) -> someHeartbeatPayloadFuture.complete(payload))
+			.createTestingHeartbeatTarget();
+
+		final CompletableFuture<Integer> specialHeartbeatPayloadFuture = new CompletableFuture<>();
+		final TestingHeartbeatTarget<Integer> specialHeartbeatTarget = new TestingHeartbeatTargetBuilder<Integer>()
+			.setReceiveHeartbeatConsumer((ignored, payload) -> specialHeartbeatPayloadFuture.complete(payload))
+			.createTestingHeartbeatTarget();
+
+		final TestingHeartbeatListener<Void, Integer> testingHeartbeatListener = new TestingHeartbeatListenerBuilder<Void, Integer>()
+			.setRetrievePayloadFunction(payloads::get)
+			.createNewTestingHeartbeatListener();
 
 		HeartbeatManager<?, Integer> heartbeatManager = new HeartbeatManagerImpl<>(
 			heartbeatTimeout,
 			ResourceID.generate(),
-			new TargetDependentHeartbeatSender(specialTargetId, specialResponse, defaultResponse),
-			Executors.directExecutor(),
-			mock(ScheduledExecutor.class),
+			testingHeartbeatListener,
+			TestingUtils.defaultScheduledExecutor(),
 			LOG);
 
 		try {
@@ -373,10 +391,10 @@ public class HeartbeatManagerTest extends TestLogger {
 			heartbeatManager.monitorTarget(specialTargetId, specialHeartbeatTarget);
 
 			heartbeatManager.requestHeartbeat(someTargetId, null);
-			assertEquals(defaultResponse, someHeartbeatTarget.getLastReceivedHeartbeatPayload());
+			assertThat(someHeartbeatPayloadFuture.get(), is(payloads.get(someTargetId)));
 
 			heartbeatManager.requestHeartbeat(specialTargetId, null);
-			assertEquals(specialResponse, specialHeartbeatTarget.getLastReceivedHeartbeatPayload());
+			assertThat(specialHeartbeatPayloadFuture.get(), is(payloads.get(specialTargetId)));
 		} finally {
 			heartbeatManager.stop();
 		}
@@ -410,7 +428,6 @@ public class HeartbeatManagerTest extends TestLogger {
 			heartbeatTimeout,
 			ResourceID.generate(),
 			new TargetDependentHeartbeatSender(specialTargetId, specialResponse, defaultResponse),
-			Executors.directExecutor(),
 			new ScheduledExecutorServiceAdapter(scheduledThreadPoolExecutor),
 			LOG);
 
@@ -491,16 +508,16 @@ public class HeartbeatManagerTest extends TestLogger {
 		}
 
 		@Override
-		public CompletableFuture<Integer> retrievePayload(ResourceID resourceID) {
+		public Integer retrievePayload(ResourceID resourceID) {
 			if (resourceID.equals(specialId)) {
-				return CompletableFuture.completedFuture(specialResponse);
+				return specialResponse;
 			} else {
-				return CompletableFuture.completedFuture(defaultResponse);
+				return defaultResponse;
 			}
 		}
 	}
 
-	static class TestingHeartbeatListener implements HeartbeatListener<Object, Object> {
+	static class SimpleTestingHeartbeatListener implements HeartbeatListener<Object, Object> {
 
 		private final CompletableFuture<ResourceID> future = new CompletableFuture<>();
 
@@ -508,7 +525,7 @@ public class HeartbeatManagerTest extends TestLogger {
 
 		private int numberHeartbeatReports;
 
-		TestingHeartbeatListener(Object payload) {
+		SimpleTestingHeartbeatListener(Object payload) {
 			this.payload = payload;
 		}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatListener.java b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatListener.java
new file mode 100644
index 00000000000..dcd5ed5e216
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatListener.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.heartbeat;
+
+import org.apache.flink.runtime.clusterframework.types.ResourceID;
+
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+final class TestingHeartbeatListener<I, O> implements HeartbeatListener<I, O> {
+
+	private final Consumer<ResourceID> notifyHeartbeatTimeoutConsumer;
+
+	private final BiConsumer<ResourceID, I> reportPayloadConsumer;
+
+	private final Function<ResourceID, O> retrievePayloadFunction;
+
+	TestingHeartbeatListener(Consumer<ResourceID> notifyHeartbeatTimeoutConsumer, BiConsumer<ResourceID, I> reportPayloadConsumer, Function<ResourceID, O> retrievePayloadFunction) {
+		this.notifyHeartbeatTimeoutConsumer = notifyHeartbeatTimeoutConsumer;
+		this.reportPayloadConsumer = reportPayloadConsumer;
+		this.retrievePayloadFunction = retrievePayloadFunction;
+	}
+
+	@Override
+	public void notifyHeartbeatTimeout(ResourceID resourceID) {
+		notifyHeartbeatTimeoutConsumer.accept(resourceID);
+	}
+
+	@Override
+	public void reportPayload(ResourceID resourceID, I payload) {
+		reportPayloadConsumer.accept(resourceID, payload);
+	}
+
+	@Override
+	public O retrievePayload(ResourceID resourceID) {
+		return retrievePayloadFunction.apply(resourceID);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatListenerBuilder.java b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatListenerBuilder.java
new file mode 100644
index 00000000000..89775fc4354
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatListenerBuilder.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.heartbeat;
+
+import org.apache.flink.runtime.clusterframework.types.ResourceID;
+
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+class TestingHeartbeatListenerBuilder<I, O> {
+	private Consumer<ResourceID> notifyHeartbeatTimeoutConsumer = ignored -> {};
+	private BiConsumer<ResourceID, I> reportPayloadConsumer = (ignoredA, ignoredB) -> {};
+	private Function<ResourceID, O> retrievePayloadFunction = ignored -> null;
+
+	public TestingHeartbeatListenerBuilder<I, O> setNotifyHeartbeatTimeoutConsumer(Consumer<ResourceID> notifyHeartbeatTimeoutConsumer) {
+		this.notifyHeartbeatTimeoutConsumer = notifyHeartbeatTimeoutConsumer;
+		return this;
+	}
+
+	public TestingHeartbeatListenerBuilder<I, O> setReportPayloadConsumer(BiConsumer<ResourceID, I> reportPayloadConsumer) {
+		this.reportPayloadConsumer = reportPayloadConsumer;
+		return this;
+	}
+
+	public TestingHeartbeatListenerBuilder<I, O> setRetrievePayloadFunction(Function<ResourceID, O> retrievePayloadFunction) {
+		this.retrievePayloadFunction = retrievePayloadFunction;
+		return this;
+	}
+
+	public TestingHeartbeatListener<I, O> createNewTestingHeartbeatListener() {
+		return new TestingHeartbeatListener<>(notifyHeartbeatTimeoutConsumer, reportPayloadConsumer, retrievePayloadFunction);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatServices.java b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatServices.java
index a98f45a2d09..9de099a6c47 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatServices.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatServices.java
@@ -18,44 +18,12 @@
 
 package org.apache.flink.runtime.heartbeat;
 
-import org.apache.flink.runtime.clusterframework.types.ResourceID;
-import org.apache.flink.runtime.concurrent.ScheduledExecutor;
-import org.apache.flink.runtime.testingUtils.TestingUtils;
-import org.apache.flink.util.Preconditions;
-
-import org.slf4j.Logger;
-
 /**
- * A {@link HeartbeatServices} that allows the injection of a {@link ScheduledExecutor}.
+ * A {@link HeartbeatServices} implementation for testing purposes.
  */
 public class TestingHeartbeatServices extends HeartbeatServices {
 
-	private final ScheduledExecutor scheduledExecutorToUse;
-
-	public TestingHeartbeatServices(long heartbeatInterval, long heartbeatTimeout, ScheduledExecutor scheduledExecutorToUse) {
-		super(heartbeatInterval, heartbeatTimeout);
-
-		this.scheduledExecutorToUse = Preconditions.checkNotNull(scheduledExecutorToUse);
-	}
-
 	public TestingHeartbeatServices() {
-		this(1000L, 10000L, TestingUtils.defaultScheduledExecutor());
-	}
-
-	@Override
-	public <I, O> HeartbeatManager<I, O> createHeartbeatManagerSender(
-		ResourceID resourceId,
-		HeartbeatListener<I, O> heartbeatListener,
-		ScheduledExecutor scheduledExecutor,
-		Logger log) {
-
-		return new HeartbeatManagerSenderImpl<>(
-			heartbeatInterval,
-			heartbeatTimeout,
-			resourceId,
-			heartbeatListener,
-			org.apache.flink.runtime.concurrent.Executors.directExecutor(),
-			scheduledExecutorToUse,
-			log);
+		super(1000L, 10000L);
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatTarget.java b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatTarget.java
new file mode 100644
index 00000000000..78f883198f0
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatTarget.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.heartbeat;
+
+import org.apache.flink.runtime.clusterframework.types.ResourceID;
+
+import java.util.function.BiConsumer;
+
+class TestingHeartbeatTarget<T> implements HeartbeatTarget<T> {
+	private final BiConsumer<ResourceID, T> receiveHeartbeatConsumer;
+
+	private final BiConsumer<ResourceID, T> requestHeartbeatConsumer;
+
+	TestingHeartbeatTarget(BiConsumer<ResourceID, T> receiveHeartbeatConsumer, BiConsumer<ResourceID, T> requestHeartbeatConsumer) {
+		this.receiveHeartbeatConsumer = receiveHeartbeatConsumer;
+		this.requestHeartbeatConsumer = requestHeartbeatConsumer;
+	}
+
+	@Override
+	public void receiveHeartbeat(ResourceID heartbeatOrigin, T heartbeatPayload) {
+		receiveHeartbeatConsumer.accept(heartbeatOrigin, heartbeatPayload);
+	}
+
+	@Override
+	public void requestHeartbeat(ResourceID requestOrigin, T heartbeatPayload) {
+		requestHeartbeatConsumer.accept(requestOrigin, heartbeatPayload);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatTargetBuilder.java b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatTargetBuilder.java
new file mode 100644
index 00000000000..451609cb922
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/heartbeat/TestingHeartbeatTargetBuilder.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.heartbeat;
+
+import org.apache.flink.runtime.clusterframework.types.ResourceID;
+
+import java.util.function.BiConsumer;
+
+class TestingHeartbeatTargetBuilder<T> {
+	private BiConsumer<ResourceID, T> receiveHeartbeatConsumer = (ignoredA, ignoredB) -> {};
+	private BiConsumer<ResourceID, T> requestHeartbeatConsumer = (ignoredA, ignoredB) -> {};
+
+	public TestingHeartbeatTargetBuilder<T> setReceiveHeartbeatConsumer(BiConsumer<ResourceID, T> receiveHeartbeatConsumer) {
+		this.receiveHeartbeatConsumer = receiveHeartbeatConsumer;
+		return this;
+	}
+
+	public TestingHeartbeatTargetBuilder<T> setRequestHeartbeatConsumer(BiConsumer<ResourceID, T> requestHeartbeatConsumer) {
+		this.requestHeartbeatConsumer = requestHeartbeatConsumer;
+		return this;
+	}
+
+	public TestingHeartbeatTarget<T> createTestingHeartbeatTarget() {
+		return new TestingHeartbeatTarget<>(receiveHeartbeatConsumer, requestHeartbeatConsumer);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
index aa1252dc811..6cc1a776f1e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
@@ -51,6 +51,7 @@ import org.apache.flink.runtime.checkpoint.savepoint.SavepointV2;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;
 import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;
 import org.apache.flink.runtime.execution.ExecutionState;
@@ -60,9 +61,9 @@ import org.apache.flink.runtime.executiongraph.ArchivedExecutionGraph;
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
 import org.apache.flink.runtime.executiongraph.failover.FailoverStrategyLoader;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.heartbeat.TestingHeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
+import org.apache.flink.runtime.instance.SimpleSlotContext;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionID;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
 import org.apache.flink.runtime.jobgraph.DistributionPattern;
@@ -78,9 +79,13 @@ import org.apache.flink.runtime.jobgraph.tasks.CheckpointCoordinatorConfiguratio
 import org.apache.flink.runtime.jobgraph.tasks.JobCheckpointingSettings;
 import org.apache.flink.runtime.jobmanager.OnCompletionActions;
 import org.apache.flink.runtime.jobmanager.PartitionProducerDisposedException;
+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;
 import org.apache.flink.runtime.jobmaster.factories.UnregisteredJobManagerJobMetricGroupFactory;
 import org.apache.flink.runtime.jobmaster.slotpool.DefaultSchedulerFactory;
 import org.apache.flink.runtime.jobmaster.slotpool.DefaultSlotPoolFactory;
+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;
+import org.apache.flink.runtime.jobmaster.slotpool.SlotPool;
+import org.apache.flink.runtime.jobmaster.slotpool.SlotPoolFactory;
 import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.messages.FlinkJobNotFoundException;
@@ -88,6 +93,7 @@ import org.apache.flink.runtime.messages.checkpoint.DeclineCheckpoint;
 import org.apache.flink.runtime.query.KvStateLocation;
 import org.apache.flink.runtime.query.UnknownKvStateLocation;
 import org.apache.flink.runtime.registration.RegistrationResponse;
+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerId;
 import org.apache.flink.runtime.resourcemanager.SlotRequest;
 import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;
@@ -99,6 +105,7 @@ import org.apache.flink.runtime.rpc.akka.AkkaRpcServiceConfiguration;
 import org.apache.flink.runtime.scheduler.LegacySchedulerFactory;
 import org.apache.flink.runtime.scheduler.SchedulerNGFactory;
 import org.apache.flink.runtime.shuffle.NettyShuffleMaster;
+import org.apache.flink.runtime.shuffle.ShuffleMaster;
 import org.apache.flink.runtime.state.CompletedCheckpointStorageLocation;
 import org.apache.flink.runtime.state.KeyGroupRange;
 import org.apache.flink.runtime.state.OperatorStreamStateHandle;
@@ -120,6 +127,7 @@ import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.testutils.ClassLoaderUtils;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
+import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.InstantiationUtil;
 import org.apache.flink.util.SerializedThrowable;
 import org.apache.flink.util.TestLogger;
@@ -148,7 +156,9 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.ArrayBlockingQueue;
@@ -167,12 +177,15 @@ import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.anyOf;
 import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -219,8 +232,8 @@ public class JobMasterTest extends TestLogger {
 	public static void setupClass() {
 		rpcService = new TestingRpcService();
 
-		fastHeartbeatServices = new TestingHeartbeatServices(fastHeartbeatInterval, fastHeartbeatTimeout, rpcService.getScheduledExecutor());
-		heartbeatServices = new TestingHeartbeatServices(heartbeatInterval, heartbeatTimeout, rpcService.getScheduledExecutor());
+		fastHeartbeatServices = new HeartbeatServices(fastHeartbeatInterval, fastHeartbeatTimeout);
+		heartbeatServices = new HeartbeatServices(heartbeatInterval, heartbeatTimeout);
 	}
 
 	@Before
@@ -370,19 +383,224 @@ public class JobMasterTest extends TestLogger {
 			// wait for the completion of the registration
 			registrationResponse.get();
 
-			final ResourceID heartbeatResourceId = heartbeatResourceIdFuture.get(testingTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);
-
-			assertThat(heartbeatResourceId, Matchers.equalTo(jmResourceId));
-
 			final JobID disconnectedJobManager = disconnectedJobManagerFuture.get(testingTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);
 
 			assertThat(disconnectedJobManager, Matchers.equalTo(jobGraph.getJobID()));
+
+			final ResourceID heartbeatResourceId = heartbeatResourceIdFuture.getNow(null);
+
+			assertThat(heartbeatResourceId, anyOf(nullValue(), equalTo(jmResourceId)));
 		} finally {
 			jobManagerSharedServices.shutdown();
 			RpcUtils.terminateRpcEndpoint(jobMaster, testingTimeout);
 		}
 	}
 
+	/**
+	 * Tests that the {@link AllocatedSlotReport} contains up to date information and not
+	 * stale information about the allocated slots on the {@link JobMaster}.
+	 *
+	 * <p>This is a probabilistic test case which only fails if executed repeatedly without
+	 * the fix for FLINK-12863.
+	 */
+	@Test
+	public void testAllocatedSlotReportDoesNotContainStaleInformation() throws Exception {
+		final CompletableFuture<Void> assertionFuture = new CompletableFuture<>();
+		final TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();
+		final AtomicBoolean terminateHeartbeatVerification = new AtomicBoolean(false);
+		final OneShotLatch hasReceivedSlotOffers = new OneShotLatch();
+		final TestingTaskExecutorGateway taskExecutorGateway = new TestingTaskExecutorGatewayBuilder()
+			.setHeartbeatJobManagerConsumer((taskManagerId, allocatedSlotReport) -> {
+				try {
+					if (hasReceivedSlotOffers.isTriggered()) {
+						assertThat(allocatedSlotReport.getAllocatedSlotInfos(), hasSize(1));
+					} else {
+						assertThat(allocatedSlotReport.getAllocatedSlotInfos(), empty());
+					}
+				} catch (AssertionError e) {
+					assertionFuture.completeExceptionally(e);
+				}
+
+				if (terminateHeartbeatVerification.get()) {
+					assertionFuture.complete(null);
+				}
+			})
+			.createTestingTaskExecutorGateway();
+
+		rpcService.registerGateway(taskExecutorGateway.getAddress(), taskExecutorGateway);
+
+		final JobManagerSharedServices jobManagerSharedServices = new TestingJobManagerSharedServicesBuilder().build();
+
+		final JobMaster jobMaster = new JobMasterBuilder()
+			.withJobGraph(createSingleVertexJobGraph())
+			.withHeartbeatServices(new HeartbeatServices(5L, 1000L))
+			.withSlotPoolFactory(new TestingSlotPoolFactory(hasReceivedSlotOffers))
+			.createJobMaster();
+
+		CompletableFuture<Acknowledge> startFuture = jobMaster.start(jobMasterId);
+
+		try {
+			// wait for the start to complete
+			startFuture.get(testingTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);
+
+			final JobMasterGateway jobMasterGateway = jobMaster.getSelfGateway(JobMasterGateway.class);
+
+			// register task manager will trigger monitor heartbeat target, schedule heartbeat request at interval time
+			CompletableFuture<RegistrationResponse> registrationResponse = jobMasterGateway.registerTaskManager(
+				taskExecutorGateway.getAddress(),
+				taskManagerLocation,
+				testingTimeout);
+
+			// wait for the completion of the registration
+			registrationResponse.get();
+
+			final SlotOffer slotOffer = new SlotOffer(new AllocationID(), 0, ResourceProfile.UNKNOWN);
+
+			final CompletableFuture<Collection<SlotOffer>> slotOfferFuture = jobMasterGateway.offerSlots(taskManagerLocation.getResourceID(), Collections.singleton(slotOffer), testingTimeout);
+
+			assertThat(slotOfferFuture.get(), containsInAnyOrder(slotOffer));
+
+			terminateHeartbeatVerification.set(true);
+
+			// make sure that no assertion has been violated
+			assertionFuture.get();
+		} finally {
+			RpcUtils.terminateRpcEndpoint(jobMaster, testingTimeout);
+			jobManagerSharedServices.shutdown();
+		}
+	}
+
+	private static final class TestingSlotPoolFactory implements SlotPoolFactory {
+
+		private final OneShotLatch hasReceivedSlotOffers;
+
+		public TestingSlotPoolFactory(OneShotLatch hasReceivedSlotOffers) {
+			this.hasReceivedSlotOffers = hasReceivedSlotOffers;
+		}
+
+		@Nonnull
+		@Override
+		public SlotPool createSlotPool(@Nonnull JobID jobId) {
+			return new TestingSlotPool(jobId, hasReceivedSlotOffers);
+		}
+	}
+
+	private static final class TestingSlotPool implements SlotPool {
+
+		private final JobID jobId;
+
+		private final OneShotLatch hasReceivedSlotOffers;
+
+		private final Map<ResourceID, Collection<SlotInfo>> registeredSlots;
+
+		private TestingSlotPool(JobID jobId, OneShotLatch hasReceivedSlotOffers) {
+			this.jobId = jobId;
+			this.hasReceivedSlotOffers = hasReceivedSlotOffers;
+			this.registeredSlots = new HashMap<>(16);
+		}
+
+		@Override
+		public void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) {
+		}
+
+		@Override
+		public void suspend() {
+			clear();
+		}
+
+		@Override
+		public void close() {
+			clear();
+		}
+
+		private void clear() {
+			registeredSlots.clear();
+		}
+
+		@Override
+		public void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {
+			throw new UnsupportedOperationException("TestingSlotPool does not support this operation.");
+		}
+
+		@Override
+		public void disconnectResourceManager() {
+			throw new UnsupportedOperationException("TestingSlotPool does not support this operation.");
+		}
+
+		@Override
+		public boolean registerTaskManager(ResourceID resourceID) {
+			registeredSlots.computeIfAbsent(resourceID, ignored -> new ArrayList<>(16));
+			return true;
+		}
+
+		@Override
+		public boolean releaseTaskManager(ResourceID resourceId, Exception cause) {
+			registeredSlots.remove(resourceId);
+			return true;
+		}
+
+		@Override
+		public Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {
+			hasReceivedSlotOffers.trigger();
+			final Collection<SlotInfo> slotInfos = Optional.ofNullable(registeredSlots.get(taskManagerLocation.getResourceID()))
+				.orElseThrow(() -> new FlinkRuntimeException("TaskManager not registered."));
+
+			int slotIndex = slotInfos.size();
+
+			for (SlotOffer offer : offers) {
+				slotInfos.add(new SimpleSlotContext(
+					offer.getAllocationId(),
+					taskManagerLocation,
+					slotIndex,
+					taskManagerGateway));
+				slotIndex++;
+			}
+
+			return offers;
+		}
+
+		@Override
+		public Optional<ResourceID> failAllocation(AllocationID allocationID, Exception cause) {
+			throw new UnsupportedOperationException("TestingSlotPool does not support this operation.");
+		}
+
+		@Nonnull
+		@Override
+		public Collection<SlotInfo> getAvailableSlotsInformation() {
+			final Collection<SlotInfo> allSlotInfos = registeredSlots.values().stream().flatMap(Collection::stream).collect(Collectors.toList());
+
+			return Collections.unmodifiableCollection(allSlotInfos);
+		}
+
+		@Override
+		public Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID) {
+			throw new UnsupportedOperationException("TestingSlotPool does not support this operation.");
+		}
+
+		@Nonnull
+		@Override
+		public CompletableFuture<PhysicalSlot> requestNewAllocatedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, Time timeout) {
+			return new CompletableFuture<>();
+		}
+
+		@Override
+		public AllocatedSlotReport createAllocatedSlotReport(ResourceID taskManagerId) {
+			final Collection<SlotInfo> slotInfos = registeredSlots.getOrDefault(taskManagerId, Collections.emptyList());
+
+			final List<AllocatedSlotInfo> allocatedSlotInfos = slotInfos
+				.stream()
+				.map(slotInfo -> new AllocatedSlotInfo(slotInfo.getPhysicalSlotNumber(), slotInfo.getAllocationId()))
+				.collect(Collectors.toList());
+
+			return new AllocatedSlotReport(jobId, allocatedSlotInfos);
+		}
+
+		@Override
+		public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {
+			throw new UnsupportedOperationException("TestingSlotPool does not support this operation.");
+		}
+	}
+
 	@Test
 	public void testHeartbeatTimeoutWithResourceManager() throws Exception {
 		final String resourceManagerAddress = "rm";
@@ -1845,26 +2063,97 @@ public class JobMasterTest extends TestLogger {
 			JobManagerSharedServices jobManagerSharedServices,
 			HeartbeatServices heartbeatServices,
 			OnCompletionActions onCompletionActions) throws Exception {
-		final JobMasterConfiguration jobMasterConfiguration = JobMasterConfiguration.fromConfiguration(configuration);
-		final SchedulerNGFactory schedulerNGFactory = new LegacySchedulerFactory(
-			jobManagerSharedServices.getRestartStrategyFactory());
 
-		return new JobMaster(
-			rpcService,
-			jobMasterConfiguration,
-			jmResourceId,
-			jobGraph,
-			highAvailabilityServices,
-			DefaultSlotPoolFactory.fromConfiguration(configuration),
-			DefaultSchedulerFactory.fromConfiguration(configuration),
-			jobManagerSharedServices,
-			heartbeatServices,
-			UnregisteredJobManagerJobMetricGroupFactory.INSTANCE,
-			onCompletionActions,
-			testingFatalErrorHandler,
-			JobMasterTest.class.getClassLoader(),
-			schedulerNGFactory,
-			NettyShuffleMaster.INSTANCE);
+		return new JobMasterBuilder()
+			.withConfiguration(configuration)
+			.withJobGraph(jobGraph)
+			.withHighAvailabilityServices(highAvailabilityServices)
+			.withJobManagerSharedServices(jobManagerSharedServices)
+			.withHeartbeatServices(heartbeatServices)
+			.withOnCompletionActions(onCompletionActions)
+			.createJobMaster();
+	}
+
+	private final class JobMasterBuilder {
+
+		private Configuration configuration = JobMasterTest.this.configuration;
+
+		private JobGraph jobGraph = JobMasterTest.jobGraph;
+
+		private HighAvailabilityServices highAvailabilityServices = haServices;
+
+		private JobManagerSharedServices jobManagerSharedServices = new TestingJobManagerSharedServicesBuilder().build();
+
+		private HeartbeatServices heartbeatServices = JobMasterTest.heartbeatServices;
+
+		private SlotPoolFactory slotPoolFactory = DefaultSlotPoolFactory.fromConfiguration(configuration);
+
+		private OnCompletionActions onCompletionActions = new TestingOnCompletionActions();
+
+		private ShuffleMaster<?> shuffleMaster = NettyShuffleMaster.INSTANCE;
+
+		private JobMasterBuilder withConfiguration(Configuration configuration) {
+			this.configuration = configuration;
+			return this;
+		}
+
+		private JobMasterBuilder withJobGraph(JobGraph jobGraph) {
+			this.jobGraph = jobGraph;
+			return this;
+		}
+
+		private JobMasterBuilder withHighAvailabilityServices(HighAvailabilityServices highAvailabilityServices) {
+			this.highAvailabilityServices = highAvailabilityServices;
+			return this;
+		}
+
+		private JobMasterBuilder withJobManagerSharedServices(JobManagerSharedServices jobManagerSharedServices) {
+			this.jobManagerSharedServices = jobManagerSharedServices;
+			return this;
+		}
+
+		private JobMasterBuilder withHeartbeatServices(HeartbeatServices heartbeatServices) {
+			this.heartbeatServices = heartbeatServices;
+			return this;
+		}
+
+		private JobMasterBuilder withSlotPoolFactory(SlotPoolFactory slotPoolFactory) {
+			this.slotPoolFactory = slotPoolFactory;
+			return this;
+		}
+
+		private JobMasterBuilder withOnCompletionActions(OnCompletionActions onCompletionActions) {
+			this.onCompletionActions = onCompletionActions;
+			return this;
+		}
+
+		private JobMasterBuilder withShuffleMaster(ShuffleMaster<?> shuffleMaster) {
+			this.shuffleMaster = shuffleMaster;
+			return this;
+		}
+
+		private JobMaster createJobMaster() throws Exception {
+			final JobMasterConfiguration jobMasterConfiguration = JobMasterConfiguration.fromConfiguration(configuration);
+			final SchedulerNGFactory schedulerNGFactory = new LegacySchedulerFactory(
+				jobManagerSharedServices.getRestartStrategyFactory());
+
+			return new JobMaster(
+				rpcService,
+				jobMasterConfiguration,
+				jmResourceId,
+				jobGraph,
+				highAvailabilityServices,
+				slotPoolFactory,
+				DefaultSchedulerFactory.fromConfiguration(configuration),
+				jobManagerSharedServices,
+				heartbeatServices,
+				UnregisteredJobManagerJobMetricGroupFactory.INSTANCE,
+				onCompletionActions,
+				testingFatalErrorHandler,
+				JobMasterTest.class.getClassLoader(),
+				schedulerNGFactory,
+				shuffleMaster);
+		}
 	}
 
 	private JobGraph createSingleVertexJobWithRestartStrategy() throws IOException {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java
index 5bd99af2761..95e43fce658 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java
@@ -55,9 +55,11 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeoutException;
 
+import static org.hamcrest.Matchers.anyOf;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.assertThat;
 
 /**
@@ -198,7 +200,9 @@ public class ResourceManagerTest extends TestLogger {
 				assertThat(registrationFuture.get(), instanceOf(RegistrationResponse.Success.class));
 			},
 			resourceManagerResourceId -> {
-				assertThat(heartbeatRequestFuture.get(), is(equalTo(resourceManagerResourceId)));
+				// might have been completed or not depending whether the timeout was triggered first
+				final ResourceID optionalHeartbeatRequestOrigin = heartbeatRequestFuture.getNow(null);
+				assertThat(optionalHeartbeatRequestOrigin, anyOf(is(resourceManagerResourceId), is(nullValue())));
 				assertThat(disconnectFuture.get(), is(equalTo(resourceManagerId)));
 			});
 	}
@@ -219,7 +223,9 @@ public class ResourceManagerTest extends TestLogger {
 				registerTaskExecutor(resourceManagerGateway, taskExecutorId, taskExecutorGateway.getAddress());
 			},
 			resourceManagerResourceId -> {
-				assertThat(heartbeatRequestFuture.get(), is(equalTo(resourceManagerResourceId)));
+				// might have been completed or not depending whether the timeout was triggered first
+				final ResourceID optionalHeartbeatRequestOrigin = heartbeatRequestFuture.getNow(null);
+				assertThat(optionalHeartbeatRequestOrigin, anyOf(is(resourceManagerResourceId), is(nullValue())));
 				assertThat(disconnectFuture.get(), instanceOf(TimeoutException.class));
 			}
 		);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
index 873e73f0912..89f10b29d0c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorTest.java
@@ -101,12 +101,15 @@ import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.ExecutorUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.NetUtils;
 import org.apache.flink.util.SerializedValue;
 import org.apache.flink.util.TestLogger;
 import org.apache.flink.util.function.FunctionUtils;
 
+import org.apache.flink.shaded.guava18.com.google.common.collect.Lists;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -134,7 +137,7 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.function.Function;
@@ -144,6 +147,7 @@ import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.notNullValue;
@@ -1746,6 +1750,101 @@ public class TaskExecutorTest extends TestLogger {
 		}
 	}
 
+	/**
+	 * Tests that the {@link SlotReport} sent to the RM does not contain
+	 * out dated/stale information as slots are being requested from the
+	 * TM.
+	 *
+	 * <p>This is a probabilistic test case and needs to be executed
+	 * several times to produce a failure without the fix for FLINK-12865.
+	 */
+	@Test
+	public void testSlotReportDoesNotContainStaleInformation() throws Exception {
+		final OneShotLatch receivedSlotRequest = new OneShotLatch();
+		final CompletableFuture<Void> verifySlotReportFuture = new CompletableFuture<>();
+		final OneShotLatch terminateSlotReportVerification = new OneShotLatch();
+		final TestingResourceManagerGateway testingResourceManagerGateway = new TestingResourceManagerGateway();
+		// Assertions for this test
+		testingResourceManagerGateway.setTaskExecutorHeartbeatConsumer((ignored, slotReport) -> {
+			try {
+				final ArrayList<SlotStatus> slots = Lists.newArrayList(slotReport);
+				assertThat(slots, hasSize(1));
+				final SlotStatus slotStatus = slots.get(0);
+
+				log.info("Received SlotStatus: {}", slotStatus);
+
+				if (receivedSlotRequest.isTriggered()) {
+					assertThat(slotStatus.getAllocationID(), is(notNullValue()));
+				} else {
+					assertThat(slotStatus.getAllocationID(), is(nullValue()));
+				}
+			} catch (AssertionError e) {
+				verifySlotReportFuture.completeExceptionally(e);
+			}
+
+			if (terminateSlotReportVerification.isTriggered()) {
+				verifySlotReportFuture.complete(null);
+			}
+		});
+		final CompletableFuture<ResourceID> taskExecutorRegistrationFuture = new CompletableFuture<>();
+
+		testingResourceManagerGateway.setSendSlotReportFunction(ignored -> {
+			taskExecutorRegistrationFuture.complete(null);
+			return CompletableFuture.completedFuture(Acknowledge.get());
+		});
+
+		rpc.registerGateway(testingResourceManagerGateway.getAddress(), testingResourceManagerGateway);
+		resourceManagerLeaderRetriever.notifyListener(testingResourceManagerGateway.getAddress(), testingResourceManagerGateway.getFencingToken().toUUID());
+
+		final TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()
+			.setTaskSlotTable(new AllocateSlotNotifyingTaskSlotTable(Collections.singleton(ResourceProfile.UNKNOWN), timerService, receivedSlotRequest))
+			.build();
+		final TaskExecutor taskExecutor = createTaskExecutor(taskManagerServices);
+		final ResourceID taskExecutorResourceId = taskManagerServices.getTaskManagerLocation().getResourceID();
+
+		taskExecutor.start();
+
+		final TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);
+
+		final ScheduledExecutorService heartbeatExecutor = java.util.concurrent.Executors.newSingleThreadScheduledExecutor();
+
+		try {
+			taskExecutorRegistrationFuture.get();
+
+			final OneShotLatch scheduleFirstHeartbeat = new OneShotLatch();
+			final ResourceID resourceManagerResourceId = testingResourceManagerGateway.getOwnResourceId();
+			final long heartbeatInterval = 5L;
+			heartbeatExecutor.scheduleWithFixedDelay(
+				() -> {
+					scheduleFirstHeartbeat.trigger();
+					taskExecutorGateway.heartbeatFromResourceManager(resourceManagerResourceId);
+				},
+				0L,
+				heartbeatInterval,
+				TimeUnit.MILLISECONDS);
+
+			scheduleFirstHeartbeat.await();
+
+			SlotID slotId = new SlotID(taskExecutorResourceId, 0);
+			final CompletableFuture<Acknowledge> requestSlotFuture = taskExecutorGateway.requestSlot(
+				slotId,
+				jobId,
+				new AllocationID(),
+				"foobar",
+				testingResourceManagerGateway.getFencingToken(),
+				timeout);
+
+			requestSlotFuture.get();
+
+			terminateSlotReportVerification.trigger();
+
+			verifySlotReportFuture.get();
+		} finally {
+			ExecutorUtils.gracefulShutdown(timeout.toMilliseconds(), TimeUnit.MILLISECONDS, heartbeatExecutor);
+			RpcUtils.terminateRpcEndpoint(taskExecutor, timeout);
+		}
+	}
+
 	private TaskExecutorLocalStateStoresManager createTaskExecutorLocalStateStoresManager() throws IOException {
 		return new TaskExecutorLocalStateStoresManager(
 			false,
@@ -1828,13 +1927,12 @@ public class TaskExecutorTest extends TestLogger {
 		}
 
 		@Override
-		public <I, O> HeartbeatManager<I, O> createHeartbeatManager(ResourceID resourceId, HeartbeatListener<I, O> heartbeatListener, ScheduledExecutor scheduledExecutor, Logger log) {
+		public <I, O> HeartbeatManager<I, O> createHeartbeatManager(ResourceID resourceId, HeartbeatListener<I, O> heartbeatListener, ScheduledExecutor mainThreadExecutor, Logger log) {
 			return new RecordingHeartbeatManagerImpl<>(
 				heartbeatTimeout,
 				resourceId,
 				heartbeatListener,
-				scheduledExecutor,
-				scheduledExecutor,
+				mainThreadExecutor,
 				log,
 				unmonitoredTargets,
 				monitoredTargets);
@@ -1862,12 +1960,11 @@ public class TaskExecutorTest extends TestLogger {
 				long heartbeatTimeoutIntervalMs,
 				ResourceID ownResourceID,
 				HeartbeatListener<I, O> heartbeatListener,
-				Executor executor,
-				ScheduledExecutor scheduledExecutor,
+				ScheduledExecutor mainThreadExecutor,
 				Logger log,
 				BlockingQueue<ResourceID> unmonitoredTargets,
 				BlockingQueue<ResourceID> monitoredTargets) {
-			super(heartbeatTimeoutIntervalMs, ownResourceID, heartbeatListener, executor, scheduledExecutor, log);
+			super(heartbeatTimeoutIntervalMs, ownResourceID, heartbeatListener, mainThreadExecutor, log);
 			this.unmonitoredTargets = unmonitoredTargets;
 			this.monitoredTargets = monitoredTargets;
 		}
@@ -1898,4 +1995,25 @@ public class TaskExecutorTest extends TestLogger {
 			return slotReports.poll();
 		}
 	}
+
+	private static final class AllocateSlotNotifyingTaskSlotTable extends TaskSlotTable {
+
+		private final OneShotLatch allocateSlotLatch;
+
+		private AllocateSlotNotifyingTaskSlotTable(
+				Collection<ResourceProfile> resourceProfiles,
+				TimerService<AllocationID> timerService,
+				OneShotLatch allocateSlotLatch) {
+			super(resourceProfiles, timerService);
+			this.allocateSlotLatch = allocateSlotLatch;
+		}
+
+		@Override
+		public boolean allocateSlot(int index, JobID jobId, AllocationID allocationId, Time slotTimeout) {
+			final boolean result = super.allocateSlot(index, jobId, allocationId, slotTimeout);
+			allocateSlotLatch.trigger();
+
+			return result;
+		}
+	}
 }
