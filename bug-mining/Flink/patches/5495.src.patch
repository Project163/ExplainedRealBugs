diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/WindowEmitStrategy.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/WindowEmitStrategy.scala
index 1adf6fabfb0..be7232c0104 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/WindowEmitStrategy.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/WindowEmitStrategy.scala
@@ -48,7 +48,7 @@ class WindowEmitStrategy(
     }
     if (isEventTime && lateFireDelayEnabled && allowLateness <= 0L) {
       throw new TableException("The 'AFTER WATERMARK' emit strategy requires set " +
-        "'minIdleStateRetentionTime' in table config.")
+        "'allow-lateness' or 'minIdleStateRetentionTime' in table config.")
     }
     if (earlyFireDelayEnabled && (earlyFireDelay == null || earlyFireDelay.toMillis < 0)) {
       throw new TableException("Early-fire delay should not be null or negative value when" +
@@ -58,6 +58,10 @@ class WindowEmitStrategy(
       throw new TableException("Late-fire delay should not be null or negative value when" +
         "enable late-fire emit strategy.")
     }
+    if (lateFireDelayEnabled && (lateFireDelay.toMillis > allowLateness)) {
+      throw new TableException(s"Allow-lateness [${allowLateness}ms] should not be smaller than " +
+        s"Late-fire delay [${lateFireDelay.toMillis}ms] when enable late-fire emit strategy.")
+    }
   }
 
   def produceUpdates: JBoolean = {
@@ -140,16 +144,7 @@ object WindowEmitStrategy {
     val isEventTime = isRowtimeAttribute(window.timeAttribute)
     val isSessionWindow = window.isInstanceOf[SessionGroupWindow]
 
-    val allowLateness = if (isSessionWindow) {
-      // ignore allow lateness in session window because retraction is not supported
-      0L
-    } else if (tableConfig.getMinIdleStateRetentionTime < 0) {
-      // min idle state retention time is not set, use 0L as default which means not allow lateness
-      0L
-    } else {
-      // use min idle state retention time as allow lateness
-      tableConfig.getMinIdleStateRetentionTime
-    }
+    val allowLateness = parseAllowLateness(isSessionWindow, tableConfig)
     val enableEarlyFireDelay = tableConfig.getConfiguration.getBoolean(
       TABLE_EXEC_EMIT_EARLY_FIRE_ENABLED)
     val earlyFireDelay: Duration = tableConfig.getConfiguration
@@ -160,7 +155,7 @@ object WindowEmitStrategy {
     val lateFireDelay: Duration = tableConfig.getConfiguration
       .getOptional(TABLE_EXEC_EMIT_LATE_FIRE_DELAY)
       .orElse(null)
-    new WindowEmitStrategy(
+      new WindowEmitStrategy(
       isEventTime,
       isSessionWindow,
       earlyFireDelay,
@@ -170,6 +165,32 @@ object WindowEmitStrategy {
       allowLateness)
   }
 
+  private def parseAllowLateness(
+      isSessionWindow: Boolean,
+      tableConfig: TableConfig): Long = {
+    val enableLateFireDelay = tableConfig.getConfiguration.getBoolean(
+      TABLE_EXEC_EMIT_LATE_FIRE_ENABLED)
+    val emitAllowLateness: Duration = tableConfig.getConfiguration
+      .getOptional(TABLE_EXEC_EMIT_ALLOW_LATENESS)
+      .orElse(null)
+    if (isSessionWindow) {
+      // ignore allow lateness in session window because retraction is not supported
+      0L
+    } else if (!enableLateFireDelay) {
+      // ignore allow lateness if disable late-fire delay
+      0L
+    } else if (emitAllowLateness != null) {
+      // return emit allow-lateness if it is set
+      emitAllowLateness.toMillis
+    } else if (tableConfig.getMinIdleStateRetentionTime < 0) {
+      // min idle state retention time is not set, use 0L as default which means not allow lateness
+      0L
+    } else {
+      // use min idle state retention time as allow lateness
+      tableConfig.getMinIdleStateRetentionTime
+    }
+  }
+
   // It is a experimental config, will may be removed later.
   @Experimental
   val TABLE_EXEC_EMIT_EARLY_FIRE_ENABLED: ConfigOption[JBoolean] =
@@ -210,4 +231,17 @@ object WindowEmitStrategy {
           "0 means no delay (fire on every element). " +
           "> 0 means the fire interval.")
 
+  // It is a experimental config, will may be removed later.
+  @Experimental
+  val TABLE_EXEC_EMIT_ALLOW_LATENESS: ConfigOption[Duration] =
+  key("table.exec.emit.allow-lateness")
+    .durationType()
+    .noDefaultValue()
+    .withDescription("Sets the time by which elements are allowed to be late. " +
+        "Elements that arrive behind the watermark by more than the specified time " +
+        "will be dropped. " +
+        "Note: use the value if it is set, else use 'minIdleStateRetentionTime' in table config." +
+        "< 0 is illegal configuration. " +
+        "0 means disable allow lateness. " +
+        "> 0 means allow-lateness.")
 }
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.xml
index 1c1a42f45d0..0aefa62bc72 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.xml
@@ -656,6 +656,32 @@ Calc(select=[w$start AS EXPR$0, EXPR$1], changelogMode=[I])
       +- ChangelogNormalize(key=[a], changelogMode=[I,UB,UA,D])
          +- Exchange(distribution=[hash[a]], changelogMode=[UA,D])
             +- TableSourceScan(table=[[default_catalog, default_database, src, project=[a]]], fields=[a], changelogMode=[UA,D])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testWindowAggregateWithAllowLateness">
+    <Resource name="sql">
+      <![CDATA[
+SELECT TUMBLE_START(`rowtime`, INTERVAL '1' SECOND), COUNT(*) cnt
+FROM MyTable
+GROUP BY TUMBLE(`rowtime`, INTERVAL '1' SECOND)
+]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(EXPR$0=[TUMBLE_START($0)], cnt=[$1])
++- LogicalAggregate(group=[{0}], cnt=[COUNT()])
+   +- LogicalProject($f0=[$TUMBLE($4, 1000:INTERVAL SECOND)])
+      +- LogicalTableScan(table=[[default_catalog, default_database, MyTable]])
+]]>
+    </Resource>
+    <Resource name="optimized rel plan">
+      <![CDATA[
+Calc(select=[w$start AS EXPR$0, cnt], changelogMode=[I,UA])
++- GroupWindowAggregate(window=[TumblingGroupWindow('w$, rowtime, 1000)], properties=[w$start, w$end, w$rowtime, w$proctime], select=[COUNT(*) AS cnt, start('w$) AS w$start, end('w$) AS w$end, rowtime('w$) AS w$rowtime, proctime('w$) AS w$proctime], emit=[late delay 5000 millisecond], changelogMode=[I,UA])
+   +- Exchange(distribution=[single], changelogMode=[I])
+      +- Calc(select=[rowtime], changelogMode=[I])
+         +- DataStreamScan(table=[[default_catalog, default_database, MyTable]], fields=[a, b, c, proctime, rowtime], changelogMode=[I])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.scala
index 55627eb175a..90739d56246 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/agg/GroupWindowTest.scala
@@ -22,7 +22,7 @@ import org.apache.flink.api.common.time.Time
 import org.apache.flink.api.scala._
 import org.apache.flink.table.api._
 import org.apache.flink.table.planner.plan.utils.JavaUserDefinedAggFunctions.WeightedAvgWithMerge
-import org.apache.flink.table.planner.plan.utils.WindowEmitStrategy.{TABLE_EXEC_EMIT_LATE_FIRE_DELAY, TABLE_EXEC_EMIT_LATE_FIRE_ENABLED}
+import org.apache.flink.table.planner.plan.utils.WindowEmitStrategy.{TABLE_EXEC_EMIT_LATE_FIRE_DELAY, TABLE_EXEC_EMIT_LATE_FIRE_ENABLED, TABLE_EXEC_EMIT_ALLOW_LATENESS}
 import org.apache.flink.table.planner.utils.TableTestBase
 
 import java.time.Duration
@@ -445,6 +445,37 @@ class GroupWindowTest extends TableTestBase {
     util.verifyRelPlan(sql, ExplainDetail.CHANGELOG_MODE)
   }
 
+  @Test
+  def testWindowAggregateWithAllowLateness(): Unit = {
+    util.conf.getConfiguration.setBoolean(TABLE_EXEC_EMIT_LATE_FIRE_ENABLED, true)
+    util.conf.getConfiguration.set(TABLE_EXEC_EMIT_LATE_FIRE_DELAY, Duration.ofSeconds(5))
+    util.conf.getConfiguration.set(TABLE_EXEC_EMIT_ALLOW_LATENESS, Duration.ofHours(1))
+    val sql =
+      """
+        |SELECT TUMBLE_START(`rowtime`, INTERVAL '1' SECOND), COUNT(*) cnt
+        |FROM MyTable
+        |GROUP BY TUMBLE(`rowtime`, INTERVAL '1' SECOND)
+        |""".stripMargin
+    util.verifyRelPlan(sql, ExplainDetail.CHANGELOG_MODE)
+  }
+
+  @Test
+  def testWindowAggregateWithInvalidAllowLateness(): Unit = {
+    util.conf.getConfiguration.setBoolean(TABLE_EXEC_EMIT_LATE_FIRE_ENABLED, true)
+    util.conf.getConfiguration.set(TABLE_EXEC_EMIT_LATE_FIRE_DELAY, Duration.ofSeconds(5))
+    util.conf.getConfiguration.set(TABLE_EXEC_EMIT_ALLOW_LATENESS, Duration.ofSeconds(1))
+    val sql =
+      """
+        |SELECT TUMBLE_START(`rowtime`, INTERVAL '1' SECOND), COUNT(*) cnt
+        |FROM MyTable
+        |GROUP BY TUMBLE(`rowtime`, INTERVAL '1' SECOND)
+        |""".stripMargin
+    thrown.expect(classOf[TableException])
+    thrown.expectMessage("Allow-lateness [1000ms] should not be smaller than " +
+      "Late-fire delay [5000ms] when enable late-fire emit strategy.")
+    util.verifyRelPlan(sql, ExplainDetail.CHANGELOG_MODE)
+  }
+
   @Test
   def testWindowAggregateWithAllowLatenessOnly(): Unit = {
     util.conf.setIdleStateRetentionTime(Time.hours(1), Time.hours(2))
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/GroupWindowITCase.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/GroupWindowITCase.scala
index 5a84fd08065..21c4283f341 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/GroupWindowITCase.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/GroupWindowITCase.scala
@@ -27,7 +27,7 @@ import org.apache.flink.table.api.internal.TableEnvironmentInternal
 import org.apache.flink.table.planner.factories.TestValuesTableFactory
 import org.apache.flink.table.planner.factories.TestValuesTableFactory.{changelogRow, registerData}
 import org.apache.flink.table.planner.plan.utils.JavaUserDefinedAggFunctions.{ConcatDistinctAggFunction, WeightedAvg}
-import org.apache.flink.table.planner.plan.utils.WindowEmitStrategy.{TABLE_EXEC_EMIT_LATE_FIRE_DELAY, TABLE_EXEC_EMIT_LATE_FIRE_ENABLED}
+import org.apache.flink.table.planner.plan.utils.WindowEmitStrategy.{TABLE_EXEC_EMIT_LATE_FIRE_DELAY, TABLE_EXEC_EMIT_LATE_FIRE_ENABLED, TABLE_EXEC_EMIT_ALLOW_LATENESS}
 import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.{HEAP_BACKEND, ROCKSDB_BACKEND, StateBackendMode}
 import org.apache.flink.table.planner.runtime.utils.TimeTestUtil.TimestampAndWatermarkWithOffset
 import org.apache.flink.table.planner.runtime.utils._
@@ -316,8 +316,8 @@ class GroupWindowITCase(mode: StateBackendMode, useTimestampLtz: Boolean)
       return
     }
     // wait 10 millisecond for late elements
-    tEnv.getConfig.setIdleStateRetentionTime(
-      Time.milliseconds(10), Time.minutes(6))
+    tEnv.getConfig.getConfiguration.set(
+      TABLE_EXEC_EMIT_ALLOW_LATENESS, Duration.ofMillis(10))
     // emit result without delay after watermark
     withLateFireDelay(tEnv.getConfig, Time.of(0, TimeUnit.NANOSECONDS))
     val data = List(
