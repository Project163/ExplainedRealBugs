diff --git a/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/NumberSequenceSource.java b/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/NumberSequenceSource.java
index d08b30a0856..8c4b9959ac2 100644
--- a/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/NumberSequenceSource.java
+++ b/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/NumberSequenceSource.java
@@ -106,9 +106,11 @@ public class NumberSequenceSource
 
         int splitId = 1;
         for (NumberSequenceIterator seq : subSequences) {
-            splits.add(
-                    new NumberSequenceSplit(
-                            String.valueOf(splitId++), seq.getCurrent(), seq.getTo()));
+            if (seq.hasNext()) {
+                splits.add(
+                        new NumberSequenceSplit(
+                                String.valueOf(splitId++), seq.getCurrent(), seq.getTo()));
+            }
         }
 
         return new IteratorSourceEnumerator<>(enumContext, splits);
diff --git a/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/util/IteratorSourceReader.java b/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/util/IteratorSourceReader.java
index 5c9ae25c961..4a5701e9a20 100644
--- a/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/util/IteratorSourceReader.java
+++ b/flink-core/src/main/java/org/apache/flink/api/connector/source/lib/util/IteratorSourceReader.java
@@ -128,6 +128,9 @@ public class IteratorSourceReader<
 
         // non-null queue signals splits were assigned, in this case no splits
         remainingSplits = new ArrayDeque<>();
+
+        // set availability so that pollNext is actually called
+        availability.complete(null);
     }
 
     @Override
diff --git a/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/IteratorSourcesITCase.java b/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/IteratorSourcesITCase.java
deleted file mode 100644
index 7451633a418..00000000000
--- a/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/IteratorSourcesITCase.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.api.connector.source.lib;
-
-import org.apache.flink.api.common.eventtime.WatermarkStrategy;
-import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
-import org.apache.flink.streaming.api.datastream.DataStream;
-import org.apache.flink.streaming.api.datastream.DataStreamUtils;
-import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
-import org.apache.flink.test.util.MiniClusterWithClientResource;
-import org.apache.flink.util.TestLogger;
-
-import org.junit.ClassRule;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import static org.junit.Assert.fail;
-
-/**
- * An integration test for the sources based on iterators.
- *
- * <p>This test uses the {@link NumberSequenceSource} as a concrete iterator source implementation,
- * but covers all runtime-related aspects for all the iterator-based sources together.
- */
-public class IteratorSourcesITCase extends TestLogger {
-
-    private static final int PARALLELISM = 4;
-
-    @ClassRule
-    public static final MiniClusterWithClientResource MINI_CLUSTER =
-            new MiniClusterWithClientResource(
-                    new MiniClusterResourceConfiguration.Builder()
-                            .setNumberTaskManagers(1)
-                            .setNumberSlotsPerTaskManager(PARALLELISM)
-                            .build());
-
-    // ------------------------------------------------------------------------
-
-    @Test
-    public void testParallelSourceExecution() throws Exception {
-        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
-        env.setParallelism(PARALLELISM);
-
-        final DataStream<Long> stream =
-                env.fromSource(
-                        new NumberSequenceSource(1L, 1_000L),
-                        WatermarkStrategy.noWatermarks(),
-                        "iterator source");
-
-        final List<Long> result =
-                DataStreamUtils.collectBoundedStream(stream, "Iterator Source Test");
-
-        verifySequence(result, 1L, 1_000L);
-    }
-
-    // ------------------------------------------------------------------------
-    //  test utils
-    // ------------------------------------------------------------------------
-
-    private static void verifySequence(final List<Long> sequence, final long from, final long to) {
-        if (sequence.size() != to - from + 1) {
-            fail(String.format("Expected: Sequence [%d, %d]. Found: %s", from, to, sequence));
-        }
-
-        final ArrayList<Long> list =
-                new ArrayList<>(sequence); // copy to be safe against immutable lists, etc.
-        list.sort(Long::compareTo);
-
-        int pos = 0;
-        for (long value = from; value <= to; value++, pos++) {
-            if (value != list.get(pos)) {
-                fail(String.format("Expected: Sequence [%d, %d]. Found: %s", from, to, list));
-            }
-        }
-    }
-}
diff --git a/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/NumberSequenceSourceITCase.java b/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/NumberSequenceSourceITCase.java
index a34155fa425..1fb817c872c 100644
--- a/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/NumberSequenceSourceITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/api/connector/source/lib/NumberSequenceSourceITCase.java
@@ -1,12 +1,13 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -17,41 +18,87 @@
 
 package org.apache.flink.api.connector.source.lib;
 
+import org.apache.flink.api.common.eventtime.WatermarkStrategy;
 import org.apache.flink.api.common.restartstrategy.RestartStrategies;
+import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
 import org.apache.flink.streaming.api.CheckpointingMode;
+import org.apache.flink.streaming.api.datastream.DataStream;
 import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
-import org.apache.flink.streaming.util.StreamCollector;
+import org.apache.flink.test.util.MiniClusterWithClientResource;
+import org.apache.flink.util.TestLogger;
 
-import org.junit.Rule;
+import org.junit.ClassRule;
 import org.junit.Test;
 
-import java.util.Collection;
-import java.util.concurrent.CompletableFuture;
+import java.util.List;
 import java.util.stream.LongStream;
 
-import static org.junit.Assert.assertArrayEquals;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.junit.Assert.assertThat;
 
-/** Tests {@link NumberSequenceSource}. */
-public class NumberSequenceSourceITCase {
-    @Rule public StreamCollector collector = new StreamCollector();
+/**
+ * An integration test for the sources based on iterators.
+ *
+ * <p>This test uses the {@link NumberSequenceSource} as a concrete iterator source implementation,
+ * but covers all runtime-related aspects for all the iterator-based sources together.
+ */
+public class NumberSequenceSourceITCase extends TestLogger {
+
+    private static final int PARALLELISM = 4;
+
+    @ClassRule
+    public static final MiniClusterWithClientResource MINI_CLUSTER =
+            new MiniClusterWithClientResource(
+                    new MiniClusterResourceConfiguration.Builder()
+                            .setNumberTaskManagers(1)
+                            .setNumberSlotsPerTaskManager(PARALLELISM)
+                            .build());
+
+    // ------------------------------------------------------------------------
+
+    @Test
+    public void testParallelSourceExecution() throws Exception {
+        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setParallelism(PARALLELISM);
+
+        final DataStream<Long> stream =
+                env.fromSource(
+                        new NumberSequenceSource(1L, 1_000L),
+                        WatermarkStrategy.noWatermarks(),
+                        "iterator source");
+
+        final List<Long> result = stream.executeAndCollect(10000);
+        assertThat(result, containsInAnyOrder(LongStream.rangeClosed(1, 1000).boxed().toArray()));
+    }
 
     @Test
     public void testCheckpointingWithDelayedAssignment() throws Exception {
         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
         env.setParallelism(1);
-        env.setRestartStrategy(new RestartStrategies.NoRestartStrategyConfiguration());
+        env.setRestartStrategy(RestartStrategies.noRestart());
         env.enableCheckpointing(10, CheckpointingMode.EXACTLY_ONCE);
         final SingleOutputStreamOperator<Long> stream =
                 env.fromSequence(0, 100)
                         .map(
                                 x -> {
-                                    Thread.sleep(10);
+                                    if (x == 0) {
+                                        Thread.sleep(50);
+                                    }
                                     return x;
                                 });
-        final CompletableFuture<Collection<Long>> result = collector.collect(stream);
-        env.execute();
+        List<Long> result = stream.executeAndCollect(1000);
+        assertThat(result, contains(LongStream.rangeClosed(0, 100).boxed().toArray()));
+    }
 
-        assertArrayEquals(LongStream.rangeClosed(0, 100).boxed().toArray(), result.get().toArray());
+    @Test
+    public void testLessSplitsThanParallelism() throws Exception {
+        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setParallelism(PARALLELISM);
+        int n = PARALLELISM - 2;
+        DataStream<Long> stream = env.fromSequence(0, n).map(l -> l);
+        List<Long> result = stream.executeAndCollect(100);
+        assertThat(result, containsInAnyOrder(LongStream.rangeClosed(0, n).boxed().toArray()));
     }
 }
