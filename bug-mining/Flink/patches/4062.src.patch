diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
index 40f145f8ae4..09f05b974b7 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandler.java
@@ -36,6 +36,7 @@ class AlternatingCheckpointBarrierHandler extends CheckpointBarrierHandler {
 	private final CheckpointBarrierAligner alignedHandler;
 	private final CheckpointBarrierUnaligner unalignedHandler;
 	private CheckpointBarrierHandler activeHandler;
+	private long lastSeenBarrierId;
 
 	AlternatingCheckpointBarrierHandler(CheckpointBarrierAligner alignedHandler, CheckpointBarrierUnaligner unalignedHandler, AbstractInvokable invokable) {
 		super(invokable);
@@ -55,6 +56,10 @@ class AlternatingCheckpointBarrierHandler extends CheckpointBarrierHandler {
 
 	@Override
 	public void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {
+		if (receivedBarrier.getId() < lastSeenBarrierId) {
+			return;
+		}
+		lastSeenBarrierId = receivedBarrier.getId();
 		CheckpointBarrierHandler previousHandler = activeHandler;
 		activeHandler = receivedBarrier.isCheckpoint() ? unalignedHandler : alignedHandler;
 		abortPreviousIfNeeded(receivedBarrier, previousHandler);
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java
index 83833c0e16f..fdaacb5a260 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingCheckpointBarrierHandlerTest.java
@@ -127,6 +127,27 @@ public class AlternatingCheckpointBarrierHandlerTest {
 		assertFalse(barrierHandler.getAllBarriersReceivedFuture(id).isDone());
 	}
 
+	@Test
+	public void testOutOfOrderBarrier() throws Exception {
+		SingleInputGate inputGate = new SingleInputGateBuilder().setNumberOfChannels(2).build();
+		inputGate.setInputChannels(new TestInputChannel(inputGate, 0), new TestInputChannel(inputGate, 1));
+		TestInvokable target = new TestInvokable();
+		CheckpointBarrierAligner alignedHandler = new CheckpointBarrierAligner("test", new InputGate[]{inputGate, inputGate}, singletonMap(inputGate, 0), target);
+		CheckpointBarrierUnaligner unalignedHandler = new CheckpointBarrierUnaligner(new int[]{inputGate.getNumberOfInputChannels()}, ChannelStateWriter.NO_OP, "test", target);
+		AlternatingCheckpointBarrierHandler barrierHandler = new AlternatingCheckpointBarrierHandler(alignedHandler, unalignedHandler, target);
+
+		long checkpointId = 10;
+		long outOfOrderSavepointId = 5;
+		long initialAlignedCheckpointId = alignedHandler.getLatestCheckpointId();
+
+		barrierHandler.processBarrier(new CheckpointBarrier(checkpointId, 0, new CheckpointOptions(CHECKPOINT, CheckpointStorageLocationReference.getDefault())), 0);
+		barrierHandler.processBarrier(new CheckpointBarrier(outOfOrderSavepointId, 0, new CheckpointOptions(SAVEPOINT, CheckpointStorageLocationReference.getDefault())), 1);
+
+		assertEquals(checkpointId, barrierHandler.getLatestCheckpointId());
+		assertInflightDataEquals(unalignedHandler, barrierHandler, checkpointId, inputGate.getNumberOfInputChannels());
+		assertEquals(initialAlignedCheckpointId, alignedHandler.getLatestCheckpointId());
+	}
+
 	@Test
 	public void testEndOfPartition() throws Exception {
 		int totalChannels = 5;
