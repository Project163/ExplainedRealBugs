diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java
index 2d21b6cf37d..252d25c2e29 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializer.java
@@ -57,11 +57,12 @@ interface ChannelStateSerializer {
 /** Wrapper around various buffers to receive channel state data. */
 @Internal
 @NotThreadSafe
-interface ChannelStateByteBuffer {
+interface ChannelStateByteBuffer extends AutoCloseable {
 
     boolean isWritable();
 
-    void recycle();
+    @Override
+    void close();
 
     /**
      * Read up to <code>bytesToRead</code> bytes into this buffer from the given {@link
@@ -82,7 +83,7 @@ interface ChannelStateByteBuffer {
             }
 
             @Override
-            public void recycle() {
+            public void close() {
                 buffer.recycleBuffer();
             }
 
@@ -102,8 +103,8 @@ interface ChannelStateByteBuffer {
             }
 
             @Override
-            public void recycle() {
-                bufferBuilder.recycle();
+            public void close() {
+                bufferBuilder.close();
             }
 
             @Override
@@ -135,7 +136,7 @@ interface ChannelStateByteBuffer {
             }
 
             @Override
-            public void recycle() {}
+            public void close() {}
 
             @Override
             public int writeBytes(InputStream input, int bytesToRead) throws IOException {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializer.java
index fd6b1c72cda..54f4a9e528a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializer.java
@@ -306,7 +306,9 @@ public class EventSerializer {
         MemorySegment data = MemorySegmentFactory.wrap(serializedEvent.array());
 
         return new BufferConsumer(
-                data, FreeingBufferRecycler.INSTANCE, getDataType(event, hasPriority));
+                new NetworkBuffer(
+                        data, FreeingBufferRecycler.INSTANCE, getDataType(event, hasPriority)),
+                data.size());
     }
 
     public static AbstractEvent fromBuffer(Buffer buffer, ClassLoader classLoader)
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferBuilder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferBuilder.java
index a5ae7ceeb98..36d21e64422 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferBuilder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferBuilder.java
@@ -34,18 +34,17 @@ import static org.apache.flink.util.Preconditions.checkState;
  * written data.
  */
 @NotThreadSafe
-public class BufferBuilder {
+public class BufferBuilder implements AutoCloseable {
+    private final Buffer buffer;
     private final MemorySegment memorySegment;
 
-    private final BufferRecycler recycler;
-
     private final SettablePositionMarker positionMarker = new SettablePositionMarker();
 
     private boolean bufferConsumerCreated = false;
 
     public BufferBuilder(MemorySegment memorySegment, BufferRecycler recycler) {
         this.memorySegment = checkNotNull(memorySegment);
-        this.recycler = checkNotNull(recycler);
+        this.buffer = new NetworkBuffer(memorySegment, recycler);
     }
 
     /**
@@ -73,7 +72,7 @@ public class BufferBuilder {
         checkState(
                 !bufferConsumerCreated, "Two BufferConsumer shouldn't exist for one BufferBuilder");
         bufferConsumerCreated = true;
-        return new BufferConsumer(memorySegment, recycler, positionMarker, currentReaderPosition);
+        return new BufferConsumer(buffer.retainBuffer(), positionMarker, currentReaderPosition);
     }
 
     /** Same as {@link #append(ByteBuffer)} but additionally {@link #commit()} the appending. */
@@ -143,16 +142,12 @@ public class BufferBuilder {
     }
 
     public int getMaxCapacity() {
-        return memorySegment.size();
-    }
-
-    @VisibleForTesting
-    public BufferRecycler getRecycler() {
-        return recycler;
+        return buffer.getMaxCapacity();
     }
 
-    public void recycle() {
-        recycler.recycle(memorySegment);
+    @Override
+    public void close() {
+        buffer.recycleBuffer();
     }
 
     /**
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java
index 191d8992a2a..084f0ed910f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java
@@ -46,41 +46,15 @@ public class BufferConsumer implements Closeable {
 
     private int currentReaderPosition;
 
-    /** Constructs {@link BufferConsumer} instance with the initial reader position. */
-    public BufferConsumer(
-            MemorySegment memorySegment,
-            BufferRecycler recycler,
-            PositionMarker currentWriterPosition,
-            int currentReaderPosition) {
-        this(
-                new NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler)),
-                currentWriterPosition,
-                currentReaderPosition);
-    }
-
-    /** Constructs {@link BufferConsumer} instance with static content. */
-    public BufferConsumer(
-            MemorySegment memorySegment, BufferRecycler recycler, Buffer.DataType dataType) {
-        this(memorySegment, recycler, memorySegment.size(), dataType);
-    }
-
     /** Constructs {@link BufferConsumer} instance with static content of a certain size. */
-    public BufferConsumer(
-            MemorySegment memorySegment,
-            BufferRecycler recycler,
-            int size,
-            Buffer.DataType dataType) {
-        this(
-                new NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler), dataType),
-                () -> -size,
-                0);
-        checkState(memorySegment.size() > 0);
+    public BufferConsumer(Buffer buffer, int size) {
+        this(buffer, () -> -size, 0);
         checkState(
                 isFinished(),
                 "BufferConsumer with static size must be finished after construction!");
     }
 
-    private BufferConsumer(
+    public BufferConsumer(
             Buffer buffer,
             BufferBuilder.PositionMarker currentWriterPosition,
             int currentReaderPosition) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferWritingResultPartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferWritingResultPartition.java
index bc3278d03cb..abb7e1d57d2 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferWritingResultPartition.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferWritingResultPartition.java
@@ -349,6 +349,7 @@ public abstract class BufferWritingResultPartition extends ResultPartition {
             numBytesOut.inc(bufferBuilder.finish());
             numBuffersOut.inc();
             unicastBufferBuilders[targetSubpartition] = null;
+            bufferBuilder.close();
         }
     }
 
@@ -362,6 +363,7 @@ public abstract class BufferWritingResultPartition extends ResultPartition {
         if (broadcastBufferBuilder != null) {
             numBytesOut.inc(broadcastBufferBuilder.finish() * numSubpartitions);
             numBuffersOut.inc(numSubpartitions);
+            broadcastBufferBuilder.close();
             broadcastBufferBuilder = null;
         }
     }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/SpanningRecordSerializationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/SpanningRecordSerializationTest.java
index c1aa03a1a49..6924a881bf5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/SpanningRecordSerializationTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/SpanningRecordSerializationTest.java
@@ -292,15 +292,16 @@ public class SpanningRecordSerializationTest extends TestLogger {
     }
 
     private static Buffer appendLeftOverBytes(Buffer buffer, byte[] leftOverBytes) {
-        BufferBuilder bufferBuilder =
+        try (BufferBuilder bufferBuilder =
                 new BufferBuilder(
                         MemorySegmentFactory.allocateUnpooledSegment(
                                 buffer.readableBytes() + leftOverBytes.length),
-                        FreeingBufferRecycler.INSTANCE);
-        try (BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer()) {
-            bufferBuilder.append(buffer.getNioBufferReadable());
-            bufferBuilder.appendAndCommit(ByteBuffer.wrap(leftOverBytes));
-            return bufferConsumer.build();
+                        FreeingBufferRecycler.INSTANCE)) {
+            try (BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer()) {
+                bufferBuilder.append(buffer.getNioBufferReadable());
+                bufferBuilder.appendAndCommit(ByteBuffer.wrap(leftOverBytes));
+                return bufferConsumer.build();
+            }
         }
     }
 
@@ -332,6 +333,10 @@ public class SpanningRecordSerializationTest extends TestLogger {
         BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
         bufferConsumer.build().recycleBuffer();
 
+        // Closing the BufferBuilder here just allow to be sure that Buffer will be recovered when
+        // BufferConsumer will be closed.
+        bufferBuilder.close();
+
         bufferBuilder.appendAndCommit(serializedRecord);
         return new BufferAndSerializerResult(
                 bufferBuilder,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/RecordWriterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/RecordWriterTest.java
index aacfd546cbd..ec78fe26418 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/RecordWriterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/writer/RecordWriterTest.java
@@ -312,13 +312,14 @@ public class RecordWriterTest {
             assertTrue(recordWriter.getAvailableFuture().isDone());
 
             // request one buffer from the local pool to make it unavailable afterwards
-            final BufferBuilder bufferBuilder = localPool.requestBufferBuilder(0);
-            assertNotNull(bufferBuilder);
-            assertFalse(recordWriter.getAvailableFuture().isDone());
+            try (BufferBuilder bufferBuilder = localPool.requestBufferBuilder(0)) {
+                assertNotNull(bufferBuilder);
+                assertFalse(recordWriter.getAvailableFuture().isDone());
 
-            // recycle the buffer to make the local pool available again
-            final Buffer buffer = BufferBuilderTestUtils.buildSingleBuffer(bufferBuilder);
-            buffer.recycleBuffer();
+                // recycle the buffer to make the local pool available again
+                final Buffer buffer = BufferBuilderTestUtils.buildSingleBuffer(bufferBuilder);
+                buffer.recycleBuffer();
+            }
             assertTrue(recordWriter.getAvailableFuture().isDone());
             assertEquals(recordWriter.AVAILABLE, recordWriter.getAvailableFuture());
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderAndConsumerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderAndConsumerTest.java
index c6db226f8a5..029e2da2012 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderAndConsumerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderAndConsumerTest.java
@@ -18,7 +18,7 @@
 
 package org.apache.flink.runtime.io.network.buffer;
 
-import org.apache.flink.core.memory.MemorySegmentFactory;
+import org.apache.flink.core.memory.MemorySegment;
 
 import org.junit.Test;
 
@@ -28,6 +28,7 @@ import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.util.ArrayList;
 
+import static org.apache.flink.core.memory.MemorySegmentFactory.allocateUnpooledSegment;
 import static org.apache.flink.runtime.io.network.buffer.BufferBuilderTestUtils.buildSingleBuffer;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -46,6 +47,8 @@ public class BufferBuilderAndConsumerTest {
 
         assertEquals(3 * Integer.BYTES, bufferBuilder.appendAndCommit(toByteBuffer(1, 2, 3)));
 
+        bufferBuilder.close();
+
         Buffer buffer = bufferConsumer.build();
         assertFalse(buffer.isRecycled());
         buffer.recycleBuffer();
@@ -152,33 +155,37 @@ public class BufferBuilderAndConsumerTest {
 
     @Test
     public void buildEmptyBuffer() {
-        Buffer buffer = buildSingleBuffer(createBufferBuilder());
-        assertEquals(0, buffer.getSize());
-        assertContent(buffer, FreeingBufferRecycler.INSTANCE);
+        try (BufferBuilder bufferBuilder = createBufferBuilder()) {
+            Buffer buffer = buildSingleBuffer(bufferBuilder);
+            assertEquals(0, buffer.getSize());
+            assertContent(buffer, FreeingBufferRecycler.INSTANCE);
+        }
     }
 
     @Test
     public void buildingBufferMultipleTimes() {
-        BufferBuilder bufferBuilder = createBufferBuilder();
-        try (BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer()) {
-            bufferBuilder.appendAndCommit(toByteBuffer(0, 1));
-            bufferBuilder.appendAndCommit(toByteBuffer(2));
+        try (BufferBuilder bufferBuilder = createBufferBuilder()) {
+            try (BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer()) {
+                bufferBuilder.appendAndCommit(toByteBuffer(0, 1));
+                bufferBuilder.appendAndCommit(toByteBuffer(2));
 
-            assertContent(bufferConsumer, 0, 1, 2);
+                assertContent(bufferConsumer, 0, 1, 2);
 
-            bufferBuilder.appendAndCommit(toByteBuffer(3, 42));
-            bufferBuilder.appendAndCommit(toByteBuffer(44));
+                bufferBuilder.appendAndCommit(toByteBuffer(3, 42));
+                bufferBuilder.appendAndCommit(toByteBuffer(44));
 
-            assertContent(bufferConsumer, 3, 42, 44);
+                assertContent(bufferConsumer, 3, 42, 44);
 
-            ArrayList<Integer> originalValues = new ArrayList<>();
-            while (!bufferBuilder.isFull()) {
-                bufferBuilder.appendAndCommit(toByteBuffer(1337));
-                originalValues.add(1337);
-            }
+                ArrayList<Integer> originalValues = new ArrayList<>();
+                while (!bufferBuilder.isFull()) {
+                    bufferBuilder.appendAndCommit(toByteBuffer(1337));
+                    originalValues.add(1337);
+                }
 
-            assertContent(
-                    bufferConsumer, originalValues.stream().mapToInt(Integer::intValue).toArray());
+                assertContent(
+                        bufferConsumer,
+                        originalValues.stream().mapToInt(Integer::intValue).toArray());
+            }
         }
     }
 
@@ -220,6 +227,43 @@ public class BufferBuilderAndConsumerTest {
         assertEquals(0, bufferBuilder.getWritableBytes());
     }
 
+    @Test
+    public void recycleWithoutConsumer() {
+        // given: Recycler with the counter of recycle invocation.
+        CountedRecycler recycler = new CountedRecycler();
+        BufferBuilder bufferBuilder =
+                new BufferBuilder(allocateUnpooledSegment(BUFFER_SIZE), recycler);
+
+        // when: Invoke the recycle.
+        bufferBuilder.close();
+
+        // then: Recycling successfully finished.
+        assertEquals(1, recycler.recycleInvocationCounter);
+    }
+
+    @Test
+    public void recycleConsumerAndBufferBuilder() {
+        // given: Recycler with the counter of recycling invocation.
+        CountedRecycler recycler = new CountedRecycler();
+        BufferBuilder bufferBuilder =
+                new BufferBuilder(allocateUnpooledSegment(BUFFER_SIZE), recycler);
+
+        // and: One buffer consumer.
+        BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
+
+        // when: Invoke the recycle of BufferBuilder.
+        bufferBuilder.close();
+
+        // then: Nothing happened because BufferBuilder has already consumer.
+        assertEquals(0, recycler.recycleInvocationCounter);
+
+        // when: Close the consumer.
+        bufferConsumer.close();
+
+        // then: Recycling successfully finished.
+        assertEquals(1, recycler.recycleInvocationCounter);
+    }
+
     private static void testIsFinished(int writes) {
         BufferBuilder bufferBuilder = createBufferBuilder();
         BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
@@ -283,7 +327,16 @@ public class BufferBuilderAndConsumerTest {
 
     private static BufferBuilder createBufferBuilder() {
         return new BufferBuilder(
-                MemorySegmentFactory.allocateUnpooledSegment(BUFFER_SIZE),
-                FreeingBufferRecycler.INSTANCE);
+                allocateUnpooledSegment(BUFFER_SIZE), FreeingBufferRecycler.INSTANCE);
+    }
+
+    private static class CountedRecycler implements BufferRecycler {
+        int recycleInvocationCounter;
+
+        @Override
+        public void recycle(MemorySegment memorySegment) {
+            recycleInvocationCounter++;
+            memorySegment.free();
+        }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderTestUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderTestUtils.java
index f08e128ecd5..77eb28d9b68 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderTestUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/BufferBuilderTestUtils.java
@@ -39,12 +39,20 @@ public class BufferBuilderTestUtils {
         return createFilledBufferBuilder(size, 0);
     }
 
+    public static BufferBuilder createBufferBuilder(MemorySegment memorySegment) {
+        return createFilledBufferBuilder(memorySegment, 0);
+    }
+
     public static BufferBuilder createFilledBufferBuilder(int size, int dataSize) {
         checkArgument(size >= dataSize);
+        return createFilledBufferBuilder(
+                MemorySegmentFactory.allocateUnpooledSegment(size), dataSize);
+    }
+
+    public static BufferBuilder createFilledBufferBuilder(
+            MemorySegment memorySegment, int dataSize) {
         BufferBuilder bufferBuilder =
-                new BufferBuilder(
-                        MemorySegmentFactory.allocateUnpooledSegment(size),
-                        FreeingBufferRecycler.INSTANCE);
+                new BufferBuilder(memorySegment, FreeingBufferRecycler.INSTANCE);
         return fillBufferBuilder(bufferBuilder, dataSize);
     }
 
@@ -83,6 +91,7 @@ public class BufferBuilderTestUtils {
 
         if (isFinished) {
             bufferBuilder.finish();
+            bufferBuilder.close();
         }
 
         return bufferConsumer;
@@ -90,9 +99,11 @@ public class BufferBuilderTestUtils {
 
     public static BufferConsumer createEventBufferConsumer(int size, Buffer.DataType dataType) {
         return new BufferConsumer(
-                MemorySegmentFactory.allocateUnpooledSegment(size),
-                FreeingBufferRecycler.INSTANCE,
-                dataType);
+                new NetworkBuffer(
+                        MemorySegmentFactory.allocateUnpooledSegment(size),
+                        FreeingBufferRecycler.INSTANCE,
+                        dataType),
+                size);
     }
 
     public static Buffer buildBufferWithAscendingInts(int bufferSize, int numInts, int nextValue) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
index 545d37ad200..d713a3cdd24 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
@@ -449,15 +449,15 @@ public class LocalBufferPoolTest extends TestLogger {
         assertFalse(localBufferPool.getAvailableFuture().isDone());
 
         // recycle segments
-        bufferBuilder11.getRecycler().recycle(bufferBuilder11.getMemorySegment());
+        bufferBuilder11.close();
         assertFalse(localBufferPool.getAvailableFuture().isDone());
-        bufferBuilder21.getRecycler().recycle(bufferBuilder21.getMemorySegment());
+        bufferBuilder21.close();
         assertFalse(localBufferPool.getAvailableFuture().isDone());
-        bufferBuilder02.getRecycler().recycle(bufferBuilder02.getMemorySegment());
+        bufferBuilder02.close();
         assertTrue(localBufferPool.getAvailableFuture().isDone());
-        bufferBuilder01.getRecycler().recycle(bufferBuilder01.getMemorySegment());
+        bufferBuilder01.close();
         assertTrue(localBufferPool.getAvailableFuture().isDone());
-        bufferBuilder22.getRecycler().recycle(bufferBuilder22.getMemorySegment());
+        bufferBuilder22.close();
         assertTrue(localBufferPool.getAvailableFuture().isDone());
     }
 
@@ -468,55 +468,53 @@ public class LocalBufferPoolTest extends TestLogger {
         assertTrue(localBufferPool.isAvailable());
 
         // request one buffer
-        final BufferBuilder bufferBuilder =
-                checkNotNull(localBufferPool.requestBufferBuilderBlocking());
-        CompletableFuture<?> availableFuture = localBufferPool.getAvailableFuture();
-        assertFalse(availableFuture.isDone());
-
-        // set the pool size
-        final int numLocalBuffers = 5;
-        localBufferPool.setNumBuffers(numLocalBuffers);
-        assertTrue(availableFuture.isDone());
-        assertTrue(localBufferPool.isAvailable());
-
-        // drain the local buffer pool
-        final Deque<Buffer> buffers = new ArrayDeque<>(LocalBufferPoolTest.numBuffers);
-        for (int i = 0; i < numLocalBuffers - 1; i++) {
+        try (BufferBuilder bufferBuilder =
+                checkNotNull(localBufferPool.requestBufferBuilderBlocking())) {
+            CompletableFuture<?> availableFuture = localBufferPool.getAvailableFuture();
+            assertFalse(availableFuture.isDone());
+
+            // set the pool size
+            final int numLocalBuffers = 5;
+            localBufferPool.setNumBuffers(numLocalBuffers);
+            assertTrue(availableFuture.isDone());
             assertTrue(localBufferPool.isAvailable());
-            buffers.add(checkNotNull(localBufferPool.requestBuffer()));
-        }
-        assertFalse(localBufferPool.isAvailable());
 
-        buffers.pop().recycleBuffer();
-        assertTrue(localBufferPool.isAvailable());
+            // drain the local buffer pool
+            final Deque<Buffer> buffers = new ArrayDeque<>(LocalBufferPoolTest.numBuffers);
+            for (int i = 0; i < numLocalBuffers - 1; i++) {
+                assertTrue(localBufferPool.isAvailable());
+                buffers.add(checkNotNull(localBufferPool.requestBuffer()));
+            }
+            assertFalse(localBufferPool.isAvailable());
 
-        // recycle the requested segments to global buffer pool
-        for (final Buffer buffer : buffers) {
-            buffer.recycleBuffer();
-        }
-        assertTrue(localBufferPool.isAvailable());
+            buffers.pop().recycleBuffer();
+            assertTrue(localBufferPool.isAvailable());
 
-        // scale down (first buffer still taken), but there should still be one segment locally
-        // available
-        localBufferPool.setNumBuffers(2);
-        assertTrue(localBufferPool.isAvailable());
+            // recycle the requested segments to global buffer pool
+            for (final Buffer buffer : buffers) {
+                buffer.recycleBuffer();
+            }
+            assertTrue(localBufferPool.isAvailable());
 
-        final Buffer buffer2 = checkNotNull(localBufferPool.requestBuffer());
-        assertFalse(localBufferPool.isAvailable());
+            // scale down (first buffer still taken), but there should still be one segment locally
+            // available
+            localBufferPool.setNumBuffers(2);
+            assertTrue(localBufferPool.isAvailable());
 
-        buffer2.recycleBuffer();
-        assertTrue(localBufferPool.isAvailable());
+            final Buffer buffer2 = checkNotNull(localBufferPool.requestBuffer());
+            assertFalse(localBufferPool.isAvailable());
 
-        // reset the pool size
-        localBufferPool.setNumBuffers(1);
-        CompletableFuture<?> availableFuture2 = localBufferPool.getAvailableFuture();
-        assertFalse(availableFuture2.isDone());
+            buffer2.recycleBuffer();
+            assertTrue(localBufferPool.isAvailable());
+
+            // reset the pool size
+            localBufferPool.setNumBuffers(1);
+            assertFalse(localBufferPool.getAvailableFuture().isDone());
+            // recycle the requested buffer
+        }
 
-        // recycle the requested buffer
-        bufferBuilder.createBufferConsumer().close();
-        bufferBuilder.recycle();
         assertTrue(localBufferPool.isAvailable());
-        assertTrue(availableFuture2.isDone());
+        assertTrue(localBufferPool.getAvailableFuture().isDone());
     }
 
     /** For FLINK-20547: https://issues.apache.org/jira/browse/FLINK-20547. */
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
index 917c61a5b93..235ca3c9c4e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPoolTest.java
@@ -695,7 +695,7 @@ public class NetworkBufferPoolTest extends TestLogger {
 
             // recycle all the requested buffers
             for (BufferBuilder bufferBuilder : segmentsRequested) {
-                bufferBuilder.createBufferConsumer().close();
+                bufferBuilder.close();
             }
 
         } finally {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionWriteReadTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionWriteReadTest.java
index 37dad721a32..64afe9962d1 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionWriteReadTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionWriteReadTest.java
@@ -26,6 +26,7 @@ import org.apache.flink.runtime.io.disk.FileChannelManagerImpl;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.buffer.BufferConsumer;
 import org.apache.flink.runtime.io.network.buffer.BufferDecompressor;
+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;
 import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;
 import org.apache.flink.runtime.util.EnvironmentInformation;
 
@@ -232,7 +233,9 @@ public class BoundedBlockingSubpartitionWriteReadTest {
             }
 
             partition.add(
-                    new BufferConsumer(memory, (ignored) -> {}, pos, Buffer.DataType.DATA_BUFFER));
+                    new BufferConsumer(
+                            new NetworkBuffer(memory, (ignored) -> {}, Buffer.DataType.DATA_BUFFER),
+                            pos));
 
             // we need to flush after every buffer as long as the add() contract is that
             // buffer are immediately added and can be filled further after that (for low latency
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannelTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannelTest.java
index 650dc4b5272..ee48c4aa117 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannelTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannelTest.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.io.network.partition.consumer;
 
+import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.checkpoint.channel.RecordingChannelStateWriter;
 import org.apache.flink.runtime.concurrent.FutureUtils;
@@ -32,6 +33,7 @@ import org.apache.flink.runtime.io.network.buffer.BufferConsumer;
 import org.apache.flink.runtime.io.network.buffer.BufferPool;
 import org.apache.flink.runtime.io.network.buffer.BufferProvider;
 import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;
+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;
 import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;
 import org.apache.flink.runtime.io.network.partition.BufferAvailabilityListener;
 import org.apache.flink.runtime.io.network.partition.BufferWritingResultPartition;
@@ -100,11 +102,14 @@ public class LocalInputChannelTest {
         CheckpointBarrier barrier =
                 new CheckpointBarrier(
                         1L, 0L, CheckpointOptions.alignedWithTimeout(getDefault(), 123L));
+        MemorySegment memorySegment = EventSerializer.toBuffer(barrier, false).getMemorySegment();
         BufferConsumer barrierHolder =
                 new BufferConsumer(
-                        EventSerializer.toBuffer(barrier, false).getMemorySegment(),
-                        FreeingBufferRecycler.INSTANCE,
-                        Buffer.DataType.EVENT_BUFFER);
+                        new NetworkBuffer(
+                                memorySegment,
+                                FreeingBufferRecycler.INSTANCE,
+                                Buffer.DataType.EVENT_BUFFER),
+                        memorySegment.size());
         BufferConsumer data = BufferBuilderTestUtils.createFilledFinishedBufferConsumer(1);
 
         RecordingChannelStateWriter stateWriter = new RecordingChannelStateWriter();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java
index 5182e20c0bc..1828147f825 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java
@@ -35,6 +35,7 @@ import org.apache.flink.runtime.io.network.TestingPartitionRequestClient;
 import org.apache.flink.runtime.io.network.api.CheckpointBarrier;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.buffer.Buffer.DataType;
+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;
 import org.apache.flink.runtime.io.network.buffer.BufferListener.NotificationResult;
 import org.apache.flink.runtime.io.network.buffer.BufferPool;
 import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;
@@ -1237,9 +1238,11 @@ public class RemoteInputChannelTest {
             final Callable<Void> bufferPoolInteractionsTask =
                     () -> {
                         for (int i = 0; i < retries; ++i) {
-                            Buffer buffer =
-                                    buildSingleBuffer(bufferPool.requestBufferBuilderBlocking());
-                            buffer.recycleBuffer();
+                            try (BufferBuilder bufferBuilder =
+                                    bufferPool.requestBufferBuilderBlocking()) {
+                                Buffer buffer = buildSingleBuffer(bufferBuilder);
+                                buffer.recycleBuffer();
+                            }
                         }
                         return null;
                     };
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/util/TestSubpartitionProducer.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/util/TestSubpartitionProducer.java
index 2b8808a6bdc..973e68f940a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/util/TestSubpartitionProducer.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/util/TestSubpartitionProducer.java
@@ -22,6 +22,7 @@ import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.core.memory.MemorySegmentFactory;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.buffer.BufferConsumer;
+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;
 import org.apache.flink.runtime.io.network.partition.ResultSubpartition;
 import org.apache.flink.runtime.io.network.util.TestProducerSource.BufferAndChannel;
 
@@ -77,7 +78,9 @@ public class TestSubpartitionProducer implements Callable<Boolean> {
                 MemorySegment segment = MemorySegmentFactory.wrap(bufferAndChannel.getBuffer());
                 subpartition.add(
                         new BufferConsumer(
-                                segment, MemorySegment::free, Buffer.DataType.DATA_BUFFER));
+                                new NetworkBuffer(
+                                        segment, MemorySegment::free, Buffer.DataType.DATA_BUFFER),
+                                segment.size()));
 
                 // Check for interrupted flag after adding data to prevent resource leaks
                 if (Thread.interrupted()) {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java b/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java
index 47ced2c1011..4b45fe2311d 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java
@@ -121,6 +121,7 @@ public class StreamTestSingleInputGate<T> extends TestSingleInputGate {
                             BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
                             bufferBuilder.appendAndCommit(serializedRecord);
                             bufferBuilder.finish();
+                            bufferBuilder.close();
 
                             // Call getCurrentBuffer to ensure size is set
                             return Optional.of(
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
index 969867bff29..6be7815cffb 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
@@ -236,12 +236,14 @@ public class StreamTaskNetworkInputTest {
     }
 
     private BufferOrEvent createDataBuffer() throws IOException {
-        BufferBuilder bufferBuilder = BufferBuilderTestUtils.createEmptyBufferBuilder(PAGE_SIZE);
-        BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
-        serializeRecord(42L, bufferBuilder);
-        serializeRecord(44L, bufferBuilder);
+        try (BufferBuilder bufferBuilder =
+                BufferBuilderTestUtils.createEmptyBufferBuilder(PAGE_SIZE)) {
+            BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
+            serializeRecord(42L, bufferBuilder);
+            serializeRecord(44L, bufferBuilder);
 
-        return new BufferOrEvent(bufferConsumer.build(), new InputChannelInfo(0, 0));
+            return new BufferOrEvent(bufferConsumer.build(), new InputChannelInfo(0, 0));
+        }
     }
 
     private StreamTaskNetworkInput<Long> createStreamTaskNetworkInput(List<BufferOrEvent> buffers) {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/recovery/DemultiplexingRecordDeserializerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/recovery/DemultiplexingRecordDeserializerTest.java
index 447c2be36d2..09864681491 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/recovery/DemultiplexingRecordDeserializerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/recovery/DemultiplexingRecordDeserializerTest.java
@@ -19,6 +19,7 @@ package org.apache.flink.streaming.runtime.io.recovery;
 
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
 import org.apache.flink.core.memory.DataOutputSerializer;
+import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;
 import org.apache.flink.runtime.io.disk.iomanager.IOManager;
 import org.apache.flink.runtime.io.disk.iomanager.IOManagerAsync;
@@ -56,6 +57,7 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.stream.Collectors;
 
 import static java.util.Collections.emptySet;
+import static org.apache.flink.core.memory.MemorySegmentFactory.allocateUnpooledSegment;
 import static org.apache.flink.runtime.checkpoint.InflightDataRescalingDescriptorUtil.array;
 import static org.apache.flink.runtime.checkpoint.InflightDataRescalingDescriptorUtil.mappings;
 import static org.apache.flink.runtime.checkpoint.InflightDataRescalingDescriptorUtil.rescalingDescriptor;
@@ -115,15 +117,17 @@ public class DemultiplexingRecordDeserializerTest {
 
             long start = selector.getInputSubtaskIndex() << 4 | selector.getOutputSubtaskIndex();
 
-            final BufferBuilder bufferBuilder = createBufferBuilder(128);
-            Buffer buffer = writeLongs(bufferBuilder, start + 1L, start + 2L, start + 3L);
+            MemorySegment memorySegment = allocateUnpooledSegment(128);
+            try (BufferBuilder bufferBuilder = createBufferBuilder(memorySegment)) {
+                Buffer buffer = writeLongs(bufferBuilder, start + 1L, start + 2L, start + 3L);
 
-            deserializer.select(selector);
-            deserializer.setNextBuffer(buffer);
+                deserializer.select(selector);
+                deserializer.setNextBuffer(buffer);
+            }
 
             assertEquals(
                     Arrays.asList(start + 1L, start + 2L, start + 3L), readLongs(deserializer));
-            assertTrue(bufferBuilder.getMemorySegment().isFreed());
+            assertTrue(memorySegment.isFreed());
         }
     }
 
@@ -151,23 +155,25 @@ public class DemultiplexingRecordDeserializerTest {
                 deserializer.getVirtualChannelSelectors());
 
         for (int i = 0; i < 100; i++) {
-            final BufferBuilder bufferBuilder = createBufferBuilder(128);
-            // add one even and one odd number
-            Buffer buffer = writeLongs(bufferBuilder, i, i + 1L);
-
-            SubtaskConnectionDescriptor selector =
-                    Iterables.get(deserializer.getVirtualChannelSelectors(), i / 10 % 2);
-            deserializer.select(selector);
-            deserializer.setNextBuffer(buffer);
-
-            if (selector.getInputSubtaskIndex() == 41) {
-                assertEquals(Arrays.asList((long) i, i + 1L), readLongs(deserializer));
-            } else {
-                // only odd should occur in output
-                assertEquals(Arrays.asList(i / 2 * 2 + 1L), readLongs(deserializer));
+            MemorySegment memorySegment = allocateUnpooledSegment(128);
+            try (BufferBuilder bufferBuilder = createBufferBuilder(memorySegment)) {
+                // add one even and one odd number
+                Buffer buffer = writeLongs(bufferBuilder, i, i + 1L);
+
+                SubtaskConnectionDescriptor selector =
+                        Iterables.get(deserializer.getVirtualChannelSelectors(), i / 10 % 2);
+                deserializer.select(selector);
+                deserializer.setNextBuffer(buffer);
+
+                if (selector.getInputSubtaskIndex() == 41) {
+                    assertEquals(Arrays.asList((long) i, i + 1L), readLongs(deserializer));
+                } else {
+                    // only odd should occur in output
+                    assertEquals(Arrays.asList(i / 2 * 2 + 1L), readLongs(deserializer));
+                }
             }
 
-            assertTrue(bufferBuilder.getMemorySegment().isFreed());
+            assertTrue(memorySegment.isFreed());
         }
     }
 
@@ -190,13 +196,15 @@ public class DemultiplexingRecordDeserializerTest {
                         deserializer.getVirtualChannelSelectors().iterator();
                 iterator.hasNext(); ) {
             SubtaskConnectionDescriptor selector = iterator.next();
-            final BufferBuilder bufferBuilder = createBufferBuilder(128);
-            final long ts =
-                    42L + selector.getInputSubtaskIndex() + selector.getOutputSubtaskIndex();
-            Buffer buffer = write(bufferBuilder, new Watermark(ts));
-
-            deserializer.select(selector);
-            deserializer.setNextBuffer(buffer);
+            MemorySegment memorySegment = allocateUnpooledSegment(128);
+            try (BufferBuilder bufferBuilder = createBufferBuilder(memorySegment)) {
+                final long ts =
+                        42L + selector.getInputSubtaskIndex() + selector.getOutputSubtaskIndex();
+                Buffer buffer = write(bufferBuilder, new Watermark(ts));
+
+                deserializer.select(selector);
+                deserializer.setNextBuffer(buffer);
+            }
 
             if (iterator.hasNext()) {
                 assertEquals(Collections.emptyList(), read(deserializer));
@@ -205,7 +213,7 @@ public class DemultiplexingRecordDeserializerTest {
                 assertEquals(Arrays.asList(new Watermark(42)), read(deserializer));
             }
 
-            assertTrue(bufferBuilder.getMemorySegment().isFreed());
+            assertTrue(memorySegment.isFreed());
         }
     }
 
