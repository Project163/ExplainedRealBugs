diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/AbstractHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/AbstractHaServices.java
index 195b623950c..da8fb83266f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/AbstractHaServices.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/AbstractHaServices.java
@@ -253,8 +253,10 @@ public abstract class AbstractHaServices implements HighAvailabilityServices {
     /**
      * Closes the components which is used for external operations(e.g. Zookeeper Client, Kubernetes
      * Client).
+     *
+     * @throws Exception if the close operation failed
      */
-    protected abstract void internalClose();
+    protected abstract void internalClose() throws Exception;
 
     /**
      * Clean up the meta data in the distributed system(e.g. Zookeeper, Kubernetes ConfigMap).
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/AbstractZooKeeperHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/AbstractZooKeeperHaServices.java
new file mode 100644
index 00000000000..13f729e5369
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/AbstractZooKeeperHaServices.java
@@ -0,0 +1,148 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.highavailability.zookeeper;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.blob.BlobStoreService;
+import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.ZooKeeperCheckpointRecoveryFactory;
+import org.apache.flink.runtime.highavailability.AbstractHaServices;
+import org.apache.flink.runtime.highavailability.RunningJobsRegistry;
+import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.util.ZooKeeperUtils;
+
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
+import org.apache.flink.shaded.curator4.org.apache.curator.utils.ZKPaths;
+import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.KeeperException;
+
+import java.util.concurrent.Executor;
+
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
+/** Abstract ZooKeeper based HA services. */
+public abstract class AbstractZooKeeperHaServices extends AbstractHaServices {
+    /** The curator resource to use. */
+    private final CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper;
+
+    public AbstractZooKeeperHaServices(
+            CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper,
+            Executor executor,
+            Configuration configuration,
+            BlobStoreService blobStoreService) {
+        super(configuration, executor, blobStoreService);
+        this.curatorFrameworkWrapper = checkNotNull(curatorFrameworkWrapper);
+    }
+
+    protected final CuratorFramework getCuratorFramework() {
+        return curatorFrameworkWrapper.asCuratorFramework();
+    }
+
+    @Override
+    public CheckpointRecoveryFactory createCheckpointRecoveryFactory() throws Exception {
+        return new ZooKeeperCheckpointRecoveryFactory(
+                ZooKeeperUtils.useNamespaceAndEnsurePath(
+                        curatorFrameworkWrapper.asCuratorFramework(), ZooKeeperUtils.getJobsPath()),
+                configuration,
+                ioExecutor);
+    }
+
+    @Override
+    public JobGraphStore createJobGraphStore() throws Exception {
+        return ZooKeeperUtils.createJobGraphs(
+                curatorFrameworkWrapper.asCuratorFramework(), configuration);
+    }
+
+    @Override
+    public RunningJobsRegistry createRunningJobsRegistry() {
+        return new ZooKeeperRunningJobsRegistry(
+                curatorFrameworkWrapper.asCuratorFramework(), configuration);
+    }
+
+    @Override
+    protected void internalClose() throws Exception {
+        curatorFrameworkWrapper.close();
+    }
+
+    @Override
+    protected void internalCleanup() throws Exception {
+        cleanupZooKeeperPaths();
+    }
+
+    @Override
+    protected void internalCleanupJobData(JobID jobID) throws Exception {
+        deleteZNode(ZooKeeperUtils.getLeaderPathForJob(jobID));
+    }
+
+    /** Cleans up leftover ZooKeeper paths. */
+    private void cleanupZooKeeperPaths() throws Exception {
+        deleteOwnedZNode();
+        tryDeleteEmptyParentZNodes();
+    }
+
+    private void deleteOwnedZNode() throws Exception {
+        deleteZNode("/");
+    }
+
+    protected void deleteZNode(String path) throws Exception {
+        ZooKeeperUtils.deleteZNode(curatorFrameworkWrapper.asCuratorFramework(), path);
+    }
+
+    /**
+     * Tries to delete empty parent znodes.
+     *
+     * <p>IMPORTANT: This method can be removed once all supported ZooKeeper versions support the
+     * container {@link org.apache.zookeeper.CreateMode}.
+     *
+     * @throws Exception if the deletion fails for other reason than {@link
+     *     KeeperException.NotEmptyException}
+     */
+    private void tryDeleteEmptyParentZNodes() throws Exception {
+        // try to delete the parent znodes if they are empty
+        String remainingPath =
+                getParentPath(
+                        getNormalizedPath(
+                                curatorFrameworkWrapper.asCuratorFramework().getNamespace()));
+        final CuratorFramework nonNamespaceClient =
+                curatorFrameworkWrapper.asCuratorFramework().usingNamespace(null);
+
+        while (!isRootPath(remainingPath)) {
+            try {
+                nonNamespaceClient.delete().forPath(remainingPath);
+            } catch (KeeperException.NotEmptyException ignored) {
+                // We can only delete empty znodes
+                break;
+            }
+
+            remainingPath = getParentPath(remainingPath);
+        }
+    }
+
+    private static boolean isRootPath(String remainingPath) {
+        return ZKPaths.PATH_SEPARATOR.equals(remainingPath);
+    }
+
+    private static String getNormalizedPath(String path) {
+        return ZKPaths.makePath(path, "");
+    }
+
+    private static String getParentPath(String path) {
+        return ZKPaths.getPathAndNode(path).getPath();
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java
index 03c89f5d013..9c8b42fd5a7 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperHaServices.java
@@ -22,26 +22,13 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.runtime.blob.BlobStoreService;
-import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
-import org.apache.flink.runtime.checkpoint.ZooKeeperCheckpointRecoveryFactory;
 import org.apache.flink.runtime.highavailability.AbstractHaServices;
-import org.apache.flink.runtime.highavailability.RunningJobsRegistry;
-import org.apache.flink.runtime.jobmanager.JobGraphStore;
 import org.apache.flink.runtime.leaderelection.LeaderElectionService;
 import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalService;
 import org.apache.flink.runtime.util.ZooKeeperUtils;
 
-import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
-import org.apache.flink.shaded.curator4.org.apache.curator.utils.ZKPaths;
-import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.KeeperException;
-import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.data.Stat;
-
-import javax.annotation.Nonnull;
-
 import java.util.concurrent.Executor;
 
-import static org.apache.flink.util.Preconditions.checkNotNull;
-
 /**
  * An implementation of the {@link AbstractHaServices} using Apache ZooKeeper. The services store
  * data in ZooKeeper's nodes as illustrated by the following tree structure:
@@ -96,68 +83,27 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
  * HighAvailabilityOptions#HA_CLUSTER_ID}. All nodes with the same cluster id will join the same
  * cluster and participate in the execution of the same set of jobs.
  */
-public class ZooKeeperHaServices extends AbstractHaServices {
+public class ZooKeeperHaServices extends AbstractZooKeeperHaServices {
 
     // ------------------------------------------------------------------------
 
-    /** The curator resource to use. */
-    private final CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper;
-
     public ZooKeeperHaServices(
             CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper,
             Executor executor,
             Configuration configuration,
             BlobStoreService blobStoreService) {
-        super(configuration, executor, blobStoreService);
-        this.curatorFrameworkWrapper = checkNotNull(curatorFrameworkWrapper);
-    }
-
-    @Override
-    public CheckpointRecoveryFactory createCheckpointRecoveryFactory() throws Exception {
-        return new ZooKeeperCheckpointRecoveryFactory(
-                ZooKeeperUtils.useNamespaceAndEnsurePath(
-                        curatorFrameworkWrapper.asCuratorFramework(), ZooKeeperUtils.getJobsPath()),
-                configuration,
-                ioExecutor);
-    }
-
-    @Override
-    public JobGraphStore createJobGraphStore() throws Exception {
-        return ZooKeeperUtils.createJobGraphs(
-                curatorFrameworkWrapper.asCuratorFramework(), configuration);
-    }
-
-    @Override
-    public RunningJobsRegistry createRunningJobsRegistry() {
-        return new ZooKeeperRunningJobsRegistry(
-                curatorFrameworkWrapper.asCuratorFramework(), configuration);
+        super(curatorFrameworkWrapper, executor, configuration, blobStoreService);
     }
 
     @Override
     protected LeaderElectionService createLeaderElectionService(String leaderPath) {
-        return ZooKeeperUtils.createLeaderElectionService(
-                curatorFrameworkWrapper.asCuratorFramework(), leaderPath);
+        return ZooKeeperUtils.createLeaderElectionService(getCuratorFramework(), leaderPath);
     }
 
     @Override
     protected LeaderRetrievalService createLeaderRetrievalService(String leaderPath) {
         return ZooKeeperUtils.createLeaderRetrievalService(
-                curatorFrameworkWrapper.asCuratorFramework(), leaderPath, configuration);
-    }
-
-    @Override
-    public void internalClose() {
-        curatorFrameworkWrapper.close();
-    }
-
-    @Override
-    public void internalCleanup() throws Exception {
-        cleanupZooKeeperPaths();
-    }
-
-    @Override
-    public void internalCleanupJobData(JobID jobID) throws Exception {
-        deleteZNode(ZooKeeperUtils.getLeaderPathForJob(jobID));
+                getCuratorFramework(), leaderPath, configuration);
     }
 
     @Override
@@ -179,91 +125,4 @@ public class ZooKeeperHaServices extends AbstractHaServices {
     protected String getLeaderPathForRestServer() {
         return ZooKeeperUtils.getLeaderPathForRestServer();
     }
-
-    // ------------------------------------------------------------------------
-    //  Utilities
-    // ------------------------------------------------------------------------
-
-    /** Cleans up leftover ZooKeeper paths. */
-    private void cleanupZooKeeperPaths() throws Exception {
-        deleteOwnedZNode();
-        tryDeleteEmptyParentZNodes();
-    }
-
-    private void deleteOwnedZNode() throws Exception {
-        deleteZNode("/");
-    }
-
-    private void deleteZNode(String path) throws Exception {
-        // delete the HA_CLUSTER_ID znode which is owned by this cluster
-
-        // Since we are using Curator version 2.12 there is a bug in deleting the children
-        // if there is a concurrent delete operation. Therefore we need to add this retry
-        // logic. See https://issues.apache.org/jira/browse/CURATOR-430 for more information.
-        // The retry logic can be removed once we upgrade to Curator version >= 4.0.1.
-        boolean zNodeDeleted = false;
-        while (!zNodeDeleted) {
-            Stat stat = curatorFrameworkWrapper.asCuratorFramework().checkExists().forPath(path);
-            if (stat == null) {
-                logger.debug("znode {} has been deleted", path);
-                return;
-            }
-            try {
-                curatorFrameworkWrapper
-                        .asCuratorFramework()
-                        .delete()
-                        .deletingChildrenIfNeeded()
-                        .forPath(path);
-                zNodeDeleted = true;
-            } catch (KeeperException.NoNodeException ignored) {
-                // concurrent delete operation. Try again.
-                logger.debug(
-                        "Retrying to delete znode because of other concurrent delete operation.");
-            }
-        }
-    }
-
-    /**
-     * Tries to delete empty parent znodes.
-     *
-     * <p>IMPORTANT: This method can be removed once all supported ZooKeeper versions support the
-     * container {@link org.apache.zookeeper.CreateMode}.
-     *
-     * @throws Exception if the deletion fails for other reason than {@link
-     *     KeeperException.NotEmptyException}
-     */
-    private void tryDeleteEmptyParentZNodes() throws Exception {
-        // try to delete the parent znodes if they are empty
-        String remainingPath =
-                getParentPath(
-                        getNormalizedPath(
-                                curatorFrameworkWrapper.asCuratorFramework().getNamespace()));
-        final CuratorFramework nonNamespaceClient =
-                curatorFrameworkWrapper.asCuratorFramework().usingNamespace(null);
-
-        while (!isRootPath(remainingPath)) {
-            try {
-                nonNamespaceClient.delete().forPath(remainingPath);
-            } catch (KeeperException.NotEmptyException ignored) {
-                // We can only delete empty znodes
-                break;
-            }
-
-            remainingPath = getParentPath(remainingPath);
-        }
-    }
-
-    private static boolean isRootPath(String remainingPath) {
-        return ZKPaths.PATH_SEPARATOR.equals(remainingPath);
-    }
-
-    @Nonnull
-    private static String getNormalizedPath(String path) {
-        return ZKPaths.makePath(path, "");
-    }
-
-    @Nonnull
-    private static String getParentPath(String path) {
-        return ZKPaths.getPathAndNode(path).getPath();
-    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperMultipleComponentLeaderElectionHaServices.java b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperMultipleComponentLeaderElectionHaServices.java
new file mode 100644
index 00000000000..b5755b90980
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/highavailability/zookeeper/ZooKeeperMultipleComponentLeaderElectionHaServices.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.highavailability.zookeeper;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.blob.BlobStoreService;
+import org.apache.flink.runtime.leaderelection.DefaultLeaderElectionService;
+import org.apache.flink.runtime.leaderelection.DefaultMultipleComponentLeaderElectionService;
+import org.apache.flink.runtime.leaderelection.LeaderElectionService;
+import org.apache.flink.runtime.leaderelection.MultipleComponentLeaderElectionService;
+import org.apache.flink.runtime.leaderelection.ZooKeeperMultipleComponentLeaderElectionDriverFactory;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalService;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.runtime.util.ZooKeeperUtils;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.FlinkRuntimeException;
+
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
+
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.concurrent.Executor;
+
+/**
+ * ZooKeeper HA services that only use a single leader election per process.
+ *
+ * <pre>
+ * /flink
+ *      +/cluster_id_1/leader/latch
+ *      |            |       /resource_manager/connection_info
+ *      |            |       /dispatcher/connection_info
+ *      |            |       /rest_server/connection_info
+ *      |            |       /job-id-1/connection_info
+ *      |            |       /job-id-2/connection_info
+ *      |            |
+ *      |            |
+ *      |            +jobgraphs/job-id-1
+ *      |            |         /job-id-2
+ *      |            +jobs/job-id-1/checkpoints/latest
+ *      |                 |                    /latest-1
+ *      |                 |                    /latest-2
+ *      |                 |       /checkpoint_id_counter
+ * </pre>
+ */
+public class ZooKeeperMultipleComponentLeaderElectionHaServices
+        extends AbstractZooKeeperHaServices {
+
+    private final Object lock = new Object();
+
+    private final CuratorFramework leaderNamespacedCuratorFramework;
+
+    private final FatalErrorHandler fatalErrorHandler;
+
+    @Nullable
+    @GuardedBy("lock")
+    private MultipleComponentLeaderElectionService multipleComponentLeaderElectionService = null;
+
+    public ZooKeeperMultipleComponentLeaderElectionHaServices(
+            CuratorFrameworkWithUnhandledErrorListener curatorFrameworkWrapper,
+            Configuration config,
+            Executor ioExecutor,
+            BlobStoreService blobStoreService,
+            FatalErrorHandler fatalErrorHandler)
+            throws Exception {
+        super(curatorFrameworkWrapper, ioExecutor, config, blobStoreService);
+        this.leaderNamespacedCuratorFramework =
+                ZooKeeperUtils.useNamespaceAndEnsurePath(
+                        getCuratorFramework(), ZooKeeperUtils.getLeaderPath());
+        this.fatalErrorHandler = fatalErrorHandler;
+    }
+
+    @Override
+    protected LeaderElectionService createLeaderElectionService(String leaderName) {
+        return new DefaultLeaderElectionService(
+                getOrInitializeSingleLeaderElectionService().createDriverFactory(leaderName));
+    }
+
+    private MultipleComponentLeaderElectionService getOrInitializeSingleLeaderElectionService() {
+        synchronized (lock) {
+            if (multipleComponentLeaderElectionService == null) {
+                try {
+                    multipleComponentLeaderElectionService =
+                            new DefaultMultipleComponentLeaderElectionService(
+                                    fatalErrorHandler,
+                                    new ZooKeeperMultipleComponentLeaderElectionDriverFactory(
+                                            leaderNamespacedCuratorFramework));
+                } catch (Exception e) {
+                    throw new FlinkRuntimeException(
+                            String.format(
+                                    "Could not initialize the %s",
+                                    DefaultMultipleComponentLeaderElectionService.class
+                                            .getSimpleName()),
+                            e);
+                }
+            }
+
+            return multipleComponentLeaderElectionService;
+        }
+    }
+
+    @Override
+    protected LeaderRetrievalService createLeaderRetrievalService(String leaderPath) {
+        // Maybe use a single service for leader retrieval
+        return ZooKeeperUtils.createLeaderRetrievalService(
+                leaderNamespacedCuratorFramework, leaderPath, configuration);
+    }
+
+    @Override
+    protected void internalClose() throws Exception {
+        Exception exception = null;
+        synchronized (lock) {
+            if (multipleComponentLeaderElectionService != null) {
+                try {
+                    multipleComponentLeaderElectionService.close();
+                } catch (Exception e) {
+                    exception = e;
+                }
+                multipleComponentLeaderElectionService = null;
+            }
+        }
+
+        try {
+            super.internalClose();
+        } catch (Exception e) {
+            exception = ExceptionUtils.firstOrSuppressed(e, exception);
+        }
+
+        ExceptionUtils.tryRethrowException(exception);
+    }
+
+    @Override
+    protected String getLeaderPathForResourceManager() {
+        return ZooKeeperUtils.getResourceManagerNode();
+    }
+
+    @Override
+    protected String getLeaderPathForDispatcher() {
+        return ZooKeeperUtils.getDispatcherNode();
+    }
+
+    @Override
+    protected String getLeaderPathForJobManager(JobID jobID) {
+        return jobID.toString();
+    }
+
+    @Override
+    protected String getLeaderPathForRestServer() {
+        return ZooKeeperUtils.getRestServerNode();
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionDriver.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionDriver.java
index dfa197a872f..111ca05f209 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionDriver.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperLeaderElectionDriver.java
@@ -30,17 +30,10 @@ import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.lea
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.leader.LeaderLatchListener;
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.state.ConnectionState;
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.state.ConnectionStateListener;
-import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.CreateMode;
-import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.KeeperException;
-import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.data.Stat;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
 import java.util.UUID;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -171,18 +164,8 @@ public class ZooKeeperLeaderElectionDriver implements LeaderElectionDriver, Lead
         if (leaderLatch.hasLeadership()) {
             ChildData childData = cache.getCurrentData(connectionInformationPath);
             if (childData != null) {
-                final byte[] data = childData.getData();
-                if (data != null && data.length > 0) {
-                    final ByteArrayInputStream bais = new ByteArrayInputStream(data);
-                    final ObjectInputStream ois = new ObjectInputStream(bais);
-
-                    final String leaderAddress = ois.readUTF();
-                    final UUID leaderSessionID = (UUID) ois.readObject();
-
-                    leaderElectionEventHandler.onLeaderInformationChange(
-                            LeaderInformation.known(leaderSessionID, leaderAddress));
-                    return;
-                }
+                leaderElectionEventHandler.onLeaderInformationChange(
+                        ZooKeeperUtils.readLeaderInformation(childData.getData()));
             }
             leaderElectionEventHandler.onLeaderInformationChange(LeaderInformation.empty());
         }
@@ -204,51 +187,11 @@ public class ZooKeeperLeaderElectionDriver implements LeaderElectionDriver, Lead
         }
 
         try {
-            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            final ObjectOutputStream oos = new ObjectOutputStream(baos);
-
-            oos.writeUTF(leaderInformation.getLeaderAddress());
-            oos.writeObject(leaderInformation.getLeaderSessionID());
-
-            oos.close();
-
-            boolean dataWritten = false;
-
-            while (!dataWritten && leaderLatch.hasLeadership()) {
-                Stat stat = client.checkExists().forPath(connectionInformationPath);
-
-                if (stat != null) {
-                    long owner = stat.getEphemeralOwner();
-                    long sessionID = client.getZookeeperClient().getZooKeeper().getSessionId();
-
-                    if (owner == sessionID) {
-                        try {
-                            client.setData().forPath(connectionInformationPath, baos.toByteArray());
-
-                            dataWritten = true;
-                        } catch (KeeperException.NoNodeException noNode) {
-                            // node was deleted in the meantime
-                        }
-                    } else {
-                        try {
-                            client.delete().forPath(connectionInformationPath);
-                        } catch (KeeperException.NoNodeException noNode) {
-                            // node was deleted in the meantime --> try again
-                        }
-                    }
-                } else {
-                    try {
-                        client.create()
-                                .creatingParentsIfNeeded()
-                                .withMode(CreateMode.EPHEMERAL)
-                                .forPath(connectionInformationPath, baos.toByteArray());
-
-                        dataWritten = true;
-                    } catch (KeeperException.NodeExistsException nodeExists) {
-                        // node has been created in the meantime --> try again
-                    }
-                }
-            }
+            ZooKeeperUtils.writeLeaderInformationToZooKeeper(
+                    leaderInformation,
+                    client,
+                    leaderLatch::hasLeadership,
+                    connectionInformationPath);
 
             if (LOG.isDebugEnabled()) {
                 LOG.debug("Successfully wrote leader information: {}.", leaderInformation);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriver.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriver.java
new file mode 100644
index 00000000000..928bd994ab6
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriver.java
@@ -0,0 +1,272 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.runtime.util.ZooKeeperUtils;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.Preconditions;
+import org.apache.flink.util.concurrent.Executors;
+
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.cache.ChildData;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.cache.TreeCache;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.cache.TreeCacheSelector;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.leader.LeaderLatch;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.leader.LeaderLatchListener;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.state.ConnectionState;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.state.ConnectionStateListener;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/** ZooKeeper based {@link MultipleComponentLeaderElectionDriver} implementation. */
+public class ZooKeeperMultipleComponentLeaderElectionDriver
+        implements MultipleComponentLeaderElectionDriver, LeaderLatchListener {
+
+    private static final Logger LOG =
+            LoggerFactory.getLogger(ZooKeeperMultipleComponentLeaderElectionDriver.class);
+
+    private final CuratorFramework curatorFramework;
+
+    private final MultipleComponentLeaderElectionDriver.Listener leaderElectionListener;
+
+    private final LeaderLatch leaderLatch;
+
+    private final TreeCache treeCache;
+
+    private final ConnectionStateListener listener =
+            (client, newState) -> handleStateChange(newState);
+
+    private AtomicBoolean running = new AtomicBoolean(true);
+
+    public ZooKeeperMultipleComponentLeaderElectionDriver(
+            CuratorFramework curatorFramework,
+            MultipleComponentLeaderElectionDriver.Listener leaderElectionListener)
+            throws Exception {
+        this.curatorFramework = Preconditions.checkNotNull(curatorFramework);
+        this.leaderElectionListener = Preconditions.checkNotNull(leaderElectionListener);
+
+        this.leaderLatch = new LeaderLatch(curatorFramework, ZooKeeperUtils.getLeaderLatchPath());
+        this.treeCache =
+                TreeCache.newBuilder(curatorFramework, "/")
+                        .setCacheData(true)
+                        .setCreateParentNodes(false)
+                        .setSelector(
+                                new ZooKeeperMultipleComponentLeaderElectionDriver
+                                        .ConnectionInfoNodeSelector())
+                        .setExecutor(Executors.newDirectExecutorService())
+                        .build();
+        treeCache
+                .getListenable()
+                .addListener(
+                        (client, event) -> {
+                            switch (event.getType()) {
+                                case NODE_ADDED:
+                                case NODE_UPDATED:
+                                    Preconditions.checkNotNull(
+                                            event.getData(),
+                                            "The ZooKeeper event data must not be null.");
+                                    handleChangedLeaderInformation(event.getData());
+                                    break;
+                                case NODE_REMOVED:
+                                    Preconditions.checkNotNull(
+                                            event.getData(),
+                                            "The ZooKeeper event data must not be null.");
+                                    handleRemovedLeaderInformation(event.getData().getPath());
+                                    break;
+                            }
+                        });
+
+        leaderLatch.addListener(this);
+        curatorFramework.getConnectionStateListenable().addListener(listener);
+        leaderLatch.start();
+        treeCache.start();
+    }
+
+    @Override
+    public void close() throws Exception {
+        if (running.compareAndSet(true, false)) {
+            LOG.info("Closing {}.", this);
+
+            curatorFramework.getConnectionStateListenable().removeListener(listener);
+
+            Exception exception = null;
+
+            try {
+                treeCache.close();
+            } catch (Exception e) {
+                exception = e;
+            }
+
+            try {
+                leaderLatch.close();
+            } catch (Exception e) {
+                exception = ExceptionUtils.firstOrSuppressed(e, exception);
+            }
+
+            ExceptionUtils.tryRethrowException(exception);
+        }
+    }
+
+    @Override
+    public boolean hasLeadership() {
+        return leaderLatch.hasLeadership();
+    }
+
+    @Override
+    public void publishLeaderInformation(String componentId, LeaderInformation leaderInformation)
+            throws Exception {
+        Preconditions.checkState(running.get());
+
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Write leader information {} for {}.", leaderInformation, componentId);
+        }
+
+        if (!leaderLatch.hasLeadership()) {
+            return;
+        }
+
+        final String connectionInformationPath =
+                ZooKeeperUtils.generateConnectionInformationPath(componentId);
+
+        ZooKeeperUtils.writeLeaderInformationToZooKeeper(
+                leaderInformation,
+                curatorFramework,
+                leaderLatch::hasLeadership,
+                connectionInformationPath);
+    }
+
+    @Override
+    public void deleteLeaderInformation(String leaderName) throws Exception {
+        ZooKeeperUtils.deleteZNode(
+                curatorFramework, ZooKeeperUtils.generateZookeeperPath(leaderName));
+    }
+
+    private void handleStateChange(ConnectionState newState) {
+        switch (newState) {
+            case CONNECTED:
+                LOG.debug("Connected to ZooKeeper quorum. Leader election can start.");
+                break;
+            case SUSPENDED:
+                LOG.warn("Connection to ZooKeeper suspended, waiting for reconnection.");
+                break;
+            case RECONNECTED:
+                LOG.info(
+                        "Connection to ZooKeeper was reconnected. Leader election can be restarted.");
+                break;
+            case LOST:
+                // Maybe we have to throw an exception here to terminate the JobManager
+                LOG.warn(
+                        "Connection to ZooKeeper lost. The contender no longer participates in the leader election.");
+                break;
+        }
+    }
+
+    @Override
+    public void isLeader() {
+        LOG.debug("{} obtained the leadership.", this);
+        leaderElectionListener.isLeader();
+    }
+
+    @Override
+    public void notLeader() {
+        LOG.debug("{} lost the leadership.", this);
+        leaderElectionListener.notLeader();
+    }
+
+    private void handleChangedLeaderInformation(ChildData childData) {
+        if (shouldHandleLeaderInformationEvent(childData.getPath())) {
+            final String leaderName = extractLeaderName(childData.getPath());
+
+            final LeaderInformation leaderInformation =
+                    tryReadingLeaderInformation(childData, leaderName);
+
+            leaderElectionListener.notifyLeaderInformationChange(leaderName, leaderInformation);
+        }
+    }
+
+    private String extractLeaderName(String path) {
+        final String[] splits = ZooKeeperUtils.splitZooKeeperPath(path);
+
+        Preconditions.checkState(
+                splits.length >= 2,
+                String.format(
+                        "Expecting path consisting of /<leader_name>/connection_info. Got path '%s'",
+                        path));
+
+        return splits[splits.length - 2];
+    }
+
+    private void handleRemovedLeaderInformation(String removedNodePath) {
+        if (shouldHandleLeaderInformationEvent(removedNodePath)) {
+            final String leaderName = extractLeaderName(removedNodePath);
+
+            leaderElectionListener.notifyLeaderInformationChange(
+                    leaderName, LeaderInformation.empty());
+        }
+    }
+
+    private boolean shouldHandleLeaderInformationEvent(String path) {
+        return running.get() && leaderLatch.hasLeadership() && isConnectionInfoNode(path);
+    }
+
+    private boolean isConnectionInfoNode(String path) {
+        return path.endsWith(ZooKeeperUtils.CONNECTION_INFO_NODE);
+    }
+
+    private LeaderInformation tryReadingLeaderInformation(ChildData childData, String id) {
+        LeaderInformation leaderInformation;
+        try {
+            leaderInformation = ZooKeeperUtils.readLeaderInformation(childData.getData());
+
+            LOG.debug("Leader information for {} has changed to {}.", id, leaderInformation);
+        } catch (IOException | ClassNotFoundException e) {
+            LOG.debug(
+                    "Could not read leader information for {}. Rewriting the information.", id, e);
+            leaderInformation = LeaderInformation.empty();
+        }
+
+        return leaderInformation;
+    }
+
+    /**
+     * This selector finds all connection info nodes. See {@link
+     * org.apache.flink.runtime.highavailability.zookeeper.ZooKeeperMultipleComponentLeaderElectionHaServices}
+     * for more details on the Znode layout.
+     */
+    private static class ConnectionInfoNodeSelector implements TreeCacheSelector {
+        @Override
+        public boolean traverseChildren(String fullPath) {
+            return true;
+        }
+
+        @Override
+        public boolean acceptChild(String fullPath) {
+            return !fullPath.endsWith(ZooKeeperUtils.getLeaderLatchPath());
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "ZooKeeperMultipleComponentLeaderElectionDriver";
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverFactory.java
new file mode 100644
index 00000000000..841ebe39c39
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverFactory.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.util.Preconditions;
+
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
+
+/** Factory for {@link ZooKeeperMultipleComponentLeaderElectionDriver}. */
+public class ZooKeeperMultipleComponentLeaderElectionDriverFactory
+        implements MultipleComponentLeaderElectionDriverFactory {
+
+    private final CuratorFramework curatorFramework;
+
+    public ZooKeeperMultipleComponentLeaderElectionDriverFactory(
+            CuratorFramework curatorFramework) {
+        this.curatorFramework = Preconditions.checkNotNull(curatorFramework);
+    }
+
+    @Override
+    public ZooKeeperMultipleComponentLeaderElectionDriver create(
+            MultipleComponentLeaderElectionDriver.Listener leaderElectionListener)
+            throws Exception {
+        return new ZooKeeperMultipleComponentLeaderElectionDriver(
+                curatorFramework, leaderElectionListener);
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java
index cce86039352..1d8e4916667 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/util/ZooKeeperUtils.java
@@ -41,6 +41,7 @@ import org.apache.flink.runtime.jobmanager.ZooKeeperJobGraphStoreUtil;
 import org.apache.flink.runtime.jobmanager.ZooKeeperJobGraphStoreWatcher;
 import org.apache.flink.runtime.leaderelection.DefaultLeaderElectionService;
 import org.apache.flink.runtime.leaderelection.LeaderElectionDriverFactory;
+import org.apache.flink.runtime.leaderelection.LeaderInformation;
 import org.apache.flink.runtime.leaderelection.ZooKeeperLeaderElectionDriver;
 import org.apache.flink.runtime.leaderelection.ZooKeeperLeaderElectionDriverFactory;
 import org.apache.flink.runtime.leaderretrieval.DefaultLeaderRetrievalService;
@@ -66,8 +67,11 @@ import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.cac
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.recipes.cache.TreeCacheSelector;
 import org.apache.flink.shaded.curator4.org.apache.curator.framework.state.SessionConnectionStateErrorPolicy;
 import org.apache.flink.shaded.curator4.org.apache.curator.retry.ExponentialBackoffRetry;
+import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.CreateMode;
+import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.KeeperException;
 import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.ZooDefs;
 import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.data.ACL;
+import org.apache.flink.shaded.zookeeper3.org.apache.zookeeper.data.Stat;
 
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
@@ -75,13 +79,19 @@ import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nonnull;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.io.Serializable;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
+import java.util.UUID;
 import java.util.concurrent.Executor;
+import java.util.function.BooleanSupplier;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
@@ -96,13 +106,17 @@ public class ZooKeeperUtils {
     /** The prefix of the completed checkpoint file. */
     public static final String HA_STORAGE_COMPLETED_CHECKPOINT = "completedCheckpoint";
 
-    private static final String RESOURCE_MANAGER_LEADER = "/resource_manager";
+    private static final String RESOURCE_MANAGER_LEADER = "resource_manager";
 
-    private static final String DISPATCHER_LEADER = "/dispatcher";
+    private static final String DISPATCHER_LEADER = "dispatcher";
 
-    private static final String LEADER_NODE = "/leader";
+    private static final String LEADER_NODE = "leader";
 
-    private static final String REST_SERVER_LEADER = "/rest_server";
+    private static final String REST_SERVER_LEADER = "rest_server";
+
+    private static final String LEADER_LATCH_NODE = "latch";
+
+    public static final String CONNECTION_INFO_NODE = "connection_info";
 
     public static String getLeaderPathForResourceManager() {
         return getLeaderPath(RESOURCE_MANAGER_LEADER);
@@ -120,6 +134,10 @@ public class ZooKeeperUtils {
         return generateZookeeperPath(getLeaderPathForJob(jobId), LEADER_NODE);
     }
 
+    public static String getSingleLeaderElectionPathForJobManager(JobID jobID) {
+        return getLeaderPath(jobID.toString());
+    }
+
     @Nonnull
     public static String getLeaderPathForJob(JobID jobId) {
         return generateZookeeperPath(getJobsPath(), getPathForJob(jobId));
@@ -137,17 +155,37 @@ public class ZooKeeperUtils {
         return "/checkpoint_id_counter";
     }
 
+    public static String getLeaderPath() {
+        return generateZookeeperPath(LEADER_NODE);
+    }
+
+    public static String getDispatcherNode() {
+        return DISPATCHER_LEADER;
+    }
+
+    public static String getResourceManagerNode() {
+        return RESOURCE_MANAGER_LEADER;
+    }
+
+    public static String getRestServerNode() {
+        return REST_SERVER_LEADER;
+    }
+
+    public static String getLeaderLatchPath() {
+        return generateZookeeperPath(LEADER_LATCH_NODE);
+    }
+
     private static String getLeaderPath(String suffix) {
         return generateZookeeperPath(LEADER_NODE, suffix);
     }
 
     @Nonnull
     public static String generateConnectionInformationPath(String path) {
-        return generateZookeeperPath(path, "connection_info");
+        return generateZookeeperPath(path, CONNECTION_INFO_NODE);
     }
 
     public static String generateLeaderLatchPath(String path) {
-        return generateZookeeperPath(path, "latch");
+        return generateZookeeperPath(path, LEADER_LATCH_NODE);
     }
 
     /**
@@ -402,6 +440,87 @@ public class ZooKeeperUtils {
         return new ZooKeeperLeaderElectionDriverFactory(client, path);
     }
 
+    public static void writeLeaderInformationToZooKeeper(
+            LeaderInformation leaderInformation,
+            CuratorFramework curatorFramework,
+            BooleanSupplier hasLeadershipCheck,
+            String connectionInformationPath)
+            throws Exception {
+        final byte[] data;
+
+        if (leaderInformation.isEmpty()) {
+            data = null;
+        } else {
+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            final ObjectOutputStream oos = new ObjectOutputStream(baos);
+
+            oos.writeUTF(leaderInformation.getLeaderAddress());
+            oos.writeObject(leaderInformation.getLeaderSessionID());
+
+            oos.close();
+
+            data = baos.toByteArray();
+        }
+
+        boolean dataWritten = false;
+
+        while (!dataWritten && hasLeadershipCheck.getAsBoolean()) {
+            Stat stat = curatorFramework.checkExists().forPath(connectionInformationPath);
+
+            if (stat != null) {
+                long owner = stat.getEphemeralOwner();
+                long sessionID =
+                        curatorFramework.getZookeeperClient().getZooKeeper().getSessionId();
+
+                if (owner == sessionID) {
+                    try {
+                        curatorFramework.setData().forPath(connectionInformationPath, data);
+
+                        dataWritten = true;
+                    } catch (KeeperException.NoNodeException noNode) {
+                        // node was deleted in the meantime
+                    }
+                } else {
+                    try {
+                        curatorFramework.delete().forPath(connectionInformationPath);
+                    } catch (KeeperException.NoNodeException noNode) {
+                        // node was deleted in the meantime --> try again
+                    }
+                }
+            } else {
+                try {
+                    curatorFramework
+                            .create()
+                            .creatingParentsIfNeeded()
+                            .withMode(CreateMode.EPHEMERAL)
+                            .forPath(connectionInformationPath, data);
+
+                    dataWritten = true;
+                } catch (KeeperException.NodeExistsException nodeExists) {
+                    // node has been created in the meantime --> try again
+                }
+            }
+        }
+    }
+
+    public static LeaderInformation readLeaderInformation(byte[] data)
+            throws IOException, ClassNotFoundException {
+        if (data != null && data.length > 0) {
+            final ByteArrayInputStream bais = new ByteArrayInputStream(data);
+            final String leaderAddress;
+            final UUID leaderSessionID;
+
+            try (final ObjectInputStream ois = new ObjectInputStream(bais)) {
+                leaderAddress = ois.readUTF();
+                leaderSessionID = (UUID) ois.readObject();
+            }
+
+            return LeaderInformation.known(leaderSessionID, leaderAddress);
+        } else {
+            return LeaderInformation.empty();
+        }
+    }
+
     /**
      * Creates a {@link DefaultJobGraphStore} instance with {@link ZooKeeperStateHandleStore},
      * {@link ZooKeeperJobGraphStoreWatcher} and {@link ZooKeeperJobGraphStoreUtil}.
@@ -544,10 +663,10 @@ public class ZooKeeperUtils {
                 prefix);
     }
 
-    /** Creates a ZooKeeper path of the form "/root/child". */
-    public static String generateZookeeperPath(String root, String child) {
+    /** Creates a ZooKeeper path of the form "/a/b/.../z". */
+    public static String generateZookeeperPath(String... paths) {
         final String result =
-                Stream.of(root, child)
+                Arrays.stream(paths)
                         .map(ZooKeeperUtils::trimSlashes)
                         .filter(s -> !s.isEmpty())
                         .collect(Collectors.joining("/", "/", ""));
@@ -555,6 +674,16 @@ public class ZooKeeperUtils {
         return result;
     }
 
+    /**
+     * Splits the given ZooKeeper path into its parts.
+     *
+     * @param path path to split
+     * @return splited path
+     */
+    public static String[] splitZooKeeperPath(String path) {
+        return path.split("/");
+    }
+
     public static String trimStartingSlash(String path) {
         return path.startsWith("/") ? path.substring(1) : path;
     }
@@ -701,6 +830,29 @@ public class ZooKeeperUtils {
         }
     }
 
+    public static void deleteZNode(CuratorFramework curatorFramework, String path)
+            throws Exception {
+        // Since we are using Curator version 2.12 there is a bug in deleting the children
+        // if there is a concurrent delete operation. Therefore we need to add this retry
+        // logic. See https://issues.apache.org/jira/browse/CURATOR-430 for more information.
+        // The retry logic can be removed once we upgrade to Curator version >= 4.0.1.
+        boolean zNodeDeleted = false;
+        while (!zNodeDeleted) {
+            Stat stat = curatorFramework.checkExists().forPath(path);
+            if (stat == null) {
+                LOG.debug("znode {} has been deleted", path);
+                return;
+            }
+            try {
+                curatorFramework.delete().deletingChildrenIfNeeded().forPath(path);
+                zNodeDeleted = true;
+            } catch (KeeperException.NoNodeException ignored) {
+                // concurrent delete operation. Try again.
+                LOG.debug("Retrying to delete znode because of other concurrent delete operation.");
+            }
+        }
+    }
+
     /** Private constructor to prevent instantiation. */
     private ZooKeeperUtils() {
         throw new RuntimeException();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java
new file mode 100644
index 00000000000..c827bdfe3da
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/ZooKeeperMultipleComponentLeaderElectionDriverTest.java
@@ -0,0 +1,591 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.api.common.time.Deadline;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.HighAvailabilityOptions;
+import org.apache.flink.core.testutils.EachCallbackWrapper;
+import org.apache.flink.runtime.highavailability.zookeeper.CuratorFrameworkWithUnhandledErrorListener;
+import org.apache.flink.runtime.leaderretrieval.DefaultLeaderRetrievalService;
+import org.apache.flink.runtime.leaderretrieval.ZooKeeperLeaderRetrievalDriver;
+import org.apache.flink.runtime.leaderretrieval.ZooKeeperLeaderRetrievalDriverFactory;
+import org.apache.flink.runtime.rest.util.NoOpFatalErrorHandler;
+import org.apache.flink.runtime.util.ZooKeeperUtils;
+import org.apache.flink.runtime.zookeeper.ZooKeeperExtension;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.TestLoggerExtension;
+import org.apache.flink.util.function.RunnableWithException;
+
+import org.apache.flink.shaded.curator4.com.google.common.collect.Iterables;
+import org.apache.flink.shaded.curator4.org.apache.curator.framework.CuratorFramework;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import java.time.Duration;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Tests for the {@link ZooKeeperMultipleComponentLeaderElectionDriver}. */
+@ExtendWith(TestLoggerExtension.class)
+class ZooKeeperMultipleComponentLeaderElectionDriverTest {
+
+    private final ZooKeeperExtension zooKeeperExtension = new ZooKeeperExtension();
+
+    @RegisterExtension
+    private final EachCallbackWrapper<ZooKeeperExtension> eachWrapper =
+            new EachCallbackWrapper<>(zooKeeperExtension);
+
+    @Test
+    public void testElectionDriverGainsLeadershipAtStartup() throws Exception {
+        new Context() {
+            {
+                runTest(() -> leaderElectionListener.await(IsLeaderEvent.class));
+            }
+        };
+    }
+
+    @Test
+    public void testElectionDriverLosesLeadership() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderElectionListener.await(IsLeaderEvent.class);
+                            zooKeeperExtension.stop();
+                            leaderElectionListener.await(NotLeaderEvent.class);
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testPublishLeaderInformation() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderElectionListener.await(IsLeaderEvent.class);
+
+                            final String componentId = "retrieved-component";
+                            final DefaultLeaderRetrievalService defaultLeaderRetrievalService =
+                                    new DefaultLeaderRetrievalService(
+                                            new ZooKeeperLeaderRetrievalDriverFactory(
+                                                    curatorFramework.asCuratorFramework(),
+                                                    componentId,
+                                                    ZooKeeperLeaderRetrievalDriver
+                                                            .LeaderInformationClearancePolicy
+                                                            .ON_LOST_CONNECTION));
+
+                            final TestingListener leaderRetrievalListener = new TestingListener();
+                            defaultLeaderRetrievalService.start(leaderRetrievalListener);
+
+                            final LeaderInformation leaderInformation =
+                                    LeaderInformation.known(UUID.randomUUID(), "foobar");
+                            leaderElectionDriver.publishLeaderInformation(
+                                    componentId, leaderInformation);
+
+                            leaderRetrievalListener.waitForNewLeader(10_000L);
+
+                            assertThat(leaderRetrievalListener.getLeader())
+                                    .isEqualTo(leaderInformation);
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testPublishEmptyLeaderInformation() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderElectionListener.await(IsLeaderEvent.class);
+
+                            final String componentId = "retrieved-component";
+                            final DefaultLeaderRetrievalService defaultLeaderRetrievalService =
+                                    new DefaultLeaderRetrievalService(
+                                            new ZooKeeperLeaderRetrievalDriverFactory(
+                                                    curatorFramework.asCuratorFramework(),
+                                                    componentId,
+                                                    ZooKeeperLeaderRetrievalDriver
+                                                            .LeaderInformationClearancePolicy
+                                                            .ON_LOST_CONNECTION));
+
+                            final TestingListener leaderRetrievalListener = new TestingListener();
+                            defaultLeaderRetrievalService.start(leaderRetrievalListener);
+
+                            leaderElectionDriver.publishLeaderInformation(
+                                    componentId,
+                                    LeaderInformation.known(UUID.randomUUID(), "foobar"));
+
+                            leaderRetrievalListener.waitForNewLeader(10_000L);
+
+                            leaderElectionDriver.publishLeaderInformation(
+                                    componentId, LeaderInformation.empty());
+
+                            leaderRetrievalListener.waitForEmptyLeaderInformation(10_000L);
+
+                            assertThat(leaderRetrievalListener.getLeader())
+                                    .isEqualTo(LeaderInformation.empty());
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testNonLeaderCannotPublishLeaderInformation() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            ElectionDriver otherLeaderElectionDriver = null;
+                            try {
+                                leaderElectionListener.await(IsLeaderEvent.class);
+
+                                otherLeaderElectionDriver =
+                                        createLeaderElectionDriver(
+                                                curatorFramework.asCuratorFramework());
+
+                                assertThat(otherLeaderElectionDriver.hasLeadership()).isFalse();
+
+                                otherLeaderElectionDriver.publishLeaderInformation(
+                                        "componentId",
+                                        LeaderInformation.known(UUID.randomUUID(), "localhost"));
+
+                                assertThat(
+                                                leaderElectionListener.await(
+                                                        LeaderInformationChangeEvent.class,
+                                                        Duration.ofMillis(50L)))
+                                        .isEmpty();
+                            } finally {
+                                if (otherLeaderElectionDriver != null) {
+                                    otherLeaderElectionDriver.close();
+                                }
+                            }
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testLeaderInformationChange() throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderElectionListener.await(IsLeaderEvent.class);
+
+                            final LeaderInformation leaderInformation =
+                                    LeaderInformation.known(UUID.randomUUID(), "foobar");
+                            final String componentId = "componentId";
+                            final String path =
+                                    ZooKeeperUtils.generateConnectionInformationPath(componentId);
+
+                            ZooKeeperUtils.writeLeaderInformationToZooKeeper(
+                                    leaderInformation,
+                                    curatorFramework.asCuratorFramework(),
+                                    () -> true,
+                                    path);
+
+                            final LeaderInformationChangeEvent leaderInformationChangeEvent =
+                                    leaderElectionListener.await(
+                                            LeaderInformationChangeEvent.class);
+
+                            assertThat(leaderInformationChangeEvent.getComponentId())
+                                    .isEqualTo(componentId);
+                            assertThat(leaderInformationChangeEvent.getLeaderInformation())
+                                    .isEqualTo(leaderInformation);
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testLeaderElectionWithMultipleDrivers() throws Exception {
+        final CuratorFrameworkWithUnhandledErrorListener curatorFramework = startCuratorFramework();
+
+        try {
+            Set<ElectionDriver> electionDrivers =
+                    Stream.generate(
+                                    () ->
+                                            createLeaderElectionDriver(
+                                                    curatorFramework.asCuratorFramework()))
+                            .limit(3)
+                            .collect(Collectors.toSet());
+
+            while (!electionDrivers.isEmpty()) {
+                final CompletableFuture<Object> anyLeader =
+                        CompletableFuture.anyOf(
+                                electionDrivers.stream()
+                                        .map(ElectionDriver::getLeadershipFuture)
+                                        .collect(Collectors.toList())
+                                        .toArray(new CompletableFuture[0]));
+
+                // wait for any leader
+                anyLeader.join();
+
+                final Map<Boolean, Set<ElectionDriver>> leaderAndRest =
+                        electionDrivers.stream()
+                                .collect(
+                                        Collectors.partitioningBy(
+                                                ElectionDriver::hasLeadership, Collectors.toSet()));
+
+                assertThat(leaderAndRest.get(true)).hasSize(1);
+                Iterables.getOnlyElement(leaderAndRest.get(true)).close();
+
+                electionDrivers = leaderAndRest.get(false);
+            }
+        } finally {
+            curatorFramework.close();
+        }
+    }
+
+    @Test
+    public void testLeaderConnectionInfoNodeRemovalLeadsToLeaderChangeWithEmptyLeaderInformation()
+            throws Exception {
+        new Context() {
+            {
+                runTest(
+                        () -> {
+                            leaderElectionListener.await(IsLeaderEvent.class);
+
+                            final LeaderInformation leaderInformation =
+                                    LeaderInformation.known(UUID.randomUUID(), "foobar");
+                            final String componentId = "componentId";
+                            final String path =
+                                    ZooKeeperUtils.generateConnectionInformationPath(componentId);
+
+                            ZooKeeperUtils.writeLeaderInformationToZooKeeper(
+                                    leaderInformation,
+                                    curatorFramework.asCuratorFramework(),
+                                    () -> true,
+                                    path);
+
+                            // wait for the publishing of the leader information
+                            leaderElectionListener.await(LeaderInformationChangeEvent.class);
+
+                            curatorFramework.asCuratorFramework().delete().forPath(path);
+
+                            // wait for the removal of the leader information
+                            final LeaderInformationChangeEvent leaderInformationChangeEvent =
+                                    leaderElectionListener.await(
+                                            LeaderInformationChangeEvent.class);
+                            assertThat(leaderInformationChangeEvent.getComponentId())
+                                    .isEqualTo(componentId);
+                            assertThat(leaderInformationChangeEvent.getLeaderInformation())
+                                    .isEqualTo(LeaderInformation.empty());
+                        });
+            }
+        };
+    }
+
+    private static ElectionDriver createLeaderElectionDriver(CuratorFramework curatorFramework) {
+        final SimpleLeaderElectionListener leaderElectionListener =
+                new SimpleLeaderElectionListener();
+
+        try {
+            final ZooKeeperMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                    createLeaderElectionDriver(leaderElectionListener, curatorFramework);
+            return new ElectionDriver(leaderElectionDriver, leaderElectionListener);
+        } catch (Exception e) {
+            ExceptionUtils.rethrow(e);
+            return null;
+        }
+    }
+
+    private static final class ElectionDriver {
+        private final ZooKeeperMultipleComponentLeaderElectionDriver leaderElectionDriver;
+        private final SimpleLeaderElectionListener leaderElectionListener;
+
+        private ElectionDriver(
+                ZooKeeperMultipleComponentLeaderElectionDriver leaderElectionDriver,
+                SimpleLeaderElectionListener leaderElectionListener) {
+            this.leaderElectionDriver = leaderElectionDriver;
+            this.leaderElectionListener = leaderElectionListener;
+        }
+
+        void close() throws Exception {
+            leaderElectionDriver.close();
+        }
+
+        boolean hasLeadership() {
+            return leaderElectionDriver.hasLeadership();
+        }
+
+        CompletableFuture<Void> getLeadershipFuture() {
+            return leaderElectionListener.getLeadershipFuture();
+        }
+
+        void publishLeaderInformation(String componentId, LeaderInformation leaderInformation)
+                throws Exception {
+            leaderElectionDriver.publishLeaderInformation(componentId, leaderInformation);
+        }
+    }
+
+    private static final class SimpleLeaderElectionListener
+            implements MultipleComponentLeaderElectionDriver.Listener {
+
+        private final CompletableFuture<Void> leadershipFuture = new CompletableFuture<>();
+
+        CompletableFuture<Void> getLeadershipFuture() {
+            return leadershipFuture;
+        }
+
+        @Override
+        public void isLeader() {
+            leadershipFuture.complete(null);
+        }
+
+        @Override
+        public void notLeader() {}
+
+        @Override
+        public void notifyLeaderInformationChange(
+                String componentId, LeaderInformation leaderInformation) {}
+
+        @Override
+        public void notifyAllKnownLeaderInformation(
+                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {}
+    }
+
+    private static ZooKeeperMultipleComponentLeaderElectionDriver createLeaderElectionDriver(
+            MultipleComponentLeaderElectionDriver.Listener leaderElectionListener,
+            CuratorFramework curatorFramework)
+            throws Exception {
+        return new ZooKeeperMultipleComponentLeaderElectionDriver(
+                curatorFramework, leaderElectionListener);
+    }
+
+    private CuratorFrameworkWithUnhandledErrorListener startCuratorFramework() {
+        final Configuration configuration = new Configuration();
+        configuration.set(
+                HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperExtension.getConnectString());
+        return ZooKeeperUtils.startCuratorFramework(configuration, NoOpFatalErrorHandler.INSTANCE);
+    }
+
+    private static final class TestingLeaderElectionListener
+            implements MultipleComponentLeaderElectionDriver.Listener {
+        private final BlockingQueue<LeaderElectionEvent> leaderElectionEvents =
+                new ArrayBlockingQueue<>(10);
+
+        @Override
+        public void isLeader() {
+            put(new IsLeaderEvent());
+        }
+
+        @Override
+        public void notLeader() {
+            put(new NotLeaderEvent());
+        }
+
+        @Override
+        public void notifyLeaderInformationChange(
+                String componentId, LeaderInformation leaderInformation) {
+            put(new LeaderInformationChangeEvent(componentId, leaderInformation));
+        }
+
+        @Override
+        public void notifyAllKnownLeaderInformation(
+                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
+            put(new AllKnownLeaderInformationEvent(leaderInformationWithComponentIds));
+        }
+
+        private void put(LeaderElectionEvent leaderElectionEvent) {
+            try {
+                leaderElectionEvents.put(leaderElectionEvent);
+            } catch (InterruptedException e) {
+                ExceptionUtils.rethrow(e);
+            }
+        }
+
+        public <T> T await(Class<T> clazz) throws InterruptedException {
+            while (true) {
+                final LeaderElectionEvent leaderElectionEvent = leaderElectionEvents.take();
+
+                if (clazz.isAssignableFrom(leaderElectionEvent.getClass())) {
+                    return clazz.cast(leaderElectionEvent);
+                }
+            }
+        }
+
+        public <T> Optional<T> await(Class<T> clazz, Duration timeout) throws InterruptedException {
+            final Deadline deadline = Deadline.fromNow(timeout);
+
+            while (true) {
+                final Duration timeLeft = deadline.timeLeft();
+
+                if (timeLeft.isNegative()) {
+                    return Optional.empty();
+                } else {
+                    final Optional<LeaderElectionEvent> optLeaderElectionEvent =
+                            Optional.ofNullable(
+                                    leaderElectionEvents.poll(
+                                            timeLeft.toMillis(), TimeUnit.MILLISECONDS));
+
+                    if (optLeaderElectionEvent.isPresent()) {
+                        final LeaderElectionEvent leaderElectionEvent =
+                                optLeaderElectionEvent.get();
+
+                        if (clazz.isAssignableFrom(leaderElectionEvent.getClass())) {
+                            return Optional.of(clazz.cast(optLeaderElectionEvent));
+                        }
+                    } else {
+                        return Optional.empty();
+                    }
+                }
+            }
+        }
+    }
+
+    private abstract static class LeaderElectionEvent {
+        boolean isIsLeaderEvent() {
+            return false;
+        }
+
+        boolean isNotLeaderEvent() {
+            return false;
+        }
+
+        boolean isLeaderInformationChangeEvent() {
+            return false;
+        }
+
+        boolean isAllKnownLeaderInformationEvent() {
+            return false;
+        }
+
+        IsLeaderEvent asIsLeaderEvent() {
+            return as(IsLeaderEvent.class);
+        }
+
+        NotLeaderEvent asNotLeaderEvent() {
+            return as(NotLeaderEvent.class);
+        }
+
+        LeaderInformationChangeEvent asLeaderInformationChangeEvent() {
+            return as(LeaderInformationChangeEvent.class);
+        }
+
+        AllKnownLeaderInformationEvent asAllKnownLeaderInformationEvent() {
+            return as(AllKnownLeaderInformationEvent.class);
+        }
+
+        <T> T as(Class<T> clazz) {
+            if (clazz.isAssignableFrom(getClass())) {
+                return clazz.cast(this);
+            } else {
+                throw new IllegalStateException("Cannot cast object.");
+            }
+        }
+    }
+
+    private static class IsLeaderEvent extends LeaderElectionEvent {
+        @Override
+        boolean isIsLeaderEvent() {
+            return true;
+        }
+    }
+
+    private static class NotLeaderEvent extends LeaderElectionEvent {
+        @Override
+        boolean isNotLeaderEvent() {
+            return true;
+        }
+    }
+
+    private static class LeaderInformationChangeEvent extends LeaderElectionEvent {
+        private final String componentId;
+        private final LeaderInformation leaderInformation;
+
+        private LeaderInformationChangeEvent(
+                String componentId, LeaderInformation leaderInformation) {
+            this.componentId = componentId;
+            this.leaderInformation = leaderInformation;
+        }
+
+        @Override
+        boolean isLeaderInformationChangeEvent() {
+            return true;
+        }
+
+        public String getComponentId() {
+            return componentId;
+        }
+
+        public LeaderInformation getLeaderInformation() {
+            return leaderInformation;
+        }
+    }
+
+    private static class AllKnownLeaderInformationEvent extends LeaderElectionEvent {
+        private final Collection<LeaderInformationWithComponentId>
+                leaderInformationWithComponentIds;
+
+        private AllKnownLeaderInformationEvent(
+                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
+            this.leaderInformationWithComponentIds = leaderInformationWithComponentIds;
+        }
+
+        @Override
+        boolean isAllKnownLeaderInformationEvent() {
+            return true;
+        }
+    }
+
+    private class Context {
+        protected final TestingLeaderElectionListener leaderElectionListener;
+        protected final CuratorFrameworkWithUnhandledErrorListener curatorFramework;
+        protected final ZooKeeperMultipleComponentLeaderElectionDriver leaderElectionDriver;
+
+        private Context() throws Exception {
+            this.leaderElectionListener = new TestingLeaderElectionListener();
+            this.curatorFramework = startCuratorFramework();
+            this.leaderElectionDriver =
+                    createLeaderElectionDriver(
+                            leaderElectionListener, curatorFramework.asCuratorFramework());
+        }
+
+        protected final void runTest(RunnableWithException test) throws Exception {
+            try {
+                test.run();
+            } finally {
+                close();
+            }
+        }
+
+        private void close() throws Exception {
+            this.leaderElectionDriver.close();
+            this.curatorFramework.close();
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsITCase.java
new file mode 100644
index 00000000000..b4b6818f814
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsITCase.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.util;
+
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.HighAvailabilityOptions;
+import org.apache.flink.core.testutils.EachCallbackWrapper;
+import org.apache.flink.runtime.highavailability.zookeeper.CuratorFrameworkWithUnhandledErrorListener;
+import org.apache.flink.runtime.leaderelection.LeaderInformation;
+import org.apache.flink.runtime.rest.util.NoOpFatalErrorHandler;
+import org.apache.flink.runtime.zookeeper.ZooKeeperExtension;
+import org.apache.flink.util.TestLoggerExtension;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import javax.annotation.Nonnull;
+
+import java.util.UUID;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Integration tests for the {@link ZooKeeperUtils}. */
+@ExtendWith(TestLoggerExtension.class)
+class ZooKeeperUtilsITCase {
+    private final ZooKeeperExtension zooKeeperExtension = new ZooKeeperExtension();
+
+    @RegisterExtension
+    private final EachCallbackWrapper<ZooKeeperExtension> eachWrapper =
+            new EachCallbackWrapper<>(zooKeeperExtension);
+
+    @Test
+    public void testWriteAndReadLeaderInformation() throws Exception {
+        runWriteAndReadLeaderInformationTest(LeaderInformation.known(UUID.randomUUID(), "barfoo"));
+    }
+
+    @Test
+    public void testWriteAndReadEmptyLeaderInformation() throws Exception {
+        runWriteAndReadLeaderInformationTest(LeaderInformation.empty());
+    }
+
+    private void runWriteAndReadLeaderInformationTest(LeaderInformation leaderInformation)
+            throws Exception {
+        final CuratorFrameworkWithUnhandledErrorListener curatorFramework = startCuratorFramework();
+
+        final String path = "/foobar";
+
+        try {
+            ZooKeeperUtils.writeLeaderInformationToZooKeeper(
+                    leaderInformation, curatorFramework.asCuratorFramework(), () -> true, path);
+
+            final LeaderInformation readLeaderInformation =
+                    ZooKeeperUtils.readLeaderInformation(
+                            curatorFramework.asCuratorFramework().getData().forPath(path));
+
+            assertThat(readLeaderInformation).isEqualTo(leaderInformation);
+        } finally {
+            curatorFramework.close();
+        }
+    }
+
+    @Nonnull
+    private CuratorFrameworkWithUnhandledErrorListener startCuratorFramework() {
+        final Configuration configuration = new Configuration();
+        configuration.set(
+                HighAvailabilityOptions.HA_ZOOKEEPER_QUORUM, zooKeeperExtension.getConnectString());
+        final CuratorFrameworkWithUnhandledErrorListener curatorFramework =
+                ZooKeeperUtils.startCuratorFramework(configuration, NoOpFatalErrorHandler.INSTANCE);
+        return curatorFramework;
+    }
+
+    @Test
+    public void testDeleteZNode() throws Exception {
+        final CuratorFrameworkWithUnhandledErrorListener curatorFramework = startCuratorFramework();
+
+        try {
+            final String path = "/foobar";
+            curatorFramework.asCuratorFramework().create().forPath(path, new byte[4]);
+            curatorFramework.asCuratorFramework().create().forPath(path + "/bar", new byte[4]);
+            ZooKeeperUtils.deleteZNode(curatorFramework.asCuratorFramework(), path);
+
+            assertThat(curatorFramework.asCuratorFramework().getChildren().forPath("/")).isEmpty();
+        } finally {
+            curatorFramework.close();
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsTest.java
index 9cacc9deefa..83d4b8a9ec0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/util/ZooKeeperUtilsTest.java
@@ -37,13 +37,15 @@ public class ZooKeeperUtilsTest extends TestLogger {
 
     @Test
     public void testZookeeperPathGeneration() {
-        runZookeeperPathGenerationTest("root", "namespace", "/root/namespace");
-        runZookeeperPathGenerationTest("/root/", "/namespace/", "/root/namespace");
-        runZookeeperPathGenerationTest("//root//", "//namespace//", "/root/namespace");
-        runZookeeperPathGenerationTest("////", "namespace", "/namespace");
-        runZookeeperPathGenerationTest("//a//", "/b/", "/a/b");
-        runZookeeperPathGenerationTest("", "", "/");
-        runZookeeperPathGenerationTest("root", "////", "/root");
+        runZookeeperPathGenerationTest("/root/namespace", "root", "namespace");
+        runZookeeperPathGenerationTest("/root/namespace", "/root/", "/namespace/");
+        runZookeeperPathGenerationTest("/root/namespace", "//root//", "//namespace//");
+        runZookeeperPathGenerationTest("/namespace", "////", "namespace");
+        runZookeeperPathGenerationTest("/a/b", "//a//", "/b/");
+        runZookeeperPathGenerationTest("/", "", "");
+        runZookeeperPathGenerationTest("/root", "root", "////");
+        runZookeeperPathGenerationTest("/", "");
+        runZookeeperPathGenerationTest("/a/b/c/d", "a", "b", "c", "d");
     }
 
     @Test
@@ -106,9 +108,8 @@ public class ZooKeeperUtilsTest extends TestLogger {
         Assert.assertEquals(errorMsg, handler.getErrorFuture().get().getMessage());
     }
 
-    private void runZookeeperPathGenerationTest(
-            String root, String namespace, String expectedValue) {
-        final String result = ZooKeeperUtils.generateZookeeperPath(root, namespace);
+    private void runZookeeperPathGenerationTest(String expectedValue, String... paths) {
+        final String result = ZooKeeperUtils.generateZookeeperPath(paths);
 
         assertThat(result, is(expectedValue));
     }
