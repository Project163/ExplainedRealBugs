diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/util/serialization/SimpleStringSchema.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/util/serialization/SimpleStringSchema.java
index 7f5a8419fd5..ddc55a2bf1f 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/util/serialization/SimpleStringSchema.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/util/serialization/SimpleStringSchema.java
@@ -20,19 +20,59 @@ package org.apache.flink.streaming.util.serialization;
 import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
 import org.apache.flink.api.common.typeinfo.TypeInformation;
-import org.apache.flink.configuration.ConfigConstants;
+
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+
+import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /**
  * Very simple serialization schema for strings.
+ * 
+ * <p>By default, the serializer uses "UTF-8" for string/byte conversion.
  */
 @PublicEvolving
 public class SimpleStringSchema implements DeserializationSchema<String>, SerializationSchema<String> {
 
 	private static final long serialVersionUID = 1L;
 
+	/** The charset to use to convert between strings and bytes.
+	 * The field is transient because we serialize a different delegate object instead */
+	private transient Charset charset;
+
+	/**
+	 * Creates a new SimpleStringSchema that uses "UTF-8" as the encoding.
+	 */
+	public SimpleStringSchema() {
+		this(StandardCharsets.UTF_8);
+	}
+
+	/**
+	 * Creates a new SimpleStringSchema that uses the given charset to convert between strings and bytes.
+	 * 
+	 * @param charset The charset to use to convert between strings and bytes.
+	 */
+	public SimpleStringSchema(Charset charset) {
+		this.charset = checkNotNull(charset);
+	}
+
+	/**
+	 * Gets the charset used by this schema for serialization.
+	 * @return The charset used by this schema for serialization.
+	 */
+	public Charset getCharset() {
+		return charset;
+	}
+
+	// ------------------------------------------------------------------------
+	//  Kafka Serialization
+	// ------------------------------------------------------------------------
+
 	@Override
 	public String deserialize(byte[] message) {
-		return new String(message, ConfigConstants.DEFAULT_CHARSET);
+		return new String(message, charset);
 	}
 
 	@Override
@@ -42,11 +82,26 @@ public class SimpleStringSchema implements DeserializationSchema<String>, Serial
 
 	@Override
 	public byte[] serialize(String element) {
-		return element.getBytes(ConfigConstants.DEFAULT_CHARSET);
+		return element.getBytes(charset);
 	}
 
 	@Override
 	public TypeInformation<String> getProducedType() {
 		return BasicTypeInfo.STRING_TYPE_INFO;
 	}
+
+	// ------------------------------------------------------------------------
+	//  Java Serialization
+	// ------------------------------------------------------------------------
+
+	private void writeObject (ObjectOutputStream out) throws IOException {
+		out.defaultWriteObject();
+		out.writeUTF(charset.name());
+	}
+
+	private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
+		in.defaultReadObject();
+		String charsetName = in.readUTF();
+		this.charset = Charset.forName(charsetName);
+	}
 }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/serialization/SimpleStringSchemaTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/serialization/SimpleStringSchemaTest.java
new file mode 100644
index 00000000000..74b1d181470
--- /dev/null
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/serialization/SimpleStringSchemaTest.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.util.serialization;
+
+import org.apache.flink.core.testutils.CommonTestUtils;
+import org.junit.Test;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+
+import static org.junit.Assert.*;
+
+/**
+ * Tests for the {@link SimpleStringSchema}.
+ */
+public class SimpleStringSchemaTest {
+
+	@Test
+	public void testSerializationWithAnotherCharset() {
+		final Charset charset = StandardCharsets.UTF_16BE;
+		final String string = "之掃描古籍版實乃姚鼐的";
+		final byte[] bytes = string.getBytes(charset);
+
+		assertArrayEquals(bytes, new SimpleStringSchema(charset).serialize(string));
+		assertEquals(string, new SimpleStringSchema(charset).deserialize(bytes));
+	}
+
+	@Test
+	public void testSerializability() throws Exception {
+		final SimpleStringSchema schema = new SimpleStringSchema(StandardCharsets.UTF_16LE);
+		final SimpleStringSchema copy = CommonTestUtils.createCopySerializable(schema);
+
+		assertEquals(schema.getCharset(), copy.getCharset());
+	}
+}
diff --git a/flink-tests/src/test/java/org/apache/flink/test/misc/CheckForbiddenMethodsUsage.java b/flink-tests/src/test/java/org/apache/flink/test/manual/CheckForbiddenMethodsUsage.java
similarity index 80%
rename from flink-tests/src/test/java/org/apache/flink/test/misc/CheckForbiddenMethodsUsage.java
rename to flink-tests/src/test/java/org/apache/flink/test/manual/CheckForbiddenMethodsUsage.java
index 8fdf74b519d..aabe7c0e9d0 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/misc/CheckForbiddenMethodsUsage.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/manual/CheckForbiddenMethodsUsage.java
@@ -15,14 +15,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.flink.test.misc;
+package org.apache.flink.test.manual;
 
-import com.google.common.collect.Lists;
-import org.apache.flink.types.parser.FieldParser;
 import org.apache.flink.types.parser.FieldParserTest;
-import org.apache.flink.types.parser.VarLengthStringParserTest;
+
 import org.junit.BeforeClass;
 import org.junit.Test;
+
 import org.reflections.Reflections;
 import org.reflections.scanners.MemberUsageScanner;
 import org.reflections.util.ClasspathHelper;
@@ -32,19 +31,34 @@ import java.lang.reflect.Constructor;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
 import static org.junit.Assert.assertEquals;
 
+/**
+ * Tests via reflection that certain methods are not called in Flink.
+ * 
+ * <p>Forbidden calls include:
+ *   - Byte / String conversions that do not specify an explicit charset
+ *     because they produce different results in different locales
+ */
 public class CheckForbiddenMethodsUsage {
 
 	private static class ForbiddenCall {
+
 		private final Method method;
-		private final Constructor constructor;
+		private final Constructor<?> constructor;
 		private final List<Member> exclusions;
 
+		private ForbiddenCall(Method method, Constructor<?> ctor, List<Member> exclusions) {
+			this.method = method;
+			this.exclusions = exclusions;
+			this.constructor = ctor;
+		}
+
 		public Method getMethod() {
 			return method;
 		}
@@ -53,10 +67,12 @@ public class CheckForbiddenMethodsUsage {
 			return exclusions;
 		}
 
-		private ForbiddenCall(Method method, Constructor ctor, List<Member> exclusions) {
-			this.method = method;
-			this.exclusions = exclusions;
-			this.constructor = ctor;
+		public Set<Member> getUsages(Reflections reflections) {
+			if (method == null) {
+				return reflections.getConstructorUsage(constructor);
+			}
+
+			return reflections.getMethodUsage(method);
 		}
 
 		public static ForbiddenCall of(Method method) {
@@ -67,29 +83,23 @@ public class CheckForbiddenMethodsUsage {
 			return new ForbiddenCall(method, null, exclusions);
 		}
 
-		public static ForbiddenCall of(Constructor ctor) {
+		public static ForbiddenCall of(Constructor<?> ctor) {
 			return new ForbiddenCall(null, ctor, Collections.<Member>emptyList());
 		}
 
-		public static ForbiddenCall of(Constructor ctor, List<Member> exclusions) {
+		public static ForbiddenCall of(Constructor<?> ctor, List<Member> exclusions) {
 			return new ForbiddenCall(null, ctor, exclusions);
 		}
-
-		public Set<Member> getUsages(Reflections reflections) {
-			if (method == null) {
-				return reflections.getConstructorUsage(constructor);
-			}
-
-			return reflections.getMethodUsage(method);
-		}
 	}
 
-	private static List<ForbiddenCall> forbiddenCalls = new ArrayList<>();
+	// ------------------------------------------------------------------------
+
+	private static final List<ForbiddenCall> forbiddenCalls = new ArrayList<>();
 
 	@BeforeClass
 	public static void init() throws Exception {
 		forbiddenCalls.add(ForbiddenCall.of(String.class.getMethod("getBytes"),
-			Lists.<Member>newArrayList(
+			Arrays.<Member>asList(
 				FieldParserTest.class.getMethod("testEndsWithDelimiter"),
 				FieldParserTest.class.getMethod("testDelimiterNext")
 			)));
@@ -102,6 +112,7 @@ public class CheckForbiddenMethodsUsage {
 	@Test
 	public void testNoDefaultEncoding() throws Exception {
 		final Reflections reflections = new Reflections(new ConfigurationBuilder()
+			.useParallelExecutor(Runtime.getRuntime().availableProcessors())
 			.addUrls(ClasspathHelper.forPackage("org.apache.flink"))
 			.addScanners(new MemberUsageScanner()));
 
