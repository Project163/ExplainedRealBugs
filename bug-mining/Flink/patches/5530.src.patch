diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointOptionsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointOptionsTest.java
index 021e7a30644..a55fb2edbc3 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointOptionsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointOptionsTest.java
@@ -79,18 +79,29 @@ public class CheckpointOptionsTest {
         CheckpointStorageLocationReference location =
                 CheckpointStorageLocationReference.getDefault();
         assertFalse(
-                new CheckpointOptions(CHECKPOINT, location, AlignmentType.UNALIGNED, Long.MAX_VALUE)
+                new CheckpointOptions(
+                                CHECKPOINT,
+                                location,
+                                AlignmentType.UNALIGNED,
+                                NO_ALIGNMENT_TIME_OUT)
                         .needsAlignment());
         assertTrue(
-                new CheckpointOptions(CHECKPOINT, location, AlignmentType.ALIGNED, Long.MAX_VALUE)
+                new CheckpointOptions(
+                                CHECKPOINT, location, AlignmentType.ALIGNED, NO_ALIGNMENT_TIME_OUT)
                         .needsAlignment());
         assertTrue(
                 new CheckpointOptions(
-                                CHECKPOINT, location, AlignmentType.FORCED_ALIGNED, Long.MAX_VALUE)
+                                CHECKPOINT,
+                                location,
+                                AlignmentType.FORCED_ALIGNED,
+                                NO_ALIGNMENT_TIME_OUT)
                         .needsAlignment());
         assertFalse(
                 new CheckpointOptions(
-                                CHECKPOINT, location, AlignmentType.AT_LEAST_ONCE, Long.MAX_VALUE)
+                                CHECKPOINT,
+                                location,
+                                AlignmentType.AT_LEAST_ONCE,
+                                NO_ALIGNMENT_TIME_OUT)
                         .needsAlignment());
     }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java
index d1e361cbad5..3f9a2a2f3ae 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java
@@ -254,12 +254,7 @@ public class SingleCheckpointBarrierHandler extends CheckpointBarrierHandler {
     public void processBarrierAnnouncement(
             CheckpointBarrier announcedBarrier, int sequenceNumber, InputChannelInfo channelInfo)
             throws IOException {
-        if (checkNewCheckpoint(announcedBarrier)) {
-            firstBarrierArrivalTime = getClock().relativeTimeNanos();
-            if (alternating) {
-                registerAlignmentTimer(announcedBarrier);
-            }
-        }
+        checkNewCheckpoint(announcedBarrier);
 
         long barrierId = announcedBarrier.getId();
         if (currentCheckpointId > barrierId
@@ -299,18 +294,23 @@ public class SingleCheckpointBarrierHandler extends CheckpointBarrierHandler {
                                 announcedBarrier.getCheckpointOptions().getAlignmentTimeout()));
     }
 
-    private boolean checkNewCheckpoint(CheckpointBarrier barrier) throws IOException {
+    private void checkNewCheckpoint(CheckpointBarrier barrier) throws IOException {
         long barrierId = barrier.getId();
-        if (currentCheckpointId < barrierId) {
-            if (isCheckpointPending()) {
-                cancelSubsumedCheckpoint(barrierId);
-            }
-            currentCheckpointId = barrierId;
-            numBarriersReceived = 0;
-            allBarriersReceivedFuture = new CompletableFuture<>();
-            return true;
+        if (currentCheckpointId >= barrierId) {
+            return; // This barrier is not the first for this checkpoint.
+        }
+
+        if (isCheckpointPending()) {
+            cancelSubsumedCheckpoint(barrierId);
+        }
+        currentCheckpointId = barrierId;
+        numBarriersReceived = 0;
+        allBarriersReceivedFuture = new CompletableFuture<>();
+        firstBarrierArrivalTime = getClock().relativeTimeNanos();
+
+        if (alternating && barrier.getCheckpointOptions().isTimeoutable()) {
+            registerAlignmentTimer(barrier);
         }
-        return false;
     }
 
     @Override
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlternatingCheckpointsTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlternatingCheckpointsTest.java
index a8b11642c4c..a2e55fcd0d8 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlternatingCheckpointsTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/AlternatingCheckpointsTest.java
@@ -57,6 +57,7 @@ import java.util.function.BiFunction;
 
 import static java.util.Collections.singletonList;
 import static junit.framework.TestCase.assertTrue;
+import static org.apache.flink.runtime.checkpoint.CheckpointOptions.AlignmentType;
 import static org.apache.flink.runtime.checkpoint.CheckpointOptions.alignedNoTimeout;
 import static org.apache.flink.runtime.checkpoint.CheckpointOptions.alignedWithTimeout;
 import static org.apache.flink.runtime.checkpoint.CheckpointOptions.unaligned;
@@ -352,6 +353,99 @@ public class AlternatingCheckpointsTest {
         assertEquals(1, target.getTriggeredCheckpointCounter());
     }
 
+    @Test
+    public void testTimeoutAlignmentWhenLocalBarrierFirst() throws Exception {
+        // given: Gate with remote and local channels.
+        int numChannels = 3;
+        ValidatingCheckpointHandler target = new ValidatingCheckpointHandler();
+        CheckpointedInputGate gate =
+                new TestCheckpointedInputGateBuilder(
+                                numChannels, getTestBarrierHandlerFactory(target))
+                        .withMixedChannels(0)
+                        .withMailboxExecutor()
+                        .build();
+
+        long alignmentTimeout = 100;
+        Buffer checkpointBarrier = withTimeout(1, alignmentTimeout);
+
+        // when: Execute the first checkpoint when announcement received first.
+        ((TestInputChannel) gate.getChannel(0)).read(checkpointBarrier.retainBuffer());
+        (getChannel(gate, 1)).onBuffer(checkpointBarrier.retainBuffer(), 0, 0);
+        (getChannel(gate, 2)).onBuffer(checkpointBarrier.retainBuffer(), 0, 0);
+
+        assertAnnouncement(gate);
+        assertAnnouncement(gate);
+        assertBarrier(gate);
+        assertBarrier(gate);
+        assertBarrier(gate);
+
+        // then: The checkpoint executed successfully.
+        assertEquals(1, target.getTriggeredCheckpointCounter());
+
+        // given: The time in the future.
+        clock.advanceTime(alignmentTimeout + 1, TimeUnit.MILLISECONDS);
+
+        checkpointBarrier = withTimeout(2, alignmentTimeout);
+
+        // when: Execute the second checkpoint when barrier from local channel without announcement
+        // received first.
+        ((TestInputChannel) gate.getChannel(0)).read(checkpointBarrier.retainBuffer());
+        assertBarrier(gate);
+
+        // then: Nothing happens because the alignment timeout should only start after this barrier.
+        assertEquals(1, target.getTriggeredCheckpointCounter());
+
+        // when: Receiving the barrier from second channel(with/without) announcement after time
+        // more than alignment timeout.
+        clock.advanceTime(alignmentTimeout + 1, TimeUnit.MILLISECONDS);
+        (getChannel(gate, 1)).onBuffer(checkpointBarrier.retainBuffer(), 1, 0);
+        assertAnnouncement(gate);
+        assertBarrier(gate);
+
+        // then: The checkpoint should started as unaligned.
+        assertEquals(2, target.getTriggeredCheckpointCounter());
+        List<CheckpointOptions> checkpointOptions = target.getTriggeredCheckpointOptions();
+        assertEquals(
+                AlignmentType.UNALIGNED,
+                checkpointOptions.get(checkpointOptions.size() - 1).getAlignment());
+    }
+
+    @Test
+    public void testActiveTimeoutAfterLocalBarrierPassiveTimeout() throws Exception {
+        int numChannels = 2;
+        ValidatingCheckpointHandler target = new ValidatingCheckpointHandler();
+        try (CheckpointedInputGate gate =
+                new TestCheckpointedInputGateBuilder(
+                                numChannels, getTestBarrierHandlerFactory(target))
+                        .withMixedChannels(0)
+                        .withMailboxExecutor()
+                        .build()) {
+            long alignmentTimeout = 10;
+            Buffer checkpointBarrier = withTimeout(alignmentTimeout);
+
+            ((TestInputChannel) gate.getChannel(0)).read(checkpointBarrier.retainBuffer());
+            ((TestInputChannel) gate.getChannel(0)).read(dataBuffer());
+            assertBarrier(gate);
+
+            getChannel(gate, 1).onBuffer(dataBuffer(), 0, 0);
+            getChannel(gate, 1).onBuffer(checkpointBarrier.retainBuffer(), 1, 0);
+
+            assertEquals(0, target.getTriggeredCheckpointCounter());
+            clock.advanceTimeWithoutRunningCallables(alignmentTimeout + 1, TimeUnit.MILLISECONDS);
+            // the announcement should passively time out causing the barriers to overtake the data
+            // buffers
+            assertAnnouncement(gate);
+            // we simulate active time out firing after the passive one
+            clock.executeCallables();
+            assertBarrier(gate);
+            assertEquals(1, target.getTriggeredCheckpointCounter());
+            assertThat(target.getTriggeredCheckpointOptions(), contains(unaligned(getDefault())));
+            // Followed by overtaken buffers
+            assertData(gate);
+            assertData(gate);
+        }
+    }
+
     /**
      * This test tries to make sure that the first time out happens after processing {@link
      * EventAnnouncement} but before/during processing the first {@link CheckpointBarrier} of at
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TestCheckpointedInputGateBuilder.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TestCheckpointedInputGateBuilder.java
index c80b0525b8b..aaee13c7426 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TestCheckpointedInputGateBuilder.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TestCheckpointedInputGateBuilder.java
@@ -21,6 +21,7 @@ package org.apache.flink.streaming.util;
 import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;
 import org.apache.flink.runtime.checkpoint.channel.RecordingChannelStateWriter;
 import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;
+import org.apache.flink.runtime.io.network.partition.consumer.InputChannel;
 import org.apache.flink.runtime.io.network.partition.consumer.InputChannelBuilder;
 import org.apache.flink.runtime.io.network.partition.consumer.RemoteInputChannel;
 import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;
@@ -34,6 +35,9 @@ import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxProcessor;
 import org.apache.flink.util.function.SupplierWithException;
 
 import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
 
 /** A builder for creating instances of {@link CheckpointedInputGate} for tests. */
 public class TestCheckpointedInputGateBuilder {
@@ -61,6 +65,15 @@ public class TestCheckpointedInputGateBuilder {
         return this;
     }
 
+    /**
+     * Uses all channels as {@link RemoteInputChannel RemoteInputChannels} except the channel from
+     * testChannelIds which should be {@link TestInputChannel}.
+     */
+    public TestCheckpointedInputGateBuilder withMixedChannels(Integer... testChannelIds) {
+        this.gateBuilder = () -> buildMixedGate(testChannelIds);
+        return this;
+    }
+
     /** Uses {@link TestInputChannel TestInputChannels}. */
     public TestCheckpointedInputGateBuilder withTestChannels() {
         this.gateBuilder = this::buildTestGate;
@@ -104,6 +117,22 @@ public class TestCheckpointedInputGateBuilder {
         return gate;
     }
 
+    private SingleInputGate buildMixedGate(Integer... testChannelIds) throws IOException {
+        Set<Integer> testChannelIdSet = new HashSet<>(Arrays.asList(testChannelIds));
+        SingleInputGate gate = buildRemoteGate();
+        InputChannel[] channels = new InputChannel[numChannels];
+        for (int i = 0; i < numChannels; i++) {
+            if (testChannelIdSet.contains(i)) {
+                channels[i] = new TestInputChannel(gate, i, false, true);
+            } else {
+                channels[i] = gate.getChannel(i);
+            }
+        }
+        gate.setInputChannels(channels);
+
+        return gate;
+    }
+
     private SingleInputGate buildRemoteGate() throws IOException {
         int maxUsedBuffers = 10;
         NetworkBufferPool networkBufferPool =
