diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/ComputationState.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/ComputationState.java
index 88ef3d3288a..c9aef27a30d 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/ComputationState.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/ComputationState.java
@@ -18,13 +18,8 @@
 
 package org.apache.flink.cep.nfa;
 
-import org.apache.flink.cep.pattern.conditions.IterativeCondition;
-import org.apache.flink.util.Preconditions;
+import javax.annotation.Nullable;
 
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
 import java.util.Objects;
 
 /**
@@ -36,7 +31,7 @@ import java.util.Objects;
  */
 public class ComputationState<T> {
 	// pointer to the NFA state of the computation
-	private final State<T> state;
+	private final String state;
 
 	// the last taken event
 	private final T event;
@@ -52,14 +47,12 @@ public class ComputationState<T> {
 	// Timestamp of the first element in the pattern
 	private final long startTimestamp;
 
-	private final State<T> previousState;
-
-	private final ConditionContext conditionContext;
+	@Nullable
+	private final String previousState;
 
 	private ComputationState(
-			final NFA<T> nfa,
-			final State<T> currentState,
-			final State<T> previousState,
+			final String currentState,
+			@Nullable final String previousState,
 			final T event,
 			final int counter,
 			final long timestamp,
@@ -72,25 +65,12 @@ public class ComputationState<T> {
 		this.version = version;
 		this.startTimestamp = startTimestamp;
 		this.previousState = previousState;
-		this.conditionContext = new ConditionContext(nfa, this);
 	}
 
 	public int getCounter() {
 		return counter;
 	}
 
-	public ConditionContext getConditionContext() {
-		return conditionContext;
-	}
-
-	public boolean isFinalState() {
-		return state.isFinal();
-	}
-
-	public boolean isStartState() {
-		return state.isStart() && event == null;
-	}
-
 	public long getTimestamp() {
 		return timestamp;
 	}
@@ -99,11 +79,12 @@ public class ComputationState<T> {
 		return startTimestamp;
 	}
 
-	public State<T> getState() {
+	public String getState() {
 		return state;
 	}
 
-	public State<T> getPreviousState() {
+	@Nullable
+	public String getPreviousState() {
 		return previousState;
 	}
 
@@ -137,85 +118,22 @@ public class ComputationState<T> {
 		return Objects.hash(state, event, counter, timestamp, version, startTimestamp, previousState);
 	}
 
-	public static <T> ComputationState<T> createStartState(final NFA<T> nfa, final State<T> state) {
-		Preconditions.checkArgument(state.isStart());
-		return new ComputationState<>(nfa, state, null, null, 0, -1L, new DeweyNumber(1), -1L);
+	public static <T> ComputationState<T> createStartState(final String state) {
+		return new ComputationState<>(state, null, null, 0, -1L, new DeweyNumber(1), -1L);
 	}
 
-	public static <T> ComputationState<T> createStartState(final NFA<T> nfa, final State<T> state, final DeweyNumber version) {
-		Preconditions.checkArgument(state.isStart());
-		return new ComputationState<>(nfa, state, null, null, 0, -1L, version, -1L);
+	public static <T> ComputationState<T> createStartState(final String state, final DeweyNumber version) {
+		return new ComputationState<T>(state, null, null, 0, -1L, version, -1L);
 	}
 
 	public static <T> ComputationState<T> createState(
-			final NFA<T> nfa,
-			final State<T> currentState,
-			final State<T> previousState,
+			final String currentState,
+			final String previousState,
 			final T event,
 			final int counter,
 			final long timestamp,
 			final DeweyNumber version,
 			final long startTimestamp) {
-		return new ComputationState<>(nfa, currentState, previousState, event, counter, timestamp, version, startTimestamp);
-	}
-
-	public boolean isStopState() {
-		return state.isStop();
-	}
-
-	/**
-	 * The context used when evaluating this computation state.
-	 */
-	public class ConditionContext implements IterativeCondition.Context<T> {
-
-		private static final long serialVersionUID = -6733978464782277795L;
-
-		/**
-		 * A flag indicating if we should recompute the matching pattern, so that
-		 * the {@link IterativeCondition iterative condition} can be evaluated.
-		 */
-		private boolean shouldUpdate;
-
-		/** The current computation state. */
-		private transient ComputationState<T> computationState;
-
-		/** The owning {@link NFA} of this computation state. */
-		private final NFA<T> nfa;
-
-		/**
-		 * The matched pattern so far. A condition will be evaluated over this
-		 * pattern. This is evaluated <b>only once</b>, as this is an expensive
-		 * operation that traverses a path in the {@link SharedBuffer}.
-		 */
-		private transient Map<String, List<T>> matchedEvents;
-
-		public ConditionContext(NFA<T> nfa, ComputationState<T> computationState) {
-			this.nfa = nfa;
-			this.computationState = computationState;
-			this.shouldUpdate = true;
-		}
-
-		@Override
-		public Iterable<T> getEventsForPattern(final String key) {
-			Preconditions.checkNotNull(key);
-
-			// the (partially) matched pattern is computed lazily when this method is called.
-			// this is to avoid any overheads when using a simple, non-iterative condition.
-
-			if (shouldUpdate) {
-				this.matchedEvents = nfa.extractCurrentMatches(computationState);
-				shouldUpdate = false;
-			}
-
-			return new Iterable<T>() {
-				@Override
-				public Iterator<T> iterator() {
-					List<T> elements = matchedEvents.get(key);
-					return elements == null
-							? Collections.EMPTY_LIST.<T>iterator()
-							: elements.iterator();
-				}
-			};
-		}
+		return new ComputationState<>(currentState, previousState, event, counter, timestamp, version, startTimestamp);
 	}
 }
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
index 5624db9de43..7324db31cc7 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
@@ -18,44 +18,25 @@
 
 package org.apache.flink.cep.nfa;
 
-import org.apache.flink.api.common.typeutils.CompatibilityResult;
-import org.apache.flink.api.common.typeutils.CompatibilityUtil;
-import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;
-import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
-import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;
-import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;
-import org.apache.flink.api.common.typeutils.base.EnumSerializer;
-import org.apache.flink.api.common.typeutils.base.LongSerializer;
-import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.cep.nfa.compiler.NFACompiler;
 import org.apache.flink.cep.nfa.compiler.NFAStateNameHandler;
 import org.apache.flink.cep.operator.AbstractKeyedCEPPatternOperator;
 import org.apache.flink.cep.pattern.conditions.IterativeCondition;
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataInputViewStreamWrapper;
-import org.apache.flink.core.memory.DataOutputView;
-import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
 import org.apache.flink.streaming.api.windowing.time.Time;
 import org.apache.flink.util.Preconditions;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Queue;
 import java.util.Set;
 import java.util.Stack;
@@ -85,16 +66,14 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
  * @see <a href="https://people.cs.umass.edu/~yanlei/publications/sase-sigmod08.pdf">
  * https://people.cs.umass.edu/~yanlei/publications/sase-sigmod08.pdf</a>
  */
-public class NFA<T> implements Serializable {
-
-	private static final long serialVersionUID = 2957674889294717265L;
+public class NFA<T> {
 
 	/**
 	 * A set of all the valid NFA states, as returned by the
 	 * {@link NFACompiler NFACompiler}.
 	 * These are directly derived from the user-specified pattern.
 	 */
-	private Set<State<T>> states;
+	private final Map<String, State<T>> states;
 
 	/**
 	 * The length of a windowed pattern, as specified using the
@@ -109,82 +88,76 @@ public class NFA<T> implements Serializable {
 	 */
 	private final boolean handleTimeout;
 
-	/**
-	 * Current set of {@link ComputationState computation states} within the state machine.
-	 * These are the "active" intermediate states that are waiting for new matching
-	 * events to transition to new valid states.
-	 */
-	private transient Queue<ComputationState<T>> computationStates;
-
-	/**
-	 * Buffer used to store the matched events.
-	 */
-	private SharedBuffer<String, T> eventSharedBuffer;
+	private final TypeSerializer<T> eventSerializer;
 
-	private TypeSerializer<T> eventSerializer;
-
-	/**
-	 * Flag indicating whether the matching status of the state machine has changed.
-	 */
-	private boolean nfaChanged;
-
-	public NFA(final TypeSerializer<T> eventSerializer,
+	public NFA(
+			final TypeSerializer<T> eventSerializer,
 			final long windowTime,
-			final boolean handleTimeout) {
+			final boolean handleTimeout,
+			final Collection<State<T>> states) {
 		this.eventSerializer = checkNotNull(eventSerializer);
 		this.windowTime = windowTime;
 		this.handleTimeout = handleTimeout;
-		this.eventSharedBuffer = new SharedBuffer<>();
-		this.computationStates = new LinkedList<>();
-		this.states = new HashSet<>();
-		this.nfaChanged = false;
+
+		this.states = new HashMap<>();
+		for (State<T> state : states) {
+			this.states.put(state.getName(), state);
+		}
 	}
 
-	public Set<State<T>> getStates() {
-		return states;
+	@VisibleForTesting
+	public Collection<State<T>> getStates() {
+		return states.values();
 	}
 
-	public void addStates(final Collection<State<T>> newStates) {
-		for (State<T> state: newStates) {
-			addState(state);
+	public NFAState<T> createNFAState() {
+		List<ComputationState<T>> startingStates = new ArrayList<>();
+		for (State<T> state : states.values()) {
+			if (state.isStart()) {
+				startingStates.add(ComputationState.createStartState(state.getName()));
+			}
 		}
+		return new NFAState<>(startingStates);
 	}
 
-	public void addState(final State<T> state) {
-		states.add(state);
+	private State<T> getState(String state) {
+		State<T> result = states.get(state);
+		return result;
+	}
 
-		if (state.isStart()) {
-			computationStates.add(ComputationState.createStartState(this, state));
-		}
+	private State<T> getState(ComputationState<T> state) {
+		State<T> result = states.get(state.getState());
+		return result;
 	}
 
-	/**
-	 * Check if the NFA has finished processing all incoming data so far. That is
-	 * when the buffer keeping the matches is empty.
-	 *
-	 * @return {@code true} if there are no elements in the {@link SharedBuffer},
-	 * {@code false} otherwise.
-	 */
-	public boolean isEmpty() {
-		return eventSharedBuffer.isEmpty();
+	private boolean isStartState(ComputationState<T> state) {
+		State<T> stateObject = getState(state);
+		if (stateObject == null) {
+			throw new RuntimeException("State " + state.getState() + " does not exist in the NFA. NFA has states " + states.values());
+		}
+
+		return stateObject.isStart();
 	}
 
-	/**
-	 * Check if the matching status of the NFA has changed so far.
-	 *
-	 * @return {@code true} if matching status has changed, {@code false} otherwise
-	 */
-	public boolean isNFAChanged() {
-		return nfaChanged;
+	private boolean isStopState(ComputationState<T> state) {
+		State<T> stateObject = getState(state);
+		if (stateObject == null) {
+			throw new RuntimeException("State " + state.getState() + " does not exist in the NFA. NFA has states " + states.values());
+		}
+
+		return stateObject.isStop();
 	}
 
-	/**
-	 * Reset {@link #nfaChanged} to {@code false}.
-	 */
-	public void resetNFAChanged() {
-		this.nfaChanged = false;
+	private boolean isFinalState(ComputationState<T> state) {
+		State<T> stateObject = getState(state);
+		if (stateObject == null) {
+			throw new RuntimeException("State " + state.getState() + " does not exist in the NFA. NFA has states " + states.values());
+		}
+
+		return stateObject.isFinal();
 	}
 
+
 	/**
 	 * Processes the next input event. If some of the computations reach a final state then the
 	 * resulting event sequences are returned. If computations time out and timeout handling is
@@ -193,14 +166,16 @@ public class NFA<T> implements Serializable {
 	 * <p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned
 	 * with the element that resulted in the stop state.
 	 *
+	 * @param nfaState The NFAState object that we need to affect while processing
 	 * @param event The current event to be processed or null if only pruning shall be done
 	 * @param timestamp The timestamp of the current event
 	 * @return Tuple of the collection of matched patterns (e.g. the result of computations which have
 	 * reached a final state) and the collection of timed out patterns (if timeout handling is
 	 * activated)
 	 */
-	public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event, final long timestamp) {
-		return process(event, timestamp, AfterMatchSkipStrategy.noSkip());
+	public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(
+		NFAState<T> nfaState, final T event, final long timestamp) {
+		return process(nfaState, event, timestamp, AfterMatchSkipStrategy.noSkip());
 	}
 
 	/**
@@ -211,6 +186,7 @@ public class NFA<T> implements Serializable {
 	 * <p>If computations reach a stop state, the path forward is discarded and currently constructed path is returned
 	 * with the element that resulted in the stop state.
 	 *
+	 * @param nfaState The NFAState object that we need to affect while processing
 	 * @param event The current event to be processed or null if only pruning shall be done
 	 * @param timestamp The timestamp of the current event
 	 * @param afterMatchSkipStrategy The skip strategy to use after per match
@@ -218,8 +194,15 @@ public class NFA<T> implements Serializable {
 	 * reached a final state) and the collection of timed out patterns (if timeout handling is
 	 * activated)
 	 */
-	public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(final T event,
-		final long timestamp, AfterMatchSkipStrategy afterMatchSkipStrategy) {
+	public Tuple2<Collection<Map<String, List<T>>>, Collection<Tuple2<Map<String, List<T>>, Long>>> process(
+			NFAState<T> nfaState,
+			final T event,
+			final long timestamp,
+			AfterMatchSkipStrategy afterMatchSkipStrategy) {
+
+		Queue<ComputationState<T>> computationStates = nfaState.getComputationStates();
+		SharedBuffer<String, T> eventSharedBuffer = nfaState.getEventSharedBuffer();
+
 		final int numberComputationStates = computationStates.size();
 		final Collection<Map<String, List<T>>> result = new ArrayList<>();
 		final Collection<Tuple2<Map<String, List<T>>, Long>> timeoutResult = new ArrayList<>();
@@ -230,31 +213,31 @@ public class NFA<T> implements Serializable {
 
 			final Collection<ComputationState<T>> newComputationStates;
 
-			if (!computationState.isStartState() &&
+			if (!isStartState(computationState) &&
 				windowTime > 0L &&
 				timestamp - computationState.getStartTimestamp() >= windowTime) {
 
 				if (handleTimeout) {
 					// extract the timed out event pattern
-					Map<String, List<T>> timedOutPattern = extractCurrentMatches(computationState);
+					Map<String, List<T>> timedOutPattern = extractCurrentMatches(eventSharedBuffer, computationState);
 					timeoutResult.add(Tuple2.of(timedOutPattern, timestamp));
 				}
 
 				eventSharedBuffer.release(
-						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState().getName()),
+						NFAStateNameHandler.getOriginalNameFromInternal(computationState.getPreviousState()),
 						computationState.getEvent(),
 						computationState.getTimestamp(),
 						computationState.getCounter());
 
 				newComputationStates = Collections.emptyList();
-				nfaChanged = true;
+				nfaState.setStateChanged(true);
 			} else if (event != null) {
-				newComputationStates = computeNextStates(computationState, event, timestamp);
+				newComputationStates = computeNextStates(eventSharedBuffer, computationState, event, timestamp);
 
 				if (newComputationStates.size() != 1) {
-					nfaChanged = true;
+					nfaState.setStateChanged(true);
 				} else if (!newComputationStates.iterator().next().equals(computationState)) {
-					nfaChanged = true;
+					nfaState.setStateChanged(true);
 				}
 			} else {
 				newComputationStates = Collections.singleton(computationState);
@@ -266,24 +249,24 @@ public class NFA<T> implements Serializable {
 			boolean shouldDiscardPath = false;
 			for (final ComputationState<T> newComputationState: newComputationStates) {
 
-				if (newComputationState.isFinalState()) {
+				if (isFinalState(newComputationState)) {
 					// we've reached a final state and can thus retrieve the matching event sequence
-					Map<String, List<T>> matchedPattern = extractCurrentMatches(newComputationState);
+					Map<String, List<T>> matchedPattern = extractCurrentMatches(eventSharedBuffer, newComputationState);
 					result.add(matchedPattern);
 
 					// remove found patterns because they are no longer needed
 					eventSharedBuffer.release(
 							NFAStateNameHandler.getOriginalNameFromInternal(
-									newComputationState.getPreviousState().getName()),
+									newComputationState.getPreviousState()),
 							newComputationState.getEvent(),
 							newComputationState.getTimestamp(),
 							newComputationState.getCounter());
-				} else if (newComputationState.isStopState()) {
+				} else if (isStopState(newComputationState)) {
 					//reached stop state. release entry for the stop state
 					shouldDiscardPath = true;
 					eventSharedBuffer.release(
 							NFAStateNameHandler.getOriginalNameFromInternal(
-									newComputationState.getPreviousState().getName()),
+									newComputationState.getPreviousState()),
 							newComputationState.getEvent(),
 							newComputationState.getTimestamp(),
 							newComputationState.getCounter());
@@ -299,7 +282,7 @@ public class NFA<T> implements Serializable {
 				for (final ComputationState<T> state : statesToRetain) {
 					eventSharedBuffer.release(
 							NFAStateNameHandler.getOriginalNameFromInternal(
-									state.getPreviousState().getName()),
+									state.getPreviousState()),
 							state.getEvent(),
 							state.getTimestamp(),
 							state.getCounter());
@@ -310,7 +293,8 @@ public class NFA<T> implements Serializable {
 
 		}
 
-		discardComputationStatesAccordingToStrategy(computationStates, result, afterMatchSkipStrategy);
+		discardComputationStatesAccordingToStrategy(
+			eventSharedBuffer, computationStates, result, afterMatchSkipStrategy);
 
 		// prune shared buffer based on window length
 		if (windowTime > 0L) {
@@ -322,7 +306,7 @@ public class NFA<T> implements Serializable {
 				// remove all elements which are expired
 				// with respect to the window length
 				if (eventSharedBuffer.prune(pruningTimestamp)) {
-					nfaChanged = true;
+					nfaState.setStateChanged(true);
 				}
 			}
 		}
@@ -330,7 +314,9 @@ public class NFA<T> implements Serializable {
 		return Tuple2.of(result, timeoutResult);
 	}
 
-	private void discardComputationStatesAccordingToStrategy(Queue<ComputationState<T>> computationStates,
+	private void discardComputationStatesAccordingToStrategy(
+		SharedBuffer<String, T> eventSharedBuffer,
+		Queue<ComputationState<T>> computationStates,
 		Collection<Map<String, List<T>>> matchedResult, AfterMatchSkipStrategy afterMatchSkipStrategy) {
 		Set<T> discardEvents = new HashSet<>();
 		switch(afterMatchSkipStrategy.getStrategy()) {
@@ -368,14 +354,14 @@ public class NFA<T> implements Serializable {
 		if (!discardEvents.isEmpty()) {
 			List<ComputationState<T>> discardStates = new ArrayList<>();
 			for (ComputationState<T> computationState : computationStates) {
-				Map<String, List<T>> partialMatch = extractCurrentMatches(computationState);
+				Map<String, List<T>> partialMatch = extractCurrentMatches(eventSharedBuffer, computationState);
 				for (List<T> list: partialMatch.values()) {
 					for (T e: list) {
 						if (discardEvents.contains(e)) {
 							// discard the computation state.
 							eventSharedBuffer.release(
 								NFAStateNameHandler.getOriginalNameFromInternal(
-									computationState.getState().getName()),
+									computationState.getState()),
 								computationState.getEvent(),
 								computationState.getTimestamp(),
 								computationState.getCounter()
@@ -390,25 +376,6 @@ public class NFA<T> implements Serializable {
 		}
 	}
 
-	@Override
-	public boolean equals(Object obj) {
-		if (obj instanceof NFA) {
-			@SuppressWarnings("unchecked")
-			NFA<T> other = (NFA<T>) obj;
-
-			return eventSharedBuffer.equals(other.eventSharedBuffer) &&
-				states.equals(other.states) &&
-				windowTime == other.windowTime;
-		} else {
-			return false;
-		}
-	}
-
-	@Override
-	public int hashCode() {
-		return Objects.hash(eventSharedBuffer, states, windowTime);
-	}
-
 	private static <T> boolean isEquivalentState(final State<T> s1, final State<T> s2) {
 		return s1.getName().equals(s2.getName());
 	}
@@ -487,17 +454,19 @@ public class NFA<T> implements Serializable {
 	 *     <li>Release the corresponding entries in {@link SharedBuffer}.</li>
 	 *</ol>
 	 *
+	 * @param eventSharedBuffer The shared buffer that we need to change
 	 * @param computationState Current computation state
 	 * @param event Current event which is processed
 	 * @param timestamp Timestamp of the current event
 	 * @return Collection of computation states which result from the current one
 	 */
 	private Collection<ComputationState<T>> computeNextStates(
+			final SharedBuffer<String, T> eventSharedBuffer,
 			final ComputationState<T> computationState,
 			final T event,
 			final long timestamp) {
 
-		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(computationState, event);
+		final OutgoingEdges<T> outgoingEdges = createDecisionGraph(eventSharedBuffer, computationState, event);
 
 		// Create the computing version based on the previously computed edges
 		// We need to defer the creation of computation states until we know how many edges start
@@ -511,9 +480,9 @@ public class NFA<T> implements Serializable {
 		for (StateTransition<T> edge : edges) {
 			switch (edge.getAction()) {
 				case IGNORE: {
-					if (!computationState.isStartState()) {
+					if (!isStartState(computationState)) {
 						final DeweyNumber version;
-						if (isEquivalentState(edge.getTargetState(), computationState.getState())) {
+						if (isEquivalentState(edge.getTargetState(), getState(computationState))) {
 							//Stay in the same state (it can be either looping one or singleton)
 							final int toIncrease = calculateIncreasingSelfState(
 								outgoingEdges.getTotalIgnoreBranches(),
@@ -528,9 +497,10 @@ public class NFA<T> implements Serializable {
 						}
 
 						addComputationState(
+								eventSharedBuffer,
 								resultingComputationStates,
 								edge.getTargetState(),
-								computationState.getPreviousState(),
+								getState(computationState.getPreviousState()),
 								computationState.getEvent(),
 								computationState.getCounter(),
 								computationState.getTimestamp(),
@@ -543,7 +513,7 @@ public class NFA<T> implements Serializable {
 				case TAKE:
 					final State<T> nextState = edge.getTargetState();
 					final State<T> currentState = edge.getSourceState();
-					final State<T> previousState = computationState.getPreviousState();
+					final State<T> previousState = getState(computationState.getPreviousState());
 
 					final T previousEvent = computationState.getEvent();
 
@@ -553,7 +523,7 @@ public class NFA<T> implements Serializable {
 
 					final int counter;
 					final long startTimestamp;
-					if (computationState.isStartState()) {
+					if (isStartState(computationState)) {
 						startTimestamp = timestamp;
 						counter = eventSharedBuffer.put(
 							NFAStateNameHandler.getOriginalNameFromInternal(
@@ -577,6 +547,7 @@ public class NFA<T> implements Serializable {
 					}
 
 					addComputationState(
+							eventSharedBuffer,
 							resultingComputationStates,
 							nextState,
 							currentState,
@@ -587,9 +558,10 @@ public class NFA<T> implements Serializable {
 							startTimestamp);
 
 					//check if newly created state is optional (have a PROCEED path to Final state)
-					final State<T> finalState = findFinalStateAfterProceed(nextState, event, computationState);
+					final State<T> finalState = findFinalStateAfterProceed(eventSharedBuffer, nextState, event, computationState);
 					if (finalState != null) {
 						addComputationState(
+								eventSharedBuffer,
 								resultingComputationStates,
 								finalState,
 								currentState,
@@ -603,13 +575,13 @@ public class NFA<T> implements Serializable {
 			}
 		}
 
-		if (computationState.isStartState()) {
+		if (isStartState(computationState)) {
 			int totalBranches = calculateIncreasingSelfState(
 					outgoingEdges.getTotalIgnoreBranches(),
 					outgoingEdges.getTotalTakeBranches());
 
 			DeweyNumber startVersion = computationState.getVersion().increase(totalBranches);
-			ComputationState<T> startState = ComputationState.createStartState(this, computationState.getState(), startVersion);
+			ComputationState<T> startState = ComputationState.createStartState(computationState.getState(), startVersion);
 			resultingComputationStates.add(startState);
 		}
 
@@ -617,7 +589,7 @@ public class NFA<T> implements Serializable {
 			// release the shared entry referenced by the current computation state.
 			eventSharedBuffer.release(
 					NFAStateNameHandler.getOriginalNameFromInternal(
-							computationState.getPreviousState().getName()),
+							computationState.getPreviousState()),
 					computationState.getEvent(),
 					computationState.getTimestamp(),
 					computationState.getCounter());
@@ -627,6 +599,7 @@ public class NFA<T> implements Serializable {
 	}
 
 	private void addComputationState(
+			SharedBuffer<String, T> eventSharedBuffer,
 			List<ComputationState<T>> computationStates,
 			State<T> currentState,
 			State<T> previousState,
@@ -636,14 +609,17 @@ public class NFA<T> implements Serializable {
 			DeweyNumber version,
 			long startTimestamp) {
 		ComputationState<T> computationState = ComputationState.createState(
-				this, currentState, previousState, event, counter, timestamp, version, startTimestamp);
+				currentState.getName(), previousState.getName(), event, counter, timestamp, version, startTimestamp);
 		computationStates.add(computationState);
 
 		String originalStateName = NFAStateNameHandler.getOriginalNameFromInternal(previousState.getName());
 		eventSharedBuffer.lock(originalStateName, event, timestamp, counter);
 	}
 
-	private State<T> findFinalStateAfterProceed(State<T> state, T event, ComputationState<T> computationState) {
+	private State<T> findFinalStateAfterProceed(
+		SharedBuffer<String, T> eventSharedBuffer,
+		State<T> state, T event,
+		ComputationState<T> computationState) {
 		final Stack<State<T>> statesToCheck = new Stack<>();
 		statesToCheck.push(state);
 
@@ -652,7 +628,7 @@ public class NFA<T> implements Serializable {
 				final State<T> currentState = statesToCheck.pop();
 				for (StateTransition<T> transition : currentState.getStateTransitions()) {
 					if (transition.getAction() == StateTransitionAction.PROCEED &&
-							checkFilterCondition(computationState, transition.getCondition(), event)) {
+							checkFilterCondition(eventSharedBuffer, computationState, transition.getCondition(), event)) {
 						if (transition.getTargetState().isFinal()) {
 							return transition.getTargetState();
 						} else {
@@ -672,11 +648,14 @@ public class NFA<T> implements Serializable {
 		return takeBranches == 0 && ignoreBranches == 0 ? 0 : ignoreBranches + Math.max(1, takeBranches);
 	}
 
-	private OutgoingEdges<T> createDecisionGraph(ComputationState<T> computationState, T event) {
-		final OutgoingEdges<T> outgoingEdges = new OutgoingEdges<>(computationState.getState());
+	private OutgoingEdges<T> createDecisionGraph(
+		SharedBuffer<String, T> eventSharedBuffer,
+		ComputationState<T> computationState, T event) {
+		State<T> state = getState(computationState);
+		final OutgoingEdges<T> outgoingEdges = new OutgoingEdges<>(state);
 
 		final Stack<State<T>> states = new Stack<>();
-		states.push(computationState.getState());
+		states.push(state);
 
 		//First create all outgoing edges, so to be able to reason about the Dewey version
 		while (!states.isEmpty()) {
@@ -686,7 +665,7 @@ public class NFA<T> implements Serializable {
 			// check all state transitions for each state
 			for (StateTransition<T> stateTransition : stateTransitions) {
 				try {
-					if (checkFilterCondition(computationState, stateTransition.getCondition(), event)) {
+					if (checkFilterCondition(eventSharedBuffer, computationState, stateTransition.getCondition(), event)) {
 						// filter condition is true
 						switch (stateTransition.getAction()) {
 							case PROCEED:
@@ -708,8 +687,12 @@ public class NFA<T> implements Serializable {
 		return outgoingEdges;
 	}
 
-	private boolean checkFilterCondition(ComputationState<T> computationState, IterativeCondition<T> condition, T event) throws Exception {
-		return condition == null || condition.filter(event, computationState.getConditionContext());
+	private boolean checkFilterCondition(
+		SharedBuffer<String, T> eventSharedBuffer,
+		ComputationState<T> computationState,
+		IterativeCondition<T> condition,
+		T event) throws Exception {
+		return condition == null || condition.filter(event, new ConditionContext<>(this, eventSharedBuffer, computationState));
 	}
 
 	/**
@@ -717,17 +700,19 @@ public class NFA<T> implements Serializable {
 	 * sequence is returned as a map which contains the events and the names of the states to which
 	 * the events were mapped.
 	 *
+	 * @param eventSharedBuffer The {@link SharedBuffer} from which to extract the matches
 	 * @param computationState The end computation state of the extracted event sequences
 	 * @return Collection of event sequences which end in the given computation state
 	 */
-	Map<String, List<T>> extractCurrentMatches(final ComputationState<T> computationState) {
+	Map<String, List<T>> extractCurrentMatches(
+		SharedBuffer<String, T> eventSharedBuffer, final ComputationState<T> computationState) {
 		if (computationState.getPreviousState() == null) {
 			return new HashMap<>();
 		}
 
 		List<Map<String, List<T>>> paths = eventSharedBuffer.extractPatterns(
 				NFAStateNameHandler.getOriginalNameFromInternal(
-						computationState.getPreviousState().getName()),
+						computationState.getPreviousState()),
 				computationState.getEvent(),
 				computationState.getTimestamp(),
 				computationState.getCounter(),
@@ -758,392 +743,62 @@ public class NFA<T> implements Serializable {
 		return result;
 	}
 
-	//////////////////////			Serialization			//////////////////////
-
-	/**
-	 * The {@link TypeSerializerConfigSnapshot} serializer configuration to be stored with the managed state.
-	 */
-	public static final class NFASerializerConfigSnapshot<T> extends CompositeTypeSerializerConfigSnapshot {
-
-		private static final int VERSION = 1;
-
-		/** This empty constructor is required for deserializing the configuration. */
-		public NFASerializerConfigSnapshot() {}
-
-		public NFASerializerConfigSnapshot(
-				TypeSerializer<T> eventSerializer,
-				TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer) {
-
-			super(eventSerializer, sharedBufferSerializer);
-		}
-
-		@Override
-		public int getVersion() {
-			return VERSION;
-		}
-	}
-
 	/**
-	 * A {@link TypeSerializer} for {@link NFA} that uses Java Serialization.
+	 * The context used when evaluating this computation state.
 	 */
-	public static class NFASerializer<T> extends TypeSerializer<NFA<T>> {
-
-		private static final long serialVersionUID = 2098282423980597010L;
-
-		private final TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer;
-
-		private final TypeSerializer<T> eventSerializer;
-
-		public NFASerializer(TypeSerializer<T> typeSerializer) {
-			this(typeSerializer, new SharedBuffer.SharedBufferSerializer<>(StringSerializer.INSTANCE, typeSerializer));
-		}
-
-		public NFASerializer(
-				TypeSerializer<T> typeSerializer,
-				TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer) {
-			this.eventSerializer = typeSerializer;
-			this.sharedBufferSerializer = sharedBufferSerializer;
-		}
-
-		@Override
-		public boolean isImmutableType() {
-			return false;
-		}
-
-		@Override
-		public NFASerializer<T> duplicate() {
-			return new NFASerializer<>(eventSerializer.duplicate());
-		}
-
-		@Override
-		public NFA<T> createInstance() {
-			return null;
-		}
-
-		@Override
-		public NFA<T> copy(NFA<T> from) {
-			try {
-				ByteArrayOutputStream baos = new ByteArrayOutputStream();
-				serialize(from, new DataOutputViewStreamWrapper(baos));
-				baos.close();
-
-				byte[] data = baos.toByteArray();
-
-				ByteArrayInputStream bais = new ByteArrayInputStream(data);
-				NFA<T> copy = deserialize(new DataInputViewStreamWrapper(bais));
-				bais.close();
-				return copy;
-			} catch (IOException e) {
-				throw new RuntimeException("Could not copy NFA.", e);
-			}
-		}
-
-		@Override
-		public NFA<T> copy(NFA<T> from, NFA<T> reuse) {
-			return copy(from);
-		}
-
-		@Override
-		public int getLength() {
-			return -1;
-		}
-
-		@Override
-		public void serialize(NFA<T> record, DataOutputView target) throws IOException {
-			serializeStates(record.states, target);
-			target.writeLong(record.windowTime);
-			target.writeBoolean(record.handleTimeout);
-
-			sharedBufferSerializer.serialize(record.eventSharedBuffer, target);
+	public static class ConditionContext<T> implements IterativeCondition.Context<T> {
 
-			target.writeInt(record.computationStates.size());
+		/**
+		 * A flag indicating if we should recompute the matching pattern, so that
+		 * the {@link IterativeCondition iterative condition} can be evaluated.
+		 */
+		private boolean shouldUpdate;
 
-			StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
-			LongSerializer timestampSerializer = LongSerializer.INSTANCE;
-			DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
+		/** The current computation state. */
+		private ComputationState<T> computationState;
 
-			for (ComputationState<T> computationState: record.computationStates) {
-				stateNameSerializer.serialize(computationState.getState().getName(), target);
-				stateNameSerializer.serialize(computationState.getPreviousState() == null
-						? null : computationState.getPreviousState().getName(), target);
+		/**
+		 * The matched pattern so far. A condition will be evaluated over this
+		 * pattern. This is evaluated <b>only once</b>, as this is an expensive
+		 * operation that traverses a path in the {@link SharedBuffer}.
+		 */
+		private Map<String, List<T>> matchedEvents;
 
-				timestampSerializer.serialize(computationState.getTimestamp(), target);
-				versionSerializer.serialize(computationState.getVersion(), target);
-				timestampSerializer.serialize(computationState.getStartTimestamp(), target);
-				target.writeInt(computationState.getCounter());
+		private NFA<T> nfa;
 
-				if (computationState.getEvent() == null) {
-					target.writeBoolean(false);
-				} else {
-					target.writeBoolean(true);
-					eventSerializer.serialize(computationState.getEvent(), target);
-				}
-			}
-		}
-
-		@Override
-		public NFA<T> deserialize(DataInputView source) throws IOException {
-			Set<State<T>> states = deserializeStates(source);
-			long windowTime = source.readLong();
-			boolean handleTimeout = source.readBoolean();
-
-			NFA<T> nfa = new NFA<>(eventSerializer, windowTime, handleTimeout);
-			nfa.states = states;
-
-			nfa.eventSharedBuffer = sharedBufferSerializer.deserialize(source);
-
-			Queue<ComputationState<T>> computationStates = new LinkedList<>();
-			StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
-			LongSerializer timestampSerializer = LongSerializer.INSTANCE;
-			DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
-
-			int computationStateNo = source.readInt();
-			for (int i = 0; i < computationStateNo; i++) {
-				State<T> state = getStateByName(stateNameSerializer.deserialize(source), nfa);
-				State<T> prevState = getStateByName(stateNameSerializer.deserialize(source), nfa);
-				long timestamp = timestampSerializer.deserialize(source);
-				DeweyNumber version = versionSerializer.deserialize(source);
-				long startTimestamp = timestampSerializer.deserialize(source);
-				int counter = source.readInt();
-
-				T event = null;
-				if (source.readBoolean()) {
-					event = eventSerializer.deserialize(source);
-				}
-
-				computationStates.add(ComputationState.createState(
-						nfa, state, prevState, event, counter, timestamp, version, startTimestamp));
-			}
-
-			nfa.computationStates = computationStates;
-			return nfa;
-		}
-
-		private State<T> getStateByName(String name, NFA<T> nfa) {
-			for (State<T> state: nfa.states) {
-				if (state.getName().equals(name)) {
-					return state;
-				}
-			}
-			return null;
-		}
-
-		@Override
-		public NFA<T> deserialize(NFA<T> reuse, DataInputView source) throws IOException {
-			return deserialize(source);
-		}
-
-		@Override
-		public void copy(DataInputView source, DataOutputView target) throws IOException {
-			Set<State<T>> states = deserializeStates(source);
-			serializeStates(states, target);
-
-			long windowTime = source.readLong();
-			target.writeLong(windowTime);
-
-			boolean handleTimeout = source.readBoolean();
-			target.writeBoolean(handleTimeout);
-
-			SharedBuffer<String, T> sharedBuffer = sharedBufferSerializer.deserialize(source);
-			sharedBufferSerializer.serialize(sharedBuffer, target);
-
-			StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
-			LongSerializer timestampSerializer = LongSerializer.INSTANCE;
-			DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
-
-			int computationStateNo = source.readInt();
-			target.writeInt(computationStateNo);
-
-			for (int i = 0; i < computationStateNo; i++) {
-				String stateName = stateNameSerializer.deserialize(source);
-				stateNameSerializer.serialize(stateName, target);
-
-				String prevStateName = stateNameSerializer.deserialize(source);
-				stateNameSerializer.serialize(prevStateName, target);
-
-				long timestamp = timestampSerializer.deserialize(source);
-				timestampSerializer.serialize(timestamp, target);
-
-				DeweyNumber version = versionSerializer.deserialize(source);
-				versionSerializer.serialize(version, target);
-
-				long startTimestamp = timestampSerializer.deserialize(source);
-				timestampSerializer.serialize(startTimestamp, target);
-
-				int counter = source.readInt();
-				target.writeInt(counter);
-
-				boolean hasEvent = source.readBoolean();
-				target.writeBoolean(hasEvent);
-				if (hasEvent) {
-					T event = eventSerializer.deserialize(source);
-					eventSerializer.serialize(event, target);
-				}
-			}
-		}
-
-		@Override
-		public boolean equals(Object obj) {
-			return obj == this ||
-					(obj != null && obj.getClass().equals(getClass()) &&
-							sharedBufferSerializer.equals(((NFASerializer) obj).sharedBufferSerializer) &&
-							eventSerializer.equals(((NFASerializer) obj).eventSerializer));
-		}
-
-		@Override
-		public boolean canEqual(Object obj) {
-			return true;
-		}
+		private SharedBuffer<String, T> eventSharedBuffer;
 
-		@Override
-		public int hashCode() {
-			return 37 * sharedBufferSerializer.hashCode() + eventSerializer.hashCode();
+		public ConditionContext(
+				NFA<T> nfa,
+				SharedBuffer<String, T> eventSharedBuffer,
+				ComputationState<T> computationState) {
+			this.computationState = computationState;
+			this.nfa = nfa;
+			this.eventSharedBuffer = eventSharedBuffer;
+			this.shouldUpdate = true;
 		}
 
 		@Override
-		public TypeSerializerConfigSnapshot snapshotConfiguration() {
-			return new NFASerializerConfigSnapshot<>(eventSerializer, sharedBufferSerializer);
-		}
+		public Iterable<T> getEventsForPattern(final String key) {
+			Preconditions.checkNotNull(key);
 
-		@Override
-		public CompatibilityResult<NFA<T>> ensureCompatibility(TypeSerializerConfigSnapshot configSnapshot) {
-			if (configSnapshot instanceof NFASerializerConfigSnapshot) {
-				List<Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> serializersAndConfigs =
-						((NFASerializerConfigSnapshot) configSnapshot).getNestedSerializersAndConfigs();
-
-				CompatibilityResult<T> eventCompatResult = CompatibilityUtil.resolveCompatibilityResult(
-						serializersAndConfigs.get(0).f0,
-						UnloadableDummyTypeSerializer.class,
-						serializersAndConfigs.get(0).f1,
-						eventSerializer);
-
-				CompatibilityResult<SharedBuffer<String, T>> sharedBufCompatResult =
-						CompatibilityUtil.resolveCompatibilityResult(
-								serializersAndConfigs.get(1).f0,
-								UnloadableDummyTypeSerializer.class,
-								serializersAndConfigs.get(1).f1,
-								sharedBufferSerializer);
-
-				if (!sharedBufCompatResult.isRequiresMigration() && !eventCompatResult.isRequiresMigration()) {
-					return CompatibilityResult.compatible();
-				} else {
-					if (eventCompatResult.getConvertDeserializer() != null &&
-						sharedBufCompatResult.getConvertDeserializer() != null) {
-						return CompatibilityResult.requiresMigration(
-							new NFASerializer<>(
-								new TypeDeserializerAdapter<>(eventCompatResult.getConvertDeserializer()),
-								new TypeDeserializerAdapter<>(sharedBufCompatResult.getConvertDeserializer())));
-					}
-				}
-			}
-
-			return CompatibilityResult.requiresMigration();
-		}
+			// the (partially) matched pattern is computed lazily when this method is called.
+			// this is to avoid any overheads when using a simple, non-iterative condition.
 
-		private void serializeStates(Set<State<T>> states, DataOutputView out) throws IOException {
-			TypeSerializer<String> nameSerializer = StringSerializer.INSTANCE;
-			TypeSerializer<State.StateType> stateTypeSerializer = new EnumSerializer<>(State.StateType.class);
-			TypeSerializer<StateTransitionAction> actionSerializer = new EnumSerializer<>(StateTransitionAction.class);
-
-			out.writeInt(states.size());
-			for (State<T> state: states) {
-				nameSerializer.serialize(state.getName(), out);
-				stateTypeSerializer.serialize(state.getStateType(), out);
+			if (shouldUpdate) {
+				this.matchedEvents = nfa.extractCurrentMatches(eventSharedBuffer, computationState);
+				shouldUpdate = false;
 			}
 
-			for (State<T> state: states) {
-				nameSerializer.serialize(state.getName(), out);
-
-				out.writeInt(state.getStateTransitions().size());
-				for (StateTransition<T> transition : state.getStateTransitions()) {
-					nameSerializer.serialize(transition.getSourceState().getName(), out);
-					nameSerializer.serialize(transition.getTargetState().getName(), out);
-					actionSerializer.serialize(transition.getAction(), out);
-
-					serializeCondition(transition.getCondition(), out);
+			return new Iterable<T>() {
+				@Override
+				public Iterator<T> iterator() {
+					List<T> elements = matchedEvents.get(key);
+					return elements == null
+						? Collections.EMPTY_LIST.<T>iterator()
+						: elements.iterator();
 				}
-			}
-		}
-
-		private Set<State<T>> deserializeStates(DataInputView in) throws IOException {
-			TypeSerializer<String> nameSerializer = StringSerializer.INSTANCE;
-			TypeSerializer<State.StateType> stateTypeSerializer = new EnumSerializer<>(State.StateType.class);
-			TypeSerializer<StateTransitionAction> actionSerializer = new EnumSerializer<>(StateTransitionAction.class);
-
-			final int noOfStates = in.readInt();
-			Map<String, State<T>> states = new HashMap<>(noOfStates);
-
-			for (int i = 0; i < noOfStates; i++) {
-				String stateName = nameSerializer.deserialize(in);
-				State.StateType stateType = stateTypeSerializer.deserialize(in);
-
-				State<T> state = new State<>(stateName, stateType);
-				states.put(stateName, state);
-			}
-
-			for (int i = 0; i < noOfStates; i++) {
-				String srcName = nameSerializer.deserialize(in);
-
-				int noOfTransitions = in.readInt();
-				for (int j = 0; j < noOfTransitions; j++) {
-					String src = nameSerializer.deserialize(in);
-					Preconditions.checkState(src.equals(srcName),
-							"Source Edge names do not match (" + srcName + " - " + src + ").");
-
-					String trgt = nameSerializer.deserialize(in);
-					StateTransitionAction action = actionSerializer.deserialize(in);
-
-					IterativeCondition<T> condition = null;
-					try {
-						condition = deserializeCondition(in);
-					} catch (ClassNotFoundException e) {
-						e.printStackTrace();
-					}
-
-					State<T> srcState = states.get(src);
-					State<T> trgtState = states.get(trgt);
-					srcState.addStateTransition(action, trgtState, condition);
-				}
-
-			}
-			return new HashSet<>(states.values());
-		}
-
-		private void serializeCondition(IterativeCondition<T> condition, DataOutputView out) throws IOException {
-			out.writeBoolean(condition != null);
-			if (condition != null) {
-				ByteArrayOutputStream baos = new ByteArrayOutputStream();
-				ObjectOutputStream oos = new ObjectOutputStream(baos);
-
-				oos.writeObject(condition);
-
-				oos.close();
-				baos.close();
-
-				byte[] serCondition = baos.toByteArray();
-				out.writeInt(serCondition.length);
-				out.write(serCondition);
-			}
-		}
-
-		private IterativeCondition<T> deserializeCondition(DataInputView in) throws IOException, ClassNotFoundException {
-			boolean hasCondition = in.readBoolean();
-			if (hasCondition) {
-				int length = in.readInt();
-
-				byte[] serCondition = new byte[length];
-				in.readFully(serCondition);
-
-				ByteArrayInputStream bais = new ByteArrayInputStream(serCondition);
-				ObjectInputStream ois = new ObjectInputStream(bais);
-
-				IterativeCondition<T> condition = (IterativeCondition<T>) ois.readObject();
-				ois.close();
-				bais.close();
-
-				return condition;
-			}
-			return null;
+			};
 		}
 	}
 }
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAState.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAState.java
new file mode 100644
index 00000000000..e9414c39665
--- /dev/null
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAState.java
@@ -0,0 +1,144 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.cep.nfa;
+
+import org.apache.flink.cep.operator.AbstractKeyedCEPPatternOperator;
+
+import java.util.LinkedList;
+import java.util.Queue;
+
+/**
+ * State kept for a {@link NFA}.
+ *
+ * <p>The {@link AbstractKeyedCEPPatternOperator CEP operator}
+ * keeps one NFA per key, for keyed input streams, and a single global NFA for non-keyed ones.
+ * When an event gets processed, it updates the NFA's internal state machine.
+ *
+ * <p>An event that belongs to a partially matched sequence is kept in an internal
+ * {@link SharedBuffer buffer}, which is a memory-optimized data-structure exactly for
+ * this purpose. Events in the buffer are removed when all the matched sequences that
+ * contain them are:
+ * <ol>
+ *  <li>emitted (success)</li>
+ *  <li>discarded (patterns containing NOT)</li>
+ *  <li>timed-out (windowed patterns)</li>
+ * </ol>
+ *
+ * <p>The implementation is strongly based on the paper "Efficient Pattern Matching over Event Streams".
+ *
+ * @param <T> Type of the processed events
+ * @see <a href="https://people.cs.umass.edu/~yanlei/publications/sase-sigmod08.pdf">
+ * https://people.cs.umass.edu/~yanlei/publications/sase-sigmod08.pdf</a>
+ */
+public class NFAState<T> {
+
+	/**
+	 * Current set of {@link ComputationState computation states} within the state machine.
+	 * These are the "active" intermediate states that are waiting for new matching
+	 * events to transition to new valid states.
+	 */
+	private Queue<ComputationState<T>> computationStates;
+
+	/**
+	 * Buffer used to store the matched events.
+	 */
+	private SharedBuffer<String, T> eventSharedBuffer;
+
+	/**
+	 * Flag indicating whether the matching status of the state machine has changed.
+	 */
+	private boolean stateChanged;
+
+	public NFAState(
+			Queue<ComputationState<T>> computationStates,
+			SharedBuffer<String, T> eventSharedBuffer,
+			boolean stateChanged) {
+		this.computationStates = computationStates;
+		this.eventSharedBuffer = eventSharedBuffer;
+		this.stateChanged = stateChanged;
+	}
+
+	public NFAState() {
+		this(new LinkedList<>(), new SharedBuffer<>(), false);
+	}
+
+	public NFAState(Iterable<ComputationState<T>> startingStates) {
+		this();
+
+		for (ComputationState<T> startingState : startingStates) {
+			computationStates.add(startingState);
+		}
+	}
+
+	/**
+	 * Check if the NFA has finished processing all incoming data so far. That is
+	 * when the buffer keeping the matches is empty.
+	 *
+	 * @return {@code true} if there are no elements in the {@link SharedBuffer},
+	 * {@code false} otherwise.
+	 */
+	public boolean isEmpty() {
+		return eventSharedBuffer.isEmpty();
+	}
+
+	/**
+	 * Check if the matching status of the NFA has changed so far.
+	 *
+	 * @return {@code true} if matching status has changed, {@code false} otherwise
+	 */
+	public boolean isStateChanged() {
+		return stateChanged;
+	}
+
+	/**
+	 * Reset the changed bit checked via {@link #isStateChanged()} to {@code false}.
+	 */
+	public void resetStateChanged() {
+		this.stateChanged = false;
+	}
+
+	public void setStateChanged(boolean stateChanged) {
+		this.stateChanged = stateChanged;
+	}
+
+	public Queue<ComputationState<T>> getComputationStates() {
+		return computationStates;
+	}
+
+	public SharedBuffer<String, T> getEventSharedBuffer() {
+		return eventSharedBuffer;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (obj instanceof NFAState) {
+			@SuppressWarnings("unchecked")
+			NFAState<T> other = (NFAState<T>) obj;
+
+			return eventSharedBuffer.equals(other.eventSharedBuffer);
+		} else {
+			return false;
+		}
+	}
+
+	@Override
+	public int hashCode() {
+		return eventSharedBuffer.hashCode();
+	}
+}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java
new file mode 100644
index 00000000000..4dae7986f43
--- /dev/null
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java
@@ -0,0 +1,267 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.cep.nfa;
+
+import org.apache.flink.api.common.typeutils.CompatibilityResult;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;
+import org.apache.flink.api.common.typeutils.base.LongSerializer;
+import org.apache.flink.api.common.typeutils.base.StringSerializer;
+import org.apache.flink.api.java.tuple.Tuple2;
+import org.apache.flink.core.memory.DataInputView;
+import org.apache.flink.core.memory.DataInputViewStreamWrapper;
+import org.apache.flink.core.memory.DataOutputView;
+import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+/**
+ * A {@link TypeSerializer} for {@link NFAState} that uses Java Serialization.
+ */
+public class NFAStateSerializer<T> extends TypeSerializer<NFAState<T>> {
+
+	private static final long serialVersionUID = 2098282423980597010L;
+
+	private final TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer;
+
+	private final TypeSerializer<T> eventSerializer;
+
+	public NFAStateSerializer(TypeSerializer<T> typeSerializer) {
+		this(typeSerializer, new SharedBuffer.SharedBufferSerializer<>(StringSerializer.INSTANCE, typeSerializer));
+	}
+
+	public NFAStateSerializer(
+			TypeSerializer<T> typeSerializer,
+			TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer) {
+		this.eventSerializer = typeSerializer;
+		this.sharedBufferSerializer = sharedBufferSerializer;
+	}
+
+	@Override
+	public boolean isImmutableType() {
+		return false;
+	}
+
+	@Override
+	public NFAStateSerializer<T> duplicate() {
+		return new NFAStateSerializer<>(eventSerializer.duplicate());
+	}
+
+	@Override
+	public NFAState<T> createInstance() {
+		return null;
+	}
+
+	@Override
+	public NFAState<T> copy(NFAState<T> from) {
+		try {
+			ByteArrayOutputStream baos = new ByteArrayOutputStream();
+			serialize(from, new DataOutputViewStreamWrapper(baos));
+			baos.close();
+
+			byte[] data = baos.toByteArray();
+
+			ByteArrayInputStream bais = new ByteArrayInputStream(data);
+			NFAState<T> copy = deserialize(new DataInputViewStreamWrapper(bais));
+			bais.close();
+			return copy;
+		} catch (IOException e) {
+			throw new RuntimeException("Could not copy NFA.", e);
+		}
+	}
+
+	@Override
+	public NFAState<T> copy(NFAState<T> from, NFAState<T> reuse) {
+		return copy(from);
+	}
+
+	@Override
+	public int getLength() {
+		return -1;
+	}
+
+	@Override
+	public void serialize(NFAState<T> record, DataOutputView target) throws IOException {
+		sharedBufferSerializer.serialize(record.getEventSharedBuffer(), target);
+
+		target.writeInt(record.getComputationStates().size());
+
+		StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
+		LongSerializer timestampSerializer = LongSerializer.INSTANCE;
+		DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
+
+		for (ComputationState<T> computationState: record.getComputationStates()) {
+			stateNameSerializer.serialize(computationState.getState(), target);
+			stateNameSerializer.serialize(computationState.getPreviousState(), target);
+
+			timestampSerializer.serialize(computationState.getTimestamp(), target);
+			versionSerializer.serialize(computationState.getVersion(), target);
+			timestampSerializer.serialize(computationState.getStartTimestamp(), target);
+			target.writeInt(computationState.getCounter());
+
+			if (computationState.getEvent() == null) {
+				target.writeBoolean(false);
+			} else {
+				target.writeBoolean(true);
+				eventSerializer.serialize(computationState.getEvent(), target);
+			}
+		}
+	}
+
+	@Override
+	public NFAState<T> deserialize(DataInputView source) throws IOException {
+		SharedBuffer<String, T> sharedBuffer = sharedBufferSerializer.deserialize(source);
+
+		Queue<ComputationState<T>> computationStates = new LinkedList<>();
+		StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
+		LongSerializer timestampSerializer = LongSerializer.INSTANCE;
+		DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
+
+		int computationStateNo = source.readInt();
+		for (int i = 0; i < computationStateNo; i++) {
+			String state = stateNameSerializer.deserialize(source);
+			String prevState = stateNameSerializer.deserialize(source);
+			long timestamp = timestampSerializer.deserialize(source);
+			DeweyNumber version = versionSerializer.deserialize(source);
+			long startTimestamp = timestampSerializer.deserialize(source);
+			int counter = source.readInt();
+
+			T event = null;
+			if (source.readBoolean()) {
+				event = eventSerializer.deserialize(source);
+			}
+
+			computationStates.add(ComputationState.createState(
+					state, prevState, event, counter, timestamp, version, startTimestamp));
+		}
+
+		return new NFAState<>(computationStates, sharedBuffer, false);
+	}
+
+	@Override
+	public NFAState<T> deserialize(NFAState<T> reuse, DataInputView source) throws IOException {
+		return deserialize(source);
+	}
+
+	@Override
+	public void copy(DataInputView source, DataOutputView target) throws IOException {
+		SharedBuffer<String, T> sharedBuffer = sharedBufferSerializer.deserialize(source);
+		sharedBufferSerializer.serialize(sharedBuffer, target);
+
+		StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
+		LongSerializer timestampSerializer = LongSerializer.INSTANCE;
+		DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
+
+		int computationStateNo = source.readInt();
+		target.writeInt(computationStateNo);
+
+		for (int i = 0; i < computationStateNo; i++) {
+			String stateName = stateNameSerializer.deserialize(source);
+			stateNameSerializer.serialize(stateName, target);
+
+			String prevStateName = stateNameSerializer.deserialize(source);
+			stateNameSerializer.serialize(prevStateName, target);
+
+			long timestamp = timestampSerializer.deserialize(source);
+			timestampSerializer.serialize(timestamp, target);
+
+			DeweyNumber version = versionSerializer.deserialize(source);
+			versionSerializer.serialize(version, target);
+
+			long startTimestamp = timestampSerializer.deserialize(source);
+			timestampSerializer.serialize(startTimestamp, target);
+
+			int counter = source.readInt();
+			target.writeInt(counter);
+
+			boolean hasEvent = source.readBoolean();
+			target.writeBoolean(hasEvent);
+			if (hasEvent) {
+				T event = eventSerializer.deserialize(source);
+				eventSerializer.serialize(event, target);
+			}
+		}
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		return obj == this ||
+				(obj != null && obj.getClass().equals(getClass()) &&
+						sharedBufferSerializer.equals(((NFAStateSerializer) obj).sharedBufferSerializer) &&
+						eventSerializer.equals(((NFAStateSerializer) obj).eventSerializer));
+	}
+
+	@Override
+	public boolean canEqual(Object obj) {
+		return true;
+	}
+
+	@Override
+	public int hashCode() {
+		return 37 * sharedBufferSerializer.hashCode() + eventSerializer.hashCode();
+	}
+
+	@Override
+	public TypeSerializerConfigSnapshot snapshotConfiguration() {
+		return new NFAStateSerializerConfigSnapshot<>(eventSerializer, sharedBufferSerializer);
+	}
+
+	@Override
+	public CompatibilityResult<NFAState<T>> ensureCompatibility(TypeSerializerConfigSnapshot configSnapshot) {
+		if (configSnapshot instanceof NFAStateSerializerConfigSnapshot) {
+			List<Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> serializersAndConfigs =
+					((NFAStateSerializerConfigSnapshot) configSnapshot).getNestedSerializersAndConfigs();
+
+			CompatibilityResult<T> eventCompatResult = CompatibilityUtil.resolveCompatibilityResult(
+					serializersAndConfigs.get(0).f0,
+					UnloadableDummyTypeSerializer.class,
+					serializersAndConfigs.get(0).f1,
+					eventSerializer);
+
+			CompatibilityResult<SharedBuffer<String, T>> sharedBufCompatResult =
+					CompatibilityUtil.resolveCompatibilityResult(
+							serializersAndConfigs.get(1).f0,
+							UnloadableDummyTypeSerializer.class,
+							serializersAndConfigs.get(1).f1,
+							sharedBufferSerializer);
+
+			if (!sharedBufCompatResult.isRequiresMigration() && !eventCompatResult.isRequiresMigration()) {
+				return CompatibilityResult.compatible();
+			} else {
+				if (eventCompatResult.getConvertDeserializer() != null &&
+					sharedBufCompatResult.getConvertDeserializer() != null) {
+					return CompatibilityResult.requiresMigration(
+						new NFAStateSerializer<>(
+							new TypeDeserializerAdapter<>(eventCompatResult.getConvertDeserializer()),
+							new TypeDeserializerAdapter<>(sharedBufCompatResult.getConvertDeserializer())));
+				}
+			}
+		}
+
+		return CompatibilityResult.requiresMigration();
+	}
+}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializerConfigSnapshot.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializerConfigSnapshot.java
new file mode 100644
index 00000000000..ab72348d527
--- /dev/null
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializerConfigSnapshot.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.cep.nfa;
+
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+
+/**
+ * {@link CompositeTypeSerializerConfigSnapshot} for {@link NFAStateSerializer}.
+ */
+public final class NFAStateSerializerConfigSnapshot<T> extends CompositeTypeSerializerConfigSnapshot {
+
+	private static final int VERSION = 1;
+
+	/** This empty constructor is required for deserializing the configuration. */
+	public NFAStateSerializerConfigSnapshot() {}
+
+	public NFAStateSerializerConfigSnapshot(
+			TypeSerializer<T> eventSerializer,
+			TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer) {
+
+		super(eventSerializer, sharedBufferSerializer);
+	}
+
+	@Override
+	public int getVersion() {
+		return VERSION;
+	}
+}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/SharedBuffer.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/SharedBuffer.java
index adfa7379376..a00a310392c 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/SharedBuffer.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/SharedBuffer.java
@@ -36,7 +36,6 @@ import org.apache.commons.lang3.StringUtils;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -67,11 +66,9 @@ import java.util.Stack;
  * @param <K> Type of the keys
  * @param <V> Type of the values
  */
-public class SharedBuffer<K extends Serializable, V> implements Serializable {
+public class SharedBuffer<K, V> {
 
-	private static final long serialVersionUID = 9213251042562206495L;
-
-	private transient Map<K, SharedBufferPage<K, V>> pages;
+	private Map<K, SharedBufferPage<K, V>> pages;
 
 	public SharedBuffer() {
 		this.pages = new HashMap<>(4);
@@ -807,7 +804,7 @@ public class SharedBuffer<K extends Serializable, V> implements Serializable {
 	/**
 	 * A {@link TypeSerializer} for the {@link SharedBuffer}.
 	 */
-	public static class SharedBufferSerializer<K extends Serializable, V> extends TypeSerializer<SharedBuffer<K, V>> {
+	public static class SharedBufferSerializer<K, V> extends TypeSerializer<SharedBuffer<K, V>> {
 
 		private static final long serialVersionUID = -3254176794680331560L;
 
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java
index 39e8d34acef..5b9522b3e20 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java
@@ -919,11 +919,8 @@ public class NFACompiler {
 
 		@Override
 		public NFA<T> createNFA() {
-			NFA<T> result =  new NFA<>(inputTypeSerializer.duplicate(), windowTime, timeoutHandling);
-
-			result.addStates(states);
-
-			return result;
+			return new NFA<>(
+				inputTypeSerializer.duplicate(), windowTime, timeoutHandling, states);
 		}
 	}
 }
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java
index 36f0283687b..312549f40d6 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java
@@ -31,6 +31,8 @@ import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.cep.EventComparator;
 import org.apache.flink.cep.nfa.AfterMatchSkipStrategy;
 import org.apache.flink.cep.nfa.NFA;
+import org.apache.flink.cep.nfa.NFAState;
+import org.apache.flink.cep.nfa.NFAStateSerializer;
 import org.apache.flink.cep.nfa.compiler.NFACompiler;
 import org.apache.flink.runtime.state.StateInitializationContext;
 import org.apache.flink.runtime.state.VoidNamespace;
@@ -79,13 +81,15 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 	private static final String NFA_OPERATOR_STATE_NAME = "nfaOperatorStateName";
 	private static final String EVENT_QUEUE_STATE_NAME = "eventQueuesStateName";
 
-	private transient ValueState<NFA<IN>> nfaOperatorState;
+	private transient ValueState<NFAState<IN>> nfaValueState;
 	private transient MapState<Long, List<IN>> elementQueueState;
 
 	private final NFACompiler.NFAFactory<IN> nfaFactory;
 
 	private transient InternalTimerService<VoidNamespace> timerService;
 
+	private transient NFA<IN> nfa;
+
 	/**
 	 * The last seen watermark. This will be used to
 	 * decide if an incoming element is late or not.
@@ -129,11 +133,11 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 	public void initializeState(StateInitializationContext context) throws Exception {
 		super.initializeState(context);
 
-		if (nfaOperatorState == null) {
-			nfaOperatorState = getRuntimeContext().getState(
+		if (nfaValueState == null) {
+			nfaValueState = getRuntimeContext().getState(
 				new ValueStateDescriptor<>(
 						NFA_OPERATOR_STATE_NAME,
-						new NFA.NFASerializer<>(inputSerializer)));
+						new NFAStateSerializer<>(inputSerializer)));
 		}
 
 		if (elementQueueState == null) {
@@ -155,6 +159,8 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 				"watermark-callbacks",
 				VoidNamespaceSerializer.INSTANCE,
 				this);
+
+		this.nfa = nfaFactory.createNFA();
 	}
 
 	@Override
@@ -162,9 +168,9 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 		if (isProcessingTime) {
 			if (comparator == null) {
 				// there can be no out of order elements in processing time
-				NFA<IN> nfa = getNFA();
-				processEvent(nfa, element.getValue(), getProcessingTimeService().getCurrentProcessingTime());
-				updateNFA(nfa);
+				NFAState<IN> nfaState = getNFAState();
+				processEvent(nfaState, element.getValue(), getProcessingTimeService().getCurrentProcessingTime());
+				updateNFA(nfaState);
 			} else {
 				long currentTime = timerService.currentProcessingTime();
 				bufferEvent(element.getValue(), currentTime);
@@ -238,27 +244,27 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 
 		// STEP 1
 		PriorityQueue<Long> sortedTimestamps = getSortedTimestamps();
-		NFA<IN> nfa = getNFA();
+		NFAState<IN> nfaState = getNFAState();
 
 		// STEP 2
 		while (!sortedTimestamps.isEmpty() && sortedTimestamps.peek() <= timerService.currentWatermark()) {
 			long timestamp = sortedTimestamps.poll();
 			sort(elementQueueState.get(timestamp)).forEachOrdered(
-				event -> processEvent(nfa, event, timestamp)
+				event -> processEvent(nfaState, event, timestamp)
 			);
 			elementQueueState.remove(timestamp);
 		}
 
 		// STEP 3
-		advanceTime(nfa, timerService.currentWatermark());
+		advanceTime(nfaState, timerService.currentWatermark());
 
 		// STEP 4
 		if (sortedTimestamps.isEmpty()) {
 			elementQueueState.clear();
 		}
-		updateNFA(nfa);
+		updateNFA(nfaState);
 
-		if (!sortedTimestamps.isEmpty() || !nfa.isEmpty()) {
+		if (!sortedTimestamps.isEmpty() || !nfaState.isEmpty()) {
 			saveRegisterWatermarkTimer();
 		}
 
@@ -276,7 +282,7 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 
 		// STEP 1
 		PriorityQueue<Long> sortedTimestamps = getSortedTimestamps();
-		NFA<IN> nfa = getNFA();
+		NFAState<IN> nfa = getNFAState();
 
 		// STEP 2
 		while (!sortedTimestamps.isEmpty()) {
@@ -307,18 +313,18 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 		this.lastWatermark = timestamp;
 	}
 
-	private NFA<IN> getNFA() throws IOException {
-		NFA<IN> nfa = nfaOperatorState.value();
-		return nfa != null ? nfa : nfaFactory.createNFA();
+	private NFAState<IN> getNFAState() throws IOException {
+		NFAState<IN> nfaState = nfaValueState.value();
+		return nfaState != null ? nfaState : nfa.createNFAState();
 	}
 
-	private void updateNFA(NFA<IN> nfa) throws IOException {
-		if (nfa.isNFAChanged()) {
-			if (nfa.isEmpty()) {
-				nfaOperatorState.clear();
+	private void updateNFA(NFAState<IN> nfaState) throws IOException {
+		if (nfaState.isStateChanged()) {
+			if (nfaState.isEmpty()) {
+				nfaValueState.clear();
 			} else {
-				nfa.resetNFAChanged();
-				nfaOperatorState.update(nfa);
+				nfaState.resetStateChanged();
+				nfaValueState.update(nfaState);
 			}
 		}
 	}
@@ -335,13 +341,13 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 	 * Process the given event by giving it to the NFA and outputting the produced set of matched
 	 * event sequences.
 	 *
-	 * @param nfa NFA to be used for the event detection
+	 * @param nfaState Our NFAState object
 	 * @param event The current event to be processed
 	 * @param timestamp The timestamp of the event
 	 */
-	private void processEvent(NFA<IN> nfa, IN event, long timestamp)  {
+	private void processEvent(NFAState<IN> nfaState, IN event, long timestamp)  {
 		Tuple2<Collection<Map<String, List<IN>>>, Collection<Tuple2<Map<String, List<IN>>, Long>>> patterns =
-			nfa.process(event, timestamp, afterMatchSkipStrategy);
+			nfa.process(nfaState, event, timestamp, afterMatchSkipStrategy);
 
 		try {
 			processMatchedSequences(patterns.f0, timestamp);
@@ -355,12 +361,9 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 	/**
 	 * Advances the time for the given NFA to the given timestamp. This can lead to pruning and
 	 * timeouts.
-	 *
-	 * @param nfa to advance the time for
-	 * @param timestamp to advance the time to
 	 */
-	private void advanceTime(NFA<IN> nfa, long timestamp) throws Exception {
-		processEvent(nfa, null, timestamp);
+	private void advanceTime(NFAState<IN> nfaState, long timestamp) throws Exception {
+		processEvent(nfaState, null, timestamp);
 	}
 
 	protected abstract void processMatchedSequences(Iterable<Map<String, List<IN>>> matchingSequences, long timestamp) throws Exception;
@@ -373,9 +376,9 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 	//////////////////////			Testing Methods			//////////////////////
 
 	@VisibleForTesting
-	public boolean hasNonEmptyNFA(KEY key) throws IOException {
+	public boolean hasNonEmptyNFAState(KEY key) throws IOException {
 		setCurrentKey(key);
-		return nfaOperatorState.value() != null;
+		return nfaValueState.value() != null;
 	}
 
 	@VisibleForTesting
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/pattern/conditions/IterativeCondition.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/pattern/conditions/IterativeCondition.java
index e7c814f1a47..0386d0e9494 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/pattern/conditions/IterativeCondition.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/pattern/conditions/IterativeCondition.java
@@ -84,7 +84,7 @@ public abstract class IterativeCondition<T> implements Function, Serializable {
 	/**
 	 * The context used when evaluating the {@link IterativeCondition condition}.
 	 */
-	public interface Context<T> extends Serializable {
+	public interface Context<T> {
 
 		/**
 		 * @return An {@link Iterable} over the already accepted elements
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java
index c2c7cdacf3e..f9b9aa2bfa4 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java
@@ -1075,14 +1075,16 @@ public class GroupITCase extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(c, a1, b1, d),
 			Lists.newArrayList(c, a1, b1, a2, b2, d)
 		));
 
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 }
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java
index 84278b15fd4..76bc2d04a18 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAITCase.java
@@ -386,9 +386,11 @@ public class NFAITCase extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), true);
 
+		NFAState<Event> nfaState = nfa.createNFAState();
+
 		for (StreamRecord<Event> event: events) {
 			Tuple2<Collection<Map<String, List<Event>>>, Collection<Tuple2<Map<String, List<Event>>, Long>>> patterns =
-					nfa.process(event.getValue(), event.getTimestamp());
+					nfa.process(nfaState, event.getValue(), event.getTimestamp());
 
 			Collection<Map<String, List<Event>>> matchedPatterns = patterns.f0;
 			Collection<Tuple2<Map<String, List<Event>>, Long>> timeoutPatterns = patterns.f1;
@@ -2317,16 +2319,18 @@ public class NFAITCase extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		nfa.process(startEvent, 1);
-		nfa.process(middleEvent1, 2);
-		nfa.process(middleEvent2, 3);
-		nfa.process(middleEvent3, 4);
-		nfa.process(end1, 6);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		nfa.process(nfaState, startEvent, 1);
+		nfa.process(nfaState, middleEvent1, 2);
+		nfa.process(nfaState, middleEvent2, 3);
+		nfa.process(nfaState, middleEvent3, 4);
+		nfa.process(nfaState, end1, 6);
 
 		//pruning element
-		nfa.process(null, 10);
+		nfa.process(nfaState, null, 10);
 
-		assertEquals(true, nfa.isEmpty());
+		assertEquals(true, nfaState.isEmpty());
 	}
 
 	@Test
@@ -2360,14 +2364,16 @@ public class NFAITCase extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		nfa.process(startEvent, 1);
-		nfa.process(middleEvent, 5);
-		nfa.process(end1, 6);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		nfa.process(nfaState, startEvent, 1);
+		nfa.process(nfaState, middleEvent, 5);
+		nfa.process(nfaState, end1, 6);
 
 		//pruning element
-		nfa.process(null, 10);
+		nfa.process(nfaState, null, 10);
 
-		assertEquals(true, nfa.isEmpty());
+		assertEquals(true, nfaState.isEmpty());
 	}
 
 	@Test
@@ -2402,15 +2408,17 @@ public class NFAITCase extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		nfa.process(startEvent, 1);
-		nfa.process(middleEvent1, 3);
-		nfa.process(middleEvent2, 4);
-		nfa.process(end1, 6);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		nfa.process(nfaState, startEvent, 1);
+		nfa.process(nfaState, middleEvent1, 3);
+		nfa.process(nfaState, middleEvent2, 4);
+		nfa.process(nfaState, end1, 6);
 
 		//pruning element
-		nfa.process(null, 10);
+		nfa.process(nfaState, null, 10);
 
-		assertEquals(true, nfa.isEmpty());
+		assertEquals(true, nfaState.isEmpty());
 	}
 
 	@Test
@@ -2445,15 +2453,17 @@ public class NFAITCase extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		nfa.process(startEvent, 1);
-		nfa.process(middleEvent1, 3);
-		nfa.process(middleEvent2, 4);
-		nfa.process(end1, 6);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		nfa.process(nfaState, startEvent, 1);
+		nfa.process(nfaState, middleEvent1, 3);
+		nfa.process(nfaState, middleEvent2, 4);
+		nfa.process(nfaState, end1, 6);
 
 		//pruning element
-		nfa.process(null, 10);
+		nfa.process(nfaState, null, 10);
 
-		assertEquals(true, nfa.isEmpty());
+		assertEquals(true, nfaState.isEmpty());
 	}
 
 	///////////////////////////////////////   Skip till next     /////////////////////////////
@@ -2703,8 +2713,11 @@ public class NFAITCase extends TestLogger {
 
 		List<Map<String, List<Event>>> resultingPatterns = new ArrayList<>();
 
+		NFAState<Event> nfaState = nfa.createNFAState();
+
 		for (StreamRecord<Event> inputEvent : inputEvents) {
 			Collection<Map<String, List<Event>>> patterns = nfa.process(
+					nfaState,
 					inputEvent.getValue(),
 					inputEvent.getTimestamp()).f0;
 
@@ -2774,8 +2787,11 @@ public class NFAITCase extends TestLogger {
 
 		List<Map<String, List<Event>>> resultingPatterns = new ArrayList<>();
 
+		NFAState<Event> nfaState = nfa.createNFAState();
+
 		for (StreamRecord<Event> inputEvent : inputEvents) {
 			Collection<Map<String, List<Event>>> patterns = nfa.process(
+				nfaState,
 				inputEvent.getValue(),
 				inputEvent.getTimestamp()).f0;
 
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAStatusChangeITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAStatusChangeITCase.java
index 37ad0064bbe..38796992bb3 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAStatusChangeITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFAStatusChangeITCase.java
@@ -36,8 +36,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
- * Tests if the {@link NFA} status ({@link NFA#computationStates} or {@link NFA#eventSharedBuffer})
- * is changed after processing events.
+ * Tests if the {@link NFAState} status is changed after processing events.
  */
 public class NFAStatusChangeITCase {
 
@@ -76,45 +75,47 @@ public class NFAStatusChangeITCase {
 		NFACompiler.NFAFactory<Event> nfaFactory = NFACompiler.compileFactory(pattern, Event.createTypeSerializer(), true);
 		NFA<Event> nfa = nfaFactory.createNFA();
 
-		nfa.process(new Event(1, "b", 1.0), 1L);
-		assertFalse("NFA status should not change as the event does not match the take condition of the 'start' state", nfa.isNFAChanged());
+		NFAState<Event> nfaState = nfa.createNFAState();
 
-		nfa.resetNFAChanged();
-		nfa.process(new Event(2, "a", 1.0), 2L);
-		assertTrue("NFA status should change as the event matches the take condition of the 'start' state", nfa.isNFAChanged());
+		nfa.process(nfaState, new Event(1, "b", 1.0), 1L);
+		assertFalse("NFA status should not change as the event does not match the take condition of the 'start' state", nfaState.isStateChanged());
+
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(2, "a", 1.0), 2L);
+		assertTrue("NFA status should change as the event matches the take condition of the 'start' state", nfaState.isStateChanged());
 
 		// the status of the queue of ComputationStatus changed,
 		// more than one ComputationStatus is generated by the event from some ComputationStatus
-		nfa.resetNFAChanged();
-		nfa.process(new Event(3, "f", 1.0), 3L);
-		assertTrue("NFA status should change as the event matches the ignore condition and proceed condition of the 'middle:1' state", nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(3, "f", 1.0), 3L);
+		assertTrue("NFA status should change as the event matches the ignore condition and proceed condition of the 'middle:1' state", nfaState.isStateChanged());
 
 		// both the queue of ComputationStatus and eventSharedBuffer have not changed
-		nfa.resetNFAChanged();
-		nfa.process(new Event(4, "f", 1.0), 4L);
-		assertFalse("NFA status should not change as the event only matches the ignore condition of the 'middle:2' state and the target state is still 'middle:2'", nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(4, "f", 1.0), 4L);
+		assertFalse("NFA status should not change as the event only matches the ignore condition of the 'middle:2' state and the target state is still 'middle:2'", nfaState.isStateChanged());
 
 		// both the queue of ComputationStatus and eventSharedBuffer have changed
-		nfa.resetNFAChanged();
-		nfa.process(new Event(5, "b", 1.0), 5L);
-		assertTrue("NFA status should change as the event matches the take condition of 'middle:2' state", nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(5, "b", 1.0), 5L);
+		assertTrue("NFA status should change as the event matches the take condition of 'middle:2' state", nfaState.isStateChanged());
 
 		// both the queue of ComputationStatus and eventSharedBuffer have changed
-		nfa.resetNFAChanged();
-		nfa.process(new Event(6, "d", 1.0), 6L);
-		assertTrue("NFA status should change as the event matches the take condition of 'middle2' state", nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(6, "d", 1.0), 6L);
+		assertTrue("NFA status should change as the event matches the take condition of 'middle2' state", nfaState.isStateChanged());
 
 		// both the queue of ComputationStatus and eventSharedBuffer have not changed
 		// as the timestamp is within the window
-		nfa.resetNFAChanged();
-		nfa.process(null, 8L);
-		assertFalse("NFA status should not change as the timestamp is within the window", nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, null, 8L);
+		assertFalse("NFA status should not change as the timestamp is within the window", nfaState.isStateChanged());
 
 		// timeout ComputationStatus will be removed from the queue of ComputationStatus and timeout event will
 		// be removed from eventSharedBuffer as the timeout happens
-		nfa.resetNFAChanged();
-		Collection<Tuple2<Map<String, List<Event>>, Long>> timeoutResults = nfa.process(null, 12L).f1;
-		assertTrue("NFA status should change as timeout happens", nfa.isNFAChanged() && !timeoutResults.isEmpty());
+		nfaState.resetStateChanged();
+		Collection<Tuple2<Map<String, List<Event>>, Long>> timeoutResults = nfa.process(nfaState, null, 12L).f1;
+		assertTrue("NFA status should change as timeout happens", nfaState.isStateChanged() && !timeoutResults.isEmpty());
 	}
 
 	@Test
@@ -143,12 +144,14 @@ public class NFAStatusChangeITCase {
 		NFACompiler.NFAFactory<Event> nfaFactory = NFACompiler.compileFactory(pattern, Event.createTypeSerializer(), true);
 		NFA<Event> nfa = nfaFactory.createNFA();
 
-		nfa.resetNFAChanged();
-		nfa.process(new Event(6, "start", 1.0), 6L);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(6, "start", 1.0), 6L);
 
-		nfa.resetNFAChanged();
-		nfa.process(new Event(6, "a", 1.0), 7L);
-		assertTrue(nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(6, "a", 1.0), 7L);
+		assertTrue(nfaState.isStateChanged());
 	}
 
 	@Test
@@ -170,11 +173,13 @@ public class NFAStatusChangeITCase {
 		NFACompiler.NFAFactory<Event> nfaFactory = NFACompiler.compileFactory(pattern, Event.createTypeSerializer(), true);
 		NFA<Event> nfa = nfaFactory.createNFA();
 
-		nfa.resetNFAChanged();
-		nfa.process(new Event(6, "start", 1.0), 6L);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(6, "start", 1.0), 6L);
 
-		nfa.resetNFAChanged();
-		nfa.process(new Event(6, "end", 1.0), 17L);
-		assertTrue(nfa.isNFAChanged());
+		nfaState.resetStateChanged();
+		nfa.process(nfaState, new Event(6, "end", 1.0), 17L);
+		assertTrue(nfaState.isStateChanged());
 	}
 }
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATest.java
index 7721653914f..5d43111ba0e 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATest.java
@@ -52,7 +52,6 @@ import static org.junit.Assert.assertEquals;
 public class NFATest extends TestLogger {
 	@Test
 	public void testSimpleNFA() {
-		NFA<Event> nfa = new NFA<>(Event.createTypeSerializer(), 0, false);
 		List<StreamRecord<Event>> streamEvents = new ArrayList<>();
 
 		streamEvents.add(new StreamRecord<>(new Event(1, "start", 1.0), 1L));
@@ -86,9 +85,12 @@ public class NFATest extends TestLogger {
 			});
 		endState.addIgnore(BooleanConditions.<Event>trueFunction());
 
-		nfa.addState(startState);
-		nfa.addState(endState);
-		nfa.addState(endingState);
+		List<State<Event>> states = new ArrayList<>();
+		states.add(startState);
+		states.add(endState);
+		states.add(endingState);
+
+		NFA<Event> nfa = new NFA<>(Event.createTypeSerializer(), 0, false, states);
 
 		Set<Map<String, List<Event>>> expectedPatterns = new HashSet<>();
 
@@ -103,7 +105,7 @@ public class NFATest extends TestLogger {
 		expectedPatterns.add(firstPattern);
 		expectedPatterns.add(secondPattern);
 
-		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, streamEvents);
+		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, nfa.createNFAState(), streamEvents);
 
 		assertEquals(expectedPatterns, actualPatterns);
 	}
@@ -126,7 +128,7 @@ public class NFATest extends TestLogger {
 
 		expectedPatterns.add(secondPattern);
 
-		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, streamEvents);
+		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, nfa.createNFAState(), streamEvents);
 
 		assertEquals(expectedPatterns, actualPatterns);
 	}
@@ -145,7 +147,7 @@ public class NFATest extends TestLogger {
 
 		Set<Map<String, List<Event>>> expectedPatterns = Collections.emptySet();
 
-		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, streamEvents);
+		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, nfa.createNFAState(), streamEvents);
 
 		assertEquals(expectedPatterns, actualPatterns);
 	}
@@ -172,7 +174,7 @@ public class NFATest extends TestLogger {
 
 		expectedPatterns.add(secondPattern);
 
-		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, streamEvents);
+		Collection<Map<String, List<Event>>> actualPatterns = runNFA(nfa, nfa.createNFAState(), streamEvents);
 
 		assertEquals(expectedPatterns, actualPatterns);
 	}
@@ -187,21 +189,25 @@ public class NFATest extends TestLogger {
 		streamEvents.add(new StreamRecord<>(new Event(3, "loop", 3.0), 103L));
 		streamEvents.add(new StreamRecord<>(new Event(4, "loop", 4.0), 104L));
 		streamEvents.add(new StreamRecord<>(new Event(5, "loop", 5.0), 105L));
-		runNFA(nfa, streamEvents);
 
-		NFA.NFASerializer<Event> serializer = new NFA.NFASerializer<>(Event.createTypeSerializer());
+		NFAState<Event> nfaState = nfa.createNFAState();
+		runNFA(nfa, nfaState, streamEvents);
+
+		NFAStateSerializer<Event> serializer = new NFAStateSerializer<>(Event.createTypeSerializer());
 
 		//serialize
 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
-		serializer.serialize(nfa, new DataOutputViewStreamWrapper(baos));
+		serializer.serialize(nfaState, new DataOutputViewStreamWrapper(baos));
 		baos.close();
 	}
 
-	public <T> Collection<Map<String, List<T>>> runNFA(NFA<T> nfa, List<StreamRecord<T>> inputs) {
+	public <T> Collection<Map<String, List<T>>> runNFA(
+		NFA<T> nfa, NFAState<T> nfaState, List<StreamRecord<T>> inputs) {
 		Set<Map<String, List<T>>> actualPatterns = new HashSet<>();
 
 		for (StreamRecord<T> streamEvent : inputs) {
 			Collection<Map<String, List<T>>> matchedPatterns = nfa.process(
+				nfaState,
 				streamEvent.getValue(),
 				streamEvent.getTimestamp()).f0;
 
@@ -311,24 +317,26 @@ public class NFATest extends TestLogger {
 			Event b3 = new Event(41, "b", 5.0);
 			Event d = new Event(43, "d", 4.0);
 
-			nfa.process(a, 1);
-			nfa.process(b, 2);
-			nfa.process(c, 3);
-			nfa.process(b1, 4);
-			nfa.process(b2, 5);
-			nfa.process(b3, 6);
-			nfa.process(d, 7);
-			nfa.process(a, 8);
+			NFAState<Event> nfaState = nfa.createNFAState();
+
+			nfa.process(nfaState, a, 1);
+			nfa.process(nfaState, b, 2);
+			nfa.process(nfaState, c, 3);
+			nfa.process(nfaState, b1, 4);
+			nfa.process(nfaState, b2, 5);
+			nfa.process(nfaState, b3, 6);
+			nfa.process(nfaState, d, 7);
+			nfa.process(nfaState, a, 8);
 
-			NFA.NFASerializer<Event> serializer = new NFA.NFASerializer<>(Event.createTypeSerializer());
+			NFAStateSerializer<Event> serializer = new NFAStateSerializer<>(Event.createTypeSerializer());
 
 			//serialize
 			ByteArrayOutputStream baos = new ByteArrayOutputStream();
-			serializer.serialize(nfa, new DataOutputViewStreamWrapper(baos));
+			serializer.serialize(nfaState, new DataOutputViewStreamWrapper(baos));
 			baos.close();
 
 			// copy
-			NFA.NFASerializer<Event> copySerializer = new NFA.NFASerializer<>(Event.createTypeSerializer());
+			NFAStateSerializer<Event> copySerializer = new NFAStateSerializer<>(Event.createTypeSerializer());
 			ByteArrayInputStream in = new ByteArrayInputStream(baos.toByteArray());
 			ByteArrayOutputStream out = new ByteArrayOutputStream();
 			copySerializer.duplicate().copy(new DataInputViewStreamWrapper(in), new DataOutputViewStreamWrapper(out));
@@ -337,15 +345,14 @@ public class NFATest extends TestLogger {
 
 			// deserialize
 			ByteArrayInputStream bais = new ByteArrayInputStream(out.toByteArray());
-			NFA<Event> copy = serializer.duplicate().deserialize(new DataInputViewStreamWrapper(bais));
+			NFAState<Event> copy = serializer.duplicate().deserialize(new DataInputViewStreamWrapper(bais));
 			bais.close();
 
-			assertEquals(nfa, copy);
+			assertEquals(nfaState, copy);
 		}
 	}
 
 	private NFA<Event> createStartEndNFA(long windowLength) {
-		NFA<Event> nfa = new NFA<>(Event.createTypeSerializer(), windowLength, false);
 
 		State<Event> startState = new State<>("start", State.StateType.Start);
 		State<Event> endState = new State<>("end", State.StateType.Normal);
@@ -373,11 +380,12 @@ public class NFATest extends TestLogger {
 			});
 		endState.addIgnore(BooleanConditions.<Event>trueFunction());
 
-		nfa.addState(startState);
-		nfa.addState(endState);
-		nfa.addState(endingState);
+		List<State<Event>> states = new ArrayList<>();
+		states.add(startState);
+		states.add(endState);
+		states.add(endingState);
 
-		return nfa;
+		return new NFA<>(Event.createTypeSerializer(), windowLength, false, states);
 	}
 
 	private NFA<Event> createLoopingNFA(long windowLength) {
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATestUtilities.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATestUtilities.java
index a9e17955ac8..b5312cbfbf7 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATestUtilities.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/NFATestUtilities.java
@@ -35,16 +35,36 @@ import java.util.Map;
  */
 public class NFATestUtilities {
 
-	public static List<List<Event>> feedNFA(List<StreamRecord<Event>> inputEvents, NFA<Event> nfa) {
-		return feedNFA(inputEvents, nfa, AfterMatchSkipStrategy.noSkip());
+	public static List<List<Event>> feedNFA(
+		List<StreamRecord<Event>> inputEvents,
+		NFA<Event> nfa) {
+		return feedNFA(inputEvents, nfa, nfa.createNFAState(), AfterMatchSkipStrategy.noSkip());
 	}
 
-	public static List<List<Event>> feedNFA(List<StreamRecord<Event>> inputEvents, NFA<Event> nfa,
-											AfterMatchSkipStrategy afterMatchSkipStrategy) {
+	public static List<List<Event>> feedNFA(
+			List<StreamRecord<Event>> inputEvents,
+			NFA<Event> nfa,
+			NFAState<Event> nfaState) {
+		return feedNFA(inputEvents, nfa, nfaState, AfterMatchSkipStrategy.noSkip());
+	}
+
+	public static List<List<Event>> feedNFA(
+		List<StreamRecord<Event>> inputEvents,
+		NFA<Event> nfa,
+		AfterMatchSkipStrategy afterMatchSkipStrategy) {
+		return feedNFA(inputEvents, nfa, nfa.createNFAState(), afterMatchSkipStrategy);
+	}
+
+	public static List<List<Event>> feedNFA(
+			List<StreamRecord<Event>> inputEvents,
+			NFA<Event> nfa,
+			NFAState<Event> nfaState,
+			AfterMatchSkipStrategy afterMatchSkipStrategy) {
 		List<List<Event>> resultingPatterns = new ArrayList<>();
 
 		for (StreamRecord<Event> inputEvent : inputEvents) {
 			Collection<Map<String, List<Event>>> patterns = nfa.process(
+				nfaState,
 				inputEvent.getValue(),
 				inputEvent.getTimestamp(),
 				afterMatchSkipStrategy).f0;
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/SameElementITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/SameElementITCase.java
index 357107fce9c..c94d739d2aa 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/SameElementITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/SameElementITCase.java
@@ -140,11 +140,13 @@ public void testClearingBuffer() throws Exception {
 
 	NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-	List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+	NFAState<Event> nfaState = nfa.createNFAState();
+
+	List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 	compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 		Lists.newArrayList(a1, b1, c1, d)
 	));
-	assertTrue(nfa.isEmpty());
+	assertTrue(nfaState.isEmpty());
 }
 
 @Test
@@ -182,13 +184,15 @@ public void testClearingBufferWithUntilAtTheEnd() throws Exception {
 
 	NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-	List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+	NFAState<Event> nfaState = nfa.createNFAState();
+
+	List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 	compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 		Lists.newArrayList(a1, d1, d2, d3),
 		Lists.newArrayList(a1, d1, d2),
 		Lists.newArrayList(a1, d1)
 	));
-	assertTrue(nfa.isEmpty());
+	assertTrue(nfaState.isEmpty());
 }
 
 	@Test
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/UntilConditionITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/UntilConditionITCase.java
index f88e5b21ab4..b6031743612 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/UntilConditionITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/UntilConditionITCase.java
@@ -91,13 +91,15 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, breaking),
 			Lists.newArrayList(startEvent, middleEvent1, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -137,7 +139,9 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, middleEvent3, breaking),
@@ -145,7 +149,7 @@ public class UntilConditionITCase {
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent3, breaking),
 			Lists.newArrayList(startEvent, middleEvent1, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -185,13 +189,15 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, breaking),
 			Lists.newArrayList(startEvent, middleEvent1, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -233,12 +239,14 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -278,14 +286,16 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, breaking),
 			Lists.newArrayList(startEvent, middleEvent1, breaking),
 			Lists.newArrayList(startEvent, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -325,7 +335,9 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, middleEvent3, breaking),
@@ -334,7 +346,7 @@ public class UntilConditionITCase {
 			Lists.newArrayList(startEvent, middleEvent1, breaking),
 			Lists.newArrayList(startEvent, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -374,14 +386,16 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, breaking),
 			Lists.newArrayList(startEvent, middleEvent1, breaking),
 			Lists.newArrayList(startEvent, breaking)
 		));
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -502,7 +516,9 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, middleEvent3),
@@ -510,7 +526,7 @@ public class UntilConditionITCase {
 			Lists.newArrayList(startEvent, middleEvent1)
 		));
 
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -553,7 +569,9 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, middleEvent3),
@@ -561,7 +579,7 @@ public class UntilConditionITCase {
 			Lists.newArrayList(startEvent, middleEvent1)
 		));
 
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 
 	@Test
@@ -604,7 +622,9 @@ public class UntilConditionITCase {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, Event.createTypeSerializer(), false);
 
-		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa);
+		NFAState<Event> nfaState = nfa.createNFAState();
+
+		final List<List<Event>> resultingPatterns = feedNFA(inputEvents, nfa, nfaState);
 
 		compareMaps(resultingPatterns, Lists.<List<Event>>newArrayList(
 			Lists.newArrayList(startEvent, middleEvent1, middleEvent2, middleEvent3),
@@ -613,6 +633,6 @@ public class UntilConditionITCase {
 			Lists.newArrayList(startEvent)
 		));
 
-		assertTrue(nfa.isEmpty());
+		assertTrue(nfaState.isEmpty());
 	}
 }
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/compiler/NFACompilerTest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/compiler/NFACompilerTest.java
index ec2cf47578c..d1b6d5901bc 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/compiler/NFACompilerTest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/compiler/NFACompilerTest.java
@@ -40,6 +40,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -132,7 +133,7 @@ public class NFACompilerTest extends TestLogger {
 
 		NFA<Event> nfa = NFACompiler.compile(pattern, serializer, false);
 
-		Set<State<Event>> states = nfa.getStates();
+		Collection<State<Event>> states = nfa.getStates();
 		assertEquals(4, states.size());
 
 		Map<String, State<Event>> stateMap = new HashMap<>();
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java
index 2fda47f9d3c..3151498feed 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java
@@ -71,7 +71,7 @@ public class CEPMigrationTest {
 
 	@Parameterized.Parameters(name = "Migration Savepoint: {0}")
 	public static Collection<MigrationVersion> parameters () {
-		return Arrays.asList(MigrationVersion.v1_3, MigrationVersion.v1_4);
+		return Arrays.asList(MigrationVersion.v1_5);
 	}
 
 	public CEPMigrationTest(MigrationVersion migrateVersion) {
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPOperatorTest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPOperatorTest.java
index 98cb4685322..5a984452dbe 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPOperatorTest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPOperatorTest.java
@@ -462,9 +462,9 @@ public class CEPOperatorTest extends TestLogger {
 		try {
 			harness.open();
 
-			final ValueState nfaOperatorState = (ValueState) Whitebox.<ValueState>getInternalState(operator, "nfaOperatorState");
+			final ValueState nfaOperatorState = (ValueState) Whitebox.<ValueState>getInternalState(operator, "nfaValueState");
 			final ValueState nfaOperatorStateSpy = Mockito.spy(nfaOperatorState);
-			Whitebox.setInternalState(operator, "nfaOperatorState", nfaOperatorStateSpy);
+			Whitebox.setInternalState(operator, "nfaValueState", nfaOperatorStateSpy);
 
 			Event startEvent = new Event(42, "c", 1.0);
 			SubEvent middleEvent = new SubEvent(42, "a", 1.0, 10.0);
@@ -507,9 +507,9 @@ public class CEPOperatorTest extends TestLogger {
 
 			harness.open();
 
-			final ValueState nfaOperatorState = (ValueState) Whitebox.<ValueState>getInternalState(operator, "nfaOperatorState");
+			final ValueState nfaOperatorState = (ValueState) Whitebox.<ValueState>getInternalState(operator, "nfaValueState");
 			final ValueState nfaOperatorStateSpy = Mockito.spy(nfaOperatorState);
-			Whitebox.setInternalState(operator, "nfaOperatorState", nfaOperatorStateSpy);
+			Whitebox.setInternalState(operator, "nfaValueState", nfaOperatorStateSpy);
 
 			Event startEvent = new Event(42, "c", 1.0);
 			SubEvent middleEvent = new SubEvent(42, "a", 1.0, 10.0);
@@ -568,8 +568,8 @@ public class CEPOperatorTest extends TestLogger {
 			assertEquals(2L, harness.numEventTimeTimers());
 			assertEquals(4L, operator.getPQSize(42));
 			assertEquals(1L, operator.getPQSize(43));
-			assertTrue(!operator.hasNonEmptyNFA(42));
-			assertTrue(!operator.hasNonEmptyNFA(43));
+			assertTrue(!operator.hasNonEmptyNFAState(42));
+			assertTrue(!operator.hasNonEmptyNFAState(43));
 
 			harness.processWatermark(new Watermark(2L));
 
@@ -581,9 +581,9 @@ public class CEPOperatorTest extends TestLogger {
 			// for 43 the element entered the NFA and the PQ is empty
 
 			assertEquals(2L, harness.numEventTimeTimers());
-			assertTrue(operator.hasNonEmptyNFA(42));
+			assertTrue(operator.hasNonEmptyNFAState(42));
 			assertEquals(1L, operator.getPQSize(42));
-			assertTrue(operator.hasNonEmptyNFA(43));
+			assertTrue(operator.hasNonEmptyNFAState(43));
 			assertTrue(!operator.hasNonEmptyPQ(43));
 
 			harness.processElement(new StreamRecord<>(startEvent2, 4L));
@@ -605,9 +605,9 @@ public class CEPOperatorTest extends TestLogger {
 			// now we have 1 key because the 43 expired and was removed.
 			// 42 is still there due to startEvent2
 			assertEquals(1L, harness.numEventTimeTimers());
-			assertTrue(operator2.hasNonEmptyNFA(42));
+			assertTrue(operator2.hasNonEmptyNFAState(42));
 			assertTrue(!operator2.hasNonEmptyPQ(42));
-			assertTrue(!operator2.hasNonEmptyNFA(43));
+			assertTrue(!operator2.hasNonEmptyNFAState(43));
 			assertTrue(!operator2.hasNonEmptyPQ(43));
 
 			verifyPattern(harness.getOutput().poll(), startEvent1, middleEvent1, endEvent1);
@@ -622,7 +622,7 @@ public class CEPOperatorTest extends TestLogger {
 			harness.processWatermark(20L);
 			harness.processWatermark(21L);
 
-			assertTrue(!operator2.hasNonEmptyNFA(42));
+			assertTrue(!operator2.hasNonEmptyNFAState(42));
 			assertTrue(!operator2.hasNonEmptyPQ(42));
 			assertEquals(0L, harness.numEventTimeTimers());
 
@@ -665,7 +665,7 @@ public class CEPOperatorTest extends TestLogger {
 
 			assertEquals(1L, harness.numEventTimeTimers());
 			assertEquals(7L, operator.getPQSize(41));
-			assertTrue(!operator.hasNonEmptyNFA(41));
+			assertTrue(!operator.hasNonEmptyNFAState(41));
 
 			harness.processWatermark(new Watermark(2L));
 
@@ -674,7 +674,7 @@ public class CEPOperatorTest extends TestLogger {
 
 			assertEquals(1L, harness.numEventTimeTimers());
 			assertEquals(6L, operator.getPQSize(41));
-			assertTrue(operator.hasNonEmptyNFA(41)); // processed the first element
+			assertTrue(operator.hasNonEmptyNFAState(41)); // processed the first element
 
 			harness.processWatermark(new Watermark(8L));
 
@@ -714,12 +714,12 @@ public class CEPOperatorTest extends TestLogger {
 
 			assertEquals(1L, harness.numEventTimeTimers());
 			assertEquals(0L, operator.getPQSize(41));
-			assertTrue(operator.hasNonEmptyNFA(41));
+			assertTrue(operator.hasNonEmptyNFAState(41));
 
 			harness.processWatermark(new Watermark(17L));
 			verifyWatermark(harness.getOutput().poll(), 17L);
 
-			assertTrue(!operator.hasNonEmptyNFA(41));
+			assertTrue(!operator.hasNonEmptyNFAState(41));
 			assertTrue(!operator.hasNonEmptyPQ(41));
 			assertEquals(0L, harness.numEventTimeTimers());
 		} finally {
@@ -800,8 +800,8 @@ public class CEPOperatorTest extends TestLogger {
 
 			assertTrue(!operator.hasNonEmptyPQ(42));
 			assertTrue(!operator.hasNonEmptyPQ(43));
-			assertTrue(operator.hasNonEmptyNFA(42));
-			assertTrue(operator.hasNonEmptyNFA(43));
+			assertTrue(operator.hasNonEmptyNFAState(42));
+			assertTrue(operator.hasNonEmptyNFAState(43));
 
 			harness.setProcessingTime(3L);
 
@@ -834,10 +834,10 @@ public class CEPOperatorTest extends TestLogger {
 
 			harness.setProcessingTime(21L);
 
-			assertTrue(operator2.hasNonEmptyNFA(42));
+			assertTrue(operator2.hasNonEmptyNFAState(42));
 
 			harness.processElement(new StreamRecord<>(startEvent1, 21L));
-			assertTrue(operator2.hasNonEmptyNFA(42));
+			assertTrue(operator2.hasNonEmptyNFAState(42));
 
 			harness.setProcessingTime(49L);
 
@@ -845,7 +845,7 @@ public class CEPOperatorTest extends TestLogger {
 			harness.processElement(new StreamRecord<>(new Event(42, "foobar", 1.0), 2L));
 
 			// the pattern expired
-			assertTrue(!operator2.hasNonEmptyNFA(42));
+			assertTrue(!operator2.hasNonEmptyNFAState(42));
 
 			assertEquals(0L, harness.numEventTimeTimers());
 			assertTrue(!operator2.hasNonEmptyPQ(42));
@@ -988,12 +988,12 @@ public class CEPOperatorTest extends TestLogger {
 			harness
 				.processElement(new StreamRecord<>(new SubEvent(42, "barfoo", 1.0, 5.0), 0L));
 
-			assertTrue(!operator.hasNonEmptyNFA(42));
-			assertTrue(!operator.hasNonEmptyNFA(43));
+			assertTrue(!operator.hasNonEmptyNFAState(42));
+			assertTrue(!operator.hasNonEmptyNFAState(43));
 
 			harness.setProcessingTime(3L);
-			assertTrue(operator.hasNonEmptyNFA(42));
-			assertTrue(operator.hasNonEmptyNFA(43));
+			assertTrue(operator.hasNonEmptyNFAState(42));
+			assertTrue(operator.hasNonEmptyNFAState(43));
 
 			harness.processElement(new StreamRecord<>(middleEvent2, 3L));
 			harness.processElement(new StreamRecord<>(middleEvent1, 3L));
@@ -1047,14 +1047,14 @@ public class CEPOperatorTest extends TestLogger {
 
 			assertTrue(operator.hasNonEmptyPQ(42));
 			assertTrue(operator.hasNonEmptyPQ(43));
-			assertTrue(!operator.hasNonEmptyNFA(42));
-			assertTrue(!operator.hasNonEmptyNFA(43));
+			assertTrue(!operator.hasNonEmptyNFAState(42));
+			assertTrue(!operator.hasNonEmptyNFAState(43));
 
 			harness.processWatermark(3L);
 			assertTrue(!operator.hasNonEmptyPQ(42));
 			assertTrue(!operator.hasNonEmptyPQ(43));
-			assertTrue(operator.hasNonEmptyNFA(42));
-			assertTrue(operator.hasNonEmptyNFA(43));
+			assertTrue(operator.hasNonEmptyNFAState(42));
+			assertTrue(operator.hasNonEmptyNFAState(43));
 
 			harness.processElement(new StreamRecord<>(startEvent2, 4L));
 			harness.processElement(new StreamRecord<Event>(middleEvent2, 5L));
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot
similarity index 80%
rename from flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.4-snapshot
rename to flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot
index 660a21a77b0..73934e565f5 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.4-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot
similarity index 77%
rename from flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.4-snapshot
rename to flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot
index d4d3405ae45..3126ff4867b 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.4-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot
similarity index 89%
rename from flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.4-snapshot
rename to flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot
index c87f307a574..63b1b492249 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.4-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot
similarity index 79%
rename from flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.4-snapshot
rename to flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot
index 34c5110607d..1b1fa754c9e 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.4-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot differ
