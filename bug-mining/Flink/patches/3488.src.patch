diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
index 3507bb5e5d0..2e115483f30 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
@@ -131,8 +131,13 @@ public class SourceStreamTask<OUT, SRC extends SourceFunction<OUT>, OP extends S
 
 	@Override
 	protected void cancelTask() {
-		if (headOperator != null) {
-			headOperator.cancel();
+		try {
+			if (headOperator != null) {
+				headOperator.cancel();
+			}
+		}
+		finally {
+			sourceThread.interrupt();
 		}
 	}
 
@@ -191,6 +196,7 @@ public class SourceStreamTask<OUT, SRC extends SourceFunction<OUT>, OP extends S
 				headOperator.run(getCheckpointLock(), getStreamStatusMaintainer(), operatorChain);
 				completionFuture.complete(null);
 			} catch (Throwable t) {
+				// Note, t can be also an InterruptedException
 				completionFuture.completeExceptionally(t);
 			}
 		}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index da83dc8038e..aeac7da7552 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -76,6 +76,7 @@ import org.apache.flink.streaming.runtime.tasks.mailbox.TaskMailbox;
 import org.apache.flink.streaming.runtime.tasks.mailbox.TaskMailboxImpl;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.Preconditions;
+import org.apache.flink.util.WrappingRuntimeException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -466,7 +467,7 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
 
 			// let the task do its work
 			isRunning = true;
-			mailboxProcessor.runMailboxLoop();
+			runMailboxLoop();
 
 			// if this left the run() method cleanly despite the fact that this was canceled,
 			// make sure the "clean shutdown" is not attempted
@@ -481,6 +482,37 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
 		}
 	}
 
+	private void runMailboxLoop() throws Exception {
+		try {
+			try {
+				mailboxProcessor.runMailboxLoop();
+			}
+			catch (WrappingRuntimeException wrappingException) {
+				Throwable unwrapped = wrappingException.unwrap();
+				if (unwrapped instanceof Exception) {
+					throw (Exception) unwrapped;
+				}
+				else {
+					throw wrappingException;
+				}
+			}
+		}
+		catch (InterruptedException e) {
+			if (!canceled) {
+				Thread.currentThread().interrupt();
+				throw e;
+			}
+		}
+		catch (Exception e) {
+			if (canceled) {
+				LOG.warn("Error while canceling task.", e);
+			}
+			else {
+				throw e;
+			}
+		}
+	}
+
 	private void afterInvoke() throws Exception {
 		LOG.debug("Finished task {}", getName());
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/Mail.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/Mail.java
index 8665a4a0acf..db1c1c44865 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/Mail.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/Mail.java
@@ -19,7 +19,6 @@ package org.apache.flink.streaming.runtime.tasks.mailbox;
 
 import org.apache.flink.annotation.Internal;
 import org.apache.flink.streaming.runtime.tasks.StreamTaskActionExecutor;
-import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.function.RunnableWithException;
 
@@ -76,10 +75,6 @@ public class Mail {
 	}
 
 	public void run() throws Exception {
-		try {
-			actionExecutor.run(runnable);
-		} catch (Exception e) {
-			throw new FlinkException("Cannot process mail " + toString(), e);
-		}
+		actionExecutor.run(runnable);
 	}
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java
index 0c93ae34340..05e968c55ed 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxProcessor.java
@@ -195,7 +195,12 @@ public class MailboxProcessor implements Closeable {
 	public void reportThrowable(Throwable throwable) {
 		sendControlMail(
 			() -> {
-				throw WrappingRuntimeException.wrapIfNecessary(throwable);
+				if (throwable instanceof Exception) {
+					throw (Exception) throwable;
+				}
+				else {
+					throw WrappingRuntimeException.wrapIfNecessary(throwable);
+				}
 			},
 			"Report throwable %s", throwable);
 	}
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java
index 87a3a47920a..4e02a865a52 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java
@@ -29,6 +29,7 @@ import org.apache.flink.runtime.checkpoint.CheckpointMetaData;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.execution.CancelTaskException;
 import org.apache.flink.runtime.jobgraph.OperatorID;
+import org.apache.flink.runtime.operators.testutils.ExpectedTestException;
 import org.apache.flink.streaming.api.TimeCharacteristic;
 import org.apache.flink.streaming.api.checkpoint.ListCheckpointed;
 import org.apache.flink.streaming.api.functions.source.FromElementsFunction;
@@ -54,6 +55,7 @@ import java.util.Random;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
@@ -62,6 +64,7 @@ import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicLong;
 
 import static org.apache.flink.util.Preconditions.checkState;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
@@ -241,6 +244,191 @@ public class SourceStreamTaskTest {
 			testHarness.getOutput());
 	}
 
+	@Test
+	public void testCancellationWithSourceBlockedOnLock() throws Exception {
+		testCancellationWithSourceBlockedOnLock(false, false);
+	}
+
+	@Test
+	public void testCancellationWithSourceBlockedOnLockWithPendingMail() throws Exception {
+		testCancellationWithSourceBlockedOnLock(true, false);
+	}
+
+	@Test
+	public void testCancellationWithSourceBlockedOnLockAndThrowingOnError() throws Exception {
+		testCancellationWithSourceBlockedOnLock(false, true);
+	}
+
+	@Test
+	public void testCancellationWithSourceBlockedOnLockWithPendingMailAndThrowingOnError() throws Exception {
+		testCancellationWithSourceBlockedOnLock(true, true);
+	}
+
+	/**
+	 * Note that this test is testing also for the shared cancellation logic inside {@link StreamTask}
+	 * which, as of the time this test is being written, is not tested anywhere else
+	 * (like {@link StreamTaskTest} or {@link OneInputStreamTaskTest}).
+	 */
+	public void testCancellationWithSourceBlockedOnLock(boolean withPendingMail, boolean throwInCancel) throws Exception {
+		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(
+			SourceStreamTask::new,
+			BasicTypeInfo.STRING_TYPE_INFO);
+
+		CancelLockingSource.reset();
+		testHarness
+			.setupOperatorChain(
+				new OperatorID(),
+				new StreamSource<>(new CancelLockingSource(throwInCancel)))
+			.chain(
+				new OperatorID(),
+				new TestBoundedOneInputStreamOperator("Operator1"),
+				BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))
+			.finish();
+
+		StreamConfig streamConfig = testHarness.getStreamConfig();
+		streamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);
+
+		testHarness.invoke();
+		CancelLockingSource.awaitRunning();
+		if (withPendingMail) {
+			// This pending mail should be blocked on checkpointLock acquisition, blocking the
+			// mailbox (task) thread.
+			testHarness.getTask().getMailboxExecutorFactory().createExecutor(0).execute(
+				() -> assertFalse(
+					"This should never execute before task cancelation",
+					testHarness.getTask().isRunning()),
+				"Test");
+		}
+
+		try {
+			testHarness.getTask().cancel();
+		}
+		catch (ExpectedTestException e) {
+			checkState(throwInCancel);
+		}
+
+		try {
+			testHarness.waitForTaskCompletion();
+		} catch (Throwable t) {
+			if (!ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {
+				throw t;
+			}
+		}
+	}
+
+	/**
+	 * A source that locks if cancellation attempts to cleanly shut down.
+	 */
+	public static class CancelLockingSource implements SourceFunction<String> {
+		private static final long serialVersionUID = 8713065281092996042L;
+
+		private static CompletableFuture<Void> isRunning = new CompletableFuture<>();
+
+		private final boolean throwOnCancel;
+
+		private volatile boolean cancelled = false;
+
+		public CancelLockingSource(boolean throwOnCancel) {
+			this.throwOnCancel = throwOnCancel;
+		}
+
+		public static void reset() {
+			isRunning = new CompletableFuture<>();
+		}
+
+		public static void awaitRunning() throws ExecutionException, InterruptedException {
+			isRunning.get();
+		}
+
+		@Override
+		public void run(SourceContext<String> ctx) throws Exception {
+			synchronized (ctx.getCheckpointLock()) {
+				while (!cancelled) {
+					isRunning.complete(null);
+
+					if (throwOnCancel) {
+						Thread.sleep(1000000000);
+					}
+					else {
+						try {
+							//noinspection SleepWhileHoldingLock
+							Thread.sleep(1000000000);
+						} catch (InterruptedException ignored) {
+						}
+					}
+				}
+			}
+		}
+
+		@Override
+		public void cancel() {
+			if (throwOnCancel) {
+				throw new ExpectedTestException();
+			}
+			cancelled = true;
+		}
+	}
+
+	@Test
+	public void testInterruptedNotSwallowed() throws Exception {
+		final StreamTaskTestHarness<String> testHarness = new StreamTaskTestHarness<>(
+			SourceStreamTask::new,
+			BasicTypeInfo.STRING_TYPE_INFO);
+
+		CancelLockingSource.reset();
+		testHarness
+			.setupOperatorChain(
+				new OperatorID(),
+				new StreamSource<>(new InterruptedSource()))
+			.chain(
+				new OperatorID(),
+				new TestBoundedOneInputStreamOperator("Operator1"),
+				BasicTypeInfo.STRING_TYPE_INFO.createSerializer(new ExecutionConfig()))
+			.finish();
+
+		StreamConfig streamConfig = testHarness.getStreamConfig();
+		streamConfig.setTimeCharacteristic(TimeCharacteristic.ProcessingTime);
+
+		testHarness.invoke();
+		try {
+			testHarness.waitForTaskCompletion();
+		} catch (Exception e) {
+			if (!(e.getCause() instanceof InterruptedException)) {
+				throw e;
+			}
+		}
+	}
+
+	/**
+	 * A source that locks if cancellation attempts to cleanly shut down.
+	 */
+	public static class InterruptedSource implements SourceFunction<String> {
+		private static final long serialVersionUID = 8713065281092996042L;
+
+		private static CompletableFuture<Void> isRunning = new CompletableFuture<>();
+
+		public static void reset() {
+			isRunning = new CompletableFuture<>();
+		}
+
+		public static void awaitRunning() throws ExecutionException, InterruptedException {
+			isRunning.get();
+		}
+
+		@Override
+		public void run(SourceContext<String> ctx) throws Exception {
+			synchronized (ctx.getCheckpointLock()) {
+				isRunning.complete(null);
+				Thread.currentThread().interrupt();
+				throw new InterruptedException();
+			}
+		}
+
+		@Override
+		public void cancel() {
+		}
+	}
+
 	/**
 	 * If finishing a task doesn't swallow exceptions this test would fail with an exception.
 	 */
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index 1e64718cdb5..7719259b6c3 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -314,26 +314,6 @@ public class StreamTaskTest extends TestLogger {
 		assertEquals(ExecutionState.FAILED, task.getExecutionState());
 	}
 
-	@Test
-	public void testCancellationNotBlockedOnLock() throws Exception {
-		syncLatch = new OneShotLatch();
-
-		StreamConfig cfg = new StreamConfig(new Configuration());
-		Task task = createTask(CancelLockingTask.class, cfg, new Configuration());
-
-		// start the task and wait until it runs
-		// execution state RUNNING is not enough, we need to wait until the stream task's run() method
-		// is entered
-		task.startTaskThread();
-		syncLatch.await();
-
-		// cancel the execution - this should lead to smooth shutdown
-		task.cancelExecution();
-		task.getExecutingThread().join();
-
-		assertEquals(ExecutionState.CANCELED, task.getExecutionState());
-	}
-
 	@Test
 	public void testCancellationFailsWithBlockingLock() throws Exception {
 		syncLatch = new OneShotLatch();
@@ -1380,55 +1360,6 @@ public class StreamTaskTest extends TestLogger {
 		}
 	}
 
-	/**
-	 * A task that locks if cancellation attempts to cleanly shut down.
-	 */
-	public static class CancelLockingTask extends StreamTask<String, AbstractStreamOperator<String>> {
-
-		private final OneShotLatch latch = new OneShotLatch();
-
-		private LockHolder holder;
-
-		public CancelLockingTask(Environment env) {
-			super(env);
-		}
-
-		@Override
-		protected void init() {}
-
-		@Override
-		protected void processInput(MailboxDefaultAction.Controller controller) throws Exception {
-			holder = new LockHolder(getCheckpointLock(), latch);
-			holder.start();
-			latch.await();
-
-			// we are at the point where cancelling can happen
-			syncLatch.trigger();
-
-			// just put this to sleep until it is interrupted
-			try {
-				Thread.sleep(100000000);
-			} catch (InterruptedException ignored) {
-				// restore interruption state
-				Thread.currentThread().interrupt();
-			}
-			controller.allActionsCompleted();
-		}
-
-		@Override
-		protected void cleanup() {
-			holder.close();
-		}
-
-		@Override
-		protected void cancelTask() {
-			holder.cancel();
-			// do not interrupt the lock holder here, to simulate spawned threads that
-			// we cannot properly interrupt on cancellation
-		}
-
-	}
-
 	/**
 	 * A task that locks if cancellation attempts to cleanly shut down.
 	 */
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxExecutorImplTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxExecutorImplTest.java
index a63b1023bee..efd70d92b6c 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxExecutorImplTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/MailboxExecutorImplTest.java
@@ -37,7 +37,6 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -152,18 +151,6 @@ public class MailboxExecutorImplTest {
 		Assert.assertEquals(Thread.currentThread(), testRunnable.wasExecutedBy());
 	}
 
-	@Test
-	public void testPrettyExceptionMessage() {
-		final String description = "Pretty command description";
-		mailboxExecutor.execute(
-			() -> {
-				throw new RuntimeException("Some random exception");
-			},
-			description);
-		expectedException.expectMessage(containsString(description));
-		mailboxExecutor.tryYield();
-	}
-
 	/**
 	 * Test {@link Runnable} that tracks execution.
 	 */
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/TaskMailboxProcessorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/TaskMailboxProcessorTest.java
index ec14705d060..9740907629a 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/TaskMailboxProcessorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/mailbox/TaskMailboxProcessorTest.java
@@ -33,9 +33,6 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import static org.hamcrest.CoreMatchers.containsString;
-import static org.junit.internal.matchers.ThrowableMessageMatcher.hasMessage;
-
 /**
  * Unit tests for {@link MailboxProcessor}.
  */
@@ -59,7 +56,7 @@ public class TaskMailboxProcessorTest {
 
 	@Test
 	public void testSubmittingRunnableWithException() throws Exception {
-		expectedException.expectCause(hasMessage(containsString("Expected")));
+		expectedException.expectMessage("Expected");
 		try (MailboxProcessor mailboxProcessor = new MailboxProcessor(controller -> {})) {
 			final Thread submitThread = new Thread(() -> {
 				mailboxProcessor.getMainMailboxExecutor().execute(
