diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferListener.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferListener.java
index dd3a5992917..6862025fe39 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferListener.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferListener.java
@@ -26,16 +26,13 @@ public interface BufferListener {
 
     /** Status of the notification result from the buffer listener. */
     enum NotificationResult {
-        BUFFER_NOT_USED(false, false),
-        BUFFER_USED_NO_NEED_MORE(true, false),
-        BUFFER_USED_NEED_MORE(true, true);
+        BUFFER_NOT_USED(false),
+        BUFFER_USED(true);
 
         private final boolean isBufferUsed;
-        private final boolean needsMoreBuffers;
 
-        NotificationResult(boolean isBufferUsed, boolean needsMoreBuffers) {
+        NotificationResult(boolean isBufferUsed) {
             this.isBufferUsed = isBufferUsed;
-            this.needsMoreBuffers = needsMoreBuffers;
         }
 
         /**
@@ -46,22 +43,14 @@ public interface BufferListener {
         boolean isBufferUsed() {
             return isBufferUsed;
         }
-
-        /**
-         * Whether the listener still needs more buffers to be notified.
-         *
-         * @return <tt>true</tt> if the listener is still waiting for more buffers.
-         */
-        boolean needsMoreBuffers() {
-            return needsMoreBuffers;
-        }
     }
 
     /**
      * Notification callback if a buffer is recycled and becomes available in buffer pool.
      *
-     * <p>Note: responsibility on recycling the given buffer is transferred to this implementation,
-     * including any errors that lead to exceptions being thrown!
+     * <p>Note: 1) Responsibility on recycling the given buffer is transferred to this
+     * implementation, including any errors that lead to exceptions being thrown! 2) The listener
+     * must register itself again if it needs still need more buffers.
      *
      * <p><strong>BEWARE:</strong> since this may be called from outside the thread that relies on
      * the listener's logic, any exception that occurs with this handler should be forwarded to the
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
index 7a5eb40956e..e86a090413a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPool.java
@@ -468,8 +468,7 @@ class LocalBufferPool implements BufferPool {
     private void recycle(MemorySegment segment, int channel) {
         BufferListener listener;
         CompletableFuture<?> toNotify = null;
-        NotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED;
-        while (!notificationResult.isBufferUsed()) {
+        do {
             synchronized (availableMemorySegments) {
                 if (channel != UNKNOWN_CHANNEL) {
                     if (subpartitionBuffersCount[channel]-- == maxBuffersPerChannel) {
@@ -496,8 +495,7 @@ class LocalBufferPool implements BufferPool {
 
                 checkConsistentAvailability();
             }
-            notificationResult = fireBufferAvailableNotification(listener, segment);
-        }
+        } while (!fireBufferAvailableNotification(listener, segment).isBufferUsed());
 
         mayNotifyAvailable(toNotify);
     }
@@ -508,20 +506,7 @@ class LocalBufferPool implements BufferPool {
         // notification and which other threads also access them.
         // -> call notifyBufferAvailable() outside of the synchronized block to avoid a deadlock
         // (FLINK-9676)
-        NotificationResult notificationResult =
-                listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
-        if (notificationResult.needsMoreBuffers()) {
-            synchronized (availableMemorySegments) {
-                if (isDestroyed) {
-                    // cleanup tasks how they would have been done if we only had one synchronized
-                    // block
-                    listener.notifyBufferDestroyed();
-                } else {
-                    registeredListeners.add(listener);
-                }
-            }
-        }
-        return notificationResult;
+        return listener.notifyBufferAvailable(new NetworkBuffer(segment, this));
     }
 
     /** Destroy is called after the produce or consume phase of a task finishes. */
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java
index 8d8e7745230..7b908cdf2a1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java
@@ -171,18 +171,25 @@ public class BufferManager implements BufferListener, BufferRecycler {
             }
 
             numRequiredBuffers = numRequired;
+            numRequestedBuffers = tryRequestBuffers();
+        }
+        return numRequestedBuffers;
+    }
 
-            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers
-                    && !isWaitingForFloatingBuffers) {
-                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();
-                Buffer buffer = bufferPool.requestBuffer();
-                if (buffer != null) {
-                    bufferQueue.addFloatingBuffer(buffer);
-                    numRequestedBuffers++;
-                } else if (bufferPool.addBufferListener(this)) {
-                    isWaitingForFloatingBuffers = true;
-                    break;
-                }
+    private int tryRequestBuffers() {
+        assert Thread.holdsLock(bufferQueue);
+
+        int numRequestedBuffers = 0;
+        while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers
+                && !isWaitingForFloatingBuffers) {
+            BufferPool bufferPool = inputChannel.inputGate.getBufferPool();
+            Buffer buffer = bufferPool.requestBuffer();
+            if (buffer != null) {
+                bufferQueue.addFloatingBuffer(buffer);
+                numRequestedBuffers++;
+            } else if (bufferPool.addBufferListener(this)) {
+                isWaitingForFloatingBuffers = true;
+                break;
             }
         }
         return numRequestedBuffers;
@@ -315,11 +322,13 @@ public class BufferManager implements BufferListener, BufferRecycler {
             return notificationResult;
         }
 
+        int numBuffers = 0;
         try {
             synchronized (bufferQueue) {
                 checkState(
                         isWaitingForFloatingBuffers,
                         "This channel should be waiting for floating buffers.");
+                isWaitingForFloatingBuffers = false;
 
                 // Important: make sure that we never add a buffer after releaseAllResources()
                 // released all buffers. Following scenarios exist:
@@ -330,22 +339,16 @@ public class BufferManager implements BufferListener, BufferRecycler {
                 // lock on bufferQueue to release buffers
                 if (inputChannel.isReleased()
                         || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {
-                    isWaitingForFloatingBuffers = false;
                     return notificationResult;
                 }
 
                 bufferQueue.addFloatingBuffer(buffer);
+                notificationResult = NotificationResult.BUFFER_USED;
+                numBuffers += 1 + tryRequestBuffers();
                 bufferQueue.notifyAll();
-
-                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {
-                    isWaitingForFloatingBuffers = false;
-                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;
-                } else {
-                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;
-                }
             }
 
-            inputChannel.notifyBufferAvailable(1);
+            inputChannel.notifyBufferAvailable(numBuffers);
         } catch (Throwable t) {
             inputChannel.setError(t);
         }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
index f72d7f87843..bdc6bbe9194 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/LocalBufferPoolTest.java
@@ -54,10 +54,8 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.powermock.api.mockito.PowerMockito.spy;
 
 /** Tests for the {@link LocalBufferPool}. */
 public class LocalBufferPoolTest extends TestLogger {
@@ -237,32 +235,24 @@ public class LocalBufferPoolTest extends TestLogger {
 
     @Test
     public void testPendingRequestWithListenersAfterRecycle() {
-        BufferListener twoTimesListener = createBufferListener(2);
-        BufferListener oneTimeListener = createBufferListener(1);
+        CountBufferListener listener1 = new CountBufferListener();
+        CountBufferListener listener2 = new CountBufferListener();
 
-        localBufferPool.setNumBuffers(2);
-
-        Buffer available1 = localBufferPool.requestBuffer();
-        Buffer available2 = localBufferPool.requestBuffer();
+        Buffer available = localBufferPool.requestBuffer();
 
         assertNull(localBufferPool.requestBuffer());
 
-        assertTrue(localBufferPool.addBufferListener(twoTimesListener));
-        assertTrue(localBufferPool.addBufferListener(oneTimeListener));
-
-        // Recycle the first buffer to notify both of the above listeners once
-        // and the twoTimesListener will be added into the registeredListeners
-        // queue of buffer pool again
-        available1.recycleBuffer();
+        assertTrue(localBufferPool.addBufferListener(listener1));
+        assertTrue(localBufferPool.addBufferListener(listener2));
 
-        verify(oneTimeListener, times(1)).notifyBufferAvailable(any(Buffer.class));
-        verify(twoTimesListener, times(1)).notifyBufferAvailable(any(Buffer.class));
+        // Recycle the buffer to notify both of the above listeners once
+        checkNotNull(available).recycleBuffer();
 
-        // Recycle the second buffer to only notify the twoTimesListener
-        available2.recycleBuffer();
+        assertEquals(1, listener1.getCount());
+        assertEquals(1, listener1.getCount());
 
-        verify(oneTimeListener, times(1)).notifyBufferAvailable(any(Buffer.class));
-        verify(twoTimesListener, times(2)).notifyBufferAvailable(any(Buffer.class));
+        assertFalse(localBufferPool.addBufferListener(listener1));
+        assertFalse(localBufferPool.addBufferListener(listener2));
     }
 
     @Test
@@ -542,25 +532,23 @@ public class LocalBufferPoolTest extends TestLogger {
                 - networkBufferPool.getNumberOfAvailableMemorySegments();
     }
 
-    private BufferListener createBufferListener(int notificationTimes) {
-        return spy(
-                new BufferListener() {
-                    AtomicInteger times = new AtomicInteger(0);
+    private static class CountBufferListener implements BufferListener {
 
-                    @Override
-                    public NotificationResult notifyBufferAvailable(Buffer buffer) {
-                        int newCount = times.incrementAndGet();
-                        buffer.recycleBuffer();
-                        if (newCount < notificationTimes) {
-                            return NotificationResult.BUFFER_USED_NEED_MORE;
-                        } else {
-                            return NotificationResult.BUFFER_USED_NO_NEED_MORE;
-                        }
-                    }
+        private final AtomicInteger times = new AtomicInteger(0);
 
-                    @Override
-                    public void notifyBufferDestroyed() {}
-                });
+        @Override
+        public NotificationResult notifyBufferAvailable(Buffer buffer) {
+            times.incrementAndGet();
+            buffer.recycleBuffer();
+            return NotificationResult.BUFFER_USED;
+        }
+
+        @Override
+        public void notifyBufferDestroyed() {}
+
+        int getCount() {
+            return times.get();
+        }
     }
 
     private static class BufferRequesterTask implements Callable<Boolean> {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java
index ff20ebbb3f4..12c78c2a31b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java
@@ -584,8 +584,8 @@ public class RemoteInputChannelTest {
 
             // Assign the floating buffer to the listener and the channel is still waiting for more
             // floating buffers
-            verify(bufferPool, times(15)).requestBuffer();
-            verify(bufferPool, times(1)).addBufferListener(inputChannel.getBufferManager());
+            verify(bufferPool, times(16)).requestBuffer();
+            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());
             assertEquals(
                     "There should be 15 buffers available in the channel",
                     15,
@@ -604,8 +604,8 @@ public class RemoteInputChannelTest {
             inputChannel.onSenderBacklog(13);
 
             // Only the number of required buffers is changed by (backlog + numExclusiveBuffers)
-            verify(bufferPool, times(15)).requestBuffer();
-            verify(bufferPool, times(1)).addBufferListener(inputChannel.getBufferManager());
+            verify(bufferPool, times(16)).requestBuffer();
+            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());
             assertEquals(
                     "There should be 15 buffers available in the channel",
                     15,
@@ -625,8 +625,8 @@ public class RemoteInputChannelTest {
 
             // Return the floating buffer to the buffer pool and the channel is not waiting for more
             // floating buffers
-            verify(bufferPool, times(15)).requestBuffer();
-            verify(bufferPool, times(1)).addBufferListener(inputChannel.getBufferManager());
+            verify(bufferPool, times(16)).requestBuffer();
+            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());
             assertEquals(
                     "There should be 15 buffers available in the channel",
                     15,
@@ -646,8 +646,8 @@ public class RemoteInputChannelTest {
 
             // The floating buffer is requested from the buffer pool and the channel is registered
             // as listener again.
-            verify(bufferPool, times(17)).requestBuffer();
-            verify(bufferPool, times(2)).addBufferListener(inputChannel.getBufferManager());
+            verify(bufferPool, times(18)).requestBuffer();
+            verify(bufferPool, times(3)).addBufferListener(inputChannel.getBufferManager());
             assertEquals(
                     "There should be 16 buffers available in the channel",
                     16,
