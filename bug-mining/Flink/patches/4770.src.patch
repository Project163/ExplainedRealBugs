diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtil.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtil.java
index a153163d187..ef241ae0bb7 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtil.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtil.java
@@ -47,12 +47,6 @@ public final class PipelinedRegionComputeUtil {
 	public static <V extends Vertex<?, ?, V, R>, R extends Result<?, ?, V, R>> Set<Set<V>> computePipelinedRegions(
 			final BaseTopology<?, ?, V, R> topology) {
 
-		// currently we let a job with co-location constraints fail as one region
-		// putting co-located vertices in the same region with each other can be a future improvement
-		if (topology.containsCoLocationConstraints()) {
-			return Collections.singleton(buildOneRegionForAllVertices(topology));
-		}
-
 		final Map<V, Set<V>> vertexToRegion = buildRawRegions(topology);
 
 		return mergeRegionsOnCycles(vertexToRegion);
@@ -117,19 +111,6 @@ public final class PipelinedRegionComputeUtil {
 		return largerSet;
 	}
 
-	private static <V extends Vertex<?, ?, V, ?>> Set<V> buildOneRegionForAllVertices(
-			final BaseTopology<?, ?, V, ?> topology) {
-
-		LOG.warn("Cannot decompose the topology into individual failover regions due to use of " +
-			"Co-Location constraints (iterations). Job will fail over as one holistic unit.");
-
-		final Set<V> allVertices = Collections.newSetFromMap(new IdentityHashMap<>());
-		for (V vertex : topology.getVertices()) {
-			allVertices.add(vertex);
-		}
-		return allVertices;
-	}
-
 	private static <V extends Vertex<?, ?, V, ?>> Set<Set<V>> uniqueRegions(final Map<V, Set<V>> vertexToRegion) {
 		final Set<Set<V>> distinctRegions = Collections.newSetFromMap(new IdentityHashMap<>());
 		distinctRegions.addAll(vertexToRegion.values());
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java
index 36946fe9b9f..f4a80aee3b6 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopology.java
@@ -25,6 +25,7 @@ import org.apache.flink.runtime.executiongraph.ExecutionVertex;
 import org.apache.flink.runtime.executiongraph.IntermediateResultPartition;
 import org.apache.flink.runtime.executiongraph.failover.flip1.PipelinedRegionComputeUtil;
 import org.apache.flink.runtime.jobgraph.IntermediateResultPartitionID;
+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraint;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
 import org.apache.flink.runtime.scheduler.strategy.ResultPartitionState;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;
@@ -38,12 +39,14 @@ import javax.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
+import static org.apache.flink.util.Preconditions.checkState;
 
 /**
  * Adapter of {@link ExecutionGraph} to {@link SchedulingTopology}.
@@ -204,6 +207,7 @@ public class DefaultExecutionTopology implements SchedulingTopology {
 
 		final List<DefaultSchedulingPipelinedRegion> pipelinedRegions = generatePipelinedRegions(topology);
 		topology.setPipelinedRegions(pipelinedRegions);
+		ensureCoLocatedVerticesInSameRegion(pipelinedRegions, executionGraph);
 
 		return topology;
 	}
@@ -227,4 +231,38 @@ public class DefaultExecutionTopology implements SchedulingTopology {
 
 		return pipelinedRegions;
 	}
+
+	/**
+	 * Co-location constraints are only used for iteration head and tail.
+	 * A paired head and tail needs to be in the same pipelined region so
+	 * that they can be restarted together.
+	 */
+	private static void ensureCoLocatedVerticesInSameRegion(
+			List<DefaultSchedulingPipelinedRegion> pipelinedRegions,
+			ExecutionGraph executionGraph) {
+
+		final Map<CoLocationConstraint, DefaultSchedulingPipelinedRegion> constraintToRegion = new IdentityHashMap<>();
+		for (DefaultSchedulingPipelinedRegion region : pipelinedRegions) {
+			for (DefaultExecutionVertex vertex : region.getVertices()) {
+				final CoLocationConstraint constraint = getCoLocationConstraint(vertex.getId(), executionGraph);
+				if (constraint != null) {
+					final DefaultSchedulingPipelinedRegion regionOfConstraint = constraintToRegion.get(constraint);
+					checkState(
+						regionOfConstraint == null || regionOfConstraint == region,
+						"co-located tasks must be in the same pipelined region");
+					constraintToRegion.putIfAbsent(constraint, region);
+				}
+			}
+		}
+	}
+
+	private static CoLocationConstraint getCoLocationConstraint(
+			ExecutionVertexID executionVertexId,
+			ExecutionGraph executionGraph) {
+
+		return executionGraph
+			.getJobVertex(executionVertexId.getJobVertexId())
+			.getTaskVertices()[executionVertexId.getSubtaskIndex()]
+			.getLocationConstraint();
+	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphCoLocationRestartTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphCoLocationRestartTest.java
index e32f258b229..bfbcca6a4f8 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphCoLocationRestartTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphCoLocationRestartTest.java
@@ -22,8 +22,11 @@ import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;
 import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;
 import org.apache.flink.runtime.execution.ExecutionState;
+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
+import org.apache.flink.runtime.jobgraph.DistributionPattern;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobgraph.ScheduleMode;
 import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraint;
 import org.apache.flink.runtime.jobmanager.scheduler.SchedulerTestBase;
 import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;
@@ -63,6 +66,7 @@ public class ExecutionGraphCoLocationRestartTest extends SchedulerTestBase {
 
 		JobVertex groupVertex = ExecutionGraphTestUtils.createNoOpVertex(NUM_TASKS);
 		JobVertex groupVertex2 = ExecutionGraphTestUtils.createNoOpVertex(NUM_TASKS);
+		groupVertex2.connectNewDataSetAsInput(groupVertex, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
 
 		SlotSharingGroup sharingGroup = new SlotSharingGroup();
 		groupVertex.setSlotSharingGroup(sharingGroup);
@@ -70,9 +74,11 @@ public class ExecutionGraphCoLocationRestartTest extends SchedulerTestBase {
 		groupVertex.setStrictlyCoLocatedWith(groupVertex2);
 
 		//initiate and schedule job
+		final JobGraph jobGraph = new JobGraph(groupVertex, groupVertex2);
+		jobGraph.setScheduleMode(ScheduleMode.EAGER);
 		final ExecutionGraph eg = TestingExecutionGraphBuilder
 			.newBuilder()
-			.setJobGraph(new JobGraph(groupVertex, groupVertex2))
+			.setJobGraph(jobGraph)
 			.setSlotProvider(testingSlotProvider)
 			.setRestartStrategy(new TestRestartStrategy(1, false))
 			.build();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphConstructionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphConstructionTest.java
index b8d24d8bc4b..2ea52fc5c3c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphConstructionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphConstructionTest.java
@@ -461,7 +461,7 @@ public class ExecutionGraphConstructionTest {
 			// simple group of two, cyclic
 			JobVertex v1 = new JobVertex("vertex1");
 			JobVertex v2 = new JobVertex("vertex2");
-			v1.setParallelism(6);
+			v1.setParallelism(4);
 			v2.setParallelism(4);
 			v1.setInvokableClass(AbstractInvokable.class);
 			v2.setInvokableClass(AbstractInvokable.class);
@@ -469,8 +469,10 @@ public class ExecutionGraphConstructionTest {
 			SlotSharingGroup sl1 = new SlotSharingGroup();
 			v1.setSlotSharingGroup(sl1);
 			v2.setSlotSharingGroup(sl1);
-			v2.setStrictlyCoLocatedWith(v1);
+
 			v1.setStrictlyCoLocatedWith(v2);
+			v2.setStrictlyCoLocatedWith(v1);
+			v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
 			
 			// complex forked dependency pattern
 			JobVertex v3 = new JobVertex("vertex3");
@@ -498,9 +500,16 @@ public class ExecutionGraphConstructionTest {
 			v7.setSlotSharingGroup(sl2);
 			
 			v4.setStrictlyCoLocatedWith(v3);
+			v4.connectNewDataSetAsInput(v3, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
+
 			v5.setStrictlyCoLocatedWith(v4);
+			v5.connectNewDataSetAsInput(v4, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
+
 			v6.setStrictlyCoLocatedWith(v3);
+			v6.connectNewDataSetAsInput(v3, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
+
 			v3.setStrictlyCoLocatedWith(v7);
+			v3.connectNewDataSetAsInput(v7, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED);
 			
 			// isolated vertex
 			JobVertex v8 = new JobVertex("vertex8");
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtilTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtilTest.java
index 677309cbfdc..d3c7baa30fd 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtilTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/failover/flip1/PipelinedRegionComputeUtilTest.java
@@ -432,82 +432,6 @@ public class PipelinedRegionComputeUtilTest extends TestLogger {
 		assertSameRegion(r1, r2, r3, r4);
 	}
 
-	/**
-	 * This test checks that are strictly co-located vertices are in the same failover region,
-	 * even through they are only connected via a blocking pattern.
-	 * This is currently an assumption / limitation of the scheduler.
-	 * <pre>
-	 *     (a1) -+-> (b1)
-	 *           X
-	 *     (a2) -+-> (b2)
-	 *
-	 *           ^
-	 *           |
-	 *       (blocking)
-	 * </pre>
-	 */
-	@Test
-	public void testBlockingAllToAllTopologyWithCoLocation() {
-		TestingSchedulingTopology topology = new TestingSchedulingTopology();
-
-		TestingSchedulingExecutionVertex va1 = topology.newExecutionVertex();
-		TestingSchedulingExecutionVertex va2 = topology.newExecutionVertex();
-		TestingSchedulingExecutionVertex vb1 = topology.newExecutionVertex();
-		TestingSchedulingExecutionVertex vb2 = topology.newExecutionVertex();
-
-		topology
-			.connect(va1, vb1, ResultPartitionType.BLOCKING)
-			.connect(va1, vb2, ResultPartitionType.BLOCKING)
-			.connect(va2, vb1, ResultPartitionType.BLOCKING)
-			.connect(va2, vb2, ResultPartitionType.BLOCKING);
-
-		topology.setContainsCoLocationConstraints(true);
-
-		Map<ExecutionVertexID, Set<SchedulingExecutionVertex>> pipelinedRegionByVertex = computePipelinedRegionByVertex(topology);
-
-		Set<SchedulingExecutionVertex> ra1 = pipelinedRegionByVertex.get(va1.getId());
-		Set<SchedulingExecutionVertex> ra2 = pipelinedRegionByVertex.get(va2.getId());
-		Set<SchedulingExecutionVertex> rb1 = pipelinedRegionByVertex.get(vb1.getId());
-		Set<SchedulingExecutionVertex> rb2 = pipelinedRegionByVertex.get(vb2.getId());
-
-		assertSameRegion(ra1, ra2, rb1, rb2);
-	}
-
-	/**
-	 * This test checks that are strictly co-located vertices are in the same failover region,
-	 * even through they are not connected.
-	 * This is currently an assumption / limitation of the scheduler.
-	 * <pre>
-	 *     (a1) -+-> (b1)
-	 *
-	 *     (a2) -+-> (b2)
-	 * </pre>
-	 */
-	@Test
-	public void testPipelinedOneToOneTopologyWithCoLocation() {
-		TestingSchedulingTopology topology = new TestingSchedulingTopology();
-
-		TestingSchedulingExecutionVertex va1 = topology.newExecutionVertex();
-		TestingSchedulingExecutionVertex va2 = topology.newExecutionVertex();
-		TestingSchedulingExecutionVertex vb1 = topology.newExecutionVertex();
-		TestingSchedulingExecutionVertex vb2 = topology.newExecutionVertex();
-
-		topology
-			.connect(va1, vb1, ResultPartitionType.PIPELINED)
-			.connect(va2, vb2, ResultPartitionType.PIPELINED);
-
-		topology.setContainsCoLocationConstraints(true);
-
-		Map<ExecutionVertexID, Set<SchedulingExecutionVertex>> pipelinedRegionByVertex = computePipelinedRegionByVertex(topology);
-
-		Set<SchedulingExecutionVertex> ra1 = pipelinedRegionByVertex.get(va1.getId());
-		Set<SchedulingExecutionVertex> ra2 = pipelinedRegionByVertex.get(va2.getId());
-		Set<SchedulingExecutionVertex> rb1 = pipelinedRegionByVertex.get(vb1.getId());
-		Set<SchedulingExecutionVertex> rb2 = pipelinedRegionByVertex.get(vb2.getId());
-
-		assertSameRegion(ra1, ra2, rb1, rb2);
-	}
-
 	/**
 	 * This test checks that cyclic dependent regions will be merged into one.
 	 * <pre>
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java
index b116887d83d..a980d577e90 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/adapter/DefaultExecutionTopologyTest.java
@@ -170,6 +170,21 @@ public class DefaultExecutionTopologyTest extends TestLogger {
 		}
 	}
 
+	@Test(expected = IllegalStateException.class)
+	public void testErrorIfCoLocatedTasksAreNotInSameRegion() throws Exception {
+		int parallelism = 3;
+		final JobVertex v1 = createNoOpVertex(parallelism);
+		final JobVertex v2 = createNoOpVertex(parallelism);
+
+		SlotSharingGroup slotSharingGroup = new SlotSharingGroup();
+		v1.setSlotSharingGroup(slotSharingGroup);
+		v2.setSlotSharingGroup(slotSharingGroup);
+		v1.setStrictlyCoLocatedWith(v2);
+
+		final ExecutionGraph executionGraph = createSimpleTestGraph(v1, v2);
+		DefaultExecutionTopology.fromExecutionGraph(executionGraph);
+	}
+
 	private void assertRegionContainsAllVertices(final DefaultSchedulingPipelinedRegion pipelinedRegionOfVertex) {
 		final Set<DefaultExecutionVertex> allVertices = Sets.newHashSet(pipelinedRegionOfVertex.getVertices());
 		assertEquals(Sets.newHashSet(adapter.getVertices()), allVertices);
