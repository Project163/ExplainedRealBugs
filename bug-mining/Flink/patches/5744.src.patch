diff --git a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedOneInputStreamTaskRunner.java b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedOneInputStreamTaskRunner.java
index e9e87ac3279..286e46add96 100644
--- a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedOneInputStreamTaskRunner.java
+++ b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedOneInputStreamTaskRunner.java
@@ -25,6 +25,7 @@ import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
 import org.apache.flink.state.api.functions.Timestamper;
 import org.apache.flink.state.api.runtime.SavepointEnvironment;
 import org.apache.flink.streaming.api.graph.StreamConfig;
+import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.util.Collector;
 
 /**
@@ -77,6 +78,15 @@ public class BoundedOneInputStreamTaskRunner<IN>
     @Override
     public void mapPartition(Iterable<IN> values, Collector<TaggedOperatorSubtaskState> out)
             throws Exception {
-        new BoundedStreamTask<>(env, values, timestamper, out).invoke();
+        BoundedStreamTask<
+                        IN,
+                        TaggedOperatorSubtaskState,
+                        ? extends OneInputStreamOperator<IN, TaggedOperatorSubtaskState>>
+                boundedStreamTask = new BoundedStreamTask<>(env, values, timestamper, out);
+        try {
+            boundedStreamTask.invoke();
+        } finally {
+            boundedStreamTask.cleanUp(null);
+        }
     }
 }
diff --git a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java
index 83e303d17a6..c7ebd6bbeec 100644
--- a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java
+++ b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java
@@ -116,7 +116,7 @@ class BoundedStreamTask<IN, OUT, OP extends OneInputStreamOperator<IN, OUT> & Bo
     protected void cancelTask() {}
 
     @Override
-    protected void cleanup() throws Exception {
+    protected void cleanUpInternal() throws Exception {
         mainOperator.close();
     }
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
index f05db0775eb..2e132cd3bbd 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
@@ -31,6 +31,8 @@ import org.apache.flink.runtime.operators.coordination.OperatorEvent;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.SerializedValue;
 
+import javax.annotation.Nullable;
+
 import java.io.IOException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Future;
@@ -113,6 +115,17 @@ public abstract class AbstractInvokable {
         return CompletableFuture.completedFuture(null);
     }
 
+    /**
+     * Cleanup any resources used in {@link #invoke()} OR {@link #restore()}. This method must be
+     * called regardless whether the aforementioned calls succeeded or failed.
+     *
+     * @param throwable iff failure happened during the execution of {@link #restore()} or {@link
+     *     #invoke()}, null otherwise.
+     *     <p>ATTENTION: {@link org.apache.flink.runtime.execution.CancelTaskException
+     *     CancelTaskException} should not be treated as a failure, null must be passed instead.
+     */
+    public void cleanUp(@Nullable Throwable throwable) throws Exception {}
+
     /**
      * Sets whether the thread that executes the {@link #invoke()} method should be interrupted
      * during cancellation. This method sets the flag for both the initial interrupt, as well as for
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
index bdb20e286cc..551e246b83f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
@@ -761,18 +761,7 @@ public class Task
             // make sure the user code classloader is accessible thread-locally
             executingThread.setContextClassLoader(userCodeClassLoader.asClassLoader());
 
-            AbstractInvokable finalInvokable = invokable;
-            runWithSystemExitMonitoring(finalInvokable::restore);
-
-            if (!transitionState(ExecutionState.INITIALIZING, ExecutionState.RUNNING)) {
-                throw new CancelTaskException();
-            }
-
-            // notify everyone that we switched to running
-            taskManagerActions.updateTaskExecutionState(
-                    new TaskExecutionState(executionId, ExecutionState.RUNNING));
-
-            runWithSystemExitMonitoring(finalInvokable::invoke);
+            restoreAndInvoke(invokable);
 
             // make sure, we enter the catch block if the task leaves the invoke() method due
             // to the fact that it has been canceled
@@ -931,6 +920,30 @@ public class Task
         }
     }
 
+    private void restoreAndInvoke(AbstractInvokable finalInvokable) throws Exception {
+        try {
+            runWithSystemExitMonitoring(finalInvokable::restore);
+
+            if (!transitionState(ExecutionState.INITIALIZING, ExecutionState.RUNNING)) {
+                throw new CancelTaskException();
+            }
+
+            // notify everyone that we switched to running
+            taskManagerActions.updateTaskExecutionState(
+                    new TaskExecutionState(executionId, ExecutionState.RUNNING));
+
+            runWithSystemExitMonitoring(finalInvokable::invoke);
+        } catch (Throwable throwable) {
+            try {
+                runWithSystemExitMonitoring(() -> finalInvokable.cleanUp(throwable));
+            } catch (Throwable cleanUpThrowable) {
+                throwable.addSuppressed(cleanUpThrowable);
+            }
+            throw throwable;
+        }
+        runWithSystemExitMonitoring(() -> finalInvokable.cleanUp(null));
+    }
+
     /**
      * Monitor user codes from exiting JVM covering user function invocation. This can be done in a
      * finer-grained way like enclosing user callback functions individually, but as exit triggered
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java
index 70b218b629a..92dcd164a08 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java
@@ -106,12 +106,15 @@ public class TaskTest extends TestLogger {
 
     @ClassRule public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();
 
+    private static boolean wasCleanedUp = false;
+
     @Before
     public void setup() {
         awaitLatch = new OneShotLatch();
         triggerLatch = new OneShotLatch();
 
         shuffleEnvironment = new NettyShuffleEnvironmentBuilder().build();
+        wasCleanedUp = false;
     }
 
     @After
@@ -121,6 +124,34 @@ public class TaskTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testCleanupWhenRestoreFails() throws Exception {
+        createTaskBuilder().setInvokable(InvokableWithExceptionInRestore.class).build().run();
+        assertTrue(wasCleanedUp);
+    }
+
+    @Test
+    public void testCleanupWhenInvokeFails() throws Exception {
+        createTaskBuilder().setInvokable(InvokableWithExceptionInInvoke.class).build().run();
+        assertTrue(wasCleanedUp);
+    }
+
+    @Test
+    public void testCleanupWhenCancelledAfterRestore() throws Exception {
+        Task task = createTaskBuilder().setInvokable(InvokableBlockingInRestore.class).build();
+        task.startTaskThread();
+        awaitLatch.await();
+        task.cancelExecution();
+        task.getExecutingThread().join();
+        assertTrue(wasCleanedUp);
+    }
+
+    @Test
+    public void testCleanupWhenAfterInvokeSucceeded() throws Exception {
+        createTaskBuilder().setInvokable(TestInvokableCorrect.class).build().run();
+        assertTrue(wasCleanedUp);
+    }
+
     @Test
     public void testRegularExecution() throws Exception {
         final QueuedNoOpTaskManagerActions taskManagerActions = new QueuedNoOpTaskManagerActions();
@@ -1221,6 +1252,12 @@ public class TaskTest extends TestLogger {
             fail("This should not be called");
             return null;
         }
+
+        @Override
+        public void cleanUp(Throwable throwable) throws Exception {
+            wasCleanedUp = true;
+            super.cleanUp(throwable);
+        }
     }
 
     private abstract static class InvokableNonInstantiable extends AbstractInvokable {
@@ -1238,6 +1275,12 @@ public class TaskTest extends TestLogger {
         public void invoke() throws Exception {
             throw new Exception("test");
         }
+
+        @Override
+        public void cleanUp(Throwable throwable) throws Exception {
+            wasCleanedUp = true;
+            super.cleanUp(throwable);
+        }
     }
 
     static final class InvokableWithExceptionInRestore extends AbstractInvokable {
@@ -1252,6 +1295,12 @@ public class TaskTest extends TestLogger {
 
         @Override
         public void invoke() throws Exception {}
+
+        @Override
+        public void cleanUp(Throwable throwable) throws Exception {
+            wasCleanedUp = true;
+            super.cleanUp(throwable);
+        }
     }
 
     private static final class FailingInvokableWithChainedException extends AbstractInvokable {
@@ -1349,6 +1398,12 @@ public class TaskTest extends TestLogger {
 
         @Override
         public void invoke() throws Exception {}
+
+        @Override
+        public void cleanUp(Throwable throwable) throws Exception {
+            wasCleanedUp = true;
+            super.cleanUp(throwable);
+        }
     }
 
     /** {@link AbstractInvokable} which throws {@link RuntimeException} on invoke. */
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
index e0313102ee7..e4908ae3fb9 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java
@@ -167,7 +167,7 @@ public class SourceStreamTask<
     }
 
     @Override
-    protected void cleanup() {
+    protected void cleanUpInternal() {
         // does not hold any resources, so no cleanup needed
     }
 
@@ -196,17 +196,12 @@ public class SourceStreamTask<
                         });
     }
 
-    @Override
-    protected void cleanUpInvoke() throws Exception {
-        if (isFailing()) {
-            interruptSourceThread(true);
-        }
-        super.cleanUpInvoke();
-    }
-
     @Override
     protected void cancelTask() {
         if (stopped.compareAndSet(false, true)) {
+            if (isFailing()) {
+                interruptSourceThread(true);
+            }
             cancelOperator(true);
         }
     }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java
index e8746139cb9..a416a10eb38 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationHead.java
@@ -106,7 +106,7 @@ public class StreamIterationHead<OUT> extends OneInputStreamTask<OUT, OUT> {
     }
 
     @Override
-    protected void cleanup() {
+    protected void cleanUpInternal() {
         // make sure that we remove the queue from the broker, to prevent a resource leak
         BlockingQueueBroker.INSTANCE.remove(brokerID);
         LOG.info("Iteration head {} removed feedback queue under {}", getName(), brokerID);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index 7375c865118..5a97c0e95e5 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -128,7 +128,6 @@ import java.util.concurrent.ThreadFactory;
 
 import static org.apache.flink.configuration.TaskManagerOptions.BUFFER_DEBLOAT_PERIOD;
 import static org.apache.flink.util.ExceptionUtils.firstOrSuppressed;
-import static org.apache.flink.util.ExceptionUtils.rethrowException;
 import static org.apache.flink.util.Preconditions.checkState;
 import static org.apache.flink.util.concurrent.FutureUtils.assertNoException;
 
@@ -471,12 +470,6 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
 
     protected void cancelTask() throws Exception {}
 
-    protected void cleanup() throws Exception {
-        if (inputProcessor != null) {
-            inputProcessor.close();
-        }
-    }
-
     /**
      * This method implements the default action of the task (e.g. processing one event from the
      * input). Implementations should (in general) be non-blocking.
@@ -635,10 +628,10 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
 
     @Override
     public final void restore() throws Exception {
-        runWithCleanUpOnFail(this::executeRestore);
+        restoreInternal();
     }
 
-    void executeRestore() throws Exception {
+    void restoreInternal() throws Exception {
         if (isRunning) {
             LOG.debug("Re-restore attempt rejected.");
             return;
@@ -725,16 +718,10 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
 
     @Override
     public final void invoke() throws Exception {
-        runWithCleanUpOnFail(this::executeInvoke);
-
-        cleanUpInvoke();
-    }
-
-    private void executeInvoke() throws Exception {
         // Allow invoking method 'invoke' without having to call 'restore' before it.
         if (!isRunning) {
             LOG.debug("Restoring during invoke will be called.");
-            executeRestore();
+            restoreInternal();
         }
 
         // final check to exit early before starting to run
@@ -780,29 +767,6 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
         }
     }
 
-    private void runWithCleanUpOnFail(RunnableWithException run) throws Exception {
-        try {
-            run.run();
-        } catch (Throwable invokeException) {
-            failing = !canceled;
-            try {
-                try {
-                    cancelTask();
-                } catch (Throwable ex) {
-                    invokeException = firstOrSuppressed(ex, invokeException);
-                }
-
-                cleanUpInvoke();
-            }
-            // TODO: investigate why Throwable instead of Exception is used here.
-            catch (Throwable cleanUpException) {
-                rethrowException(firstOrSuppressed(cleanUpException, invokeException));
-            }
-
-            rethrowException(invokeException);
-        }
-    }
-
     @VisibleForTesting
     public boolean runMailboxStep() throws Exception {
         return mailboxProcessor.runMailboxStep();
@@ -894,7 +858,18 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
                 && configuration.isCheckpointingEnabled();
     }
 
-    protected void cleanUpInvoke() throws Exception {
+    @Override
+    public final void cleanUp(Throwable throwable) throws Exception {
+        LOG.debug(
+                "Cleanup StreamTask (operators closed: {}, cancelled: {})",
+                closedOperators,
+                canceled);
+
+        failing = !canceled && throwable != null;
+
+        Exception suppressedException =
+                throwable == null ? null : runAndSuppressThrowable(this::cancelTask, null);
+
         getCompletionFuture().exceptionally(unused -> null).join();
         // clean up everything we initialized
         isRunning = false;
@@ -910,8 +885,8 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
         Thread.interrupted();
 
         // stop all timers and threads
-        Exception suppressedException =
-                runAndSuppressThrowable(this::tryShutdownTimerService, null);
+        suppressedException =
+                runAndSuppressThrowable(this::tryShutdownTimerService, suppressedException);
 
         // stop all asynchronous checkpoint threads
         suppressedException = runAndSuppressThrowable(cancelables::close, suppressedException);
@@ -919,7 +894,7 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
                 runAndSuppressThrowable(this::shutdownAsyncThreads, suppressedException);
 
         // we must! perform this cleanup
-        suppressedException = runAndSuppressThrowable(this::cleanup, suppressedException);
+        suppressedException = runAndSuppressThrowable(this::cleanUpInternal, suppressedException);
 
         // if the operators were not closed before, do a hard close
         suppressedException = runAndSuppressThrowable(this::closeAllOperators, suppressedException);
@@ -941,6 +916,12 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>> extends Ab
         }
     }
 
+    protected void cleanUpInternal() throws Exception {
+        if (inputProcessor != null) {
+            inputProcessor.close();
+        }
+    }
+
     protected CompletableFuture<Void> getCompletionFuture() {
         return FutureUtils.completedVoidFuture();
     }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamOperatorWrapperTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamOperatorWrapperTest.java
index 7a02f6004ae..0c399090a6b 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamOperatorWrapperTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamOperatorWrapperTest.java
@@ -127,7 +127,7 @@ public class StreamOperatorWrapperTest extends TestLogger {
 
     @After
     public void teardown() throws Exception {
-        containingTask.cleanup();
+        containingTask.cleanUpInternal();
     }
 
     @Test
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java
index 20a33d6d0e4..f450af4c216 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMailboxTestHarness.java
@@ -164,7 +164,7 @@ public class StreamTaskMailboxTestHarness<OUT> implements AutoCloseable {
 
     public void finishProcessing() throws Exception {
         streamTask.afterInvoke();
-        streamTask.cleanUpInvoke();
+        streamTask.cleanUp(null);
     }
 
     @Override
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskSystemExitTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskSystemExitTest.java
index 93bd7d57977..00cbaf81aa4 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskSystemExitTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskSystemExitTest.java
@@ -238,7 +238,7 @@ public class StreamTaskSystemExitTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() {}
+        protected void cleanUpInternal() {}
 
         @Override
         protected void cancelTask() {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTerminationTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTerminationTest.java
index 20b5ee6828b..4660d4d59a4 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTerminationTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTerminationTest.java
@@ -243,7 +243,7 @@ public class StreamTaskTerminationTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() throws Exception {
+        protected void cleanUpInternal() throws Exception {
             // notify the asynchronous checkpoint operation that we have reached the cleanup stage
             // --> the task
             // has been stopped
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index 9bd71951844..40338185dd5 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -382,17 +382,18 @@ public class StreamTaskTest extends TestLogger {
 
         try {
             testHarness.waitForTaskCompletion();
+            throw new RuntimeException("Expected an exception but ran successfully");
         } catch (Exception ex) {
-            // make sure the original exception is the cause and not wrapped
             if (!(ex.getCause() instanceof ExpectedTestException)) {
                 throw ex;
             }
-            // make sure DisposeException is the only suppressed exception
-            if (ex.getCause().getSuppressed().length != 1) {
-                throw ex;
-            }
-            if (!(ex.getCause().getSuppressed()[0]
-                    instanceof FailingTwiceOperator.CloseException)) {
+        }
+
+        try {
+            testHarness.getTask().cleanUp(null);
+        } catch (Exception ex) {
+            // todo: checking for suppression if there are more exceptions during cleanup
+            if (!(ex instanceof FailingTwiceOperator.CloseException)) {
                 throw ex;
             }
         }
@@ -640,7 +641,7 @@ public class StreamTaskTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() {}
+        protected void cleanUpInternal() {}
 
         @Override
         protected void cancelTask() throws Exception {
@@ -1705,84 +1706,6 @@ public class StreamTaskTest extends TestLogger {
         }
     }
 
-    @Test
-    public void testCleanUpResourcesWhenFailingDuringInit() throws Exception {
-        // given: Configured SourceStreamTask with source which fails during initialization.
-        StreamTaskMailboxTestHarnessBuilder<Integer> builder =
-                new StreamTaskMailboxTestHarnessBuilder<>(
-                                OneInputStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)
-                        .addInput(BasicTypeInfo.INT_TYPE_INFO);
-        try {
-            // when: The task initializing(restoring).
-            builder.setupOutputForSingletonOperatorChain(new OpenFailingOperator<>()).build();
-            fail("The task should fail during the restore");
-        } catch (Exception ex) {
-            // then: The task should throw exception from initialization.
-            if (!ExceptionUtils.findThrowable(ex, ExpectedTestException.class).isPresent()) {
-                throw ex;
-            }
-        }
-
-        // then: The task should clean up all resources even when it failed on init.
-        assertTrue(OpenFailingOperator.wasClosed);
-    }
-
-    @Test
-    public void testRethrowExceptionFromRestoreInsideOfInvoke() throws Exception {
-        // given: Configured SourceStreamTask with source which fails during initialization.
-        StreamTaskMailboxTestHarnessBuilder<Integer> builder =
-                new StreamTaskMailboxTestHarnessBuilder<>(
-                                OneInputStreamTask::new, BasicTypeInfo.INT_TYPE_INFO)
-                        .addInput(BasicTypeInfo.INT_TYPE_INFO);
-        try {
-            // when: The task invocation without preceded restoring.
-            StreamTaskMailboxTestHarness<Integer> harness =
-                    builder.setupOutputForSingletonOperatorChain(new OpenFailingOperator<>())
-                            .buildUnrestored();
-
-            harness.streamTask.invoke();
-
-            fail("The task should fail during the restore");
-        } catch (Exception ex) {
-            // then: The task should rethrow exception from initialization.
-            if (!ExceptionUtils.findThrowable(ex, ExpectedTestException.class).isPresent()) {
-                throw ex;
-            }
-        }
-
-        // and: The task should clean up all resources even when it failed on init.
-        assertTrue(OpenFailingOperator.wasClosed);
-    }
-
-    @Test
-    public void testCleanUpResourcesEvenWhenCancelTaskFails() throws Exception {
-        // given: Configured StreamTask which fails during restoring and then inside of cancelTask.
-        StreamTaskMailboxTestHarnessBuilder<Integer> builder =
-                new StreamTaskMailboxTestHarnessBuilder<>(
-                                (env) ->
-                                        new OneInputStreamTask<String, Integer>(env) {
-                                            @Override
-                                            protected void cancelTask() {
-                                                throw new RuntimeException("Cancel task exception");
-                                            }
-                                        },
-                                BasicTypeInfo.INT_TYPE_INFO)
-                        .addInput(BasicTypeInfo.INT_TYPE_INFO);
-        try {
-            // when: The task initializing(restoring).
-            builder.setupOutputForSingletonOperatorChain(new OpenFailingOperator<>()).build();
-            fail("The task should fail during the restore");
-        } catch (Exception ex) {
-            // then: The task should throw the original exception about the restore fail.
-            if (!ExceptionUtils.findThrowable(ex, ExpectedTestException.class).isPresent()) {
-                throw ex;
-            }
-        }
-
-        // and: The task should clean up all resources even when cancelTask fails.
-        assertTrue(OpenFailingOperator.wasClosed);
-    }
-
     /**
      * This test checks the fact that throughput calculation is started automatically(just to be
      * sure that the scheduler is configured).
@@ -2027,7 +1950,7 @@ public class StreamTaskTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() throws Exception {}
+        protected void cleanUpInternal() throws Exception {}
     }
 
     /**
@@ -2228,8 +2151,8 @@ public class StreamTaskTest extends TestLogger {
         }
 
         @Override
-        public void executeRestore() throws Exception {
-            super.executeRestore();
+        public void restoreInternal() throws Exception {
+            super.restoreInternal();
             restoreInvocationCount++;
         }
 
@@ -2321,7 +2244,7 @@ public class StreamTaskTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() throws Exception {}
+        protected void cleanUpInternal() throws Exception {}
 
         @Override
         public StreamTaskStateInitializer createStreamTaskStateInitializer() {
@@ -2448,16 +2371,16 @@ public class StreamTaskTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() throws Exception {
+        protected void cleanUpInternal() throws Exception {
             checkTaskThreadInfo();
         }
 
         private void checkTaskThreadInfo() {
             Thread currentThread = Thread.currentThread();
-            Preconditions.checkState(
+            checkState(
                     taskThreadId == currentThread.getId(),
                     "Task's method was called in non task thread.");
-            Preconditions.checkState(
+            checkState(
                     taskClassLoader == currentThread.getContextClassLoader(),
                     "Task's controller class loader has been changed during invocation.");
         }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SynchronousCheckpointITCase.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SynchronousCheckpointITCase.java
index 658be981d7e..b77e2cf0a43 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SynchronousCheckpointITCase.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SynchronousCheckpointITCase.java
@@ -203,7 +203,7 @@ public class SynchronousCheckpointITCase {
         }
 
         @Override
-        protected void cleanup() {}
+        protected void cleanUpInternal() {}
     }
 
     /**
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java
index 8c96edf913d..598bf522785 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TaskCheckpointingBehaviourTest.java
@@ -525,6 +525,6 @@ public class TaskCheckpointingBehaviourTest extends TestLogger {
         }
 
         @Override
-        protected void cleanup() {}
+        protected void cleanUpInternal() {}
     }
 }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
index 1b7adbb4f43..2ebd32b05b7 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
@@ -724,7 +724,7 @@ public class AbstractStreamOperatorTestHarness<OUT> implements AutoCloseable {
         if (internalEnvironment.isPresent()) {
             internalEnvironment.get().close();
         }
-        mockTask.cleanup();
+        mockTask.cleanUpInternal();
     }
 
     public AbstractStreamOperator<OUT> getOperator() {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java
index 6347e9892a8..92577934569 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockStreamTask.java
@@ -86,7 +86,7 @@ public class MockStreamTask<OUT, OP extends StreamOperator<OUT>> extends StreamT
     public void init() {}
 
     @Override
-    protected void cleanup() {
+    protected void cleanUpInternal() {
         mailboxProcessor.allActionsCompleted();
     }
 
