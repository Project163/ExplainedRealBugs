diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java
index a584a21c775..eb1b4f70dbd 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java
@@ -544,6 +544,7 @@ public class SingleInputGate extends InputGate {
 	private Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)
 			throws IOException, InterruptedException {
 		while (true) {
+			InputChannel inputChannel;
 			synchronized (inputChannelsWithData) {
 				while (inputChannelsWithData.size() == 0) {
 					if (isReleased) {
@@ -559,15 +560,19 @@ public class SingleInputGate extends InputGate {
 					}
 				}
 
-				InputChannel inputChannel = inputChannelsWithData.remove();
+				inputChannel = inputChannelsWithData.remove();
+				enqueuedInputChannelsWithData.clear(inputChannel.getChannelIndex());
+			}
 
-				Optional<BufferAndAvailability> result = inputChannel.getNextBuffer();
+			// Do not query inputChannel under the lock, to avoid potential deadlocks coming from
+			// notifications.
+			Optional<BufferAndAvailability> result = inputChannel.getNextBuffer();
 
+			synchronized (inputChannelsWithData) {
 				if (result.isPresent() && result.get().moreAvailable()) {
 					// enqueue the inputChannel at the end to avoid starvation
 					inputChannelsWithData.add(inputChannel);
-				} else {
-					enqueuedInputChannelsWithData.clear(inputChannel.getChannelIndex());
+					enqueuedInputChannelsWithData.set(inputChannel.getChannelIndex());
 				}
 
 				if (inputChannelsWithData.isEmpty()) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java
index 5019cfc52b2..cdce747edcf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java
@@ -199,6 +199,7 @@ public class UnionInputGate extends InputGate {
 	private Optional<InputWithData<InputGate, BufferOrEvent>> waitAndGetNextData(boolean blocking)
 			throws IOException, InterruptedException {
 		while (true) {
+			InputGate inputGate;
 			synchronized (inputGatesWithData) {
 				while (inputGatesWithData.size() == 0) {
 					if (blocking) {
@@ -210,12 +211,16 @@ public class UnionInputGate extends InputGate {
 				}
 
 				Iterator<InputGate> inputGateIterator = inputGatesWithData.iterator();
-				final InputGate inputGate = inputGateIterator.next();
+				inputGate = inputGateIterator.next();
 				inputGateIterator.remove();
+			}
 
-				// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.
-				Optional<BufferOrEvent> bufferOrEvent = inputGate.pollNextBufferOrEvent();
+			// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.
+			// Do not poll the gate under inputGatesWithData lock, since this can trigger notifications
+			// that could deadlock because of wrong locks taking order.
+			Optional<BufferOrEvent> bufferOrEvent = inputGate.pollNextBufferOrEvent();
 
+			synchronized (inputGatesWithData) {
 				if (bufferOrEvent.isPresent() && bufferOrEvent.get().moreAvailable()) {
 					// enqueue the inputGate at the end to avoid starvation
 					inputGatesWithData.add(inputGate);
