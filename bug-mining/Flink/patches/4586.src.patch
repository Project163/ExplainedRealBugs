diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlot.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlot.java
index 1d55bbda69f..15250604364 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlot.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlot.java
@@ -35,9 +35,11 @@ import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
 
+import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.Consumer;
 import java.util.function.Function;
+import java.util.stream.Collectors;
 
 /**
  * Shared slot implementation for the {@link SlotSharingExecutionSlotAllocator}.
@@ -203,6 +205,7 @@ class SharedSlot implements SlotOwner, PhysicalSlot.Payload {
 	}
 
 	private void removeLogicalSlotRequest(SlotRequestId logicalSlotRequestId) {
+		LOG.debug("Remove {}", getLogicalSlotString(logicalSlotRequestId));
 		Preconditions.checkState(
 			requestedLogicalSlots.removeKeyB(logicalSlotRequestId) != null,
 			"Trying to remove a logical slot request which has been either already removed or never created.");
@@ -215,10 +218,19 @@ class SharedSlot implements SlotOwner, PhysicalSlot.Payload {
 			slotContextFuture.isDone(),
 			"Releasing of the shared slot is expected only from its successfully allocated physical slot ({})",
 			physicalSlotRequestId);
-		for (ExecutionVertexID executionVertexId : requestedLogicalSlots.keySetA()) {
-			LOG.debug("Release {}", getLogicalSlotString(executionVertexId));
+		LOG.debug("Release shared slot ({})", physicalSlotRequestId);
+
+		// copy the logical slot collection to avoid ConcurrentModificationException
+		// if logical slot releases cause cancellation of other executions
+		// which will try to call returnLogicalSlot and modify requestedLogicalSlots collection
+		Map<ExecutionVertexID, CompletableFuture<SingleLogicalSlot>> logicalSlotFutures = requestedLogicalSlots
+			.keySetA()
+			.stream()
+			.collect(Collectors.toMap(executionVertexId -> executionVertexId, requestedLogicalSlots::getValueByKeyA));
+		for (Map.Entry<ExecutionVertexID, CompletableFuture<SingleLogicalSlot>> entry : logicalSlotFutures.entrySet()) {
+			LOG.debug("Release {}", getLogicalSlotString(entry.getKey()));
 			CompletableFuture<SingleLogicalSlot> logicalSlotFuture =
-				requestedLogicalSlots.getValueByKeyA(executionVertexId);
+				entry.getValue();
 			Preconditions.checkNotNull(logicalSlotFuture);
 			Preconditions.checkState(
 				logicalSlotFuture.isDone(),
@@ -231,8 +243,9 @@ class SharedSlot implements SlotOwner, PhysicalSlot.Payload {
 	}
 
 	private void releaseExternally() {
-		if (state == State.ALLOCATED && requestedLogicalSlots.values().isEmpty()) {
+		if (state != State.RELEASED && requestedLogicalSlots.values().isEmpty()) {
 			state = State.RELEASED;
+			LOG.debug("Release shared slot externally ({})", physicalSlotRequestId);
 			externalReleaseCallback.accept(executionSlotSharingGroup);
 		}
 	}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SharedSlotTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SharedSlotTest.java
index da5091c3b01..afb5b3e9209 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SharedSlotTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SharedSlotTest.java
@@ -50,7 +50,8 @@ import static org.junit.Assert.fail;
  */
 public class SharedSlotTest extends TestLogger {
 	private static final ExecutionVertexID EV1 = createRandomExecutionVertexId();
-	private static final ExecutionSlotSharingGroup SG = createExecutionSlotSharingGroup(EV1);
+	private static final ExecutionVertexID EV2 = createRandomExecutionVertexId();
+	private static final ExecutionSlotSharingGroup SG = createExecutionSlotSharingGroup(EV1, EV2);
 	private static final SlotRequestId PHYSICAL_SLOT_REQUEST_ID = new SlotRequestId();
 	private static final ResourceProfile RP = ResourceProfile.newBuilder().setCpuCores(2.0).build();
 
@@ -285,6 +286,30 @@ public class SharedSlotTest extends TestLogger {
 		assertThat(released.get(), is(1));
 	}
 
+	@Test
+	public void testReturnLogicalSlotWhileReleasingDoesNotCauseConcurrentModificationException() {
+		CompletableFuture<PhysicalSlot> slotContextFuture = CompletableFuture
+			.completedFuture(new TestingPhysicalSlot(RP, new AllocationID()));
+		SharedSlot sharedSlot = SharedSlotBuilder
+			.newBuilder()
+			.withSlotContextFuture(slotContextFuture)
+			.build();
+		LogicalSlot logicalSlot1 = sharedSlot.allocateLogicalSlot(EV1).join();
+		LogicalSlot logicalSlot2 = sharedSlot.allocateLogicalSlot(EV2).join();
+		logicalSlot1.tryAssignPayload(new LogicalSlot.Payload() {
+			@Override
+			public void fail(Throwable cause) {
+				sharedSlot.returnLogicalSlot(logicalSlot2);
+			}
+
+			@Override
+			public CompletableFuture<?> getTerminalStateFuture() {
+				return CompletableFuture.completedFuture(null);
+			}
+		});
+		sharedSlot.release(new Throwable());
+	}
+
 	private static class SharedSlotBuilder {
 		private CompletableFuture<PhysicalSlot> slotContextFuture = new CompletableFuture<>();
 		private boolean slotWillBeOccupiedIndefinitely = false;
