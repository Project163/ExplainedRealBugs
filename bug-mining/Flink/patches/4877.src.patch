diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/BatchTask.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/BatchTask.java
index dd664b99e64..6a59eb3b943 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/BatchTask.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/BatchTask.java
@@ -29,6 +29,7 @@ import org.apache.flink.api.common.typeutils.TypeComparator;
 import org.apache.flink.api.common.typeutils.TypeComparatorFactory;
 import org.apache.flink.api.common.typeutils.TypeSerializerFactory;
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.metrics.MetricGroup;
 import org.apache.flink.runtime.broadcast.BroadcastVariableMaterialization;
 import org.apache.flink.runtime.execution.CancelTaskException;
@@ -63,6 +64,7 @@ import org.apache.flink.runtime.taskmanager.TaskManagerRuntimeInfo;
 import org.apache.flink.util.Collector;
 import org.apache.flink.util.InstantiationUtil;
 import org.apache.flink.util.MutableObjectIterator;
+import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.UserCodeClassLoader;
 
 import org.slf4j.Logger;
@@ -73,6 +75,8 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
+import static java.util.Collections.emptyList;
+
 /**
  * The base class for all batch tasks. Encapsulated common behavior and implements the main life-cycle
  * of the user code.
@@ -831,7 +835,7 @@ public class BatchTask<S extends Function, OT> extends AbstractInvokable impleme
 
 			if (async) {
 				@SuppressWarnings({ "unchecked", "rawtypes" })
-				TempBarrier<?> barrier = new TempBarrier(this, getInput(i), this.inputSerializers[i], memMan, ioMan, memoryPages);
+				TempBarrier<?> barrier = new TempBarrier(this, getInput(i), this.inputSerializers[i], memMan, ioMan, memoryPages, emptyList());
 				barrier.startReading();
 				this.tempBarriers[i] = barrier;
 				this.inputs[i] = null;
@@ -893,21 +897,31 @@ public class BatchTask<S extends Function, OT> extends AbstractInvokable impleme
 					}
 				} else {
 					// close the async barrier if there is one
-					if (this.tempBarriers[i] != null) {
-						this.tempBarriers[i].close();
-						this.tempBarriers[i] = null;
-					}
+					List<MemorySegment> allocated = tempBarriers[i] == null ? emptyList() :
+						tempBarriers[i].closeAndGetLeftoverMemory();
+					tempBarriers[i] = null;
 
-					// recreate the local strategy
-					initInputLocalStrategy(i);
-
-					if (this.inputIsAsyncMaterialized[i]) {
-						final int pages = this.materializationMemory[i];
-						@SuppressWarnings({ "unchecked", "rawtypes" })
-						TempBarrier<?> barrier = new TempBarrier(this, getInput(i), this.inputSerializers[i], memMan, ioMan, pages);
-						barrier.startReading();
-						this.tempBarriers[i] = barrier;
-						this.inputs[i] = null;
+					try {
+						initInputLocalStrategy(i);
+
+						if (this.inputIsAsyncMaterialized[i]) {
+							final int pages = this.materializationMemory[i];
+							Preconditions.checkState(allocated.size() <= pages); // pages shouldn't change, but some segments might have been consumed
+							@SuppressWarnings({ "unchecked", "rawtypes" })
+							TempBarrier<?> barrier = new TempBarrier(this, getInput(i), this.inputSerializers[i], memMan, ioMan, pages, allocated);
+							barrier.startReading();
+							this.tempBarriers[i] = barrier;
+							this.inputs[i] = null;
+						} else {
+							memMan.release(allocated);
+						}
+					} catch (Exception exception) {
+						try {
+							memMan.release(allocated);
+						} catch (Exception releaseException) {
+							exception.addSuppressed(releaseException);
+						}
+						throw exception;
 					}
 				}
 			}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/TempBarrier.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/TempBarrier.java
index 1eefb3f9afc..6c14b3efeee 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/TempBarrier.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/TempBarrier.java
@@ -34,6 +34,8 @@ import org.apache.flink.util.MutableObjectIterator;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * This class facilitates JVM-local exchange between stages of a batch job.
@@ -66,12 +68,16 @@ public class TempBarrier<T> implements CloseableInputProvider<T> {
 			TypeSerializerFactory<T> serializerFactory,
 			MemoryManager memManager,
 			IOManager ioManager,
-			int numPages) throws MemoryAllocationException {
+			int numPages,
+			List<MemorySegment> preAllocated) throws MemoryAllocationException {
 		this.serializer = serializerFactory.getSerializer();
 		this.memManager = memManager;
 
 		this.memory = new ArrayList<>(numPages);
-		memManager.allocatePages(owner, this.memory, numPages);
+		this.memory.addAll(preAllocated);
+		if (numPages > memory.size()) {
+			memManager.allocatePages(owner, memory, numPages - preAllocated.size());
+		}
 
 		this.buffer = new SpillingBuffer(ioManager, new ListMemorySegmentSource(this.memory), memManager.getPageSize());
 		this.tempWriter = new TempWritingThread(input, serializerFactory.getSerializer(), this.buffer);
@@ -107,9 +113,17 @@ public class TempBarrier<T> implements CloseableInputProvider<T> {
 
 	@Override
 	public void close() throws IOException {
+		memManager.release(prepareToClose());
+	}
+
+	List<MemorySegment> closeAndGetLeftoverMemory() throws IOException {
+		return prepareToClose();
+	}
+
+	private List<MemorySegment> prepareToClose() throws IOException {
 		synchronized (this.lock) {
 			if (this.closed) {
-				return;
+				return Collections.emptyList();
 			}
 			if (this.exception == null) {
 				this.exception = new Exception("The dam has been closed.");
@@ -124,8 +138,11 @@ public class TempBarrier<T> implements CloseableInputProvider<T> {
 			throw new IOException("Interrupted");
 		}
 
-		this.memManager.release(this.buffer.close());
-		this.memManager.release(this.memory);
+		List<MemorySegment> toRelease = new ArrayList<>();
+		toRelease.addAll(buffer.close());
+		toRelease.addAll(memory);
+		memory.clear();
+		return toRelease;
 	}
 
 	private void setException(Throwable t) {
