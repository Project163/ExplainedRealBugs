diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractStreamTaskNetworkInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractStreamTaskNetworkInput.java
index ebf7b0b9166..3035f714119 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractStreamTaskNetworkInput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractStreamTaskNetworkInput.java
@@ -157,7 +157,9 @@ public abstract class AbstractStreamTaskNetworkInput<
             // which is very valuable in case of bounded stream
             releaseDeserializer(bufferOrEvent.getChannelInfo());
         } else if (event.getClass() == EndOfChannelStateEvent.class) {
-            return InputStatus.END_OF_RECOVERY;
+            if (checkpointedInputGate.allChannelsRecovered()) {
+                return InputStatus.END_OF_RECOVERY;
+            }
         }
         return InputStatus.MORE_AVAILABLE;
     }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGate.java
index 2868d3de412..7431d20ad66 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGate.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGate.java
@@ -173,8 +173,7 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven
         return next;
     }
 
-    private Optional<BufferOrEvent> handleEvent(BufferOrEvent bufferOrEvent)
-            throws IOException, InterruptedException {
+    private Optional<BufferOrEvent> handleEvent(BufferOrEvent bufferOrEvent) throws IOException {
         Class<? extends AbstractEvent> eventClass = bufferOrEvent.getEvent().getClass();
         if (eventClass == CheckpointBarrier.class) {
             CheckpointBarrier checkpointBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();
@@ -198,9 +197,6 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven
                     bufferOrEvent.getChannelInfo());
         } else if (bufferOrEvent.getEvent().getClass() == EndOfChannelStateEvent.class) {
             upstreamRecoveryTracker.handleEndOfRecovery(bufferOrEvent.getChannelInfo());
-            if (!upstreamRecoveryTracker.allChannelsRecovered()) {
-                return pollNext();
-            }
         }
         return Optional.of(bufferOrEvent);
     }
@@ -288,6 +284,10 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven
         return inputGate.getChannelInfos();
     }
 
+    public boolean allChannelsRecovered() {
+        return upstreamRecoveryTracker.allChannelsRecovered();
+    }
+
     @VisibleForTesting
     CheckpointBarrierHandler getCheckpointBarrierHandler() {
         return barrierHandler;
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/UpstreamRecoveryTracker.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/UpstreamRecoveryTracker.java
index 6e81d795ab0..a473560d4b1 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/UpstreamRecoveryTracker.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/UpstreamRecoveryTracker.java
@@ -18,6 +18,7 @@
 package org.apache.flink.streaming.runtime.io.checkpointing;
 
 import org.apache.flink.annotation.Internal;
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.util.Preconditions;
@@ -25,8 +26,10 @@ import org.apache.flink.util.Preconditions;
 import java.io.IOException;
 import java.util.HashSet;
 
+/** Tracks status of upstream channels while they recover. */
 @Internal
-interface UpstreamRecoveryTracker {
+@VisibleForTesting
+public interface UpstreamRecoveryTracker {
 
     void handleEndOfRecovery(InputChannelInfo channelInfo) throws IOException;
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
index fa7450383ae..2cfcff5520e 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
@@ -36,6 +36,7 @@ import org.apache.flink.runtime.io.network.buffer.BufferBuilderTestUtils;
 import org.apache.flink.runtime.io.network.buffer.BufferConsumer;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
 import org.apache.flink.runtime.io.network.partition.consumer.CheckpointableInput;
+import org.apache.flink.runtime.io.network.partition.consumer.EndOfChannelStateEvent;
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.io.network.partition.consumer.StreamTestSingleInputGate;
 import org.apache.flink.runtime.operators.testutils.DummyCheckpointInvokable;
@@ -47,6 +48,7 @@ import org.apache.flink.streaming.runtime.io.PushingAsyncDataInput.DataOutput;
 import org.apache.flink.streaming.runtime.io.checkpointing.CheckpointBarrierTracker;
 import org.apache.flink.streaming.runtime.io.checkpointing.CheckpointedInputGate;
 import org.apache.flink.streaming.runtime.io.checkpointing.SingleCheckpointBarrierHandler;
+import org.apache.flink.streaming.runtime.io.checkpointing.UpstreamRecoveryTracker;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;
@@ -69,6 +71,7 @@ import java.util.concurrent.CompletableFuture;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
+import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -207,6 +210,29 @@ public class StreamTaskNetworkInputTest {
         }
     }
 
+    @Test
+    public void testInputStatusAfterEndOfRecovery() throws Exception {
+        int numInputChannels = 2;
+        LongSerializer inSerializer = LongSerializer.INSTANCE;
+        StreamTestSingleInputGate<Long> inputGate =
+                new StreamTestSingleInputGate<>(numInputChannels, 0, inSerializer, 1024);
+
+        DataOutput<Long> output = new NoOpDataOutput<>();
+        Map<InputChannelInfo, TestRecordDeserializer> deserializers =
+                createDeserializers(inputGate.getInputGate());
+
+        StreamTaskInput<Long> input =
+                new TestStreamTaskNetworkInput(
+                        inputGate, inSerializer, numInputChannels, deserializers);
+
+        inputGate.sendElement(new StreamRecord<>(42L), 0);
+        assertThat(input.emitNext(output), equalTo(InputStatus.MORE_AVAILABLE));
+        inputGate.sendEvent(EndOfChannelStateEvent.INSTANCE, 0);
+        assertThat(input.emitNext(output), equalTo(InputStatus.MORE_AVAILABLE));
+        inputGate.sendEvent(EndOfChannelStateEvent.INSTANCE, 1);
+        assertThat(input.emitNext(output), equalTo(InputStatus.END_OF_RECOVERY));
+    }
+
     private BufferOrEvent createDataBuffer() throws IOException {
         BufferBuilder bufferBuilder = BufferBuilderTestUtils.createEmptyBufferBuilder(PAGE_SIZE);
         BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
@@ -229,7 +255,8 @@ public class StreamTaskNetworkInputTest {
         return new CheckpointedInputGate(
                 inputGate,
                 new CheckpointBarrierTracker(1, new DummyCheckpointInvokable()),
-                new SyncMailboxExecutor());
+                new SyncMailboxExecutor(),
+                UpstreamRecoveryTracker.forInputGate(inputGate));
     }
 
     private void serializeRecord(long value, BufferBuilder bufferBuilder) throws IOException {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGateTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGateTest.java
index cc9c9f1aacf..6c525c72567 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGateTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/checkpointing/CheckpointedInputGateTest.java
@@ -84,7 +84,13 @@ public class CheckpointedInputGateTest {
             assertFalse(gate.pollNext().isPresent());
             for (int channelIndex = 0; channelIndex < numberOfChannels - 1; channelIndex++) {
                 enqueueEndOfState(gate, channelIndex);
-                assertFalse("should align (block all channels)", gate.pollNext().isPresent());
+                Optional<BufferOrEvent> bufferOrEvent = gate.pollNext();
+                while (bufferOrEvent.isPresent()
+                        && bufferOrEvent.get().getEvent() instanceof EndOfChannelStateEvent
+                        && !gate.allChannelsRecovered()) {
+                    bufferOrEvent = gate.pollNext();
+                }
+                assertFalse("should align (block all channels)", bufferOrEvent.isPresent());
             }
 
             enqueueEndOfState(gate, numberOfChannels - 1);
