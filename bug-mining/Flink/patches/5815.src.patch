diff --git a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/runtime/SavepointTaskStateManager.java b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/runtime/SavepointTaskStateManager.java
index 7b89b3b5f18..ac4db135f18 100644
--- a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/runtime/SavepointTaskStateManager.java
+++ b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/runtime/SavepointTaskStateManager.java
@@ -34,6 +34,8 @@ import org.apache.flink.util.Preconditions;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
+import java.util.Optional;
+
 /**
  * A minimally implemented {@link TaskStateManager} that provides the functionality required to run
  * the {@code state-processor-api}.
@@ -65,6 +67,11 @@ final class SavepointTaskStateManager implements TaskStateManager {
         return false;
     }
 
+    @Override
+    public Optional<Long> getRestoreCheckpointId() {
+        return Optional.empty();
+    }
+
     @Nonnull
     @Override
     public PrioritizedOperatorSubtaskState prioritizedOperatorState(OperatorID operatorID) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManager.java
index 21a611bfc68..f4dadf94326 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManager.java
@@ -31,6 +31,8 @@ import org.apache.flink.runtime.state.changelog.StateChangelogStorage;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
+import java.util.Optional;
+
 /**
  * This interface provides methods to report and retrieve state for a task.
  *
@@ -74,6 +76,9 @@ public interface TaskStateManager extends CheckpointListener, AutoCloseable {
     /** Whether all the operators of the task are finished on restore. */
     boolean isFinishedOnRestore();
 
+    /** Acquires the checkpoint id to restore from. */
+    Optional<Long> getRestoreCheckpointId();
+
     /**
      * Returns means to restore previously reported state of an operator running in the owning task.
      *
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManagerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManagerImpl.java
index 02f21e571f7..1fbb81dea9c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManagerImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/TaskStateManagerImpl.java
@@ -41,6 +41,7 @@ import javax.annotation.Nullable;
 
 import java.util.Collections;
 import java.util.List;
+import java.util.Optional;
 
 /**
  * This class is the default implementation of {@link TaskStateManager} and collaborates with the
@@ -163,6 +164,16 @@ public class TaskStateManagerImpl implements TaskStateManager {
         return jobManagerTaskRestore.getTaskStateSnapshot().isFinishedOnRestore();
     }
 
+    @Override
+    public Optional<Long> getRestoreCheckpointId() {
+        if (jobManagerTaskRestore == null) {
+            // This happens only if no checkpoint to restore.
+            return Optional.empty();
+        }
+
+        return Optional.of(jobManagerTaskRestore.getRestoreCheckpointId());
+    }
+
     @Override
     public PrioritizedOperatorSubtaskState prioritizedOperatorState(OperatorID operatorID) {
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/TaskStateManagerImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/TaskStateManagerImplTest.java
index 223f67375ce..ed0a707115c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/TaskStateManagerImplTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/TaskStateManagerImplTest.java
@@ -284,6 +284,28 @@ public class TaskStateManagerImplTest extends TestLogger {
         Assert.assertTrue(stateManager.isFinishedOnRestore());
     }
 
+    public void testAcquringRestoreCheckpointId() {
+        TaskStateManagerImpl emptyStateManager =
+                new TaskStateManagerImpl(
+                        new JobID(),
+                        new ExecutionAttemptID(),
+                        new TestTaskLocalStateStore(),
+                        null,
+                        null,
+                        new TestCheckpointResponder());
+        Assert.assertFalse(emptyStateManager.getRestoreCheckpointId().isPresent());
+
+        TaskStateManagerImpl nonEmptyStateManager =
+                new TaskStateManagerImpl(
+                        new JobID(),
+                        new ExecutionAttemptID(),
+                        new TestTaskLocalStateStore(),
+                        null,
+                        new JobManagerTaskRestore(2, new TaskStateSnapshot()),
+                        new TestCheckpointResponder());
+        Assert.assertEquals(2L, (long) nonEmptyStateManager.getRestoreCheckpointId().get());
+    }
+
     public static TaskStateManager taskStateManager(
             JobID jobID,
             ExecutionAttemptID executionAttemptID,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/TestTaskStateManager.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/TestTaskStateManager.java
index a52b15a1801..22a68827ce2 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/TestTaskStateManager.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/TestTaskStateManager.java
@@ -41,6 +41,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
@@ -155,6 +156,17 @@ public class TestTaskStateManager implements TaskStateManager {
         return false;
     }
 
+    @Override
+    public Optional<Long> getRestoreCheckpointId() {
+        TaskStateSnapshot jmTaskStateSnapshot = getLastJobManagerTaskStateSnapshot();
+
+        if (jmTaskStateSnapshot == null) {
+            return Optional.empty();
+        }
+
+        return Optional.of(reportedCheckpointId);
+    }
+
     @Nonnull
     @Override
     public PrioritizedOperatorSubtaskState prioritizedOperatorState(OperatorID operatorID) {
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index b2ba02b9532..46decbbe860 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -653,6 +653,11 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
                         : new RegularOperatorChain<>(this, recordWriter);
         mainOperator = operatorChain.getMainOperator();
 
+        getEnvironment()
+                .getTaskStateManager()
+                .getRestoreCheckpointId()
+                .ifPresent(restoreId -> latestReportCheckpointId = restoreId);
+
         // task specific initialization
         init();
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java
index 974d75ab427..f8eb7337c93 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java
@@ -1105,13 +1105,13 @@ public class MultipleInputStreamTaskTest {
                         .build()) {
             CompletableFuture<Boolean> triggerResult =
                     testHarness.streamTask.triggerCheckpointAsync(
-                            new CheckpointMetaData(1, 1),
+                            new CheckpointMetaData(2, 2),
                             CheckpointOptions.alignedNoTimeout(
                                     SAVEPOINT_TERMINATE,
                                     CheckpointStorageLocationReference.getDefault()));
             checkpointCompleted.whenComplete(
                     (ignored, exception) ->
-                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));
+                            testHarness.streamTask.notifyCheckpointCompleteAsync(2));
             testHarness.waitForTaskCompletion();
             testHarness.finishProcessing();
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTaskTest.java
index 5d334ed4c88..ffe4c154e75 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTaskTest.java
@@ -260,13 +260,13 @@ public class SourceOperatorStreamTaskTest extends SourceStreamTaskTestBase {
 
             CompletableFuture<Boolean> triggerResult =
                     testHarness.streamTask.triggerCheckpointAsync(
-                            new CheckpointMetaData(1, 1),
+                            new CheckpointMetaData(2, 2),
                             CheckpointOptions.alignedNoTimeout(
                                     SAVEPOINT_TERMINATE,
                                     CheckpointStorageLocationReference.getDefault()));
             checkpointCompleted.whenComplete(
                     (ignored, exception) ->
-                            testHarness.streamTask.notifyCheckpointCompleteAsync(1));
+                            testHarness.streamTask.notifyCheckpointCompleteAsync(2));
             testHarness.waitForTaskCompletion();
             testHarness.finishProcessing();
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java
index 9715ad5e25b..2057c159ec2 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTaskTest.java
@@ -770,12 +770,12 @@ public class SourceStreamTaskTest extends SourceStreamTaskTestBase {
                         .build()) {
             CompletableFuture<Boolean> triggerResult =
                     harness.streamTask.triggerCheckpointAsync(
-                            new CheckpointMetaData(1, 1),
+                            new CheckpointMetaData(2, 2),
                             CheckpointOptions.alignedNoTimeout(
                                     SAVEPOINT_TERMINATE,
                                     CheckpointStorageLocationReference.getDefault()));
             checkpointCompleted.whenComplete(
-                    (ignored, exception) -> harness.streamTask.notifyCheckpointCompleteAsync(1));
+                    (ignored, exception) -> harness.streamTask.notifyCheckpointCompleteAsync(2));
 
             // Run mailbox till the source thread finished and suspend the mailbox
             harness.streamTask.runMailboxLoop();
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
index 07e40bdf079..09813730ff5 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java
@@ -1774,6 +1774,39 @@ public class StreamTaskTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testIgnoreCompleteCheckpointBeforeStartup() throws Exception {
+        try (StreamTaskMailboxTestHarness<String> testHarness =
+                new StreamTaskMailboxTestHarnessBuilder<>(
+                                OneInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)
+                        .addInput(BasicTypeInfo.STRING_TYPE_INFO, 3)
+                        .setTaskStateSnapshot(3, new TaskStateSnapshot())
+                        .modifyStreamConfig(
+                                config -> {
+                                    config.setCheckpointingEnabled(true);
+                                    config.getConfiguration()
+                                            .set(
+                                                    ExecutionCheckpointingOptions
+                                                            .ENABLE_CHECKPOINTS_AFTER_TASKS_FINISH,
+                                                    true);
+                                })
+                        .setupOutputForSingletonOperatorChain(
+                                new CheckpointCompleteRecordOperator())
+                        .build()) {
+            testHarness.streamTask.notifyCheckpointCompleteAsync(2);
+            testHarness.streamTask.notifyCheckpointAbortAsync(4, 3);
+            testHarness.streamTask.notifyCheckpointCompleteAsync(5);
+            testHarness.streamTask.notifyCheckpointAbortAsync(7, 6);
+
+            testHarness.processAll();
+
+            CheckpointCompleteRecordOperator operator =
+                    (CheckpointCompleteRecordOperator)
+                            (AbstractStreamOperator<?>) testHarness.streamTask.getMainOperator();
+            assertEquals(Arrays.asList(5L, 6L), operator.getNotifiedCheckpoint());
+        }
+    }
+
     @Test
     public void testBufferSizeRecalculationStartSuccessfully() throws Exception {
         int expectedThroughput = 13333;
