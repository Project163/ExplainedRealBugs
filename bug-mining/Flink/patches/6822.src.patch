diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
index 7587795ba74..1a8c8871665 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolder.java
@@ -67,7 +67,7 @@ import static org.apache.flink.util.Preconditions.checkState;
  *       closed. Events coming after that are held back (buffered), because they belong to the epoch
  *       after the checkpoint.
  *   <li>Once all coordinators in the job have completed the checkpoint, the barriers to the sources
- *       are injected. If a coordinator receives a {@link AcknowledgeCheckpointEvent} from one of
+ *       are injected. If a coordinator receives an {@link AcknowledgeCheckpointEvent} from one of
  *       its subtasks, which denotes that the subtask has received the checkpoint barrier and
  *       completed checkpoint, the coordinator reopens the corresponding subtask gateway and sends
  *       out buffered events.
@@ -76,23 +76,6 @@ import static org.apache.flink.util.Preconditions.checkState;
  *       subtask after it's latest complete checkpoint.
  * </ul>
  *
- * Thus, events delivered from coordinators behave as follows.
- *
- * <ul>
- *   <li>If the event is generated before the coordinator completes checkpoint, it would be sent out
- *       immediately.
- *   <li>If the event is generated after the coordinator completes checkpoint, it would be
- *       temporarily buffered and not be sent out to the subtask until the coordinator received a
- *       {@link AcknowledgeCheckpointEvent} from that subtask.
- *   <li>If the event is generated after the coordinator received {@link
- *       AcknowledgeCheckpointEvent}, it would be sent out immediately.
- * </ul>
- *
- * <p>This implementation can handle concurrent checkpoints. In the behavior described above, If an
- * event is generated after the coordinator has completed multiple checkpoints, and before it
- * receives {@link AcknowledgeCheckpointEvent} about any of them, the event would be buffered until
- * the coordinator has received {@link AcknowledgeCheckpointEvent} about all of these checkpoints.
- *
  * <p><b>IMPORTANT:</b> A critical assumption is that all events from the scheduler to the Tasks are
  * transported strictly in order. Events being sent from the coordinator after the checkpoint
  * barrier was injected must not overtake the checkpoint barrier. This is currently guaranteed by
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java
index 2fb2bffce3f..7c0e8a673a8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/operators/coordination/SubtaskGatewayImpl.java
@@ -45,9 +45,7 @@ import java.util.concurrent.CompletableFuture;
  * releasing them later. If the instance is closed for a specific checkpoint, events arrived after
  * that would be blocked temporarily, and released after the checkpoint finishes. If an event is
  * blocked & buffered when there are multiple ongoing checkpoints, the event would be released after
- * all these checkpoints finish. It is used for "alignment" of operator event streams with
- * checkpoint barrier injection, similar to how the input channels are aligned during a common
- * checkpoint.
+ * all these checkpoints finish.
  *
  * <p>The methods on the critical communication path, including closing/reopening the gateway and
  * sending the operator events, are required to be used in a single-threaded context specified by
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
index cdd46f103e4..f34c872d8dc 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorHolderTest.java
@@ -182,26 +182,6 @@ public class OperatorCoordinatorHolderTest extends TestLogger {
                 .containsExactly(new EventWithSubtask(new TestOperatorEvent(123), 0));
     }
 
-    @Test
-    public void triggerConcurrentCheckpoints() throws Exception {
-        final EventReceivingTasks tasks = EventReceivingTasks.createForRunningTasks();
-        final OperatorCoordinatorHolder holder =
-                createCoordinatorHolder(tasks, TestingOperatorCoordinator::new);
-
-        triggerAndCompleteCheckpoint(holder, 1111L);
-        getCoordinator(holder).getSubtaskGateway(0).sendEvent(new TestOperatorEvent(1337));
-        triggerAndCompleteCheckpoint(holder, 1112L);
-        getCoordinator(holder).getSubtaskGateway(0).sendEvent(new TestOperatorEvent(1338));
-        assertThat(tasks.getSentEventsForSubtask(0)).isEmpty();
-
-        holder.handleEventFromOperator(0, 0, new AcknowledgeCheckpointEvent(1111L));
-        assertThat(tasks.getSentEventsForSubtask(0)).containsExactly(new TestOperatorEvent(1337));
-
-        holder.handleEventFromOperator(0, 0, new AcknowledgeCheckpointEvent(1112L));
-        assertThat(tasks.getSentEventsForSubtask(0))
-                .containsExactly(new TestOperatorEvent(1337), new TestOperatorEvent(1338));
-    }
-
     @Test
     public void takeCheckpointAfterSuccessfulCheckpoint() throws Exception {
         final EventReceivingTasks tasks = EventReceivingTasks.createForRunningTasks();
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase.java
index 6a67ca2d13a..b9d44b30d11 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase.java
@@ -116,9 +116,6 @@ public class CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase
         ManuallyClosedSourceFunction.shouldCloseSource = false;
         EventReceivingOperator.shouldUnblockAllCheckpoint = false;
         EventReceivingOperator.shouldUnblockNextCheckpoint = false;
-        EventSendingCoordinatorWithGuaranteedConcurrentCheckpoint
-                        .isCheckpointAbortedBeforeScriptFailure =
-                false;
         TestScript.reset();
     }
 
@@ -160,19 +157,6 @@ public class CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase
                 .isTrue();
     }
 
-    @Test
-    public void testConcurrentCheckpoint() throws Exception {
-        env.getCheckpointConfig().setMaxConcurrentCheckpoints(2);
-        executeAndVerifyResults(
-                env,
-                new EventReceivingOperatorFactoryWithGuaranteedConcurrentCheckpoint<>(
-                        "eventReceiving", NUM_EVENTS, DELAY));
-        assertThat(
-                        EventSendingCoordinatorWithGuaranteedConcurrentCheckpoint
-                                .isCheckpointAbortedBeforeScriptFailure)
-                .isFalse();
-    }
-
     private void executeAndVerifyResults(
             StreamExecutionEnvironment env, EventReceivingOperatorFactory<Long, Long> factory)
             throws Exception {
@@ -562,172 +546,4 @@ public class CoordinatorEventsToStreamOperatorRecipientExactlyOnceITCase
                             getOperatorID(), new SerializedValue<>(new StartEvent(lastValue)));
         }
     }
-
-    /**
-     * A wrapper operator factory for {@link
-     * EventSendingCoordinatorWithGuaranteedConcurrentCheckpoint} and {@link
-     * EventReceivingOperator}.
-     */
-    private static class EventReceivingOperatorFactoryWithGuaranteedConcurrentCheckpoint<IN, OUT>
-            extends EventReceivingOperatorFactory<IN, OUT> {
-
-        public EventReceivingOperatorFactoryWithGuaranteedConcurrentCheckpoint(
-                String name, int numEvents, int delay) {
-            super(name, numEvents, delay);
-        }
-
-        @Override
-        public OperatorCoordinator.Provider getCoordinatorProvider(
-                String operatorName, OperatorID operatorID) {
-            return new OperatorCoordinator.Provider() {
-
-                @Override
-                public OperatorID getOperatorId() {
-                    return operatorID;
-                }
-
-                @Override
-                public OperatorCoordinator create(OperatorCoordinator.Context context) {
-                    return new EventSendingCoordinatorWithGuaranteedConcurrentCheckpoint(
-                            context, name, numEvents, delay);
-                }
-            };
-        }
-    }
-
-    /**
-     * A subclass of {@link EventSendingCoordinator} that additionally guarantees the following
-     * behavior around checkpoint.
-     *
-     * <ul>
-     *   <li>The job must have completed two checkpoints before the coordinator injects the failure.
-     *   <li>The two checkpoints must have an overlapping period. i.e. The second checkpoint must
-     *       have started before the first checkpoint finishes.
-     *   <li>The failure must be injected after the coordinator has completed its second checkpoint
-     *       and before it completes the third.
-     *   <li>There must be events being sent when the coordinator has completed the second
-     *       checkpoint while the subtask has not.
-     * </ul>
-     *
-     * <p>In order for this class to work correctly, make sure to invoke {@link
-     * org.apache.flink.streaming.api.environment.CheckpointConfig#setMaxConcurrentCheckpoints(int)}
-     * method with a parameter value larger than 1.
-     */
-    private static class EventSendingCoordinatorWithGuaranteedConcurrentCheckpoint
-            extends EventSendingCoordinator {
-
-        /** Whether there is a checkpoint aborted before the test script failure is triggered. */
-        private static boolean isCheckpointAbortedBeforeScriptFailure;
-
-        /**
-         * The max number that the coordinator might send out before it completes the second
-         * checkpoint.
-         */
-        private final int maxNumberBeforeSecondCheckpoint;
-
-        /** Whether the coordinator has sent out any event after the second checkpoint. */
-        private boolean isEventSentAfterSecondCheckpoint;
-
-        /** Whether the coordinator has completed the first checkpoint. */
-        private boolean isCoordinatorFirstCheckpointCompleted;
-
-        /** Whether the job (both coordinator and operator) has completed the first checkpoint. */
-        private boolean isJobFirstCheckpointCompleted;
-
-        /** Whether the coordinator has completed the second checkpoint. */
-        private boolean isCoordinatorSecondCheckpointCompleted;
-
-        /** Whether the job (both coordinator and operator) has completed the second checkpoint. */
-        private boolean isJobSecondCheckpointCompleted;
-
-        public EventSendingCoordinatorWithGuaranteedConcurrentCheckpoint(
-                Context context, String name, int numEvents, int delay) {
-            super(context, name, numEvents, delay);
-            this.maxNumberBeforeSecondCheckpoint = new Random().nextInt(numEvents / 6);
-            this.isEventSentAfterSecondCheckpoint = false;
-            this.isCoordinatorFirstCheckpointCompleted = false;
-            this.isJobFirstCheckpointCompleted = false;
-            this.isCoordinatorSecondCheckpointCompleted = false;
-            this.isJobSecondCheckpointCompleted = false;
-        }
-
-        @Override
-        protected void sendNextEvent() {
-            if (!isCoordinatorSecondCheckpointCompleted
-                    && nextNumber > maxNumberBeforeSecondCheckpoint) {
-                return;
-            }
-
-            if (!isJobSecondCheckpointCompleted && nextNumber >= maxNumberBeforeFailure) {
-                return;
-            }
-
-            super.sendNextEvent();
-
-            if (!isEventSentAfterSecondCheckpoint && isCoordinatorSecondCheckpointCompleted) {
-                isEventSentAfterSecondCheckpoint = true;
-            }
-
-            // If the checkpoint coordinator receives the completion message of checkpoint 1 and
-            // checkpoint 2 at the same time, checkpoint 2 might be completed before checkpoint 1
-            // due to the async mechanism in the checkpoint process, which would cause checkpoint 1
-            // to be accidentally aborted. In order to avoid this situation, the following code is
-            // required to make sure that checkpoint 2 is not completed until checkpoint 1 finishes.
-            if (isEventSentAfterSecondCheckpoint && isJobFirstCheckpointCompleted) {
-                EventReceivingOperator.shouldUnblockAllCheckpoint = true;
-            }
-        }
-
-        @Override
-        protected void handleCheckpoint() {
-            if (nextToComplete != null) {
-                if (!isCoordinatorFirstCheckpointCompleted) {
-                    isCoordinatorFirstCheckpointCompleted = true;
-                } else if (!isCoordinatorSecondCheckpointCompleted) {
-                    isCoordinatorSecondCheckpointCompleted = true;
-                    EventReceivingOperator.shouldUnblockNextCheckpoint = true;
-                }
-            }
-
-            super.handleCheckpoint();
-
-            if (nextToComplete != null
-                    && isEventSentAfterSecondCheckpoint
-                    && !testScript.hasAlreadyFailed()) {
-                testScript.recordHasFailed();
-                context.failJob(new Exception("test failure"));
-            }
-        }
-
-        @Override
-        public void resetToCheckpoint(long checkpointId, @Nullable byte[] checkpointData)
-                throws Exception {
-            super.resetToCheckpoint(checkpointId, checkpointData);
-            runInMailbox(
-                    () -> {
-                        isCoordinatorFirstCheckpointCompleted = true;
-                        isJobFirstCheckpointCompleted = true;
-                    });
-        }
-
-        @Override
-        public void notifyCheckpointAborted(long checkpointId) {
-            if (!testScript.hasAlreadyFailed()) {
-                isCheckpointAbortedBeforeScriptFailure = true;
-            }
-        }
-
-        @Override
-        public void notifyCheckpointComplete(long checkpointId) {
-            super.notifyCheckpointComplete(checkpointId);
-            runInMailbox(
-                    () -> {
-                        if (!isJobFirstCheckpointCompleted) {
-                            isJobFirstCheckpointCompleted = true;
-                        } else if (!isJobSecondCheckpointCompleted) {
-                            isJobSecondCheckpointCompleted = true;
-                        }
-                    });
-        }
-    }
 }
