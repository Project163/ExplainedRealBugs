diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java
index 7af248afc14..4e0696cb21d 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandler.java
@@ -35,7 +35,8 @@ import static org.apache.flink.util.Preconditions.checkState;
  */
 @Internal
 public class MultipleInputSelectionHandler {
-    public static final int MAX_SUPPORTED_INPUT_COUNT = Long.SIZE;
+    // if we directly use Long.SIZE, calculation of allSelectedMask will overflow
+    public static final int MAX_SUPPORTED_INPUT_COUNT = Long.SIZE - 1;
 
     @Nullable private final InputSelectable inputSelectable;
 
@@ -51,7 +52,7 @@ public class MultipleInputSelectionHandler {
             @Nullable InputSelectable inputSelectable, int inputCount) {
         checkSupportedInputCount(inputCount);
         this.inputSelectable = inputSelectable;
-        this.allSelectedMask = (1 << inputCount) - 1;
+        this.allSelectedMask = (1L << inputCount) - 1;
         this.availableInputsMask = allSelectedMask;
         this.notFinishedInputsMask = allSelectedMask;
     }
@@ -59,7 +60,7 @@ public class MultipleInputSelectionHandler {
     public static void checkSupportedInputCount(int inputCount) {
         checkArgument(
                 inputCount <= MAX_SUPPORTED_INPUT_COUNT,
-                "Only up to %d inputs are supported at once, while encountered %d",
+                "Only up to %s inputs are supported at once, while encountered %s",
                 MAX_SUPPORTED_INPUT_COUNT,
                 inputCount);
     }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandlerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandlerTest.java
index 5a6128ceb02..6e11e752a84 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandlerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/MultipleInputSelectionHandlerTest.java
@@ -26,6 +26,7 @@ import static org.junit.Assert.assertTrue;
 
 /** Tests for {@link MultipleInputSelectionHandler}. */
 public class MultipleInputSelectionHandlerTest {
+
     @Test
     public void testShouldSetAvailableForAnotherInput() {
         InputSelection secondAndThird = new InputSelection.Builder().select(2).select(3).build();
@@ -48,4 +49,26 @@ public class MultipleInputSelectionHandlerTest {
         selectionHandler.setAvailableInput(2);
         assertFalse(selectionHandler.shouldSetAvailableForAnotherInput());
     }
+
+    @Test
+    public void testLargeInputCount() {
+        int inputCount = MultipleInputSelectionHandler.MAX_SUPPORTED_INPUT_COUNT;
+
+        InputSelection.Builder builder = new InputSelection.Builder();
+        for (int i = 1; i <= inputCount; i++) {
+            builder.select(i);
+        }
+        InputSelection allSelected = builder.build();
+
+        MultipleInputSelectionHandler selectionHandler =
+                new MultipleInputSelectionHandler(() -> allSelected, inputCount);
+        selectionHandler.nextSelection();
+
+        for (int i = 0; i < inputCount - 1; i++) {
+            selectionHandler.setUnavailableInput(i);
+        }
+        assertTrue(selectionHandler.isAnyInputAvailable());
+        selectionHandler.setUnavailableInput(inputCount - 1);
+        assertFalse(selectionHandler.isAnyInputAvailable());
+    }
 }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MultipleInputITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MultipleInputITCase.scala
index 33707cef91f..7e1fa4f1f61 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MultipleInputITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/MultipleInputITCase.scala
@@ -20,6 +20,7 @@ package org.apache.flink.table.planner.runtime.batch.sql
 
 import org.apache.flink.api.common.typeinfo.BasicTypeInfo.{INT_TYPE_INFO, LONG_TYPE_INFO, STRING_TYPE_INFO}
 import org.apache.flink.api.java.typeutils.RowTypeInfo
+import org.apache.flink.streaming.runtime.io.MultipleInputSelectionHandler
 import org.apache.flink.table.api.config.{ExecutionConfigOptions, OptimizerConfigOptions}
 import org.apache.flink.table.planner.runtime.utils.BatchTestBase
 import org.apache.flink.types.Row
@@ -182,6 +183,27 @@ class MultipleInputITCase(shuffleMode: String) extends BatchTestBase {
     )
   }
 
+  @Test
+  def testMaxSupportedInputs(): Unit = {
+    val rowType = new RowTypeInfo(INT_TYPE_INFO, STRING_TYPE_INFO)
+    val data = Seq(BatchTestBase.row(1, "test"))
+    val nullables: Array[Boolean] = Array(true, true)
+    registerCollection("left_table", data, rowType, "a, b", nullables)
+    registerCollection("right_table", data, rowType, "c, d", nullables)
+
+    val numJoins = MultipleInputSelectionHandler.MAX_SUPPORTED_INPUT_COUNT - 1
+
+    val sql = new StringBuilder("SELECT t0.a, t0.b")
+    for (i <- 1 to numJoins) {
+      sql.append(s", t$i.c, t$i.d")
+    }
+    sql.append(" from left_table as t0")
+    for (i <- 1 to numJoins) {
+      sql.append(s" left join right_table as t$i on t0.a = t$i.c and t$i.c = 1")
+    }
+    checkMultipleInputResult(sql.toString())
+  }
+
   def checkMultipleInputResult(sql: String): Unit = {
     tEnv.getConfig.getConfiguration.setBoolean(
       OptimizerConfigOptions.TABLE_OPTIMIZER_MULTIPLE_INPUT_ENABLED, false)
