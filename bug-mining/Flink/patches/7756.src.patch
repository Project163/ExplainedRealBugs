diff --git a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesRuntimeFunctions.java b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesRuntimeFunctions.java
index c7dcdf98a67..c626581dbb2 100644
--- a/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesRuntimeFunctions.java
+++ b/flink-table/flink-table-planner/src/test/java/org/apache/flink/table/planner/factories/TestValuesRuntimeFunctions.java
@@ -518,13 +518,17 @@ final class TestValuesRuntimeFunctions {
                         .flatMap(List::stream)
                         .forEach(
                                 row -> {
-                                    boolean isDelete = row.getKind() == RowKind.DELETE;
+                                    boolean isDelete =
+                                            row.getKind() == RowKind.DELETE
+                                                    || row.getKind() == RowKind.UPDATE_BEFORE;
                                     Row key = Row.project(row, keyIndices);
                                     key.setKind(RowKind.INSERT);
                                     if (isDelete) {
                                         localUpsertResult.remove(key);
                                     } else {
-                                        localUpsertResult.put(key, row);
+                                        final Row upsertRow = Row.copy(row);
+                                        upsertRow.setKind(RowKind.INSERT);
+                                        localUpsertResult.put(key, upsertRow);
                                     }
                                 });
             }
diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TableSinkITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TableSinkITCase.scala
index c593c6c0f8b..21ba1458a45 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TableSinkITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/stream/sql/TableSinkITCase.scala
@@ -17,8 +17,11 @@
  */
 package org.apache.flink.table.planner.runtime.stream.sql
 
+import org.apache.flink.configuration.{Configuration, RestartStrategyOptions}
+import org.apache.flink.core.execution.CheckpointingMode
 import org.apache.flink.table.planner.expressions.utils.TestNonDeterministicUdf
 import org.apache.flink.table.planner.factories.TestValuesTableFactory
+import org.apache.flink.table.planner.factories.TestValuesTableFactory.changelogRow
 import org.apache.flink.table.planner.runtime.utils._
 import org.apache.flink.table.planner.runtime.utils.BatchTestBase.row
 import org.apache.flink.table.planner.runtime.utils.StreamingWithStateTestBase.StateBackendMode
@@ -28,6 +31,8 @@ import org.assertj.core.api.Assertions.{assertThat, assertThatThrownBy}
 import org.junit.jupiter.api.{BeforeEach, Disabled, TestTemplate}
 import org.junit.jupiter.api.extension.ExtendWith
 
+import java.time.Duration
+
 import scala.collection.JavaConversions._
 
 @ExtendWith(Array(classOf[ParameterizedTestExtension]))
@@ -630,4 +635,66 @@ class TableSinkITCase(mode: StateBackendMode) extends StreamingWithStateTestBase
       "+I[3, clark, 1, null, null]")
     assertThat(result.sorted).isEqualTo(expected.sorted)
   }
+
+  @TestTemplate
+  def testUpsertSinkWithFailingSource(): Unit = {
+    // enable checkpoint, we are using failing source to force have a complete checkpoint
+    // and cover restore path
+    env.enableCheckpointing(100, CheckpointingMode.EXACTLY_ONCE)
+    val configuration = new Configuration()
+    configuration.set(RestartStrategyOptions.RESTART_STRATEGY, "fixeddelay")
+    configuration.set(RestartStrategyOptions.RESTART_STRATEGY_FIXED_DELAY_ATTEMPTS, Int.box(1))
+    configuration.set(
+      RestartStrategyOptions.RESTART_STRATEGY_FIXED_DELAY_DELAY,
+      Duration.ofMillis(0))
+    env.configure(configuration, Thread.currentThread.getContextClassLoader)
+    FailingCollectionSource.reset()
+
+    val data = List(
+      changelogRow("+I", Int.box(1), "Jim"),
+      changelogRow("-U", Int.box(1), "Jim"),
+      changelogRow("+U", Int.box(1), "Ketty"),
+      changelogRow("+I", Int.box(2), "Lilith"),
+      changelogRow("-U", Int.box(2), "Lilith"),
+      // failover
+      changelogRow("+I", Int.box(3), "Sam"),
+      changelogRow("-U", Int.box(3), "Sam"),
+      changelogRow("+U", Int.box(3), "Boob"),
+      changelogRow("-D", Int.box(3), "Boob"),
+      changelogRow("+I", Int.box(4), "Julia")
+    )
+    tEnv.executeSql(s"""
+                       |CREATE TABLE pk_src (
+                       |  id int primary key not enforced,
+                       |  name string
+                       |) with (
+                       |  'connector' = 'values',
+                       |  'changelog-mode' = 'I,UA,UB,D',
+                       |  'failing-source' = 'true',
+                       |  'data-id' = '${TestValuesTableFactory.registerData(data)}'
+                       |)
+                       |""".stripMargin)
+
+    tEnv.executeSql(s"""
+                       |CREATE TABLE pk_snk (
+                       |  id int primary key not enforced,
+                       |  name string
+                       |) with (
+                       |  'connector' = 'values',
+                       |  'sink-insert-only' = 'false',
+                       |  'sink-changelog-mode-enforced' = 'I,UA,D'
+                       |)
+                       |""".stripMargin)
+
+    tEnv
+      .executeSql("""
+                    |INSERT INTO pk_snk SELECT * FROM pk_src where name <> 'unknown';
+                    |""".stripMargin)
+      .await()
+
+    val expected = List("+I[1, Ketty]", "+I[4, Julia]")
+
+    assertThat(TestValuesTableFactory.getResultsAsStrings("pk_snk").sorted)
+      .isEqualTo(expected.sorted)
+  }
 }
