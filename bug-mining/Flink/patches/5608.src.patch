diff --git a/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java b/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java
index 70b992573fa..49e8a9859ce 100644
--- a/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java
+++ b/flink-clients/src/main/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrap.java
@@ -30,6 +30,7 @@ import org.apache.flink.client.program.PackagedProgram;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.PipelineOptionsInternal;
 import org.apache.flink.core.execution.PipelineExecutorServiceLoader;
+import org.apache.flink.runtime.client.DuplicateJobSubmissionException;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.dispatcher.DispatcherBootstrap;
 import org.apache.flink.runtime.dispatcher.DispatcherGateway;
@@ -37,6 +38,7 @@ import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobmanager.HighAvailabilityMode;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.messages.Acknowledge;
+import org.apache.flink.runtime.messages.FlinkJobNotFoundException;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
@@ -48,8 +50,11 @@ import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.ScheduledFuture;
@@ -144,21 +149,19 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
             final DispatcherGateway dispatcherGateway) {
         return applicationCompletionFuture
                 .handle(
-                        (r, t) -> {
+                        (ignored, t) -> {
                             if (t == null) {
                                 LOG.info("Application completed SUCCESSFULLY");
                                 return dispatcherGateway.shutDownCluster(
                                         ApplicationStatus.SUCCEEDED);
                             }
 
-                            final Optional<UnsuccessfulExecutionException> exception =
+                            final Optional<UnsuccessfulExecutionException> maybeException =
                                     ExceptionUtils.findThrowable(
                                             t, UnsuccessfulExecutionException.class);
-
-                            if (exception.isPresent()) {
+                            if (maybeException.isPresent()) {
                                 final ApplicationStatus applicationStatus =
-                                        exception.get().getStatus();
-
+                                        maybeException.get().getStatus();
                                 if (applicationStatus == ApplicationStatus.CANCELED
                                         || applicationStatus == ApplicationStatus.FAILED) {
                                     LOG.info("Application {}: ", applicationStatus, t);
@@ -203,6 +206,7 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
             final ScheduledExecutor scheduledExecutor,
             final boolean enforceSingleJobExecution) {
         final CompletableFuture<List<JobID>> applicationExecutionFuture = new CompletableFuture<>();
+        final Set<JobID> tolerateMissingResult = Collections.synchronizedSet(new HashSet<>());
 
         // we need to hand in a future as return value because we need to get those JobIs out
         // from the scheduled task that executes the user program
@@ -211,6 +215,7 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
                         () ->
                                 runApplicationEntryPoint(
                                         applicationExecutionFuture,
+                                        tolerateMissingResult,
                                         dispatcherGateway,
                                         scheduledExecutor,
                                         enforceSingleJobExecution),
@@ -218,7 +223,12 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
                         TimeUnit.MILLISECONDS);
 
         return applicationExecutionFuture.thenCompose(
-                jobIds -> getApplicationResult(dispatcherGateway, jobIds, scheduledExecutor));
+                jobIds ->
+                        getApplicationResult(
+                                dispatcherGateway,
+                                jobIds,
+                                tolerateMissingResult,
+                                scheduledExecutor));
     }
 
     /**
@@ -229,6 +239,7 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
      */
     private void runApplicationEntryPoint(
             final CompletableFuture<List<JobID>> jobIdsFuture,
+            final Set<JobID> tolerateMissingResult,
             final DispatcherGateway dispatcherGateway,
             final ScheduledExecutor scheduledExecutor,
             final boolean enforceSingleJobExecution) {
@@ -254,21 +265,38 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
                 jobIdsFuture.complete(applicationJobIds);
             }
         } catch (Throwable t) {
-            jobIdsFuture.completeExceptionally(
-                    new ApplicationExecutionException("Could not execute application.", t));
+            // If we're running in a single job execution mode, it's safe to consider re-submission
+            // of an already finished a success.
+            final Optional<DuplicateJobSubmissionException> maybeDuplicate =
+                    ExceptionUtils.findThrowable(t, DuplicateJobSubmissionException.class);
+            if (enforceSingleJobExecution
+                    && maybeDuplicate.isPresent()
+                    && maybeDuplicate.get().isTerminated()) {
+                final JobID jobId = maybeDuplicate.get().getJobID();
+                tolerateMissingResult.add(jobId);
+                jobIdsFuture.complete(Collections.singletonList(jobId));
+            } else {
+                jobIdsFuture.completeExceptionally(
+                        new ApplicationExecutionException("Could not execute application.", t));
+            }
         }
     }
 
     private CompletableFuture<Void> getApplicationResult(
             final DispatcherGateway dispatcherGateway,
             final Collection<JobID> applicationJobIds,
+            final Set<JobID> tolerateMissingResult,
             final ScheduledExecutor executor) {
         final List<CompletableFuture<?>> jobResultFutures =
                 applicationJobIds.stream()
                         .map(
                                 jobId ->
                                         unwrapJobResultException(
-                                                getJobResult(dispatcherGateway, jobId, executor)))
+                                                getJobResult(
+                                                        dispatcherGateway,
+                                                        jobId,
+                                                        executor,
+                                                        tolerateMissingResult.contains(jobId))))
                         .collect(Collectors.toList());
         return FutureUtils.waitForAll(jobResultFutures);
     }
@@ -276,15 +304,28 @@ public class ApplicationDispatcherBootstrap implements DispatcherBootstrap {
     private CompletableFuture<JobResult> getJobResult(
             final DispatcherGateway dispatcherGateway,
             final JobID jobId,
-            final ScheduledExecutor scheduledExecutor) {
-
+            final ScheduledExecutor scheduledExecutor,
+            final boolean tolerateMissingResult) {
         final Time timeout =
                 Time.milliseconds(configuration.get(ClientOptions.CLIENT_TIMEOUT).toMillis());
         final Time retryPeriod =
                 Time.milliseconds(configuration.get(ClientOptions.CLIENT_RETRY_PERIOD).toMillis());
-
-        return JobStatusPollingUtils.getJobResult(
-                dispatcherGateway, jobId, scheduledExecutor, timeout, retryPeriod);
+        final CompletableFuture<JobResult> jobResultFuture =
+                JobStatusPollingUtils.getJobResult(
+                        dispatcherGateway, jobId, scheduledExecutor, timeout, retryPeriod);
+        if (tolerateMissingResult) {
+            // Return "unknown" job result if dispatcher no longer knows the actual result.
+            return FutureUtils.handleException(
+                    jobResultFuture,
+                    FlinkJobNotFoundException.class,
+                    exception ->
+                            new JobResult.Builder()
+                                    .jobId(jobId)
+                                    .applicationStatus(ApplicationStatus.UNKNOWN)
+                                    .netRuntime(Long.MAX_VALUE)
+                                    .build());
+        }
+        return jobResultFuture;
     }
 
     /**
diff --git a/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java b/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java
index eb0e108799c..e1606a14025 100644
--- a/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java
+++ b/flink-clients/src/test/java/org/apache/flink/client/deployment/application/ApplicationDispatcherBootstrapTest.java
@@ -28,6 +28,7 @@ import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.DeploymentOptions;
 import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.configuration.PipelineOptionsInternal;
+import org.apache.flink.runtime.client.DuplicateJobSubmissionException;
 import org.apache.flink.runtime.client.JobCancellationException;
 import org.apache.flink.runtime.client.JobExecutionException;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
@@ -35,6 +36,7 @@ import org.apache.flink.runtime.dispatcher.DispatcherGateway;
 import org.apache.flink.runtime.jobmanager.HighAvailabilityMode;
 import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.messages.Acknowledge;
+import org.apache.flink.runtime.messages.FlinkJobNotFoundException;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.webmonitor.TestingDispatcherGateway;
 import org.apache.flink.util.ExceptionUtils;
@@ -43,6 +45,7 @@ import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.SerializedThrowable;
 import org.apache.flink.util.TestLogger;
+import org.apache.flink.util.concurrent.FutureUtils;
 import org.apache.flink.util.concurrent.ScheduledExecutor;
 import org.apache.flink.util.concurrent.ScheduledExecutorServiceAdapter;
 
@@ -57,6 +60,7 @@ import java.util.Optional;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
@@ -64,7 +68,10 @@ import java.util.concurrent.TimeUnit;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Tests for the {@link ApplicationDispatcherBootstrap}. */
@@ -619,7 +626,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
     }
 
     @Test
-    public void testClusterDoesNOTShutdownWhenApplicationStatusUknown() throws Exception {
+    public void testClusterDoesNotShutdownWhenApplicationStatusUnknown() throws Exception {
         // we're "listening" on this to be completed to verify that the cluster
         // is being shut down from the ApplicationDispatcherBootstrap
         final TestingDispatcherGateway.Builder dispatcherBuilder =
@@ -650,6 +657,129 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         assertEquals(exception.getStatus(), ApplicationStatus.UNKNOWN);
     }
 
+    @Test
+    public void testDuplicateJobSubmissionWithTerminatedJobId() throws Throwable {
+        final JobID testJobID = new JobID(0, 2);
+        final Configuration configurationUnderTest = getConfiguration();
+        configurationUnderTest.set(
+                PipelineOptionsInternal.PIPELINE_FIXED_JOB_ID, testJobID.toHexString());
+        configurationUnderTest.set(
+                HighAvailabilityOptions.HA_MODE, HighAvailabilityMode.ZOOKEEPER.name());
+        final TestingDispatcherGateway.Builder dispatcherBuilder =
+                new TestingDispatcherGateway.Builder()
+                        .setSubmitFunction(
+                                jobGraph ->
+                                        FutureUtils.completedExceptionally(
+                                                new DuplicateJobSubmissionException(
+                                                        testJobID, true)))
+                        .setRequestJobStatusFunction(
+                                jobId -> CompletableFuture.completedFuture(JobStatus.FINISHED))
+                        .setRequestJobResultFunction(
+                                jobId ->
+                                        CompletableFuture.completedFuture(
+                                                createSuccessfulJobResult(jobId)));
+        final CompletableFuture<Void> applicationFuture =
+                runApplication(dispatcherBuilder, configurationUnderTest, 1);
+        applicationFuture.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);
+    }
+
+    /**
+     * In this scenario, job result is no longer present in the {@link
+     * org.apache.flink.runtime.dispatcher.Dispatcher dispatcher} (job has terminated and job
+     * manager failed over), but we know that job has already terminated from {@link
+     * org.apache.flink.runtime.highavailability.RunningJobsRegistry running jobs registry}.
+     */
+    @Test
+    public void testDuplicateJobSubmissionWithTerminatedJobIdWithUnknownResult() throws Throwable {
+        final JobID testJobID = new JobID(0, 2);
+        final Configuration configurationUnderTest = getConfiguration();
+        configurationUnderTest.set(
+                PipelineOptionsInternal.PIPELINE_FIXED_JOB_ID, testJobID.toHexString());
+        configurationUnderTest.set(
+                HighAvailabilityOptions.HA_MODE, HighAvailabilityMode.ZOOKEEPER.name());
+        final TestingDispatcherGateway.Builder dispatcherBuilder =
+                new TestingDispatcherGateway.Builder()
+                        .setSubmitFunction(
+                                jobGraph ->
+                                        FutureUtils.completedExceptionally(
+                                                new DuplicateJobSubmissionException(
+                                                        testJobID, true)))
+                        .setRequestJobStatusFunction(
+                                jobId ->
+                                        FutureUtils.completedExceptionally(
+                                                new FlinkJobNotFoundException(jobId)))
+                        .setRequestJobResultFunction(
+                                jobId ->
+                                        FutureUtils.completedExceptionally(
+                                                new FlinkJobNotFoundException(jobId)));
+        final CompletableFuture<Void> applicationFuture =
+                runApplication(dispatcherBuilder, configurationUnderTest, 1);
+        applicationFuture.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);
+    }
+
+    /**
+     * In this scenario, job result is no longer present in the {@link
+     * org.apache.flink.runtime.dispatcher.Dispatcher dispatcher} (job has terminated and job
+     * manager failed over), but we know that job has already terminated from {@link
+     * org.apache.flink.runtime.highavailability.RunningJobsRegistry running jobs registry}.
+     */
+    @Test
+    public void testDuplicateJobSubmissionWithTerminatedJobIdWithUnknownResultAttached()
+            throws Throwable {
+        final JobID testJobID = new JobID(0, 2);
+        final Configuration configurationUnderTest = getConfiguration();
+        configurationUnderTest.set(
+                PipelineOptionsInternal.PIPELINE_FIXED_JOB_ID, testJobID.toHexString());
+        configurationUnderTest.set(
+                HighAvailabilityOptions.HA_MODE, HighAvailabilityMode.ZOOKEEPER.name());
+        final TestingDispatcherGateway.Builder dispatcherBuilder =
+                new TestingDispatcherGateway.Builder()
+                        .setSubmitFunction(
+                                jobGraph ->
+                                        FutureUtils.completedExceptionally(
+                                                new DuplicateJobSubmissionException(
+                                                        testJobID, true)))
+                        .setRequestJobStatusFunction(
+                                jobId ->
+                                        FutureUtils.completedExceptionally(
+                                                new FlinkJobNotFoundException(jobId)))
+                        .setRequestJobResultFunction(
+                                jobId ->
+                                        FutureUtils.completedExceptionally(
+                                                new FlinkJobNotFoundException(jobId)));
+        final CompletableFuture<Void> applicationFuture =
+                runApplication(dispatcherBuilder, configurationUnderTest, 1);
+        applicationFuture.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void testDuplicateJobSubmissionWithRunningJobId() throws Throwable {
+        final JobID testJobID = new JobID(0, 2);
+        final Configuration configurationUnderTest = getConfiguration();
+        configurationUnderTest.set(
+                PipelineOptionsInternal.PIPELINE_FIXED_JOB_ID, testJobID.toHexString());
+        configurationUnderTest.set(
+                HighAvailabilityOptions.HA_MODE, HighAvailabilityMode.ZOOKEEPER.name());
+        final TestingDispatcherGateway.Builder dispatcherBuilder =
+                new TestingDispatcherGateway.Builder()
+                        .setSubmitFunction(
+                                jobGraph ->
+                                        FutureUtils.completedExceptionally(
+                                                new DuplicateJobSubmissionException(
+                                                        testJobID, false)));
+        final CompletableFuture<Void> applicationFuture =
+                runApplication(dispatcherBuilder, configurationUnderTest, 1);
+        final ExecutionException executionException =
+                assertThrows(
+                        ExecutionException.class,
+                        () -> applicationFuture.get(TIMEOUT_SECONDS, TimeUnit.SECONDS));
+        final Optional<DuplicateJobSubmissionException> maybeDuplicate =
+                ExceptionUtils.findThrowable(
+                        executionException, DuplicateJobSubmissionException.class);
+        assertTrue(maybeDuplicate.isPresent());
+        assertFalse(maybeDuplicate.get().isTerminated());
+    }
+
     private CompletableFuture<Void> runApplication(
             TestingDispatcherGateway.Builder dispatcherBuilder, int noOfJobs)
             throws FlinkException {
@@ -728,7 +858,7 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
                                             .toURI()
                                             .toURL()))
                     .setEntryPointClassName(MULTI_EXECUTE_JOB_CLASS_NAME)
-                    .setArguments(String.valueOf(noOfJobs))
+                    .setArguments(String.valueOf(noOfJobs), Boolean.toString(true))
                     .build();
         } catch (ProgramInvocationException | FileNotFoundException | MalformedURLException e) {
             throw new FlinkException("Could not load the provided entrypoint class.", e);
@@ -780,11 +910,11 @@ public class ApplicationDispatcherBootstrapTest extends TestLogger {
         try {
             future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);
         } catch (Throwable e) {
-            Optional<E> expectionException = ExceptionUtils.findThrowable(e, exceptionClass);
-            if (!expectionException.isPresent()) {
+            Optional<E> maybeException = ExceptionUtils.findThrowable(e, exceptionClass);
+            if (!maybeException.isPresent()) {
                 throw e;
             }
-            return expectionException.get();
+            return maybeException.get();
         }
         throw new Exception(
                 "Future should have completed exceptionally with "
diff --git a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
index c85b7972c90..ee784db0c6c 100644
--- a/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
+++ b/flink-core/src/main/java/org/apache/flink/util/concurrent/FutureUtils.java
@@ -72,7 +72,7 @@ public class FutureUtils {
 
     /**
      * Fakes asynchronous execution by immediately executing the operation and completing the
-     * supplied future either noramlly or exceptionally.
+     * supplied future either normally or exceptionally.
      *
      * @param operation to executed
      * @param <T> type of the result
@@ -1274,9 +1274,9 @@ public class FutureUtils {
      * @return completable future, that can recover from a specified exception
      */
     public static <T, E extends Throwable> CompletableFuture<T> handleException(
-            CompletableFuture<T> completableFuture,
+            CompletableFuture<? extends T> completableFuture,
             Class<E> exceptionClass,
-            Function<E, T> exceptionHandler) {
+            Function<? super E, ? extends T> exceptionHandler) {
         final CompletableFuture<T> handledFuture = new CompletableFuture<>();
         checkNotNull(completableFuture)
                 .whenComplete(
@@ -1284,8 +1284,7 @@ public class FutureUtils {
                             if (throwable == null) {
                                 handledFuture.complete(result);
                             } else if (exceptionClass.isAssignableFrom(throwable.getClass())) {
-                                @SuppressWarnings("unchecked")
-                                final E exception = (E) throwable;
+                                final E exception = exceptionClass.cast(throwable);
                                 try {
                                     handledFuture.complete(exceptionHandler.apply(exception));
                                 } catch (Throwable t) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/client/DuplicateJobSubmissionException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/client/DuplicateJobSubmissionException.java
index b25d824ce27..2ad7097c18f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/client/DuplicateJobSubmissionException.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/client/DuplicateJobSubmissionException.java
@@ -25,7 +25,19 @@ import org.apache.flink.api.common.JobID;
  */
 public class DuplicateJobSubmissionException extends JobSubmissionException {
 
-    public DuplicateJobSubmissionException(JobID jobID) {
+    private final boolean terminated;
+
+    public DuplicateJobSubmissionException(JobID jobID, boolean terminated) {
         super(jobID, "Job has already been submitted.");
+        this.terminated = terminated;
+    }
+
+    /**
+     * Checks whether the duplicate job has already been finished.
+     *
+     * @return true if the job has already finished, either successfully or as a failure
+     */
+    public boolean isTerminated() {
+        return terminated;
     }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index ca865398fe9..cb0db401942 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -302,7 +302,8 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
         try {
             if (isDuplicateJob(jobGraph.getJobID())) {
                 return FutureUtils.completedExceptionally(
-                        new DuplicateJobSubmissionException(jobGraph.getJobID()));
+                        new DuplicateJobSubmissionException(
+                                jobGraph.getJobID(), isTerminated(jobGraph.getJobID())));
             } else if (isPartialResourceConfigured(jobGraph)) {
                 return FutureUtils.completedExceptionally(
                         new JobSubmissionException(
@@ -325,18 +326,26 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
      * @throws FlinkException if the job scheduling status cannot be retrieved
      */
     private boolean isDuplicateJob(JobID jobId) throws FlinkException {
-        final RunningJobsRegistry.JobSchedulingStatus jobSchedulingStatus;
+        return isTerminated(jobId) || runningJobs.containsKey(jobId);
+    }
 
+    /**
+     * Checks whether the given job has already been executed.
+     *
+     * @param jobId identifying the submitted job
+     * @return true if the job has already finished, either successfully or as a failure
+     * @throws FlinkException if the job scheduling status cannot be retrieved
+     */
+    private boolean isTerminated(JobID jobId) throws FlinkException {
         try {
-            jobSchedulingStatus = runningJobsRegistry.getJobSchedulingStatus(jobId);
+            final RunningJobsRegistry.JobSchedulingStatus schedulingStatus =
+                    runningJobsRegistry.getJobSchedulingStatus(jobId);
+            return schedulingStatus == RunningJobsRegistry.JobSchedulingStatus.DONE;
         } catch (IOException e) {
             throw new FlinkException(
                     String.format("Failed to retrieve job scheduling status for job %s.", jobId),
                     e);
         }
-
-        return jobSchedulingStatus == RunningJobsRegistry.JobSchedulingStatus.DONE
-                || runningJobs.containsKey(jobId);
     }
 
     private boolean isPartialResourceConfigured(JobGraph jobGraph) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java
index 727e9f2d15a..36662eade5b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/concurrent/FutureUtilsTest.java
@@ -858,28 +858,29 @@ public class FutureUtilsTest extends TestLogger {
         final CompletableFuture<String> handled =
                 FutureUtils.handleException(
                         future, UnsupportedOperationException.class, exception -> "handled");
-        future.completeExceptionally(new IllegalArgumentException("foobar"));
+        final IllegalArgumentException futureException = new IllegalArgumentException("foobar");
+        future.completeExceptionally(futureException);
         final CompletionException completionException =
                 assertThrows(CompletionException.class, handled::join);
-        assertTrue(completionException.getCause() instanceof IllegalArgumentException);
-        assertEquals("foobar", completionException.getCause().getMessage());
+        assertEquals(futureException, completionException.getCause());
     }
 
     @Test
     public void testHandleExceptionWithThrowingExceptionHandler() {
         final CompletableFuture<String> future = new CompletableFuture<>();
+        final IllegalStateException handlerException =
+                new IllegalStateException("something went terribly wrong");
         final CompletableFuture<String> handled =
                 FutureUtils.handleException(
                         future,
                         UnsupportedOperationException.class,
                         exception -> {
-                            throw new IllegalStateException("something went terribly wrong");
+                            throw handlerException;
                         });
         future.completeExceptionally(new UnsupportedOperationException("foobar"));
         final CompletionException completionException =
                 assertThrows(CompletionException.class, handled::join);
-        assertTrue(completionException.getCause() instanceof IllegalStateException);
-        assertEquals("something went terribly wrong", completionException.getCause().getMessage());
+        assertEquals(handlerException, completionException.getCause());
     }
 
     @Test
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
index 3b7b210242b..3047831e829 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
@@ -32,6 +32,7 @@ import org.apache.flink.runtime.blob.VoidBlobStore;
 import org.apache.flink.runtime.checkpoint.Checkpoints;
 import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
+import org.apache.flink.runtime.client.DuplicateJobSubmissionException;
 import org.apache.flink.runtime.client.JobSubmissionException;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.execution.librarycache.LibraryCacheManager;
@@ -135,7 +136,9 @@ import static org.hamcrest.Matchers.greaterThan;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -264,6 +267,49 @@ public class DispatcherTest extends TestLogger {
                 jobMasterLeaderElectionService.getStartFuture().isDone());
     }
 
+    @Test
+    public void testDuplicateJobSubmissionWithGloballyTerminatedJobId() throws Exception {
+        haServices.getRunningJobsRegistry().setJobFinished(jobGraph.getJobID());
+        dispatcher =
+                createAndStartDispatcher(
+                        heartbeatServices,
+                        haServices,
+                        new ExpectedJobIdJobManagerRunnerFactory(
+                                jobId, createdJobManagerRunnerLatch));
+        final DispatcherGateway dispatcherGateway =
+                dispatcher.getSelfGateway(DispatcherGateway.class);
+        final CompletableFuture<Acknowledge> submitFuture =
+                dispatcherGateway.submitJob(jobGraph, TIMEOUT);
+        final ExecutionException executionException =
+                assertThrows(ExecutionException.class, submitFuture::get);
+        assertTrue(executionException.getCause() instanceof DuplicateJobSubmissionException);
+        final DuplicateJobSubmissionException duplicateException =
+                (DuplicateJobSubmissionException) executionException.getCause();
+        assertTrue(duplicateException.isTerminated());
+    }
+
+    @Test
+    public void testDuplicateJobSubmissionWithRunningJobId() throws Exception {
+        dispatcher =
+                new TestingDispatcherBuilder()
+                        .setJobManagerRunnerFactory(
+                                new ExpectedJobIdJobManagerRunnerFactory(
+                                        jobId, createdJobManagerRunnerLatch))
+                        .setInitialJobGraphs(Collections.singleton(jobGraph))
+                        .build();
+        dispatcher.start();
+        final DispatcherGateway dispatcherGateway =
+                dispatcher.getSelfGateway(DispatcherGateway.class);
+        final CompletableFuture<Acknowledge> submitFuture =
+                dispatcherGateway.submitJob(jobGraph, TIMEOUT);
+        final ExecutionException executionException =
+                assertThrows(ExecutionException.class, submitFuture::get);
+        assertTrue(executionException.getCause() instanceof DuplicateJobSubmissionException);
+        final DuplicateJobSubmissionException duplicateException =
+                (DuplicateJobSubmissionException) executionException.getCause();
+        assertFalse(duplicateException.isTerminated());
+    }
+
     /**
      * Tests that we can submit a job to the Dispatcher which then spawns a new JobManagerRunner.
      */
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java
index 4593f03ad18..48a54a8b7cd 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/SessionDispatcherLeaderProcessTest.java
@@ -571,7 +571,7 @@ public class SessionDispatcherLeaderProcessTest extends TestLogger {
                                 jobGraph ->
                                         FutureUtils.completedExceptionally(
                                                 new DuplicateJobSubmissionException(
-                                                        jobGraph.getJobID())))
+                                                        jobGraph.getJobID(), false)))
                         .build();
 
         runOnAddedJobGraphTest(dispatcherGateway, this::verifyOnAddedJobGraphResultDidNotFail);
