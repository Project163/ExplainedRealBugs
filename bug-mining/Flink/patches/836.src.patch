diff --git a/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/BackPressureStatsTracker.java b/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/BackPressureStatsTracker.java
index 3eb2f580573..b9b8a47c5d7 100644
--- a/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/BackPressureStatsTracker.java
+++ b/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/BackPressureStatsTracker.java
@@ -25,6 +25,7 @@ import com.google.common.collect.Maps;
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
 import org.apache.flink.runtime.executiongraph.ExecutionVertex;
+import org.apache.flink.runtime.jobgraph.JobStatus;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import scala.Option;
@@ -237,11 +238,15 @@ public class BackPressureStatsTracker {
 						return;
 					}
 
-					if (success != null) {
+					// Job finished, ignore.
+					JobStatus jobState = vertex.getGraph().getState();
+					if (jobState.isTerminalState()) {
+						LOG.debug("Ignoring sample, because job is in state " + jobState + ".");
+					} else if (success != null) {
 						OperatorBackPressureStats stats = createStatsFromSample(success);
 						operatorStatsCache.put(vertex, stats);
 					} else {
-						LOG.error("Failed to gather stack trace sample.", failure);
+						LOG.warn("Failed to gather stack trace sample.", failure);
 					}
 				} catch (Throwable t) {
 					LOG.error("Error during stats completion.", t);
diff --git a/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/StackTraceSample.java b/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/StackTraceSample.java
index e86126523db..c2906d40e71 100644
--- a/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/StackTraceSample.java
+++ b/flink-runtime-web/src/main/java/org/apache/flink/runtime/webmonitor/StackTraceSample.java
@@ -108,4 +108,12 @@ public class StackTraceSample {
 		return stackTracesByTask;
 	}
 
+	@Override
+	public String toString() {
+		return "StackTraceSample{" +
+				"sampleId=" + sampleId +
+				", startTime=" + startTime +
+				", endTime=" + endTime +
+				'}';
+	}
 }
diff --git a/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/StackTraceSampleCoordinatorITCase.java b/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/StackTraceSampleCoordinatorITCase.java
new file mode 100644
index 00000000000..63c3712e2b5
--- /dev/null
+++ b/flink-runtime-web/src/test/java/org/apache/flink/runtime/webmonitor/StackTraceSampleCoordinatorITCase.java
@@ -0,0 +1,179 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.webmonitor;
+
+import akka.actor.ActorSystem;
+import akka.testkit.JavaTestKit;
+import org.apache.flink.configuration.ConfigConstants;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.akka.AkkaUtils;
+import org.apache.flink.runtime.client.JobClient;
+import org.apache.flink.runtime.executiongraph.ExecutionGraph;
+import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
+import org.apache.flink.runtime.instance.ActorGateway;
+import org.apache.flink.runtime.instance.AkkaActorGateway;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobmanager.Tasks;
+import org.apache.flink.runtime.messages.JobManagerMessages;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;
+import org.apache.flink.runtime.testingUtils.TestingUtils;
+import org.apache.flink.util.TestLogger;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import scala.concurrent.Await;
+import scala.concurrent.Future;
+import scala.concurrent.duration.FiniteDuration;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.apache.flink.runtime.testingUtils.TestingJobManagerMessages.AllVerticesRunning;
+import static org.apache.flink.runtime.testingUtils.TestingJobManagerMessages.ExecutionGraphFound;
+import static org.apache.flink.runtime.testingUtils.TestingJobManagerMessages.RequestExecutionGraph;
+import static org.apache.flink.runtime.testingUtils.TestingJobManagerMessages.WaitForAllVerticesToBeRunning;
+import static org.junit.Assert.fail;
+
+/**
+ * Simple stack trace sampling test.
+ */
+public class StackTraceSampleCoordinatorITCase extends TestLogger {
+
+	private static ActorSystem testActorSystem;
+
+	@BeforeClass
+	public static void setup() {
+		testActorSystem = AkkaUtils.createLocalActorSystem(new Configuration());
+	}
+
+	@AfterClass
+	public static void teardown() {
+		JavaTestKit.shutdownActorSystem(testActorSystem);
+	}
+
+	/**
+	 * Tests that a cleared task is answered with a partial success response.
+	 */
+	@Test
+	public void testTaskClearedWhileSampling() throws Exception {
+		new JavaTestKit(testActorSystem) {{
+			final FiniteDuration deadline = new FiniteDuration(60, TimeUnit.SECONDS);
+
+			// The JobGraph
+			final JobGraph jobGraph = new JobGraph();
+			final int parallelism = 1;
+
+			final JobVertex task = new JobVertex("Task");
+			task.setInvokableClass(Tasks.BlockingNoOpInvokable.class);
+			task.setParallelism(parallelism);
+
+			jobGraph.addVertex(task);
+
+			ActorGateway jobManger = null;
+			ActorGateway taskManager = null;
+
+			try {
+				jobManger = TestingUtils.createJobManager(testActorSystem, new Configuration());
+
+				Configuration config = new Configuration();
+				config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, parallelism);
+
+				taskManager = TestingUtils.createTaskManager(
+						testActorSystem, jobManger, config, true, true);
+
+				final ActorGateway jm = jobManger;
+
+				new Within(deadline) {
+					@Override
+					protected void run() {
+						try {
+							ActorGateway testActor = new AkkaActorGateway(getTestActor(), null);
+
+							int maxAttempts = 10;
+							int sleepTime = 100;
+
+							for (int i = 0; i < maxAttempts; i++, sleepTime *= 2) {
+								// Submit the job and wait until it is running
+								JobClient.submitJobDetached(
+										jm,
+										jobGraph,
+										deadline,
+										ClassLoader.getSystemClassLoader());
+
+								jm.tell(new WaitForAllVerticesToBeRunning(jobGraph.getJobID()), testActor);
+
+								expectMsgEquals(new AllVerticesRunning(jobGraph.getJobID()));
+
+								// Get the ExecutionGraph
+								jm.tell(new RequestExecutionGraph(jobGraph.getJobID()), testActor);
+								ExecutionGraphFound executionGraphResponse =
+										expectMsgClass(ExecutionGraphFound.class);
+								ExecutionGraph executionGraph = executionGraphResponse.executionGraph();
+								ExecutionJobVertex vertex = executionGraph.getJobVertex(task.getID());
+
+								StackTraceSampleCoordinator coordinator = new StackTraceSampleCoordinator(
+										testActorSystem, 60000);
+
+								Future<?> sampleFuture = coordinator.triggerStackTraceSample(
+										vertex.getTaskVertices(),
+										// Do this often so we have a good
+										// chance of removing the job during
+										// sampling.
+										Integer.MAX_VALUE,
+										new FiniteDuration(10, TimeUnit.MILLISECONDS),
+										0);
+
+								// Wait before cancelling so that some samples
+								// are actually taken.
+								Thread.sleep(sleepTime);
+
+								// Cancel job
+								Future<?> removeFuture = jm.ask(
+										new TestingJobManagerMessages.NotifyWhenJobRemoved(jobGraph.getJobID()),
+										remaining());
+
+								jm.tell(new JobManagerMessages.CancelJob(jobGraph.getJobID()));
+
+								try {
+									// Throws Exception on failure
+									Await.result(sampleFuture, remaining());
+
+									// OK, we are done. Got the expected
+									// partial result.
+									break;
+								} catch (Throwable t) {
+									// We were too fast in cancelling the job.
+									// Fall through and retry.
+								} finally {
+									Await.ready(removeFuture, remaining());
+								}
+							}
+						} catch (Exception e) {
+							e.printStackTrace();
+							fail(e.getMessage());
+						}
+					}
+				};
+			} finally {
+				TestingUtils.stopActor(jobManger);
+				TestingUtils.stopActor(taskManager);
+			}
+		}};
+	}
+}
diff --git a/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManager.scala b/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManager.scala
index 16b70629dd1..8745f26cb81 100644
--- a/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManager.scala
+++ b/flink-runtime/src/main/scala/org/apache/flink/runtime/taskmanager/TaskManager.scala
@@ -729,19 +729,16 @@ class TaskManager(
                   // ---- Done ----
                   log.debug(s"Done with stack trace sample $sampleId.")
 
-                  sender ! ResponseStackTraceSampleSuccess(
-                    sampleId,
-                    executionId,
-                    currentTraces)
+                  sender ! ResponseStackTraceSampleSuccess(sampleId, executionId, currentTraces)
                 }
 
               case None =>
-                if (currentTraces.size() == 0) {
+                if (currentTraces.isEmpty()) {
                   throw new IllegalStateException(s"Cannot sample task $executionId. " +
                     s"Either the task is not known to the task manager or it is not running.")
                 } else {
-                  throw new IllegalStateException(s"Cannot sample task $executionId. " +
-                    s"Task was removed after ${currentTraces.size()} sample(s).")
+                  // Task removed during sampling. Reply with partial result.
+                  sender ! ResponseStackTraceSampleSuccess(sampleId, executionId, currentTraces)
                 }
             }
           } else {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskManagerTest.java
index a014d3dc1be..cccd32558a9 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskManagerTest.java
@@ -60,6 +60,7 @@ import org.apache.flink.runtime.messages.TaskMessages.PartitionState;
 import org.apache.flink.runtime.messages.TaskMessages.StopTask;
 import org.apache.flink.runtime.messages.TaskMessages.SubmitTask;
 import org.apache.flink.runtime.messages.TaskMessages.TaskOperationResult;
+import org.apache.flink.runtime.testingUtils.TestingJobManagerMessages;
 import org.apache.flink.runtime.testingUtils.TestingTaskManagerMessages;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.testutils.StoppableInvokable;
@@ -98,7 +99,7 @@ import static org.junit.Assert.fail;
 public class TaskManagerTest extends TestLogger {
 
 	private static final Logger LOG = LoggerFactory.getLogger(TaskManagerTest.class);
-	
+
 	private static final FiniteDuration timeout = new FiniteDuration(1, TimeUnit.MINUTES);
 
 	private static final FiniteDuration d = new FiniteDuration(20, TimeUnit.SECONDS);
@@ -116,7 +117,7 @@ public class TaskManagerTest extends TestLogger {
 	public static void teardown() {
 		JavaTestKit.shutdownActorSystem(system);
 	}
-	
+
 	@Test
 	public void testSubmitAndExecuteTask() {
 		new JavaTestKit(system){{
@@ -126,7 +127,7 @@ public class TaskManagerTest extends TestLogger {
 					system,
 					getTestActor(),
 					Option.<String>empty());
-			
+
 			try {
 				taskManager = TestingUtils.createTaskManager(
 						system,
@@ -136,13 +137,13 @@ public class TaskManagerTest extends TestLogger {
 						false);
 
 				final ActorGateway tm = taskManager;
-				
+
 				// handle the registration
 				new Within(d) {
 					@Override
 					protected void run() {
 						expectMsgClass(RegistrationMessages.RegisterTaskManager.class);
-						
+
 						final InstanceID iid = new InstanceID();
 						assertEquals(tm.actor(), getLastSender());
 						tm.tell(
@@ -163,13 +164,13 @@ public class TaskManagerTest extends TestLogger {
 						Collections.<InputGateDeploymentDescriptor>emptyList(),
 						new ArrayList<BlobKey>(), Collections.<URL>emptyList(), 0);
 
-				
+
 				new Within(d) {
 
 					@Override
 					protected void run() {
 						tm.tell(new SubmitTask(tdd), jobManager);
-						
+
 						// TaskManager should acknowledge the submission
 						// heartbeats may be interleaved
 						long deadline = System.currentTimeMillis() + 10000;
@@ -187,7 +188,7 @@ public class TaskManagerTest extends TestLogger {
 						// task should have switched to finished
 						Object toFinished = new TaskMessages.UpdateTaskExecutionState(
 										new TaskExecutionState(jid, eid, ExecutionState.FINISHED));
-						
+
 						deadline = System.currentTimeMillis() + 10000;
 						do {
 							Object message = receiveOne(d);
@@ -209,8 +210,8 @@ public class TaskManagerTest extends TestLogger {
 								fail("Unexpected message: " + message);
 							}
 						} while (System.currentTimeMillis() < deadline);
-						
-						
+
+
 					}
 				};
 			}
@@ -225,7 +226,7 @@ public class TaskManagerTest extends TestLogger {
 			}
 		}};
 	}
-	
+
 	@Test
 	public void testJobSubmissionAndCanceling() {
 		new JavaTestKit(system){{
@@ -291,7 +292,7 @@ public class TaskManagerTest extends TestLogger {
 
 							Await.ready(t1Running, d);
 							Await.ready(t2Running, d);
-							
+
 							tm.tell(TestingTaskManagerMessages.getRequestRunningTasksMessage(), testActorGateway);
 
 							Map<ExecutionAttemptID, Task> runningTasks = expectMsgClass(TestingTaskManagerMessages
@@ -569,7 +570,7 @@ public class TaskManagerTest extends TestLogger {
 			}
 		}};
 	}
-	
+
 	@Test
 	public void testRunJobWithForwardChannel() {
 		new JavaTestKit(system){{
@@ -648,7 +649,7 @@ public class TaskManagerTest extends TestLogger {
 							// only now (after the sender is running), submit the receiver task
 							tm.tell(new SubmitTask(tdd2), testActorGateway);
 							expectMsgEquals(Messages.getAcknowledge());
-							
+
 							// wait until the receiver task is running
 							Await.ready(t2Running, d);
 
@@ -698,7 +699,7 @@ public class TaskManagerTest extends TestLogger {
 			}
 		}};
 	}
-	
+
 	@Test
 	public void testCancellingDependentAndStateUpdateFails() {
 		// this tests creates two tasks. the sender sends data, and fails to send the
@@ -1009,7 +1010,7 @@ public class TaskManagerTest extends TestLogger {
 
 						// The task should fail after repeated requests
 						assertEquals(msg.getExecutionState(), ExecutionState.FAILED);
-						
+
 						Throwable error = msg.getError(getClass().getClassLoader());
 						if (error.getClass() != PartitionNotFoundException.class) {
 							error.printStackTrace();
@@ -1041,10 +1042,11 @@ public class TaskManagerTest extends TestLogger {
 	public void testTriggerStackTraceSampleMessage() throws Exception {
 		new JavaTestKit(system) {{
 			ActorGateway taskManagerActorGateway = null;
-			ActorGateway jobManagerActorGateway = TestingUtils.createForwardingJobManager(
-					system,
-					getTestActor(),
-					Option.<String>empty());
+
+			// We need this to be a JM that answers to update messages for
+			// robustness on Travis (if jobs need to be resubmitted in (4)).
+			ActorRef jm = system.actorOf(Props.create(new SimpleLookupJobManagerCreator(null)));
+			ActorGateway jobManagerActorGateway = new AkkaActorGateway(jm, null);
 
 			final ActorGateway testActorGateway = new AkkaActorGateway(
 					getTestActor(),
@@ -1059,18 +1061,6 @@ public class TaskManagerTest extends TestLogger {
 						true,
 						false);
 
-				// Registration
-				new Within(d) {
-					@Override
-					protected void run() {
-						expectMsgClass(RegistrationMessages.RegisterTaskManager.class);
-						assertEquals(taskManager.actor(), getLastSender());
-
-						taskManager.tell(new RegistrationMessages.AcknowledgeRegistration(
-								new InstanceID(), 12345), jobManager);
-					}
-				};
-
 				// Single blocking task
 				final TaskDeploymentDescriptor tdd = new TaskDeploymentDescriptor(
 						new JobID(),
@@ -1089,6 +1079,11 @@ public class TaskManagerTest extends TestLogger {
 						Collections.<URL>emptyList(),
 						0);
 
+				// Make sure to register
+				Future<?> connectFuture = taskManager.ask(new TestingTaskManagerMessages
+						.NotifyWhenRegisteredAtJobManager(jobManager.actor()), remaining());
+				Await.ready(connectFuture, remaining());
+
 				// Submit the task
 				new Within(d) {
 					@Override
@@ -1219,7 +1214,7 @@ public class TaskManagerTest extends TestLogger {
 				};
 
 				//
-				// 4) Trigger sample for the blocking task with max depth
+				// 3) Trigger sample for the blocking task with max depth
 				//
 				new Within(d) {
 					@Override
@@ -1263,35 +1258,66 @@ public class TaskManagerTest extends TestLogger {
 				};
 
 				//
-				// 5) Trigger sample for the blocking task, but cancel it during sampling
+				// 4) Trigger sample for the blocking task, but cancel it during sampling
 				//
 				new Within(d) {
 					@Override
 					protected void run() {
 						try {
-							// Trigger many samples in order to cancel the task
-							// during a sample
-							taskManager.tell(new TriggerStackTraceSample(
-											0,
-											tdd.getExecutionId(),
-											10000,
-											new FiniteDuration(100, TimeUnit.MILLISECONDS),
-											0),
-									testActorGateway);
+							int maxAttempts = 10;
+							int sleepTime = 100;
+							for (int i = 0; i < maxAttempts; i++, sleepTime *= 2) {
+								// Trigger many samples in order to cancel the task
+								// during a sample
+								taskManager.tell(new TriggerStackTraceSample(
+												44,
+												tdd.getExecutionId(),
+												Integer.MAX_VALUE,
+												new FiniteDuration(10, TimeUnit.MILLISECONDS),
+												0),
+										testActorGateway);
 
-							// Cancel the task
-							taskManager.tell(new CancelTask(tdd.getExecutionId()));
+								Thread.sleep(sleepTime);
 
-							// Receive the expected message (heartbeat races possible)
-							Object[] msg = receiveN(1);
-							while (!(msg[0] instanceof ResponseStackTraceSampleFailure)) {
-								msg = receiveN(1);
-							}
+								Future<?> removeFuture = taskManager.ask(
+										new TestingJobManagerMessages.NotifyWhenJobRemoved(tdd.getJobID()),
+										remaining());
 
-							ResponseStackTraceSampleFailure response = (ResponseStackTraceSampleFailure) msg[0];
+								// Cancel the task
+								taskManager.tell(new CancelTask(tdd.getExecutionId()));
 
-							assertEquals(tdd.getExecutionId(), response.executionId());
-							assertEquals(IllegalStateException.class, response.cause().getClass());
+								// Receive the expected message (heartbeat races possible)
+								while (true) {
+									Object[] msg = receiveN(1);
+									if (msg[0] instanceof ResponseStackTraceSampleSuccess) {
+										ResponseStackTraceSampleSuccess response = (ResponseStackTraceSampleSuccess) msg[0];
+
+										assertEquals(tdd.getExecutionId(), response.executionId());
+										assertEquals(44, response.sampleId());
+
+										// Done
+										return;
+									} else if (msg[0] instanceof ResponseStackTraceSampleFailure) {
+										// Wait for removal before resubmitting
+										Await.ready(removeFuture, remaining());
+
+										Future<?> taskRunningFuture = taskManager.ask(
+												new TestingTaskManagerMessages.NotifyWhenTaskIsRunning(
+														tdd.getExecutionId()), timeout);
+
+										// Resubmit
+										taskManager.tell(new SubmitTask(tdd));
+
+										Await.ready(taskRunningFuture, remaining());
+
+										// Retry the sample message
+										break;
+									} else {
+										// Different message
+										continue;
+									}
+								}
+							}
 						} catch (Exception e) {
 							e.printStackTrace();
 							fail(e.getMessage());
