diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
index f615b2de699..c1071740095 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultScheduler.java
@@ -88,8 +88,6 @@ public class DefaultScheduler extends SchedulerBase implements SchedulerOperatio
 
 	private final SchedulingStrategy schedulingStrategy;
 
-	private final ExecutionVertexVersioner executionVertexVersioner;
-
 	private final ExecutionVertexOperations executionVertexOperations;
 
 	public DefaultScheduler(
@@ -133,6 +131,7 @@ public class DefaultScheduler extends SchedulerBase implements SchedulerOperatio
 			slotRequestTimeout,
 			shuffleMaster,
 			partitionTracker,
+			executionVertexVersioner,
 			false);
 
 		this.log = log;
@@ -140,7 +139,6 @@ public class DefaultScheduler extends SchedulerBase implements SchedulerOperatio
 		this.delayExecutor = checkNotNull(delayExecutor);
 		this.userCodeLoader = checkNotNull(userCodeLoader);
 		this.executionVertexOperations = checkNotNull(executionVertexOperations);
-		this.executionVertexVersioner = checkNotNull(executionVertexVersioner);
 
 		final FailoverStrategy failoverStrategy = failoverStrategyFactory.create(
 			getFailoverTopology(),
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LegacyScheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LegacyScheduler.java
index cc52928abac..86da9c341bd 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LegacyScheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LegacyScheduler.java
@@ -79,6 +79,7 @@ public class LegacyScheduler extends SchedulerBase {
 			slotRequestTimeout,
 			shuffleMaster,
 			partitionTracker,
+			new ExecutionVertexVersioner(),
 			true);
 	}
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
index 16eaab6ef5e..aaa1a32c20f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
@@ -19,6 +19,7 @@
 
 package org.apache.flink.runtime.scheduler;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.restartstrategy.RestartStrategies;
@@ -80,6 +81,7 @@ import org.apache.flink.runtime.query.UnknownKvStateLocation;
 import org.apache.flink.runtime.rest.handler.legacy.backpressure.BackPressureStatsTracker;
 import org.apache.flink.runtime.rest.handler.legacy.backpressure.OperatorBackPressureStats;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;
 import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;
 import org.apache.flink.runtime.shuffle.ShuffleMaster;
 import org.apache.flink.runtime.state.KeyGroupRange;
@@ -88,6 +90,7 @@ import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
 import org.apache.flink.runtime.webmonitor.WebMonitorUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.InstantiationUtil;
+import org.apache.flink.util.IterableUtils;
 import org.apache.flink.util.function.FunctionUtils;
 
 import org.slf4j.Logger;
@@ -97,12 +100,14 @@ import java.net.InetSocketAddress;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
+import java.util.stream.Collectors;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
@@ -150,6 +155,8 @@ public abstract class SchedulerBase implements SchedulerNG {
 
 	private final boolean legacyScheduling;
 
+	protected final ExecutionVertexVersioner executionVertexVersioner;
+
 	private ComponentMainThreadExecutor mainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(
 		"SchedulerBase is not initialized with proper main thread executor. " +
 			"Call to SchedulerBase.setMainThreadExecutor(...) required.");
@@ -171,6 +178,7 @@ public abstract class SchedulerBase implements SchedulerNG {
 		final Time slotRequestTimeout,
 		final ShuffleMaster<?> shuffleMaster,
 		final JobMasterPartitionTracker partitionTracker,
+		final ExecutionVertexVersioner executionVertexVersioner,
 		final boolean legacyScheduling) throws Exception {
 
 		this.log = checkNotNull(log);
@@ -200,6 +208,7 @@ public abstract class SchedulerBase implements SchedulerNG {
 		this.blobWriter = checkNotNull(blobWriter);
 		this.jobManagerJobMetricGroup = checkNotNull(jobManagerJobMetricGroup);
 		this.slotRequestTimeout = checkNotNull(slotRequestTimeout);
+		this.executionVertexVersioner = checkNotNull(executionVertexVersioner);
 		this.legacyScheduling = legacyScheduling;
 
 		this.executionGraph = createAndRestoreExecutionGraph(jobManagerJobMetricGroup, checkNotNull(shuffleMaster), checkNotNull(partitionTracker));
@@ -349,6 +358,7 @@ public abstract class SchedulerBase implements SchedulerNG {
 	}
 
 	protected void failJob(Throwable cause) {
+		incrementVersionsOfAllVertices();
 		executionGraph.failJob(cause);
 	}
 
@@ -397,6 +407,18 @@ public abstract class SchedulerBase implements SchedulerNG {
 
 	protected abstract long getNumberOfRestarts();
 
+	private Map<ExecutionVertexID, ExecutionVertexVersion> incrementVersionsOfAllVertices() {
+		return executionVertexVersioner.recordVertexModifications(
+			IterableUtils.toStream(schedulingTopology.getVertices())
+				.map(SchedulingExecutionVertex::getId)
+				.collect(Collectors.toSet()));
+	}
+
+	@VisibleForTesting
+	ExecutionVertexVersioner getExecutionVertexVersioner() {
+		return executionVertexVersioner;
+	}
+
 	// ------------------------------------------------------------------------
 	// SchedulerNG
 	// ------------------------------------------------------------------------
@@ -429,12 +451,16 @@ public abstract class SchedulerBase implements SchedulerNG {
 	@Override
 	public void suspend(Throwable cause) {
 		mainThreadExecutor.assertRunningInMainThread();
+
+		incrementVersionsOfAllVertices();
 		executionGraph.suspend(cause);
 	}
 
 	@Override
 	public void cancel() {
 		mainThreadExecutor.assertRunningInMainThread();
+
+		incrementVersionsOfAllVertices();
 		executionGraph.cancel();
 	}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
index 0e76a26a2c1..def728e8ee8 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
@@ -550,6 +550,53 @@ public class DefaultSchedulerTest extends TestLogger {
 		assertThat(duration, lessThan(timeout));
 	}
 
+	@Test
+	public void failJobWillIncrementVertexVersions() {
+		final JobGraph jobGraph = singleNonParallelJobVertexJobGraph();
+		final JobVertex onlyJobVertex = getOnlyJobVertex(jobGraph);
+		final ExecutionVertexID onlyExecutionVertexId = new ExecutionVertexID(onlyJobVertex.getID(), 0);
+
+		// suppress restarts so any task failure will lead to job failure
+		testRestartBackoffTimeStrategy.setCanRestart(false);
+		final DefaultScheduler scheduler = createSchedulerAndStartScheduling(jobGraph);
+
+		final ArchivedExecutionVertex archivedExecutionVertex = Iterables.getOnlyElement(scheduler.requestJob().getAllExecutionVertices());
+		final ExecutionAttemptID attemptId = archivedExecutionVertex.getCurrentExecutionAttempt().getAttemptId();
+
+		scheduler.updateTaskExecutionState(new TaskExecutionState(jobGraph.getJobID(), attemptId, ExecutionState.FAILED));
+
+		final ExecutionVertexVersioner executionVertexVersioner = scheduler.getExecutionVertexVersioner();
+		assertTrue(executionVertexVersioner.isModified(new ExecutionVertexVersion(onlyExecutionVertexId, 1)));
+	}
+
+	@Test
+	public void cancelJobWillIncrementVertexVersions() {
+		final JobGraph jobGraph = singleNonParallelJobVertexJobGraph();
+		final JobVertex onlyJobVertex = getOnlyJobVertex(jobGraph);
+		final ExecutionVertexID onlyExecutionVertexId = new ExecutionVertexID(onlyJobVertex.getID(), 0);
+
+		final DefaultScheduler scheduler = createSchedulerAndStartScheduling(jobGraph);
+
+		scheduler.cancel();
+
+		final ExecutionVertexVersioner executionVertexVersioner = scheduler.getExecutionVertexVersioner();
+		assertTrue(executionVertexVersioner.isModified(new ExecutionVertexVersion(onlyExecutionVertexId, 1)));
+	}
+
+	@Test
+	public void suspendJobWillIncrementVertexVersions() {
+		final JobGraph jobGraph = singleNonParallelJobVertexJobGraph();
+		final JobVertex onlyJobVertex = getOnlyJobVertex(jobGraph);
+		final ExecutionVertexID onlyExecutionVertexId = new ExecutionVertexID(onlyJobVertex.getID(), 0);
+
+		final DefaultScheduler scheduler = createSchedulerAndStartScheduling(jobGraph);
+
+		scheduler.suspend(new Exception("forced suspend"));
+
+		final ExecutionVertexVersioner executionVertexVersioner = scheduler.getExecutionVertexVersioner();
+		assertTrue(executionVertexVersioner.isModified(new ExecutionVertexVersion(onlyExecutionVertexId, 1)));
+	}
+
 	private static JobVertex createVertexWithAllInputConstraints(String name, int parallelism) {
 		final JobVertex v = new JobVertex(name);
 		v.setParallelism(parallelism);
