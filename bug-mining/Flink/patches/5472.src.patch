diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java
index c50c9146469..08a6badba18 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java
@@ -114,9 +114,9 @@ public class KubernetesResourceManagerDriver
     }
 
     @Override
-    public CompletableFuture<Void> terminate() {
+    public void terminate() throws Exception {
         if (!running) {
-            return FutureUtils.completedVoidFuture();
+            return;
         }
         running = false;
 
@@ -135,9 +135,9 @@ public class KubernetesResourceManagerDriver
             exception = ExceptionUtils.firstOrSuppressed(e, exception);
         }
 
-        return exception == null
-                ? FutureUtils.completedVoidFuture()
-                : FutureUtils.completedExceptionally(exception);
+        if (exception != null) {
+            throw exception;
+        }
     }
 
     @Override
diff --git a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriver.java b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriver.java
index 8868b608eb8..bd44058ff76 100644
--- a/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriver.java
+++ b/flink-mesos/src/main/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriver.java
@@ -204,15 +204,16 @@ public class MesosResourceManagerDriver
             throw new ResourceManagerException(
                     "Unable to configure the artifact server with TaskManager artifacts.", e);
         }
+
+        onGrantLeadership();
     }
 
     @Override
-    public CompletableFuture<Void> terminate() {
-        return stopSupportingActorsAsync();
+    public void terminate() throws Exception {
+        onRevokeLeadership().get();
     }
 
-    @Override
-    public CompletableFuture<Void> onGrantLeadership() {
+    private void onGrantLeadership() throws Exception {
         Preconditions.checkState(initializedMesosConfig != null);
 
         schedulerDriver =
@@ -228,24 +229,19 @@ public class MesosResourceManagerDriver
                 actorFactory.createReconciliationCoordinator(flinkConfig, schedulerDriver);
         taskMonitor = actorFactory.createTaskMonitor(flinkConfig, selfActor, schedulerDriver);
 
-        return getWorkersAsync()
-                .thenApplyAsync(
-                        (tasksFromPreviousAttempts) -> {
-                            // recover state
-                            recoverWorkers(tasksFromPreviousAttempts);
+        List<MesosWorkerStore.Worker> tasksFromPreviousAttempts = getWorkersAsync().get();
 
-                            // begin scheduling
-                            connectionMonitor.tell(new ConnectionMonitor.Start(), selfActor);
-                            schedulerDriver.start();
+        // recover state
+        recoverWorkers(tasksFromPreviousAttempts);
 
-                            log.info("Mesos resource manager started.");
-                            return null;
-                        },
-                        getMainThreadExecutor());
+        // begin scheduling
+        connectionMonitor.tell(new ConnectionMonitor.Start(), selfActor);
+        schedulerDriver.start();
+
+        log.info("Mesos resource manager started.");
     }
 
-    @Override
-    public CompletableFuture<Void> onRevokeLeadership() {
+    private CompletableFuture<Void> onRevokeLeadership() {
         schedulerDriver.stop(true);
 
         workersInNew.clear();
diff --git a/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriverTest.java b/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriverTest.java
index c8f5c347d2f..9a307302d30 100644
--- a/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriverTest.java
+++ b/flink-mesos/src/test/java/org/apache/flink/mesos/runtime/clusterframework/MesosResourceManagerDriverTest.java
@@ -132,13 +132,13 @@ public class MesosResourceManagerDriverTest
     }
 
     @Test
-    public void testClearStateAfterRevokeLeadership() throws Exception {
+    public void testClearStateAfterTermination() throws Exception {
         new Context() {
             {
                 preparePreviousAttemptWorkers();
                 runTest(
                         () -> {
-                            runInMainThread(() -> getDriver().onRevokeLeadership());
+                            runInMainThread(() -> getDriver().terminate());
 
                             assertThat(
                                     schedulerDriverStopFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
index 421ca45b3c4..b8954d677a8 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
@@ -37,7 +37,6 @@ import org.apache.flink.runtime.heartbeat.HeartbeatManager;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.heartbeat.HeartbeatTarget;
 import org.apache.flink.runtime.heartbeat.NoOpHeartbeatManager;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.instance.InstanceID;
 import org.apache.flink.runtime.io.network.partition.DataSetMetaInfo;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTracker;
@@ -47,8 +46,6 @@ import org.apache.flink.runtime.jobmaster.JobMaster;
 import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
 import org.apache.flink.runtime.jobmaster.JobMasterRegistrationSuccess;
-import org.apache.flink.runtime.leaderelection.LeaderContender;
-import org.apache.flink.runtime.leaderelection.LeaderElectionService;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.metrics.MetricNames;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
@@ -109,8 +106,7 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
  * </ul>
  */
 public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
-        extends FencedRpcEndpoint<ResourceManagerId>
-        implements ResourceManagerGateway, LeaderContender {
+        extends FencedRpcEndpoint<ResourceManagerId> implements ResourceManagerGateway {
 
     public static final String RESOURCE_MANAGER_NAME = "resourcemanager";
 
@@ -133,9 +129,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
     private final Map<ResourceID, CompletableFuture<TaskExecutorGateway>>
             taskExecutorGatewayFutures;
 
-    /** High availability services for leader retrieval and election. */
-    private final HighAvailabilityServices highAvailabilityServices;
-
     private final HeartbeatServices heartbeatServices;
 
     /** Fatal error handler. */
@@ -152,29 +145,17 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
     protected final Executor ioExecutor;
 
-    /** The service to elect a ResourceManager leader. */
-    private LeaderElectionService leaderElectionService;
-
+    private final CompletableFuture<Void> startedFuture;
     /** The heartbeat manager with task managers. */
     private HeartbeatManager<TaskExecutorHeartbeatPayload, Void> taskManagerHeartbeatManager;
 
     /** The heartbeat manager with job managers. */
     private HeartbeatManager<Void, Void> jobManagerHeartbeatManager;
 
-    private boolean hasLeadership = false;
-
-    /**
-     * Represents asynchronous state clearing work.
-     *
-     * @see #clearStateAsync()
-     * @see #clearStateInternal()
-     */
-    private CompletableFuture<Void> clearStateFuture = CompletableFuture.completedFuture(null);
-
     public ResourceManager(
             RpcService rpcService,
+            UUID leaderSessionId,
             ResourceID resourceId,
-            HighAvailabilityServices highAvailabilityServices,
             HeartbeatServices heartbeatServices,
             SlotManager slotManager,
             ResourceManagerPartitionTrackerFactory clusterPartitionTrackerFactory,
@@ -185,10 +166,12 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
             Time rpcTimeout,
             Executor ioExecutor) {
 
-        super(rpcService, AkkaRpcServiceUtils.createRandomName(RESOURCE_MANAGER_NAME), null);
+        super(
+                rpcService,
+                AkkaRpcServiceUtils.createRandomName(RESOURCE_MANAGER_NAME),
+                ResourceManagerId.fromUuid(leaderSessionId));
 
         this.resourceId = checkNotNull(resourceId);
-        this.highAvailabilityServices = checkNotNull(highAvailabilityServices);
         this.heartbeatServices = checkNotNull(heartbeatServices);
         this.slotManager = checkNotNull(slotManager);
         this.jobLeaderIdService = checkNotNull(jobLeaderIdService);
@@ -222,6 +205,8 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                                                                     throwable);
                                                         }));
         this.ioExecutor = ioExecutor;
+
+        this.startedFuture = new CompletableFuture<>();
     }
 
     // ------------------------------------------------------------------------
@@ -233,6 +218,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
         try {
             log.info("Starting the resource manager.");
             startResourceManagerServices();
+            startedFuture.complete(null);
         } catch (Throwable t) {
             final ResourceManagerException exception =
                     new ResourceManagerException(
@@ -245,15 +231,16 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
     private void startResourceManagerServices() throws Exception {
         try {
-            leaderElectionService =
-                    highAvailabilityServices.getResourceManagerLeaderElectionService();
-
-            initialize();
-
-            leaderElectionService.start(this);
             jobLeaderIdService.start(new JobLeaderIdActionsImpl());
 
             registerMetrics();
+
+            startHeartbeatServices();
+
+            slotManager.start(
+                    getFencingToken(), getMainThreadExecutor(), new ResourceActionsImpl());
+
+            initialize();
         } catch (Exception e) {
             handleStartResourceManagerServicesException(e);
         }
@@ -269,6 +256,14 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
         throw e;
     }
 
+    /**
+     * Completion of this future indicates that the resource manager is fully started and is ready
+     * to serve.
+     */
+    public CompletableFuture<Void> getStartedFuture() {
+        return startedFuture;
+    }
+
     @Override
     public final CompletableFuture<Void> onStop() {
         try {
@@ -300,12 +295,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
             exception = ExceptionUtils.firstOrSuppressed(e, exception);
         }
 
-        try {
-            leaderElectionService.stop();
-        } catch (Exception e) {
-            exception = ExceptionUtils.firstOrSuppressed(e, exception);
-        }
-
         try {
             jobLeaderIdService.stop();
         } catch (Exception e) {
@@ -1022,7 +1011,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
                     new ResourceManagerException(
                             "Could not properly clear the job leader id service.", e));
         }
-        clearStateFuture = clearStateAsync();
     }
 
     /**
@@ -1183,99 +1171,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
         fatalErrorHandler.onFatalError(t);
     }
 
-    // ------------------------------------------------------------------------
-    //  Leader Contender
-    // ------------------------------------------------------------------------
-
-    /**
-     * Callback method when current resourceManager is granted leadership.
-     *
-     * @param newLeaderSessionID unique leadershipID
-     */
-    @Override
-    public void grantLeadership(final UUID newLeaderSessionID) {
-        final CompletableFuture<Boolean> acceptLeadershipFuture =
-                clearStateFuture.thenComposeAsync(
-                        (ignored) -> tryAcceptLeadership(newLeaderSessionID),
-                        getUnfencedMainThreadExecutor());
-
-        final CompletableFuture<Void> confirmationFuture =
-                acceptLeadershipFuture.thenAcceptAsync(
-                        (acceptLeadership) -> {
-                            if (acceptLeadership) {
-                                // confirming the leader session ID might be blocking,
-                                leaderElectionService.confirmLeadership(
-                                        newLeaderSessionID, getAddress());
-                            }
-                        },
-                        ioExecutor);
-
-        confirmationFuture.whenComplete(
-                (Void ignored, Throwable throwable) -> {
-                    if (throwable != null) {
-                        onFatalError(ExceptionUtils.stripCompletionException(throwable));
-                    }
-                });
-    }
-
-    private CompletableFuture<Boolean> tryAcceptLeadership(final UUID newLeaderSessionID) {
-        if (leaderElectionService.hasLeadership(newLeaderSessionID)) {
-            final ResourceManagerId newResourceManagerId =
-                    ResourceManagerId.fromUuid(newLeaderSessionID);
-
-            log.info(
-                    "ResourceManager {} was granted leadership with fencing token {}",
-                    getAddress(),
-                    newResourceManagerId);
-
-            // clear the state if we've been the leader before
-            if (getFencingToken() != null) {
-                clearStateInternal();
-            }
-
-            setFencingToken(newResourceManagerId);
-
-            startServicesOnLeadership();
-
-            return prepareLeadershipAsync().thenApply(ignored -> hasLeadership = true);
-        } else {
-            return CompletableFuture.completedFuture(false);
-        }
-    }
-
-    private void startServicesOnLeadership() {
-        startHeartbeatServices();
-
-        slotManager.start(getFencingToken(), getMainThreadExecutor(), new ResourceActionsImpl());
-
-        onLeadership();
-    }
-
-    protected void onLeadership() {
-        // noop by default
-    }
-
-    /** Callback method when current resourceManager loses leadership. */
-    @Override
-    public void revokeLeadership() {
-        runAsyncWithoutFencing(
-                () -> {
-                    hasLeadership = false;
-
-                    log.info(
-                            "ResourceManager {} was revoked leadership. Clearing fencing token.",
-                            getAddress());
-
-                    clearStateInternal();
-
-                    setFencingToken(null);
-
-                    slotManager.suspend();
-
-                    stopHeartbeatServices();
-                });
-    }
-
     private void startHeartbeatServices() {
         taskManagerHeartbeatManager =
                 heartbeatServices.createHeartbeatManagerSender(
@@ -1297,22 +1192,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
         jobManagerHeartbeatManager.stop();
     }
 
-    /**
-     * Handles error occurring in the leader election service.
-     *
-     * @param exception Exception being thrown in the leader election service
-     */
-    @Override
-    public void handleError(final Exception exception) {
-        onFatalError(
-                new ResourceManagerException(
-                        "Received an error from the LeaderElectionService.", exception));
-    }
-
-    protected boolean hasLeadership() {
-        return hasLeadership;
-    }
-
     // ------------------------------------------------------------------------
     //  Framework specific behavior
     // ------------------------------------------------------------------------
@@ -1332,28 +1211,6 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
      */
     protected abstract void terminate() throws Exception;
 
-    /**
-     * This method can be overridden to add a (non-blocking) initialization routine to the
-     * ResourceManager that will be called when leadership is granted but before leadership is
-     * confirmed.
-     *
-     * @return Returns a {@code CompletableFuture} that completes when the computation is finished.
-     */
-    protected CompletableFuture<Void> prepareLeadershipAsync() {
-        return CompletableFuture.completedFuture(null);
-    }
-
-    /**
-     * This method can be overridden to add a (non-blocking) state clearing routine to the
-     * ResourceManager that will be called when leadership is revoked.
-     *
-     * @return Returns a {@code CompletableFuture} that completes when the state clearing routine is
-     *     finished.
-     */
-    protected CompletableFuture<Void> clearStateAsync() {
-        return CompletableFuture.completedFuture(null);
-    }
-
     /**
      * The framework specific code to deregister the application. This should report the
      * application's final status and shut down the resource manager cleanly.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerFactory.java
index b02ee2fd437..fd8a9f6d8e1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerFactory.java
@@ -36,6 +36,7 @@ import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
 
+import java.util.UUID;
 import java.util.concurrent.Executor;
 
 /**
@@ -89,7 +90,8 @@ public abstract class ResourceManagerFactory<T extends ResourceIDRetrievable> {
     }
 
     public ResourceManager<T> createResourceManager(
-            ResourceManagerProcessContext context, ResourceID resourceId) throws Exception {
+            ResourceManagerProcessContext context, UUID leaderSessionId, ResourceID resourceId)
+            throws Exception {
 
         final ResourceManagerRuntimeServices resourceManagerRuntimeServices =
                 createResourceManagerRuntimeServices(
@@ -102,7 +104,7 @@ public abstract class ResourceManagerFactory<T extends ResourceIDRetrievable> {
                 context.getRmConfig(),
                 resourceId,
                 context.getRpcService(),
-                context.getHighAvailabilityServices(),
+                leaderSessionId,
                 context.getHeartbeatServices(),
                 context.getFatalErrorHandler(),
                 context.getClusterInformation(),
@@ -135,7 +137,7 @@ public abstract class ResourceManagerFactory<T extends ResourceIDRetrievable> {
             Configuration configuration,
             ResourceID resourceId,
             RpcService rpcService,
-            HighAvailabilityServices highAvailabilityServices,
+            UUID leaderSessionId,
             HeartbeatServices heartbeatServices,
             FatalErrorHandler fatalErrorHandler,
             ClusterInformation clusterInformation,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImpl.java
index f44dc71bff7..da7dd7c5c02 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImpl.java
@@ -18,6 +18,7 @@
 
 package org.apache.flink.runtime.resourcemanager;
 
+import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
@@ -25,33 +26,63 @@ import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
+import org.apache.flink.runtime.leaderelection.LeaderContender;
+import org.apache.flink.runtime.leaderelection.LeaderElectionService;
 import org.apache.flink.runtime.metrics.MetricRegistry;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.util.ConfigurationException;
 import org.apache.flink.util.FlinkException;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import javax.annotation.Nullable;
 import javax.annotation.concurrent.GuardedBy;
 
+import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /** Default implementation of {@link ResourceManagerService}. */
-public class ResourceManagerServiceImpl implements ResourceManagerService {
+public class ResourceManagerServiceImpl implements ResourceManagerService, LeaderContender {
+
+    public static final String ENABLE_MULTI_LEADER_SESSION_PROPERTY =
+            "flink.tests.enable-rm-multi-leader-session";
+
+    private static final Logger LOG = LoggerFactory.getLogger(ResourceManagerServiceImpl.class);
 
     private final ResourceManagerFactory<?> resourceManagerFactory;
     private final ResourceManagerProcessContext rmProcessContext;
 
-    private final CompletableFuture<Void> terminationFuture;
+    private final LeaderElectionService leaderElectionService;
+    private final FatalErrorHandler fatalErrorHandler;
+    private final Executor ioExecutor;
+
+    private final ExecutorService handleLeaderEventExecutor;
+    private final CompletableFuture<Void> serviceTerminationFuture;
 
     private final Object lock = new Object();
 
+    private final boolean enableMultiLeaderSession;
+
+    @GuardedBy("lock")
+    private boolean running;
+
     @Nullable
     @GuardedBy("lock")
-    private ResourceManager<?> resourceManager;
+    private ResourceManager<?> leaderResourceManager;
+
+    @Nullable
+    @GuardedBy("lock")
+    private UUID leaderSessionID;
+
+    @GuardedBy("lock")
+    private CompletableFuture<Void> previousResourceManagerTerminationFuture;
 
     private ResourceManagerServiceImpl(
             ResourceManagerFactory<?> resourceManagerFactory,
@@ -59,42 +90,62 @@ public class ResourceManagerServiceImpl implements ResourceManagerService {
         this.resourceManagerFactory = checkNotNull(resourceManagerFactory);
         this.rmProcessContext = checkNotNull(rmProcessContext);
 
-        this.terminationFuture = new CompletableFuture<>();
+        this.leaderElectionService =
+                rmProcessContext
+                        .getHighAvailabilityServices()
+                        .getResourceManagerLeaderElectionService();
+        this.fatalErrorHandler = rmProcessContext.getFatalErrorHandler();
+        this.ioExecutor = rmProcessContext.getIoExecutor();
+
+        this.handleLeaderEventExecutor = Executors.newSingleThreadExecutor();
+        this.serviceTerminationFuture = new CompletableFuture<>();
 
-        this.resourceManager = null;
+        this.enableMultiLeaderSession =
+                System.getProperties().containsKey(ENABLE_MULTI_LEADER_SESSION_PROPERTY);
+
+        this.running = false;
+        this.leaderResourceManager = null;
+        this.leaderSessionID = null;
+        this.previousResourceManagerTerminationFuture = FutureUtils.completedVoidFuture();
     }
 
+    // ------------------------------------------------------------------------
+    //  ResourceManagerService
+    // ------------------------------------------------------------------------
+
     @Override
     public void start() throws Exception {
         synchronized (lock) {
-            resourceManager =
-                    resourceManagerFactory.createResourceManager(
-                            rmProcessContext, ResourceID.generate());
+            if (running) {
+                LOG.debug("Resource manager service has already started.");
+                return;
+            }
+            running = true;
+        }
 
-            FutureUtils.forward(resourceManager.getTerminationFuture(), terminationFuture);
+        LOG.info("Starting resource manager service.");
 
-            resourceManager.start();
-        }
+        leaderElectionService.start(this);
     }
 
     @Override
     public CompletableFuture<Void> getTerminationFuture() {
-        return terminationFuture;
+        return serviceTerminationFuture;
     }
 
     @Override
     public CompletableFuture<Void> deregisterApplication(
             final ApplicationStatus applicationStatus, final @Nullable String diagnostics) {
         synchronized (lock) {
-            if (resourceManager != null) {
-                return resourceManager
+            if (running && leaderResourceManager != null) {
+                return leaderResourceManager
                         .getSelfGateway(ResourceManagerGateway.class)
                         .deregisterApplication(applicationStatus, diagnostics)
                         .thenApply(ack -> null);
             } else {
                 return FutureUtils.completedExceptionally(
                         new FlinkException(
-                                "Cannot deregister application. Resource manager service is not started."));
+                                "Cannot deregister application. Resource manager service is not available."));
             }
         }
     }
@@ -102,15 +153,182 @@ public class ResourceManagerServiceImpl implements ResourceManagerService {
     @Override
     public CompletableFuture<Void> closeAsync() {
         synchronized (lock) {
-            if (resourceManager != null) {
-                resourceManager.closeAsync();
+            if (running) {
+                LOG.info("Stopping resource manager service.");
+                running = false;
+                stopLeaderElectionService();
+                stopLeaderResourceManager();
             } else {
-                // resource manager is never started
-                terminationFuture.complete(null);
+                LOG.debug("Resource manager service is not running.");
             }
+
+            FutureUtils.forward(previousResourceManagerTerminationFuture, serviceTerminationFuture);
         }
 
-        return terminationFuture;
+        handleLeaderEventExecutor.shutdownNow();
+
+        return serviceTerminationFuture;
+    }
+
+    // ------------------------------------------------------------------------
+    //  LeaderContender
+    // ------------------------------------------------------------------------
+
+    @Override
+    public void grantLeadership(UUID newLeaderSessionID) {
+        handleLeaderEventExecutor.execute(
+                () -> {
+                    synchronized (lock) {
+                        if (!running) {
+                            LOG.info(
+                                    "Resource manager service is not running. Ignore granting leadership with session ID {}.",
+                                    newLeaderSessionID);
+                            return;
+                        }
+
+                        LOG.info(
+                                "Resource manager service is granted leadership with session id {}.",
+                                newLeaderSessionID);
+
+                        try {
+                            startNewLeaderResourceManager(newLeaderSessionID);
+                        } catch (Throwable t) {
+                            fatalErrorHandler.onFatalError(
+                                    new FlinkException("Cannot start resource manager.", t));
+                        }
+                    }
+                });
+    }
+
+    @Override
+    public void revokeLeadership() {
+        handleLeaderEventExecutor.execute(
+                () -> {
+                    synchronized (lock) {
+                        if (!running) {
+                            LOG.info(
+                                    "Resource manager service is not running. Ignore revoking leadership.");
+                            return;
+                        }
+
+                        LOG.info(
+                                "Resource manager service is revoked leadership with session id {}.",
+                                leaderSessionID);
+
+                        stopLeaderResourceManager();
+
+                        if (!enableMultiLeaderSession) {
+                            closeAsync();
+                        }
+                    }
+                });
+    }
+
+    @Override
+    public void handleError(Exception exception) {
+        fatalErrorHandler.onFatalError(
+                new FlinkException(
+                        "Exception during leader election of resource manager occurred.",
+                        exception));
+    }
+
+    // ------------------------------------------------------------------------
+    //  Internal
+    // ------------------------------------------------------------------------
+
+    @GuardedBy("lock")
+    private void startNewLeaderResourceManager(UUID newLeaderSessionID) throws Exception {
+        stopLeaderResourceManager();
+
+        this.leaderSessionID = newLeaderSessionID;
+        this.leaderResourceManager =
+                resourceManagerFactory.createResourceManager(
+                        rmProcessContext, newLeaderSessionID, ResourceID.generate());
+
+        final ResourceManager<?> newLeaderResourceManager = this.leaderResourceManager;
+
+        previousResourceManagerTerminationFuture
+                .thenComposeAsync(
+                        (ignore) -> {
+                            synchronized (lock) {
+                                return startResourceManagerIfIsLeader(newLeaderResourceManager);
+                            }
+                        },
+                        handleLeaderEventExecutor)
+                .thenAcceptAsync(
+                        (isStillLeader) -> {
+                            if (isStillLeader) {
+                                leaderElectionService.confirmLeadership(
+                                        newLeaderSessionID, newLeaderResourceManager.getAddress());
+                            }
+                        },
+                        ioExecutor);
+    }
+
+    /**
+     * Returns a future that completes as {@code true} if the resource manager is still leader and
+     * started, and {@code false} if it's no longer leader.
+     */
+    @GuardedBy("lock")
+    private CompletableFuture<Boolean> startResourceManagerIfIsLeader(
+            ResourceManager<?> resourceManager) {
+        if (isLeader(resourceManager)) {
+            resourceManager.start();
+            forwardTerminationFuture(resourceManager);
+            return resourceManager.getStartedFuture().thenApply(ignore -> true);
+        } else {
+            return CompletableFuture.completedFuture(false);
+        }
+    }
+
+    private void forwardTerminationFuture(ResourceManager<?> resourceManager) {
+        resourceManager
+                .getTerminationFuture()
+                .whenComplete(
+                        (ignore, throwable) -> {
+                            synchronized (lock) {
+                                if (isLeader(resourceManager)) {
+                                    if (throwable != null) {
+                                        serviceTerminationFuture.completeExceptionally(throwable);
+                                    } else {
+                                        serviceTerminationFuture.complete(null);
+                                    }
+                                }
+                            }
+                        });
+    }
+
+    @GuardedBy("lock")
+    private boolean isLeader(ResourceManager<?> resourceManager) {
+        return running && this.leaderResourceManager == resourceManager;
+    }
+
+    @GuardedBy("lock")
+    private void stopLeaderResourceManager() {
+        if (leaderResourceManager != null) {
+            previousResourceManagerTerminationFuture =
+                    previousResourceManagerTerminationFuture.thenCombine(
+                            leaderResourceManager.closeAsync(), (ignore1, ignore2) -> null);
+            leaderResourceManager = null;
+            leaderSessionID = null;
+        }
+    }
+
+    private void stopLeaderElectionService() {
+        try {
+            leaderElectionService.stop();
+        } catch (Exception e) {
+            serviceTerminationFuture.completeExceptionally(
+                    new FlinkException("Cannot stop leader election service.", e));
+        }
+    }
+
+    @VisibleForTesting
+    @Nullable
+    public ResourceManager<?> getLeaderResourceManager() {
+        synchronized (lock) {
+            return leaderResourceManager;
+        }
     }
 
     public static ResourceManagerServiceImpl create(
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManager.java
index 173e3913c2a..fbae8daed8a 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManager.java
@@ -23,7 +23,6 @@ import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerFactory;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
 import org.apache.flink.runtime.resourcemanager.exceptions.ResourceManagerException;
@@ -34,6 +33,7 @@ import org.apache.flink.util.Preconditions;
 
 import javax.annotation.Nullable;
 
+import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 
@@ -50,8 +50,8 @@ public class StandaloneResourceManager extends ResourceManager<ResourceID> {
 
     public StandaloneResourceManager(
             RpcService rpcService,
+            UUID leaderSessionId,
             ResourceID resourceId,
-            HighAvailabilityServices highAvailabilityServices,
             HeartbeatServices heartbeatServices,
             SlotManager slotManager,
             ResourceManagerPartitionTrackerFactory clusterPartitionTrackerFactory,
@@ -64,8 +64,8 @@ public class StandaloneResourceManager extends ResourceManager<ResourceID> {
             Executor ioExecutor) {
         super(
                 rpcService,
+                leaderSessionId,
                 resourceId,
-                highAvailabilityServices,
                 heartbeatServices,
                 slotManager,
                 clusterPartitionTrackerFactory,
@@ -80,7 +80,7 @@ public class StandaloneResourceManager extends ResourceManager<ResourceID> {
 
     @Override
     protected void initialize() throws ResourceManagerException {
-        // nothing to initialize
+        startStartupPeriod();
     }
 
     @Override
@@ -108,11 +108,6 @@ public class StandaloneResourceManager extends ResourceManager<ResourceID> {
         return resourceID;
     }
 
-    @Override
-    protected void onLeadership() {
-        startStartupPeriod();
-    }
-
     private void startStartupPeriod() {
         setFailUnfulfillableRequest(false);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerFactory.java
index fd6580ed043..4677aca5186 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerFactory.java
@@ -26,7 +26,6 @@ import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerImpl;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
@@ -38,6 +37,7 @@ import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
 
+import java.util.UUID;
 import java.util.concurrent.Executor;
 
 /** {@link ResourceManagerFactory} which creates a {@link StandaloneResourceManager}. */
@@ -59,7 +59,7 @@ public final class StandaloneResourceManagerFactory extends ResourceManagerFacto
             Configuration configuration,
             ResourceID resourceId,
             RpcService rpcService,
-            HighAvailabilityServices highAvailabilityServices,
+            UUID leaderSessionId,
             HeartbeatServices heartbeatServices,
             FatalErrorHandler fatalErrorHandler,
             ClusterInformation clusterInformation,
@@ -73,8 +73,8 @@ public final class StandaloneResourceManagerFactory extends ResourceManagerFacto
 
         return new StandaloneResourceManager(
                 rpcService,
+                leaderSessionId,
                 resourceId,
-                highAvailabilityServices,
                 heartbeatServices,
                 resourceManagerRuntimeServices.getSlotManager(),
                 ResourceManagerPartitionTrackerImpl::new,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java
index 2c20addb619..12304f6193a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java
@@ -31,7 +31,6 @@ import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.concurrent.ScheduledExecutor;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerFactory;
 import org.apache.flink.runtime.metrics.MetricNames;
 import org.apache.flink.runtime.metrics.ThresholdMeter;
@@ -53,6 +52,7 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
@@ -104,8 +104,8 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
             ResourceManagerDriver<WorkerType> resourceManagerDriver,
             Configuration flinkConfig,
             RpcService rpcService,
+            UUID leaderSessionId,
             ResourceID resourceId,
-            HighAvailabilityServices highAvailabilityServices,
             HeartbeatServices heartbeatServices,
             SlotManager slotManager,
             ResourceManagerPartitionTrackerFactory clusterPartitionTrackerFactory,
@@ -119,8 +119,8 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
             Executor ioExecutor) {
         super(
                 rpcService,
+                leaderSessionId,
                 resourceId,
-                highAvailabilityServices,
                 heartbeatServices,
                 slotManager,
                 clusterPartitionTrackerFactory,
@@ -160,22 +160,12 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
     @Override
     protected void terminate() throws ResourceManagerException {
         try {
-            resourceManagerDriver.terminate().get();
+            resourceManagerDriver.terminate();
         } catch (Exception e) {
             throw new ResourceManagerException("Cannot terminate resource provider.", e);
         }
     }
 
-    @Override
-    protected CompletableFuture<Void> prepareLeadershipAsync() {
-        return resourceManagerDriver.onGrantLeadership();
-    }
-
-    @Override
-    protected CompletableFuture<Void> clearStateAsync() {
-        return resourceManagerDriver.onRevokeLeadership();
-    }
-
     @Override
     protected void internalDeregisterApplication(
             ApplicationStatus finalStatus, @Nullable String optionalDiagnostics)
@@ -337,13 +327,6 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
     }
 
     private void internalStopWorker(final ResourceID resourceId) {
-        if (!hasLeadership()) {
-            log.warn(
-                    "Cannot stop worker {}. Does not have leadership.",
-                    resourceId.getStringWithMetadata());
-            return;
-        }
-
         log.info("Stopping worker {}.", resourceId.getStringWithMetadata());
 
         final WorkerType worker = workerNodeMap.get(resourceId);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java
index bf9641de47c..a8eefaf139d 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java
@@ -30,7 +30,6 @@ import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceIDRetrievable;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerImpl;
 import org.apache.flink.runtime.metrics.ThresholdMeter;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
@@ -43,6 +42,7 @@ import org.apache.flink.runtime.rpc.RpcService;
 import javax.annotation.Nullable;
 
 import java.time.Duration;
+import java.util.UUID;
 import java.util.concurrent.Executor;
 
 /**
@@ -91,7 +91,7 @@ public abstract class ActiveResourceManagerFactory<WorkerType extends ResourceID
             Configuration configuration,
             ResourceID resourceId,
             RpcService rpcService,
-            HighAvailabilityServices highAvailabilityServices,
+            UUID leaderSessionId,
             HeartbeatServices heartbeatServices,
             FatalErrorHandler fatalErrorHandler,
             ClusterInformation clusterInformation,
@@ -111,8 +111,8 @@ public abstract class ActiveResourceManagerFactory<WorkerType extends ResourceID
                         configuration, webInterfaceUrl, rpcService.getAddress()),
                 configuration,
                 rpcService,
+                leaderSessionId,
                 resourceId,
-                highAvailabilityServices,
                 heartbeatServices,
                 resourceManagerRuntimeServices.getSlotManager(),
                 ResourceManagerPartitionTrackerImpl::new,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriver.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriver.java
index 227a5ec0923..46a389909df 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriver.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriver.java
@@ -21,7 +21,6 @@ package org.apache.flink.runtime.resourcemanager.active;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
 import org.apache.flink.runtime.clusterframework.types.ResourceIDRetrievable;
-import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.concurrent.ScheduledExecutor;
 
 import javax.annotation.Nullable;
@@ -48,35 +47,8 @@ public interface ResourceManagerDriver<WorkerType extends ResourceIDRetrievable>
             Executor ioExecutor)
             throws Exception;
 
-    /**
-     * Terminate the deployment specific components.
-     *
-     * @return A future that will be completed successfully when the driver is terminated, or
-     *     exceptionally if it cannot be terminated.
-     */
-    CompletableFuture<Void> terminate();
-
-    /**
-     * This method can be overridden to add a (non-blocking) initialization routine to the
-     * ResourceManager that will be called when leadership is granted but before leadership is
-     * confirmed.
-     *
-     * @return Returns a {@code CompletableFuture} that completes when the computation is finished.
-     */
-    default CompletableFuture<Void> onGrantLeadership() {
-        return FutureUtils.completedVoidFuture();
-    }
-
-    /**
-     * This method can be overridden to add a (non-blocking) state clearing routine to the
-     * ResourceManager that will be called when leadership is revoked.
-     *
-     * @return Returns a {@code CompletableFuture} that completes when the state clearing routine is
-     *     finished.
-     */
-    default CompletableFuture<Void> onRevokeLeadership() {
-        return FutureUtils.completedVoidFuture();
-    }
+    /** Terminate the deployment specific components. */
+    void terminate() throws Exception;
 
     /**
      * The deployment specific code to deregister the application. This should report the
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointTest.java
index db497bd9a6b..167fdca7fbb 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/ClusterEntrypointTest.java
@@ -34,24 +34,13 @@ import org.apache.flink.runtime.dispatcher.runner.DispatcherRunnerFactory;
 import org.apache.flink.runtime.dispatcher.runner.TestingDispatcherRunner;
 import org.apache.flink.runtime.entrypoint.component.DefaultDispatcherResourceManagerComponentFactory;
 import org.apache.flink.runtime.entrypoint.component.DispatcherResourceManagerComponentFactory;
-import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServicesBuilder;
-import org.apache.flink.runtime.io.network.partition.NoOpResourceManagerPartitionTracker;
 import org.apache.flink.runtime.jobmanager.JobGraphStoreFactory;
 import org.apache.flink.runtime.leaderelection.LeaderElectionService;
-import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
-import org.apache.flink.runtime.resourcemanager.ArbitraryWorkerResourceSpecFactory;
-import org.apache.flink.runtime.resourcemanager.JobLeaderIdService;
-import org.apache.flink.runtime.resourcemanager.ResourceManager;
 import org.apache.flink.runtime.resourcemanager.ResourceManagerFactory;
-import org.apache.flink.runtime.resourcemanager.ResourceManagerRuntimeServices;
-import org.apache.flink.runtime.resourcemanager.ResourceManagerRuntimeServicesConfiguration;
 import org.apache.flink.runtime.resourcemanager.StandaloneResourceManagerFactory;
-import org.apache.flink.runtime.resourcemanager.TestingJobLeaderIdService;
-import org.apache.flink.runtime.resourcemanager.TestingResourceManager;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerBuilder;
+import org.apache.flink.runtime.resourcemanager.TestingResourceManagerFactory;
 import org.apache.flink.runtime.rest.SessionRestEndpointFactory;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcService;
@@ -59,7 +48,6 @@ import org.apache.flink.runtime.testutils.TestJvmProcess;
 import org.apache.flink.runtime.testutils.TestingClusterEntrypointProcess;
 import org.apache.flink.runtime.util.SignalHandler;
 import org.apache.flink.testutils.executor.TestExecutorResource;
-import org.apache.flink.util.ConfigurationException;
 import org.apache.flink.util.OperatingSystem;
 import org.apache.flink.util.TestLogger;
 
@@ -68,8 +56,6 @@ import org.junit.ClassRule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import javax.annotation.Nullable;
-
 import java.io.File;
 import java.io.IOException;
 import java.util.UUID;
@@ -77,7 +63,6 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-import java.util.function.BiConsumer;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
@@ -142,7 +127,7 @@ public class ClusterEntrypointTest extends TestLogger {
         final TestingResourceManagerFactory testingResourceManagerFactory =
                 new TestingResourceManagerFactory.Builder()
                         .setInternalDeregisterApplicationConsumer(
-                                (ignored1, ignored2) -> deregisterFuture.complete(null))
+                                (ignored1, ignored2, ignore3) -> deregisterFuture.complete(null))
                         .build();
         final TestingEntryPoint testingEntryPoint =
                 new TestingEntryPoint.Builder()
@@ -174,7 +159,11 @@ public class ClusterEntrypointTest extends TestLogger {
         final TestingResourceManagerFactory testingResourceManagerFactory =
                 new TestingResourceManagerFactory.Builder()
                         .setInternalDeregisterApplicationConsumer(
-                                (ignored1, ignored2) -> deregisterFuture.complete(null))
+                                (ignored1, ignored2, ignore3) -> deregisterFuture.complete(null))
+                        .setInitializeConsumer(
+                                (ignore) ->
+                                        dispatcherShutDownFuture.complete(
+                                                ApplicationStatus.SUCCEEDED))
                         .build();
         final TestingDispatcherRunnerFactory testingDispatcherRunnerFactory =
                 new TestingDispatcherRunnerFactory.Builder()
@@ -192,8 +181,6 @@ public class ClusterEntrypointTest extends TestLogger {
         final CompletableFuture<ApplicationStatus> appStatusFuture =
                 startClusterEntrypoint(testingEntryPoint);
 
-        dispatcherShutDownFuture.complete(ApplicationStatus.SUCCEEDED);
-
         assertThat(
                 appStatusFuture.get(TIMEOUT_MS, TimeUnit.MILLISECONDS),
                 is(ApplicationStatus.SUCCEEDED));
@@ -364,75 +351,4 @@ public class ClusterEntrypointTest extends TestLogger {
             }
         }
     }
-
-    private static class TestingResourceManagerFactory extends ResourceManagerFactory<ResourceID> {
-
-        private final BiConsumer<ApplicationStatus, String> deregisterAppConsumer;
-
-        private TestingResourceManagerFactory(
-                BiConsumer<ApplicationStatus, String> deregisterAppConsumer) {
-            this.deregisterAppConsumer = deregisterAppConsumer;
-        }
-
-        @Override
-        protected ResourceManager<ResourceID> createResourceManager(
-                Configuration configuration,
-                ResourceID resourceId,
-                RpcService rpcService,
-                HighAvailabilityServices highAvailabilityServices,
-                HeartbeatServices heartbeatServices,
-                FatalErrorHandler fatalErrorHandler,
-                ClusterInformation clusterInformation,
-                @Nullable String webInterfaceUrl,
-                ResourceManagerMetricGroup resourceManagerMetricGroup,
-                ResourceManagerRuntimeServices resourceManagerRuntimeServices,
-                Executor ioExecutor)
-                throws Exception {
-            final SlotManager slotManager =
-                    SlotManagerBuilder.newBuilder()
-                            .setScheduledExecutor(rpcService.getScheduledExecutor())
-                            .build();
-            final JobLeaderIdService jobLeaderIdService =
-                    new TestingJobLeaderIdService.Builder().build();
-            return new TestingResourceManager(
-                    rpcService,
-                    resourceId,
-                    highAvailabilityServices,
-                    heartbeatServices,
-                    slotManager,
-                    NoOpResourceManagerPartitionTracker::get,
-                    jobLeaderIdService,
-                    fatalErrorHandler,
-                    resourceManagerMetricGroup) {
-                @Override
-                protected void internalDeregisterApplication(
-                        ApplicationStatus finalStatus, @Nullable String diagnostics) {
-                    deregisterAppConsumer.accept(finalStatus, diagnostics);
-                }
-            };
-        }
-
-        @Override
-        protected ResourceManagerRuntimeServicesConfiguration
-                createResourceManagerRuntimeServicesConfiguration(Configuration configuration)
-                        throws ConfigurationException {
-            return ResourceManagerRuntimeServicesConfiguration.fromConfiguration(
-                    configuration, ArbitraryWorkerResourceSpecFactory.INSTANCE);
-        }
-
-        public static final class Builder {
-            private BiConsumer<ApplicationStatus, String> deregisterAppConsumer =
-                    (ignore1, ignore2) -> {};
-
-            public Builder setInternalDeregisterApplicationConsumer(
-                    BiConsumer<ApplicationStatus, String> biConsumer) {
-                this.deregisterAppConsumer = biConsumer;
-                return this;
-            }
-
-            public TestingResourceManagerFactory build() {
-                return new TestingResourceManagerFactory(deregisterAppConsumer);
-            }
-        }
-    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponentTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponentTest.java
index 6b3f9da15c8..dcb10287095 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponentTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/entrypoint/component/DispatcherResourceManagerComponentTest.java
@@ -18,16 +18,19 @@
 
 package org.apache.flink.runtime.entrypoint.component;
 
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.dispatcher.runner.TestingDispatcherRunner;
 import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;
-import org.apache.flink.runtime.resourcemanager.TestingResourceManagerService;
+import org.apache.flink.runtime.resourcemanager.ResourceManagerService;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.Test;
 
+import javax.annotation.Nullable;
+
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
 
@@ -90,4 +93,67 @@ public class DispatcherResourceManagerComponentTest extends TestLogger {
         final CompletableFuture<Throwable> errorFuture = fatalErrorHandler.getErrorFuture();
         assertThat(errorFuture, willNotComplete(Duration.ofMillis(10L)));
     }
+
+    /**
+     * Testing implementation of {@link
+     * org.apache.flink.runtime.resourcemanager.ResourceManagerService}, which does not actually
+     * start the service internally.
+     */
+    private static class TestingResourceManagerService implements ResourceManagerService {
+        private final CompletableFuture<Void> terminationFuture;
+        private final boolean completeTerminationFutureOnClose;
+
+        private TestingResourceManagerService(
+                CompletableFuture<Void> terminationFuture,
+                boolean completeTerminationFutureOnClose) {
+            this.terminationFuture = terminationFuture;
+            this.completeTerminationFutureOnClose = completeTerminationFutureOnClose;
+        }
+
+        @Override
+        public void start() throws Exception {}
+
+        @Override
+        public CompletableFuture<Void> getTerminationFuture() {
+            return terminationFuture;
+        }
+
+        @Override
+        public CompletableFuture<Void> deregisterApplication(
+                ApplicationStatus applicationStatus, @Nullable String diagnostics) {
+            return FutureUtils.completedVoidFuture();
+        }
+
+        @Override
+        public CompletableFuture<Void> closeAsync() {
+            if (completeTerminationFutureOnClose) {
+                terminationFuture.complete(null);
+            }
+            return getTerminationFuture();
+        }
+
+        private static Builder newBuilder() {
+            return new Builder();
+        }
+
+        private static class Builder {
+            private CompletableFuture<Void> terminationFuture = new CompletableFuture<>();
+            private boolean completeTerminationFutureOnClose = true;
+
+            private Builder setTerminationFuture(CompletableFuture<Void> terminationFuture) {
+                this.terminationFuture = terminationFuture;
+                return this;
+            }
+
+            private Builder withManualTerminationFutureCompletion() {
+                this.completeTerminationFutureOnClose = false;
+                return this;
+            }
+
+            private TestingResourceManagerService build() {
+                return new TestingResourceManagerService(
+                        terminationFuture, completeTerminationFutureOnClose);
+            }
+        }
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
index 0abbb117ff1..03fe210b0e0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/LeaderChangeClusterComponentsTest.java
@@ -32,6 +32,7 @@ import org.apache.flink.runtime.jobmaster.JobResult;
 import org.apache.flink.runtime.jobmaster.utils.JobResultUtils;
 import org.apache.flink.runtime.minicluster.TestingMiniCluster;
 import org.apache.flink.runtime.minicluster.TestingMiniClusterConfiguration;
+import org.apache.flink.runtime.resourcemanager.ResourceManagerServiceImpl;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.util.LeaderRetrievalUtils;
@@ -43,6 +44,7 @@ import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.time.Duration;
+import java.util.Properties;
 import java.util.concurrent.CompletableFuture;
 
 import static org.hamcrest.Matchers.is;
@@ -63,12 +65,17 @@ public class LeaderChangeClusterComponentsTest extends TestLogger {
 
     private static EmbeddedHaServicesWithLeadershipControl highAvailabilityServices;
 
+    private static Properties sysProps;
+
     private JobGraph jobGraph;
 
     private JobID jobId;
 
     @BeforeClass
     public static void setupClass() throws Exception {
+        sysProps = System.getProperties();
+        System.setProperty(ResourceManagerServiceImpl.ENABLE_MULTI_LEADER_SESSION_PROPERTY, "");
+
         highAvailabilityServices =
                 new EmbeddedHaServicesWithLeadershipControl(TestingUtils.defaultExecutor());
 
@@ -94,6 +101,8 @@ public class LeaderChangeClusterComponentsTest extends TestLogger {
         if (miniCluster != null) {
             miniCluster.close();
         }
+
+        System.setProperties(sysProps);
     }
 
     @Test
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionService.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionService.java
index e63e248e762..f7ea757ce11 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionService.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionService.java
@@ -120,4 +120,8 @@ public class TestingLeaderElectionService implements LeaderElectionService {
     public synchronized CompletableFuture<Void> getStartFuture() {
         return startFuture;
     }
+
+    public synchronized boolean isStopped() {
+        return contender == null;
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerHATest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerHATest.java
index 0fdce8da959..a55db20b968 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerHATest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerHATest.java
@@ -18,128 +18,57 @@
 
 package org.apache.flink.runtime.resourcemanager;
 
-import org.apache.flink.api.common.resources.CPUResource;
-import org.apache.flink.api.common.time.Time;
-import org.apache.flink.configuration.ClusterOptions;
-import org.apache.flink.configuration.Configuration;
-import org.apache.flink.configuration.MemorySize;
-import org.apache.flink.configuration.ResourceManagerOptions;
-import org.apache.flink.runtime.clusterframework.types.ResourceID;
-import org.apache.flink.runtime.entrypoint.ClusterInformation;
-import org.apache.flink.runtime.heartbeat.TestingHeartbeatServices;
-import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
-import org.apache.flink.runtime.io.network.partition.NoOpResourceManagerPartitionTracker;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
-import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
-import org.apache.flink.runtime.resourcemanager.slotmanager.AnyMatchingSlotMatchingStrategy;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerConfiguration;
-import org.apache.flink.runtime.rpc.RpcService;
-import org.apache.flink.runtime.rpc.RpcUtils;
-import org.apache.flink.runtime.rpc.TestingRpcService;
-import org.apache.flink.runtime.testingUtils.TestingUtils;
-import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.util.TestLogger;
 
-import org.junit.Assert;
 import org.junit.Test;
 
+import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ForkJoinPool;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 /** ResourceManager HA test, including grant leadership and revoke leadership. */
 public class ResourceManagerHATest extends TestLogger {
 
     @Test
     public void testGrantAndRevokeLeadership() throws Exception {
-        ResourceID rmResourceId = ResourceID.generate();
-        RpcService rpcService = new TestingRpcService();
-
-        CompletableFuture<UUID> leaderSessionIdFuture = new CompletableFuture<>();
-
-        TestingLeaderElectionService leaderElectionService =
-                new TestingLeaderElectionService() {
-                    @Override
-                    public void confirmLeadership(UUID leaderId, String leaderAddress) {
-                        leaderSessionIdFuture.complete(leaderId);
-                    }
-                };
-
-        TestingHighAvailabilityServices highAvailabilityServices =
-                new TestingHighAvailabilityServices();
-        highAvailabilityServices.setResourceManagerLeaderElectionService(leaderElectionService);
-
-        TestingHeartbeatServices heartbeatServices = new TestingHeartbeatServices();
+        final TestingLeaderElectionService leaderElectionService =
+                new TestingLeaderElectionService();
 
-        final Configuration configuration = new Configuration();
-        ResourceManagerRuntimeServicesConfiguration resourceManagerRuntimeServicesConfiguration =
-                new ResourceManagerRuntimeServicesConfiguration(
-                        Time.seconds(5L),
-                        new SlotManagerConfiguration(
-                                TestingUtils.infiniteTime(),
-                                TestingUtils.infiniteTime(),
-                                TestingUtils.infiniteTime(),
-                                true,
-                                AnyMatchingSlotMatchingStrategy.INSTANCE,
-                                WorkerResourceSpec.ZERO,
-                                1,
-                                ResourceManagerOptions.MAX_SLOT_NUM.defaultValue(),
-                                new CPUResource(Double.MAX_VALUE),
-                                MemorySize.MAX_VALUE,
-                                ResourceManagerOptions.REDUNDANT_TASK_MANAGER_NUM.defaultValue()),
-                        ClusterOptions.isFineGrainedResourceManagementEnabled(configuration));
-        ResourceManagerRuntimeServices resourceManagerRuntimeServices =
-                ResourceManagerRuntimeServices.fromConfiguration(
-                        resourceManagerRuntimeServicesConfiguration,
-                        highAvailabilityServices,
-                        rpcService.getScheduledExecutor(),
-                        UnregisteredMetricGroups.createUnregisteredSlotManagerMetricGroup());
-
-        TestingFatalErrorHandler testingFatalErrorHandler = new TestingFatalErrorHandler();
-
-        CompletableFuture<ResourceManagerId> revokedLeaderIdFuture = new CompletableFuture<>();
-
-        final ResourceManager resourceManager =
-                new StandaloneResourceManager(
-                        rpcService,
-                        rmResourceId,
-                        highAvailabilityServices,
-                        heartbeatServices,
-                        resourceManagerRuntimeServices.getSlotManager(),
-                        NoOpResourceManagerPartitionTracker::get,
-                        resourceManagerRuntimeServices.getJobLeaderIdService(),
-                        new ClusterInformation("localhost", 1234),
-                        testingFatalErrorHandler,
-                        UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup(),
-                        Time.minutes(5L),
-                        RpcUtils.INF_TIMEOUT,
-                        ForkJoinPool.commonPool()) {
-
-                    @Override
-                    public void revokeLeadership() {
-                        super.revokeLeadership();
-                        runAsyncWithoutFencing(
-                                () -> revokedLeaderIdFuture.complete(getFencingToken()));
-                    }
-                };
+        final TestingResourceManagerService resourceManagerService =
+                TestingResourceManagerService.newBuilder()
+                        .setRmLeaderElectionService(leaderElectionService)
+                        .build();
 
         try {
-            resourceManager.start();
+            resourceManagerService.start();
 
-            Assert.assertNull(resourceManager.getFencingToken());
             final UUID leaderId = UUID.randomUUID();
-            leaderElectionService.isLeader(leaderId);
-            // after grant leadership, resourceManager's leaderId has value
-            Assert.assertEquals(leaderId, leaderSessionIdFuture.get());
-            // then revoke leadership, resourceManager's leaderId should be different
-            leaderElectionService.notLeader();
-            Assert.assertNotEquals(leaderId, revokedLeaderIdFuture.get());
-
-            if (testingFatalErrorHandler.hasExceptionOccurred()) {
-                testingFatalErrorHandler.rethrowError();
-            }
+            resourceManagerService.isLeader(leaderId);
+
+            // after grant leadership, verify resource manager is started with the fencing token
+            assertEquals(
+                    leaderId,
+                    leaderElectionService.getConfirmationFuture().get().getLeaderSessionId());
+            assertTrue(resourceManagerService.getResourceManagerFencingToken().isPresent());
+            assertEquals(
+                    leaderId,
+                    resourceManagerService.getResourceManagerFencingToken().get().toUUID());
+
+            // then revoke leadership, verify resource manager is closed
+            final Optional<CompletableFuture<Void>> rmTerminationFutureOpt =
+                    resourceManagerService.getResourceManagerTerminationFuture();
+            assertTrue(rmTerminationFutureOpt.isPresent());
+
+            resourceManagerService.notLeader();
+            rmTerminationFutureOpt.get().get();
+
+            resourceManagerService.rethrowFatalErrorIfAny();
         } finally {
-            rpcService.stopService().get();
+            resourceManagerService.cleanUp();
         }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java
index 1c9eb170b0a..0af1b0ee4f5 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerJobMasterTest.java
@@ -21,12 +21,7 @@ package org.apache.flink.runtime.resourcemanager;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
-import org.apache.flink.runtime.entrypoint.ClusterInformation;
-import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
-import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
-import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServicesBuilder;
-import org.apache.flink.runtime.io.network.partition.NoOpResourceManagerPartitionTracker;
 import org.apache.flink.runtime.jobmaster.JobMaster;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
 import org.apache.flink.runtime.jobmaster.JobMasterRegistrationSuccess;
@@ -34,15 +29,11 @@ import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;
 import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
 import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;
-import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.runtime.registration.RegistrationResponse;
 import org.apache.flink.runtime.resourcemanager.exceptions.ResourceManagerException;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerBuilder;
 import org.apache.flink.runtime.rpc.RpcUtils;
 import org.apache.flink.runtime.rpc.TestingRpcService;
 import org.apache.flink.runtime.rpc.exceptions.FencingTokenException;
-import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.TestLogger;
@@ -54,7 +45,6 @@ import org.junit.Test;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 
 import static org.junit.Assert.assertTrue;
@@ -69,19 +59,13 @@ public class ResourceManagerJobMasterTest extends TestLogger {
 
     private JobID jobId;
 
-    private TestingJobMasterGateway jobMasterGateway;
-
     private ResourceID jobMasterResourceId;
 
-    private SettableLeaderRetrievalService jobMasterLeaderRetrievalService;
-
-    private TestingLeaderElectionService resourceManagerLeaderElectionService;
-
-    private TestingHighAvailabilityServices haServices;
+    private TestingJobMasterGateway jobMasterGateway;
 
-    private TestingFatalErrorHandler testingFatalErrorHandler;
+    private SettableLeaderRetrievalService jobMasterLeaderRetrievalService;
 
-    private ResourceManager<?> resourceManager;
+    private TestingResourceManagerService resourceManagerService;
 
     private ResourceManagerGateway resourceManagerGateway;
 
@@ -90,18 +74,28 @@ public class ResourceManagerJobMasterTest extends TestLogger {
         rpcService = new TestingRpcService();
 
         jobId = new JobID();
+        jobMasterResourceId = ResourceID.generate();
 
         createAndRegisterJobMasterGateway();
-        jobMasterResourceId = ResourceID.generate();
 
+        createAndStartResourceManagerService();
+    }
+
+    private void createAndRegisterJobMasterGateway() {
+        jobMasterGateway = new TestingJobMasterGatewayBuilder().build();
+        rpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);
         jobMasterLeaderRetrievalService =
                 new SettableLeaderRetrievalService(
                         jobMasterGateway.getAddress(), jobMasterGateway.getFencingToken().toUUID());
-        resourceManagerLeaderElectionService = new TestingLeaderElectionService();
+    }
 
-        haServices =
-                new TestingHighAvailabilityServicesBuilder()
-                        .setJobMasterLeaderRetrieverFunction(
+    private void createAndStartResourceManagerService() throws Exception {
+        final TestingLeaderElectionService leaderElectionService =
+                new TestingLeaderElectionService();
+        resourceManagerService =
+                TestingResourceManagerService.newBuilder()
+                        .setRpcService(rpcService)
+                        .setJmLeaderRetrieverFunction(
                                 requestedJobId -> {
                                     if (requestedJobId.equals(jobId)) {
                                         return jobMasterLeaderRetrievalService;
@@ -110,77 +104,37 @@ public class ResourceManagerJobMasterTest extends TestLogger {
                                                 String.format("Unknown job id %s", jobId));
                                     }
                                 })
-                        .setResourceManagerLeaderElectionService(
-                                resourceManagerLeaderElectionService)
-                        .build();
-
-        testingFatalErrorHandler = new TestingFatalErrorHandler();
-
-        resourceManager = createAndStartResourceManager();
-
-        // wait until the leader election has been completed
-        resourceManagerLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-        resourceManagerGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class);
-    }
-
-    private void createAndRegisterJobMasterGateway() {
-        jobMasterGateway = new TestingJobMasterGatewayBuilder().build();
-        rpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);
-    }
-
-    private ResourceManager<?> createAndStartResourceManager() throws Exception {
-        ResourceID rmResourceId = ResourceID.generate();
-
-        HeartbeatServices heartbeatServices = new HeartbeatServices(1000L, 1000L);
-
-        JobLeaderIdService jobLeaderIdService =
-                new DefaultJobLeaderIdService(
-                        haServices, rpcService.getScheduledExecutor(), Time.minutes(5L));
-
-        final SlotManager slotManager =
-                SlotManagerBuilder.newBuilder()
-                        .setScheduledExecutor(rpcService.getScheduledExecutor())
+                        .setRmLeaderElectionService(leaderElectionService)
                         .build();
 
-        ResourceManager<?> resourceManager =
-                new StandaloneResourceManager(
-                        rpcService,
-                        rmResourceId,
-                        haServices,
-                        heartbeatServices,
-                        slotManager,
-                        NoOpResourceManagerPartitionTracker::get,
-                        jobLeaderIdService,
-                        new ClusterInformation("localhost", 1234),
-                        testingFatalErrorHandler,
-                        UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup(),
-                        Time.minutes(5L),
-                        RpcUtils.INF_TIMEOUT,
-                        ForkJoinPool.commonPool());
-
-        resourceManager.start();
-
-        return resourceManager;
+        resourceManagerService.start();
+        resourceManagerService.isLeader(UUID.randomUUID());
+
+        leaderElectionService
+                .getConfirmationFuture()
+                .thenRun(
+                        () -> {
+                            resourceManagerGateway =
+                                    resourceManagerService
+                                            .getResourceManagerGateway()
+                                            .orElseThrow(
+                                                    () ->
+                                                            new AssertionError(
+                                                                    "RM not available after confirming leadership."));
+                        })
+                .get(TIMEOUT.getSize(), TIMEOUT.getUnit());
     }
 
     @After
     public void teardown() throws Exception {
-        if (resourceManager != null) {
-            RpcUtils.terminateRpcEndpoint(resourceManager, TIMEOUT);
-        }
-
-        if (haServices != null) {
-            haServices.closeAndCleanupAllData();
+        if (resourceManagerService != null) {
+            resourceManagerService.rethrowFatalErrorIfAny();
+            resourceManagerService.cleanUp();
         }
 
         if (rpcService != null) {
             RpcUtils.terminateRpcService(rpcService, TIMEOUT);
         }
-
-        if (testingFatalErrorHandler != null && testingFatalErrorHandler.hasExceptionOccurred()) {
-            testingFatalErrorHandler.rethrowError();
-        }
     }
 
     /**
@@ -208,7 +162,7 @@ public class ResourceManagerJobMasterTest extends TestLogger {
         final ResourceManagerGateway wronglyFencedGateway =
                 rpcService
                         .connect(
-                                resourceManager.getAddress(),
+                                resourceManagerGateway.getAddress(),
                                 ResourceManagerId.generate(),
                                 ResourceManagerGateway.class)
                         .get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
@@ -291,6 +245,6 @@ public class ResourceManagerJobMasterTest extends TestLogger {
         }
 
         // ignore the reported error
-        testingFatalErrorHandler.clearError();
+        resourceManagerService.ignoreFatalErrors();
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerPartitionLifecycleTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerPartitionLifecycleTest.java
index 3853b1ccc4d..e304e22e905 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerPartitionLifecycleTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerPartitionLifecycleTest.java
@@ -20,17 +20,11 @@ package org.apache.flink.runtime.resourcemanager;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
-import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
 import org.apache.flink.runtime.instance.HardwareDescription;
-import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerImpl;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionID;
 import org.apache.flink.runtime.jobgraph.IntermediateDataSetID;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
-import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.runtime.registration.RegistrationResponse;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerBuilder;
 import org.apache.flink.runtime.rpc.RpcUtils;
 import org.apache.flink.runtime.rpc.TestingRpcService;
 import org.apache.flink.runtime.taskexecutor.SlotReport;
@@ -40,7 +34,6 @@ import org.apache.flink.runtime.taskexecutor.TaskExecutorMemoryConfiguration;
 import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;
 import org.apache.flink.runtime.taskexecutor.partition.ClusterPartitionReport;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
-import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.After;
@@ -68,13 +61,7 @@ public class ResourceManagerPartitionLifecycleTest extends TestLogger {
 
     private static TestingRpcService rpcService;
 
-    private TestingHighAvailabilityServices highAvailabilityServices;
-
-    private TestingLeaderElectionService resourceManagerLeaderElectionService;
-
-    private TestingFatalErrorHandler testingFatalErrorHandler;
-
-    private TestingResourceManager resourceManager;
+    private TestingResourceManagerService resourceManagerService;
 
     @BeforeClass
     public static void setupClass() {
@@ -82,26 +69,13 @@ public class ResourceManagerPartitionLifecycleTest extends TestLogger {
     }
 
     @Before
-    public void setup() throws Exception {
-        highAvailabilityServices = new TestingHighAvailabilityServices();
-        resourceManagerLeaderElectionService = new TestingLeaderElectionService();
-        highAvailabilityServices.setResourceManagerLeaderElectionService(
-                resourceManagerLeaderElectionService);
-        testingFatalErrorHandler = new TestingFatalErrorHandler();
-    }
+    public void setup() throws Exception {}
 
     @After
     public void after() throws Exception {
-        if (resourceManager != null) {
-            RpcUtils.terminateRpcEndpoint(resourceManager, TIMEOUT);
-        }
-
-        if (highAvailabilityServices != null) {
-            highAvailabilityServices.closeAndCleanupAllData();
-        }
-
-        if (testingFatalErrorHandler.hasExceptionOccurred()) {
-            testingFatalErrorHandler.rethrowError();
+        if (resourceManagerService != null) {
+            resourceManagerService.rethrowFatalErrorIfAny();
+            resourceManagerService.cleanUp();
         }
     }
 
@@ -227,36 +201,25 @@ public class ResourceManagerPartitionLifecycleTest extends TestLogger {
     }
 
     private ResourceManagerGateway createAndStartResourceManager() throws Exception {
-        final SlotManager slotManager =
-                SlotManagerBuilder.newBuilder()
-                        .setScheduledExecutor(rpcService.getScheduledExecutor())
+        final TestingLeaderElectionService leaderElectionService =
+                new TestingLeaderElectionService();
+
+        resourceManagerService =
+                TestingResourceManagerService.newBuilder()
+                        .setRpcService(rpcService)
+                        .setRmLeaderElectionService(leaderElectionService)
                         .build();
-        final JobLeaderIdService jobLeaderIdService =
-                new DefaultJobLeaderIdService(
-                        highAvailabilityServices,
-                        rpcService.getScheduledExecutor(),
-                        TestingUtils.infiniteTime());
-
-        final TestingResourceManager resourceManager =
-                new TestingResourceManager(
-                        rpcService,
-                        ResourceID.generate(),
-                        highAvailabilityServices,
-                        new HeartbeatServices(100000L, 1000000L),
-                        slotManager,
-                        ResourceManagerPartitionTrackerImpl::new,
-                        jobLeaderIdService,
-                        testingFatalErrorHandler,
-                        UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup());
-
-        resourceManager.start();
+        resourceManagerService.start();
 
         // first make the ResourceManager the leader
-        resourceManagerLeaderElectionService.isLeader(ResourceManagerId.generate().toUUID()).get();
+        resourceManagerService.isLeader(UUID.randomUUID());
 
-        this.resourceManager = resourceManager;
+        leaderElectionService.getConfirmationFuture().get(TIMEOUT.getSize(), TIMEOUT.getUnit());
 
-        return resourceManager.getSelfGateway(ResourceManagerGateway.class);
+        return resourceManagerService
+                .getResourceManagerGateway()
+                .orElseThrow(
+                        () -> new AssertionError("RM not available after confirming leadership."));
     }
 
     private static TaskExecutorHeartbeatPayload createTaskExecutorHeartbeatPayload(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImplTest.java
new file mode 100644
index 00000000000..69100a67779
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerServiceImplTest.java
@@ -0,0 +1,476 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.resourcemanager;
+
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.entrypoint.ClusterInformation;
+import org.apache.flink.runtime.heartbeat.HeartbeatServices;
+import org.apache.flink.runtime.heartbeat.TestingHeartbeatServices;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
+import org.apache.flink.runtime.metrics.MetricRegistry;
+import org.apache.flink.runtime.metrics.util.TestingMetricRegistry;
+import org.apache.flink.runtime.rpc.RpcUtils;
+import org.apache.flink.runtime.rpc.TestingRpcService;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.util.Properties;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.TimeoutException;
+
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Tests for {@link ResourceManagerServiceImpl}. */
+public class ResourceManagerServiceImplTest extends TestLogger {
+
+    private static final Time TIMEOUT = Time.seconds(10L);
+    private static final Time FAST_TIMEOUT = Time.milliseconds(50L);
+
+    private static final HeartbeatServices heartbeatServices = new TestingHeartbeatServices();
+    private static final ClusterInformation clusterInformation =
+            new ClusterInformation("localhost", 1234);
+    private static final MetricRegistry metricRegistry = TestingMetricRegistry.builder().build();
+
+    private static TestingRpcService rpcService;
+    private static TestingHighAvailabilityServices haService;
+    private static TestingFatalErrorHandler fatalErrorHandler;
+
+    private TestingResourceManagerFactory.Builder rmFactoryBuilder;
+    private TestingLeaderElectionService leaderElectionService;
+    private ResourceManagerServiceImpl resourceManagerService;
+
+    private Properties sysProps;
+
+    @BeforeClass
+    public static void setupClass() {
+        rpcService = new TestingRpcService();
+        haService = new TestingHighAvailabilityServices();
+        fatalErrorHandler = new TestingFatalErrorHandler();
+    }
+
+    @Before
+    public void setup() throws Exception {
+        sysProps = System.getProperties();
+        System.setProperty(ResourceManagerServiceImpl.ENABLE_MULTI_LEADER_SESSION_PROPERTY, "");
+
+        fatalErrorHandler.clearError();
+
+        rmFactoryBuilder = new TestingResourceManagerFactory.Builder();
+
+        leaderElectionService = new TestingLeaderElectionService();
+        haService.setResourceManagerLeaderElectionService(leaderElectionService);
+    }
+
+    @After
+    public void teardown() throws Exception {
+        if (resourceManagerService != null) {
+            resourceManagerService.close();
+        }
+
+        if (leaderElectionService != null) {
+            leaderElectionService.stop();
+        }
+
+        if (fatalErrorHandler.hasExceptionOccurred()) {
+            fatalErrorHandler.rethrowError();
+        }
+
+        System.setProperties(sysProps);
+    }
+
+    @AfterClass
+    public static void teardownClass() throws Exception {
+        if (rpcService != null) {
+            RpcUtils.terminateRpcService(rpcService, TIMEOUT);
+        }
+    }
+
+    private void createAndStartResourceManager() throws Exception {
+        createResourceManager();
+        resourceManagerService.start();
+    }
+
+    private void createResourceManager() throws Exception {
+        final TestingResourceManagerFactory rmFactory = rmFactoryBuilder.build();
+        resourceManagerService =
+                ResourceManagerServiceImpl.create(
+                        rmFactory,
+                        new Configuration(),
+                        rpcService,
+                        haService,
+                        heartbeatServices,
+                        fatalErrorHandler,
+                        clusterInformation,
+                        null,
+                        metricRegistry,
+                        "localhost",
+                        ForkJoinPool.commonPool());
+    }
+
+    @Test
+    public void grantLeadership_startRmAndConfirmLeaderSession() throws Exception {
+        final UUID leaderSessionId = UUID.randomUUID();
+        final CompletableFuture<UUID> startRmFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setInitializeConsumer(startRmFuture::complete);
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(leaderSessionId);
+
+        // should start new RM and confirm leader session
+        assertThat(startRmFuture.get(TIMEOUT.getSize(), TIMEOUT.getUnit()), is(leaderSessionId));
+        assertThat(
+                leaderElectionService
+                        .getConfirmationFuture()
+                        .get(TIMEOUT.getSize(), TIMEOUT.getUnit())
+                        .getLeaderSessionId(),
+                is(leaderSessionId));
+    }
+
+    @Test
+    public void grantLeadership_confirmLeaderSessionAfterRmStarted() throws Exception {
+        final UUID leaderSessionId = UUID.randomUUID();
+        final CompletableFuture<Void> finishRmInitializationFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setInitializeConsumer(
+                (ignore) -> blockOnFuture(finishRmInitializationFuture));
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(leaderSessionId);
+
+        // RM initialization not finished, should not confirm leader session
+        assertNotComplete(leaderElectionService.getConfirmationFuture());
+
+        // finish RM initialization
+        finishRmInitializationFuture.complete(null);
+
+        // should confirm leader session
+        assertThat(
+                leaderElectionService
+                        .getConfirmationFuture()
+                        .get(TIMEOUT.getSize(), TIMEOUT.getUnit())
+                        .getLeaderSessionId(),
+                is(leaderSessionId));
+    }
+
+    @Test
+    public void grantLeadership_withExistingLeader_stopExistLeader() throws Exception {
+        final UUID leaderSessionId1 = UUID.randomUUID();
+        final UUID leaderSessionId2 = UUID.randomUUID();
+        final CompletableFuture<UUID> startRmFuture1 = new CompletableFuture<>();
+        final CompletableFuture<UUID> startRmFuture2 = new CompletableFuture<>();
+        final CompletableFuture<UUID> terminateRmFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder
+                .setInitializeConsumer(
+                        uuid -> {
+                            if (!startRmFuture1.isDone()) {
+                                startRmFuture1.complete(uuid);
+                            } else {
+                                startRmFuture2.complete(uuid);
+                            }
+                        })
+                .setTerminateConsumer(terminateRmFuture::complete);
+
+        createAndStartResourceManager();
+
+        // first time grant leadership
+        leaderElectionService.isLeader(leaderSessionId1);
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // second time grant leadership
+        leaderElectionService.isLeader(leaderSessionId2);
+
+        // should terminate first RM, start a new RM and confirm leader session
+        assertThat(
+                terminateRmFuture.get(TIMEOUT.getSize(), TIMEOUT.getUnit()), is(leaderSessionId1));
+        assertThat(startRmFuture2.get(TIMEOUT.getSize(), TIMEOUT.getUnit()), is(leaderSessionId2));
+        assertThat(
+                leaderElectionService
+                        .getConfirmationFuture()
+                        .get(TIMEOUT.getSize(), TIMEOUT.getUnit())
+                        .getLeaderSessionId(),
+                is(leaderSessionId2));
+    }
+
+    @Test
+    public void grantLeadership_withExistingLeader_waitTerminationOfExistingLeader()
+            throws Exception {
+        final UUID leaderSessionId1 = UUID.randomUUID();
+        final UUID leaderSessionId2 = UUID.randomUUID();
+        final CompletableFuture<UUID> startRmFuture1 = new CompletableFuture<>();
+        final CompletableFuture<UUID> startRmFuture2 = new CompletableFuture<>();
+        final CompletableFuture<Void> finishRmTerminationFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder
+                .setInitializeConsumer(
+                        uuid -> {
+                            if (!startRmFuture1.isDone()) {
+                                startRmFuture1.complete(uuid);
+                            } else {
+                                startRmFuture2.complete(uuid);
+                            }
+                        })
+                .setTerminateConsumer((ignore) -> blockOnFuture(finishRmTerminationFuture));
+
+        createAndStartResourceManager();
+
+        // first time grant leadership
+        leaderElectionService.isLeader(leaderSessionId1);
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // second time grant leadership
+        leaderElectionService.isLeader(leaderSessionId2);
+
+        // first RM termination not finished, should not start new RM
+        assertNotComplete(startRmFuture2);
+
+        // finish first RM termination
+        finishRmTerminationFuture.complete(null);
+
+        // should start new RM and confirm leader session
+        assertThat(startRmFuture2.get(TIMEOUT.getSize(), TIMEOUT.getUnit()), is(leaderSessionId2));
+        assertThat(
+                leaderElectionService
+                        .getConfirmationFuture()
+                        .get(TIMEOUT.getSize(), TIMEOUT.getUnit())
+                        .getLeaderSessionId(),
+                is(leaderSessionId2));
+    }
+
+    @Test
+    public void grantLeadership_notStarted_doesNotStartNewRm() throws Exception {
+        final CompletableFuture<UUID> startRmFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setInitializeConsumer(startRmFuture::complete);
+
+        createResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(UUID.randomUUID());
+
+        // service not started, should not start new RM
+        assertNotComplete(startRmFuture);
+        assertNotComplete(leaderElectionService.getConfirmationFuture());
+    }
+
+    @Test
+    public void grantLeadership_stopped_doesNotStartNewRm() throws Exception {
+        final CompletableFuture<UUID> startRmFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setInitializeConsumer(startRmFuture::complete);
+
+        createAndStartResourceManager();
+        resourceManagerService.close();
+
+        // grant leadership
+        leaderElectionService.isLeader(UUID.randomUUID());
+
+        // service stopped, should not start new RM
+        assertNotComplete(startRmFuture);
+        assertNotComplete(leaderElectionService.getConfirmationFuture());
+    }
+
+    @Test
+    public void revokeLeadership_stopExistLeader() throws Exception {
+        final UUID leaderSessionId = UUID.randomUUID();
+        final CompletableFuture<UUID> terminateRmFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setTerminateConsumer(terminateRmFuture::complete);
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(leaderSessionId);
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // revoke leadership
+        leaderElectionService.notLeader();
+
+        // should terminate RM
+        assertThat(
+                terminateRmFuture.get(TIMEOUT.getSize(), TIMEOUT.getUnit()), is(leaderSessionId));
+    }
+
+    @Test
+    public void revokeLeadership_terminateService_multiLeaderSessionDisabled() throws Exception {
+        System.clearProperty(ResourceManagerServiceImpl.ENABLE_MULTI_LEADER_SESSION_PROPERTY);
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(UUID.randomUUID());
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // revoke leadership
+        leaderElectionService.notLeader();
+
+        // should terminate service
+        resourceManagerService.getTerminationFuture().get(TIMEOUT.getSize(), TIMEOUT.getUnit());
+    }
+
+    @Test
+    public void leaderRmTerminated_terminateService() throws Exception {
+        final UUID leaderSessionId = UUID.randomUUID();
+        final CompletableFuture<Void> rmTerminationFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setGetTerminationFutureFunction((ignore1, ignore2) -> rmTerminationFuture);
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(leaderSessionId);
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // terminate RM
+        rmTerminationFuture.complete(null);
+
+        // should terminate service
+        resourceManagerService.getTerminationFuture().get(TIMEOUT.getSize(), TIMEOUT.getUnit());
+    }
+
+    @Test
+    public void nonLeaderRmTerminated_doseNotTerminateService() throws Exception {
+        final UUID leaderSessionId = UUID.randomUUID();
+        final CompletableFuture<UUID> terminateRmFuture = new CompletableFuture<>();
+        final CompletableFuture<Void> rmTerminationFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder
+                .setTerminateConsumer(terminateRmFuture::complete)
+                .setGetTerminationFutureFunction((ignore1, ignore2) -> rmTerminationFuture);
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(leaderSessionId);
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // revoke leadership
+        leaderElectionService.notLeader();
+        assertThat(
+                terminateRmFuture.get(TIMEOUT.getSize(), TIMEOUT.getUnit()), is(leaderSessionId));
+
+        // terminate RM
+        rmTerminationFuture.complete(null);
+
+        // should not terminate service
+        assertNotComplete(resourceManagerService.getTerminationFuture());
+    }
+
+    @Test
+    public void closeService_stopRmAndLeaderElection() throws Exception {
+        final CompletableFuture<UUID> terminateRmFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setTerminateConsumer(terminateRmFuture::complete);
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(UUID.randomUUID());
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+        assertFalse(leaderElectionService.isStopped());
+
+        // close service
+        resourceManagerService.close();
+
+        // should stop RM and leader election
+        assertTrue(terminateRmFuture.isDone());
+        assertTrue(leaderElectionService.isStopped());
+    }
+
+    @Test
+    public void closeService_futureCompleteAfterRmTerminated() throws Exception {
+        final CompletableFuture<Void> finishRmTerminationFuture = new CompletableFuture<>();
+
+        rmFactoryBuilder.setTerminateConsumer((ignore) -> blockOnFuture(finishRmTerminationFuture));
+
+        createAndStartResourceManager();
+
+        // grant leadership
+        leaderElectionService.isLeader(UUID.randomUUID());
+
+        // make sure RM started, before proceeding the next step
+        assertRmStarted();
+
+        // close service
+        final CompletableFuture<Void> closeServiceFuture = resourceManagerService.closeAsync();
+
+        // RM termination not finished, future should not complete
+        assertNotComplete(closeServiceFuture);
+
+        // finish RM termination
+        finishRmTerminationFuture.complete(null);
+
+        closeServiceFuture.get(TIMEOUT.getSize(), TIMEOUT.getUnit());
+    }
+
+    private static void blockOnFuture(CompletableFuture<?> future) {
+        try {
+            future.get();
+        } catch (Exception e) {
+            e.printStackTrace();
+            fail();
+        }
+    }
+
+    private static void assertNotComplete(CompletableFuture<?> future) throws Exception {
+        try {
+            future.get(FAST_TIMEOUT.getSize(), FAST_TIMEOUT.getUnit());
+            fail();
+        } catch (TimeoutException e) {
+            // expected
+        }
+    }
+
+    private void assertRmStarted() throws Exception {
+        leaderElectionService.getConfirmationFuture().get(TIMEOUT.getSize(), TIMEOUT.getUnit());
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java
index 9223bbe21ea..ebbfa0c8b04 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTaskExecutorTest.java
@@ -23,19 +23,10 @@ import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
 import org.apache.flink.runtime.clusterframework.types.SlotID;
-import org.apache.flink.runtime.entrypoint.ClusterInformation;
-import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
 import org.apache.flink.runtime.instance.HardwareDescription;
 import org.apache.flink.runtime.instance.InstanceID;
-import org.apache.flink.runtime.io.network.partition.NoOpResourceManagerPartitionTracker;
-import org.apache.flink.runtime.leaderelection.LeaderElectionService;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
-import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.runtime.registration.RegistrationResponse;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
-import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerBuilder;
-import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcUtils;
 import org.apache.flink.runtime.rpc.TestingRpcService;
 import org.apache.flink.runtime.rpc.exceptions.FencingTokenException;
@@ -47,7 +38,6 @@ import org.apache.flink.runtime.taskexecutor.TaskExecutorRegistrationSuccess;
 import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;
 import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
-import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
@@ -62,7 +52,6 @@ import java.util.Collection;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.stream.Collectors;
@@ -82,7 +71,8 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
 
     private static final Time TIMEOUT = Time.seconds(10L);
 
-    private static final long HEARTBEAT_TIMEOUT = 5000;
+    private static final ResourceProfile DEFAULT_SLOT_PROFILE =
+            ResourceProfile.fromResources(1.0, 1234);
 
     private static TestingRpcService rpcService;
 
@@ -96,16 +86,12 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
 
     private ResourceID taskExecutorResourceID;
 
-    private ResourceID resourceManagerResourceID;
-
-    private StandaloneResourceManager resourceManager;
+    private TestingResourceManagerService rmService;
 
     private ResourceManagerGateway rmGateway;
 
     private ResourceManagerGateway wronglyFencedGateway;
 
-    private TestingFatalErrorHandler testingFatalErrorHandler;
-
     @BeforeClass
     public static void setupClass() {
         rpcService = new TestingRpcService();
@@ -117,22 +103,16 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
 
         createAndRegisterTaskExecutorGateway();
         taskExecutorResourceID = ResourceID.generate();
-        resourceManagerResourceID = ResourceID.generate();
-        testingFatalErrorHandler = new TestingFatalErrorHandler();
-        TestingLeaderElectionService rmLeaderElectionService = new TestingLeaderElectionService();
-        resourceManager =
-                createAndStartResourceManager(rmLeaderElectionService, testingFatalErrorHandler);
-        rmGateway = resourceManager.getSelfGateway(ResourceManagerGateway.class);
+
+        createAndStartResourceManager();
+
         wronglyFencedGateway =
                 rpcService
                         .connect(
-                                resourceManager.getAddress(),
+                                rmGateway.getAddress(),
                                 ResourceManagerId.generate(),
                                 ResourceManagerGateway.class)
                         .get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
-
-        grantLeadership(rmLeaderElectionService)
-                .get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
     }
 
     private void createAndRegisterTaskExecutorGateway() {
@@ -141,60 +121,38 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
         rpcService.registerGateway(taskExecutorGateway.getAddress(), taskExecutorGateway);
     }
 
-    private CompletableFuture<UUID> grantLeadership(
-            TestingLeaderElectionService leaderElectionService) {
-        UUID leaderSessionId = UUID.randomUUID();
-        return leaderElectionService.isLeader(leaderSessionId);
-    }
-
-    private StandaloneResourceManager createAndStartResourceManager(
-            LeaderElectionService rmLeaderElectionService, FatalErrorHandler fatalErrorHandler)
-            throws Exception {
-        TestingHighAvailabilityServices highAvailabilityServices =
-                new TestingHighAvailabilityServices();
-        HeartbeatServices heartbeatServices = new HeartbeatServices(1000L, HEARTBEAT_TIMEOUT);
-        highAvailabilityServices.setResourceManagerLeaderElectionService(rmLeaderElectionService);
-
-        SlotManager slotManager =
-                SlotManagerBuilder.newBuilder()
-                        .setScheduledExecutor(rpcService.getScheduledExecutor())
+    private void createAndStartResourceManager() throws Exception {
+        final TestingLeaderElectionService leaderElectionService =
+                new TestingLeaderElectionService();
+        rmService =
+                TestingResourceManagerService.newBuilder()
+                        .setRpcService(rpcService)
+                        .setRmLeaderElectionService(leaderElectionService)
                         .build();
 
-        JobLeaderIdService jobLeaderIdService =
-                new DefaultJobLeaderIdService(
-                        highAvailabilityServices,
-                        rpcService.getScheduledExecutor(),
-                        Time.minutes(5L));
-
-        StandaloneResourceManager resourceManager =
-                new StandaloneResourceManager(
-                        rpcService,
-                        resourceManagerResourceID,
-                        highAvailabilityServices,
-                        heartbeatServices,
-                        slotManager,
-                        NoOpResourceManagerPartitionTracker::get,
-                        jobLeaderIdService,
-                        new ClusterInformation("localhost", 1234),
-                        fatalErrorHandler,
-                        UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup(),
-                        Time.minutes(5L),
-                        RpcUtils.INF_TIMEOUT,
-                        ForkJoinPool.commonPool());
-
-        resourceManager.start();
-
-        return resourceManager;
+        rmService.start();
+        rmService.isLeader(UUID.randomUUID());
+
+        leaderElectionService
+                .getConfirmationFuture()
+                .thenRun(
+                        () -> {
+                            rmGateway =
+                                    rmService
+                                            .getResourceManagerGateway()
+                                            .orElseThrow(
+                                                    () ->
+                                                            new AssertionError(
+                                                                    "RM not available after confirming leadership."));
+                        })
+                .get(TIMEOUT.getSize(), TIMEOUT.getUnit());
     }
 
     @After
     public void teardown() throws Exception {
-        if (resourceManager != null) {
-            RpcUtils.terminateRpcEndpoint(resourceManager, TIMEOUT);
-        }
-
-        if (testingFatalErrorHandler != null && testingFatalErrorHandler.hasExceptionOccurred()) {
-            testingFatalErrorHandler.rethrowError();
+        if (rmService != null) {
+            rmService.rethrowFatalErrorIfAny();
+            rmService.cleanUp();
         }
     }
 
@@ -272,8 +230,8 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
                             hardwareDescription,
                             new TaskExecutorMemoryConfiguration(
                                     1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L),
-                            ResourceProfile.ZERO,
-                            ResourceProfile.ZERO);
+                            DEFAULT_SLOT_PROFILE,
+                            DEFAULT_SLOT_PROFILE);
 
             CompletableFuture<RegistrationResponse> firstFuture =
                     rmGateway.registerTaskExecutor(taskExecutorRegistration, fastTimeout);
@@ -331,13 +289,24 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
     /** Tests that a TaskExecutor can disconnect from the {@link ResourceManager}. */
     @Test
     public void testDisconnectTaskExecutor() throws Exception {
+        final int numberSlots = 10;
+        final TaskExecutorRegistration taskExecutorRegistration =
+                new TaskExecutorRegistration(
+                        taskExecutorGateway.getAddress(),
+                        taskExecutorResourceID,
+                        dataPort,
+                        jmxPort,
+                        hardwareDescription,
+                        new TaskExecutorMemoryConfiguration(
+                                1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L),
+                        DEFAULT_SLOT_PROFILE,
+                        DEFAULT_SLOT_PROFILE.multiply(numberSlots));
         final RegistrationResponse registrationResponse =
-                registerTaskExecutor(rmGateway, taskExecutorGateway.getAddress()).get();
+                rmGateway.registerTaskExecutor(taskExecutorRegistration, TIMEOUT).get();
         assertThat(registrationResponse, instanceOf(TaskExecutorRegistrationSuccess.class));
 
         final InstanceID registrationId =
                 ((TaskExecutorRegistrationSuccess) registrationResponse).getRegistrationId();
-        final int numberSlots = 10;
         final Collection<SlotStatus> slots = createSlots(numberSlots);
         final SlotReport slotReport = new SlotReport(slots);
         rmGateway.sendSlotReport(taskExecutorResourceID, registrationId, slotReport, TIMEOUT).get();
@@ -407,8 +376,8 @@ public class ResourceManagerTaskExecutorTest extends TestLogger {
                         hardwareDescription,
                         new TaskExecutorMemoryConfiguration(
                                 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L),
-                        ResourceProfile.ZERO,
-                        ResourceProfile.ZERO),
+                        DEFAULT_SLOT_PROFILE,
+                        DEFAULT_SLOT_PROFILE),
                 TIMEOUT);
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java
index 070445152c4..96cca74a5f2 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/ResourceManagerTest.java
@@ -95,8 +95,6 @@ public class ResourceManagerTest extends TestLogger {
 
     private TestingHighAvailabilityServices highAvailabilityServices;
 
-    private TestingLeaderElectionService resourceManagerLeaderElectionService;
-
     private TestingFatalErrorHandler testingFatalErrorHandler;
 
     private ResourceID resourceManagerResourceId;
@@ -113,9 +111,8 @@ public class ResourceManagerTest extends TestLogger {
     @Before
     public void setup() throws Exception {
         highAvailabilityServices = new TestingHighAvailabilityServices();
-        resourceManagerLeaderElectionService = new TestingLeaderElectionService();
         highAvailabilityServices.setResourceManagerLeaderElectionService(
-                resourceManagerLeaderElectionService);
+                new TestingLeaderElectionService());
         testingFatalErrorHandler = new TestingFatalErrorHandler();
         resourceManagerResourceId = ResourceID.generate();
     }
@@ -463,11 +460,12 @@ public class ResourceManagerTest extends TestLogger {
             SlotManager slotManager)
             throws Exception {
 
+        resourceManagerId = ResourceManagerId.generate();
         final TestingResourceManager resourceManager =
                 new TestingResourceManager(
                         rpcService,
+                        resourceManagerId.toUUID(),
                         resourceManagerResourceId,
-                        highAvailabilityServices,
                         heartbeatServices,
                         slotManager,
                         NoOpResourceManagerPartitionTracker::get,
@@ -476,10 +474,7 @@ public class ResourceManagerTest extends TestLogger {
                         UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup());
 
         resourceManager.start();
-
-        // first make the ResourceManager the leader
-        resourceManagerId = ResourceManagerId.generate();
-        resourceManagerLeaderElectionService.isLeader(resourceManagerId.toUUID()).get();
+        resourceManager.getStartedFuture().get(TIMEOUT.getSize(), TIMEOUT.getUnit());
 
         return resourceManager;
     }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerTest.java
index f35aeb3ed48..4fb97ed1d16 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/StandaloneResourceManagerTest.java
@@ -22,7 +22,6 @@ import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.NoOpResourceManagerPartitionTracker;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
@@ -39,6 +38,7 @@ import org.apache.flink.util.TestLogger;
 import org.junit.ClassRule;
 import org.junit.Test;
 
+import java.util.UUID;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -95,28 +95,6 @@ public class StandaloneResourceManagerTest extends TestLogger {
         rm.close();
     }
 
-    @Test
-    public void testStartUpPeriodAfterLeadershipSwitch() throws Exception {
-        final LinkedBlockingQueue<Boolean> setFailUnfulfillableRequestInvokes =
-                new LinkedBlockingQueue<>();
-        final SlotManager slotManager =
-                new TestingSlotManagerBuilder()
-                        .setSetFailUnfulfillableRequestConsumer(
-                                setFailUnfulfillableRequestInvokes::add)
-                        .createSlotManager();
-        final TestingStandaloneResourceManager rm =
-                createResourceManager(Time.milliseconds(1L), slotManager);
-
-        assertThat(setFailUnfulfillableRequestInvokes.take(), is(false));
-        assertThat(setFailUnfulfillableRequestInvokes.take(), is(true));
-
-        rm.rmServices.revokeLeadership();
-        rm.rmServices.grantLeadership();
-
-        assertThat(setFailUnfulfillableRequestInvokes.take(), is(false));
-        assertThat(setFailUnfulfillableRequestInvokes.take(), is(true));
-    }
-
     private TestingStandaloneResourceManager createResourceManager(
             Time startupPeriod, SlotManager slotManager) throws Exception {
 
@@ -127,42 +105,39 @@ public class StandaloneResourceManagerTest extends TestLogger {
         final TestingStandaloneResourceManager rm =
                 new TestingStandaloneResourceManager(
                         rmServices.rpcService,
+                        UUID.randomUUID(),
                         ResourceID.generate(),
-                        rmServices.highAvailabilityServices,
                         rmServices.heartbeatServices,
                         rmServices.slotManager,
                         rmServices.jobLeaderIdService,
                         new ClusterInformation("localhost", 1234),
                         fatalErrorHandler,
                         UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup(),
-                        startupPeriod,
-                        rmServices);
+                        startupPeriod);
 
         rm.start();
-        rmServices.grantLeadership();
+        rm.getStartedFuture().get(TIMEOUT.getSize(), TIMEOUT.getUnit());
 
         return rm;
     }
 
     private static class TestingStandaloneResourceManager extends StandaloneResourceManager {
-        private final MockResourceManagerRuntimeServices rmServices;
 
         private TestingStandaloneResourceManager(
                 RpcService rpcService,
+                UUID leaderSessionId,
                 ResourceID resourceId,
-                HighAvailabilityServices highAvailabilityServices,
                 HeartbeatServices heartbeatServices,
                 SlotManager slotManager,
                 JobLeaderIdService jobLeaderIdService,
                 ClusterInformation clusterInformation,
                 FatalErrorHandler fatalErrorHandler,
                 ResourceManagerMetricGroup resourceManagerMetricGroup,
-                Time startupPeriodTime,
-                MockResourceManagerRuntimeServices rmServices) {
+                Time startupPeriodTime) {
             super(
                     rpcService,
+                    leaderSessionId,
                     resourceId,
-                    highAvailabilityServices,
                     heartbeatServices,
                     slotManager,
                     NoOpResourceManagerPartitionTracker::get,
@@ -173,7 +148,6 @@ public class StandaloneResourceManagerTest extends TestLogger {
                     startupPeriodTime,
                     RpcUtils.INF_TIMEOUT,
                     ForkJoinPool.commonPool());
-            this.rmServices = rmServices;
         }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManager.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManager.java
index 6479a45df4f..54adb32d852 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManager.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManager.java
@@ -22,7 +22,6 @@ import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
-import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerFactory;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
 import org.apache.flink.runtime.resourcemanager.exceptions.ResourceManagerException;
@@ -33,6 +32,7 @@ import org.apache.flink.runtime.rpc.RpcUtils;
 
 import javax.annotation.Nullable;
 
+import java.util.UUID;
 import java.util.concurrent.ForkJoinPool;
 
 /** Simple {@link ResourceManager} implementation for testing purposes. */
@@ -40,8 +40,8 @@ public class TestingResourceManager extends ResourceManager<ResourceID> {
 
     public TestingResourceManager(
             RpcService rpcService,
+            UUID leaderSessionId,
             ResourceID resourceId,
-            HighAvailabilityServices highAvailabilityServices,
             HeartbeatServices heartbeatServices,
             SlotManager slotManager,
             ResourceManagerPartitionTrackerFactory clusterPartitionTrackerFactory,
@@ -50,8 +50,8 @@ public class TestingResourceManager extends ResourceManager<ResourceID> {
             ResourceManagerMetricGroup resourceManagerMetricGroup) {
         super(
                 rpcService,
+                leaderSessionId,
                 resourceId,
-                highAvailabilityServices,
                 heartbeatServices,
                 slotManager,
                 clusterPartitionTrackerFactory,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerFactory.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerFactory.java
new file mode 100644
index 00000000000..377d10225e1
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerFactory.java
@@ -0,0 +1,217 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.resourcemanager;
+
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.akka.AkkaUtils;
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;
+import org.apache.flink.runtime.clusterframework.types.ResourceID;
+import org.apache.flink.runtime.entrypoint.ClusterInformation;
+import org.apache.flink.runtime.heartbeat.HeartbeatServices;
+import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerFactory;
+import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerImpl;
+import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
+import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.runtime.rpc.RpcService;
+import org.apache.flink.util.ConfigurationException;
+import org.apache.flink.util.function.TriConsumer;
+
+import javax.annotation.Nullable;
+
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+
+/** Implementation of {@link ResourceManagerFactory} for testing purpose. */
+public class TestingResourceManagerFactory extends ResourceManagerFactory<ResourceID> {
+
+    private final Consumer<UUID> initializeConsumer;
+    private final Consumer<UUID> terminateConsumer;
+    private final TriConsumer<UUID, ApplicationStatus, String>
+            internalDeregisterApplicationConsumer;
+    private final BiFunction<ResourceManager<?>, CompletableFuture<Void>, CompletableFuture<Void>>
+            getTerminationFutureFunction;
+
+    public TestingResourceManagerFactory(
+            Consumer<UUID> initializeConsumer,
+            Consumer<UUID> terminateConsumer,
+            TriConsumer<UUID, ApplicationStatus, String> internalDeregisterApplicationConsumer,
+            BiFunction<ResourceManager<?>, CompletableFuture<Void>, CompletableFuture<Void>>
+                    getTerminationFutureFunction) {
+        this.initializeConsumer = initializeConsumer;
+        this.terminateConsumer = terminateConsumer;
+        this.internalDeregisterApplicationConsumer = internalDeregisterApplicationConsumer;
+        this.getTerminationFutureFunction = getTerminationFutureFunction;
+    }
+
+    @Override
+    protected ResourceManager<ResourceID> createResourceManager(
+            Configuration configuration,
+            ResourceID resourceId,
+            RpcService rpcService,
+            UUID leaderSessionId,
+            HeartbeatServices heartbeatServices,
+            FatalErrorHandler fatalErrorHandler,
+            ClusterInformation clusterInformation,
+            @Nullable String webInterfaceUrl,
+            ResourceManagerMetricGroup resourceManagerMetricGroup,
+            ResourceManagerRuntimeServices resourceManagerRuntimeServices,
+            Executor ioExecutor) {
+
+        return new MockResourceManager(
+                rpcService,
+                leaderSessionId,
+                resourceId,
+                heartbeatServices,
+                resourceManagerRuntimeServices.getSlotManager(),
+                ResourceManagerPartitionTrackerImpl::new,
+                resourceManagerRuntimeServices.getJobLeaderIdService(),
+                clusterInformation,
+                fatalErrorHandler,
+                resourceManagerMetricGroup,
+                AkkaUtils.getTimeoutAsTime(configuration),
+                ioExecutor);
+    }
+
+    @Override
+    protected ResourceManagerRuntimeServicesConfiguration
+            createResourceManagerRuntimeServicesConfiguration(Configuration configuration)
+                    throws ConfigurationException {
+        return StandaloneResourceManagerFactory.getInstance()
+                .createResourceManagerRuntimeServicesConfiguration(configuration);
+    }
+
+    public static class Builder {
+        private Consumer<UUID> initializeConsumer = (ignore) -> {};
+        private Consumer<UUID> terminateConsumer = (ignore) -> {};
+        private TriConsumer<UUID, ApplicationStatus, String> internalDeregisterApplicationConsumer =
+                (ignore1, ignore2, ignore3) -> {};
+        private BiFunction<ResourceManager<?>, CompletableFuture<Void>, CompletableFuture<Void>>
+                getTerminationFutureFunction =
+                        (rm, superTerminationFuture) -> superTerminationFuture;
+
+        public Builder setInitializeConsumer(Consumer<UUID> initializeConsumer) {
+            this.initializeConsumer = initializeConsumer;
+            return this;
+        }
+
+        public Builder setTerminateConsumer(Consumer<UUID> terminateConsumer) {
+            this.terminateConsumer = terminateConsumer;
+            return this;
+        }
+
+        public Builder setInternalDeregisterApplicationConsumer(
+                TriConsumer<UUID, ApplicationStatus, String>
+                        internalDeregisterApplicationConsumer) {
+            this.internalDeregisterApplicationConsumer = internalDeregisterApplicationConsumer;
+            return this;
+        }
+
+        public Builder setGetTerminationFutureFunction(
+                BiFunction<ResourceManager<?>, CompletableFuture<Void>, CompletableFuture<Void>>
+                        getTerminationFutureFunction) {
+            this.getTerminationFutureFunction = getTerminationFutureFunction;
+            return this;
+        }
+
+        public TestingResourceManagerFactory build() {
+            return new TestingResourceManagerFactory(
+                    initializeConsumer,
+                    terminateConsumer,
+                    internalDeregisterApplicationConsumer,
+                    getTerminationFutureFunction);
+        }
+    }
+
+    private class MockResourceManager extends ResourceManager<ResourceID> {
+
+        private final UUID leaderSessionId;
+
+        public MockResourceManager(
+                RpcService rpcService,
+                UUID leaderSessionId,
+                ResourceID resourceId,
+                HeartbeatServices heartbeatServices,
+                SlotManager slotManager,
+                ResourceManagerPartitionTrackerFactory clusterPartitionTrackerFactory,
+                JobLeaderIdService jobLeaderIdService,
+                ClusterInformation clusterInformation,
+                FatalErrorHandler fatalErrorHandler,
+                ResourceManagerMetricGroup resourceManagerMetricGroup,
+                Time rpcTimeout,
+                Executor ioExecutor) {
+            super(
+                    rpcService,
+                    leaderSessionId,
+                    resourceId,
+                    heartbeatServices,
+                    slotManager,
+                    clusterPartitionTrackerFactory,
+                    jobLeaderIdService,
+                    clusterInformation,
+                    fatalErrorHandler,
+                    resourceManagerMetricGroup,
+                    rpcTimeout,
+                    ioExecutor);
+            this.leaderSessionId = leaderSessionId;
+        }
+
+        @Override
+        protected void initialize() {
+            initializeConsumer.accept(leaderSessionId);
+        }
+
+        @Override
+        protected void terminate() {
+            terminateConsumer.accept(leaderSessionId);
+        }
+
+        @Override
+        protected void internalDeregisterApplication(
+                ApplicationStatus finalStatus, @Nullable String optionalDiagnostics) {
+            internalDeregisterApplicationConsumer.accept(
+                    leaderSessionId, finalStatus, optionalDiagnostics);
+        }
+
+        @Override
+        public boolean startNewWorker(WorkerResourceSpec workerResourceSpec) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        protected ResourceID workerStarted(ResourceID resourceID) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public boolean stopWorker(ResourceID worker) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public CompletableFuture<Void> getTerminationFuture() {
+            return getTerminationFutureFunction.apply(
+                    MockResourceManager.this, super.getTerminationFuture());
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerService.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerService.java
index d9c7c0845df..1128b54d1a0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerService.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/TestingResourceManagerService.java
@@ -18,82 +18,185 @@
 
 package org.apache.flink.runtime.resourcemanager;
 
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.configuration.Configuration;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.entrypoint.ClusterInformation;
+import org.apache.flink.runtime.heartbeat.TestingHeartbeatServices;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
+import org.apache.flink.runtime.leaderretrieval.LeaderRetrievalService;
+import org.apache.flink.runtime.metrics.util.TestingMetricRegistry;
+import org.apache.flink.runtime.rpc.FencedRpcEndpoint;
+import org.apache.flink.runtime.rpc.RpcEndpoint;
+import org.apache.flink.runtime.rpc.RpcService;
+import org.apache.flink.runtime.rpc.TestingRpcService;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 
 import javax.annotation.Nullable;
 
+import java.util.Optional;
+import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ForkJoinPool;
+import java.util.function.Function;
+
+import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /** Implementation of {@link ResourceManagerService} for testing purpose. */
 public class TestingResourceManagerService implements ResourceManagerService {
 
-    private final CompletableFuture<Void> terminationFuture;
-    private final CompletableFuture<Void> deregisterApplicationFuture;
-    private final boolean completeTerminationFutureOnClose;
+    private static final Time TIMEOUT = Time.seconds(10L);
+
+    private final ResourceManagerServiceImpl rmService;
+    private final TestingLeaderElectionService leaderElectionService;
+    private final TestingFatalErrorHandler fatalErrorHandler;
+    private final RpcService rpcService;
+    private final boolean needStopRpcService;
 
     private TestingResourceManagerService(
-            CompletableFuture<Void> terminationFuture,
-            CompletableFuture<Void> deregisterApplicationFuture,
-            boolean completeTerminationFutureOnClose) {
-        this.terminationFuture = terminationFuture;
-        this.deregisterApplicationFuture = deregisterApplicationFuture;
-        this.completeTerminationFutureOnClose = completeTerminationFutureOnClose;
+            ResourceManagerServiceImpl rmService,
+            TestingLeaderElectionService leaderElectionService,
+            TestingFatalErrorHandler fatalErrorHandler,
+            RpcService rpcService,
+            boolean needStopRpcService) {
+        this.rmService = rmService;
+        this.leaderElectionService = leaderElectionService;
+        this.fatalErrorHandler = fatalErrorHandler;
+        this.rpcService = rpcService;
+        this.needStopRpcService = needStopRpcService;
     }
 
     @Override
-    public void start() throws Exception {}
+    public void start() throws Exception {
+        rmService.start();
+    }
 
     @Override
     public CompletableFuture<Void> getTerminationFuture() {
-        return terminationFuture;
+        return rmService.getTerminationFuture();
     }
 
     @Override
     public CompletableFuture<Void> deregisterApplication(
             ApplicationStatus applicationStatus, @Nullable String diagnostics) {
-        return deregisterApplicationFuture;
+        return rmService.deregisterApplication(applicationStatus, diagnostics);
     }
 
     @Override
     public CompletableFuture<Void> closeAsync() {
-        if (completeTerminationFutureOnClose) {
-            terminationFuture.complete(null);
+        return rmService.closeAsync();
+    }
+
+    public Optional<ResourceManagerGateway> getResourceManagerGateway() {
+        return getResourceManagerOpt().map(rm -> rm.getSelfGateway(ResourceManagerGateway.class));
+    }
+
+    public Optional<ResourceManagerId> getResourceManagerFencingToken() {
+        return getResourceManagerOpt().map(FencedRpcEndpoint::getFencingToken);
+    }
+
+    public Optional<CompletableFuture<Void>> getResourceManagerTerminationFuture() {
+        return getResourceManagerOpt().map(RpcEndpoint::getTerminationFuture);
+    }
+
+    private Optional<ResourceManager<?>> getResourceManagerOpt() {
+        return Optional.ofNullable(rmService.getLeaderResourceManager());
+    }
+
+    public void isLeader(UUID uuid) {
+        leaderElectionService.isLeader(uuid);
+    }
+
+    public void notLeader() {
+        leaderElectionService.notLeader();
+    }
+
+    public void rethrowFatalErrorIfAny() throws Exception {
+        if (fatalErrorHandler.hasExceptionOccurred()) {
+            fatalErrorHandler.rethrowError();
         }
-        return getTerminationFuture();
+    }
+
+    public void ignoreFatalErrors() {
+        fatalErrorHandler.clearError();
+    }
+
+    public void cleanUp() throws Exception {
+        rmService
+                .closeAsync()
+                .thenCompose((ignore) -> this.stopRpcServiceIfNeeded())
+                .get(TIMEOUT.getSize(), TIMEOUT.getUnit());
+    }
+
+    private CompletableFuture<Void> stopRpcServiceIfNeeded() {
+        return needStopRpcService ? rpcService.stopService() : FutureUtils.completedVoidFuture();
     }
 
     public static Builder newBuilder() {
         return new Builder();
     }
 
-    public static final class Builder {
-        private CompletableFuture<Void> terminationFuture = new CompletableFuture<>();
-        private CompletableFuture<Void> deregisterApplicationFuture =
-                FutureUtils.completedVoidFuture();
-        private boolean completeTerminationFutureOnClose = true;
+    public static class Builder {
+
+        private RpcService rpcService = null;
+        private boolean needStopRpcService = true;
+        private TestingLeaderElectionService rmLeaderElectionService = null;
+        private Function<JobID, LeaderRetrievalService> jmLeaderRetrieverFunction = null;
 
-        public Builder setTerminationFuture(CompletableFuture<Void> terminationFuture) {
-            this.terminationFuture = terminationFuture;
+        public Builder setRpcService(RpcService rpcService) {
+            this.rpcService = checkNotNull(rpcService);
+            this.needStopRpcService = false;
             return this;
         }
 
-        public Builder setDeregisterApplicationFuture(
-                CompletableFuture<Void> deregisterApplicationFuture) {
-            this.deregisterApplicationFuture = deregisterApplicationFuture;
+        public Builder setRmLeaderElectionService(
+                TestingLeaderElectionService rmLeaderElectionService) {
+            this.rmLeaderElectionService = checkNotNull(rmLeaderElectionService);
             return this;
         }
 
-        public Builder withManualTerminationFutureCompletion() {
-            this.completeTerminationFutureOnClose = false;
+        public Builder setJmLeaderRetrieverFunction(
+                Function<JobID, LeaderRetrievalService> jmLeaderRetrieverFunction) {
+            this.jmLeaderRetrieverFunction = checkNotNull(jmLeaderRetrieverFunction);
             return this;
         }
 
-        public TestingResourceManagerService build() {
+        public TestingResourceManagerService build() throws Exception {
+            rpcService = rpcService != null ? rpcService : new TestingRpcService();
+            rmLeaderElectionService =
+                    rmLeaderElectionService != null
+                            ? rmLeaderElectionService
+                            : new TestingLeaderElectionService();
+
+            final TestingHighAvailabilityServices haServices =
+                    new TestingHighAvailabilityServices();
+            haServices.setResourceManagerLeaderElectionService(rmLeaderElectionService);
+            if (jmLeaderRetrieverFunction != null) {
+                haServices.setJobMasterLeaderRetrieverFunction(jmLeaderRetrieverFunction);
+            }
+
+            final TestingFatalErrorHandler fatalErrorHandler = new TestingFatalErrorHandler();
+
             return new TestingResourceManagerService(
-                    terminationFuture,
-                    deregisterApplicationFuture,
-                    completeTerminationFutureOnClose);
+                    ResourceManagerServiceImpl.create(
+                            StandaloneResourceManagerFactory.getInstance(),
+                            new Configuration(),
+                            rpcService,
+                            haServices,
+                            new TestingHeartbeatServices(),
+                            fatalErrorHandler,
+                            new ClusterInformation("localhost", 1234),
+                            null,
+                            TestingMetricRegistry.builder().build(),
+                            "localhost",
+                            ForkJoinPool.commonPool()),
+                    rmLeaderElectionService,
+                    fatalErrorHandler,
+                    rpcService,
+                    needStopRpcService);
         }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
index 18e3a319a5f..896d4cb9775 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
@@ -53,6 +53,7 @@ import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ForkJoinPool;
@@ -890,8 +891,8 @@ public class ActiveResourceManagerTest extends TestLogger {
                             driver,
                             configuration,
                             rpcService,
+                            UUID.randomUUID(),
                             ResourceID.generate(),
-                            rmServices.highAvailabilityServices,
                             rmServices.heartbeatServices,
                             rmServices.slotManager,
                             NoOpResourceManagerPartitionTracker::get,
@@ -906,7 +907,9 @@ public class ActiveResourceManagerTest extends TestLogger {
                             ForkJoinPool.commonPool());
 
             activeResourceManager.start();
-            rmServices.grantLeadership();
+            activeResourceManager
+                    .getStartedFuture()
+                    .get(TIMEOUT_TIME.getSize(), TIMEOUT_TIME.getUnit());
 
             return activeResourceManager;
         }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriverTestBase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriverTestBase.java
index 2471ad46306..39af4220c5f 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriverTestBase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ResourceManagerDriverTestBase.java
@@ -82,7 +82,6 @@ public abstract class ResourceManagerDriverTestBase<WorkerType extends ResourceI
         final Context context = createContext();
         context.runTest(
                 () -> {
-                    context.getDriver().onRevokeLeadership();
                     context.getDriver().terminate();
                     context.validateTermination();
                 });
@@ -179,7 +178,6 @@ public abstract class ResourceManagerDriverTestBase<WorkerType extends ResourceI
                     resourceEventHandlerBuilder.build(),
                     mainThreadExecutor,
                     ForkJoinPool.commonPool());
-            driver.onGrantLeadership();
 
             testMethod.run();
         }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/TestingResourceManagerDriver.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/TestingResourceManagerDriver.java
index 1cf76b41fb1..f8e8f8b7cff 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/TestingResourceManagerDriver.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/TestingResourceManagerDriver.java
@@ -32,7 +32,6 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 import java.util.function.Function;
-import java.util.function.Supplier;
 
 /** Testing implementation of {@link ResourceManagerDriver}. */
 public class TestingResourceManagerDriver implements ResourceManagerDriver<ResourceID> {
@@ -40,7 +39,6 @@ public class TestingResourceManagerDriver implements ResourceManagerDriver<Resou
     private final TriFunctionWithException<
                     ResourceEventHandler<ResourceID>, ScheduledExecutor, Executor, Void, Exception>
             initializeFunction;
-    private final Supplier<CompletableFuture<Void>> terminateSupplier;
     private final BiConsumerWithException<ApplicationStatus, String, Exception>
             deregisterApplicationConsumer;
     private final Function<TaskExecutorProcessSpec, CompletableFuture<ResourceID>>
@@ -55,14 +53,12 @@ public class TestingResourceManagerDriver implements ResourceManagerDriver<Resou
                             Void,
                             Exception>
                     initializeFunction,
-            final Supplier<CompletableFuture<Void>> terminateSupplier,
             final BiConsumerWithException<ApplicationStatus, String, Exception>
                     deregisterApplicationConsumer,
             final Function<TaskExecutorProcessSpec, CompletableFuture<ResourceID>>
                     requestResourceFunction,
             final Consumer<ResourceID> releaseResourceConsumer) {
         this.initializeFunction = Preconditions.checkNotNull(initializeFunction);
-        this.terminateSupplier = Preconditions.checkNotNull(terminateSupplier);
         this.deregisterApplicationConsumer =
                 Preconditions.checkNotNull(deregisterApplicationConsumer);
         this.requestResourceFunction = Preconditions.checkNotNull(requestResourceFunction);
@@ -79,8 +75,8 @@ public class TestingResourceManagerDriver implements ResourceManagerDriver<Resou
     }
 
     @Override
-    public CompletableFuture<Void> terminate() {
-        return terminateSupplier.get();
+    public void terminate() {
+        // noop
     }
 
     @Override
@@ -109,9 +105,6 @@ public class TestingResourceManagerDriver implements ResourceManagerDriver<Resou
                         Exception>
                 initializeFunction = (ignore1, ignore2, ignore3) -> null;
 
-        private Supplier<CompletableFuture<Void>> terminateSupplier =
-                () -> CompletableFuture.completedFuture(null);
-
         private BiConsumerWithException<ApplicationStatus, String, Exception>
                 deregisterApplicationConsumer = (ignore1, ignore2) -> {};
 
@@ -133,11 +126,6 @@ public class TestingResourceManagerDriver implements ResourceManagerDriver<Resou
             return this;
         }
 
-        public Builder setTerminateSupplier(Supplier<CompletableFuture<Void>> terminateSupplier) {
-            this.terminateSupplier = Preconditions.checkNotNull(terminateSupplier);
-            return this;
-        }
-
         public Builder setDeregisterApplicationConsumer(
                 BiConsumerWithException<ApplicationStatus, String, Exception>
                         deregisterApplicationConsumer) {
@@ -161,7 +149,6 @@ public class TestingResourceManagerDriver implements ResourceManagerDriver<Resou
         public TestingResourceManagerDriver build() {
             return new TestingResourceManagerDriver(
                     initializeFunction,
-                    terminateSupplier,
                     deregisterApplicationConsumer,
                     requestResourceFunction,
                     releaseResourceConsumer);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/utils/MockResourceManagerRuntimeServices.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/utils/MockResourceManagerRuntimeServices.java
index fd8920be3b5..18cb6c7727f 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/utils/MockResourceManagerRuntimeServices.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/utils/MockResourceManagerRuntimeServices.java
@@ -31,9 +31,6 @@ import org.apache.flink.runtime.resourcemanager.slotmanager.SlotManagerBuilder;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
 
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
 /** Mock services needed by the resource manager. */
@@ -76,15 +73,4 @@ public class MockResourceManagerRuntimeServices {
                         rpcService.getScheduledExecutor(),
                         Time.minutes(5L));
     }
-
-    public void grantLeadership() throws Exception {
-        UUID rmLeaderSessionId = UUID.randomUUID();
-        rmLeaderElectionService
-                .isLeader(rmLeaderSessionId)
-                .get(timeout.toMilliseconds(), TimeUnit.MILLISECONDS);
-    }
-
-    public void revokeLeadership() {
-        rmLeaderElectionService.notLeader();
-    }
 }
diff --git a/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java b/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java
index 15cea4e031b..42a4c1763e8 100644
--- a/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java
+++ b/flink-yarn/src/main/java/org/apache/flink/yarn/YarnResourceManagerDriver.java
@@ -188,7 +188,7 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
     }
 
     @Override
-    public CompletableFuture<Void> terminate() {
+    public void terminate() throws Exception {
         // shut down all components
         Exception exception = null;
 
@@ -208,9 +208,9 @@ public class YarnResourceManagerDriver extends AbstractResourceManagerDriver<Yar
             }
         }
 
-        return exception == null
-                ? FutureUtils.completedVoidFuture()
-                : FutureUtils.completedExceptionally(exception);
+        if (exception != null) {
+            throw exception;
+        }
     }
 
     @Override
