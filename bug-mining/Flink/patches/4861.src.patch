diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java
index 46839b30b10..c04ea618fc0 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/SourceOperator.java
@@ -139,9 +139,27 @@ public class SourceOperator<OUT, SplitT extends SourceSplit>
 		this.emitProgressiveWatermarks = emitProgressiveWatermarks;
 	}
 
-	@Override
-	public void open() throws Exception {
+	/**
+	 * Initializes the reader. The code from this method should ideally happen in the
+	 * constructor or in the operator factory even. It has to happen here at a slightly
+	 * later stage, because of the lazy metric initialization.
+	 *
+	 * <p>Calling this method explicitly is an optional way to have the reader
+	 * initialization a bit earlier than in open(), as needed by the
+	 * {@link org.apache.flink.streaming.runtime.tasks.SourceOperatorStreamTask}
+	 *
+	 * <p>This code should move to the constructor once the metric groups are available
+	 * at task setup time.
+	 */
+	public void initReader() throws Exception {
+		if (sourceReader != null) {
+			return;
+		}
+
 		final MetricGroup metricGroup = getMetricGroup();
+		assert metricGroup != null;
+
+		final int subtaskIndex = getRuntimeContext().getIndexOfThisSubtask();
 
 		final SourceReaderContext context = new SourceReaderContext() {
 			@Override
@@ -161,7 +179,7 @@ public class SourceOperator<OUT, SplitT extends SourceSplit>
 
 			@Override
 			public int getIndexOfSubtask() {
-				return getRuntimeContext().getIndexOfThisSubtask();
+				return subtaskIndex;
 			}
 
 			@Override
@@ -175,22 +193,27 @@ public class SourceOperator<OUT, SplitT extends SourceSplit>
 			}
 		};
 
+		sourceReader = readerFactory.apply(context);
+	}
+
+	@Override
+	public void open() throws Exception {
+		initReader();
+
 		// in the future when we this one is migrated to the "eager initialization" operator
 		// (StreamOperatorV2), then we should evaluate this during operator construction.
 		if (emitProgressiveWatermarks) {
 			eventTimeLogic = TimestampsAndWatermarks.createProgressiveEventTimeLogic(
 					watermarkStrategy,
-					metricGroup,
+					getMetricGroup(),
 					getProcessingTimeService(),
 					getExecutionConfig().getAutoWatermarkInterval());
 		} else {
 			eventTimeLogic = TimestampsAndWatermarks.createNoOpEventTimeLogic(
 					watermarkStrategy,
-					metricGroup);
+					getMetricGroup());
 		}
 
-		sourceReader = readerFactory.apply(context);
-
 		// restore the state if necessary.
 		final List<SplitT> splits = CollectionUtil.iterableToList(readerState.get());
 		if (!splits.isEmpty()) {
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
index 4dce5833cc2..6d9f679d72c 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
@@ -49,8 +49,15 @@ public class SourceOperatorStreamTask<T> extends StreamTask<T, SourceOperator<T,
 	}
 
 	@Override
-	public void init() {
-		final StreamTaskInput<T> input = new StreamTaskSourceInput<>(mainOperator, 0, 0);
+	public void init() throws Exception {
+		final SourceOperator<T, ?> sourceOperator = this.mainOperator;
+		// reader initialization, which cannot happen in the constructor due to the
+		// lazy metric group initialization. We do this here now, rather than
+		// later (in open()) so that we can access the reader when setting up the
+		// input processors
+		sourceOperator.initReader();
+
+		final StreamTaskInput<T> input = new StreamTaskSourceInput<>(sourceOperator, 0, 0);
 
 		// The SourceOperatorStreamTask doesn't have any inputs, so there is no need for
 		// a WatermarkGauge on the input.
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/SourceOperatorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/SourceOperatorTest.java
index 78348d8667a..9570494523a 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/SourceOperatorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/SourceOperatorTest.java
@@ -91,9 +91,7 @@ public class SourceOperatorTest {
 	@After
 	public void cleanUp() throws Exception {
 		operator.close();
-		if (((TestingSourceOperator<Integer>) operator).isReaderCreated()) {
-			assertTrue(mockSourceReader.isClosed());
-		}
+		assertTrue(mockSourceReader.isClosed());
 	}
 
 	@Test
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/source/TestingSourceOperator.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/source/TestingSourceOperator.java
index 46b1382be8e..f82128f7437 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/source/TestingSourceOperator.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/source/TestingSourceOperator.java
@@ -43,8 +43,6 @@ public class TestingSourceOperator<T>  extends SourceOperator<T, MockSourceSplit
 	private final int subtaskIndex;
 	private final int parallelism;
 
-	private volatile boolean readerCreated;
-
 	public TestingSourceOperator(
 			SourceReader<T, MockSourceSplit> reader,
 			WatermarkStrategy<T> watermarkStrategy,
@@ -85,13 +83,13 @@ public class TestingSourceOperator<T>  extends SourceOperator<T, MockSourceSplit
 		this.subtaskIndex = subtaskIndex;
 		this.parallelism = parallelism;
 		this.metrics = UnregisteredMetricGroups.createUnregisteredOperatorMetricGroup();
-		this.readerCreated = false;
-	}
 
-	@Override
-	public void open() throws Exception {
-		super.open();
-		readerCreated = true;
+		// unchecked wrapping is okay to keep tests simpler
+		try {
+			initReader();
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
 	}
 
 	@Override
@@ -106,8 +104,4 @@ public class TestingSourceOperator<T>  extends SourceOperator<T, MockSourceSplit
 		cfg.setAutoWatermarkInterval(100);
 		return cfg;
 	}
-
-	public boolean isReaderCreated() {
-		return readerCreated;
-	}
 }
