diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java
index fe10d245733..12a5fdbd772 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManager.java
@@ -49,7 +49,6 @@ import javax.annotation.Nullable;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Optional;
@@ -77,7 +76,7 @@ public class DeclarativeSlotManager implements SlotManager {
     private final SlotManagerMetricGroup slotManagerMetricGroup;
 
     private final Map<JobID, String> jobMasterTargetAddresses = new HashMap<>();
-    private final Set<SlotID> pendingSlotAllocations;
+    private final Map<SlotID, AllocationID> pendingSlotAllocations;
 
     private boolean sendNotEnoughResourceNotifications = true;
 
@@ -105,7 +104,7 @@ public class DeclarativeSlotManager implements SlotManager {
         this.slotManagerMetricGroup = Preconditions.checkNotNull(slotManagerMetricGroup);
         this.resourceTracker = Preconditions.checkNotNull(resourceTracker);
 
-        pendingSlotAllocations = new HashSet<>(16);
+        pendingSlotAllocations = new HashMap<>(16);
 
         this.slotTracker = Preconditions.checkNotNull(slotTracker);
         slotTracker.registerSlotStatusUpdateListener(createSlotStatusUpdateListener());
@@ -536,16 +535,18 @@ public class DeclarativeSlotManager implements SlotManager {
                 taskManagerSlot.getTaskManagerConnection();
         final TaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();
 
+        final AllocationID allocationId = new AllocationID();
+
         slotTracker.notifyAllocationStart(slotId, jobId);
         taskExecutorManager.markUsed(instanceId);
-        pendingSlotAllocations.add(slotId);
+        pendingSlotAllocations.put(slotId, allocationId);
 
         // RPC call to the task manager
         CompletableFuture<Acknowledge> requestFuture =
                 gateway.requestSlot(
                         slotId,
                         jobId,
-                        new AllocationID(),
+                        allocationId,
                         resourceProfile,
                         targetAddress,
                         resourceManagerId,
@@ -554,7 +555,10 @@ public class DeclarativeSlotManager implements SlotManager {
         CompletableFuture<Void> slotAllocationResponseProcessingFuture =
                 requestFuture.handleAsync(
                         (Acknowledge acknowledge, Throwable throwable) -> {
-                            if (!pendingSlotAllocations.contains(slotId)) {
+                            final AllocationID currentAllocationForSlot =
+                                    pendingSlotAllocations.get(slotId);
+                            if (currentAllocationForSlot == null
+                                    || !currentAllocationForSlot.equals(allocationId)) {
                                 LOG.debug(
                                         "Ignoring slot allocation update from task executor {} for slot {} and job {}, because the allocation was already completed or cancelled.",
                                         instanceId,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java
index f8526c51161..191789f169e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DeclarativeSlotManagerTest.java
@@ -26,6 +26,7 @@ import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
 import org.apache.flink.runtime.clusterframework.types.SlotID;
+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;
 import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.concurrent.ManuallyTriggeredScheduledExecutor;
 import org.apache.flink.runtime.concurrent.ScheduledExecutor;
@@ -49,6 +50,8 @@ import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
 import org.apache.flink.util.function.FunctionUtils;
 
+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterators;
+
 import akka.pattern.AskTimeoutException;
 import org.junit.Test;
 
@@ -70,6 +73,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Supplier;
 
 import static org.hamcrest.CoreMatchers.hasItem;
+import static org.hamcrest.CoreMatchers.not;
 import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.equalTo;
@@ -1305,6 +1309,71 @@ public class DeclarativeSlotManagerTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testAllocationUpdatesIgnoredIfSlotMarkedAsPendingForOtherJob() throws Exception {
+        final DefaultSlotTracker slotTracker = new DefaultSlotTracker();
+
+        final CompletableFuture<AllocationID> firstSlotAllocationIdFuture =
+                new CompletableFuture<>();
+        final CompletableFuture<Acknowledge> firstSlotRequestAcknowledgeFuture =
+                new CompletableFuture<>();
+        final Iterator<CompletableFuture<Acknowledge>> slotRequestAcknowledgeFutures =
+                Arrays.asList(
+                                firstSlotRequestAcknowledgeFuture,
+                                new CompletableFuture<Acknowledge>())
+                        .iterator();
+
+        final TestingTaskExecutorGateway taskExecutorGateway =
+                new TestingTaskExecutorGatewayBuilder()
+                        .setRequestSlotFunction(
+                                requestSlotParameters -> {
+                                    firstSlotAllocationIdFuture.complete(requestSlotParameters.f2);
+                                    return slotRequestAcknowledgeFutures.next();
+                                })
+                        .createTestingTaskExecutorGateway();
+
+        try (final DeclarativeSlotManager slotManager =
+                createDeclarativeSlotManagerBuilder()
+                        .setSlotTracker(slotTracker)
+                        .buildAndStart(
+                                ResourceManagerId.generate(),
+                                ComponentMainThreadExecutorServiceAdapter.forMainThread(),
+                                new TestingResourceActionsBuilder().build())) {
+
+            final TaskExecutorConnection taskExecutionConnection =
+                    createTaskExecutorConnection(taskExecutorGateway);
+            final SlotReport slotReport =
+                    createSlotReport(taskExecutionConnection.getResourceID(), 1);
+            final SlotID slotId = Iterators.getOnlyElement(slotReport.iterator()).getSlotID();
+
+            // register task executor
+            slotManager.registerTaskManager(
+                    taskExecutionConnection, slotReport, ResourceProfile.ANY, ResourceProfile.ANY);
+            slotManager.reportSlotStatus(
+                    taskExecutionConnection.getInstanceID(),
+                    createSlotReport(taskExecutionConnection.getResourceID(), 1));
+
+            // triggers the allocation of a slot
+            final JobID firstJobId = new JobID();
+            slotManager.processResourceRequirements(createResourceRequirements(firstJobId, 1));
+            // clear requirements immediately to ensure the slot will not get re-allocated to the
+            // same job
+            slotManager.processResourceRequirements(
+                    ResourceRequirements.empty(firstJobId, "foobar"));
+            // when the slot is freed it will be re-assigned to this second job
+            slotManager.processResourceRequirements(createResourceRequirements(new JobID(), 1));
+
+            slotManager.freeSlot(slotId, firstSlotAllocationIdFuture.get());
+
+            // acknowledge the first allocation
+            // this should fail if the acknowledgement is not ignored
+            firstSlotRequestAcknowledgeFuture.complete(Acknowledge.get());
+
+            // sanity check that the acknowledge was really ignored
+            assertThat(slotTracker.getSlot(slotId).getJobId(), is(not(firstJobId)));
+        }
+    }
+
     private static SlotReport createSlotReport(ResourceID taskExecutorResourceId, int numberSlots) {
         final Set<SlotStatus> slotStatusSet = new HashSet<>(numberSlots);
         for (int i = 0; i < numberSlots; i++) {
