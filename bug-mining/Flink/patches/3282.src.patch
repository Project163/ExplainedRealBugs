diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SystemProcessingTimeServiceTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SystemProcessingTimeServiceTest.java
index a01a9c8fc82..493dbf3636f 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SystemProcessingTimeServiceTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SystemProcessingTimeServiceTest.java
@@ -26,6 +26,7 @@ import org.junit.Assert;
 import org.junit.Test;
 
 import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -34,10 +35,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 
-import static org.hamcrest.Matchers.anyOf;
 import static org.hamcrest.Matchers.instanceOf;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.nullValue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -140,40 +138,26 @@ public class SystemProcessingTimeServiceTest extends TestLogger {
 
 	@Test
 	public void testImmediateShutdown() throws Exception {
+		final CompletableFuture<Throwable> errorFuture = new CompletableFuture<>();
 
-		final Object lock = new Object();
-		final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-
-		final SystemProcessingTimeService timer = createSystemProcessingTimeService(errorRef);
+		final SystemProcessingTimeService timer = createSystemProcessingTimeService(errorFuture);
 
 		try {
 			assertFalse(timer.isTerminated());
 
 			final OneShotLatch latch = new OneShotLatch();
 
-			// the task should trigger immediately and should block until terminated with interruption
+			// the task should trigger immediately and sleep until terminated with interruption
 			timer.registerTimer(System.currentTimeMillis(), timestamp -> {
-				synchronized (lock) {
-					latch.trigger();
-					Thread.sleep(100000000);
-				}
+				latch.trigger();
+				Thread.sleep(100000000);
 			});
 
 			latch.await();
 			timer.shutdownService();
-			synchronized (lock) {
-				assertTrue(timer.isTerminated());
-
-				// The shutdownService() may not necessary wait for active tasks to finish properly.
-				// From the ScheduledThreadPoolExecutor Java docs:
-				// 	There are no guarantees beyond best-effort attempts to stop processing actively executing tasks.
-				// 	This implementation cancels tasks via {@link Thread#interrupt}, so any task that
-				// 	fails to respond to interrupts may never terminate.
-				assertThat(errorRef.get(), is(anyOf(nullValue(), instanceOf(InterruptedException.class))));
-				assertEquals(0, timer.getNumTasksScheduled());
-			}
 
-			errorRef.set(null);
+			assertTrue(timer.isTerminated());
+			assertEquals(0, timer.getNumTasksScheduled());
 
 			try {
 				timer.registerTimer(System.currentTimeMillis() + 1000, timestamp -> fail("should not be called"));
@@ -183,7 +167,6 @@ public class SystemProcessingTimeServiceTest extends TestLogger {
 			catch (IllegalStateException e) {
 				// expected
 			}
-			assertThat(errorRef.get(), is(nullValue()));
 
 			try {
 				timer.scheduleAtFixedRate(timestamp -> fail("should not be called"), 0L, 100L);
@@ -193,7 +176,9 @@ public class SystemProcessingTimeServiceTest extends TestLogger {
 			catch (IllegalStateException e) {
 				// expected
 			}
-			assertThat(errorRef.get(), is(nullValue()));
+
+			// check that the task eventually responded to interruption
+			assertThat(errorFuture.get(30L, TimeUnit.SECONDS), instanceOf(InterruptedException.class));
 		}
 		finally {
 			timer.shutdownService();
@@ -375,6 +360,12 @@ public class SystemProcessingTimeServiceTest extends TestLogger {
 		Assert.assertTrue(timerFinished.get());
 	}
 
+	private static SystemProcessingTimeService createSystemProcessingTimeService(CompletableFuture<Throwable> errorFuture) {
+		Preconditions.checkArgument(!errorFuture.isDone());
+
+		return new SystemProcessingTimeService(new TestOnTimerCompletablyCallbackContext(errorFuture));
+	}
+
 	private static SystemProcessingTimeService createSystemProcessingTimeService(AtomicReference<Throwable> errorRef) {
 
 		Preconditions.checkArgument(errorRef.get() == null);
@@ -439,4 +430,21 @@ public class SystemProcessingTimeServiceTest extends TestLogger {
 			}
 		}
 	}
+
+	private static class TestOnTimerCompletablyCallbackContext implements SystemProcessingTimeService.ScheduledCallbackExecutionContext {
+		private final CompletableFuture<Throwable> completableExceptionHandler;
+
+		TestOnTimerCompletablyCallbackContext(CompletableFuture<Throwable> completableExceptionHandler) {
+			this.completableExceptionHandler = completableExceptionHandler;
+		}
+
+		@Override
+		public void invoke(ProcessingTimeCallback callback, long timestamp) {
+			try {
+				callback.onProcessingTime(timestamp);
+			} catch (Throwable t) {
+				completableExceptionHandler.complete(t);
+			}
+		}
+	}
 }
