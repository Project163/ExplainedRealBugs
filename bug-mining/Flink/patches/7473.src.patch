diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulator.java
index 0bcebe4345f..2f5c469e33a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulator.java
@@ -32,6 +32,7 @@ import org.apache.flink.util.concurrent.ExecutorThreadFactory;
 import org.apache.flink.util.function.TriConsumer;
 
 import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -72,6 +73,7 @@ public class SortBufferAccumulator implements BufferAccumulator {
     private final int bufferSizeBytes;
 
     /** The empty buffers without storing data. */
+    @GuardedBy("lock")
     private final LinkedList<MemorySegment> freeSegments = new LinkedList<>();
 
     /** The memory manager of the tiered storage. */
@@ -85,7 +87,9 @@ public class SortBufferAccumulator implements BufferAccumulator {
      * data integrity. Note that this can be null before using it to store records, and this {@link
      * DataBuffer} will be released once flushed.
      */
-    @Nullable private TieredStorageSortBuffer currentDataBuffer;
+    @GuardedBy("lock")
+    @Nullable
+    private TieredStorageSortBuffer currentDataBuffer;
 
     /**
      * The buffer recycler. Note that this can be null before requesting buffers from the memory
@@ -116,6 +120,11 @@ public class SortBufferAccumulator implements BufferAccumulator {
     /** Whether the current {@link DataBuffer} is a broadcast sort buffer. */
     private boolean isBroadcastDataBuffer;
 
+    @GuardedBy("lock")
+    private boolean isDataBufferReleased;
+
+    private final Object lock = new Object();
+
     public SortBufferAccumulator(
             int numSubpartitions,
             int numExpectedBuffers,
@@ -154,28 +163,31 @@ public class SortBufferAccumulator implements BufferAccumulator {
     }
 
     @Override
-    public synchronized void receive(
+    public void receive(
             ByteBuffer record,
             TieredStorageSubpartitionId subpartitionId,
             Buffer.DataType dataType,
             boolean isBroadcast)
             throws IOException {
         int targetSubpartition = subpartitionId.getSubpartitionId();
-        switchCurrentDataBufferIfNeeded(isBroadcast);
-        if (!checkNotNull(currentDataBuffer).append(record, targetSubpartition, dataType)) {
-            return;
-        }
+        synchronized (lock) {
+            switchCurrentDataBufferIfNeeded(isBroadcast);
+            if (!checkNotNull(currentDataBuffer).append(record, targetSubpartition, dataType)) {
+                return;
+            }
 
-        // The sort buffer is empty, but we failed to write the record into it, which indicates the
-        // record is larger than the sort buffer can hold. So the record is written into multiple
-        // buffers directly.
-        if (!currentDataBuffer.hasRemaining()) {
-            currentDataBuffer.release();
-            writeLargeRecord(record, targetSubpartition, dataType);
-            return;
+            // The sort buffer is empty, but we failed to write the record into it, which indicates
+            // the record is larger than the sort buffer can hold. So the record is written into
+            // multiple buffers directly.
+            if (!currentDataBuffer.hasRemaining()) {
+                isDataBufferReleased = true;
+                currentDataBuffer.release();
+                writeLargeRecord(record, targetSubpartition, dataType);
+                return;
+            }
+            flushDataBuffer();
         }
 
-        flushDataBuffer();
         checkState(record.hasRemaining(), "Empty record.");
         receive(record, subpartitionId, dataType, isBroadcast);
     }
@@ -193,18 +205,21 @@ public class SortBufferAccumulator implements BufferAccumulator {
                 ExceptionUtils.rethrow(e);
             }
         }
-        flushCurrentDataBuffer();
-        releaseFreeBuffers();
-        if (currentDataBuffer != null) {
-            currentDataBuffer.release();
+        synchronized (lock) {
+            flushCurrentDataBuffer();
+            isDataBufferReleased = true;
+            releaseFreeBuffers();
+            if (currentDataBuffer != null) {
+                currentDataBuffer.release();
+            }
         }
     }
 
     // ------------------------------------------------------------------------
     //  Internal Methods
     // ------------------------------------------------------------------------
-
-    private synchronized void switchCurrentDataBufferIfNeeded(boolean isBroadcast) {
+    @GuardedBy("lock")
+    private void switchCurrentDataBufferIfNeeded(boolean isBroadcast) {
         if (isBroadcast == isBroadcastDataBuffer
                 && currentDataBuffer != null
                 && !currentDataBuffer.isReleased()
@@ -213,9 +228,12 @@ public class SortBufferAccumulator implements BufferAccumulator {
         }
         isBroadcastDataBuffer = isBroadcast;
         flushCurrentDataBuffer();
+        isDataBufferReleased = true;
         currentDataBuffer = createNewDataBuffer();
+        isDataBufferReleased = false;
     }
 
+    @GuardedBy("lock")
     private TieredStorageSortBuffer createNewDataBuffer() {
         requestBuffers();
 
@@ -230,6 +248,7 @@ public class SortBufferAccumulator implements BufferAccumulator {
                 isPartialRecordAllowed);
     }
 
+    @GuardedBy("lock")
     private void requestBuffers() {
         while (freeSegments.size()
                 < Math.min(numExpectedBuffers, memoryManager.getBufferPoolSize() - 1)) {
@@ -241,7 +260,8 @@ public class SortBufferAccumulator implements BufferAccumulator {
         }
     }
 
-    private synchronized void flushDataBuffer() {
+    @GuardedBy("lock")
+    private void flushDataBuffer() {
         if (currentDataBuffer == null
                 || currentDataBuffer.isReleased()
                 || !currentDataBuffer.hasRemaining()) {
@@ -264,24 +284,29 @@ public class SortBufferAccumulator implements BufferAccumulator {
             flushBuffer(bufferWithSubpartition, numRemainingConsecutiveBuffers);
         }
 
+        isDataBufferReleased = true;
         releaseFreeBuffers();
         currentDataBuffer.release();
     }
 
-    private synchronized void flushCurrentDataBuffer() {
-        if (currentDataBuffer != null) {
-            flushDataBuffer();
-            currentDataBuffer = null;
+    private void flushCurrentDataBuffer() {
+        synchronized (lock) {
+            if (currentDataBuffer != null) {
+                flushDataBuffer();
+                currentDataBuffer = null;
+            }
         }
     }
 
-    private synchronized boolean returnFreeSegments(int numSegments) {
-        if (currentDataBuffer == null
-                || currentDataBuffer.isReleased()
-                || !currentDataBuffer.hasRemaining()) {
-            return false;
-        } else {
-            return currentDataBuffer.returnFreeSegments(numSegments);
+    private boolean returnFreeSegments(int numSegments) {
+        synchronized (lock) {
+            if (currentDataBuffer == null
+                    || currentDataBuffer.isReleased()
+                    || !currentDataBuffer.hasRemaining()) {
+                return false;
+            } else {
+                return currentDataBuffer.returnFreeSegments(numSegments);
+            }
         }
     }
 
@@ -311,11 +336,13 @@ public class SortBufferAccumulator implements BufferAccumulator {
     }
 
     private MemorySegment getFreeSegment() {
-        MemorySegment freeSegment = freeSegments.poll();
-        if (freeSegment == null) {
-            freeSegment = requestBuffer().getMemorySegment();
+        synchronized (lock) {
+            MemorySegment freeSegment = freeSegments.poll();
+            if (freeSegment == null) {
+                freeSegment = requestBuffer().getMemorySegment();
+            }
+            return freeSegment;
         }
-        return freeSegment;
     }
 
     private void flushBuffer(
@@ -338,11 +365,22 @@ public class SortBufferAccumulator implements BufferAccumulator {
     }
 
     private void releaseFreeBuffers() {
-        freeSegments.forEach(this::recycleBuffer);
-        freeSegments.clear();
+        synchronized (lock) {
+            isDataBufferReleased = true;
+            freeSegments.forEach(this::recycleBuffer);
+            freeSegments.clear();
+        }
     }
 
     private void recycleBuffer(MemorySegment memorySegment) {
-        checkNotNull(bufferRecycler).recycle(memorySegment);
+        synchronized (lock) {
+            if (!isDataBufferReleased
+                    && currentDataBuffer != null
+                    && !currentDataBuffer.isReleased()) {
+                freeSegments.add(memorySegment);
+            } else {
+                checkNotNull(bufferRecycler).recycle(memorySegment);
+            }
+        }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/TestingTieredStorageMemoryManager.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/TestingTieredStorageMemoryManager.java
index da5e64451da..761d731579b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/TestingTieredStorageMemoryManager.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/TestingTieredStorageMemoryManager.java
@@ -199,6 +199,12 @@ public class TestingTieredStorageMemoryManager implements TieredStorageMemoryMan
             return this;
         }
 
+        public TestingTieredStorageMemoryManager.Builder setGetBufferPoolSizeSupplier(
+                Supplier<Integer> getBufferPoolSizeSupplier) {
+            this.getBufferPoolSizeSupplier = getBufferPoolSizeSupplier;
+            return this;
+        }
+
         public TestingTieredStorageMemoryManager.Builder setReleaseRunnable(
                 Runnable releaseRunnable) {
             this.releaseRunnable = releaseRunnable;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulatorTest.java
index 9bd53265f0b..62ebaeb5f98 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/hybrid/tiered/storage/SortBufferAccumulatorTest.java
@@ -18,9 +18,12 @@
 
 package org.apache.flink.runtime.io.network.partition.hybrid.tiered.storage;
 
+import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;
 import org.apache.flink.runtime.io.network.buffer.BufferPool;
 import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;
+import org.apache.flink.runtime.io.network.partition.hybrid.tiered.TestingTieredStorageMemoryManager;
 import org.apache.flink.runtime.io.network.partition.hybrid.tiered.common.TieredStorageSubpartitionId;
 
 import org.junit.jupiter.api.AfterEach;
@@ -202,6 +205,48 @@ class SortBufferAccumulatorTest {
         assertThat(tieredStorageMemoryManager.numOwnerRequestedBuffer(bufferAccumulator)).isZero();
     }
 
+    @Test
+    void testReuseRecycledBuffersWhenFlushDataBuffer() throws IOException {
+        int numBuffers = 10;
+        int numSubpartitions = 10;
+
+        AtomicInteger numRequestedBuffers = new AtomicInteger(0);
+        TestingTieredStorageMemoryManager memoryManager =
+                new TestingTieredStorageMemoryManager.Builder()
+                        .setRequestBufferBlockingFunction(
+                                owner -> {
+                                    numRequestedBuffers.incrementAndGet();
+                                    MemorySegment memorySegment =
+                                            globalPool.requestPooledMemorySegment();
+                                    // When flushing data from the data buffer, the buffers should
+                                    // not be requested from here anymore because the freeSegments
+                                    // can be reused before released.
+                                    assertThat(numRequestedBuffers.get() < numBuffers).isTrue();
+                                    return new BufferBuilder(
+                                            memorySegment,
+                                            segment -> globalPool.requestPooledMemorySegment());
+                                })
+                        .setGetBufferPoolSizeSupplier(() -> numBuffers)
+                        .build();
+
+        SortBufferAccumulator bufferAccumulator =
+                new SortBufferAccumulator(
+                        numSubpartitions, numBuffers, BUFFER_SIZE_BYTES, 0L, memoryManager, true);
+        bufferAccumulator.setup(
+                ((subpartition, buffer, numRemainingBuffers) -> buffer.recycleBuffer()));
+
+        for (int i = 0; i < numSubpartitions; i++) {
+            bufferAccumulator.receive(
+                    generateRandomData(10, new Random()),
+                    new TieredStorageSubpartitionId(i % numSubpartitions),
+                    Buffer.DataType.DATA_BUFFER,
+                    false);
+        }
+
+        // Trigger flushing buffers from data buffer.
+        bufferAccumulator.close();
+    }
+
     private TieredStorageMemoryManagerImpl createStorageMemoryManager(int numBuffersInBufferPool)
             throws IOException {
         BufferPool bufferPool =
