diff --git a/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java
new file mode 100644
index 00000000000..ef1fdf0567c
--- /dev/null
+++ b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/CombinedWatermarkStatus.java
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.api.common.eventtime;
+
+import org.apache.flink.annotation.Internal;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.apache.flink.util.Preconditions.checkState;
+
+/**
+ * A {@link CombinedWatermarkStatus} combines the watermark (and idleness) updates of multiple
+ * partitions/shards/splits into one combined watermark.
+ */
+@Internal
+final class CombinedWatermarkStatus {
+
+    /** List of all watermark outputs, for efficient access. */
+    private final List<PartialWatermark> partialWatermarks = new ArrayList<>();
+
+    /** The combined watermark over the per-output watermarks. */
+    private long combinedWatermark = Long.MIN_VALUE;
+
+    private boolean idle = false;
+
+    public long getCombinedWatermark() {
+        return combinedWatermark;
+    }
+
+    public boolean isIdle() {
+        return idle;
+    }
+
+    public boolean remove(PartialWatermark o) {
+        return partialWatermarks.remove(o);
+    }
+
+    public void add(PartialWatermark element) {
+        partialWatermarks.add(element);
+    }
+
+    /**
+     * Checks whether we need to update the combined watermark.
+     *
+     * <p><b>NOTE:</b>It can update {@link #isIdle()} status.
+     *
+     * @return true, if the combined watermark changed
+     */
+    public boolean updateCombinedWatermark() {
+        long minimumOverAllOutputs = Long.MAX_VALUE;
+
+        boolean hasOutputs = false;
+        boolean allIdle = true;
+        for (PartialWatermark partialWatermark : partialWatermarks) {
+            if (!partialWatermark.isIdle()) {
+                minimumOverAllOutputs =
+                        Math.min(minimumOverAllOutputs, partialWatermark.getWatermark());
+                allIdle = false;
+            }
+            hasOutputs = true;
+        }
+
+        // if we don't have any outputs minimumOverAllOutputs is not valid, it's still
+        // at its initial Long.MAX_VALUE state and we must not emit that
+        this.idle = allIdle;
+        if (!hasOutputs || allIdle) {
+            return false;
+        }
+
+        if (minimumOverAllOutputs > combinedWatermark) {
+            combinedWatermark = minimumOverAllOutputs;
+            return true;
+        }
+
+        return false;
+    }
+
+    /** Per-output watermark state. */
+    static class PartialWatermark {
+        private long watermark = Long.MIN_VALUE;
+        private boolean idle = false;
+
+        /**
+         * Returns the current watermark timestamp. This will throw {@link IllegalStateException} if
+         * the output is currently idle.
+         */
+        private long getWatermark() {
+            checkState(!idle, "Output is idle.");
+            return watermark;
+        }
+
+        /**
+         * Returns true if the watermark was advanced, that is if the new watermark is larger than
+         * the previous one.
+         *
+         * <p>Setting a watermark will clear the idleness flag.
+         */
+        public boolean setWatermark(long watermark) {
+            this.idle = false;
+            final boolean updated = watermark > this.watermark;
+            this.watermark = Math.max(watermark, this.watermark);
+            return updated;
+        }
+
+        private boolean isIdle() {
+            return idle;
+        }
+
+        public void setIdle(boolean idle) {
+            this.idle = idle;
+        }
+    }
+}
diff --git a/flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java
index e13e57aa8ed..102169b49e1 100644
--- a/flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java
+++ b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/WatermarkOutputMultiplexer.java
@@ -19,11 +19,10 @@
 package org.apache.flink.api.common.eventtime;
 
 import org.apache.flink.annotation.Internal;
+import org.apache.flink.api.common.eventtime.CombinedWatermarkStatus.PartialWatermark;
 import org.apache.flink.util.Preconditions;
 
-import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 import static org.apache.flink.util.Preconditions.checkState;
@@ -57,16 +56,12 @@ public class WatermarkOutputMultiplexer {
      */
     private final WatermarkOutput underlyingOutput;
 
-    /** The combined watermark over the per-output watermarks. */
-    private long combinedWatermark = Long.MIN_VALUE;
-
     /**
      * Map view, to allow finding them when requesting the {@link WatermarkOutput} for a given id.
      */
-    private final Map<String, OutputState> watermarkPerOutputId;
+    private final Map<String, PartialWatermark> watermarkPerOutputId;
 
-    /** List of all watermark outputs, for efficient access. */
-    private final List<OutputState> watermarkOutputs;
+    private final CombinedWatermarkStatus combinedWatermarkStatus;
 
     /**
      * Creates a new {@link WatermarkOutputMultiplexer} that emits combined updates to the given
@@ -75,7 +70,7 @@ public class WatermarkOutputMultiplexer {
     public WatermarkOutputMultiplexer(WatermarkOutput underlyingOutput) {
         this.underlyingOutput = underlyingOutput;
         this.watermarkPerOutputId = new HashMap<>();
-        this.watermarkOutputs = new ArrayList<>();
+        this.combinedWatermarkStatus = new CombinedWatermarkStatus();
     }
 
     /**
@@ -84,18 +79,19 @@ public class WatermarkOutputMultiplexer {
      * output.
      */
     public void registerNewOutput(String id) {
-        final OutputState outputState = new OutputState();
+        final PartialWatermark outputState = new PartialWatermark();
 
-        final OutputState previouslyRegistered = watermarkPerOutputId.putIfAbsent(id, outputState);
+        final PartialWatermark previouslyRegistered =
+                watermarkPerOutputId.putIfAbsent(id, outputState);
         checkState(previouslyRegistered == null, "Already contains an output for ID %s", id);
 
-        watermarkOutputs.add(outputState);
+        combinedWatermarkStatus.add(outputState);
     }
 
     public boolean unregisterOutput(String id) {
-        final OutputState output = watermarkPerOutputId.remove(id);
+        final PartialWatermark output = watermarkPerOutputId.remove(id);
         if (output != null) {
-            watermarkOutputs.remove(output);
+            combinedWatermarkStatus.remove(output);
             return true;
         } else {
             return false;
@@ -109,7 +105,7 @@ public class WatermarkOutputMultiplexer {
      * outputs.
      */
     public WatermarkOutput getImmediateOutput(String outputId) {
-        final OutputState outputState = watermarkPerOutputId.get(outputId);
+        final PartialWatermark outputState = watermarkPerOutputId.get(outputId);
         Preconditions.checkArgument(
                 outputState != null, "no output registered under id %s", outputId);
         return new ImmediateOutput(outputState);
@@ -122,7 +118,7 @@ public class WatermarkOutputMultiplexer {
      * outputs.
      */
     public WatermarkOutput getDeferredOutput(String outputId) {
-        final OutputState outputState = watermarkPerOutputId.get(outputId);
+        final PartialWatermark outputState = watermarkPerOutputId.get(outputId);
         Preconditions.checkArgument(
                 outputState != null, "no output registered under id %s", outputId);
         return new DeferredOutput(outputState);
@@ -142,65 +138,11 @@ public class WatermarkOutputMultiplexer {
      * deferred per-output updates.
      */
     private void updateCombinedWatermark() {
-        long minimumOverAllOutputs = Long.MAX_VALUE;
-
-        boolean hasOutputs = false;
-        boolean allIdle = true;
-        for (OutputState outputState : watermarkOutputs) {
-            if (!outputState.isIdle()) {
-                minimumOverAllOutputs = Math.min(minimumOverAllOutputs, outputState.getWatermark());
-                allIdle = false;
-            }
-            hasOutputs = true;
-        }
-
-        // if we don't have any outputs minimumOverAllOutputs is not valid, it's still
-        // at its initial Long.MAX_VALUE state and we must not emit that
-        if (!hasOutputs) {
-            return;
-        }
-
-        if (allIdle) {
+        if (combinedWatermarkStatus.updateCombinedWatermark()) {
+            underlyingOutput.emitWatermark(
+                    new Watermark(combinedWatermarkStatus.getCombinedWatermark()));
+        } else if (combinedWatermarkStatus.isIdle()) {
             underlyingOutput.markIdle();
-        } else if (minimumOverAllOutputs > combinedWatermark) {
-            combinedWatermark = minimumOverAllOutputs;
-            underlyingOutput.emitWatermark(new Watermark(minimumOverAllOutputs));
-        }
-    }
-
-    /** Per-output watermark state. */
-    private static class OutputState {
-        private long watermark = Long.MIN_VALUE;
-        private boolean idle = false;
-
-        /**
-         * Returns the current watermark timestamp. This will throw {@link IllegalStateException} if
-         * the output is currently idle.
-         */
-        public long getWatermark() {
-            checkState(!idle, "Output is idle.");
-            return watermark;
-        }
-
-        /**
-         * Returns true if the watermark was advanced, that is if the new watermark is larger than
-         * the previous one.
-         *
-         * <p>Setting a watermark will clear the idleness flag.
-         */
-        public boolean setWatermark(long watermark) {
-            this.idle = false;
-            final boolean updated = watermark > this.watermark;
-            this.watermark = Math.max(watermark, this.watermark);
-            return updated;
-        }
-
-        public boolean isIdle() {
-            return idle;
-        }
-
-        public void setIdle(boolean idle) {
-            this.idle = idle;
         }
     }
 
@@ -210,9 +152,9 @@ public class WatermarkOutputMultiplexer {
      */
     private class ImmediateOutput implements WatermarkOutput {
 
-        private final OutputState state;
+        private final PartialWatermark state;
 
-        public ImmediateOutput(OutputState state) {
+        public ImmediateOutput(PartialWatermark state) {
             this.state = state;
         }
 
@@ -223,7 +165,7 @@ public class WatermarkOutputMultiplexer {
 
             // if it's higher than the max watermark so far we might have to update the
             // combined watermark
-            if (wasUpdated && timestamp > combinedWatermark) {
+            if (wasUpdated && timestamp > combinedWatermarkStatus.getCombinedWatermark()) {
                 updateCombinedWatermark();
             }
         }
@@ -245,9 +187,9 @@ public class WatermarkOutputMultiplexer {
      */
     private static class DeferredOutput implements WatermarkOutput {
 
-        private final OutputState state;
+        private final PartialWatermark state;
 
-        public DeferredOutput(OutputState state) {
+        public DeferredOutput(PartialWatermark state) {
             this.state = state;
         }
 
