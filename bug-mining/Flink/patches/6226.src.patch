diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobDispatcherITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobDispatcherITCase.java
index 265892eb823..9be03d377b0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobDispatcherITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobDispatcherITCase.java
@@ -68,7 +68,6 @@ import java.util.function.Supplier;
 
 import static java.nio.file.StandardOpenOption.CREATE;
 import static org.apache.flink.runtime.entrypoint.component.FileJobGraphRetriever.JOB_GRAPH_FILE_PATH;
-import static org.junit.Assert.assertNotNull;
 
 /** An integration test which recovers from checkpoint after regaining the leadership. */
 @ExtendWith(TestLoggerExtension.class)
@@ -137,11 +136,14 @@ public class JobDispatcherITCase {
             // job is suspended, wait until it's running
             awaitJobStatus(cluster, jobID, JobStatus.RUNNING, deadline);
 
-            assertNotNull(
-                    cluster.getArchivedExecutionGraph(jobID)
-                            .get()
-                            .getCheckpointStatsSnapshot()
-                            .getLatestRestoredCheckpoint());
+            CommonTestUtils.waitUntilCondition(
+                    () ->
+                            cluster.getArchivedExecutionGraph(jobID)
+                                            .get()
+                                            .getCheckpointStatsSnapshot()
+                                            .getLatestRestoredCheckpoint()
+                                    != null,
+                    deadline);
         }
     }
 
@@ -213,5 +215,11 @@ public class JobDispatcherITCase {
             atLeastOneCheckpointCompleted.countDown();
             return CompletableFuture.completedFuture(null);
         }
+
+        @Override
+        public Future<Void> notifyCheckpointAbortAsync(
+                long checkpointId, long latestCompletedCheckpointId) {
+            return CompletableFuture.completedFuture(null);
+        }
     }
 }
