diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
index 5591107b8a9..506cb6da84f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointsCleaner.java
@@ -18,34 +18,40 @@
 
 package org.apache.flink.runtime.checkpoint;
 
+import org.apache.flink.util.AutoCloseableAsync;
 import org.apache.flink.util.function.RunnableWithException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 import javax.annotation.concurrent.ThreadSafe;
 
 import java.io.Serializable;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.apache.flink.util.Preconditions.checkState;
 
 /**
  * Delegate class responsible for checkpoints cleaning and counting the number of checkpoints yet to
  * clean.
  */
 @ThreadSafe
-public class CheckpointsCleaner implements Serializable {
+public class CheckpointsCleaner implements Serializable, AutoCloseableAsync {
     private static final Logger LOG = LoggerFactory.getLogger(CheckpointsCleaner.class);
     private static final long serialVersionUID = 2545865801947537790L;
 
-    private final AtomicInteger numberOfCheckpointsToClean;
+    @GuardedBy("this")
+    private int numberOfCheckpointsToClean;
 
-    public CheckpointsCleaner() {
-        this.numberOfCheckpointsToClean = new AtomicInteger(0);
-    }
+    @GuardedBy("this")
+    @Nullable
+    private CompletableFuture<Void> cleanUpFuture;
 
-    int getNumberOfCheckpointsToClean() {
-        return numberOfCheckpointsToClean.get();
+    synchronized int getNumberOfCheckpointsToClean() {
+        return numberOfCheckpointsToClean;
     }
 
     public void cleanCheckpoint(
@@ -78,7 +84,7 @@ public class CheckpointsCleaner implements Serializable {
             RunnableWithException cleanupAction,
             Runnable postCleanupAction,
             Executor executor) {
-        numberOfCheckpointsToClean.incrementAndGet();
+        incrementNumberOfCheckpointsToClean();
         executor.execute(
                 () -> {
                     try {
@@ -89,9 +95,34 @@ public class CheckpointsCleaner implements Serializable {
                                 checkpoint.getCheckpointID(),
                                 e);
                     } finally {
-                        numberOfCheckpointsToClean.decrementAndGet();
+                        decrementNumberOfCheckpointsToClean();
                         postCleanupAction.run();
                     }
                 });
     }
+
+    private synchronized void incrementNumberOfCheckpointsToClean() {
+        checkState(cleanUpFuture == null, "CheckpointsCleaner has already been closed");
+        numberOfCheckpointsToClean++;
+    }
+
+    private synchronized void decrementNumberOfCheckpointsToClean() {
+        numberOfCheckpointsToClean--;
+        maybeCompleteCloseUnsafe();
+    }
+
+    private void maybeCompleteCloseUnsafe() {
+        if (numberOfCheckpointsToClean == 0 && cleanUpFuture != null) {
+            cleanUpFuture.complete(null);
+        }
+    }
+
+    @Override
+    public synchronized CompletableFuture<Void> closeAsync() {
+        if (cleanUpFuture == null) {
+            cleanUpFuture = new CompletableFuture<>();
+        }
+        maybeCompleteCloseUnsafe();
+        return cleanUpFuture;
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
index 2e5eda65bab..ac9aca78ad2 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
@@ -598,9 +598,12 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
         final FlinkException cause = new FlinkException("Scheduler is being stopped.");
 
         final CompletableFuture<Void> checkpointServicesShutdownFuture =
-                executionGraph
-                        .getTerminationFuture()
-                        .thenAcceptAsync(this::shutDownCheckpointServices, getMainThreadExecutor());
+                CompletableFuture.allOf(
+                        executionGraph
+                                .getTerminationFuture()
+                                .thenAcceptAsync(
+                                        this::shutDownCheckpointServices, getMainThreadExecutor()),
+                        checkpointsCleaner.closeAsync());
         FutureUtils.assertNoException(checkpointServicesShutdownFuture);
 
         incrementVersionsOfAllVertices();
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java
index 83003fdd8e0..4d4b5fe40e1 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/adaptive/AdaptiveScheduler.java
@@ -420,10 +420,12 @@ public class AdaptiveScheduler
 
         backgroundTask.abort();
         // wait for the background task to finish and then close services
-        return FutureUtils.runAfterwardsAsync(
-                backgroundTask.getTerminationFuture(),
-                () -> stopCheckpointServicesSafely(jobTerminationFuture.get()),
-                getMainThreadExecutor());
+        return CompletableFuture.allOf(
+                FutureUtils.runAfterwardsAsync(
+                        backgroundTask.getTerminationFuture(),
+                        () -> stopCheckpointServicesSafely(jobTerminationFuture.get()),
+                        getMainThreadExecutor()),
+                checkpointsCleaner.closeAsync());
     }
 
     private void stopCheckpointServicesSafely(JobStatus terminalState) {
