diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java
index dd32efb38d7..364ba0f57e3 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStore.java
@@ -240,7 +240,7 @@ public class ZooKeeperStateHandleStore<T extends Serializable> {
 		try {
 			return InstantiationUtil.deserializeObject(data, Thread.currentThread().getContextClassLoader());
 		} catch (IOException | ClassNotFoundException e) {
-			throw new Exception("Failed to deserialize state handle from ZooKeeper data from " +
+			throw new IOException("Failed to deserialize state handle from ZooKeeper data from " +
 				pathInZooKeeper + '.', e);
 		}
 	}
@@ -285,6 +285,8 @@ public class ZooKeeperStateHandleStore<T extends Serializable> {
 
 		retry:
 		while (!success) {
+			stateHandles.clear();
+
 			Stat stat = client.checkExists().forPath("/");
 			if (stat == null) {
 				break; // Node does not exist, done.
@@ -303,6 +305,9 @@ public class ZooKeeperStateHandleStore<T extends Serializable> {
 					} catch (KeeperException.NoNodeException ignored) {
 						// Concurrent deletion, retry
 						continue retry;
+					} catch (IOException ioException) {
+						LOG.warn("Could not get all ZooKeeper children. Node {} contained " +
+							"corrupted data. Ignoring this node.", path, ioException);
 					}
 				}
 
@@ -333,6 +338,8 @@ public class ZooKeeperStateHandleStore<T extends Serializable> {
 
 		retry:
 		while (!success) {
+			stateHandles.clear();
+
 			Stat stat = client.checkExists().forPath("/");
 			if (stat == null) {
 				break; // Node does not exist, done.
@@ -353,6 +360,9 @@ public class ZooKeeperStateHandleStore<T extends Serializable> {
 					} catch (KeeperException.NoNodeException ignored) {
 						// Concurrent deletion, retry
 						continue retry;
+					} catch (IOException ioException) {
+						LOG.warn("Could not get all ZooKeeper children. Node {} contained " +
+							"corrupted data. Ignoring this node.", path, ioException);
 					}
 				}
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreITCase.java
index 5db3557efc7..4dc4c6bd8a3 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreITCase.java
@@ -35,6 +35,7 @@ import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -536,6 +537,56 @@ public class ZooKeeperStateHandleStoreITCase extends TestLogger {
 		assertEquals(0, ZooKeeper.getClient().getChildren().forPath("/").size());
 	}
 
+	/**
+	 * Tests that the ZooKeeperStateHandleStore can handle corrupted data by ignoring the respective
+	 * ZooKeeper ZNodes.
+	 */
+	@Test
+	public void testCorruptedData() throws Exception {
+		LongStateStorage stateStorage = new LongStateStorage();
+
+		ZooKeeperStateHandleStore<Long> store = new ZooKeeperStateHandleStore<>(
+			ZooKeeper.getClient(),
+			stateStorage,
+			Executors.directExecutor());
+
+		final Collection<Long> input = new HashSet<>();
+		input.add(1L);
+		input.add(2L);
+		input.add(3L);
+
+		for (Long aLong : input) {
+			store.add("/" + aLong, aLong);
+		}
+
+		// corrupt one of the entries
+		ZooKeeper.getClient().setData().forPath("/" + 2, new byte[2]);
+
+		List<Tuple2<RetrievableStateHandle<Long>, String>> allEntries = store.getAll();
+
+		Collection<Long> expected = new HashSet<>(input);
+		expected.remove(2L);
+
+		Collection<Long> actual = new HashSet<>(expected.size());
+
+		for (Tuple2<RetrievableStateHandle<Long>, String> entry : allEntries) {
+			actual.add(entry.f0.retrieveState());
+		}
+
+		assertEquals(expected, actual);
+
+		// check the same for the all sorted by name call
+		allEntries = store.getAllSortedByName();
+
+		actual.clear();
+
+		for (Tuple2<RetrievableStateHandle<Long>, String> entry : allEntries) {
+			actual.add(entry.f0.retrieveState());
+		}
+
+		assertEquals(expected, actual);
+	}
+
 	// ---------------------------------------------------------------------------------------------
 	// Simple test helpers
 	// ---------------------------------------------------------------------------------------------
