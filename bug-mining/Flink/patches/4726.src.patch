diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/ExtractionUtils.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/ExtractionUtils.java
index 2ed11ff386d..75d87853d84 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/ExtractionUtils.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/extraction/ExtractionUtils.java
@@ -102,22 +102,32 @@ public final class ExtractionUtils {
 		int currentClass = 0;
 		for (int currentParam = 0; currentParam < paramCount; currentParam++) {
 			final Class<?> param = executable.getParameterTypes()[currentParam];
-			// entire parameter matches
-			if (classes[currentClass] == null || ExtractionUtils.isAssignable(classes[currentClass], param, true)) {
-				currentClass++;
-			}
-			// last parameter is a vararg that consumes remaining classes
-			else if (currentParam == paramCount - 1 && executable.isVarArgs()) {
+			// last parameter is a vararg that needs to consume remaining classes
+			if (currentParam == paramCount - 1 && executable.isVarArgs()) {
 				final Class<?> paramComponent = executable.getParameterTypes()[currentParam].getComponentType();
-				while (currentClass < classCount && ExtractionUtils.isAssignable(classes[currentClass], paramComponent, true)) {
+				// we have more than 1 classes left so the vararg needs to consume them all
+				if (classCount - currentClass > 1) {
+					while (currentClass < classCount && ExtractionUtils.isAssignable(classes[currentClass], paramComponent, true)) {
+						currentClass++;
+					}
+				} else if (parameterMatches(classes[currentClass], param)
+						|| parameterMatches(classes[currentClass], paramComponent)) {
 					currentClass++;
 				}
 			}
+			// entire parameter matches
+			else if (parameterMatches(classes[currentClass], param)) {
+				currentClass++;
+			}
 		}
 		// check if all classes have been consumed
 		return currentClass == classCount;
 	}
 
+	private static boolean parameterMatches(Class<?> clz, Class<?> param) {
+		return clz == null || ExtractionUtils.isAssignable(clz, param, true);
+	}
+
 	/**
 	 * Creates a method signature string like {@code int eval(Integer, String)}.
 	 */
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java
index ca7bd70dd65..30f849a8c13 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/types/extraction/TypeInferenceExtractorTest.java
@@ -140,7 +140,9 @@ public class TypeInferenceExtractorTest {
 				.expectOutputMapping(
 					InputTypeStrategies.varyingSequence(
 						new String[]{"myInt", "myAny"},
-						new ArgumentTypeStrategy[]{InputTypeStrategies.explicit(DataTypes.INT()), InputTypeStrategies.ANY}),
+						new ArgumentTypeStrategy[]{
+							InputTypeStrategies.explicit(
+								DataTypes.ARRAY(DataTypes.INT())), InputTypeStrategies.ANY}),
 					TypeStrategies.explicit(DataTypes.BOOLEAN())),
 
 			// global input hints and local output hints
@@ -625,7 +627,7 @@ public class TypeInferenceExtractorTest {
 
 	private static class ComplexFunctionHint extends ScalarFunction {
 		@FunctionHint(
-			input = {@DataTypeHint("INT"), @DataTypeHint(inputGroup = InputGroup.ANY)},
+			input = {@DataTypeHint("ARRAY<INT>"), @DataTypeHint(inputGroup = InputGroup.ANY)},
 			argumentNames = {"myInt", "myAny"},
 			output = @DataTypeHint("BOOLEAN"),
 			isVarArgs = true
