diff --git a/flink-yarn/src/main/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourcePriorityAdapter.java b/flink-yarn/src/main/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourcePriorityAdapter.java
new file mode 100644
index 00000000000..0d02e1a9353
--- /dev/null
+++ b/flink-yarn/src/main/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourcePriorityAdapter.java
@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.yarn;
+
+import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
+import org.apache.flink.util.Preconditions;
+
+import org.apache.hadoop.yarn.api.records.Priority;
+import org.apache.hadoop.yarn.api.records.Resource;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * Utility class for converting between Flink {@link TaskExecutorProcessSpec} and Yarn {@link Resource} and {@link Priority}.
+ */
+public class TaskExecutorProcessSpecContainerResourcePriorityAdapter {
+
+	private static final Logger LOG = LoggerFactory.getLogger(TaskExecutorProcessSpecContainerResourcePriorityAdapter.class);
+
+	private final Map<TaskExecutorProcessSpec, PriorityAndResource> taskExecutorProcessSpecToPriorityAndResource;
+	private final Map<Priority, TaskExecutorProcessSpec> priorityToTaskExecutorProcessSpec;
+
+	private final Resource maxContainerResource;
+	private final Map<String, Long> externalResourceConfigs;
+
+	private int nextPriority = 1;
+
+	TaskExecutorProcessSpecContainerResourcePriorityAdapter(
+			final Resource maxContainerResource,
+			final Map<String, Long> externalResourceConfigs) {
+		this.maxContainerResource = Preconditions.checkNotNull(maxContainerResource);
+		this.externalResourceConfigs = Preconditions.checkNotNull(externalResourceConfigs);
+
+		taskExecutorProcessSpecToPriorityAndResource = new HashMap<>();
+		priorityToTaskExecutorProcessSpec = new HashMap<>();
+
+		validateExternalResourceConfigs();
+	}
+
+	Optional<PriorityAndResource> getPriorityAndResource(final TaskExecutorProcessSpec taskExecutorProcessSpec) {
+		tryAdaptAndAddTaskExecutorResourceSpecIfNotExist(taskExecutorProcessSpec);
+		return Optional.ofNullable(taskExecutorProcessSpecToPriorityAndResource.get(taskExecutorProcessSpec));
+	}
+
+	Optional<TaskExecutorProcessSpecAndResource> getTaskExecutorProcessSpecAndResource(Priority priority) {
+		final TaskExecutorProcessSpec taskExecutorProcessSpec = priorityToTaskExecutorProcessSpec.get(priority);
+
+		if (taskExecutorProcessSpec == null) {
+			return Optional.empty();
+		}
+
+		final PriorityAndResource priorityAndResource = taskExecutorProcessSpecToPriorityAndResource.get(taskExecutorProcessSpec);
+		Preconditions.checkState(priorityAndResource != null);
+		Preconditions.checkState(priority.equals(priorityAndResource.getPriority()));
+
+		return Optional.of(new TaskExecutorProcessSpecAndResource(taskExecutorProcessSpec, priorityAndResource.getResource()));
+	}
+
+	private void validateExternalResourceConfigs() {
+		final Map<String, Long> maxExternalResources =
+			ResourceInformationReflector.INSTANCE.getExternalResources(maxContainerResource);
+		for (Map.Entry<String, Long> entry : externalResourceConfigs.entrySet()) {
+			final String resourceName = entry.getKey();
+			final long configuredValue = entry.getValue();
+			Preconditions.checkState(maxExternalResources.containsKey(resourceName),
+				"External resource %s is not supported by the Yarn cluster.",
+				resourceName);
+			Preconditions.checkState(configuredValue <= maxExternalResources.get(resourceName),
+				"Configured value for external resource %s (%s) exceeds the max limitation of the Yarn cluster (%s).",
+				resourceName,
+				configuredValue,
+				maxExternalResources.get(resourceName));
+		}
+	}
+
+	private void tryAdaptAndAddTaskExecutorResourceSpecIfNotExist(final TaskExecutorProcessSpec taskExecutorProcessSpec) {
+		if (!taskExecutorProcessSpecToPriorityAndResource.containsKey(taskExecutorProcessSpec)) {
+			tryAdaptResource(taskExecutorProcessSpec)
+				.ifPresent((resource) -> {
+					final Priority priority = Priority.newInstance(nextPriority++);
+					taskExecutorProcessSpecToPriorityAndResource.put(
+						taskExecutorProcessSpec, new PriorityAndResource(priority, resource));
+					priorityToTaskExecutorProcessSpec.put(priority, taskExecutorProcessSpec);
+				});
+		}
+	}
+
+	private Optional<Resource> tryAdaptResource(final TaskExecutorProcessSpec taskExecutorProcessSpec) {
+		final Resource resource = Resource.newInstance(
+			taskExecutorProcessSpec.getTotalProcessMemorySize().getMebiBytes(),
+			taskExecutorProcessSpec.getCpuCores().getValue().intValue());
+
+		if (resource.getMemory() > maxContainerResource.getMemory() ||
+			resource.getVirtualCores() > maxContainerResource.getVirtualCores()) {
+			LOG.warn("Requested container resource ({}) exceeds the max limitation of the Yarn cluster ({}). Will not allocate resource.",
+				resource,
+				maxContainerResource);
+			return Optional.empty();
+		}
+
+		for (Map.Entry<String, Long> externalResource: externalResourceConfigs.entrySet()) {
+			ResourceInformationReflector.INSTANCE.setResourceInformation(
+				resource, externalResource.getKey(), externalResource.getValue());
+		}
+
+		return Optional.of(resource);
+	}
+
+	class PriorityAndResource {
+		private final Priority priority;
+		private final Resource resource;
+
+		private PriorityAndResource(Priority priority, Resource resource) {
+			this.priority = Preconditions.checkNotNull(priority);
+			this.resource = Preconditions.checkNotNull(resource);
+		}
+
+		Priority getPriority() {
+			return priority;
+		}
+
+		Resource getResource() {
+			return resource;
+		}
+	}
+
+	class TaskExecutorProcessSpecAndResource {
+		private final TaskExecutorProcessSpec taskExecutorProcessSpec;
+		private final Resource resource;
+
+		private TaskExecutorProcessSpecAndResource(TaskExecutorProcessSpec taskExecutorProcessSpec, Resource resource) {
+			this.taskExecutorProcessSpec = Preconditions.checkNotNull(taskExecutorProcessSpec);
+			this.resource = Preconditions.checkNotNull(resource);
+		}
+
+		TaskExecutorProcessSpec getTaskExecutorProcessSpec() {
+			return taskExecutorProcessSpec;
+		}
+
+		Resource getResource() {
+			return resource;
+		}
+	}
+}
diff --git a/flink-yarn/src/test/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourcePriorityAdapterTest.java b/flink-yarn/src/test/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourcePriorityAdapterTest.java
new file mode 100644
index 00000000000..82b9dc815dc
--- /dev/null
+++ b/flink-yarn/src/test/java/org/apache/flink/yarn/TaskExecutorProcessSpecContainerResourcePriorityAdapterTest.java
@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.yarn;
+
+import org.apache.flink.api.common.resources.CPUResource;
+import org.apache.flink.configuration.MemorySize;
+import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
+import org.apache.flink.runtime.util.HadoopUtils;
+import org.apache.flink.util.TestLogger;
+
+import org.apache.hadoop.yarn.api.records.Priority;
+import org.apache.hadoop.yarn.api.records.Resource;
+import org.junit.Test;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assume.assumeTrue;
+
+/**
+ * Tests for {@link TaskExecutorProcessSpecContainerResourcePriorityAdapter}.
+ */
+public class TaskExecutorProcessSpecContainerResourcePriorityAdapterTest extends TestLogger {
+
+	private static final Resource MAX_CONTAINER_RESOURCE = Resource.newInstance(102400, 100);
+
+	private static final String SUPPORTED_EXTERNAL_RESOURCE_NAME = "testing-external-resource";
+	private static final long SUPPORTED_EXTERNAL_RESOURCE_MAX = 10000L;
+
+	private static final TaskExecutorProcessSpec TASK_EXECUTOR_PROCESS_SPEC_1 = new TaskExecutorProcessSpec(
+		new CPUResource(1.0),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100),
+		MemorySize.ofMebiBytes(100));
+
+	private static final TaskExecutorProcessSpec TASK_EXECUTOR_PROCESS_SPEC_2 = new TaskExecutorProcessSpec(
+		new CPUResource(2.0),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200),
+		MemorySize.ofMebiBytes(200));
+
+	private static final TaskExecutorProcessSpec TASK_EXECUTOR_PROCESS_SPEC_EXCEED_MAX = new TaskExecutorProcessSpec(
+		new CPUResource(200.0),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400),
+		MemorySize.ofMebiBytes(102400));
+
+	@Test
+	public void testGetResourceFromSpec() {
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter = getAdapter();
+		final Resource resource = getResource(adapter, TASK_EXECUTOR_PROCESS_SPEC_1);
+		assertThat(resource.getMemory(), is(TASK_EXECUTOR_PROCESS_SPEC_1.getTotalProcessMemorySize().getMebiBytes()));
+		assertThat(resource.getVirtualCores(), is(TASK_EXECUTOR_PROCESS_SPEC_1.getCpuCores().getValue().intValue()));
+	}
+
+	@Test
+	public void testGetPriorityFromSpec() {
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter = getAdapter();
+		final Priority priority1 = getPriority(adapter, TASK_EXECUTOR_PROCESS_SPEC_1);
+		final Priority priority2 = getPriority(adapter, TASK_EXECUTOR_PROCESS_SPEC_2);
+		final Priority priority3 = getPriority(adapter, TASK_EXECUTOR_PROCESS_SPEC_1);
+		assertThat(priority1, not(priority2));
+		assertThat(priority1, is(priority3));
+	}
+
+	@Test
+	public void testMaxContainerResource() {
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter = getAdapter();
+		assertThat(adapter.getPriorityAndResource(TASK_EXECUTOR_PROCESS_SPEC_EXCEED_MAX).isPresent(), is(false));
+	}
+
+	@Test
+	public void testGetTaskExecutorProcessSpecAndResource() {
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter = getAdapter();
+
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter.PriorityAndResource addedPriorityAndResource =
+			adapter.getPriorityAndResource(TASK_EXECUTOR_PROCESS_SPEC_1).get();
+		final Priority unknownPriority = Priority.newInstance(987);
+
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter.TaskExecutorProcessSpecAndResource resultSpecAndResource =
+			adapter.getTaskExecutorProcessSpecAndResource(addedPriorityAndResource.getPriority()).get();
+
+		assertThat(resultSpecAndResource.getTaskExecutorProcessSpec(), is(TASK_EXECUTOR_PROCESS_SPEC_1));
+		assertThat(resultSpecAndResource.getResource(), is(addedPriorityAndResource.getResource()));
+		assertThat(adapter.getTaskExecutorProcessSpecAndResource(unknownPriority).isPresent(), is(false));
+	}
+
+	@Test
+	public void testExternalResource() {
+		assumeTrue(HadoopUtils.isMinHadoopVersion(2, 10));
+
+		final long amount = 1;
+		final TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter =
+			getAdapterWithExternalResources(SUPPORTED_EXTERNAL_RESOURCE_NAME, amount);
+		final Resource resource = getResource(adapter, TASK_EXECUTOR_PROCESS_SPEC_1);
+
+		final Map<String, Long> resultExternalResources = ResourceInformationReflector.INSTANCE.getExternalResources(resource);
+		assertThat(resultExternalResources.size(), is(1));
+		assertThat(resultExternalResources.get(SUPPORTED_EXTERNAL_RESOURCE_NAME), is(amount));
+	}
+
+	@Test(expected = IllegalStateException.class)
+	public void testExternalResourceFailExceedMax() {
+		assumeTrue(HadoopUtils.isMinHadoopVersion(2, 10));
+
+		getAdapterWithExternalResources(SUPPORTED_EXTERNAL_RESOURCE_NAME, SUPPORTED_EXTERNAL_RESOURCE_MAX + 1);
+	}
+
+	@Test(expected = IllegalStateException.class)
+	public void testExternalResourceFailResourceTypeNotSupported() {
+		assumeTrue(HadoopUtils.isMinHadoopVersion(2, 10));
+
+		getAdapterWithExternalResources("testing-unsupported-resource", 1);
+	}
+
+	@Test(expected = IllegalStateException.class)
+	public void testExternalResourceFailHadoopVersionNotSupported() {
+		assumeTrue(!HadoopUtils.isMinHadoopVersion(2, 10));
+
+		getAdapterWithExternalResources(SUPPORTED_EXTERNAL_RESOURCE_NAME, 100);
+	}
+
+	private static TaskExecutorProcessSpecContainerResourcePriorityAdapter getAdapter() {
+		return new TaskExecutorProcessSpecContainerResourcePriorityAdapter(MAX_CONTAINER_RESOURCE, Collections.emptyMap());
+	}
+
+	private static TaskExecutorProcessSpecContainerResourcePriorityAdapter getAdapterWithExternalResources(String name, long amount) {
+		final Resource maxResource = Resource.newInstance(MAX_CONTAINER_RESOURCE.getMemory(), MAX_CONTAINER_RESOURCE.getVirtualCores());
+		ResourceInformationReflector.INSTANCE.setResourceInformation(
+			maxResource, SUPPORTED_EXTERNAL_RESOURCE_NAME, SUPPORTED_EXTERNAL_RESOURCE_MAX);
+
+		final Map<String, Long> externalResources = new HashMap<>();
+		externalResources.put(name, amount);
+
+		return new TaskExecutorProcessSpecContainerResourcePriorityAdapter(maxResource, externalResources);
+	}
+
+	private static Resource getResource(TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter, TaskExecutorProcessSpec spec) {
+		return adapter.getPriorityAndResource(spec).get().getResource();
+	}
+
+	private static Priority getPriority(TaskExecutorProcessSpecContainerResourcePriorityAdapter adapter, TaskExecutorProcessSpec spec) {
+		return adapter.getPriorityAndResource(spec).get().getPriority();
+	}
+}
