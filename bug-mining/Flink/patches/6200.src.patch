diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandle.java
index d8c4e44a633..602cf6d65c8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/IncrementalRemoteKeyedStateHandle.java
@@ -408,7 +408,7 @@ public class IncrementalRemoteKeyedStateHandle implements IncrementalKeyedStateH
         return "IncrementalRemoteKeyedStateHandle{"
                 + "backendIdentifier="
                 + backendIdentifier
-                + "stateHandleId="
+                + ", stateHandleId="
                 + stateHandleId
                 + ", keyGroupRange="
                 + keyGroupRange
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java
index c49b561c863..58101a29713 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java
@@ -237,6 +237,30 @@ public interface ChangelogStateBackendHandle extends KeyedStateHandle {
             public Optional<byte[]> asBytesIfInMemory() {
                 throw new UnsupportedOperationException("Should not call here.");
             }
+
+            @Override
+            public boolean equals(Object o) {
+                if (this == o) {
+                    return true;
+                }
+                if (o == null || getClass() != o.getClass()) {
+                    return false;
+                }
+                StreamStateHandleWrapper that = (StreamStateHandleWrapper) o;
+                return Objects.equals(
+                        keyedStateHandle.getStateHandleId(),
+                        that.keyedStateHandle.getStateHandleId());
+            }
+
+            @Override
+            public int hashCode() {
+                return Objects.hash(keyedStateHandle.getStateHandleId());
+            }
+
+            @Override
+            public String toString() {
+                return "Wrapped{" + keyedStateHandle + '}';
+            }
         }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ChangelogTestUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ChangelogTestUtils.java
index 26cc1d3e6d1..cf5a657d0df 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/ChangelogTestUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/ChangelogTestUtils.java
@@ -89,9 +89,19 @@ public class ChangelogTestUtils {
             return isDiscarded;
         }
 
-        IncrementalStateHandleWrapper copy() {
+        IncrementalStateHandleWrapper deserialize() {
             return new IncrementalStateHandleWrapper(stateHandle.copy());
         }
+
+        @Override
+        public boolean equals(Object o) {
+            // override original IncrementalRemoteKeyedStateHandle#equals() method via comparing
+            // the memory address directly. This is to ensure state handle generated via
+            // #deserialize is different from the original one, which let the
+            // SharedStateRegistryImpl treat them are different via Objects#equals.
+            // More information can refer to FLINK-26101.
+            return (this == o);
+        }
     }
 
     public static class ChangelogStateHandleWrapper extends InMemoryChangelogStateHandle
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
index a724ca6abee..e2da9f673bd 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
@@ -112,8 +112,8 @@ public class SharedStateRegistryTest {
         ChangelogTestUtils.IncrementalStateHandleWrapper materializedStateBase1 =
                 createDummyIncrementalStateHandle(materializationId1);
 
-        // we copy the state handle due to FLINK-25479 to mock on JM side
-        IncrementalStateHandleWrapper materializedState1 = materializedStateBase1.copy();
+        // we deserialize the state handle due to FLINK-25479 to mock on JM side
+        IncrementalStateHandleWrapper materializedState1 = materializedStateBase1.deserialize();
         ChangelogStateHandleWrapper nonMaterializedState1 = createDummyChangelogStateHandle(1, 2);
         long materializationId = 1L;
         long checkpointId1 = 41;
@@ -128,7 +128,7 @@ public class SharedStateRegistryTest {
         sharedStateRegistry.checkpointCompleted(checkpointId1);
         sharedStateRegistry.unregisterUnusedState(checkpointId1);
 
-        IncrementalStateHandleWrapper materializedState2 = materializedStateBase1.copy();
+        IncrementalStateHandleWrapper materializedState2 = materializedStateBase1.deserialize();
         ChangelogStateHandleWrapper nonMaterializedState2 = createDummyChangelogStateHandle(2, 3);
         long checkpointId2 = 42;
         ChangelogStateBackendHandleImpl changelogStateBackendHandle2 =
@@ -145,13 +145,15 @@ public class SharedStateRegistryTest {
         // the 1st materialized state would not be discarded since the 2nd changelog state backend
         // handle still use it.
         assertFalse(materializedState1.isDiscarded());
+        // FLINK-26101, check whether the multi registered state not discarded.
+        assertFalse(materializedState2.isDiscarded());
         assertTrue(nonMaterializedState1.isDiscarded());
 
         long materializationId2 = 2L;
         IncrementalStateHandleWrapper materializedStateBase2 =
                 createDummyIncrementalStateHandle(materializationId2);
 
-        IncrementalStateHandleWrapper materializedState3 = materializedStateBase2.copy();
+        IncrementalStateHandleWrapper materializedState3 = materializedStateBase2.deserialize();
         long checkpointId3 = 43L;
         ChangelogStateBackendHandleImpl changelogStateBackendHandle3 =
                 new ChangelogStateBackendHandleImpl(
