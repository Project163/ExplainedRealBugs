diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java
index 328142f35e2..75fa24928e3 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java
@@ -75,7 +75,8 @@ public final class ChannelStatePersister {
         } else if (checkpointStatus == CheckpointStatus.BARRIER_RECEIVED) {
             checkState(
                     lastSeenBarrier >= barrierId,
-                    "Internal error, #stopPersisting for last checkpoint has not been called.");
+                    "Internal error, #stopPersisting for last checkpoint has not been called for "
+                            + channelInfo);
         }
         if (knownBuffers.size() > 0) {
             channelStateWriter.addInputData(
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java
index 5cdc3686416..3f54f1a42c9 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java
@@ -296,6 +296,7 @@ public class SingleInputGate extends IndexedInputGate {
 
     @VisibleForTesting
     void convertRecoveredInputChannels() {
+        LOG.info("Converting recovered input channels ({} channels)", getNumberOfInputChannels());
         for (Map.Entry<IntermediateResultPartitionID, InputChannel> entry :
                 inputChannels.entrySet()) {
             InputChannel inputChannel = entry.getValue();
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java
index 90e58f93897..6a0c1485bac 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/checkpointing/SingleCheckpointBarrierHandler.java
@@ -145,6 +145,10 @@ public class SingleCheckpointBarrierHandler extends CheckpointBarrierHandler {
                 }
                 numBarriersReceived = 0;
                 lastCancelledOrCompletedCheckpointId = currentCheckpointId;
+                LOG.debug(
+                        "{}: Received all barriers for checkpoint {}.",
+                        taskName,
+                        currentCheckpointId);
                 handleBarrier(
                         barrier,
                         channelInfo,
@@ -179,6 +183,11 @@ public class SingleCheckpointBarrierHandler extends CheckpointBarrierHandler {
             }
             return true;
         } catch (CheckpointException e) {
+            LOG.debug(
+                    "{}: Aborting checkpoint {} after exception {}.",
+                    taskName,
+                    currentCheckpointId,
+                    e);
             abortInternal(barrier.getId(), e);
             return false;
         } catch (RuntimeException | IOException e) {
@@ -227,6 +236,7 @@ public class SingleCheckpointBarrierHandler extends CheckpointBarrierHandler {
         final long cancelledId = cancelBarrier.getCheckpointId();
         if (cancelledId > currentCheckpointId
                 || (cancelledId == currentCheckpointId && numBarriersReceived > 0)) {
+            LOG.debug("{}: Received cancellation {}.", taskName, cancelledId);
             abortInternal(
                     cancelledId,
                     new CheckpointException(
