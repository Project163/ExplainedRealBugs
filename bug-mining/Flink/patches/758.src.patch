diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
index ff6a82c86f1..1a4ccae16a2 100644
--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java
@@ -340,6 +340,29 @@ public class TypeExtractor {
 		}
 		return ti;
 	}
+
+	/**
+	 * Creates a {@link TypeInformation} from the given parameters.
+	 *
+	 * If the given {@code instance} implements {@link ResultTypeQueryable}, its information
+	 * is used to determine the type information. Otherwise, the type information is derived
+	 * based on the given class information.
+	 *
+	 * @param instance			instance to determine type information for
+	 * @param baseClass			base class of {@code instance}
+	 * @param clazz				class of {@code instance}
+	 * @param returnParamPos	index of the return type in the type arguments of {@code clazz}
+	 * @param <OUT>				output type
+	 * @return type information
+	 */
+	@SuppressWarnings("unchecked")
+	public static <OUT> TypeInformation<OUT> createTypeInfo(Object instance, Class<?> baseClass, Class<?> clazz, int returnParamPos) {
+		if (instance instanceof ResultTypeQueryable) {
+			return ((ResultTypeQueryable<OUT>) instance).getProducedType();
+		} else {
+			return createTypeInfo(baseClass, clazz, returnParamPos, null, null);
+		}
+	}
 	
 	public static <IN1, IN2, OUT> TypeInformation<OUT> createTypeInfo(Class<?> baseClass, Class<?> clazz, int returnParamPos,
 			TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {
diff --git a/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java b/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java
index 844f3c067ba..57b32b123c3 100644
--- a/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java
+++ b/flink-java/src/test/java/org/apache/flink/api/java/type/extractor/TypeExtractorTest.java
@@ -1561,6 +1561,28 @@ public class TypeExtractorTest {
 		TypeInformation<?> ti = TypeExtractor.getMapReturnTypes(mapInterface, BasicTypeInfo.STRING_TYPE_INFO);
 		Assert.assertEquals(BasicTypeInfo.BOOLEAN_TYPE_INFO, ti);
 	}
+
+	@Test
+	public void testCreateTypeInfoFromInstance() {
+		ResultTypeQueryable instance = new ResultTypeQueryable<Long>() {
+			@Override
+			public TypeInformation<Long> getProducedType() {
+				return BasicTypeInfo.LONG_TYPE_INFO;
+			}
+		};
+		TypeInformation<?> ti = TypeExtractor.createTypeInfo(instance, null, null, 0);
+		Assert.assertEquals(BasicTypeInfo.LONG_TYPE_INFO, ti);
+
+		// method also needs to work for instances that do not implement ResultTypeQueryable
+		MapFunction<Integer, Long> func = new MapFunction<Integer, Long>() {
+			@Override
+			public Long map(Integer value) throws Exception {
+				return value.longValue();
+			}
+		};
+		ti = TypeExtractor.createTypeInfo(func, MapFunction.class, func.getClass(), 0);
+		Assert.assertEquals(BasicTypeInfo.INT_TYPE_INFO, ti);
+	}
 	
 	@SuppressWarnings({ "serial", "unchecked", "rawtypes" })
 	@Test
diff --git a/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/gsa/GatherSumApplyIteration.java b/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/gsa/GatherSumApplyIteration.java
index 23ccb68395e..a68b5c8ef08 100755
--- a/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/gsa/GatherSumApplyIteration.java
+++ b/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/gsa/GatherSumApplyIteration.java
@@ -115,7 +115,7 @@ public class GatherSumApplyIteration<K, VV, EV, M> implements CustomUnaryOperati
 
 		// Prepare type information
 		TypeInformation<K> keyType = ((TupleTypeInfo<?>) vertexDataSet.getType()).getTypeAt(0);
-		TypeInformation<M> messageType = TypeExtractor.createTypeInfo(GatherFunction.class, gather.getClass(), 2, null, null);
+		TypeInformation<M> messageType = TypeExtractor.createTypeInfo(gather, GatherFunction.class, gather.getClass(), 2);
 		TypeInformation<Tuple2<K, M>> innerType = new TupleTypeInfo<Tuple2<K, M>>(keyType, messageType);
 		TypeInformation<Vertex<K, VV>> outputType = vertexDataSet.getType();
 
diff --git a/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/spargel/VertexCentricIteration.java b/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/spargel/VertexCentricIteration.java
index be48f9c4b68..5c60833aab9 100644
--- a/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/spargel/VertexCentricIteration.java
+++ b/flink-libraries/flink-gelly/src/main/java/org/apache/flink/graph/spargel/VertexCentricIteration.java
@@ -110,7 +110,7 @@ public class VertexCentricIteration<K, VV, Message, EV>
 	}
 	
 	private TypeInformation<Message> getMessageType(MessagingFunction<K, VV, Message, EV> mf) {
-		return TypeExtractor.createTypeInfo(MessagingFunction.class, mf.getClass(), 2, null, null);
+		return TypeExtractor.createTypeInfo(mf, MessagingFunction.class, mf.getClass(), 2);
 	}
 	
 	// --------------------------------------------------------------------------------------------
@@ -683,4 +683,4 @@ public class VertexCentricIteration<K, VV, Message, EV>
 		// let the operator know that we preserve the key field
 		updates.withForwardedFieldsFirst("0").withForwardedFieldsSecond("0");
 	}
-}
\ No newline at end of file
+}
