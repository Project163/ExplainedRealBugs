diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
index 7324db31cc7..bc28cc5809e 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFA.java
@@ -19,15 +19,28 @@
 package org.apache.flink.cep.nfa;
 
 import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.api.common.typeutils.CompatibilityResult;
+import org.apache.flink.api.common.typeutils.CompatibilityUtil;
+import org.apache.flink.api.common.typeutils.CompositeTypeSerializerConfigSnapshot;
+import org.apache.flink.api.common.typeutils.TypeDeserializerAdapter;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.api.common.typeutils.TypeSerializerConfigSnapshot;
+import org.apache.flink.api.common.typeutils.UnloadableDummyTypeSerializer;
+import org.apache.flink.api.common.typeutils.base.EnumSerializer;
+import org.apache.flink.api.common.typeutils.base.StringSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.cep.nfa.compiler.NFACompiler;
 import org.apache.flink.cep.nfa.compiler.NFAStateNameHandler;
 import org.apache.flink.cep.operator.AbstractKeyedCEPPatternOperator;
 import org.apache.flink.cep.pattern.conditions.IterativeCondition;
+import org.apache.flink.core.memory.DataInputView;
+import org.apache.flink.core.memory.DataOutputView;
 import org.apache.flink.streaming.api.windowing.time.Time;
 import org.apache.flink.util.Preconditions;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -121,13 +134,11 @@ public class NFA<T> {
 	}
 
 	private State<T> getState(String state) {
-		State<T> result = states.get(state);
-		return result;
+		return states.get(state);
 	}
 
 	private State<T> getState(ComputationState<T> state) {
-		State<T> result = states.get(state.getState());
-		return result;
+		return states.get(state.getState());
 	}
 
 	private boolean isStartState(ComputationState<T> state) {
@@ -801,4 +812,255 @@ public class NFA<T> {
 			};
 		}
 	}
+
+	/**
+	 * The {@link TypeSerializerConfigSnapshot} serializer configuration to be stored with the managed state.
+	 */
+	@Deprecated
+	public static final class NFASerializerConfigSnapshot<T> extends CompositeTypeSerializerConfigSnapshot {
+
+		private static final int VERSION = 1;
+
+		/** This empty constructor is required for deserializing the configuration. */
+		public NFASerializerConfigSnapshot() {}
+
+		public NFASerializerConfigSnapshot(
+			TypeSerializer<T> eventSerializer,
+			TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer) {
+
+			super(eventSerializer, sharedBufferSerializer);
+		}
+
+		@Override
+		public int getVersion() {
+			return VERSION;
+		}
+	}
+
+	/**
+	 * Only for backward compatibility with <1.5.
+	 */
+	@Deprecated
+	public static class NFASerializer<T> extends TypeSerializer<NFA<T>> {
+
+		private static final long serialVersionUID = 2098282423980597010L;
+
+		private final TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer;
+
+		private final TypeSerializer<T> eventSerializer;
+
+		public NFASerializer(TypeSerializer<T> typeSerializer) {
+			this(typeSerializer, new SharedBuffer.SharedBufferSerializer<>(StringSerializer.INSTANCE, typeSerializer));
+		}
+
+		NFASerializer(
+			TypeSerializer<T> typeSerializer,
+			TypeSerializer<SharedBuffer<String, T>> sharedBufferSerializer) {
+			this.eventSerializer = typeSerializer;
+			this.sharedBufferSerializer = sharedBufferSerializer;
+		}
+
+		@Override
+		public boolean isImmutableType() {
+			return false;
+		}
+
+		@Override
+		public NFASerializer<T> duplicate() {
+			return new NFASerializer<>(eventSerializer.duplicate());
+		}
+
+		@Override
+		public NFA<T> createInstance() {
+			return null;
+		}
+
+		@Override
+		public NFA<T> copy(NFA<T> from) {
+			throw new UnsupportedOperationException();
+		}
+
+		@Override
+		public NFA<T> copy(NFA<T> from, NFA<T> reuse) {
+			return copy(from);
+		}
+
+		@Override
+		public int getLength() {
+			return -1;
+		}
+
+		@Override
+		public void serialize(NFA<T> record, DataOutputView target) throws IOException {
+			throw new UnsupportedOperationException();
+		}
+
+		@Override
+		public NFA<T> deserialize(DataInputView source) throws IOException {
+			deserializeStates(source);
+			source.readLong();
+			source.readBoolean();
+
+			SharedBuffer<String, T> sharedBuffer = sharedBufferSerializer.deserialize(source);
+			Queue<ComputationState<T>> computationStates = NFASerializationUtils.deserializeComputationStates(eventSerializer, source);
+
+			return new DummyNFA<>(eventSerializer, computationStates, sharedBuffer);
+		}
+
+		/**
+		 * Dummy nfa just for backwards compatibility.
+		 */
+		public static class DummyNFA<T> extends NFA<T> {
+
+			Queue<ComputationState<T>> computationStates;
+			SharedBuffer<String, T> sharedBuffer;
+
+			public SharedBuffer<String, T> getSharedBuffer() {
+				return sharedBuffer;
+			}
+
+			public Queue<ComputationState<T>> getComputationStates() {
+				return computationStates;
+			}
+
+			DummyNFA(TypeSerializer<T> eventSerializer, Queue<ComputationState<T>> computationStates, SharedBuffer<String, T> sharedBuffer) {
+				super(eventSerializer, 0, false, Collections.emptyList());
+				this.sharedBuffer = sharedBuffer;
+				this.computationStates = computationStates;
+			}
+		}
+
+		@Override
+		public NFA<T> deserialize(NFA<T> reuse, DataInputView source) throws IOException {
+			return deserialize(source);
+		}
+
+		@Override
+		public void copy(DataInputView source, DataOutputView target) throws IOException {
+			throw new UnsupportedOperationException();
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			return obj == this ||
+				(obj != null && obj.getClass().equals(getClass()) &&
+					sharedBufferSerializer.equals(((NFASerializer) obj).sharedBufferSerializer) &&
+					eventSerializer.equals(((NFASerializer) obj).eventSerializer));
+		}
+
+		@Override
+		public boolean canEqual(Object obj) {
+			return true;
+		}
+
+		@Override
+		public int hashCode() {
+			return 37 * sharedBufferSerializer.hashCode() + eventSerializer.hashCode();
+		}
+
+		@Override
+		public TypeSerializerConfigSnapshot snapshotConfiguration() {
+			return new NFASerializerConfigSnapshot<>(eventSerializer, sharedBufferSerializer);
+		}
+
+		@Override
+		public CompatibilityResult<NFA<T>> ensureCompatibility(TypeSerializerConfigSnapshot configSnapshot) {
+			if (configSnapshot instanceof NFASerializerConfigSnapshot) {
+				List<Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> serializersAndConfigs =
+					((NFASerializerConfigSnapshot) configSnapshot).getNestedSerializersAndConfigs();
+
+				CompatibilityResult<T> eventCompatResult = CompatibilityUtil.resolveCompatibilityResult(
+						serializersAndConfigs.get(0).f0,
+						UnloadableDummyTypeSerializer.class,
+						serializersAndConfigs.get(0).f1,
+						eventSerializer);
+
+				CompatibilityResult<SharedBuffer<String, T>> sharedBufCompatResult =
+						CompatibilityUtil.resolveCompatibilityResult(
+								serializersAndConfigs.get(1).f0,
+								UnloadableDummyTypeSerializer.class,
+								serializersAndConfigs.get(1).f1,
+								sharedBufferSerializer);
+
+				if (!sharedBufCompatResult.isRequiresMigration() && !eventCompatResult.isRequiresMigration()) {
+					return CompatibilityResult.compatible();
+				} else {
+					if (eventCompatResult.getConvertDeserializer() != null &&
+						sharedBufCompatResult.getConvertDeserializer() != null) {
+						return CompatibilityResult.requiresMigration(
+							new NFASerializer<>(
+								new TypeDeserializerAdapter<>(eventCompatResult.getConvertDeserializer()),
+								new TypeDeserializerAdapter<>(sharedBufCompatResult.getConvertDeserializer())));
+					}
+				}
+			}
+
+			return CompatibilityResult.requiresMigration();
+		}
+
+		private Set<State<T>> deserializeStates(DataInputView in) throws IOException {
+			TypeSerializer<String> nameSerializer = StringSerializer.INSTANCE;
+			TypeSerializer<State.StateType> stateTypeSerializer = new EnumSerializer<>(State.StateType.class);
+			TypeSerializer<StateTransitionAction> actionSerializer = new EnumSerializer<>(StateTransitionAction.class);
+
+			final int noOfStates = in.readInt();
+			Map<String, State<T>> states = new HashMap<>(noOfStates);
+
+			for (int i = 0; i < noOfStates; i++) {
+				String stateName = nameSerializer.deserialize(in);
+				State.StateType stateType = stateTypeSerializer.deserialize(in);
+
+				State<T> state = new State<>(stateName, stateType);
+				states.put(stateName, state);
+			}
+
+			for (int i = 0; i < noOfStates; i++) {
+				String srcName = nameSerializer.deserialize(in);
+
+				int noOfTransitions = in.readInt();
+				for (int j = 0; j < noOfTransitions; j++) {
+					String src = nameSerializer.deserialize(in);
+					Preconditions.checkState(src.equals(srcName),
+							"Source Edge names do not match (" + srcName + " - " + src + ").");
+
+					String trgt = nameSerializer.deserialize(in);
+					StateTransitionAction action = actionSerializer.deserialize(in);
+
+					IterativeCondition<T> condition = null;
+					try {
+						condition = deserializeCondition(in);
+					} catch (ClassNotFoundException e) {
+						e.printStackTrace();
+					}
+
+					State<T> srcState = states.get(src);
+					State<T> trgtState = states.get(trgt);
+					srcState.addStateTransition(action, trgtState, condition);
+				}
+
+			}
+			return new HashSet<>(states.values());
+		}
+
+		private IterativeCondition<T> deserializeCondition(DataInputView in) throws IOException, ClassNotFoundException {
+			boolean hasCondition = in.readBoolean();
+			if (hasCondition) {
+				int length = in.readInt();
+
+				byte[] serCondition = new byte[length];
+				in.read(serCondition);
+
+				ByteArrayInputStream bais = new ByteArrayInputStream(serCondition);
+				ObjectInputStream ois = new ObjectInputStream(bais);
+
+				IterativeCondition<T> condition = (IterativeCondition<T>) ois.readObject();
+				ois.close();
+				bais.close();
+
+				return condition;
+			}
+			return null;
+		}
+	}
+
 }
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFASerializationUtils.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFASerializationUtils.java
new file mode 100644
index 00000000000..612eb250615
--- /dev/null
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFASerializationUtils.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.cep.nfa;
+
+import org.apache.flink.api.common.typeutils.TypeSerializer;
+import org.apache.flink.api.common.typeutils.base.LongSerializer;
+import org.apache.flink.api.common.typeutils.base.StringSerializer;
+import org.apache.flink.core.memory.DataInputView;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.Queue;
+
+class NFASerializationUtils {
+
+	/**
+	 * Deserializes {@link Queue} of {@link ComputationState}s. The queue is represented as count of states then follows
+	 * n instances of the computational state.
+	 *
+	 * @param eventSerializer event serializer for deserializing accepted events
+	 * @param source          view on the serialized data
+	 * @param <T>             type of processed events
+	 * @return queue of computation states
+	 */
+	static <T> Queue<ComputationState<T>> deserializeComputationStates(TypeSerializer<T> eventSerializer,
+			DataInputView source) throws IOException {
+		Queue<ComputationState<T>> computationStates = new LinkedList<>();
+		StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
+		LongSerializer timestampSerializer = LongSerializer.INSTANCE;
+		DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
+
+		int computationStateNo = source.readInt();
+		for (int i = 0; i < computationStateNo; i++) {
+			String state = stateNameSerializer.deserialize(source);
+			String prevState = stateNameSerializer.deserialize(source);
+			long timestamp = timestampSerializer.deserialize(source);
+			DeweyNumber version = versionSerializer.deserialize(source);
+			long startTimestamp = timestampSerializer.deserialize(source);
+			int counter = source.readInt();
+
+			T event = null;
+			if (source.readBoolean()) {
+				event = eventSerializer.deserialize(source);
+			}
+
+			computationStates.add(ComputationState.createState(
+				state, prevState, event, counter, timestamp, version, startTimestamp));
+		}
+		return computationStates;
+	}
+
+	private NFASerializationUtils() {
+	}
+}
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java
index 4dae7986f43..5b057e17b39 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/NFAStateSerializer.java
@@ -35,7 +35,6 @@ import org.apache.flink.core.memory.DataOutputViewStreamWrapper;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
@@ -135,30 +134,8 @@ public class NFAStateSerializer<T> extends TypeSerializer<NFAState<T>> {
 	@Override
 	public NFAState<T> deserialize(DataInputView source) throws IOException {
 		SharedBuffer<String, T> sharedBuffer = sharedBufferSerializer.deserialize(source);
-
-		Queue<ComputationState<T>> computationStates = new LinkedList<>();
-		StringSerializer stateNameSerializer = StringSerializer.INSTANCE;
-		LongSerializer timestampSerializer = LongSerializer.INSTANCE;
-		DeweyNumber.DeweyNumberSerializer versionSerializer = new DeweyNumber.DeweyNumberSerializer();
-
-		int computationStateNo = source.readInt();
-		for (int i = 0; i < computationStateNo; i++) {
-			String state = stateNameSerializer.deserialize(source);
-			String prevState = stateNameSerializer.deserialize(source);
-			long timestamp = timestampSerializer.deserialize(source);
-			DeweyNumber version = versionSerializer.deserialize(source);
-			long startTimestamp = timestampSerializer.deserialize(source);
-			int counter = source.readInt();
-
-			T event = null;
-			if (source.readBoolean()) {
-				event = eventSerializer.deserialize(source);
-			}
-
-			computationStates.add(ComputationState.createState(
-					state, prevState, event, counter, timestamp, version, startTimestamp));
-		}
-
+		Queue<ComputationState<T>> computationStates = NFASerializationUtils.deserializeComputationStates(
+			eventSerializer, source);
 		return new NFAState<>(computationStates, sharedBuffer, false);
 	}
 
@@ -234,20 +211,20 @@ public class NFAStateSerializer<T> extends TypeSerializer<NFAState<T>> {
 	public CompatibilityResult<NFAState<T>> ensureCompatibility(TypeSerializerConfigSnapshot configSnapshot) {
 		if (configSnapshot instanceof NFAStateSerializerConfigSnapshot) {
 			List<Tuple2<TypeSerializer<?>, TypeSerializerConfigSnapshot>> serializersAndConfigs =
-					((NFAStateSerializerConfigSnapshot) configSnapshot).getNestedSerializersAndConfigs();
+				((NFAStateSerializerConfigSnapshot) configSnapshot).getNestedSerializersAndConfigs();
 
 			CompatibilityResult<T> eventCompatResult = CompatibilityUtil.resolveCompatibilityResult(
-					serializersAndConfigs.get(0).f0,
-					UnloadableDummyTypeSerializer.class,
-					serializersAndConfigs.get(0).f1,
-					eventSerializer);
+				serializersAndConfigs.get(0).f0,
+				UnloadableDummyTypeSerializer.class,
+				serializersAndConfigs.get(0).f1,
+				eventSerializer);
 
 			CompatibilityResult<SharedBuffer<String, T>> sharedBufCompatResult =
-					CompatibilityUtil.resolveCompatibilityResult(
-							serializersAndConfigs.get(1).f0,
-							UnloadableDummyTypeSerializer.class,
-							serializersAndConfigs.get(1).f1,
-							sharedBufferSerializer);
+				CompatibilityUtil.resolveCompatibilityResult(
+					serializersAndConfigs.get(1).f0,
+					UnloadableDummyTypeSerializer.class,
+					serializersAndConfigs.get(1).f1,
+					sharedBufferSerializer);
 
 			if (!sharedBufCompatResult.isRequiresMigration() && !eventCompatResult.isRequiresMigration()) {
 				return CompatibilityResult.compatible();
diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java
index 312549f40d6..7cdf7322ab6 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/operator/AbstractKeyedCEPPatternOperator.java
@@ -34,6 +34,7 @@ import org.apache.flink.cep.nfa.NFA;
 import org.apache.flink.cep.nfa.NFAState;
 import org.apache.flink.cep.nfa.NFAStateSerializer;
 import org.apache.flink.cep.nfa.compiler.NFACompiler;
+import org.apache.flink.runtime.state.KeyedStateFunction;
 import org.apache.flink.runtime.state.StateInitializationContext;
 import org.apache.flink.runtime.state.VoidNamespace;
 import org.apache.flink.runtime.state.VoidNamespaceSerializer;
@@ -78,7 +79,7 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 
 	///////////////			State			//////////////
 
-	private static final String NFA_OPERATOR_STATE_NAME = "nfaOperatorStateName";
+	private static final String NFA_STATE_NAME = "nfaStateName";
 	private static final String EVENT_QUEUE_STATE_NAME = "eventQueuesStateName";
 
 	private transient ValueState<NFAState<IN>> nfaValueState;
@@ -136,7 +137,7 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 		if (nfaValueState == null) {
 			nfaValueState = getRuntimeContext().getState(
 				new ValueStateDescriptor<>(
-						NFA_OPERATOR_STATE_NAME,
+						NFA_STATE_NAME,
 						new NFAStateSerializer<>(inputSerializer)));
 		}
 
@@ -149,6 +150,30 @@ public abstract class AbstractKeyedCEPPatternOperator<IN, KEY, OUT, F extends Fu
 					)
 			);
 		}
+
+		migrateOldState();
+	}
+
+	private void migrateOldState() throws Exception {
+		getKeyedStateBackend().applyToAllKeys(
+			VoidNamespace.INSTANCE,
+			VoidNamespaceSerializer.INSTANCE,
+			new ValueStateDescriptor<>(
+				"nfaOperatorStateName",
+				new NFA.NFASerializer<>(inputSerializer)
+			),
+			new KeyedStateFunction<Object, ValueState<NFA<IN>>>() {
+				@Override
+				public void process(Object key, ValueState<NFA<IN>> state) throws Exception {
+					NFA<IN> oldState = state.value();
+					if (oldState instanceof NFA.NFASerializer.DummyNFA) {
+						NFA.NFASerializer.DummyNFA<IN> dummyNFA = (NFA.NFASerializer.DummyNFA<IN>) oldState;
+						nfaValueState.update(new NFAState<>(dummyNFA.getComputationStates(), dummyNFA.getSharedBuffer(), false));
+						state.clear();
+					}
+				}
+			}
+		);
 	}
 
 	@Override
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java
index 3151498feed..9b120cac925 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/operator/CEPMigrationTest.java
@@ -71,7 +71,7 @@ public class CEPMigrationTest {
 
 	@Parameterized.Parameters(name = "Migration Savepoint: {0}")
 	public static Collection<MigrationVersion> parameters () {
-		return Arrays.asList(MigrationVersion.v1_5);
+		return Arrays.asList(MigrationVersion.v1_3, MigrationVersion.v1_4, MigrationVersion.v1_5);
 	}
 
 	public CEPMigrationTest(MigrationVersion migrateVersion) {
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.4-snapshot
new file mode 100644
index 00000000000..34c5110607d
Binary files /dev/null and b/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.4-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot
index 73934e565f5..4a2b607368b 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-after-branching-flink1.5-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.4-snapshot
new file mode 100644
index 00000000000..d4d3405ae45
Binary files /dev/null and b/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.4-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot
index 3126ff4867b..f5e00beece1 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-conditions-flink1.5-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.4-snapshot
new file mode 100644
index 00000000000..c87f307a574
Binary files /dev/null and b/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.4-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot
index 63b1b492249..901804359a9 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-single-pattern-afterwards-flink1.5-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.4-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.4-snapshot
new file mode 100644
index 00000000000..660a21a77b0
Binary files /dev/null and b/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.4-snapshot differ
diff --git a/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot b/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot
index 1b1fa754c9e..53819f22637 100644
Binary files a/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot and b/flink-libraries/flink-cep/src/test/resources/cep-migration-starting-new-pattern-flink1.5-snapshot differ
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java
index 9915dd51816..c1934165772 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java
@@ -396,6 +396,8 @@ public abstract class AbstractStreamOperator<OUT>
 		return snapshotInProgress;
 	}
 
+
+
 	/**
 	 * Stream operators with state, which want to participate in a snapshot need to override this hook method.
 	 *
