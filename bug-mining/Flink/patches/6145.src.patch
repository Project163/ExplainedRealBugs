diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionService.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionService.java
new file mode 100644
index 00000000000..978f69b70f7
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionService.java
@@ -0,0 +1,278 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.ExecutorUtils;
+import org.apache.flink.util.FlinkException;
+import org.apache.flink.util.Preconditions;
+import org.apache.flink.util.concurrent.ExecutorThreadFactory;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+
+/**
+ * Default implementation of a {@link MultipleComponentLeaderElectionService} that allows to
+ * register multiple {@link LeaderElectionEventHandler}.
+ */
+public class DefaultMultipleComponentLeaderElectionService
+        implements MultipleComponentLeaderElectionService,
+                MultipleComponentLeaderElectionDriver.Listener {
+    private static final Logger LOG =
+            LoggerFactory.getLogger(DefaultMultipleComponentLeaderElectionService.class);
+
+    private final Object lock = new Object();
+
+    private final MultipleComponentLeaderElectionDriver multipleComponentLeaderElectionDriver;
+
+    private final FatalErrorHandler fatalErrorHandler;
+
+    @GuardedBy("lock")
+    private final ExecutorService leadershipOperationExecutor;
+
+    @GuardedBy("lock")
+    private final Map<String, LeaderElectionEventHandler> leaderElectionEventHandlers;
+
+    @GuardedBy("lock")
+    private boolean running = true;
+
+    @Nullable
+    @GuardedBy("lock")
+    private UUID currentLeaderSessionId = null;
+
+    @VisibleForTesting
+    DefaultMultipleComponentLeaderElectionService(
+            FatalErrorHandler fatalErrorHandler,
+            MultipleComponentLeaderElectionDriverFactory
+                    multipleComponentLeaderElectionDriverFactory,
+            ExecutorService leadershipOperationExecutor)
+            throws Exception {
+        this.fatalErrorHandler = Preconditions.checkNotNull(fatalErrorHandler);
+
+        this.leadershipOperationExecutor = Preconditions.checkNotNull(leadershipOperationExecutor);
+
+        leaderElectionEventHandlers = new HashMap<>();
+
+        multipleComponentLeaderElectionDriver =
+                multipleComponentLeaderElectionDriverFactory.create(this);
+    }
+
+    public DefaultMultipleComponentLeaderElectionService(
+            FatalErrorHandler fatalErrorHandler,
+            MultipleComponentLeaderElectionDriverFactory
+                    multipleComponentLeaderElectionDriverFactory)
+            throws Exception {
+        this(
+                fatalErrorHandler,
+                multipleComponentLeaderElectionDriverFactory,
+                Executors.newSingleThreadExecutor(
+                        new ExecutorThreadFactory("leadershipOperationExecutor")));
+    }
+
+    @Override
+    public void close() throws Exception {
+        synchronized (lock) {
+            if (!running) {
+                return;
+            }
+            running = false;
+
+            LOG.info("Closing {}.", this.getClass().getSimpleName());
+
+            ExecutorUtils.gracefulShutdown(10L, TimeUnit.SECONDS, leadershipOperationExecutor);
+
+            multipleComponentLeaderElectionDriver.close();
+        }
+    }
+
+    @Override
+    public LeaderElectionDriverFactory createDriverFactory(String componentId) {
+        return new MultipleComponentLeaderElectionDriverAdapterFactory(componentId, this);
+    }
+
+    @Override
+    public void publishLeaderInformation(String componentId, LeaderInformation leaderInformation) {
+        try {
+            multipleComponentLeaderElectionDriver.publishLeaderInformation(
+                    componentId, leaderInformation);
+        } catch (Exception e) {
+            fatalErrorHandler.onFatalError(
+                    new FlinkException(
+                            String.format(
+                                    "Could not write leader information %s for leader %s.",
+                                    leaderInformation, componentId),
+                            e));
+        }
+    }
+
+    @Override
+    public void registerLeaderElectionEventHandler(
+            String componentId, LeaderElectionEventHandler leaderElectionEventHandler) {
+
+        synchronized (lock) {
+            Preconditions.checkArgument(
+                    !leaderElectionEventHandlers.containsKey(componentId),
+                    "Do not support duplicate LeaderElectionEventHandler registration under %s",
+                    componentId);
+            leaderElectionEventHandlers.put(componentId, leaderElectionEventHandler);
+
+            if (currentLeaderSessionId != null) {
+                final UUID leaderSessionId = currentLeaderSessionId;
+                leadershipOperationExecutor.execute(
+                        () -> leaderElectionEventHandler.onGrantLeadership(leaderSessionId));
+            }
+        }
+    }
+
+    @Override
+    public void unregisterLeaderElectionEventHandler(String componentId) throws Exception {
+        final LeaderElectionEventHandler unregisteredLeaderElectionEventHandler;
+        synchronized (lock) {
+            unregisteredLeaderElectionEventHandler =
+                    leaderElectionEventHandlers.remove(componentId);
+
+            if (unregisteredLeaderElectionEventHandler != null) {
+                leadershipOperationExecutor.execute(
+                        unregisteredLeaderElectionEventHandler::onRevokeLeadership);
+            } else {
+                LOG.debug(
+                        "Could not find leader election event handler for componentId {}. Ignoring the unregister call.",
+                        componentId);
+            }
+        }
+
+        multipleComponentLeaderElectionDriver.deleteLeaderInformation(componentId);
+    }
+
+    @Override
+    public boolean hasLeadership(String componentId) {
+        synchronized (lock) {
+            Preconditions.checkState(running);
+
+            return leaderElectionEventHandlers.containsKey(componentId)
+                    && multipleComponentLeaderElectionDriver.hasLeadership();
+        }
+    }
+
+    @Override
+    public void isLeader() {
+        final UUID newLeaderSessionId = UUID.randomUUID();
+        synchronized (lock) {
+            if (!running) {
+                return;
+            }
+
+            currentLeaderSessionId = UUID.randomUUID();
+
+            forEachLeaderElectionEventHandler(
+                    leaderElectionEventHandler ->
+                            leaderElectionEventHandler.onGrantLeadership(newLeaderSessionId));
+        }
+    }
+
+    @Override
+    public void notLeader() {
+        synchronized (lock) {
+            if (!running) {
+                return;
+            }
+
+            currentLeaderSessionId = null;
+
+            forEachLeaderElectionEventHandler(LeaderElectionEventHandler::onRevokeLeadership);
+        }
+    }
+
+    @GuardedBy("lock")
+    private void forEachLeaderElectionEventHandler(
+            Consumer<? super LeaderElectionEventHandler> action) {
+
+        for (LeaderElectionEventHandler leaderElectionEventHandler :
+                leaderElectionEventHandlers.values()) {
+            leadershipOperationExecutor.execute(() -> action.accept(leaderElectionEventHandler));
+        }
+    }
+
+    @Override
+    public void notifyLeaderInformationChange(
+            String componentId, LeaderInformation leaderInformation) {
+        synchronized (lock) {
+            if (!running) {
+                return;
+            }
+
+            final LeaderElectionEventHandler leaderElectionEventHandler =
+                    leaderElectionEventHandlers.get(componentId);
+
+            if (leaderElectionEventHandler != null) {
+                leadershipOperationExecutor.execute(
+                        () ->
+                                leaderElectionEventHandler.onLeaderInformationChange(
+                                        leaderInformation));
+            }
+        }
+    }
+
+    @Override
+    public void notifyAllKnownLeaderInformation(
+            Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds) {
+        synchronized (lock) {
+            if (!running) {
+                return;
+            }
+
+            final Map<String, LeaderInformation> leaderInformationByName =
+                    leaderInformationWithComponentIds.stream()
+                            .collect(
+                                    Collectors.toMap(
+                                            LeaderInformationWithComponentId::getComponentId,
+                                            LeaderInformationWithComponentId
+                                                    ::getLeaderInformation));
+
+            for (Map.Entry<String, LeaderElectionEventHandler>
+                    leaderNameLeaderElectionEventHandlerPair :
+                            leaderElectionEventHandlers.entrySet()) {
+                final String leaderName = leaderNameLeaderElectionEventHandlerPair.getKey();
+                if (leaderInformationByName.containsKey(leaderName)) {
+                    leaderNameLeaderElectionEventHandlerPair
+                            .getValue()
+                            .onLeaderInformationChange(leaderInformationByName.get(leaderName));
+                } else {
+                    leaderNameLeaderElectionEventHandlerPair
+                            .getValue()
+                            .onLeaderInformationChange(LeaderInformation.empty());
+                }
+            }
+        }
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/LeaderInformationWithComponentId.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/LeaderInformationWithComponentId.java
new file mode 100644
index 00000000000..4921cf03815
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/LeaderInformationWithComponentId.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import java.util.Objects;
+
+/** Leader information and its corresponding leader name. */
+public final class LeaderInformationWithComponentId {
+    private final String componentId;
+
+    private final LeaderInformation leaderInformation;
+
+    private LeaderInformationWithComponentId(
+            String componentId, LeaderInformation leaderInformation) {
+        this.componentId = componentId;
+        this.leaderInformation = leaderInformation;
+    }
+
+    LeaderInformation getLeaderInformation() {
+        return leaderInformation;
+    }
+
+    String getComponentId() {
+        return componentId;
+    }
+
+    public static LeaderInformationWithComponentId create(
+            String componentId, LeaderInformation leaderInformation) {
+        return new LeaderInformationWithComponentId(componentId, leaderInformation);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+        LeaderInformationWithComponentId that = (LeaderInformationWithComponentId) o;
+        return Objects.equals(componentId, that.componentId)
+                && Objects.equals(leaderInformation, that.leaderInformation);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(componentId, leaderInformation);
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriver.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriver.java
new file mode 100644
index 00000000000..5ce1999cef3
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriver.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import java.util.Collection;
+
+/**
+ * A leader election driver that allows to write {@link LeaderInformation} for multiple components.
+ */
+public interface MultipleComponentLeaderElectionDriver {
+
+    /**
+     * Closes the driver.
+     *
+     * @throws Exception if closing this driver fails
+     */
+    void close() throws Exception;
+
+    /**
+     * Returns whether the driver has currently leadership.
+     *
+     * @return {@code true} if the driver has leadership, otherwise {@code false}
+     */
+    boolean hasLeadership();
+
+    /**
+     * Publishes the leader information for the given component.
+     *
+     * @param componentId identifying the component for which to publish the leader information
+     * @param leaderInformation leader information of the respective component
+     * @throws Exception if publishing fails
+     */
+    void publishLeaderInformation(String componentId, LeaderInformation leaderInformation)
+            throws Exception;
+
+    /**
+     * Deletes the leader information for the given component.
+     *
+     * @param componentId identifying the component for which to delete the leader information
+     * @throws Exception if deleting fails
+     */
+    void deleteLeaderInformation(String componentId) throws Exception;
+
+    /**
+     * Listener interface for state changes of the {@link MultipleComponentLeaderElectionDriver}.
+     */
+    interface Listener {
+
+        /** Callback that is called once the driver obtains the leadership. */
+        void isLeader();
+
+        /** Callback that is called once the driver loses the leadership. */
+        void notLeader();
+
+        /**
+         * Notifies the listener about a changed leader information for the given component.
+         *
+         * @param componentId identifying the component whose leader information has changed
+         * @param leaderInformation new leader information
+         */
+        void notifyLeaderInformationChange(String componentId, LeaderInformation leaderInformation);
+
+        /**
+         * Notifies the listener about all currently known leader information.
+         *
+         * @param leaderInformationWithComponentIds leader information with component ids
+         */
+        void notifyAllKnownLeaderInformation(
+                Collection<LeaderInformationWithComponentId> leaderInformationWithComponentIds);
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverAdapter.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverAdapter.java
new file mode 100644
index 00000000000..c866609dfb7
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverAdapter.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.util.Preconditions;
+
+/**
+ * {@link LeaderElectionDriver} adapter that multiplexes the leader election of a component into a
+ * single leader election via {@link MultipleComponentLeaderElectionService}.
+ */
+final class MultipleComponentLeaderElectionDriverAdapter implements LeaderElectionDriver {
+    private final String componentId;
+    private final MultipleComponentLeaderElectionService multipleComponentLeaderElectionService;
+
+    MultipleComponentLeaderElectionDriverAdapter(
+            String componentId,
+            MultipleComponentLeaderElectionService multipleComponentLeaderElectionService,
+            LeaderElectionEventHandler leaderElectionEventHandler) {
+        this.componentId = Preconditions.checkNotNull(componentId);
+        this.multipleComponentLeaderElectionService =
+                Preconditions.checkNotNull(multipleComponentLeaderElectionService);
+
+        multipleComponentLeaderElectionService.registerLeaderElectionEventHandler(
+                this.componentId, leaderElectionEventHandler);
+    }
+
+    @Override
+    public void writeLeaderInformation(LeaderInformation leaderInformation) {
+        multipleComponentLeaderElectionService.publishLeaderInformation(
+                componentId, leaderInformation);
+    }
+
+    @Override
+    public boolean hasLeadership() {
+        return multipleComponentLeaderElectionService.hasLeadership(componentId);
+    }
+
+    @Override
+    public void close() throws Exception {
+        multipleComponentLeaderElectionService.unregisterLeaderElectionEventHandler(componentId);
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverAdapterFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverAdapterFactory.java
new file mode 100644
index 00000000000..939cfb0c608
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverAdapterFactory.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.Preconditions;
+
+/** Factory for a {@link MultipleComponentLeaderElectionDriverAdapter}. */
+final class MultipleComponentLeaderElectionDriverAdapterFactory
+        implements LeaderElectionDriverFactory {
+    private final String leaderName;
+    private final MultipleComponentLeaderElectionService singleLeaderElectionService;
+
+    MultipleComponentLeaderElectionDriverAdapterFactory(
+            String leaderName, MultipleComponentLeaderElectionService singleLeaderElectionService) {
+        this.leaderName = Preconditions.checkNotNull(leaderName);
+        this.singleLeaderElectionService = Preconditions.checkNotNull(singleLeaderElectionService);
+    }
+
+    @Override
+    public LeaderElectionDriver createLeaderElectionDriver(
+            LeaderElectionEventHandler leaderEventHandler,
+            FatalErrorHandler fatalErrorHandler,
+            String leaderContenderDescription)
+            throws Exception {
+        return new MultipleComponentLeaderElectionDriverAdapter(
+                leaderName, singleLeaderElectionService, leaderEventHandler);
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverFactory.java
new file mode 100644
index 00000000000..c02ccbb7e26
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionDriverFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+/** Factory for {@link MultipleComponentLeaderElectionDriver}. */
+public interface MultipleComponentLeaderElectionDriverFactory {
+
+    /**
+     * Creates a {@link MultipleComponentLeaderElectionDriver} for the given leader contender
+     * description. Moreover, it registers the given leader election listener with the service.
+     *
+     * @param leaderElectionListener listener for the callbacks of the {@link
+     *     MultipleComponentLeaderElectionDriver}
+     * @return created {@link MultipleComponentLeaderElectionDriver} instance
+     * @throws Exception if the creation fails
+     */
+    MultipleComponentLeaderElectionDriver create(
+            MultipleComponentLeaderElectionDriver.Listener leaderElectionListener) throws Exception;
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionService.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionService.java
new file mode 100644
index 00000000000..0ce739ebf3d
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/MultipleComponentLeaderElectionService.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+/**
+ * Leader election service that allows to register multiple {@link LeaderElectionEventHandler
+ * LeaderElectionEventHandlers} that are identified by different names. For each event handler it is
+ * possible to write the corresponding {@link LeaderInformation}.
+ */
+public interface MultipleComponentLeaderElectionService {
+
+    /**
+     * Closes this service.
+     *
+     * @throws Exception if the service failed to close
+     */
+    void close() throws Exception;
+
+    /**
+     * Creates a {@link LeaderElectionDriverFactory} for the given leader name.
+     *
+     * @param componentId identifying the component for which to create a leader election driver
+     *     factory
+     * @return Leader election driver factory
+     */
+    LeaderElectionDriverFactory createDriverFactory(String componentId);
+
+    /**
+     * Publishes the given leader information for the component identified by the given leader name.
+     *
+     * @param componentId identifying the component
+     * @param leaderInformation leader information
+     */
+    void publishLeaderInformation(String componentId, LeaderInformation leaderInformation);
+
+    /**
+     * Registers a new leader election event handler under the given component id.
+     *
+     * @param componentId identifying the leader election event handler
+     * @param leaderElectionEventHandler leader election event handler to register
+     * @throws IllegalArgumentException if there is already a handler registered for the given
+     *     component id
+     */
+    void registerLeaderElectionEventHandler(
+            String componentId, LeaderElectionEventHandler leaderElectionEventHandler);
+
+    /**
+     * Unregisters the leader election event handler with the given component id.
+     *
+     * @param componentId identifying the component
+     * @throws Exception if the leader election event handler could not be unregistered
+     */
+    void unregisterLeaderElectionEventHandler(String componentId) throws Exception;
+
+    /**
+     * Returns whether the given component has leadership.
+     *
+     * @param componentId identifying the component
+     * @return {@code true} if the component has leadership otherwise {@code false}
+     */
+    boolean hasLeadership(String componentId);
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionServiceTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionServiceTest.java
new file mode 100644
index 00000000000..e1f89513fd1
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultMultipleComponentLeaderElectionServiceTest.java
@@ -0,0 +1,293 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.runtime.util.TestingFatalErrorHandlerExtension;
+import org.apache.flink.util.TestLoggerExtension;
+import org.apache.flink.util.concurrent.Executors;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import javax.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/** Tests for the {@link DefaultMultipleComponentLeaderElectionService}. */
+@ExtendWith(TestLoggerExtension.class)
+class DefaultMultipleComponentLeaderElectionServiceTest {
+
+    @RegisterExtension
+    public final TestingFatalErrorHandlerExtension fatalErrorHandlerExtension =
+            new TestingFatalErrorHandlerExtension();
+
+    @Test
+    public void isLeaderInformsAllRegisteredLeaderElectionEventHandlers() throws Exception {
+        final TestingMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                TestingMultipleComponentLeaderElectionDriver.newBuilder().build();
+
+        final DefaultMultipleComponentLeaderElectionService leaderElectionService =
+                createDefaultMultiplexingLeaderElectionService(leaderElectionDriver);
+
+        try {
+            final Collection<SimpleTestingLeaderElectionEventListener> eventListeners =
+                    Stream.generate(SimpleTestingLeaderElectionEventListener::new)
+                            .limit(4)
+                            .collect(Collectors.toList());
+
+            int counter = 0;
+            for (SimpleTestingLeaderElectionEventListener eventListener : eventListeners) {
+                leaderElectionService.registerLeaderElectionEventHandler(
+                        String.valueOf(counter), eventListener);
+                counter++;
+            }
+
+            leaderElectionDriver.grantLeadership();
+
+            for (SimpleTestingLeaderElectionEventListener eventListener : eventListeners) {
+                assertThat(eventListener.hasLeadership()).isTrue();
+            }
+        } finally {
+            leaderElectionService.close();
+        }
+    }
+
+    private DefaultMultipleComponentLeaderElectionService
+            createDefaultMultiplexingLeaderElectionService(
+                    TestingMultipleComponentLeaderElectionDriver leaderElectionDriver)
+                    throws Exception {
+        return new DefaultMultipleComponentLeaderElectionService(
+                fatalErrorHandlerExtension.getTestingFatalErrorHandler(),
+                new TestingMultipleComponentLeaderElectionDriverFactory(leaderElectionDriver),
+                Executors.newDirectExecutorService());
+    }
+
+    @Test
+    public void notLeaderInformsAllRegisteredLeaderElectionEventHandlers() throws Exception {
+        final TestingMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                TestingMultipleComponentLeaderElectionDriver.newBuilder().build();
+
+        final DefaultMultipleComponentLeaderElectionService leaderElectionService =
+                createDefaultMultiplexingLeaderElectionService(leaderElectionDriver);
+
+        try {
+            final Collection<SimpleTestingLeaderElectionEventListener> eventListeners =
+                    Stream.generate(SimpleTestingLeaderElectionEventListener::new)
+                            .limit(4)
+                            .collect(Collectors.toList());
+
+            int counter = 0;
+            for (SimpleTestingLeaderElectionEventListener eventListener : eventListeners) {
+                leaderElectionService.registerLeaderElectionEventHandler(
+                        String.valueOf(counter), eventListener);
+                counter++;
+            }
+
+            leaderElectionDriver.grantLeadership();
+            leaderElectionDriver.revokeLeadership();
+
+            for (SimpleTestingLeaderElectionEventListener eventListener : eventListeners) {
+                assertThat(eventListener.hasLeadership()).isFalse();
+            }
+        } finally {
+            leaderElectionService.close();
+        }
+    }
+
+    @Test
+    public void unregisteredEventHandlersAreNotNotified() throws Exception {
+        final TestingMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                TestingMultipleComponentLeaderElectionDriver.newBuilder().build();
+
+        final DefaultMultipleComponentLeaderElectionService leaderElectionService =
+                createDefaultMultiplexingLeaderElectionService(leaderElectionDriver);
+
+        try {
+            final SimpleTestingLeaderElectionEventListener leaderElectionEventHandler =
+                    new SimpleTestingLeaderElectionEventListener();
+            final String componentId = "foobar";
+            leaderElectionService.registerLeaderElectionEventHandler(
+                    componentId, leaderElectionEventHandler);
+            leaderElectionService.unregisterLeaderElectionEventHandler(componentId);
+
+            leaderElectionDriver.grantLeadership();
+
+            assertThat(leaderElectionEventHandler.hasLeadership()).isFalse();
+        } finally {
+            leaderElectionService.close();
+        }
+    }
+
+    @Test
+    public void newlyRegisteredEventHandlersAreInformedAboutLeadership() throws Exception {
+        final TestingMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                TestingMultipleComponentLeaderElectionDriver.newBuilder().build();
+        final DefaultMultipleComponentLeaderElectionService leaderElectionService =
+                createDefaultMultiplexingLeaderElectionService(leaderElectionDriver);
+
+        try {
+            leaderElectionDriver.grantLeadership();
+
+            final SimpleTestingLeaderElectionEventListener leaderElectionEventHandler =
+                    new SimpleTestingLeaderElectionEventListener();
+            leaderElectionService.registerLeaderElectionEventHandler(
+                    "foobar", leaderElectionEventHandler);
+
+            assertThat(leaderElectionEventHandler.hasLeadership()).isTrue();
+        } finally {
+            leaderElectionService.close();
+        }
+    }
+
+    @Test
+    public void allKnownLeaderInformationCallsEventHandlers() throws Exception {
+        final TestingMultipleComponentLeaderElectionDriver leaderElectionDriver =
+                TestingMultipleComponentLeaderElectionDriver.newBuilder().build();
+        final DefaultMultipleComponentLeaderElectionService leaderElectionService =
+                createDefaultMultiplexingLeaderElectionService(leaderElectionDriver);
+
+        try {
+            leaderElectionDriver.grantLeadership();
+
+            final Collection<Component> knownLeaderInformation = createComponents(3);
+            final Collection<Component> unknownLeaderInformation = createComponents(2);
+
+            registerLeaderElectionEventHandler(leaderElectionService, knownLeaderInformation);
+            registerLeaderElectionEventHandler(leaderElectionService, unknownLeaderInformation);
+
+            leaderElectionService.notifyAllKnownLeaderInformation(
+                    knownLeaderInformation.stream()
+                            .map(
+                                    component ->
+                                            LeaderInformationWithComponentId.create(
+                                                    component.getComponentId(),
+                                                    component.getLeaderInformation()))
+                            .collect(Collectors.toList()));
+
+            for (Component component : knownLeaderInformation) {
+                assertThat(component.getLeaderElectionEventListener().getLeaderInformation())
+                        .isEqualTo(component.getLeaderInformation());
+            }
+
+            for (Component component : unknownLeaderInformation) {
+                assertThat(component.getLeaderElectionEventListener().getLeaderInformation())
+                        .isEqualTo(LeaderInformation.empty());
+            }
+
+        } finally {
+            leaderElectionService.close();
+        }
+    }
+
+    private void registerLeaderElectionEventHandler(
+            DefaultMultipleComponentLeaderElectionService leaderElectionService,
+            Collection<Component> knownLeaderInformation) {
+        for (Component component : knownLeaderInformation) {
+            leaderElectionService.registerLeaderElectionEventHandler(
+                    component.getComponentId(), component.getLeaderElectionEventListener());
+        }
+    }
+
+    private Collection<Component> createComponents(int numberComponents) {
+        final List<Component> result = new ArrayList<>();
+
+        for (int i = 0; i < numberComponents; i++) {
+            result.add(
+                    new Component(
+                            UUID.randomUUID().toString(),
+                            new SimpleTestingLeaderElectionEventListener(),
+                            LeaderInformation.known(UUID.randomUUID(), "localhost")));
+        }
+
+        return result;
+    }
+
+    private static final class Component {
+        private final String componentId;
+        private final SimpleTestingLeaderElectionEventListener leaderElectionEventListener;
+        private final LeaderInformation leaderInformation;
+
+        private Component(
+                String componentId,
+                SimpleTestingLeaderElectionEventListener leaderElectionEventListener,
+                LeaderInformation leaderInformation) {
+            this.componentId = componentId;
+            this.leaderElectionEventListener = leaderElectionEventListener;
+            this.leaderInformation = leaderInformation;
+        }
+
+        String getComponentId() {
+            return componentId;
+        }
+
+        LeaderInformation getLeaderInformation() {
+            return leaderInformation;
+        }
+
+        SimpleTestingLeaderElectionEventListener getLeaderElectionEventListener() {
+            return leaderElectionEventListener;
+        }
+    }
+
+    private static final class SimpleTestingLeaderElectionEventListener
+            implements LeaderElectionEventHandler {
+
+        private boolean hasLeadership;
+
+        @Nullable private LeaderInformation leaderInformation;
+
+        SimpleTestingLeaderElectionEventListener() {
+            hasLeadership = false;
+            leaderInformation = null;
+        }
+
+        public boolean hasLeadership() {
+            return hasLeadership;
+        }
+
+        @Override
+        public void onGrantLeadership(UUID newLeaderSessionId) {
+            hasLeadership = true;
+        }
+
+        @Override
+        public void onRevokeLeadership() {
+            hasLeadership = false;
+            leaderInformation = null;
+        }
+
+        @Override
+        public void onLeaderInformationChange(LeaderInformation leaderInformation) {
+            this.leaderInformation = leaderInformation;
+        }
+
+        @Nullable
+        LeaderInformation getLeaderInformation() {
+            return leaderInformation;
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingMultipleComponentLeaderElectionDriver.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingMultipleComponentLeaderElectionDriver.java
new file mode 100644
index 00000000000..5b937929d41
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingMultipleComponentLeaderElectionDriver.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+import org.apache.flink.util.Preconditions;
+import org.apache.flink.util.function.BiConsumerWithException;
+import org.apache.flink.util.function.ThrowingConsumer;
+
+import java.util.Optional;
+
+/** Testing implementation of {@link MultipleComponentLeaderElectionDriver}. */
+public class TestingMultipleComponentLeaderElectionDriver
+        implements MultipleComponentLeaderElectionDriver {
+
+    private final BiConsumerWithException<String, LeaderInformation, Exception>
+            publishLeaderInformationConsumer;
+    private final ThrowingConsumer<String, Exception> deleteLeaderInformationConsumer;
+    private boolean hasLeadership;
+
+    private Optional<Listener> listener;
+
+    private TestingMultipleComponentLeaderElectionDriver(
+            BiConsumerWithException<String, LeaderInformation, Exception>
+                    publishLeaderInformationConsumer,
+            ThrowingConsumer<String, Exception> deleteLeaderInformationConsumer) {
+        this.publishLeaderInformationConsumer = publishLeaderInformationConsumer;
+        this.deleteLeaderInformationConsumer = deleteLeaderInformationConsumer;
+        hasLeadership = false;
+        listener = Optional.empty();
+    }
+
+    public void grantLeadership() {
+        if (!hasLeadership) {
+            hasLeadership = true;
+            listener.ifPresent(Listener::isLeader);
+        }
+    }
+
+    public void revokeLeadership() {
+        if (hasLeadership) {
+            hasLeadership = false;
+            listener.ifPresent(Listener::notLeader);
+        }
+    }
+
+    public void setListener(Listener listener) {
+        Preconditions.checkState(!this.listener.isPresent(), "Can only set a single listener.");
+        this.listener = Optional.of(listener);
+    }
+
+    @Override
+    public void close() throws Exception {}
+
+    @Override
+    public boolean hasLeadership() {
+        return hasLeadership;
+    }
+
+    @Override
+    public void publishLeaderInformation(String componentId, LeaderInformation leaderInformation)
+            throws Exception {
+        publishLeaderInformationConsumer.accept(componentId, leaderInformation);
+    }
+
+    @Override
+    public void deleteLeaderInformation(String componentId) throws Exception {
+        deleteLeaderInformationConsumer.accept(componentId);
+    }
+
+    public static Builder newBuilder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+        private BiConsumerWithException<String, LeaderInformation, Exception>
+                publishLeaderInformationConsumer = (ignoredA, ignoredB) -> {};
+        private ThrowingConsumer<String, Exception> deleteLeaderInformationConsumer = ignored -> {};
+
+        public Builder setPublishLeaderInformationConsumer(
+                BiConsumerWithException<String, LeaderInformation, Exception>
+                        publishLeaderInformationConsumer) {
+            this.publishLeaderInformationConsumer = publishLeaderInformationConsumer;
+            return this;
+        }
+
+        public Builder setDeleteLeaderInformationConsumer(
+                ThrowingConsumer<String, Exception> deleteLeaderInformationConsumer) {
+            this.deleteLeaderInformationConsumer = deleteLeaderInformationConsumer;
+            return this;
+        }
+
+        public TestingMultipleComponentLeaderElectionDriver build() {
+            return new TestingMultipleComponentLeaderElectionDriver(
+                    publishLeaderInformationConsumer, deleteLeaderInformationConsumer);
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingMultipleComponentLeaderElectionDriverFactory.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingMultipleComponentLeaderElectionDriverFactory.java
new file mode 100644
index 00000000000..fe902e2ea0d
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingMultipleComponentLeaderElectionDriverFactory.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.leaderelection;
+
+/**
+ * Testing implementation of {@link MultipleComponentLeaderElectionDriverFactory} that returns a
+ * given {@link MultipleComponentLeaderElectionDriver}.
+ */
+public class TestingMultipleComponentLeaderElectionDriverFactory
+        implements MultipleComponentLeaderElectionDriverFactory {
+
+    final TestingMultipleComponentLeaderElectionDriver testingMultipleComponentLeaderElectionDriver;
+
+    public TestingMultipleComponentLeaderElectionDriverFactory(
+            TestingMultipleComponentLeaderElectionDriver
+                    testingMultipleComponentLeaderElectionDriver) {
+        this.testingMultipleComponentLeaderElectionDriver =
+                testingMultipleComponentLeaderElectionDriver;
+    }
+
+    @Override
+    public MultipleComponentLeaderElectionDriver create(
+            MultipleComponentLeaderElectionDriver.Listener leaderElectionListener)
+            throws Exception {
+        testingMultipleComponentLeaderElectionDriver.setListener(leaderElectionListener);
+
+        return testingMultipleComponentLeaderElectionDriver;
+    }
+}
