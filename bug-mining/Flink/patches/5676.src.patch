diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java
index a629a25c962..1b92af0d390 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java
@@ -19,7 +19,6 @@ package org.apache.flink.runtime.dispatcher;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
 import org.apache.flink.runtime.checkpoint.EmbeddedCompletedCheckpointStore;
 import org.apache.flink.runtime.checkpoint.JobManagerTaskRestore;
@@ -64,8 +63,6 @@ import static org.junit.Assert.assertTrue;
 /** An integration test for various fail-over scenarios of the {@link Dispatcher} component. */
 public class DispatcherFailoverITCase extends AbstractDispatcherTest {
 
-    private static final Time TIMEOUT = Time.seconds(1);
-
     private final BlockingQueue<RpcEndpoint> toTerminate = new LinkedBlockingQueue<>();
 
     @Before
@@ -134,18 +131,19 @@ public class DispatcherFailoverITCase extends AbstractDispatcherTest {
         final DispatcherGateway dispatcherGateway =
                 dispatcher.getSelfGateway(DispatcherGateway.class);
         dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
-        awaitStatus(dispatcherGateway, jobId, JobStatus.RUNNING);
 
         // Run vertices, checkpoint and finish.
         final JobMasterGateway jobMasterGateway =
                 connectToLeadingJobMaster(leaderElectionService).get();
         try (final JobMasterTester tester =
                 new JobMasterTester(rpcService, jobId, jobMasterGateway)) {
-            final List<TaskDeploymentDescriptor> descriptors = tester.deployVertices(2).get();
-            tester.transitionTo(descriptors, ExecutionState.INITIALIZING).get();
-            tester.transitionTo(descriptors, ExecutionState.RUNNING).get();
+            final CompletableFuture<List<TaskDeploymentDescriptor>> descriptorsFuture =
+                    tester.deployVertices(2);
+            awaitStatus(dispatcherGateway, jobId, JobStatus.RUNNING);
+            tester.transitionTo(descriptorsFuture.get(), ExecutionState.INITIALIZING).get();
+            tester.transitionTo(descriptorsFuture.get(), ExecutionState.RUNNING).get();
             tester.getCheckpointFuture(1L).get();
-            tester.transitionTo(descriptors, ExecutionState.FINISHED).get();
+            tester.transitionTo(descriptorsFuture.get(), ExecutionState.FINISHED).get();
         }
         awaitStatus(dispatcherGateway, jobId, JobStatus.FINISHED);
         jobGraphRemovalErrorReceived.await();
@@ -161,18 +159,18 @@ public class DispatcherFailoverITCase extends AbstractDispatcherTest {
         toTerminate.add(secondDispatcher);
         final DispatcherGateway secondDispatcherGateway =
                 secondDispatcher.getSelfGateway(DispatcherGateway.class);
-        UUID uuid = UUID.randomUUID();
-        leaderElectionService.isLeader(uuid);
-        awaitStatus(secondDispatcherGateway, jobId, JobStatus.RUNNING);
+        leaderElectionService.isLeader(UUID.randomUUID());
 
         // Now make sure that restored job started from checkpoint.
         final JobMasterGateway secondJobMasterGateway =
                 connectToLeadingJobMaster(leaderElectionService).get();
         try (final JobMasterTester tester =
                 new JobMasterTester(rpcService, jobId, secondJobMasterGateway)) {
-            final List<TaskDeploymentDescriptor> descriptors = tester.deployVertices(2).get();
+            final CompletableFuture<List<TaskDeploymentDescriptor>> descriptorsFuture =
+                    tester.deployVertices(2);
+            awaitStatus(secondDispatcherGateway, jobId, JobStatus.RUNNING);
             final Optional<JobManagerTaskRestore> maybeRestore =
-                    descriptors.stream()
+                    descriptorsFuture.get().stream()
                             .map(TaskDeploymentDescriptor::getTaskRestore)
                             .filter(Objects::nonNull)
                             .findAny();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java
index e59ed445053..67b1656964c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java
@@ -34,7 +34,6 @@ import org.apache.flink.runtime.jobmaster.JobMasterGateway;
 import org.apache.flink.runtime.jobmaster.JobMasterId;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.rpc.TestingRpcService;
-import org.apache.flink.runtime.scheduler.ExecutionGraphInfo;
 import org.apache.flink.runtime.state.OperatorStreamStateHandle;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
 import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;
@@ -117,8 +116,6 @@ public class JobMasterTester implements Closeable {
     private final JobMasterGateway jobMasterGateway;
     private final TaskExecutorGateway taskExecutorGateway;
 
-    private final CompletableFuture<ExecutionGraphInfo> executionGraphInfoFuture;
-
     private final CompletableFuture<List<TaskDeploymentDescriptor>> descriptorsFuture =
             new CompletableFuture<>();
 
@@ -131,7 +128,6 @@ public class JobMasterTester implements Closeable {
         this.jobId = jobId;
         this.jobMasterGateway = jobMasterGateway;
         this.taskExecutorGateway = createTaskExecutorGateway();
-        executionGraphInfoFuture = jobMasterGateway.requestJob(TIMEOUT);
     }
 
     public CompletableFuture<Acknowledge> transitionTo(
@@ -239,21 +235,23 @@ public class JobMasterTester implements Closeable {
 
     private CompletableFuture<Acknowledge> onSubmitTaskConsumer(
             TaskDeploymentDescriptor taskDeploymentDescriptor, JobMasterId jobMasterId) {
-        return executionGraphInfoFuture.thenCompose(
-                executionGraphInfo -> {
-                    final int numVertices =
-                            Iterables.size(
-                                    executionGraphInfo
-                                            .getArchivedExecutionGraph()
-                                            .getAllExecutionVertices());
-                    descriptors.put(
-                            taskDeploymentDescriptor.getExecutionAttemptId(),
-                            taskDeploymentDescriptor);
-                    if (descriptors.size() == numVertices) {
-                        descriptorsFuture.complete(new ArrayList<>(descriptors.values()));
-                    }
-                    return CompletableFuture.completedFuture(Acknowledge.get());
-                });
+        return jobMasterGateway
+                .requestJob(TIMEOUT)
+                .thenCompose(
+                        executionGraphInfo -> {
+                            final int numVertices =
+                                    Iterables.size(
+                                            executionGraphInfo
+                                                    .getArchivedExecutionGraph()
+                                                    .getAllExecutionVertices());
+                            descriptors.put(
+                                    taskDeploymentDescriptor.getExecutionAttemptId(),
+                                    taskDeploymentDescriptor);
+                            if (descriptors.size() == numVertices) {
+                                descriptorsFuture.complete(new ArrayList<>(descriptors.values()));
+                            }
+                            return CompletableFuture.completedFuture(Acknowledge.get());
+                        });
     }
 
     private CompletableFuture<Acknowledge> completeAttemptCheckpoint(
