diff --git a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/DefaultSchemaResolver.java b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/DefaultSchemaResolver.java
index 5aa6015ff62..5b008ccd960 100644
--- a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/DefaultSchemaResolver.java
+++ b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/catalog/DefaultSchemaResolver.java
@@ -222,10 +222,13 @@ class DefaultSchemaResolver implements SchemaResolver {
                             columns.stream().map(Column::getName).collect(Collectors.toList())));
         }
         final LogicalType timeFieldType = timeColumn.get().getDataType().getLogicalType();
-        if (!canBeTimeAttributeType(timeFieldType) || getPrecision(timeFieldType) != 3) {
+        if (!canBeTimeAttributeType(timeFieldType) || getPrecision(timeFieldType) > 3) {
             throw new ValidationException(
-                    "Invalid data type of time field for watermark definition. "
-                            + "The field must be of type TIMESTAMP(3) or TIMESTAMP_LTZ(3).");
+                    String.format(
+                            "Invalid data type of time field for watermark definition. "
+                                    + "The field must be of type TIMESTAMP(p) or TIMESTAMP_LTZ(p),"
+                                    + " the supported precision 'p' is from 0 to 3, but the time field type is %s",
+                            timeFieldType));
         }
         if (isProctimeAttribute(timeFieldType)) {
             throw new ValidationException(
@@ -235,10 +238,13 @@ class DefaultSchemaResolver implements SchemaResolver {
     }
 
     private void validateWatermarkExpression(LogicalType watermarkType) {
-        if (!canBeTimeAttributeType(watermarkType) || getPrecision(watermarkType) != 3) {
+        if (!canBeTimeAttributeType(watermarkType) || getPrecision(watermarkType) > 3) {
             throw new ValidationException(
-                    "Invalid data type of expression for watermark definition. "
-                            + "The field must be of type TIMESTAMP(3) or TIMESTAMP_LTZ(3).");
+                    String.format(
+                            "Invalid data type of expression for watermark definition. "
+                                    + "The field must be of type TIMESTAMP(p) or TIMESTAMP_LTZ(p),"
+                                    + " the supported precision 'p' is from 0 to 3, but the watermark expression type is %s",
+                            watermarkType));
         }
     }
 
@@ -277,7 +283,8 @@ class DefaultSchemaResolver implements SchemaResolver {
                 default:
                     throw new ValidationException(
                             "Invalid data type of expression for rowtime definition. "
-                                    + "The field must be of type TIMESTAMP(3) or TIMESTAMP_LTZ(3).");
+                                    + "The field must be of type TIMESTAMP(p) or TIMESTAMP_LTZ(p),"
+                                    + " the supported precision 'p' is from 0 to 3.");
             }
         }
         return column;
diff --git a/flink-table/flink-table-api-java/src/test/java/org/apache/flink/table/catalog/SchemaResolutionTest.java b/flink-table/flink-table-api-java/src/test/java/org/apache/flink/table/catalog/SchemaResolutionTest.java
index 0dfb68017fb..aeb5bda6a24 100644
--- a/flink-table/flink-table-api-java/src/test/java/org/apache/flink/table/catalog/SchemaResolutionTest.java
+++ b/flink-table/flink-table-api-java/src/test/java/org/apache/flink/table/catalog/SchemaResolutionTest.java
@@ -202,7 +202,8 @@ public class SchemaResolutionTest {
                         .column("ts", DataTypes.BOOLEAN())
                         .watermark("ts", callSql(WATERMARK_SQL))
                         .build(),
-                "Invalid data type of time field for watermark definition. The field must be of type TIMESTAMP(3) or TIMESTAMP_LTZ(3).");
+                "Invalid data type of time field for watermark definition."
+                        + " The field must be of type TIMESTAMP(p) or TIMESTAMP_LTZ(p), the supported precision 'p' is from 0 to 3, but the time field type is BOOLEAN");
 
         testError(
                 Schema.newBuilder()
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.xml
index f56b37b7362..beff39de083 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.xml
@@ -88,6 +88,25 @@ LogicalProject(a=[$0], b=[$1])
       <![CDATA[
 Calc(select=[a, b], where=[(b > 10)])
 +- TableSourceScan(table=[[default_catalog, default_database, VirtualTable, watermark=[-(+($2, 5000:INTERVAL SECOND), 5000:INTERVAL SECOND)], filter=[]]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testWatermarkOnCurrentRowTimestampFunction">
+    <Resource name="sql">
+      <![CDATA[SELECT * FROM timeTestTable]]>
+    </Resource>
+    <Resource name="ast">
+      <![CDATA[
+LogicalProject(a=[$0], b=[$1], rowtime=[$2])
++- LogicalWatermarkAssigner(rowtime=[rowtime], watermark=[$2])
+   +- LogicalProject(a=[$0], b=[$1], rowtime=[TO_TIMESTAMP_LTZ($1, 0)])
+      +- LogicalTableScan(table=[[default_catalog, default_database, timeTestTable]])
+]]>
+    </Resource>
+    <Resource name="optimized exec plan">
+      <![CDATA[
+Calc(select=[a, b, Reinterpret(TO_TIMESTAMP_LTZ(b, 0)) AS rowtime])
++- TableSourceScan(table=[[default_catalog, default_database, timeTestTable, watermark=[TO_TIMESTAMP_LTZ($1, 0)]]], fields=[a, b])
 ]]>
     </Resource>
   </TestCase>
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala
index c0bf232ccf1..230930fbfdc 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/api/TableEnvironmentTest.scala
@@ -1311,6 +1311,11 @@ class TableEnvironmentTest {
         |  f24 int not null,
         |  f25 varchar not null,
         |  f26 row<f0 int not null, f1 int> not null,
+        |  f27 AS LOCALTIME,
+        |  f28 AS CURRENT_TIME,
+        |  f29 AS LOCALTIMESTAMP,
+        |  f30 AS CURRENT_TIMESTAMP,
+        |  f31 AS CURRENT_ROW_TIMESTAMP(),
         |  ts AS to_timestamp(f25),
         |  PRIMARY KEY(f24, f26) NOT ENFORCED,
         |  WATERMARK FOR ts AS ts - INTERVAL '1' SECOND
@@ -1355,6 +1360,13 @@ class TableEnvironmentTest {
         Row.of("f25", "STRING", Boolean.box(false), null, null, null),
         Row.of("f26", "ROW<`f0` INT NOT NULL, `f1` INT>", Boolean.box(false),
           "PRI(f24, f26)", null, null),
+        Row.of("f27", "TIME(0)", Boolean.box(false), null, "AS LOCALTIME", null),
+        Row.of("f28", "TIME(0)", Boolean.box(false), null, "AS CURRENT_TIME", null),
+        Row.of("f29", "TIMESTAMP(3)", Boolean.box(false), null, "AS LOCALTIMESTAMP", null),
+        Row.of("f30", "TIMESTAMP_LTZ(3)", Boolean.box(false), null,
+          "AS CURRENT_TIMESTAMP", null),
+        Row.of("f31", "TIMESTAMP_LTZ(3)", Boolean.box(false), null,
+          "AS CURRENT_ROW_TIMESTAMP()", null),
         Row.of("ts", "TIMESTAMP(3) *ROWTIME*", Boolean.box(true), null, "AS TO_TIMESTAMP(`f25`)",
           "`ts` - INTERVAL '1' SECOND"))
     val tableResult1 = tableEnv.executeSql("describe T1")
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/expressions/ScalarFunctionsTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/expressions/ScalarFunctionsTest.scala
index e97ce274aec..3da9ef22676 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/expressions/ScalarFunctionsTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/expressions/ScalarFunctionsTest.scala
@@ -3035,7 +3035,6 @@ class ScalarFunctionsTest extends ScalarTypesTestBase {
       "10")
 
     // e.g: 12:13:43
-    // TODO
     testAllApis(
       localTime().cast(DataTypes.STRING).charLength(),
       "localTime().cast(STRING).charLength()",
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.scala
index 3c8994356e3..8b756f33cb2 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/stream/sql/SourceWatermarkTest.scala
@@ -119,6 +119,21 @@ class SourceWatermarkTest extends TableTestBase {
          |   'readable-metadata' = 'originTime:BIGINT'
          | )
          """.stripMargin)
+
+    util.tableEnv.executeSql(
+      s"""
+         | CREATE TABLE timeTestTable(
+         |   a INT,
+         |   b BIGINT,
+         |   rowtime AS TO_TIMESTAMP_LTZ(b, 0),
+         |   WATERMARK FOR rowtime AS rowtime
+         | ) WITH (
+         |   'connector' = 'values',
+         |   'enable-watermark-push-down' = 'true',
+         |   'bounded' = 'false',
+         |   'disable-lookup' = 'true'
+         | )
+         """.stripMargin)
   }
 
   @Test
@@ -156,6 +171,11 @@ class SourceWatermarkTest extends TableTestBase {
     util.verifyExecPlan("SELECT a, b FROM MyLtzTable")
   }
 
+  @Test
+  def testWatermarkOnCurrentRowTimestampFunction(): Unit = {
+    util.verifyExecPlan("SELECT * FROM timeTestTable")
+  }
+
   @Test
   def testProjectTransposeWatermarkAssigner(): Unit = {
     val sourceDDL =
