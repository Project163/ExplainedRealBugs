diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
index b07400cbbfb..8e7dd5d9053 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
@@ -45,7 +45,6 @@ import org.apache.flink.runtime.jobmaster.JobManagerSharedServices;
 import org.apache.flink.runtime.jobmaster.JobNotFinishedException;
 import org.apache.flink.runtime.jobmaster.TestingJobManagerRunner;
 import org.apache.flink.runtime.jobmaster.factories.JobManagerJobMetricGroupFactory;
-import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
 import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;
@@ -108,8 +107,6 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 
 	private Configuration configuration;
 
-	private TestingLeaderElectionService dispatcherLeaderElectionService;
-
 	private SingleRunningJobsRegistry runningJobsRegistry;
 
 	private TestingHighAvailabilityServices highAvailabilityServices;
@@ -150,12 +147,10 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 		configuration.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath());
 
 		highAvailabilityServices = new TestingHighAvailabilityServices();
-		dispatcherLeaderElectionService = new TestingLeaderElectionService();
-		highAvailabilityServices.setDispatcherLeaderElectionService(dispatcherLeaderElectionService);
 		clearedJobLatch = new OneShotLatch();
 		runningJobsRegistry = new SingleRunningJobsRegistry(jobId, clearedJobLatch);
 		highAvailabilityServices.setRunningJobsRegistry(runningJobsRegistry);
-		jobGraphStore = TestingJobGraphStore.newBuilder().build();
+		jobGraphStore = TestingJobGraphStore.newBuilder().withAutomaticStart().build();
 		highAvailabilityServices.setJobGraphStore(jobGraphStore);
 
 		storedHABlobFuture = new CompletableFuture<>();
@@ -217,8 +212,6 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 		dispatcher.start();
 
 		dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
-
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
 	}
 
 	@After
@@ -409,28 +402,24 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 	}
 
 	/**
-	 * Tests that recovered jobs will only be started after the complete termination of any
-	 * other previously running JobMasters for the same job.
+	 * Tests that terminating the Dispatcher will wait for all JobMasters to be terminated.
 	 */
 	@Test
-	public void testJobRecoveryWithPendingTermination() throws Exception {
+	public void testDispatcherTerminationWaitsForJobMasterTerminations() throws Exception {
 		final TestingJobManagerRunnerFactory jobManagerRunnerFactory = startDispatcherAndSubmitJob(1);
-		runningJobsRegistry.setJobRunning(jobId);
 
-		dispatcherLeaderElectionService.notLeader();
-		final UUID leaderSessionId = UUID.randomUUID();
-		final CompletableFuture<UUID> leaderFuture = dispatcherLeaderElectionService.isLeader(leaderSessionId);
+		final CompletableFuture<Void> dispatcherTerminationFuture = dispatcher.closeAsync();
 
 		try {
-			leaderFuture.get(10L, TimeUnit.MILLISECONDS);
-			fail("We should not become leader before all previously running JobMasters have terminated.");
+			dispatcherTerminationFuture.get(10L, TimeUnit.MILLISECONDS);
+			fail("We should not terminate before all running JobMasters have terminated.");
 		} catch (TimeoutException ignored) {
 			// expected
 		} finally {
 			jobManagerRunnerFactory.takeCreatedJobManagerRunner().completeTerminationFuture();
 		}
 
-		assertThat(leaderFuture.get(), equalTo(leaderSessionId));
+		dispatcherTerminationFuture.get();
 	}
 
 	private static final class SingleRunningJobsRegistry implements RunningJobsRegistry {
@@ -494,6 +483,7 @@ public class DispatcherResourceCleanupTest extends TestLogger {
 				ignored -> {
 					throw new Exception("Failed to Remove future");
 				})
+			.withAutomaticStart()
 			.build();
 
 		highAvailabilityServices.setJobGraphStore(jobGraphStore);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java
index 0376d448546..1e3232c0f95 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.testutils;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.function.BiFunctionWithException;
 import org.apache.flink.util.function.FunctionWithException;
@@ -153,6 +154,8 @@ public class TestingJobGraphStore implements JobGraphStore {
 
 		private Collection<JobGraph> initialJobGraphs = Collections.emptyList();
 
+		private boolean startJobGraphStore = false;
+
 		private Builder() {}
 
 		public Builder setStartConsumer(ThrowingConsumer<JobGraphListener, ? extends Exception> startConsumer) {
@@ -195,8 +198,13 @@ public class TestingJobGraphStore implements JobGraphStore {
 			return this;
 		}
 
+		public Builder withAutomaticStart() {
+			this.startJobGraphStore = true;
+			return this;
+		}
+
 		public TestingJobGraphStore build() {
-			return new TestingJobGraphStore(
+			final TestingJobGraphStore jobGraphStore = new TestingJobGraphStore(
 				startConsumer,
 				stopRunnable,
 				jobIdsFunction,
@@ -205,6 +213,16 @@ public class TestingJobGraphStore implements JobGraphStore {
 				removeJobGraphConsumer,
 				releaseJobGraphConsumer,
 				initialJobGraphs);
+
+			if (startJobGraphStore) {
+				try {
+					jobGraphStore.start(null);
+				} catch (Exception e) {
+					ExceptionUtils.rethrow(e);
+				}
+			}
+
+			return jobGraphStore;
 		}
 	}
 
