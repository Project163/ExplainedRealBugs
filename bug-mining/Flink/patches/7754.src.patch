diff --git a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/adaptive/AdaptiveSkewedJoinITCase.scala b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/adaptive/AdaptiveSkewedJoinITCase.scala
index 9b1bd4d0785..6ff56242e26 100644
--- a/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/adaptive/AdaptiveSkewedJoinITCase.scala
+++ b/flink-table/flink-table-planner/src/test/scala/org/apache/flink/table/planner/runtime/batch/sql/adaptive/AdaptiveSkewedJoinITCase.scala
@@ -87,6 +87,13 @@ class AdaptiveSkewedJoinITCase extends AdaptiveJoinITCase {
     checkResult(sql)
   }
 
+  @Test
+  def testJoinWithHashOutput(): Unit = {
+    val sql =
+      "SELECT * FROM (SELECT * FROM T1, T2 WHERE T1.a1 = T2.a2) as T4 LEFT JOIN T3 ON T3.b3 = T4.b1"
+    checkResult(sql)
+  }
+
   override def checkResult(sql: String): Unit = {
     tEnv.getConfig
       .set(
diff --git a/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/strategy/AdaptiveSkewedJoinOptimizationStrategy.java b/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/strategy/AdaptiveSkewedJoinOptimizationStrategy.java
index ea0420c50f8..d8373a98e44 100644
--- a/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/strategy/AdaptiveSkewedJoinOptimizationStrategy.java
+++ b/flink-table/flink-table-runtime/src/main/java/org/apache/flink/table/runtime/strategy/AdaptiveSkewedJoinOptimizationStrategy.java
@@ -27,11 +27,19 @@ import org.apache.flink.streaming.api.graph.StreamGraphContext;
 import org.apache.flink.streaming.api.graph.util.ImmutableStreamEdge;
 import org.apache.flink.streaming.api.graph.util.ImmutableStreamNode;
 import org.apache.flink.streaming.api.graph.util.StreamEdgeUpdateRequestInfo;
+import org.apache.flink.streaming.runtime.partitioner.BroadcastPartitioner;
+import org.apache.flink.streaming.runtime.partitioner.CustomPartitionerWrapper;
 import org.apache.flink.streaming.runtime.partitioner.ForwardForConsecutiveHashPartitioner;
+import org.apache.flink.streaming.runtime.partitioner.GlobalPartitioner;
+import org.apache.flink.streaming.runtime.partitioner.KeyGroupStreamPartitioner;
+import org.apache.flink.streaming.runtime.partitioner.RebalancePartitioner;
+import org.apache.flink.streaming.runtime.partitioner.ShufflePartitioner;
 import org.apache.flink.streaming.runtime.partitioner.StreamPartitioner;
 import org.apache.flink.table.api.config.OptimizerConfigOptions;
 import org.apache.flink.table.runtime.operators.join.FlinkJoinType;
 import org.apache.flink.table.runtime.operators.join.adaptive.AdaptiveJoin;
+import org.apache.flink.table.runtime.partitioner.BinaryHashPartitioner;
+import org.apache.flink.table.runtime.partitioner.RowDataCustomStreamPartitioner;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -40,6 +48,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import static org.apache.flink.runtime.scheduler.adaptivebatch.util.VertexParallelismAndInputInfosDeciderUtils.computeSkewThreshold;
 import static org.apache.flink.runtime.scheduler.adaptivebatch.util.VertexParallelismAndInputInfosDeciderUtils.median;
@@ -57,6 +66,25 @@ public class AdaptiveSkewedJoinOptimizationStrategy
     private static final int LEFT_INPUT_TYPE_NUMBER = 1;
     private static final int RIGHT_INPUT_TYPE_NUMBER = 2;
 
+    /** Set of partitioners that can automatically correct key group. */
+    private static final Set<Class<?>> partitionersCanCorrectKeyGroupAutomatic =
+            Set.of(
+                    BinaryHashPartitioner.class,
+                    BroadcastPartitioner.class,
+                    CustomPartitionerWrapper.class,
+                    GlobalPartitioner.class,
+                    KeyGroupStreamPartitioner.class,
+                    RebalancePartitioner.class,
+                    RowDataCustomStreamPartitioner.class,
+                    ShufflePartitioner.class);
+
+    /**
+     * Set of partitioners that can force key group correction but may introduce additional shuffle
+     * overhead.
+     */
+    private static final Set<Class<?>> partitionersCanCorrectKeyGroupForced =
+            Set.of(ForwardForConsecutiveHashPartitioner.class);
+
     private Map<Integer, Map<Integer, long[]>> aggregatedProducedBytesByTypeNumberAndNodeId;
 
     private OptimizerConfigOptions.AdaptiveSkewedJoinOptimizationStrategy
@@ -98,7 +126,7 @@ public class AdaptiveSkewedJoinOptimizationStrategy
             ImmutableStreamNode adaptiveJoinNode,
             List<ImmutableStreamEdge> upstreamStreamEdges,
             AdaptiveJoin adaptiveJoin) {
-        if (!canPerformOptimization(adaptiveJoinNode)) {
+        if (!canPerformOptimization(context, adaptiveJoinNode)) {
             return;
         }
         for (ImmutableStreamEdge edge : upstreamStreamEdges) {
@@ -116,7 +144,8 @@ public class AdaptiveSkewedJoinOptimizationStrategy
         }
     }
 
-    private boolean canPerformOptimization(ImmutableStreamNode adaptiveJoinNode) {
+    private boolean canPerformOptimization(
+            StreamGraphContext context, ImmutableStreamNode adaptiveJoinNode) {
         // For broadcast joins, especially those generated by
         // AdaptiveBroadcastJoinOptimizationStrategy, skip perform optimization to
         // avoid unexpected problems.
@@ -125,10 +154,10 @@ public class AdaptiveSkewedJoinOptimizationStrategy
         }
         if (adaptiveSkewedJoinOptimizationStrategy
                 == OptimizerConfigOptions.AdaptiveSkewedJoinOptimizationStrategy.AUTO) {
-            return canPerformOptimizationAutomatic(adaptiveJoinNode);
+            return canPerformOptimizationAutomatic(context, adaptiveJoinNode);
         } else if (adaptiveSkewedJoinOptimizationStrategy
                 == OptimizerConfigOptions.AdaptiveSkewedJoinOptimizationStrategy.FORCED) {
-            return canPerformOptimizationForced(adaptiveJoinNode);
+            return canPerformOptimizationForced(context, adaptiveJoinNode);
         } else {
             return false;
         }
@@ -300,23 +329,41 @@ public class AdaptiveSkewedJoinOptimizationStrategy
         return false;
     }
 
-    private static boolean canPerformOptimizationAutomatic(ImmutableStreamNode adaptiveJoinNode) {
-        // In AUTO mode, we need to ensure that there are no intra-correlated out edge to ensure the
-        // application of this optimization wouldn't break data correctness or introduce additional
-        // performance overhead.
+    private static boolean canPerformOptimizationAutomatic(
+            StreamGraphContext context, ImmutableStreamNode adaptiveJoinNode) {
         return adaptiveJoinNode.getOutEdges().stream()
-                .noneMatch(ImmutableStreamEdge::isIntraInputKeyCorrelated);
+                .allMatch(
+                        edge -> {
+                            Class<?> classOfOutputPartitioner =
+                                    checkNotNull(
+                                                    context.getOutputPartitioner(
+                                                            edge.getEdgeId(),
+                                                            edge.getSourceId(),
+                                                            edge.getTargetId()))
+                                            .getClass();
+                            return !edge.isIntraInputKeyCorrelated()
+                                    || partitionersCanCorrectKeyGroupAutomatic.contains(
+                                            classOfOutputPartitioner);
+                        });
     }
 
-    private static boolean canPerformOptimizationForced(ImmutableStreamNode adaptiveJoinNode) {
-        // In FORCED mode, if there is an intra-correlated out edge, and the type of it is
-        // ForwardForConsecutiveHash, we can modify its partitioner to HashPartitioner to ensure
-        // the data correctness after the optimization applied. Otherwise, this optimization is not
-        // allowed.
+    private static boolean canPerformOptimizationForced(
+            StreamGraphContext context, ImmutableStreamNode adaptiveJoinNode) {
         return adaptiveJoinNode.getOutEdges().stream()
-                .noneMatch(
-                        edge ->
-                                edge.isIntraInputKeyCorrelated()
-                                        && !edge.isForwardForConsecutiveHashEdge());
+                .allMatch(
+                        edge -> {
+                            Class<?> classOfOutputPartitioner =
+                                    checkNotNull(
+                                                    context.getOutputPartitioner(
+                                                            edge.getEdgeId(),
+                                                            edge.getSourceId(),
+                                                            edge.getTargetId()))
+                                            .getClass();
+                            return !edge.isIntraInputKeyCorrelated()
+                                    || partitionersCanCorrectKeyGroupAutomatic.contains(
+                                            classOfOutputPartitioner)
+                                    || partitionersCanCorrectKeyGroupForced.contains(
+                                            classOfOutputPartitioner);
+                        });
     }
 }
