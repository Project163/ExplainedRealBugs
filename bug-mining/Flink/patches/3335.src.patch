diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index c38ef28e6f5..4b5b4f8806d 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -99,7 +99,7 @@ import java.util.stream.Collectors;
  * about the state of the Flink session cluster.
  */
 public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId> implements
-	DispatcherGateway, LeaderContender, JobGraphStore.JobGraphListener {
+	DispatcherGateway, LeaderContender {
 
 	public static final String DISPATCHER_NAME = "dispatcher";
 
@@ -201,7 +201,6 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId> impleme
 
 	private void startDispatcherServices() throws Exception {
 		try {
-			jobGraphStore.start(this);
 			leaderElectionService.start(this);
 
 			registerDispatcherMetrics(jobManagerMetricGroup);
@@ -243,12 +242,6 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId> impleme
 			exception = ExceptionUtils.firstOrSuppressed(e, exception);
 		}
 
-		try {
-			jobGraphStore.stop();
-		} catch (Exception e) {
-			exception = ExceptionUtils.firstOrSuppressed(e, exception);
-		}
-
 		try {
 			leaderElectionService.stop();
 		} catch (Exception e) {
@@ -1009,78 +1002,4 @@ public abstract class Dispatcher extends FencedRpcEndpoint<DispatcherId> impleme
 	public void handleError(final Exception exception) {
 		onFatalError(new DispatcherException("Received an error from the LeaderElectionService.", exception));
 	}
-
-	//------------------------------------------------------
-	// JobGraphListener
-	//------------------------------------------------------
-
-	@Override
-	public void onAddedJobGraph(final JobID jobId) {
-		runAsync(
-			() -> {
-				if (!jobManagerRunnerFutures.containsKey(jobId)) {
-					// IMPORTANT: onAddedJobGraph can generate false positives and, thus, we must expect that
-					// the specified job is already removed from the JobGraphStore. In this case,
-					// JobGraphStore.recoverJob returns null.
-					final CompletableFuture<Optional<JobGraph>> recoveredJob = recoveryOperation.thenApplyAsync(
-						FunctionUtils.uncheckedFunction(ignored -> Optional.ofNullable(recoverJob(jobId))),
-						getRpcService().getExecutor());
-
-					final DispatcherId dispatcherId = getFencingToken();
-					final CompletableFuture<Void> submissionFuture = recoveredJob.thenComposeAsync(
-						(Optional<JobGraph> jobGraphOptional) -> jobGraphOptional.map(
-							FunctionUtils.uncheckedFunction(jobGraph -> tryRunRecoveredJobGraph(jobGraph, dispatcherId).thenAcceptAsync(
-								FunctionUtils.uncheckedConsumer((Boolean isRecoveredJobRunning) -> {
-										if (!isRecoveredJobRunning) {
-											jobGraphStore.releaseJobGraph(jobId);
-										}
-									}),
-									getRpcService().getExecutor())))
-							.orElse(CompletableFuture.completedFuture(null)),
-						getUnfencedMainThreadExecutor());
-
-					submissionFuture.whenComplete(
-						(Void ignored, Throwable throwable) -> {
-							if (throwable != null) {
-								onFatalError(
-									new DispatcherException(
-										String.format("Could not start the added job %s", jobId),
-										ExceptionUtils.stripCompletionException(throwable)));
-							}
-						});
-
-					recoveryOperation = submissionFuture;
-				}
-			});
-	}
-
-	private CompletableFuture<Boolean> tryRunRecoveredJobGraph(JobGraph jobGraph, DispatcherId dispatcherId) throws Exception {
-		if (leaderElectionService.hasLeadership(dispatcherId.toUUID())) {
-			final JobID jobId = jobGraph.getJobID();
-			if (jobManagerRunnerFutures.containsKey(jobId)) {
-				// we must not release the job graph lock since it can only be locked once and
-				// is currently being executed. Once we support multiple locks, we must release
-				// the JobGraph here
-				log.debug("Ignore added JobGraph because the job {} is already running.", jobId);
-				return CompletableFuture.completedFuture(true);
-			} else if (runningJobsRegistry.getJobSchedulingStatus(jobId) != RunningJobsRegistry.JobSchedulingStatus.DONE) {
-				return waitForTerminatingJobManager(jobId, jobGraph, this::runJob).thenApply(ignored -> true);
-			} else {
-				log.debug("Ignore added JobGraph because the job {} has already been completed.", jobId);
-			}
-		}
-
-		return CompletableFuture.completedFuture(false);
-	}
-
-	@Override
-	public void onRemovedJobGraph(final JobID jobId) {
-		runAsync(() -> {
-			try {
-				removeJobAndRegisterTerminationFuture(jobId, false);
-			} catch (final Exception e) {
-				onFatalError(new DispatcherException(String.format("Could not remove job %s.", jobId), e));
-			}
-		});
-	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
index b079ab141c0..2791f1851ef 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
@@ -277,6 +277,11 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private void handleAddedJobGraph(JobID jobId) {
+		LOG.debug(
+			"Job {} has been added to the {} by another process.",
+			jobId,
+			jobGraphStore.getClass().getSimpleName());
+
 		// serialize all ongoing recovery operations
 		onGoingRecoveryOperation = onGoingRecoveryOperation
 			.thenApplyAsync(
@@ -317,6 +322,11 @@ public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, Job
 	}
 
 	private void handleRemovedJobGraph(JobID jobId) {
+		LOG.debug(
+			"Job {} has been removed from the {} by another process.",
+			jobId,
+			jobGraphStore.getClass().getSimpleName());
+
 		onGoingRecoveryOperation = onGoingRecoveryOperation
 			.thenCompose(ignored -> removeJobGraphIfRunning(jobId).orElse(FutureUtils.completedVoidFuture()))
 			.handle(this::onErrorIfRunning);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
index 46620142f15..bdb3b012913 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
@@ -332,82 +332,6 @@ public class DispatcherTest extends TestLogger {
 		jobIdsFuture.get(TIMEOUT.toMilliseconds(), TimeUnit.MILLISECONDS);
 	}
 
-	/**
-	 * Test callbacks from
-	 * {@link JobGraphStore.JobGraphListener}.
-	 */
-	@Test
-	public void testSubmittedJobGraphListener() throws Exception {
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
-
-		dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
-		jobMasterLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		final JobGraph jobGraph = jobGraphStore.recoverJobGraph(TEST_JOB_ID);
-
-		// pretend that other Dispatcher has removed job from submittedJobGraphStore
-		jobGraphStore.removeJobGraph(TEST_JOB_ID);
-		dispatcher.onRemovedJobGraph(TEST_JOB_ID);
-		assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), empty());
-
-		// pretend that other Dispatcher has added a job to submittedJobGraphStore
-		runningJobsRegistry.clearJob(TEST_JOB_ID);
-		jobGraphStore.putJobGraph(jobGraph);
-		dispatcher.onAddedJobGraph(TEST_JOB_ID);
-		createdJobManagerRunnerLatch.await();
-		assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), hasSize(1));
-	}
-
-	@Test
-	public void testOnAddedJobGraphRecoveryFailure() throws Exception {
-		final FlinkException expectedFailure = new FlinkException("Expected failure");
-		final JobGraphStore jobGraphStore = TestingJobGraphStore.newBuilder()
-			.setRecoverJobGraphFunction(
-				(ignoredA, ignoredB) -> {
-					throw expectedFailure;
-				})
-			.build();
-
-		haServices.setJobGraphStore(jobGraphStore);
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		jobGraphStore.putJobGraph(jobGraph);
-		dispatcher.onAddedJobGraph(TEST_JOB_ID);
-
-		final CompletableFuture<Throwable> errorFuture = fatalErrorHandler.getErrorFuture();
-
-		final Throwable throwable = errorFuture.get();
-
-		assertThat(ExceptionUtils.findThrowable(throwable, expectedFailure::equals).isPresent(), is(true));
-
-		fatalErrorHandler.clearError();
-	}
-
-	@Test
-	public void testOnAddedJobGraphWithFinishedJob() throws Throwable {
-		dispatcher = createAndStartDispatcher(heartbeatServices, haServices, new ExpectedJobIdJobManagerRunnerFactory(TEST_JOB_ID, createdJobManagerRunnerLatch));
-
-		dispatcherLeaderElectionService.isLeader(UUID.randomUUID()).get();
-
-		jobGraphStore.putJobGraph(jobGraph);
-		runningJobsRegistry.setJobFinished(TEST_JOB_ID);
-		dispatcher.onAddedJobGraph(TEST_JOB_ID);
-
-		// wait until the recovery is over
-		dispatcher.getRecoverOperationFuture(TIMEOUT).get();
-
-		final DispatcherGateway dispatcherGateway = dispatcher.getSelfGateway(DispatcherGateway.class);
-
-		// check that we did not start executing the added JobGraph
-		assertThat(dispatcherGateway.listJobs(TIMEOUT).get(), is(empty()));
-	}
-
 	/**
 	 * Test that {@link JobResult} is cached when the job finishes.
 	 */
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
index 02ad01041b1..61d2099d363 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
@@ -18,20 +18,27 @@
 
 package org.apache.flink.runtime.dispatcher.runner;
 
+import org.apache.flink.api.common.JobID;
 import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.testutils.TestingJobGraphStore;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;
 import org.apache.flink.runtime.webmonitor.TestingDispatcherGateway;
+import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.ExecutorUtils;
+import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
 import org.apache.flink.util.function.BiFunctionWithException;
 
+import org.hamcrest.core.Is;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.util.Collection;
@@ -54,7 +61,7 @@ import static org.junit.Assert.fail;
  */
 public class DispatcherLeaderProcessImplTest extends TestLogger {
 
-	private static final JobGraph PERSISTED_JOB_GRAPH = new JobGraph("Persisted JobGraph");
+	private static final JobGraph JOB_GRAPH = new JobGraph("JobGraph");
 
 	private static ExecutorService ioExecutor;
 
@@ -106,7 +113,7 @@ public class DispatcherLeaderProcessImplTest extends TestLogger {
 	@Test
 	public void start_triggersJobGraphRecoveryAndDispatcherServiceCreation() throws Exception {
 		jobGraphStore = TestingJobGraphStore.newBuilder()
-			.setInitialJobGraphs(Collections.singleton(PERSISTED_JOB_GRAPH))
+			.setInitialJobGraphs(Collections.singleton(JOB_GRAPH))
 			.build();
 
 		final CompletableFuture<Collection<JobGraph>> recoveredJobGraphsFuture = new CompletableFuture<>();
@@ -126,7 +133,7 @@ public class DispatcherLeaderProcessImplTest extends TestLogger {
 			final Collection<JobGraph> recoveredJobGraphs = recoveredJobGraphsFuture.get();
 
 			assertThat(recoveredJobGraphs, hasSize(1));
-			assertThat(recoveredJobGraphs, containsInAnyOrder(PERSISTED_JOB_GRAPH));
+			assertThat(recoveredJobGraphs, containsInAnyOrder(JOB_GRAPH));
 		}
 	}
 
@@ -239,6 +246,109 @@ public class DispatcherLeaderProcessImplTest extends TestLogger {
 		}
 	}
 
+	@Test
+	public void onRemovedJobGraph_cancelsRunningJob() throws Exception {
+		jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setInitialJobGraphs(Collections.singleton(JOB_GRAPH))
+			.build();
+
+		final CompletableFuture<JobID> cancelJobFuture = new CompletableFuture<>();
+		final TestingDispatcherGateway testingDispatcherGateway = new TestingDispatcherGateway.Builder()
+			.setCancelJobFunction(
+				jobToCancel -> {
+					cancelJobFuture.complete(jobToCancel);
+					return CompletableFuture.completedFuture(Acknowledge.get());
+				})
+			.build();
+
+		dispatcherServiceFactory = createDispatcherServiceFactoryFor(testingDispatcherGateway);
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+
+			// wait for the dispatcher process to be created
+			dispatcherLeaderProcess.getDispatcherGateway().get();
+
+			// now remove the Job from the JobGraphStore and notify the dispatcher service
+			jobGraphStore.removeJobGraph(JOB_GRAPH.getJobID());
+			dispatcherLeaderProcess.onRemovedJobGraph(JOB_GRAPH.getJobID());
+
+			assertThat(cancelJobFuture.get(), is(JOB_GRAPH.getJobID()));
+		}
+	}
+
+	@Test
+	public void onAddedJobGraph_submitsRecoveredJob() throws Exception {
+		final CompletableFuture<JobGraph> submittedJobFuture = new CompletableFuture<>();
+		final TestingDispatcherGateway testingDispatcherGateway = new TestingDispatcherGateway.Builder()
+			.setSubmitFunction(
+				submittedJob -> {
+					submittedJobFuture.complete(submittedJob);
+					return CompletableFuture.completedFuture(Acknowledge.get());
+				})
+			.build();
+
+		dispatcherServiceFactory = createDispatcherServiceFactoryFor(testingDispatcherGateway);
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+
+			// wait first for the dispatcher service to be created
+			dispatcherLeaderProcess.getDispatcherGateway().get();
+
+			jobGraphStore.putJobGraph(JOB_GRAPH);
+			dispatcherLeaderProcess.onAddedJobGraph(JOB_GRAPH.getJobID());
+
+			final JobGraph submittedJobGraph = submittedJobFuture.get();
+
+			assertThat(submittedJobGraph.getJobID(), is(JOB_GRAPH.getJobID()));
+		}
+	}
+
+	@Test
+	public void onAddedJobGraph_failingRecovery_propagatesTheFailure() throws Exception {
+		final FlinkException expectedFailure = new FlinkException("Expected failure");
+		jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setRecoverJobGraphFunction(
+				(ignoredA, ignoredB) -> {
+					throw expectedFailure;
+				})
+			.build();
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+
+			// wait first for the dispatcher service to be created
+			dispatcherLeaderProcess.getDispatcherGateway().get();
+
+			jobGraphStore.putJobGraph(JOB_GRAPH);
+			dispatcherLeaderProcess.onAddedJobGraph(JOB_GRAPH.getJobID());
+
+			final CompletableFuture<Throwable> errorFuture = fatalErrorHandler.getErrorFuture();
+			final Throwable throwable = errorFuture.get();
+			Assert.assertThat(ExceptionUtils.findThrowable(throwable, expectedFailure::equals).isPresent(), Is.is(true));
+
+			assertThat(dispatcherLeaderProcess.getState(), is(DispatcherLeaderProcessImpl.State.STOPPED));
+
+			fatalErrorHandler.clearError();
+		}
+	}
+
+	@Test
+	@Ignore
+	public void onAddedJobGraph_falsePositive_willBeIgnored() {
+		fail("Needs to be implemented once the proper deduplication mechanism is in place.");
+	}
+
+	private TestingDispatcherServiceFactory createDispatcherServiceFactoryFor(TestingDispatcherGateway testingDispatcherGateway) {
+		return TestingDispatcherServiceFactory.newBuilder()
+			.setCreateFunction(
+				(ignoredA, ignoredB) -> TestingDispatcherService.newBuilder()
+					.setDispatcherGateway(testingDispatcherGateway)
+					.build())
+			.build();
+	}
+
 	private DispatcherLeaderProcessImpl createDispatcherLeaderProcess() {
 		return DispatcherLeaderProcessImpl.create(
 			leaderSessionId,
