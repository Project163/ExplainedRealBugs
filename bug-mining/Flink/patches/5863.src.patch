diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
index 5afeac7ca13..cf98fb04baf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/AbstractInvokable.java
@@ -27,6 +27,7 @@ import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.execution.Environment;
 import org.apache.flink.runtime.jobgraph.OperatorID;
 import org.apache.flink.runtime.operators.coordination.OperatorEvent;
+import org.apache.flink.runtime.taskmanager.Task;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.SerializedValue;
 
@@ -82,8 +83,13 @@ public abstract class AbstractInvokable
     public void cleanUp(@Nullable Throwable throwable) throws Exception {}
 
     @Override
-    public boolean shouldInterruptOnCancel() {
-        return true;
+    public void maybeInterruptOnCancel(
+            Thread toInterrupt, @Nullable String taskName, @Nullable Long timeout) {
+        if (taskName != null && timeout != null) {
+            Task.logTaskThreadStackTrace(toInterrupt, taskName, timeout, "interrupting");
+        }
+
+        toInterrupt.interrupt();
     }
 
     // ------------------------------------------------------------------------
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java
index 17d0ffee402..95f60140c7c 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobgraph/tasks/TaskInvokable.java
@@ -95,9 +95,13 @@ public interface TaskInvokable {
     boolean isUsingNonBlockingInput();
 
     /**
-     * Checks whether the task should be interrupted during cancellation. This method is check both
-     * for the initial interrupt, as well as for the repeated interrupt. If this method returns true
-     * then no further interrupts will happen.
+     * Checks whether the task should be interrupted during cancellation and if so, execute the
+     * specified {@code Runnable interruptAction}.
+     *
+     * @param toInterrupt
+     * @param taskName optional taskName to log stack trace
+     * @param timeout optional timeout to log stack trace
      */
-    boolean shouldInterruptOnCancel();
+    void maybeInterruptOnCancel(
+            Thread toInterrupt, @Nullable String taskName, @Nullable Long timeout);
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
index 76f00840672..f24988c87b5 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
@@ -1226,27 +1226,25 @@ public class Task
                         // the periodic interrupting thread - a different thread than the canceller,
                         // in case
                         // the application code does blocking stuff in its cancellation paths.
-                        if (invokable.shouldInterruptOnCancel()) {
-                            Runnable interrupter =
-                                    new TaskInterrupter(
-                                            LOG,
-                                            invokable,
-                                            executingThread,
-                                            taskNameWithSubtask,
-                                            taskCancellationInterval);
+                        Runnable interrupter =
+                                new TaskInterrupter(
+                                        LOG,
+                                        invokable,
+                                        executingThread,
+                                        taskNameWithSubtask,
+                                        taskCancellationInterval);
 
-                            Thread interruptingThread =
-                                    new Thread(
-                                            executingThread.getThreadGroup(),
-                                            interrupter,
-                                            String.format(
-                                                    "Canceler/Interrupts for %s (%s).",
-                                                    taskNameWithSubtask, executionId));
-                            interruptingThread.setDaemon(true);
-                            interruptingThread.setUncaughtExceptionHandler(
-                                    FatalExitExceptionHandler.INSTANCE);
-                            interruptingThread.start();
-                        }
+                        Thread interruptingThread =
+                                new Thread(
+                                        executingThread.getThreadGroup(),
+                                        interrupter,
+                                        String.format(
+                                                "Canceler/Interrupts for %s (%s).",
+                                                taskNameWithSubtask, executionId));
+                        interruptingThread.setDaemon(true);
+                        interruptingThread.setUncaughtExceptionHandler(
+                                FatalExitExceptionHandler.INSTANCE);
+                        interruptingThread.start();
 
                         // if a cancellation timeout is set, the watchdog thread kills the process
                         // if graceful cancellation does not succeed
@@ -1646,9 +1644,7 @@ public class Task
                     Future<Void> cancellationFuture = invokable.cancel();
                     // Wait for any active actions to complete (e.g. timers, mailbox actions)
                     // Before that, interrupt to notify them about cancellation
-                    if (invokable.shouldInterruptOnCancel()) {
-                        executer.interrupt();
-                    }
+                    invokable.maybeInterruptOnCancel(executer, null, null);
                     try {
                         cancellationFuture.get(taskCancellationTimeout, TimeUnit.MILLISECONDS);
                     } catch (ExecutionException | TimeoutException | InterruptedException e) {
@@ -1719,11 +1715,8 @@ public class Task
 
                 // log stack trace where the executing thread is stuck and
                 // interrupt the running thread periodically while it is still alive
-                while (task.shouldInterruptOnCancel() && executerThread.isAlive()) {
-                    logTaskThreadStackTrace(
-                            executerThread, taskName, interruptIntervalMillis, "interrupting");
-
-                    executerThread.interrupt();
+                while (executerThread.isAlive()) {
+                    task.maybeInterruptOnCancel(executerThread, taskName, interruptIntervalMillis);
                     try {
                         executerThread.join(interruptIntervalMillis);
                     } catch (InterruptedException e) {
@@ -1803,7 +1796,7 @@ public class Task
         }
     }
 
-    private static void logTaskThreadStackTrace(
+    public static void logTaskThreadStackTrace(
             Thread thread, String taskName, long timeoutMs, String action) {
         StackTraceElement[] stack = thread.getStackTrace();
         StringBuilder stackTraceStr = new StringBuilder();
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index 0e58538fe01..2872bee80e9 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -66,6 +66,7 @@ import org.apache.flink.runtime.state.StateBackend;
 import org.apache.flink.runtime.state.StateBackendLoader;
 import org.apache.flink.runtime.state.ttl.TtlTimeProvider;
 import org.apache.flink.runtime.taskmanager.DispatcherThreadFactory;
+import org.apache.flink.runtime.taskmanager.Task;
 import org.apache.flink.runtime.throughput.ThroughputCalculator;
 import org.apache.flink.streaming.api.TimeCharacteristic;
 import org.apache.flink.streaming.api.environment.ExecutionCheckpointingOptions;
@@ -112,6 +113,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -296,7 +298,10 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
 
     private final Environment environment;
 
-    private volatile boolean shouldInterruptOnCancel = true;
+    private final Object shouldInterruptOnCancelLock = new Object();
+
+    @GuardedBy("shouldInterruptOnCancelLock")
+    private boolean shouldInterruptOnCancel = true;
 
     // ------------------------------------------------------------------------
 
@@ -902,7 +907,7 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
         // that block and stall shutdown.
         // Additionally, the cancellation watch dog will issue a hard-cancel (kill the TaskManager
         // process) as a backup in case some shutdown procedure blocks outside our control.
-        shouldInterruptOnCancel = false;
+        disableInterruptOnCancel();
 
         // clear any previously issued interrupt for a more graceful shutdown
         Thread.interrupted();
@@ -1747,9 +1752,24 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
         return true;
     }
 
+    private void disableInterruptOnCancel() {
+        synchronized (shouldInterruptOnCancelLock) {
+            shouldInterruptOnCancel = false;
+        }
+    }
+
     @Override
-    public boolean shouldInterruptOnCancel() {
-        return shouldInterruptOnCancel;
+    public void maybeInterruptOnCancel(
+            Thread toInterrupt, @Nullable String taskName, @Nullable Long timeout) {
+        synchronized (shouldInterruptOnCancelLock) {
+            if (shouldInterruptOnCancel) {
+                if (taskName != null && timeout != null) {
+                    Task.logTaskThreadStackTrace(toInterrupt, taskName, timeout, "interrupting");
+                }
+
+                toInterrupt.interrupt();
+            }
+        }
     }
 
     @Override
