diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
index f690bda4528..7d7c1997239 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/Task.java
@@ -29,6 +29,7 @@ import org.apache.flink.api.common.cache.DistributedCache;
 import org.apache.flink.api.common.time.Deadline;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.TaskManagerOptions;
+import org.apache.flink.core.fs.AutoCloseableRegistry;
 import org.apache.flink.core.fs.FileSystemSafetyNet;
 import org.apache.flink.core.fs.Path;
 import org.apache.flink.core.security.FlinkSecurityManager;
@@ -612,6 +613,9 @@ public class Task
         // need to be undone in the end
         Map<String, Future<Path>> distributedCacheEntries = new HashMap<>();
         TaskInvokable invokable = null;
+        // Registry that can be used to execute actions after the task has already failed. These
+        // actions are fired in the registration order.
+        AutoCloseableRegistry postFailureCleanUpRegistry = new AutoCloseableRegistry(false);
 
         try {
             // ----------------------------
@@ -753,7 +757,7 @@ public class Task
             // by the time we switched to running.
             this.invokable = invokable;
 
-            restoreAndInvoke(invokable);
+            restoreAndInvoke(invokable, postFailureCleanUpRegistry);
 
             // make sure, we enter the catch block if the task leaves the invoke() method due
             // to the fact that it has been canceled
@@ -786,7 +790,8 @@ public class Task
             t = preProcessException(t);
 
             try {
-                transitionStateOnFailure(t);
+                transitionStateOnFailure(t, postFailureCleanUpRegistry);
+                postFailureCleanUpRegistry.close();
             } catch (Throwable tt) {
                 String message =
                         String.format(
@@ -850,7 +855,8 @@ public class Task
      * INITIALIZING, RUNNING, CANCELING, or FAILED loop for multiple retries during concurrent state
      * changes via calls to cancel() or to failExternally()
      */
-    private void transitionStateOnFailure(Throwable t) {
+    private void transitionStateOnFailure(
+            Throwable t, AutoCloseableRegistry postFailureCleanUpRegistry) throws IOException {
         while (true) {
             ExecutionState current = this.executionState;
 
@@ -859,12 +865,14 @@ public class Task
                     || current == ExecutionState.DEPLOYING) {
                 if (ExceptionUtils.findThrowable(t, CancelTaskException.class).isPresent()) {
                     if (transitionState(current, ExecutionState.CANCELED, t)) {
-                        cancelInvokable(invokable);
+                        postFailureCleanUpRegistry.registerCloseable(
+                                () -> cancelInvokable(invokable));
                         break;
                     }
                 } else {
                     if (transitionState(current, ExecutionState.FAILED, t)) {
-                        cancelInvokable(invokable);
+                        postFailureCleanUpRegistry.registerCloseable(
+                                () -> cancelInvokable(invokable));
                         break;
                     }
                 }
@@ -919,7 +927,8 @@ public class Task
         return t;
     }
 
-    private void restoreAndInvoke(TaskInvokable finalInvokable) throws Exception {
+    private void restoreAndInvoke(
+            TaskInvokable finalInvokable, AutoCloseableRegistry cleanUpRegistry) throws Exception {
         try {
             // switch to the INITIALIZING state, if that fails, we have been canceled/failed in the
             // meantime
@@ -945,11 +954,8 @@ public class Task
 
             runWithSystemExitMonitoring(finalInvokable::invoke);
         } catch (Throwable throwable) {
-            try {
-                runWithSystemExitMonitoring(() -> finalInvokable.cleanUp(throwable));
-            } catch (Throwable cleanUpThrowable) {
-                throwable.addSuppressed(cleanUpThrowable);
-            }
+            cleanUpRegistry.registerCloseable(
+                    () -> runWithSystemExitMonitoring(() -> finalInvokable.cleanUp(throwable)));
             throw throwable;
         }
         runWithSystemExitMonitoring(() -> finalInvokable.cleanUp(null));
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java
index a165d4621a0..65bc95d4b0c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskmanager/TaskTest.java
@@ -51,6 +51,7 @@ import org.apache.flink.runtime.taskexecutor.PartitionProducerStateChecker;
 import org.apache.flink.runtime.util.NettyShuffleDescriptorBuilder;
 import org.apache.flink.testutils.TestingUtils;
 import org.apache.flink.testutils.executor.TestExecutorResource;
+import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.TestLogger;
 import org.apache.flink.util.WrappingRuntimeException;
@@ -126,6 +127,31 @@ public class TaskTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testTaskFailedWithCleanupCancelledExternally() throws Exception {
+        testTaskFailedWithCleanupFailingExternally(false);
+    }
+
+    @Test
+    public void testTaskFailedWithCleanupFailingExternally() throws Exception {
+        testTaskFailedWithCleanupFailingExternally(true);
+    }
+
+    public void testTaskFailedWithCleanupFailingExternally(boolean cancelled) throws Exception {
+        Task task =
+                createTaskBuilder()
+                        .setInvokable(
+                                cancelled
+                                        ? InvokableWithExceptionAndCleanUpFailingExternallyWithCancel
+                                                .class
+                                        : InvokableWithExceptionAndCleanUpFailingExternally.class)
+                        .build(Executors.directExecutor());
+        task.run();
+
+        assertEquals(ExecutionState.FAILED, task.getExecutionState());
+        ExceptionUtils.assertThrowable(task.getFailureCause(), ExpectedTestException.class);
+    }
+
     @Test
     public void testCleanupWhenRestoreFails() throws Exception {
         createTaskBuilder()
@@ -1389,6 +1415,43 @@ public class TaskTest extends TestLogger {
         }
     }
 
+    private static final class InvokableWithExceptionAndCleanUpFailingExternallyWithCancel
+            extends AbstractInvokable {
+        public InvokableWithExceptionAndCleanUpFailingExternallyWithCancel(
+                Environment environment) {
+            super(environment);
+        }
+
+        @Override
+        public void invoke() throws Exception {
+            throw new ExpectedTestException("THIS!");
+        }
+
+        @Override
+        public void cleanUp(Throwable throwable) throws Exception {
+            getEnvironment().failExternally(new CancelTaskException("NOT THIS!"));
+            super.cleanUp(throwable);
+        }
+    }
+
+    private static final class InvokableWithExceptionAndCleanUpFailingExternally
+            extends AbstractInvokable {
+        public InvokableWithExceptionAndCleanUpFailingExternally(Environment environment) {
+            super(environment);
+        }
+
+        @Override
+        public void invoke() throws Exception {
+            throw new ExpectedTestException("THIS!");
+        }
+
+        @Override
+        public void cleanUp(Throwable throwable) throws Exception {
+            getEnvironment().failExternally(new Exception("NOT THIS!"));
+            super.cleanUp(throwable);
+        }
+    }
+
     static final class InvokableWithExceptionInRestore extends AbstractInvokable {
         public InvokableWithExceptionInRestore(Environment environment) {
             super(environment);
