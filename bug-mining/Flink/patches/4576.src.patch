diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java
index 76d31d27e0c..a4fa6d9e537 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java
@@ -92,6 +92,8 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen
 				throw new IllegalStateException("Subpartition already requested");
 			}
 		}
+
+		notifyDataAvailable();
 	}
 
 	@Override
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/NoOpResultSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/NoOpResultSubpartitionView.java
index f8022a13c66..9818d2d36e5 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/NoOpResultSubpartitionView.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/NoOpResultSubpartitionView.java
@@ -40,7 +40,7 @@ public class NoOpResultSubpartitionView implements ResultSubpartitionView {
 
 	@Override
 	public boolean isReleased() {
-		return true;
+		return false;
 	}
 
 	@Override
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionManager.java
index 11581ee3515..dbfe3a50d39 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionManager.java
@@ -73,8 +73,6 @@ public class ResultPartitionManager implements ResultPartitionProvider {
 			subpartitionView = partition.createSubpartitionView(subpartitionIndex, availabilityListener);
 		}
 
-		availabilityListener.notifyDataAvailable();
-
 		return subpartitionView;
 	}
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java
index 8d2aa2e9d3c..47512be4391 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java
@@ -37,6 +37,8 @@ import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
+
 import java.io.IOException;
 import java.util.Collections;
 import java.util.Optional;
@@ -64,7 +66,7 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit
 	private final TaskEventPublisher taskEventPublisher;
 
 	/** The consumed subpartition. */
-	private volatile ResultSubpartitionView subpartitionView;
+	@Nullable private volatile ResultSubpartitionView subpartitionView;
 
 	private volatile boolean isReleased;
 
@@ -120,6 +122,7 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit
 	protected void requestSubpartition(int subpartitionIndex) throws IOException {
 
 		boolean retriggerRequest = false;
+		boolean notifyDataAvailable = false;
 
 		// The lock is required to request only once in the presence of retriggered requests.
 		synchronized (requestLock) {
@@ -144,6 +147,8 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit
 					if (isReleased) {
 						subpartitionView.releaseAllResources();
 						this.subpartitionView = null;
+					} else {
+						notifyDataAvailable = true;
 					}
 				} catch (PartitionNotFoundException notFound) {
 					if (increaseBackoff()) {
@@ -155,6 +160,10 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit
 			}
 		}
 
+		if (notifyDataAvailable) {
+			notifyDataAvailable();
+		}
+
 		// Do this outside of the lock scope as this might lead to a
 		// deadlock with a concurrent release of the channel via the
 		// input gate.
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionAvailabilityTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionAvailabilityTest.java
index 4bf56957e49..8a81dc8b740 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionAvailabilityTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionAvailabilityTest.java
@@ -47,7 +47,7 @@ public class BoundedBlockingSubpartitionAvailabilityTest {
 	private static final int BUFFER_SIZE = 32 * 1024;
 
 	@Test
-	public void testInitiallyAvailable() throws Exception {
+	public void testInitiallyNotAvailable() throws Exception {
 		final ResultSubpartition subpartition = createPartitionWithData(10);
 		final CountingAvailabilityListener listener = new CountingAvailabilityListener();
 
@@ -55,7 +55,7 @@ public class BoundedBlockingSubpartitionAvailabilityTest {
 		final ResultSubpartitionView subpartitionView = createView(subpartition, listener);
 
 		// assert
-		assertEquals(1, listener.numNotifications);
+		assertEquals(0, listener.numNotifications);
 
 		// cleanup
 		subpartitionView.releaseAllResources();
@@ -95,7 +95,7 @@ public class BoundedBlockingSubpartitionAvailabilityTest {
 
 		// assert
 		assertTrue(reader.isAvailable(Integer.MAX_VALUE));
-		assertEquals(2, listener.numNotifications); // one initial, one for new availability
+		assertEquals(1, listener.numNotifications);
 
 		// cleanup
 		reader.releaseAllResources();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/FileChannelBoundedDataTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/FileChannelBoundedDataTest.java
index 6fe77fde660..aa209ecf960 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/FileChannelBoundedDataTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/FileChannelBoundedDataTest.java
@@ -132,10 +132,6 @@ public class FileChannelBoundedDataTest extends BoundedDataTestBase {
 
 		final VerifyNotificationBufferAvailabilityListener listener = new VerifyNotificationBufferAvailabilityListener();
 		final ResultSubpartitionView subpartitionView = createView(subpartition, listener);
-		// the notification is triggered while creating view
-		assertTrue(listener.isAvailable);
-
-		listener.resetAvailable();
 		assertFalse(listener.isAvailable);
 
 		final BufferAndBacklog buffer1 = subpartitionView.getNextBuffer();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java
index 108e45e889c..3787627ddf0 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java
@@ -64,7 +64,6 @@ import org.junit.Test;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Optional;
@@ -240,19 +239,16 @@ public class SingleInputGateTest extends InputGateTestBase {
 			// check channel error during above partition request
 			gate.pollNext();
 
-			Collection<InputChannel> channels = gate.getInputChannels().values();
-			for (InputChannel channel: channels) {
-				if (channel.getChannelIndex() == 0) {
-					assertThat(channel, instanceOf(RemoteInputChannel.class));
-					assertNotNull(((RemoteInputChannel) channel).getPartitionRequestClient());
-					assertEquals(2, ((RemoteInputChannel) channel).getInitialCredit());
-				} else if (channel.getChannelIndex() == 1) {
-					assertThat(channel, instanceOf(LocalInputChannel.class));
-					assertNotNull(((LocalInputChannel) channel).getSubpartitionView());
-				} else if (channel.getChannelIndex() == 2) {
-					assertThat(channel, instanceOf(UnknownInputChannel.class));
-				}
-			}
+			final InputChannel remoteChannel = gate.getChannel(0);
+			assertThat(remoteChannel, instanceOf(RemoteInputChannel.class));
+			assertNotNull(((RemoteInputChannel) remoteChannel).getPartitionRequestClient());
+			assertEquals(2, ((RemoteInputChannel) remoteChannel).getInitialCredit());
+
+			final InputChannel localChannel = gate.getChannel(1);
+			assertThat(localChannel, instanceOf(LocalInputChannel.class));
+			assertNotNull(((LocalInputChannel) localChannel).getSubpartitionView());
+
+			assertThat(gate.getChannel(2), instanceOf(UnknownInputChannel.class));
 		} finally {
 			gate.close();
 			environment.close();
