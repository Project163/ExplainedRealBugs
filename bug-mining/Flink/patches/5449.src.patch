diff --git a/flink-core/src/main/java/org/apache/flink/api/common/eventtime/IndexedCombinedWatermarkStatus.java b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/IndexedCombinedWatermarkStatus.java
new file mode 100644
index 00000000000..8ba443c57ba
--- /dev/null
+++ b/flink-core/src/main/java/org/apache/flink/api/common/eventtime/IndexedCombinedWatermarkStatus.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.api.common.eventtime;
+
+import org.apache.flink.annotation.Internal;
+
+import java.util.stream.IntStream;
+
+import static org.apache.flink.util.Preconditions.checkArgument;
+
+/**
+ * Represents combined value and status of a watermark for a set number of input partial watermarks.
+ */
+@Internal
+public final class IndexedCombinedWatermarkStatus {
+    private final CombinedWatermarkStatus combinedWatermarkStatus;
+    private final CombinedWatermarkStatus.PartialWatermark[] partialWatermarks;
+
+    private IndexedCombinedWatermarkStatus(
+            CombinedWatermarkStatus combinedWatermarkStatus,
+            CombinedWatermarkStatus.PartialWatermark[] partialWatermarks) {
+        this.combinedWatermarkStatus = combinedWatermarkStatus;
+        this.partialWatermarks = partialWatermarks;
+    }
+
+    public static IndexedCombinedWatermarkStatus forInputsCount(int inputsCount) {
+        CombinedWatermarkStatus.PartialWatermark[] partialWatermarks =
+                IntStream.range(0, inputsCount)
+                        .mapToObj(i -> new CombinedWatermarkStatus.PartialWatermark())
+                        .toArray(CombinedWatermarkStatus.PartialWatermark[]::new);
+        CombinedWatermarkStatus combinedWatermarkStatus = new CombinedWatermarkStatus();
+        for (CombinedWatermarkStatus.PartialWatermark partialWatermark : partialWatermarks) {
+            combinedWatermarkStatus.add(partialWatermark);
+        }
+        return new IndexedCombinedWatermarkStatus(combinedWatermarkStatus, partialWatermarks);
+    }
+
+    /**
+     * Updates the value for the given partial watermark. Can update both the global idleness as
+     * well as the combined watermark value.
+     *
+     * @return true, if the combined watermark value changed. The global idleness needs to be
+     *     checked separately via {@link #isIdle()}
+     */
+    public boolean updateWatermark(int index, long timestamp) {
+        checkArgument(index < partialWatermarks.length);
+        partialWatermarks[index].setWatermark(timestamp);
+        return combinedWatermarkStatus.updateCombinedWatermark();
+    }
+
+    public long getCombinedWatermark() {
+        return combinedWatermarkStatus.getCombinedWatermark();
+    }
+
+    /**
+     * Updates the idleness for the given partial watermark. Can update both the global idleness as
+     * well as the combined watermark value.
+     *
+     * @return true, if the combined watermark value changed. The global idleness needs to be
+     *     checked separately via {@link #isIdle()}
+     */
+    public boolean updateStatus(int index, boolean idle) {
+        checkArgument(index < partialWatermarks.length);
+        partialWatermarks[index].setIdle(idle);
+        return combinedWatermarkStatus.updateCombinedWatermark();
+    }
+
+    public boolean isIdle() {
+        return combinedWatermarkStatus.isIdle();
+    }
+}
diff --git a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java
index 21c47f60ecc..84fa9eb6ccd 100644
--- a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java
+++ b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/BoundedStreamTask.java
@@ -30,6 +30,7 @@ import org.apache.flink.streaming.api.operators.StreamOperatorFactoryUtil;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
 import org.apache.flink.streaming.runtime.tasks.mailbox.MailboxDefaultAction;
@@ -129,6 +130,9 @@ class BoundedStreamTask<IN, OUT, OP extends OneInputStreamOperator<IN, OUT> & Bo
         @Override
         public void emitWatermark(Watermark mark) {}
 
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) {}
+
         @Override
         public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {}
 
diff --git a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/operators/StateBootstrapWrapperOperator.java b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/operators/StateBootstrapWrapperOperator.java
index 9e74f02321e..0f78c0f4c83 100644
--- a/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/operators/StateBootstrapWrapperOperator.java
+++ b/flink-libraries/flink-state-processing-api/src/main/java/org/apache/flink/state/api/output/operators/StateBootstrapWrapperOperator.java
@@ -39,6 +39,7 @@ import org.apache.flink.streaming.api.operators.StreamTaskStateInitializer;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
 import org.apache.flink.util.OutputTag;
 
@@ -93,6 +94,11 @@ public final class StateBootstrapWrapperOperator<
         operator.processLatencyMarker(latencyMarker);
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+        operator.emitStreamStatus(streamStatus);
+    }
+
     @Override
     public void open() throws Exception {
         operator.open();
@@ -201,6 +207,9 @@ public final class StateBootstrapWrapperOperator<
         @Override
         public void emitWatermark(Watermark mark) {}
 
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) {}
+
         @Override
         public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {}
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractInput.java
index 40be35b0b6e..b77d6e86e70 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractInput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractInput.java
@@ -23,6 +23,7 @@ import org.apache.flink.api.java.functions.KeySelector;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 
 import javax.annotation.Nullable;
 
@@ -65,6 +66,11 @@ public abstract class AbstractInput<IN, OUT> implements Input<IN> {
         owner.reportOrForwardLatencyMarker(latencyMarker);
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+        owner.emitStreamStatus(streamStatus, inputId);
+    }
+
     @Override
     public void setKeyContextElement(StreamRecord record) throws Exception {
         owner.internalSetKeyContextElement(record, stateKeySelector);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java
index 25b5d20c182..e4b491b31d2 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperator.java
@@ -22,6 +22,7 @@ import org.apache.flink.annotation.Internal;
 import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.ExecutionConfig;
+import org.apache.flink.api.common.eventtime.IndexedCombinedWatermarkStatus;
 import org.apache.flink.api.common.state.KeyedStateStore;
 import org.apache.flink.api.common.state.State;
 import org.apache.flink.api.common.state.StateDescriptor;
@@ -50,6 +51,7 @@ import org.apache.flink.streaming.api.operators.StreamOperatorStateHandler.Check
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
 import org.apache.flink.streaming.util.LatencyStats;
@@ -88,7 +90,6 @@ public abstract class AbstractStreamOperator<OUT>
                 SetupableStreamOperator<OUT>,
                 CheckpointedStreamOperator,
                 Serializable {
-
     private static final long serialVersionUID = 1L;
 
     /** The logger used by the operator class and its subclasses. */
@@ -108,6 +109,8 @@ public abstract class AbstractStreamOperator<OUT>
 
     protected transient Output<StreamRecord<OUT>> output;
 
+    private transient IndexedCombinedWatermarkStatus combinedWatermark;
+
     /** The runtime context for UDFs. */
     private transient StreamingRuntimeContext runtimeContext;
 
@@ -144,14 +147,6 @@ public abstract class AbstractStreamOperator<OUT>
 
     protected transient ProcessingTimeService processingTimeService;
 
-    // ---------------- two-input operator watermarks ------------------
-
-    // We keep track of watermarks from both inputs, the combined input is the minimum
-    // Once the minimum advances we emit a new watermark for downstream operators
-    private long combinedWatermark = Long.MIN_VALUE;
-    private long input1Watermark = Long.MIN_VALUE;
-    private long input2Watermark = Long.MIN_VALUE;
-
     // ------------------------------------------------------------------------
     //  Life Cycle
     // ------------------------------------------------------------------------
@@ -183,6 +178,7 @@ public abstract class AbstractStreamOperator<OUT>
             this.output = output;
         }
 
+        this.combinedWatermark = IndexedCombinedWatermarkStatus.forInputsCount(2);
         try {
             Configuration taskManagerConfig = environment.getTaskManagerInfo().getConfiguration();
             int historySize = taskManagerConfig.getInteger(MetricOptions.LATENCY_HISTORY_SIZE);
@@ -628,24 +624,42 @@ public abstract class AbstractStreamOperator<OUT>
         output.emitWatermark(mark);
     }
 
-    public void processWatermark1(Watermark mark) throws Exception {
-        input1Watermark = mark.getTimestamp();
-        long newMin = Math.min(input1Watermark, input2Watermark);
-        if (newMin > combinedWatermark) {
-            combinedWatermark = newMin;
-            processWatermark(new Watermark(combinedWatermark));
+    private void processWatermark(Watermark mark, int index) throws Exception {
+        if (combinedWatermark.updateWatermark(index, mark.getTimestamp())) {
+            processWatermark(new Watermark(combinedWatermark.getCombinedWatermark()));
         }
     }
 
+    public void processWatermark1(Watermark mark) throws Exception {
+        processWatermark(mark, 0);
+    }
+
     public void processWatermark2(Watermark mark) throws Exception {
-        input2Watermark = mark.getTimestamp();
-        long newMin = Math.min(input1Watermark, input2Watermark);
-        if (newMin > combinedWatermark) {
-            combinedWatermark = newMin;
-            processWatermark(new Watermark(combinedWatermark));
+        processWatermark(mark, 1);
+    }
+
+    public final void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+        output.emitStreamStatus(streamStatus);
+    }
+
+    private void emitStreamStatus(StreamStatus streamStatus, int index) throws Exception {
+        boolean wasIdle = combinedWatermark.isIdle();
+        if (combinedWatermark.updateStatus(index, streamStatus.isIdle())) {
+            processWatermark(new Watermark(combinedWatermark.getCombinedWatermark()));
+        }
+        if (wasIdle != combinedWatermark.isIdle()) {
+            output.emitStreamStatus(streamStatus);
         }
     }
 
+    public final void emitStreamStatus1(StreamStatus streamStatus) throws Exception {
+        emitStreamStatus(streamStatus, 0);
+    }
+
+    public final void emitStreamStatus2(StreamStatus streamStatus) throws Exception {
+        emitStreamStatus(streamStatus, 1);
+    }
+
     @Override
     public OperatorID getOperatorID() {
         return config.getOperatorID();
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java
index 3e87f0f9d3e..7862a527fa3 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2.java
@@ -22,6 +22,7 @@ import org.apache.flink.annotation.Experimental;
 import org.apache.flink.annotation.Internal;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.ExecutionConfig;
+import org.apache.flink.api.common.eventtime.IndexedCombinedWatermarkStatus;
 import org.apache.flink.api.common.state.KeyedStateStore;
 import org.apache.flink.api.common.state.State;
 import org.apache.flink.api.common.state.StateDescriptor;
@@ -50,6 +51,7 @@ import org.apache.flink.streaming.api.operators.StreamOperatorStateHandler.Check
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.ProcessingTimeService;
 import org.apache.flink.streaming.runtime.tasks.StreamTask;
 import org.apache.flink.streaming.util.LatencyStats;
@@ -58,7 +60,6 @@ import org.apache.flink.util.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Arrays;
 import java.util.Locale;
 import java.util.Optional;
 
@@ -89,7 +90,7 @@ public abstract class AbstractStreamOperatorV2<OUT>
     private final ExecutionConfig executionConfig;
     private final ClassLoader userCodeClassLoader;
     private final CloseableRegistry cancelables;
-    private final long[] inputWatermarks;
+    private final IndexedCombinedWatermarkStatus combinedWatermark;
 
     /** Metric group for the operator. */
     protected final OperatorMetricGroup metrics;
@@ -100,13 +101,7 @@ public abstract class AbstractStreamOperatorV2<OUT>
     private StreamOperatorStateHandler stateHandler;
     private InternalTimeServiceManager<?> timeServiceManager;
 
-    // We keep track of watermarks from both inputs, the combined input is the minimum
-    // Once the minimum advances we emit a new watermark for downstream operators
-    private long combinedWatermark = Long.MIN_VALUE;
-
     public AbstractStreamOperatorV2(StreamOperatorParameters<OUT> parameters, int numberOfInputs) {
-        inputWatermarks = new long[numberOfInputs];
-        Arrays.fill(inputWatermarks, Long.MIN_VALUE);
         final Environment environment = parameters.getContainingTask().getEnvironment();
         config = parameters.getStreamConfig();
         CountingOutput<OUT> countingOutput;
@@ -146,6 +141,7 @@ public abstract class AbstractStreamOperatorV2<OUT>
         executionConfig = parameters.getContainingTask().getExecutionConfig();
         userCodeClassLoader = parameters.getContainingTask().getUserCodeClassLoader();
         cancelables = parameters.getContainingTask().getCancelables();
+        this.combinedWatermark = IndexedCombinedWatermarkStatus.forInputsCount(numberOfInputs);
 
         runtimeContext =
                 new StreamingRuntimeContext(
@@ -529,14 +525,18 @@ public abstract class AbstractStreamOperatorV2<OUT>
     }
 
     protected void reportWatermark(Watermark mark, int inputId) throws Exception {
-        inputWatermarks[inputId - 1] = mark.getTimestamp();
-        long newMin = mark.getTimestamp();
-        for (long inputWatermark : inputWatermarks) {
-            newMin = Math.min(inputWatermark, newMin);
+        if (combinedWatermark.updateWatermark(inputId - 1, mark.getTimestamp())) {
+            processWatermark(new Watermark(combinedWatermark.getCombinedWatermark()));
+        }
+    }
+
+    public final void emitStreamStatus(StreamStatus streamStatus, int inputId) throws Exception {
+        boolean wasIdle = combinedWatermark.isIdle();
+        if (combinedWatermark.updateStatus(inputId - 1, streamStatus.isIdle())) {
+            processWatermark(new Watermark(combinedWatermark.getCombinedWatermark()));
         }
-        if (newMin > combinedWatermark) {
-            combinedWatermark = newMin;
-            processWatermark(new Watermark(combinedWatermark));
+        if (wasIdle != combinedWatermark.isIdle()) {
+            output.emitStreamStatus(streamStatus);
         }
     }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/CountingOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/CountingOutput.java
index 7dad0a651a5..6bd916c83dc 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/CountingOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/CountingOutput.java
@@ -22,6 +22,7 @@ import org.apache.flink.metrics.Counter;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.OutputTag;
 
 /** Wrapping {@link Output} that updates metrics on the number of emitted elements. */
@@ -39,6 +40,11 @@ public class CountingOutput<OUT> implements Output<StreamRecord<OUT>> {
         output.emitWatermark(mark);
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        output.emitStreamStatus(streamStatus);
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         output.emitLatencyMarker(latencyMarker);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Input.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Input.java
index 004fca071f3..61f0b6e0645 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Input.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Input.java
@@ -22,6 +22,7 @@ import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 
 /** {@link Input} interface used in {@link MultipleInputStreamOperator}. */
 @PublicEvolving
@@ -49,4 +50,6 @@ public interface Input<IN> {
     void processLatencyMarker(LatencyMarker latencyMarker) throws Exception;
 
     void setKeyContextElement(StreamRecord<IN> record) throws Exception;
+
+    void emitStreamStatus(StreamStatus streamStatus) throws Exception;
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Output.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Output.java
index 03e96274fd4..5dab0d4ba7e 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Output.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/Output.java
@@ -22,6 +22,7 @@ import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.Collector;
 import org.apache.flink.util.OutputTag;
 
@@ -44,6 +45,8 @@ public interface Output<T> extends Collector<T> {
      */
     void emitWatermark(Watermark mark);
 
+    void emitStreamStatus(StreamStatus streamStatus);
+
     /**
      * Emits a record to the side output identified by the given {@link OutputTag}.
      *
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TimestampedCollector.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TimestampedCollector.java
index d893a004209..9f2f54cace3 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TimestampedCollector.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TimestampedCollector.java
@@ -22,6 +22,7 @@ import org.apache.flink.annotation.Internal;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.OutputTag;
 
 /**
@@ -76,6 +77,11 @@ public final class TimestampedCollector<T> implements Output<T> {
         output.emitWatermark(mark);
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        output.emitStreamStatus(streamStatus);
+    }
+
     @Override
     public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {
         output.collect(outputTag, record);
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TwoInputStreamOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TwoInputStreamOperator.java
index aff4dd6715c..a4b12100baa 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TwoInputStreamOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/TwoInputStreamOperator.java
@@ -22,6 +22,7 @@ import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 
 /**
  * Interface for stream operators with two inputs. Use {@link
@@ -79,4 +80,8 @@ public interface TwoInputStreamOperator<IN1, IN2, OUT> extends StreamOperator<OU
      * @see org.apache.flink.streaming.runtime.streamrecord.LatencyMarker
      */
     void processLatencyMarker2(LatencyMarker latencyMarker) throws Exception;
+
+    void emitStreamStatus1(StreamStatus streamStatus) throws Exception;
+
+    void emitStreamStatus2(StreamStatus streamStatus) throws Exception;
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java
index db8263af0d5..78584b7623e 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AbstractDataOutput.java
@@ -40,7 +40,7 @@ public abstract class AbstractDataOutput<T> implements PushingAsyncDataInput.Dat
     }
 
     @Override
-    public void emitStreamStatus(StreamStatus streamStatus) {
+    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
         streamStatusMaintainer.toggleStreamStatus(streamStatus);
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java
index 7ba82d9cece..b02afd32fe6 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/RecordWriterOutput.java
@@ -31,6 +31,7 @@ import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.AnnouncedStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.streaming.runtime.tasks.WatermarkGaugeExposingOutput;
@@ -56,6 +57,8 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
 
     private final WatermarkGauge watermarkGauge = new WatermarkGauge();
 
+    private final AnnouncedStatus announcedStatus = new AnnouncedStatus(StreamStatus.ACTIVE);
+
     @SuppressWarnings("unchecked")
     public RecordWriterOutput(
             RecordWriter<SerializationDelegate<StreamRecord<OUT>>> recordWriter,
@@ -75,7 +78,7 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
                 new StreamElementSerializer<>(outSerializer);
 
         if (outSerializer != null) {
-            serializationDelegate = new SerializationDelegate<StreamElement>(outRecordSerializer);
+            serializationDelegate = new SerializationDelegate<>(outRecordSerializer);
         }
 
         this.streamStatusProvider = checkNotNull(streamStatusProvider);
@@ -101,10 +104,12 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
     }
 
     private <X> void pushToRecordWriter(StreamRecord<X> record) {
-        serializationDelegate.setInstance(record);
-
-        try {
+        // record could've been generated somewhere in the pipeline even though an IDLE status was
+        // emitted. It might've originated from a timer or just a wrong behaving operator
+        try (AutoCloseable ignored = announcedStatus.ensureActive(this::writeStreamStatus)) {
+            serializationDelegate.setInstance(record);
             recordWriter.emit(serializationDelegate);
+
         } catch (Exception e) {
             throw new RuntimeException(e.getMessage(), e);
         }
@@ -114,7 +119,6 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
     public void emitWatermark(Watermark mark) {
         watermarkGauge.setCurrentWatermark(mark.getTimestamp());
         serializationDelegate.setInstance(mark);
-
         if (streamStatusProvider.getStreamStatus().isActive()) {
             try {
                 recordWriter.broadcastEmit(serializationDelegate);
@@ -124,9 +128,16 @@ public class RecordWriterOutput<OUT> implements WatermarkGaugeExposingOutput<Str
         }
     }
 
+    @Override
     public void emitStreamStatus(StreamStatus streamStatus) {
-        serializationDelegate.setInstance(streamStatus);
+        if (!announcedStatus.getCurrentStatus().equals(streamStatus)) {
+            announcedStatus.setCurrentStatus(streamStatus);
+            writeStreamStatus(streamStatus);
+        }
+    }
 
+    private void writeStreamStatus(StreamStatus streamStatus) {
+        serializationDelegate.setInstance(streamStatus);
         try {
             recordWriter.broadcastEmit(serializationDelegate);
         } catch (Exception e) {
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java
index db351bc9532..738a0ac55ee 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessorFactory.java
@@ -319,8 +319,9 @@ public class StreamMultipleInputProcessorFactory {
         }
 
         @Override
-        public void emitStreamStatus(StreamStatus streamStatus) {
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
             streamStatusTracker.setStreamStatus(inputIndex, streamStatus);
+            input.emitStreamStatus(streamStatus);
 
             // check if we need to toggle the task's stream status
             if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {
@@ -344,6 +345,7 @@ public class StreamMultipleInputProcessorFactory {
             extends SourceOperatorStreamTask.AsyncDataOutputToOutput {
         private final int inputIndex;
         private final MultiStreamStreamStatusTracker streamStatusTracker;
+        private final Output<StreamRecord<?>> output;
 
         public StreamTaskSourceOutput(
                 Output<StreamRecord<?>> chainedSourceOutput,
@@ -358,11 +360,13 @@ public class StreamMultipleInputProcessorFactory {
                     inputWatermarkGauge);
             this.streamStatusTracker = streamStatusTracker;
             this.inputIndex = inputIndex;
+            this.output = chainedSourceOutput;
         }
 
         @Override
         public void emitStreamStatus(StreamStatus streamStatus) {
             streamStatusTracker.setStreamStatus(inputIndex, streamStatus);
+            output.emitStreamStatus(streamStatus);
 
             // check if we need to toggle the task's stream status
             if (!streamStatus.equals(streamStatusMaintainer.getStreamStatus())) {
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java
index 838f6609ae4..87b91f076fd 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessorFactory.java
@@ -302,13 +302,15 @@ public class StreamTwoInputProcessorFactory {
         }
 
         @Override
-        public void emitStreamStatus(StreamStatus streamStatus) {
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
             final StreamStatus anotherStreamStatus;
             if (inputIndex == 0) {
                 statusTracker.setFirstStatus(streamStatus);
+                operator.emitStreamStatus1(streamStatus);
                 anotherStreamStatus = statusTracker.getSecondStatus();
             } else {
                 statusTracker.setSecondStatus(streamStatus);
+                operator.emitStreamStatus2(streamStatus);
                 anotherStreamStatus = statusTracker.getFirstStatus();
             }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/AnnouncedStatus.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/AnnouncedStatus.java
new file mode 100644
index 00000000000..3cd055b7f3c
--- /dev/null
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/streamstatus/AnnouncedStatus.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.runtime.streamstatus;
+
+import org.apache.flink.annotation.Internal;
+
+import java.util.function.Consumer;
+
+/**
+ * {@link StreamStatus#IDLE} requires that no records nor watermarks travel through the branch. In
+ * order to keep the older behaviour that records could've been generated down the pipeline even
+ * though the sources were idle we go through a short ACTIVE/IDLE loop. This is a helper class that
+ * lets you easily flip the status around a code block.
+ */
+@Internal
+public final class AnnouncedStatus {
+    private StreamStatus currentStatus;
+
+    public AnnouncedStatus(StreamStatus currentStatus) {
+        this.currentStatus = currentStatus;
+    }
+
+    public StreamStatus getCurrentStatus() {
+        return currentStatus;
+    }
+
+    public void setCurrentStatus(StreamStatus currentStatus) {
+        this.currentStatus = currentStatus;
+    }
+
+    /**
+     * Makes sure that the last emitted StreamStatus was ACTIVE.
+     *
+     * <p>Example usage:
+     *
+     * <pre>{@code
+     * try (AutoCloseable ignored = announcedStatus.ensureActive(this::writeStreamStatus)) {
+     *     serializationDelegate.setInstance(record);
+     *     recordWriter.emit(serializationDelegate);
+     * } catch (Exception e) {
+     *     throw new RuntimeException(e.getMessage(), e);
+     * }
+     * }</pre>
+     *
+     * @param statusConsumer a consumer which sends the status downstream
+     */
+    public AutoCloseable ensureActive(Consumer<StreamStatus> statusConsumer) {
+        if (currentStatus.isIdle()) {
+            statusConsumer.accept(StreamStatus.ACTIVE);
+            return () -> statusConsumer.accept(StreamStatus.IDLE);
+        }
+        return () -> {};
+    }
+}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java
index 00ad65084c9..3129cd6fee1 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/BroadcastingOutputCollector.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 import org.apache.flink.util.XORShiftRandom;
@@ -52,6 +53,13 @@ class BroadcastingOutputCollector<T> implements WatermarkGaugeExposingOutput<Str
         }
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        for (Output<StreamRecord<T>> output : outputs) {
+            output.emitStreamStatus(streamStatus);
+        }
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         if (outputs.length <= 0) {
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java
index 47e0a2ce5d0..d837bc24982 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/ChainingOutput.java
@@ -28,6 +28,7 @@ import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatusProvider;
 import org.apache.flink.util.OutputTag;
 
@@ -151,4 +152,13 @@ class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>>
     public Gauge<Long> getWatermarkGauge() {
         return watermarkGauge;
     }
+
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        try {
+            input.emitStreamStatus(streamStatus);
+        } catch (Exception e) {
+            throw new ExceptionInChainedOperatorException(e);
+        }
+    }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
index ffaf6aec339..d8b458b453c 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
@@ -42,6 +42,7 @@ import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
 import org.apache.flink.streaming.runtime.streamstatus.StatusWatermarkValve;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 
 import javax.annotation.Nullable;
@@ -215,5 +216,11 @@ public class OneInputStreamTask<IN, OUT> extends StreamTask<OUT, OneInputStreamO
         public void emitLatencyMarker(LatencyMarker latencyMarker) throws Exception {
             operator.processLatencyMarker(latencyMarker);
         }
+
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+            super.emitStreamStatus(streamStatus);
+            operator.emitStreamStatus(streamStatus);
+        }
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java
index 173cd32ab7b..d6d11ed6b15 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/OperatorChain.java
@@ -384,11 +384,6 @@ public class OperatorChain<OUT, OP extends StreamOperator<OUT>>
     public void toggleStreamStatus(StreamStatus status) {
         if (!status.equals(this.streamStatus)) {
             this.streamStatus = status;
-
-            // try and forward the stream status change to all outgoing connections
-            for (RecordWriterOutput<?> streamOutput : streamOutputs) {
-                streamOutput.emitStreamStatus(status);
-            }
         }
     }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
index 74f0761fdde..8b895f6ee79 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceOperatorStreamTask.java
@@ -40,6 +40,7 @@ import org.apache.flink.streaming.runtime.io.StreamTaskSourceInput;
 import org.apache.flink.streaming.runtime.metrics.WatermarkGauge;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.streamstatus.StreamStatusMaintainer;
 
 import javax.annotation.Nullable;
@@ -192,5 +193,11 @@ public class SourceOperatorStreamTask<T> extends StreamTask<T, SourceOperator<T,
             }
             output.emitWatermark(watermark);
         }
+
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+            super.emitStreamStatus(streamStatus);
+            output.emitStreamStatus(streamStatus);
+        }
     }
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationTail.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationTail.java
index ac42b2d6994..dd13704725e 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationTail.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamIterationTail.java
@@ -26,6 +26,7 @@ import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.io.BlockingQueueBroker;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.OutputTag;
 
 import org.slf4j.Logger;
@@ -122,6 +123,9 @@ public class StreamIterationTail<IN> extends OneInputStreamTask<IN, IN> {
         @Override
         public void emitWatermark(Watermark mark) {}
 
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) {}
+
         @Override
         public void emitLatencyMarker(LatencyMarker latencyMarker) {}
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorTest.java
index a5b51e458d4..09ebd1063bc 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorTest.java
@@ -33,10 +33,14 @@ import org.apache.flink.runtime.state.StateInitializationContext;
 import org.apache.flink.runtime.state.StateSnapshotContext;
 import org.apache.flink.runtime.state.VoidNamespace;
 import org.apache.flink.runtime.state.VoidNamespaceSerializer;
+import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.util.AbstractStreamOperatorTestHarness;
 import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;
+import org.apache.flink.streaming.util.KeyedTwoInputStreamOperatorTestHarness;
 import org.apache.flink.streaming.util.OneInputStreamOperatorTestHarness;
+import org.apache.flink.streaming.util.TestHarnessUtil;
 import org.apache.flink.util.Preconditions;
 
 import org.hamcrest.Description;
@@ -50,10 +54,12 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import static junit.framework.TestCase.assertTrue;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.empty;
 
 /**
  * Tests for the facilities provided by {@link AbstractStreamOperator}. This mostly tests timers and
@@ -468,6 +474,68 @@ public class AbstractStreamOperatorTest {
                 hasRestoredKeyGroupsWith(testSnapshotData, keyGroupsToWrite));
     }
 
+    @Test
+    public void testIdleWatermarkHandling() throws Exception {
+        final WatermarkTestingOperator testOperator = new WatermarkTestingOperator();
+
+        ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();
+        KeySelector<Long, Integer> dummyKeySelector = l -> 0;
+        try (KeyedTwoInputStreamOperatorTestHarness<Integer, Long, Long, Long> testHarness =
+                new KeyedTwoInputStreamOperatorTestHarness<>(
+                        testOperator,
+                        dummyKeySelector,
+                        dummyKeySelector,
+                        BasicTypeInfo.INT_TYPE_INFO)) {
+            testHarness.setup();
+            testHarness.open();
+            testHarness.processElement1(1L, 1L);
+            testHarness.processElement1(3L, 3L);
+            testHarness.processElement1(4L, 4L);
+            testHarness.processWatermark1(new Watermark(1L));
+            assertThat(testHarness.getOutput(), empty());
+
+            testHarness.emitStreamStatus2(StreamStatus.IDLE);
+            expectedOutput.add(new StreamRecord<>(1L));
+            expectedOutput.add(new Watermark(1L));
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+
+            testHarness.processWatermark1(new Watermark(3L));
+            expectedOutput.add(new StreamRecord<>(3L));
+            expectedOutput.add(new Watermark(3L));
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+
+            testHarness.emitStreamStatus2(StreamStatus.ACTIVE);
+            // the other input is active now, we should not emit the watermark
+            testHarness.processWatermark1(new Watermark(4L));
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+        }
+    }
+
+    @Test
+    public void testIdlenessForwarding() throws Exception {
+        final WatermarkTestingOperator testOperator = new WatermarkTestingOperator();
+        ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();
+        KeySelector<Long, Integer> dummyKeySelector = l -> 0;
+        try (KeyedTwoInputStreamOperatorTestHarness<Integer, Long, Long, Long> testHarness =
+                new KeyedTwoInputStreamOperatorTestHarness<>(
+                        testOperator,
+                        dummyKeySelector,
+                        dummyKeySelector,
+                        BasicTypeInfo.INT_TYPE_INFO)) {
+            testHarness.setup();
+            testHarness.open();
+
+            testHarness.emitStreamStatus1(StreamStatus.IDLE);
+            testHarness.emitStreamStatus2(StreamStatus.IDLE);
+            expectedOutput.add(StreamStatus.IDLE);
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+        }
+    }
+
     /** Extracts the result values form the test harness and clear the output queue. */
     @SuppressWarnings({"unchecked", "rawtypes"})
     private <T> List<T> extractResult(OneInputStreamOperatorTestHarness<?, T> testHarness) {
@@ -493,6 +561,40 @@ public class AbstractStreamOperatorTest {
         }
     }
 
+    private static class WatermarkTestingOperator extends AbstractStreamOperator<Long>
+            implements TwoInputStreamOperator<Long, Long, Long>,
+                    Triggerable<Integer, VoidNamespace> {
+
+        private transient InternalTimerService<VoidNamespace> timerService;
+
+        @Override
+        public void open() throws Exception {
+            super.open();
+
+            this.timerService =
+                    getInternalTimerService("test-timers", VoidNamespaceSerializer.INSTANCE, this);
+        }
+
+        @Override
+        public void onEventTime(InternalTimer<Integer, VoidNamespace> timer) throws Exception {
+            output.collect(new StreamRecord<>(timer.getTimestamp()));
+        }
+
+        @Override
+        public void onProcessingTime(InternalTimer<Integer, VoidNamespace> timer)
+                throws Exception {}
+
+        @Override
+        public void processElement1(StreamRecord<Long> element) throws Exception {
+            timerService.registerEventTimeTimer(VoidNamespace.INSTANCE, element.getValue());
+        }
+
+        @Override
+        public void processElement2(StreamRecord<Long> element) throws Exception {
+            timerService.registerEventTimeTimer(VoidNamespace.INSTANCE, element.getValue());
+        }
+    }
+
     /**
      * Testing operator that can respond to commands by either setting/deleting state, emitting
      * state or setting timers.
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2Test.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2Test.java
index 934a2d8ca8a..fabf5cd871d 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2Test.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2Test.java
@@ -21,14 +21,26 @@ package org.apache.flink.streaming.api.operators;
 import org.apache.flink.api.common.state.ValueStateDescriptor;
 import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
 import org.apache.flink.api.common.typeutils.base.StringSerializer;
+import org.apache.flink.api.java.functions.KeySelector;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.runtime.state.VoidNamespace;
 import org.apache.flink.runtime.state.VoidNamespaceSerializer;
+import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
+import org.apache.flink.streaming.util.KeyedMultiInputStreamOperatorTestHarness;
 import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;
+import org.apache.flink.streaming.util.TestHarnessUtil;
 
+import org.junit.Test;
+
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.empty;
 
 /** Tests for the facilities provided by {@link AbstractStreamOperatorV2}. */
 public class AbstractStreamOperatorV2Test extends AbstractStreamOperatorTest {
@@ -58,6 +70,122 @@ public class AbstractStreamOperatorV2Test extends AbstractStreamOperatorTest {
         }
     }
 
+    @Test
+    public void testIdleWatermarkHandling() throws Exception {
+        ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();
+        KeySelector<Long, Integer> dummyKeySelector = l -> 0;
+        try (KeyedMultiInputStreamOperatorTestHarness<Integer, Long> testHarness =
+                new KeyedMultiInputStreamOperatorTestHarness<>(
+                        new WatermarkTestingOperatorFactory(), BasicTypeInfo.INT_TYPE_INFO)) {
+            testHarness.setKeySelector(0, dummyKeySelector);
+            testHarness.setKeySelector(1, dummyKeySelector);
+            testHarness.setKeySelector(2, dummyKeySelector);
+            testHarness.setup();
+            testHarness.open();
+            testHarness.processElement(0, new StreamRecord<>(1L, 1L));
+            testHarness.processElement(0, new StreamRecord<>(3L, 3L));
+            testHarness.processElement(0, new StreamRecord<>(4L, 4L));
+            testHarness.processWatermark(0, new Watermark(1L));
+            assertThat(testHarness.getOutput(), empty());
+
+            testHarness.emitStreamStatus(1, StreamStatus.IDLE);
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+            testHarness.emitStreamStatus(2, StreamStatus.IDLE);
+            expectedOutput.add(new StreamRecord<>(1L));
+            expectedOutput.add(new Watermark(1L));
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+
+            testHarness.processWatermark(0, new Watermark(3L));
+            expectedOutput.add(new StreamRecord<>(3L));
+            expectedOutput.add(new Watermark(3L));
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+
+            testHarness.emitStreamStatus(1, StreamStatus.ACTIVE);
+            // the other input is active now, we should not emit the watermark
+            testHarness.processWatermark(0, new Watermark(4L));
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+        }
+    }
+
+    @Test
+    public void testIdlenessForwarding() throws Exception {
+        ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>();
+        try (KeyedMultiInputStreamOperatorTestHarness<Integer, Long> testHarness =
+                new KeyedMultiInputStreamOperatorTestHarness<>(
+                        new WatermarkTestingOperatorFactory(), BasicTypeInfo.INT_TYPE_INFO)) {
+            testHarness.setup();
+            testHarness.open();
+
+            testHarness.emitStreamStatus(0, StreamStatus.IDLE);
+            testHarness.emitStreamStatus(1, StreamStatus.IDLE);
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+            testHarness.emitStreamStatus(2, StreamStatus.IDLE);
+            expectedOutput.add(StreamStatus.IDLE);
+            TestHarnessUtil.assertOutputEquals(
+                    "Output was not correct", expectedOutput, testHarness.getOutput());
+        }
+    }
+
+    private static class WatermarkTestingOperatorFactory
+            extends AbstractStreamOperatorFactory<Long> {
+        @Override
+        public <T extends StreamOperator<Long>> T createStreamOperator(
+                StreamOperatorParameters<Long> parameters) {
+            return (T) new WatermarkTestingOperator(parameters);
+        }
+
+        @Override
+        public Class<? extends StreamOperator> getStreamOperatorClass(ClassLoader classLoader) {
+            return WatermarkTestingOperator.class;
+        }
+    }
+
+    private static class WatermarkTestingOperator extends AbstractStreamOperatorV2<Long>
+            implements MultipleInputStreamOperator<Long>, Triggerable<Integer, VoidNamespace> {
+
+        private transient InternalTimerService<VoidNamespace> timerService;
+
+        public WatermarkTestingOperator(StreamOperatorParameters<Long> parameters) {
+            super(parameters, 3);
+        }
+
+        @Override
+        public void open() throws Exception {
+            super.open();
+
+            this.timerService =
+                    getInternalTimerService("test-timers", VoidNamespaceSerializer.INSTANCE, this);
+        }
+
+        @Override
+        public void onEventTime(InternalTimer<Integer, VoidNamespace> timer) throws Exception {
+            output.collect(new StreamRecord<>(timer.getTimestamp()));
+        }
+
+        @Override
+        public void onProcessingTime(InternalTimer<Integer, VoidNamespace> timer)
+                throws Exception {}
+
+        private Input<Long> createInput(int idx) {
+            return new AbstractInput<Long, Long>(this, idx) {
+                @Override
+                public void processElement(StreamRecord<Long> element) throws Exception {
+                    timerService.registerEventTimeTimer(VoidNamespace.INSTANCE, element.getValue());
+                }
+            };
+        }
+
+        @Override
+        public List<Input> getInputs() {
+            return Arrays.asList(createInput(1), createInput(2), createInput(3));
+        }
+    }
+
     /**
      * Testing operator that can respond to commands by either setting/deleting state, emitting
      * state or setting timers.
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java
index e282e27c5d8..352557cce84 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java
@@ -598,50 +598,33 @@ public class MultipleInputStreamTaskTest {
             // watermarks
             testHarness.processElement(StreamStatus.IDLE, 0, 1);
             testHarness.processElement(new Watermark(initialTime + 6), 0, 0);
-            testHarness.processElement(
-                    new Watermark(initialTime + 5),
-                    1,
-                    1); // this watermark should be advanced first
+            testHarness.processElement(new Watermark(initialTime + 5), 1, 1);
             testHarness.processElement(StreamStatus.IDLE, 1, 0); // once this is acknowledged,
-
-            // We don't expect to see Watermark(6) here because the idle status of one
-            // input doesn't propagate to the other input. That is, if input 1 is at WM 6 and input
-            // two was at WM 5 before going to IDLE then the output watermark will not jump to WM 6.
-
-            // OPS, there is a known bug: https://issues.apache.org/jira/browse/FLINK-18934
-            // that prevents this check from succeeding (AbstractStreamOperator and
-            // AbstractStreamOperatorV2
-            // are ignoring StreamStatus), so those checks needs to be commented out ...
-
-            // expectedOutput.add(new Watermark(initialTime + 5));
-            // assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));
-
-            // and in as a temporary replacement we need this code block:
-            {
-                // we wake up the source and emit watermark
-                addSourceRecords(testHarness, 1, initialTime + 5);
-                testHarness.processAll();
-                expectedOutput.add(
-                        new StreamRecord<>("" + (initialTime + 5), TimestampAssigner.NO_TIMESTAMP));
-                expectedOutput.add(new Watermark(initialTime + 5));
-                // the source should go back to being idle immediately, but AbstractStreamOperatorV2
-                // should have updated it's watermark by then.
-            }
+            expectedOutput.add(new Watermark(initialTime + 5));
             assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));
 
-            // make all input channels idle and check that the operator's idle status is forwarded
-            testHarness.processElement(StreamStatus.IDLE, 0, 0);
+            // We make the second input idle, which should forward W=6 from the first input
             testHarness.processElement(StreamStatus.IDLE, 1, 1);
+            expectedOutput.add(new Watermark(initialTime + 6));
+            assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));
 
+            // Make the first input idle
+            testHarness.processElement(StreamStatus.IDLE, 0, 0);
             expectedOutput.add(StreamStatus.IDLE);
             assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));
 
             // make source active once again, emit a watermark and go idle again.
             addSourceRecords(testHarness, 1, initialTime + 10);
+
+            // FLIP-27 sources do not emit active status on new records, we wrap a record with
+            // ACTIVE/IDLE sequence
+            expectedOutput.add(StreamStatus.ACTIVE);
             expectedOutput.add(
                     new StreamRecord<>("" + (initialTime + 10), TimestampAssigner.NO_TIMESTAMP));
-            expectedOutput.add(StreamStatus.ACTIVE);
             expectedOutput.add(StreamStatus.IDLE);
+            expectedOutput.add(StreamStatus.ACTIVE); // activate source on new watermark
+            expectedOutput.add(new Watermark(initialTime + 10)); // forward W from source
+            expectedOutput.add(StreamStatus.IDLE); // go idle after reading all records
             testHarness.processAll();
             assertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java
index c845e1db732..f317e8f04ec 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java
@@ -354,12 +354,20 @@ public class OneInputStreamTaskTest extends TestLogger {
         // the 40 - 60 watermarks should not be forwarded, only the stream status toggle element and
         // records
         expectedOutput.add(StreamStatus.IDLE);
+        expectedOutput.add(StreamStatus.ACTIVE);
         expectedOutput.add(
                 new StreamRecord<>(
                         TriggerableFailOnWatermarkTestOperator.NO_FORWARDED_WATERMARKS_MARKER));
+        expectedOutput.add(StreamStatus.IDLE);
+        expectedOutput.add(StreamStatus.ACTIVE);
         expectedOutput.add(new StreamRecord<>("40"));
+        expectedOutput.add(StreamStatus.IDLE);
+        expectedOutput.add(StreamStatus.ACTIVE);
         expectedOutput.add(new StreamRecord<>("50"));
+        expectedOutput.add(StreamStatus.IDLE);
+        expectedOutput.add(StreamStatus.ACTIVE);
         expectedOutput.add(new StreamRecord<>("60"));
+        expectedOutput.add(StreamStatus.IDLE);
         TestHarnessUtil.assertOutputEquals(
                 "Output was not correct.", expectedOutput, testHarness.getOutput());
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java
index e049e68ded0..92c63f6e279 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/SubtaskCheckpointCoordinatorTest.java
@@ -58,6 +58,7 @@ import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElementSerializer;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.StreamTaskTest.NoOpStreamTask;
 import org.apache.flink.streaming.util.MockStreamTaskBuilder;
 import org.apache.flink.util.ExceptionUtils;
@@ -607,6 +608,9 @@ public class SubtaskCheckpointCoordinatorTest {
 
         @Override
         public void processLatencyMarker(LatencyMarker latencyMarker) {}
+
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {}
     }
 
     private static SubtaskCheckpointCoordinator coordinator(
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java
index d2a8e61ef2f..6e1fb62097c 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java
@@ -227,9 +227,7 @@ public class TwoInputStreamTaskTest {
 
         testHarness.waitForInputProcessing();
         expectedOutput.add(new Watermark(initialTime + 5));
-        // We don't expect to see Watermark(6) here because the idle status of one
-        // input doesn't propagate to the other input. That is, if input 1 is at WM 6 and input
-        // two was at WM 5 before going to IDLE then the output watermark will not jump to WM 6.
+        expectedOutput.add(new Watermark(initialTime + 6));
         TestHarnessUtil.assertOutputEquals(
                 "Output was not correct.", expectedOutput, testHarness.getOutput());
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
index be0e6b3b14e..57783fe580b 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/AbstractStreamOperatorTestHarness.java
@@ -790,6 +790,11 @@ public class AbstractStreamOperatorTestHarness<OUT> implements AutoCloseable {
             outputList.add(mark);
         }
 
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) {
+            outputList.add(streamStatus);
+        }
+
         @Override
         public void emitLatencyMarker(LatencyMarker latencyMarker) {
             outputList.add(latencyMarker);
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/CollectorOutput.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/CollectorOutput.java
index e3bf9190350..159b3f28288 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/CollectorOutput.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/CollectorOutput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamElement;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.InstantiationUtil;
 import org.apache.flink.util.OutputTag;
 
@@ -43,6 +44,11 @@ public class CollectorOutput<T> implements Output<StreamRecord<T>> {
         list.add(mark);
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        list.add(streamStatus);
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         list.add(latencyMarker);
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/KeyedMultiInputStreamOperatorTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/KeyedMultiInputStreamOperatorTestHarness.java
new file mode 100644
index 00000000000..0c8cb44f9e9
--- /dev/null
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/KeyedMultiInputStreamOperatorTestHarness.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.util;
+
+import org.apache.flink.api.common.ExecutionConfig;
+import org.apache.flink.api.common.typeinfo.TypeInformation;
+import org.apache.flink.api.java.ClosureCleaner;
+import org.apache.flink.api.java.functions.KeySelector;
+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;
+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;
+
+/**
+ * A test harness for testing a {@link MultipleInputStreamOperator}.
+ *
+ * <p>This mock task provides the operator with a basic runtime context and allows pushing elements
+ * and watermarks into the operator. {@link java.util.Deque}s containing the emitted elements and
+ * watermarks can be retrieved. you are free to modify these.
+ */
+public class KeyedMultiInputStreamOperatorTestHarness<KEY, OUT>
+        extends MultiInputStreamOperatorTestHarness<OUT> {
+
+    public KeyedMultiInputStreamOperatorTestHarness(
+            StreamOperatorFactory<OUT> operator, TypeInformation<KEY> keyType) throws Exception {
+        this(operator, 1, 1, 0);
+        config.setStateKeySerializer(keyType.createSerializer(executionConfig));
+    }
+
+    public KeyedMultiInputStreamOperatorTestHarness(
+            StreamOperatorFactory<OUT> operatorFactory,
+            int maxParallelism,
+            int numSubtasks,
+            int subtaskIndex)
+            throws Exception {
+        super(operatorFactory, maxParallelism, numSubtasks, subtaskIndex);
+    }
+
+    public void setKeySelector(int idx, KeySelector<?, KEY> keySelector) {
+        ClosureCleaner.clean(keySelector, ExecutionConfig.ClosureCleanerLevel.RECURSIVE, false);
+        config.setStatePartitioner(idx, keySelector);
+    }
+}
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockOutput.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockOutput.java
index 8323906404b..c306e5752c4 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockOutput.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MockOutput.java
@@ -21,6 +21,7 @@ import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.util.InstantiationUtil;
 import org.apache.flink.util.OutputTag;
 
@@ -58,6 +59,11 @@ public class MockOutput<T> implements Output<StreamRecord<T>> {
         throw new RuntimeException("THIS MUST BE IMPLEMENTED");
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        throw new RuntimeException("THIS MUST BE IMPLEMENTED");
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         throw new RuntimeException();
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MultiInputStreamOperatorTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MultiInputStreamOperatorTestHarness.java
new file mode 100644
index 00000000000..baa737b5f4b
--- /dev/null
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/MultiInputStreamOperatorTestHarness.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.util;
+
+import org.apache.flink.streaming.api.operators.Input;
+import org.apache.flink.streaming.api.operators.MultipleInputStreamOperator;
+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;
+import org.apache.flink.streaming.api.watermark.Watermark;
+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
+
+/**
+ * A test harness for testing a {@link MultipleInputStreamOperator}.
+ *
+ * <p>This mock task provides the operator with a basic runtime context and allows pushing elements
+ * and watermarks into the operator. {@link java.util.Deque}s containing the emitted elements and
+ * watermarks can be retrieved. you are free to modify these.
+ */
+public class MultiInputStreamOperatorTestHarness<OUT>
+        extends AbstractStreamOperatorTestHarness<OUT> {
+
+    public MultiInputStreamOperatorTestHarness(StreamOperatorFactory<OUT> operator)
+            throws Exception {
+        this(operator, 1, 1, 0);
+    }
+
+    public MultiInputStreamOperatorTestHarness(
+            StreamOperatorFactory<OUT> operatorFactory,
+            int maxParallelism,
+            int numSubtasks,
+            int subtaskIndex)
+            throws Exception {
+        super(operatorFactory, maxParallelism, numSubtasks, subtaskIndex);
+    }
+
+    public void processElement(int idx, StreamRecord<?> element) throws Exception {
+        Input input = getCastedOperator().getInputs().get(idx);
+        input.setKeyContextElement(element);
+        input.processElement(element);
+    }
+
+    public void processWatermark(int idx, Watermark mark) throws Exception {
+        getCastedOperator().getInputs().get(idx).processWatermark(mark);
+    }
+
+    public void emitStreamStatus(int idx, StreamStatus streamStatus) throws Exception {
+        getCastedOperator().getInputs().get(idx).emitStreamStatus(streamStatus);
+    }
+
+    private MultipleInputStreamOperator<OUT> getCastedOperator() {
+        return (MultipleInputStreamOperator<OUT>) operator;
+    }
+}
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TwoInputStreamOperatorTestHarness.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TwoInputStreamOperatorTestHarness.java
index dd3eae29392..10c006cb1d7 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TwoInputStreamOperatorTestHarness.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/util/TwoInputStreamOperatorTestHarness.java
@@ -21,6 +21,7 @@ package org.apache.flink.streaming.util;
 import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 
 /**
  * A test harness for testing a {@link TwoInputStreamOperator}.
@@ -80,4 +81,12 @@ public class TwoInputStreamOperatorTestHarness<IN1, IN2, OUT>
         twoInputOperator.processWatermark1(mark);
         twoInputOperator.processWatermark2(mark);
     }
+
+    public void emitStreamStatus1(StreamStatus streamStatus) throws Exception {
+        twoInputOperator.emitStreamStatus1(streamStatus);
+    }
+
+    public void emitStreamStatus2(StreamStatus streamStatus) throws Exception {
+        twoInputOperator.emitStreamStatus2(streamStatus);
+    }
 }
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/FirstInputOfTwoInput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/FirstInputOfTwoInput.java
index 3773059f4e2..4dadb5a431f 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/FirstInputOfTwoInput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/FirstInputOfTwoInput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 
 /** {@link Input} for the first input of {@link TwoInputStreamOperator}. */
@@ -48,4 +49,9 @@ public class FirstInputOfTwoInput extends InputBase {
     public void processLatencyMarker(LatencyMarker latencyMarker) throws Exception {
         operator.processLatencyMarker1(latencyMarker);
     }
+
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+        operator.emitStreamStatus1(streamStatus);
+    }
 }
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/OneInput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/OneInput.java
index 5eae55d83fb..b434dbd5873 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/OneInput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/OneInput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 
 /** {@link Input} for {@link OneInputStreamOperator}. */
@@ -48,4 +49,9 @@ public class OneInput extends InputBase {
     public void processLatencyMarker(LatencyMarker latencyMarker) throws Exception {
         operator.processLatencyMarker(latencyMarker);
     }
+
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+        operator.emitStreamStatus(streamStatus);
+    }
 }
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/SecondInputOfTwoInput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/SecondInputOfTwoInput.java
index 5e6f735cf6c..1acdc324249 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/SecondInputOfTwoInput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/input/SecondInputOfTwoInput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 
 /** {@link Input} for the second input of {@link TwoInputStreamOperator}. */
@@ -48,4 +49,9 @@ public class SecondInputOfTwoInput extends InputBase {
     public void processLatencyMarker(LatencyMarker latencyMarker) throws Exception {
         operator.processLatencyMarker2(latencyMarker);
     }
+
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) throws Exception {
+        operator.emitStreamStatus2(streamStatus);
+    }
 }
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/BroadcastingOutput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/BroadcastingOutput.java
index 2c12fdcc26f..396e926e701 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/BroadcastingOutput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/BroadcastingOutput.java
@@ -22,6 +22,7 @@ import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.OperatorChain;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.util.OutputTag;
@@ -50,6 +51,13 @@ public class BroadcastingOutput implements Output<StreamRecord<RowData>> {
         }
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        for (Output<StreamRecord<RowData>> output : outputs) {
+            output.emitStreamStatus(streamStatus);
+        }
+    }
+
     @Override
     public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {
         for (Output<StreamRecord<RowData>> output : outputs) {
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/CopyingSecondInputOfTwoInputStreamOperatorOutput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/CopyingSecondInputOfTwoInputStreamOperatorOutput.java
index 947b607e454..eef6e00252f 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/CopyingSecondInputOfTwoInputStreamOperatorOutput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/CopyingSecondInputOfTwoInputStreamOperatorOutput.java
@@ -24,6 +24,7 @@ import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.util.OutputTag;
 
@@ -53,6 +54,15 @@ public class CopyingSecondInputOfTwoInputStreamOperatorOutput extends OutputBase
         }
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        try {
+            operator.emitStreamStatus2(streamStatus);
+        } catch (Exception e) {
+            throw new ExceptionInMultipleInputOperatorException(e);
+        }
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         try {
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/FirstInputOfTwoInputStreamOperatorOutput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/FirstInputOfTwoInputStreamOperatorOutput.java
index 820e784a53d..ed4fff124d7 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/FirstInputOfTwoInputStreamOperatorOutput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/FirstInputOfTwoInputStreamOperatorOutput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.util.OutputTag;
 
@@ -49,6 +50,15 @@ public class FirstInputOfTwoInputStreamOperatorOutput extends OutputBase {
         }
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        try {
+            operator.emitStreamStatus1(streamStatus);
+        } catch (Exception e) {
+            throw new ExceptionInMultipleInputOperatorException(e);
+        }
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         try {
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/OneInputStreamOperatorOutput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/OneInputStreamOperatorOutput.java
index bbf3c3f854f..f090dc7e638 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/OneInputStreamOperatorOutput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/OneInputStreamOperatorOutput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.util.OutputTag;
 
@@ -48,6 +49,15 @@ public class OneInputStreamOperatorOutput extends OutputBase {
         }
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        try {
+            operator.emitStreamStatus(streamStatus);
+        } catch (Exception e) {
+            throw new ExceptionInMultipleInputOperatorException(e);
+        }
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         try {
diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/SecondInputOfTwoInputStreamOperatorOutput.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/SecondInputOfTwoInputStreamOperatorOutput.java
index ad7e28c8123..499551329f9 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/SecondInputOfTwoInputStreamOperatorOutput.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/multipleinput/output/SecondInputOfTwoInputStreamOperatorOutput.java
@@ -23,6 +23,7 @@ import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.util.OutputTag;
 
@@ -49,6 +50,15 @@ public class SecondInputOfTwoInputStreamOperatorOutput extends OutputBase {
         }
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        try {
+            operator.emitStreamStatus2(streamStatus);
+        } catch (Exception e) {
+            throw new ExceptionInMultipleInputOperatorException(e);
+        }
+    }
+
     @Override
     public void emitLatencyMarker(LatencyMarker latencyMarker) {
         try {
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/multipleinput/output/BlackHoleOutput.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/multipleinput/output/BlackHoleOutput.java
index 961d4bea808..ddc6f19aab3 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/multipleinput/output/BlackHoleOutput.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/multipleinput/output/BlackHoleOutput.java
@@ -22,6 +22,7 @@ import org.apache.flink.streaming.api.operators.Output;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.util.OutputTag;
 
@@ -33,6 +34,11 @@ public class BlackHoleOutput implements Output<StreamRecord<RowData>> {
         // do nothing
     }
 
+    @Override
+    public void emitStreamStatus(StreamStatus streamStatus) {
+        // do nothing
+    }
+
     @Override
     public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {
         // do nothing
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/over/NonBufferOverWindowOperatorTest.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/over/NonBufferOverWindowOperatorTest.java
index d20dc160345..15343948031 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/over/NonBufferOverWindowOperatorTest.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/over/NonBufferOverWindowOperatorTest.java
@@ -24,6 +24,7 @@ import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.streaming.runtime.tasks.TestProcessingTimeService;
 import org.apache.flink.table.data.GenericRowData;
 import org.apache.flink.table.data.RowData;
@@ -183,6 +184,11 @@ public class NonBufferOverWindowOperatorTest {
             throw new RuntimeException();
         }
 
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) {
+            throw new RuntimeException();
+        }
+
         @Override
         public <X> void collect(OutputTag<X> outputTag, StreamRecord<X> record) {
             throw new RuntimeException();
diff --git a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/SortingBoundedInputITCase.java b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/SortingBoundedInputITCase.java
index cd640c169f6..607529838d1 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/SortingBoundedInputITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/SortingBoundedInputITCase.java
@@ -57,6 +57,7 @@ import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.transformations.KeyedMultipleInputTransformation;
 import org.apache.flink.streaming.runtime.streamrecord.LatencyMarker;
 import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.streaming.runtime.streamstatus.StreamStatus;
 import org.apache.flink.test.util.AbstractTestBase;
 import org.apache.flink.util.CollectionUtil;
 import org.apache.flink.util.Collector;
@@ -687,6 +688,9 @@ public class SortingBoundedInputITCase extends AbstractTestBase {
 
         @Override
         public void setKeyContextElement(StreamRecord<Tuple2<Integer, byte[]>> record) {}
+
+        @Override
+        public void emitStreamStatus(StreamStatus streamStatus) throws Exception {}
     }
 
     private static class InputGenerator extends SplittableIterator<Tuple2<Integer, byte[]>> {
