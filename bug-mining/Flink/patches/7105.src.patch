diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionService.java b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionService.java
index e6166dc4b58..2487bd15ad7 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionService.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionService.java
@@ -83,6 +83,9 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
     @GuardedBy("lock")
     private LeaderInformation confirmedLeaderInformation;
 
+    @GuardedBy("lock")
+    private boolean running;
+
     /**
      * {@code leaderElectionDriver} being {@code null} indicates that the connection to the
      * LeaderElection backend isn't established, yet. See {@link #startLeaderElectionBackend()} and
@@ -92,11 +95,18 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
      *
      * <p>{@code @Nullable} isn't used here to avoid having multiple warnings spread over this class
      * in a supporting IDE.
+     *
+     * <p>The driver is guarded by this instance's {@link #running} state.
      */
-    @GuardedBy("lock")
     private LeaderElectionDriver leaderElectionDriver;
 
-    @GuardedBy("lock")
+    /**
+     * This {@link ExecutorService} is used for running the leader event handling logic. Production
+     * code should rely on a single-threaded executor to ensure the sequential execution of the
+     * events.
+     *
+     * <p>The executor is guarded by this instance's {@link #running} state.
+     */
     private final ExecutorService leadershipOperationExecutor;
 
     public DefaultLeaderElectionService(LeaderElectionDriverFactory leaderElectionDriverFactory) {
@@ -122,6 +132,8 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
         this.confirmedLeaderInformation = LeaderInformation.empty();
 
         this.leadershipOperationExecutor = Preconditions.checkNotNull(leadershipOperationExecutor);
+
+        this.running = false;
     }
 
     /**
@@ -134,6 +146,11 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
             Preconditions.checkState(
                     leaderContender == null,
                     "No LeaderContender should have been registered, yet.");
+            Preconditions.checkState(
+                    leaderElectionDriver == null,
+                    "This DefaultLeaderElectionService cannot be reused. Calling startLeaderElectionBackend can only be called once to establish the connection to the HA backend.");
+
+            running = true;
 
             leaderElectionDriver =
                     leaderElectionDriverFactory.createLeaderElectionDriver(
@@ -152,7 +169,7 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
                     leaderContender == null,
                     "Only one LeaderContender is allowed to be registered to this service.");
             Preconditions.checkState(
-                    leaderElectionDriver != null,
+                    running,
                     "The DefaultLeaderElectionService should have established a connection to the backend before it's started.");
 
             leaderContender = contender;
@@ -207,31 +224,32 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
     @Override
     public void close() throws Exception {
         synchronized (lock) {
+            Preconditions.checkState(
+                    leaderElectionDriver != null, "The HA backend wasn't initialized.");
+
             Preconditions.checkState(
                     leaderContender == null,
                     "The DefaultLeaderElectionService should have been stopped before closing the instance.");
 
             issuedLeaderSessionID = null;
 
-            if (leaderElectionDriver != null) {
-                leaderElectionDriver.close();
-                leaderElectionDriver = null;
-
-                // The shutdown of the thread pool needs to be done forcefully because we want its
-                // lifecycle being coupled to the driver (which require it to be shut down within
-                // the lock) to allow null checks in runInLeaderEventThread method. The outstanding
-                // event handling callbacks are going to be ignored, anyway.
-                final List<Runnable> outstandingEventHandlingCalls =
-                        Preconditions.checkNotNull(leadershipOperationExecutor).shutdownNow();
-                if (!outstandingEventHandlingCalls.isEmpty()) {
-                    LOG.debug(
-                            "The DefaultLeaderElectionService was closed with {} event(s) still not being processed. No further action necessary.",
-                            outstandingEventHandlingCalls.size());
-                }
+            if (running) {
+                running = false;
             } else {
                 LOG.debug("The HA backend connection isn't established. No actions taken.");
             }
         }
+
+        leaderElectionDriver.close();
+
+        // interrupt any outstanding events
+        final List<Runnable> outstandingEventHandlingCalls =
+                Preconditions.checkNotNull(leadershipOperationExecutor).shutdownNow();
+        if (!outstandingEventHandlingCalls.isEmpty()) {
+            LOG.debug(
+                    "The DefaultLeaderElectionService was closed with {} event(s) still not being processed. No further action necessary.",
+                    outstandingEventHandlingCalls.size());
+        }
     }
 
     @Override
@@ -420,12 +438,14 @@ public class DefaultLeaderElectionService extends AbstractLeaderElectionService
 
     private void runInLeaderEventThread(Runnable callback) {
         synchronized (lock) {
-            if (!leadershipOperationExecutor.isShutdown()) {
+            if (running) {
                 FutureUtils.handleUncaughtException(
                         CompletableFuture.runAsync(
                                 () -> {
                                     synchronized (lock) {
-                                        callback.run();
+                                        if (running) {
+                                            callback.run();
+                                        }
                                     }
                                 },
                                 leadershipOperationExecutor),
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java
index 3938e20f05c..dcd12281654 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/DefaultLeaderElectionServiceTest.java
@@ -78,6 +78,63 @@ class DefaultLeaderElectionServiceTest {
         };
     }
 
+    @Test
+    void testCloseGrantDeadlock() throws Exception {
+        final OneShotLatch closeReachedLatch = new OneShotLatch();
+        final OneShotLatch closeContinueLatch = new OneShotLatch();
+        final OneShotLatch grantReachedLatch = new OneShotLatch();
+        final OneShotLatch grantContinueLatch = new OneShotLatch();
+
+        final TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory driverFactory =
+                new TestingLeaderElectionDriver.TestingLeaderElectionDriverFactory(
+                        eventHandler -> {},
+                        eventHandler -> {
+                            closeReachedLatch.trigger();
+                            closeContinueLatch.await();
+                        },
+                        leaderElectionEventHandler -> {
+                            grantReachedLatch.trigger();
+                            grantContinueLatch.awaitQuietly();
+                        });
+
+        final ManuallyTriggeredScheduledExecutorService executorService =
+                new ManuallyTriggeredScheduledExecutorService();
+        final DefaultLeaderElectionService testInstance =
+                new DefaultLeaderElectionService(driverFactory, executorService);
+        testInstance.startLeaderElectionBackend();
+        final TestingLeaderElectionDriver driver = driverFactory.getCurrentLeaderDriver();
+        assertThat(driver).isNotNull();
+
+        final Thread closeThread =
+                new Thread(
+                        () -> {
+                            try {
+                                testInstance.close();
+                            } catch (Exception e) {
+                                throw new RuntimeException(e);
+                            }
+                        },
+                        "CloseThread");
+
+        // triggers close that acquires the DefaultLeaderElectionService lock
+        closeThread.start();
+        closeReachedLatch.await();
+
+        final Thread grantThread = new Thread(driver::isLeader, "GrantThread");
+
+        // triggers the service acquiring the leadership and, as a consequence, acquiring the
+        // driver's lock
+        grantThread.start();
+        grantReachedLatch.await();
+
+        // continue both processes which shouldn't result in a deadlock
+        grantContinueLatch.trigger();
+        closeContinueLatch.trigger();
+
+        closeThread.join();
+        grantThread.join();
+    }
+
     /**
      * With {@link MultipleComponentLeaderElectionDriverAdapter} and {@link
      * DefaultMultipleComponentLeaderElectionService} it happens that {@link
@@ -239,6 +296,9 @@ class DefaultLeaderElectionServiceTest {
                                     new TestingContender("unused-address", leaderElection)
                                             .startLeaderElection())
                     .isInstanceOf(IllegalStateException.class);
+
+            // starting the backend because the close method expects it to be initialized
+            leaderElectionService.startLeaderElectionBackend();
         }
     }
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionDriver.java b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionDriver.java
index f3b4b9fd2c8..e7b411dd046 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionDriver.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/leaderelection/TestingLeaderElectionDriver.java
@@ -25,6 +25,7 @@ import javax.annotation.Nullable;
 
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
 
 /**
  * {@link LeaderElectionDriver} implementation which provides some convenience functions for testing
@@ -40,6 +41,9 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
     private final FatalErrorHandler fatalErrorHandler;
 
     private final ThrowingConsumer<LeaderElectionEventHandler, Exception> closeRunnable;
+    private final ThrowingConsumer<LeaderElectionEventHandler, Exception> beforeLockCloseRunnable;
+
+    private final Consumer<LeaderElectionEventHandler> beforeGrantRunnable;
 
     // Leader information on external storage
     private LeaderInformation leaderInformation = LeaderInformation.empty();
@@ -47,10 +51,14 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
     private TestingLeaderElectionDriver(
             LeaderElectionEventHandler leaderElectionEventHandler,
             FatalErrorHandler fatalErrorHandler,
-            ThrowingConsumer<LeaderElectionEventHandler, Exception> closeRunnable) {
+            ThrowingConsumer<LeaderElectionEventHandler, Exception> closeRunnable,
+            ThrowingConsumer<LeaderElectionEventHandler, Exception> beforeLockCloseRunnable,
+            Consumer<LeaderElectionEventHandler> beforeGrantRunnable) {
         this.leaderElectionEventHandler = leaderElectionEventHandler;
         this.fatalErrorHandler = fatalErrorHandler;
         this.closeRunnable = closeRunnable;
+        this.beforeLockCloseRunnable = beforeLockCloseRunnable;
+        this.beforeGrantRunnable = beforeGrantRunnable;
     }
 
     @Override
@@ -65,6 +73,7 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
 
     @Override
     public void close() throws Exception {
+        beforeLockCloseRunnable.accept(leaderElectionEventHandler);
         synchronized (lock) {
             closeRunnable.accept(leaderElectionEventHandler);
         }
@@ -77,6 +86,7 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
     public void isLeader(UUID newSessionID) {
         synchronized (lock) {
             isLeader.set(true);
+            beforeGrantRunnable.accept(leaderElectionEventHandler);
             leaderElectionEventHandler.onGrantLeadership(newSessionID);
         }
     }
@@ -107,6 +117,10 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
         private TestingLeaderElectionDriver currentLeaderDriver;
 
         private final ThrowingConsumer<LeaderElectionEventHandler, Exception> closeRunnable;
+        private final ThrowingConsumer<LeaderElectionEventHandler, Exception>
+                beforeLockCloseRunnable;
+
+        private final Consumer<LeaderElectionEventHandler> beforeGrantRunnable;
 
         public TestingLeaderElectionDriverFactory() {
             this(ignoredLeaderElectionEventHandler -> {});
@@ -114,7 +128,19 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
 
         public TestingLeaderElectionDriverFactory(
                 ThrowingConsumer<LeaderElectionEventHandler, Exception> closeRunnable) {
+            this(
+                    closeRunnable,
+                    ignoredLeaderElectionEventHandler -> {},
+                    ignoredLeaderElectionEventHandler -> {});
+        }
+
+        public TestingLeaderElectionDriverFactory(
+                ThrowingConsumer<LeaderElectionEventHandler, Exception> closeRunnable,
+                ThrowingConsumer<LeaderElectionEventHandler, Exception> beforeLockCloseRunnable,
+                Consumer<LeaderElectionEventHandler> beforeGrantRunnable) {
             this.closeRunnable = closeRunnable;
+            this.beforeLockCloseRunnable = beforeLockCloseRunnable;
+            this.beforeGrantRunnable = beforeGrantRunnable;
         }
 
         @Override
@@ -123,7 +149,11 @@ public class TestingLeaderElectionDriver implements LeaderElectionDriver {
                 FatalErrorHandler fatalErrorHandler) {
             currentLeaderDriver =
                     new TestingLeaderElectionDriver(
-                            leaderEventHandler, fatalErrorHandler, closeRunnable);
+                            leaderEventHandler,
+                            fatalErrorHandler,
+                            closeRunnable,
+                            beforeLockCloseRunnable,
+                            beforeGrantRunnable);
             return currentLeaderDriver;
         }
 
