diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointProperties.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointProperties.java
index c081e745dc6..138325aa03b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointProperties.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointProperties.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.runtime.checkpoint;
 
-import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.core.execution.SavepointFormatType;
 import org.apache.flink.runtime.jobgraph.RestoreMode;
@@ -57,8 +56,7 @@ public class CheckpointProperties implements Serializable {
 
     private final boolean unclaimed;
 
-    @VisibleForTesting
-    CheckpointProperties(
+    public CheckpointProperties(
             boolean forced,
             SnapshotType checkpointType,
             boolean discardSubsumed,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
index cc97510cc6a..5443301363b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/Checkpoints.java
@@ -24,7 +24,7 @@ import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
 import org.apache.flink.runtime.checkpoint.metadata.MetadataSerializer;
 import org.apache.flink.runtime.checkpoint.metadata.MetadataSerializers;
-import org.apache.flink.runtime.checkpoint.metadata.MetadataV3Serializer;
+import org.apache.flink.runtime.checkpoint.metadata.MetadataV4Serializer;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
@@ -85,12 +85,20 @@ public class Checkpoints {
 
     public static void storeCheckpointMetadata(
             CheckpointMetadata checkpointMetadata, DataOutputStream out) throws IOException {
+        storeCheckpointMetadata(checkpointMetadata, out, MetadataV4Serializer.INSTANCE);
+    }
+
+    public static void storeCheckpointMetadata(
+            CheckpointMetadata checkpointMetadata,
+            DataOutputStream out,
+            MetadataSerializer serializer)
+            throws IOException {
 
         // write generic header
         out.writeInt(HEADER_MAGIC_NUMBER);
 
-        out.writeInt(MetadataV3Serializer.VERSION);
-        MetadataV3Serializer.serialize(checkpointMetadata, out);
+        out.writeInt(serializer.getVersion());
+        serializer.serialize(checkpointMetadata, out);
     }
 
     // ------------------------------------------------------------------------
@@ -216,7 +224,8 @@ public class Checkpoints {
                 restoreMode == RestoreMode.CLAIM
                         ? new ClaimModeCompletedStorageLocation(location)
                         : location,
-                null);
+                null,
+                checkpointMetadata.getCheckpointProperties());
     }
 
     private static void throwNonRestoredStateException(
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
index f0270ab661a..7b268c244db 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CompletedCheckpoint.java
@@ -42,6 +42,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 
 import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -93,9 +94,15 @@ public class CompletedCheckpoint implements Serializable, Checkpoint {
     /** States of the different operator groups belonging to this checkpoint. */
     private final Map<OperatorID, OperatorState> operatorStates;
 
-    /** Properties for this checkpoint. */
+    /** Properties of this checkpoint. Might change during recovery. */
     private final CheckpointProperties props;
 
+    /**
+     * Properties of this checkpoint as they were during checkpoint creation. Might be null for
+     * older versions.
+     */
+    @Nullable private final CheckpointProperties restoredProps;
+
     /** States that were created by a hook on the master (in the checkpoint coordinator). */
     private final Collection<MasterState> masterHookStates;
 
@@ -123,6 +130,30 @@ public class CompletedCheckpoint implements Serializable, Checkpoint {
             CheckpointProperties props,
             CompletedCheckpointStorageLocation storageLocation,
             @Nullable CompletedCheckpointStats completedCheckpointStats) {
+        this(
+                job,
+                checkpointID,
+                timestamp,
+                completionTimestamp,
+                operatorStates,
+                masterHookStates,
+                props,
+                storageLocation,
+                completedCheckpointStats,
+                null);
+    }
+
+    public CompletedCheckpoint(
+            JobID job,
+            long checkpointID,
+            long timestamp,
+            long completionTimestamp,
+            Map<OperatorID, OperatorState> operatorStates,
+            @Nullable Collection<MasterState> masterHookStates,
+            CheckpointProperties props,
+            CompletedCheckpointStorageLocation storageLocation,
+            @Nullable CompletedCheckpointStats completedCheckpointStats,
+            @Nullable CheckpointProperties restoredProps) {
 
         checkArgument(checkpointID >= 0);
         checkArgument(timestamp >= 0);
@@ -146,6 +177,7 @@ public class CompletedCheckpoint implements Serializable, Checkpoint {
         this.metadataHandle = storageLocation.getMetadataHandle();
         this.externalPointer = storageLocation.getExternalPointer();
         this.completedCheckpointStats = completedCheckpointStats;
+        this.restoredProps = restoredProps;
     }
 
     // ------------------------------------------------------------------------
@@ -173,6 +205,10 @@ public class CompletedCheckpoint implements Serializable, Checkpoint {
         return props;
     }
 
+    public Optional<CheckpointProperties> getRestoredProperties() {
+        return Optional.ofNullable(restoredProps);
+    }
+
     public Map<OperatorID, OperatorState> getOperatorStates() {
         return operatorStates;
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
index 8ca6e22020e..1ae20634b80 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/PendingCheckpoint.java
@@ -324,7 +324,8 @@ public class PendingCheckpoint implements Checkpoint {
 
                 // write out the metadata
                 final CheckpointMetadata savepoint =
-                        new CheckpointMetadata(checkpointId, operatorStates.values(), masterStates);
+                        new CheckpointMetadata(
+                                checkpointId, operatorStates.values(), masterStates, props);
                 final CompletedCheckpointStorageLocation finalizedLocation;
 
                 try (CheckpointMetadataOutputStream out =
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/CheckpointMetadata.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/CheckpointMetadata.java
index 910cf89c986..b4bceaa22ad 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/CheckpointMetadata.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/CheckpointMetadata.java
@@ -18,10 +18,13 @@
 
 package org.apache.flink.runtime.checkpoint.metadata;
 
+import org.apache.flink.runtime.checkpoint.CheckpointProperties;
 import org.apache.flink.runtime.checkpoint.MasterState;
 import org.apache.flink.runtime.checkpoint.OperatorState;
 import org.apache.flink.util.Disposable;
 
+import javax.annotation.Nullable;
+
 import java.util.Collection;
 
 import static org.apache.flink.util.Preconditions.checkNotNull;
@@ -38,13 +41,25 @@ public class CheckpointMetadata implements Disposable {
     /** The states generated by the CheckpointCoordinator. */
     private final Collection<MasterState> masterStates;
 
+    // null when restored from an older version
+    @Nullable private final CheckpointProperties properties;
+
     public CheckpointMetadata(
             long checkpointId,
             Collection<OperatorState> operatorStates,
             Collection<MasterState> masterStates) {
+        this(checkpointId, operatorStates, masterStates, null);
+    }
+
+    public CheckpointMetadata(
+            long checkpointId,
+            Collection<OperatorState> operatorStates,
+            Collection<MasterState> masterStates,
+            @Nullable CheckpointProperties properties) {
         this.checkpointId = checkpointId;
         this.operatorStates = operatorStates;
         this.masterStates = checkNotNull(masterStates, "masterStates");
+        this.properties = properties;
     }
 
     public long getCheckpointId() {
@@ -72,4 +87,14 @@ public class CheckpointMetadata implements Disposable {
     public String toString() {
         return "Checkpoint Metadata";
     }
+
+    @Nullable
+    public CheckpointProperties getCheckpointProperties() {
+        return properties;
+    }
+
+    public CheckpointMetadata withProperties(CheckpointProperties properties) {
+        return new CheckpointMetadata(
+                this.checkpointId, this.operatorStates, this.masterStates, properties);
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializer.java
index ca944c77b68..543b2c5fc5b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializer.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.checkpoint.metadata;
 import org.apache.flink.core.io.Versioned;
 
 import java.io.DataInputStream;
+import java.io.DataOutputStream;
 import java.io.IOException;
 
 /**
@@ -43,4 +44,11 @@ public interface MetadataSerializer extends Versioned {
     CheckpointMetadata deserialize(
             DataInputStream dis, ClassLoader userCodeClassLoader, String externalPointer)
             throws IOException;
+
+    /**
+     * Serializes a savepoint or checkpoint metadata to an output stream.
+     *
+     * @throws IOException Serialization failures are forwarded
+     */
+    void serialize(CheckpointMetadata checkpointMetadata, DataOutputStream dos) throws IOException;
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializers.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializers.java
index 087b48edeba..eb27d11550a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializers.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataSerializers.java
@@ -28,12 +28,13 @@ import java.util.Map;
  */
 public class MetadataSerializers {
 
-    private static final Map<Integer, MetadataSerializer> SERIALIZERS = new HashMap<>(3);
+    private static final Map<Integer, MetadataSerializer> SERIALIZERS = new HashMap<>(4);
 
     static {
         registerSerializer(MetadataV1Serializer.INSTANCE);
         registerSerializer(MetadataV2Serializer.INSTANCE);
         registerSerializer(MetadataV3Serializer.INSTANCE);
+        registerSerializer(MetadataV4Serializer.INSTANCE);
     }
 
     private static void registerSerializer(MetadataSerializer serializer) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV1Serializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV1Serializer.java
index c0c000c9c52..d1e0075f7ae 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV1Serializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV1Serializer.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.checkpoint.metadata;
 import org.apache.flink.annotation.Internal;
 
 import java.io.DataInputStream;
+import java.io.DataOutputStream;
 import java.io.IOException;
 
 /**
@@ -49,4 +50,11 @@ public class MetadataV1Serializer implements MetadataSerializer {
         throw new IOException(
                 "This savepoint / checkpoint version (Flink 1.1 / 1.2) is no longer supported.");
     }
+
+    @Override
+    public void serialize(CheckpointMetadata checkpointMetadata, DataOutputStream dos)
+            throws IOException {
+        throw new UnsupportedOperationException(
+                "Serialization in v" + getVersion() + " is no longer supported");
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV2Serializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV2Serializer.java
index f8a0bcfad8f..49f6f3a3e2e 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV2Serializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV2Serializer.java
@@ -66,6 +66,13 @@ public class MetadataV2Serializer extends MetadataV2V3SerializerBase implements
         return deserializeMetadata(dis, externalPointer);
     }
 
+    @Override
+    public void serialize(CheckpointMetadata checkpointMetadata, DataOutputStream dos)
+            throws IOException {
+        throw new UnsupportedOperationException(
+                "Serialization in v" + getVersion() + " is no longer supported");
+    }
+
     // ------------------------------------------------------------------------
     //  version-specific serialization
     // ------------------------------------------------------------------------
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3Serializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3Serializer.java
index 843a5e00f74..83b5201e5ec 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3Serializer.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3Serializer.java
@@ -77,7 +77,8 @@ public class MetadataV3Serializer extends MetadataV2V3SerializerBase implements
     //  (De)serialization entry points
     // ------------------------------------------------------------------------
 
-    public static void serialize(CheckpointMetadata checkpointMetadata, DataOutputStream dos)
+    @Override
+    public void serialize(CheckpointMetadata checkpointMetadata, DataOutputStream dos)
             throws IOException {
         INSTANCE.serializeMetadata(checkpointMetadata, dos);
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV4Serializer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV4Serializer.java
new file mode 100644
index 00000000000..758e03a7ecb
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV4Serializer.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.checkpoint.metadata;
+
+import org.apache.flink.annotation.Internal;
+import org.apache.flink.runtime.checkpoint.CheckpointProperties;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+/**
+ * V4 serializer that adds {@link org.apache.flink.runtime.checkpoint.CheckpointProperties}
+ * serialization.
+ */
+@Internal
+public class MetadataV4Serializer implements MetadataSerializer {
+
+    public static final MetadataSerializer INSTANCE = new MetadataV4Serializer();
+    public static final int VERSION = 4;
+
+    @Override
+    public int getVersion() {
+        return VERSION;
+    }
+
+    @Override
+    public CheckpointMetadata deserialize(
+            DataInputStream dis, ClassLoader userCodeClassLoader, String externalPointer)
+            throws IOException {
+        return MetadataV3Serializer.INSTANCE
+                .deserialize(dis, userCodeClassLoader, externalPointer)
+                .withProperties(deserializeProperties(dis));
+    }
+
+    @Override
+    public void serialize(CheckpointMetadata checkpointMetadata, DataOutputStream dos)
+            throws IOException {
+        MetadataV3Serializer.INSTANCE.serialize(checkpointMetadata, dos);
+        serializeProperties(checkpointMetadata.getCheckpointProperties(), dos);
+    }
+
+    private CheckpointProperties deserializeProperties(DataInputStream dis) throws IOException {
+        try {
+            // closed outside
+            return (CheckpointProperties) new ObjectInputStream(dis).readObject();
+        } catch (ClassNotFoundException e) {
+            throw new IOException("Couldn't deserialize checkpoint properties", e);
+        }
+    }
+
+    private static void serializeProperties(CheckpointProperties properties, DataOutputStream dos)
+            throws IOException {
+        new ObjectOutputStream(dos).writeObject(properties); // closed outside
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistry.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistry.java
index 07b0b6010a6..097e7f12da8 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistry.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistry.java
@@ -44,6 +44,15 @@ public interface SharedStateRegistry extends AutoCloseable {
                 return sharedStateRegistry;
             };
 
+    /**
+     * Shortcut for {@link #registerReference(SharedStateRegistryKey, StreamStateHandle, long,
+     * boolean)} with preventDiscardingCreatedCheckpoint = false.
+     */
+    default StreamStateHandle registerReference(
+            SharedStateRegistryKey registrationKey, StreamStateHandle state, long checkpointID) {
+        return registerReference(registrationKey, state, checkpointID, false);
+    }
+
     /**
      * Register a reference to the given shared state in the registry. If there is already a state
      * handle registered under the given key, the "new" state handle is disposed .
@@ -54,11 +63,16 @@ public interface SharedStateRegistry extends AutoCloseable {
      *
      * @param state the shared state for which we register a reference.
      * @param checkpointID which uses the state
+     * @param preventDiscardingCreatedCheckpoint as long as this state is still in use. The
+     *     "checkpoint that created the state" is recorded on the first state registration.
      * @return the result of this registration request, consisting of the state handle that is
      *     registered under the key by the end of the operation and its current reference count.
      */
     StreamStateHandle registerReference(
-            SharedStateRegistryKey registrationKey, StreamStateHandle state, long checkpointID);
+            SharedStateRegistryKey registrationKey,
+            StreamStateHandle state,
+            long checkpointID,
+            boolean preventDiscardingCreatedCheckpoint);
 
     /**
      * Unregister state that is not referenced by the given checkpoint ID or any newer.
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistryImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistryImpl.java
index 83848d88fee..2e16c528997 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistryImpl.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/SharedStateRegistryImpl.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.state;
 import org.apache.flink.annotation.Internal;
 import org.apache.flink.core.fs.FSDataInputStream;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
+import org.apache.flink.runtime.checkpoint.SnapshotType.SharingFilesStrategy;
 import org.apache.flink.runtime.jobgraph.RestoreMode;
 import org.apache.flink.util.concurrent.Executors;
 
@@ -40,6 +41,7 @@ import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 
+import static org.apache.flink.runtime.checkpoint.SnapshotType.SharingFilesStrategy.NO_SHARING;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
 
@@ -52,6 +54,9 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
     /** All registered state objects by an artificial key */
     private final Map<SharedStateRegistryKey, SharedStateEntry> registeredStates;
 
+    private final Map<Long, Optional<SharingFilesStrategy>> restoredCheckpointSharingStrategies =
+            new HashMap<>();
+
     /** This flag indicates whether or not the registry is open or if close() was called */
     private boolean open;
 
@@ -72,8 +77,12 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
         this.open = true;
     }
 
+    @Override
     public StreamStateHandle registerReference(
-            SharedStateRegistryKey registrationKey, StreamStateHandle state, long checkpointID) {
+            SharedStateRegistryKey registrationKey,
+            StreamStateHandle state,
+            long checkpointID,
+            boolean preventDiscardingCreatedCheckpoint) {
 
         checkNotNull(state);
 
@@ -135,6 +144,9 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
                         entry.lastUsedCheckpointID,
                         checkpointID);
                 entry.advanceLastUsingCheckpointID(checkpointID);
+                if (preventDiscardingCreatedCheckpoint) {
+                    entry.preventDiscardingCreatedCheckpoint();
+                }
             }
         }
 
@@ -162,7 +174,14 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
                         subsumed.add(entry.stateHandle);
                     }
                     it.remove();
-                } else {
+                } else if (preventsDiscardingCreatedCheckpoint(entry)) {
+                    // Newly created checkpoints can be discarded right after subsumption. But the
+                    // initial checkpoint needs to be kept until all of its private AND shared state
+                    // is not in use. This is to enable recovery in CLAIM mode from:
+                    // - native incremental savepoints
+                    // - non-changelog checkpoints with changelog enabled
+                    // Keeping any checkpoint for longer leaves its folder undeleted on job
+                    // cancellation (and also on crash or JM failover).
                     checkpointInUse.add(entry.createdByCheckpointID);
                 }
             }
@@ -192,6 +211,11 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
     @Override
     public void registerAllAfterRestored(CompletedCheckpoint checkpoint, RestoreMode mode) {
         registerAll(checkpoint.getOperatorStates().values(), checkpoint.getCheckpointID());
+        restoredCheckpointSharingStrategies.put(
+                checkpoint.getCheckpointID(),
+                checkpoint
+                        .getRestoredProperties()
+                        .map(props -> props.getCheckpointType().getSharingFilesStrategy()));
         // In NO_CLAIM and LEGACY restore modes, shared state of the initial checkpoints must be
         // preserved. This is achieved by advancing highestRetainCheckpointID here, and then
         // checking entry.createdByCheckpointID against it on checkpoint subsumption.
@@ -277,6 +301,12 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
     /** An entry in the registry, tracking the handle and the corresponding reference count. */
     private static final class SharedStateEntry {
 
+        /**
+         * Whether usage of this state should prevent deletion of the checkpoint that created this
+         * state.
+         */
+        private boolean preventDiscardingCreatedCheckpoint = false;
+
         /** The shared state handle */
         StreamStateHandle stateHandle;
 
@@ -308,6 +338,14 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
         private void advanceLastUsingCheckpointID(long checkpointID) {
             lastUsedCheckpointID = Math.max(checkpointID, lastUsedCheckpointID);
         }
+
+        private void preventDiscardingCreatedCheckpoint() {
+            // Changed from false to true when a newer checkpoint starts reusing this state entry
+            // after recovery. This is to delay discarding the checkpoint until all of its
+            // state (both shared and private) is not used. That allows to handle transition from
+            // changelog off to on in CLAIM mode.
+            this.preventDiscardingCreatedCheckpoint = true;
+        }
     }
 
     /** An object with empty discardState for registering. */
@@ -365,4 +403,24 @@ public class SharedStateRegistryImpl implements SharedStateRegistry {
             return "EmptyDiscardStateObject{" + stateHandleID + '}';
         }
     }
+
+    private boolean preventsDiscardingCreatedCheckpoint(SharedStateEntry entry) {
+        // explicitly set by the backend, e.g. private state is reused
+        if (entry.preventDiscardingCreatedCheckpoint
+                && restoredCheckpointSharingStrategies.containsKey(entry.createdByCheckpointID)) {
+            return true;
+        }
+        // With NO_SHARING strategy, shared state, if any, is bundled inside the checkpoint folder.
+        // So the folder deletion should be delayed as long as some shared state is still in use.
+        // That allows to recover from Incremental RocksDB Native Savepoint in CLAIM mode.
+        // noinspection RedundantIfStatement
+        if (restoredCheckpointSharingStrategies
+                .getOrDefault(entry.createdByCheckpointID, Optional.empty())
+                .filter(sharingFilesStrategy -> sharingFilesStrategy == NO_SHARING)
+                .isPresent()) {
+            return true;
+        }
+
+        return false;
+    }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java b/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java
index 77d2608e755..51433d10503 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/state/changelog/ChangelogStateBackendHandle.java
@@ -183,7 +183,8 @@ public interface ChangelogStateBackendHandle
                 stateRegistry.registerReference(
                         new SharedStateRegistryKey(keyedStateHandle.getStateHandleId().toString()),
                         new StreamStateHandleWrapper(keyedStateHandle),
-                        checkpointID);
+                        checkpointID,
+                        true);
             }
             stateRegistry.registerAll(materialized, checkpointID);
             stateRegistry.registerAll(nonMaterialized, checkpointID);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointsTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointsTest.java
new file mode 100644
index 00000000000..e02eee8f7e4
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointsTest.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.checkpoint;
+
+import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
+import org.apache.flink.runtime.checkpoint.metadata.MetadataV3Serializer;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import static java.util.Collections.emptyList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+/** {@link Checkpoints} test. */
+public class CheckpointsTest {
+
+    @Test
+    public void testVersion3Compatibility() throws IOException {
+        CheckpointMetadata metadata = new CheckpointMetadata(1L, emptyList(), emptyList(), null);
+        try (ByteArrayOutputStream out = new ByteArrayOutputStream();
+                DataOutputStream dos = new DataOutputStream(out)) {
+
+            Checkpoints.storeCheckpointMetadata(metadata, dos, MetadataV3Serializer.INSTANCE);
+
+            try (DataInputStream dis =
+                    new DataInputStream(new ByteArrayInputStream(out.toByteArray()))) {
+                CheckpointMetadata deserialized =
+                        Checkpoints.loadCheckpointMetadata(
+                                // deserializer is chosen according to the version
+                                // written into the data
+                                dis, metadata.getClass().getClassLoader(), "");
+
+                assertNull(deserialized.getCheckpointProperties());
+                assertEquals(metadata.getCheckpointId(), deserialized.getCheckpointId());
+                assertEquals(metadata.getOperatorStates(), deserialized.getOperatorStates());
+                assertEquals(metadata.getMasterStates(), deserialized.getMasterStates());
+            }
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3SerializerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3SerializerTest.java
index 80b4e4ed32a..81f6232102e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3SerializerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV3SerializerTest.java
@@ -220,7 +220,7 @@ public class MetadataV3SerializerTest {
 
         CheckpointMetadata metadata =
                 new CheckpointMetadata(checkpointId, operatorStates, masterStates);
-        MetadataV3Serializer.serialize(metadata, out);
+        MetadataV3Serializer.INSTANCE.serialize(metadata, out);
         out.close();
 
         // The relative pointer resolution in MetadataV2V3SerializerBase currently runs the same
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV4SerializerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV4SerializerTest.java
new file mode 100644
index 00000000000..0acc6214d32
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/metadata/MetadataV4SerializerTest.java
@@ -0,0 +1,61 @@
+package org.apache.flink.runtime.checkpoint.metadata;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.flink.core.execution.SavepointFormatType;
+import org.apache.flink.runtime.checkpoint.CheckpointProperties;
+
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import static java.util.Collections.emptyList;
+import static org.junit.Assert.assertEquals;
+
+/** {@link MetadataV4Serializer} test. */
+public class MetadataV4SerializerTest {
+
+    @Test
+    public void testSerializeProperties() throws IOException {
+        CheckpointMetadata metadata =
+                new CheckpointMetadata(
+                        1L,
+                        emptyList(),
+                        emptyList(),
+                        CheckpointProperties.forSavepoint(false, SavepointFormatType.NATIVE));
+
+        MetadataSerializer instance = MetadataV4Serializer.INSTANCE;
+
+        try (ByteArrayOutputStream out = new ByteArrayOutputStream();
+                DataOutputStream dos = new DataOutputStream(out)) {
+            instance.serialize(metadata, dos);
+
+            try (DataInputStream dis =
+                    new DataInputStream(new ByteArrayInputStream(out.toByteArray()))) {
+                assertEquals(
+                        metadata.getCheckpointProperties(),
+                        instance.deserialize(dis, metadata.getClass().getClassLoader(), "")
+                                .getCheckpointProperties());
+            }
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
index 795e1fb03d9..625b3a8ea64 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/state/SharedStateRegistryTest.java
@@ -18,19 +18,30 @@
 
 package org.apache.flink.runtime.state;
 
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.core.execution.SavepointFormatType;
 import org.apache.flink.core.fs.FSDataInputStream;
+import org.apache.flink.runtime.checkpoint.CheckpointProperties;
+import org.apache.flink.runtime.checkpoint.CompletedCheckpoint;
+import org.apache.flink.runtime.checkpoint.OperatorState;
+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
+import org.apache.flink.runtime.jobgraph.OperatorID;
+import org.apache.flink.runtime.jobgraph.RestoreMode;
 import org.apache.flink.runtime.state.changelog.ChangelogStateBackendHandle.ChangelogStateBackendHandleImpl;
+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
+import org.apache.flink.runtime.state.testutils.TestCompletedCheckpointStorageLocation;
 
 import org.junit.Test;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.Optional;
-import java.util.Set;
+import java.util.UUID;
 
+import static java.util.Collections.singleton;
 import static junit.framework.TestCase.assertFalse;
+import static org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION;
+import static org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy.RETAIN_ON_CANCELLATION;
 import static org.apache.flink.runtime.state.ChangelogTestUtils.ChangelogStateHandleWrapper;
 import static org.apache.flink.runtime.state.ChangelogTestUtils.IncrementalStateHandleWrapper;
 import static org.apache.flink.runtime.state.ChangelogTestUtils.createDummyChangelogStateHandle;
@@ -39,6 +50,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 public class SharedStateRegistryTest {
+    private static final String RESTORED_STATE_ID = "restored-state";
 
     /** Validate that all states can be correctly registered at the registry. */
     @Test
@@ -182,20 +194,126 @@ public class SharedStateRegistryTest {
     }
 
     @Test
-    public void testUnregisterUnusedState() {
+    public void testUnregisterUnusedSavepointState() {
         SharedStateRegistry sharedStateRegistry = new SharedStateRegistryImpl();
         TestingStreamStateHandle handle = new TestingStreamStateHandle();
-        sharedStateRegistry.registerReference(new SharedStateRegistryKey("first"), handle, 1L);
-        sharedStateRegistry.registerReference(new SharedStateRegistryKey("first"), handle, 2L);
-        sharedStateRegistry.registerReference(new SharedStateRegistryKey("first"), handle, 3L);
+
+        registerInitialCheckpoint(
+                sharedStateRegistry,
+                RESTORED_STATE_ID,
+                CheckpointProperties.forSavepoint(false, SavepointFormatType.NATIVE));
+
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey(RESTORED_STATE_ID), handle, 2L);
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey(RESTORED_STATE_ID), handle, 3L);
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey("new-state"), new TestingStreamStateHandle(), 4L);
+
+        assertEquals(
+                "Only the initial checkpoint should be retained because its state is in use",
+                singleton(1L),
+                sharedStateRegistry.unregisterUnusedState(3));
+        assertTrue(
+                "The initial checkpoint state is unused so it could be discarded",
+                sharedStateRegistry.unregisterUnusedState(4).isEmpty());
+    }
+
+    @Test
+    public void testUnregisterNonInitialCheckpoint() {
+        SharedStateRegistry sharedStateRegistry = new SharedStateRegistryImpl();
+
         sharedStateRegistry.registerReference(
-                new SharedStateRegistryKey("second"), new TestingStreamStateHandle(), 4L);
-        Set<Long> stillInUse = sharedStateRegistry.unregisterUnusedState(3);
-        Set<Long> expectedInUse = new HashSet<>(Arrays.asList(1L, 4L));
-        assertEquals(expectedInUse, stillInUse);
+                new SharedStateRegistryKey("stateId"), new TestingStreamStateHandle(), 1L);
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey("stateId"), new TestingStreamStateHandle(), 2L);
+        assertTrue(
+                "First (non-initial) checkpoint could be discarded",
+                sharedStateRegistry.unregisterUnusedState(2).isEmpty());
+    }
+
+    @Test
+    public void testUnregisterInitialCheckpoint() {
+        SharedStateRegistry sharedStateRegistry = new SharedStateRegistryImpl();
+        TestingStreamStateHandle handle = new TestingStreamStateHandle();
+
+        registerInitialCheckpoint(
+                sharedStateRegistry,
+                RESTORED_STATE_ID,
+                CheckpointProperties.forCheckpoint(RETAIN_ON_CANCELLATION));
+
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey(RESTORED_STATE_ID), handle, 2L);
+
+        assertTrue(
+                "(retained) checkpoint - should NOT be considered in use even if its state is in use",
+                sharedStateRegistry.unregisterUnusedState(2).isEmpty());
+    }
+
+    /** Emulate turning changelog on while recovering from a retained checkpoint. */
+    @Test
+    public void testUnregisterInitialCheckpointUsedInChangelog() {
+        SharedStateRegistry sharedStateRegistry = new SharedStateRegistryImpl();
+        TestingStreamStateHandle handle = new TestingStreamStateHandle();
+
+        // "normal" restored checkpoint
+        registerInitialCheckpoint(
+                sharedStateRegistry,
+                RESTORED_STATE_ID,
+                CheckpointProperties.forCheckpoint(RETAIN_ON_CANCELLATION));
+
+        // "changelog" checkpoint wrapping some initial state
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey(RESTORED_STATE_ID),
+                handle,
+                2L,
+                true /* should prevent deletion */);
+
+        sharedStateRegistry.registerReference(
+                new SharedStateRegistryKey(RESTORED_STATE_ID),
+                handle,
+                3L,
+                false /* should NOT change anything - deletion should still be prevented */);
+
+        assertEquals(
+                "(retained) checkpoint - should be considered in use as long as its state is in use by changelog",
+                singleton(1L),
+                sharedStateRegistry.unregisterUnusedState(3));
+    }
 
-        stillInUse = sharedStateRegistry.unregisterUnusedState(4);
-        assertEquals(Collections.singleton(4L), stillInUse);
+    private void registerInitialCheckpoint(
+            SharedStateRegistry sharedStateRegistry,
+            String stateId,
+            CheckpointProperties properties) {
+        IncrementalRemoteKeyedStateHandle initialHandle =
+                IncrementalRemoteKeyedStateHandle.restore(
+                        UUID.randomUUID(),
+                        KeyGroupRange.EMPTY_KEY_GROUP_RANGE,
+                        1L,
+                        Collections.emptyMap(),
+                        Collections.emptyMap(),
+                        new ByteStreamStateHandle("meta", new byte[1]),
+                        1024L,
+                        new StateHandleID(stateId));
+
+        OperatorID operatorID = new OperatorID();
+        OperatorState operatorState = new OperatorState(operatorID, 1, 1);
+        operatorState.putState(
+                0, OperatorSubtaskState.builder().setManagedKeyedState(initialHandle).build());
+
+        sharedStateRegistry.registerAllAfterRestored(
+                new CompletedCheckpoint(
+                        new JobID(),
+                        1L,
+                        1L,
+                        1L,
+                        Collections.singletonMap(operatorID, operatorState),
+                        Collections.emptyList(),
+                        CheckpointProperties.forCheckpoint(NEVER_RETAIN_AFTER_TERMINATION),
+                        new TestCompletedCheckpointStorageLocation(),
+                        null,
+                        properties),
+                RestoreMode.DEFAULT);
     }
 
     private static class TestSharedState implements TestStreamStateHandle {
