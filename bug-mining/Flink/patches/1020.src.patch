diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java
index d6bfc02e51f..a2a38d49e23 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java
@@ -56,7 +56,7 @@ import org.apache.flink.streaming.api.functions.source.FilePathFilter;
 import org.apache.flink.streaming.api.functions.source.FileReadFunction;
 import org.apache.flink.streaming.api.functions.source.ContinuousFileMonitoringFunction;
 import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;
-import org.apache.flink.streaming.api.functions.source.InputFormatSource;
+import org.apache.flink.streaming.api.functions.source.InputFormatSourceFunction;
 import org.apache.flink.streaming.api.functions.source.FromElementsFunction;
 import org.apache.flink.streaming.api.functions.source.FromIteratorFunction;
 import org.apache.flink.streaming.api.functions.source.FromSplittableIteratorFunction;
@@ -1215,7 +1215,7 @@ public abstract class StreamExecutionEnvironment {
 													TypeInformation<OUT> typeInfo,
 													String sourceName) {
 
-		InputFormatSource<OUT> function = new InputFormatSource<>(inputFormat, typeInfo);
+		InputFormatSourceFunction<OUT> function = new InputFormatSourceFunction<>(inputFormat, typeInfo);
 		return addSource(function, sourceName, typeInfo);
 	}
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
index 4d4a792ebc1..e26c5343165 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/ContinuousFileReaderOperator.java
@@ -97,7 +97,9 @@ public class ContinuousFileReaderOperator<OUT, S extends Serializable> extends A
 				"Please report it.");
 		}
 
+		this.format.setRuntimeContext(getRuntimeContext());
 		this.format.configure(new Configuration());
+
 		this.collector = new TimestampedCollector<>(output);
 		this.checkpointLock = getContainingTask().getCheckpointLock();
 
@@ -230,9 +232,13 @@ public class ContinuousFileReaderOperator<OUT, S extends Serializable> extends A
 		@Override
 		public void run() {
 			try {
+
+				this.format.openInputFormat();
+
 				while (this.isRunning) {
 
 					synchronized (checkpointLock) {
+
 						if (this.currentSplit != null) {
 
 							if (currentSplit.equals(EOS)) {
@@ -297,6 +303,8 @@ public class ContinuousFileReaderOperator<OUT, S extends Serializable> extends A
 			} finally {
 				synchronized (checkpointLock) {
 					LOG.info("Reader terminated, and exiting...");
+					this.format.closeInputFormat();
+					this.isRunning = false;
 					checkpointLock.notifyAll();
 				}
 			}
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/InputFormatSource.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/InputFormatSourceFunction.java
similarity index 75%
rename from flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/InputFormatSource.java
rename to flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/InputFormatSourceFunction.java
index 2a84781bc91..bce1ec5fa00 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/InputFormatSource.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/source/InputFormatSourceFunction.java
@@ -19,6 +19,7 @@ package org.apache.flink.streaming.api.functions.source;
 
 import org.apache.flink.annotation.Internal;
 import org.apache.flink.api.common.io.InputFormat;
+import org.apache.flink.api.common.io.RichInputFormat;
 import org.apache.flink.api.common.typeinfo.TypeInformation;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.configuration.Configuration;
@@ -30,7 +31,7 @@ import java.util.Iterator;
 import java.util.NoSuchElementException;
 
 @Internal
-public class InputFormatSource<OUT> extends RichParallelSourceFunction<OUT> {
+public class InputFormatSourceFunction<OUT> extends RichParallelSourceFunction<OUT> {
 	private static final long serialVersionUID = 1L;
 
 	private TypeInformation<OUT> typeInfo;
@@ -44,7 +45,7 @@ public class InputFormatSource<OUT> extends RichParallelSourceFunction<OUT> {
 	private volatile boolean isRunning = true;
 
 	@SuppressWarnings("unchecked")
-	public InputFormatSource(InputFormat<OUT, ?> format, TypeInformation<OUT> typeInfo) {
+	public InputFormatSourceFunction(InputFormat<OUT, ?> format, TypeInformation<OUT> typeInfo) {
 		this.format = (InputFormat<OUT, InputSplit>) format;
 		this.typeInfo = typeInfo;
 	}
@@ -53,21 +54,71 @@ public class InputFormatSource<OUT> extends RichParallelSourceFunction<OUT> {
 	@SuppressWarnings("unchecked")
 	public void open(Configuration parameters) throws Exception {
 		StreamingRuntimeContext context = (StreamingRuntimeContext) getRuntimeContext();
-		this.provider = context.getInputSplitProvider();
-		
+
+		if (format instanceof RichInputFormat) {
+			((RichInputFormat) format).setRuntimeContext(context);
+		}
 		format.configure(parameters);
-		serializer = typeInfo.createSerializer(getRuntimeContext().getExecutionConfig());
 
+		provider = context.getInputSplitProvider();
+		serializer = typeInfo.createSerializer(getRuntimeContext().getExecutionConfig());
 		splitIterator = getInputSplits();
-		if (splitIterator.hasNext()) {
-			format.open(splitIterator.next());
+		isRunning = splitIterator.hasNext();
+	}
+
+	@Override
+	public void run(SourceContext<OUT> ctx) throws Exception {
+		try {
+
+			if (isRunning && format instanceof RichInputFormat) {
+				((RichInputFormat) format).openInputFormat();
+			}
+
+			OUT nextElement = serializer.createInstance();
+			while (isRunning) {
+				format.open(splitIterator.next());
+
+				// for each element we also check if cancel
+				// was called by checking the isRunning flag
+				
+				while (isRunning && !format.reachedEnd()) {
+					nextElement = format.nextRecord(nextElement);
+					ctx.collect(nextElement);
+				}
+				format.close();
+
+				if (isRunning) {
+					isRunning = splitIterator.hasNext();
+				}
+			}
+		} finally {
+			format.close();
+			if (format instanceof RichInputFormat) {
+				((RichInputFormat) format).closeInputFormat();
+			}
+			isRunning = false;
 		}
-		isRunning = true;
+	}
+
+	@Override
+	public void cancel() {
+		isRunning = false;
 	}
 
 	@Override
 	public void close() throws Exception {
 		format.close();
+		if (format instanceof RichInputFormat) {
+			((RichInputFormat) format).closeInputFormat();
+		}
+	}
+
+	/**
+	 * Returns the {@code InputFormat}. This is only needed because we need to set the input
+	 * split assigner on the {@code StreamGraph}.
+	 */
+	public InputFormat<OUT, InputSplit> getFormat() {
+		return format;
 	}
 
 	private Iterator<InputSplit> getInputSplits() {
@@ -116,33 +167,4 @@ public class InputFormatSource<OUT> extends RichParallelSourceFunction<OUT> {
 			}
 		};
 	}
-
-	@Override
-	public void run(SourceContext<OUT> ctx) throws Exception {
-		while (isRunning) {
-			OUT nextElement = serializer.createInstance();
-			nextElement =  format.nextRecord(nextElement);
-			if (nextElement == null && splitIterator.hasNext()) {
-				format.open(splitIterator.next());
-				continue;
-			} else if (nextElement == null) {
-				break;
-			}
-			ctx.collect(nextElement);
-		}
-	}
-
-	@Override
-	public void cancel() {
-		isRunning = false;
-	}
-
-
-	/**
-	 * Returns the {@code InputFormat}. This is only needed because we need to set the input
-	 * split assigner on the {@code StreamGraph}.
-	 */
-	public InputFormat<OUT, InputSplit> getFormat() {
-		return format;
-	}
 }
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java
index 685655e5a7b..de80e255a74 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java
@@ -21,7 +21,7 @@ import org.apache.flink.annotation.Internal;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
-import org.apache.flink.streaming.api.functions.source.InputFormatSource;
+import org.apache.flink.streaming.api.functions.source.InputFormatSourceFunction;
 import org.apache.flink.streaming.api.transformations.CoFeedbackTransformation;
 import org.apache.flink.streaming.api.transformations.FeedbackTransformation;
 import org.apache.flink.streaming.api.transformations.OneInputTransformation;
@@ -425,8 +425,8 @@ public class StreamGraphGenerator {
 				null,
 				source.getOutputType(),
 				"Source: " + source.getName());
-		if (source.getOperator().getUserFunction() instanceof InputFormatSource) {
-			InputFormatSource<T> fs = (InputFormatSource<T>) source.getOperator().getUserFunction();
+		if (source.getOperator().getUserFunction() instanceof InputFormatSourceFunction) {
+			InputFormatSourceFunction<T> fs = (InputFormatSourceFunction<T>) source.getOperator().getUserFunction();
 			streamGraph.setInputFormat(source.getId(), fs.getFormat());
 		}
 		streamGraph.setParallelism(source.getId(), source.getParallelism());
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/source/InputFormatSourceFunctionTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/source/InputFormatSourceFunctionTest.java
new file mode 100644
index 00000000000..32776e11495
--- /dev/null
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/source/InputFormatSourceFunctionTest.java
@@ -0,0 +1,286 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.api.functions.source;
+
+import org.apache.flink.api.common.ExecutionConfig;
+import org.apache.flink.api.common.accumulators.Accumulator;
+import org.apache.flink.api.common.io.RichInputFormat;
+import org.apache.flink.api.common.io.statistics.BaseStatistics;
+import org.apache.flink.api.common.typeinfo.TypeInformation;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.core.io.InputSplit;
+import org.apache.flink.core.io.InputSplitAssigner;
+import org.apache.flink.runtime.jobgraph.tasks.InputSplitProvider;
+import org.apache.flink.runtime.memory.MemoryManager;
+import org.apache.flink.runtime.operators.testutils.MockEnvironment;
+import org.apache.flink.streaming.api.operators.AbstractStreamOperator;
+import org.apache.flink.streaming.api.operators.StreamingRuntimeContext;
+import org.apache.flink.streaming.api.watermark.Watermark;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Collections;
+
+public class InputFormatSourceFunctionTest {
+
+	@Test
+	public void testNormalOp() throws Exception {
+		testFormatLifecycle(false);
+	}
+
+	@Test
+	public void testCancelation() throws Exception {
+		testFormatLifecycle(true);
+	}
+
+	private void testFormatLifecycle(final boolean midCancel) throws Exception {
+
+		final int noOfSplits = 5;
+		final int cancelAt = 2;
+
+		final LifeCycleTestInputFormat format = new LifeCycleTestInputFormat();
+		final InputFormatSourceFunction<Integer> reader = new InputFormatSourceFunction<>(format, TypeInformation.of(Integer.class));
+		reader.setRuntimeContext(new MockRuntimeContext(format, noOfSplits));
+
+		Assert.assertTrue(!format.isConfigured);
+		Assert.assertTrue(!format.isInputFormatOpen);
+		Assert.assertTrue(!format.isSplitOpen);
+
+		reader.open(new Configuration());
+		Assert.assertTrue(format.isConfigured);
+
+		TestSourceContext ctx = new TestSourceContext(reader, format, midCancel, cancelAt);
+		reader.run(ctx);
+
+		int splitsSeen = ctx.getSplitsSeen();
+		Assert.assertTrue(midCancel ? splitsSeen == cancelAt : splitsSeen == noOfSplits);
+
+		// we have exhausted the splits so the
+		// format and splits should be closed by now
+
+		Assert.assertTrue(!format.isSplitOpen);
+		Assert.assertTrue(!format.isInputFormatOpen);
+	}
+
+
+	private static class LifeCycleTestInputFormat extends RichInputFormat<Integer,InputSplit> {
+
+		private boolean isConfigured = false;
+		private boolean isInputFormatOpen = false;
+		private boolean isSplitOpen = false;
+
+		// end of split
+		private boolean eos = false;
+
+		private int splitCounter = 0;
+
+		private int reachedEndCalls = 0;
+		private int nextRecordCalls = 0;
+
+		@Override
+		public void openInputFormat() {
+			Assert.assertTrue(isConfigured);
+			Assert.assertTrue(!isInputFormatOpen);
+			Assert.assertTrue(!isSplitOpen);
+			this.isInputFormatOpen = true;
+		}
+
+		@Override
+		public void closeInputFormat() {
+			Assert.assertTrue(!isSplitOpen);
+			this.isInputFormatOpen = false;
+		}
+
+		@Override
+		public void configure(Configuration parameters) {
+			Assert.assertTrue(!isConfigured);
+			this.isConfigured = true;
+		}
+
+		@Override
+		public BaseStatistics getStatistics(BaseStatistics cachedStatistics) throws IOException {
+			return null;
+		}
+
+		@Override
+		public InputSplit[] createInputSplits(int minNumSplits) throws IOException {
+			Assert.assertTrue(isConfigured);
+			InputSplit[] splits = new InputSplit[minNumSplits];
+			for (int i = 0; i < minNumSplits; i++) {
+				final int idx = i;
+				splits[idx] = new InputSplit() {
+					@Override
+					public int getSplitNumber() {
+						return idx;
+					}
+				};
+			}
+			return splits;
+		}
+
+		@Override
+		public InputSplitAssigner getInputSplitAssigner(InputSplit[] inputSplits) {
+			return null;
+		}
+
+		@Override
+		public void open(InputSplit split) throws IOException {
+			// whenever a new split opens,
+			// the previous should have been closed
+			Assert.assertTrue(isInputFormatOpen);
+			Assert.assertTrue(isConfigured);
+			Assert.assertTrue(!isSplitOpen);
+
+			isSplitOpen = true;
+			eos = false;
+		}
+
+		@Override
+		public boolean reachedEnd() throws IOException {
+			Assert.assertTrue(isInputFormatOpen);
+			Assert.assertTrue(isConfigured);
+			Assert.assertTrue(isSplitOpen);
+
+			if (!eos) {
+				reachedEndCalls++;
+			}
+			return eos;
+		}
+
+		@Override
+		public Integer nextRecord(Integer reuse) throws IOException {
+			Assert.assertTrue(isInputFormatOpen);
+			Assert.assertTrue(isConfigured);
+			Assert.assertTrue(isSplitOpen);
+
+			Assert.assertTrue(reachedEndCalls == ++nextRecordCalls);
+
+			eos = true;
+			return splitCounter++;
+		}
+
+		@Override
+		public void close() throws IOException {
+			this.isSplitOpen = false;
+		}
+	}
+
+	private static class TestSourceContext implements SourceFunction.SourceContext<Integer> {
+
+		private final InputFormatSourceFunction<Integer> reader;
+		private final LifeCycleTestInputFormat format;
+		private final boolean shouldCancel;
+		private final int cancelAt;
+
+		int splitIdx = 0;
+
+		private TestSourceContext(InputFormatSourceFunction<Integer> reader, LifeCycleTestInputFormat format, boolean shouldCancel, int cancelAt) {
+			this.reader = reader;
+			this.format = format;
+			this.shouldCancel = shouldCancel;
+			this.cancelAt = cancelAt;
+		}
+
+		@Override
+		public void collect(Integer element) {
+			Assert.assertTrue(format.isSplitOpen);
+			Assert.assertTrue(splitIdx == element);
+			if (shouldCancel && splitIdx == cancelAt) {
+				reader.cancel();
+			} else {
+				splitIdx++;
+			}
+		}
+
+		@Override
+		public void collectWithTimestamp(Integer element, long timestamp) {
+			throw new UnsupportedOperationException();
+		}
+
+		@Override
+		public void emitWatermark(Watermark mark) {
+			throw new UnsupportedOperationException();
+		}
+
+		@Override
+		public Object getCheckpointLock() {
+			return null;
+		}
+
+		@Override
+		public void close() {
+			throw new UnsupportedOperationException();
+		}
+
+		public int getSplitsSeen() {
+			return this.splitIdx;
+		}
+	}
+
+	@SuppressWarnings("deprecation")
+	private static class MockRuntimeContext extends StreamingRuntimeContext {
+
+		private final int noOfSplits;
+		private int nextSplit = 0;
+		private final LifeCycleTestInputFormat format;
+		private InputSplit[] inputSplits;
+
+		private MockRuntimeContext(LifeCycleTestInputFormat format, int noOfSplits) {
+
+			super(new MockStreamOperator(),
+				new MockEnvironment("no", 4 * MemoryManager.DEFAULT_PAGE_SIZE, null, 16),
+				Collections.<String, Accumulator<?, ?>>emptyMap());
+
+			this.noOfSplits = noOfSplits;
+			this.format = format;
+		}
+
+		@Override
+		public InputSplitProvider getInputSplitProvider() {
+			try {
+				this.inputSplits = format.createInputSplits(noOfSplits);
+				Assert.assertTrue(inputSplits.length == noOfSplits);
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+
+			return new InputSplitProvider() {
+				@Override
+				public InputSplit getNextInputSplit() {
+					if (nextSplit < inputSplits.length) {
+						return inputSplits[nextSplit++];
+					}
+					return null;
+				}
+			};
+		}
+
+		// ------------------------------------------------------------------------
+
+		private static class MockStreamOperator extends AbstractStreamOperator<Integer> {
+			private static final long serialVersionUID = -1153976702711944427L;
+
+			@Override
+			public ExecutionConfig getExecutionConfig() {
+				return new ExecutionConfig();
+			}
+		}
+	}
+}
