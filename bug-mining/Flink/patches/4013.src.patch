diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java
index 2cfc6fc4dce..90c22c273f0 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java
@@ -124,6 +124,7 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven
 			else if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {
 				CheckpointBarrier checkpointBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();
 				barrierHandler.processBarrier(checkpointBarrier, offsetChannelIndex(bufferOrEvent.getChannelIndex()));
+				return next;
 			}
 			else if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {
 				barrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java
index 2d00ce2e0e2..46e7a925521 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java
@@ -24,6 +24,7 @@ import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;
 import org.apache.flink.runtime.event.AbstractEvent;
 import org.apache.flink.runtime.io.disk.iomanager.IOManager;
+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;
 import org.apache.flink.runtime.io.network.api.EndOfPartitionEvent;
 import org.apache.flink.runtime.io.network.api.serialization.RecordDeserializer;
 import org.apache.flink.runtime.io.network.api.serialization.RecordDeserializer.DeserializationResult;
@@ -134,6 +135,11 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {
 
 			Optional<BufferOrEvent> bufferOrEvent = checkpointedInputGate.pollNext();
 			if (bufferOrEvent.isPresent()) {
+				// return to the mailbox after receiving a checkpoint barrier to avoid processing of
+				// data after the barrier before checkpoint is performed for unaligned checkpoint mode
+				if (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {
+					return InputStatus.MORE_AVAILABLE;
+				}
 				processBufferOrEvent(bufferOrEvent.get());
 			} else {
 				if (checkpointedInputGate.isFinished()) {
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java
index fec9fb20fab..db6702a657b 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java
@@ -165,9 +165,7 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		handler.setNextExpectedCheckpointId(1L);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
-				assertEquals(boe, inputGate.pollNext().get());
-			}
+			assertEquals(boe, inputGate.pollNext().get());
 		}
 	}
 
@@ -215,14 +213,17 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		long startTs = System.nanoTime();
 
 		// checkpoint 1 done
+		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(2L, handler.getNextExpectedCheckpointId());
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// pre checkpoint 2
+		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
@@ -231,23 +232,37 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		// checkpoint 2 barriers come together
 		startTs = System.nanoTime();
-		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(3L, handler.getNextExpectedCheckpointId());
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels2 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
+		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);
 
-		// checkpoint 3 and 4
+		// checkpoint 3
+		check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);
-		assertEquals(5L, handler.getNextExpectedCheckpointId());
-		Integer[] expectedUnblockedChannels3 = new Integer[] {0, 1, 2, 0, 1, 2};
+		check(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);
+		assertEquals(4L, handler.getNextExpectedCheckpointId());
+		Integer[] expectedUnblockedChannels3 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
+		// checkpoint 4
+		check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);
+		assertEquals(5L, handler.getNextExpectedCheckpointId());
+		Integer[] expectedUnblockedChannels4 = new Integer[] {0, 1, 2};
+		assertArrayEquals(expectedUnblockedChannels4, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+
 		// remaining data
+		check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);
@@ -290,25 +305,29 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		// align checkpoint 1
 		startTs = System.nanoTime();
+		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 		toNotify.setNextExpectedCheckpointId(1);
-		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(1L, inputGate.getLatestCheckpointId());
 		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
-
-		// checkpoint done
 		validateAlignmentTime(startTs, inputGate);
+
+		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// alignment of checkpoint 2
 		startTs = System.nanoTime();
+		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// checkpoint 2 aborted, checkpoint 3 started
-		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(3L, inputGate.getLatestCheckpointId());
 		validateAlignmentTime(startTs, inputGate);
 		assertEquals(2, toNotify.getLastCanceledCheckpointId());
@@ -317,6 +336,7 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// checkpoint 3 alignment in progress
+		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// checkpoint 3 aborted (end of partition)
@@ -369,33 +389,45 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		handler.setNextExpectedCheckpointId(1L);
 
-		// checkpoint 1
+		// pre checkpoint 1
 		check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
+
+		// checkpoint 1
+		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(1L, inputGate.getLatestCheckpointId());
+		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
+		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};
+		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
-		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};
-		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// alignment of checkpoint 2
-		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(2L, inputGate.getLatestCheckpointId());
+		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
+
+		// checkpoint 2 aborted, checkpoint 3 started
+		check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);
+		assertEquals(3L, inputGate.getLatestCheckpointId());
 		Integer[] expectedUnblockedChannels2 = new Integer[] {0, 1};
 		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
-		assertEquals(3L, inputGate.getLatestCheckpointId());
+		check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// checkpoint 3 aborted, checkpoint 4 started
-		check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(4L, inputGate.getLatestCheckpointId());
 		Integer[] expectedUnblockedChannels3 = new Integer[] {0, 2};
 		assertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// checkpoint 4 aborted (due to end of partition)
@@ -424,7 +456,7 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		inputGate = createBarrierBuffer(2, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || (boe.getEvent().getClass() != CheckpointBarrier.class && boe.getEvent().getClass() != CancelCheckpointMarker.class)) {
+			if (boe.isBuffer() || boe.getEvent().getClass() != CancelCheckpointMarker.class) {
 				assertEquals(boe, inputGate.pollNext().get());
 			}
 		}
@@ -465,22 +497,34 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
 
+		// checkpoint 2 alignment
+		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
+		assertEquals(2L, inputGate.getLatestCheckpointId());
+		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 3};
+		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+
 		// checkpoint 3 alignment
-		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(3L, inputGate.getLatestCheckpointId());
-		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 3, 0, 3};
-		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		Integer[] expectedUnblockedChannels2 = new Integer[] {0, 3};
+		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// after checkpoint 3
+		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
-
 		check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
+
+		// checkpoint 4 alignment
+		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(4L, inputGate.getLatestCheckpointId());
-		Integer[] expectedUnblockedChannels2 = new Integer[] {3};
-		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		Integer[] expectedUnblockedChannels3 = new Integer[] {3};
+		assertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+
+		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);
 	}
 
@@ -507,16 +551,22 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		inputGate = createBarrierBuffer(3, sequence);
 
 		// data after first checkpoint
-		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
 		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+
+		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(1L, inputGate.getLatestCheckpointId());
 
 		// alignment of second checkpoint
-		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(2L, inputGate.getLatestCheckpointId());
+		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// first end-of-partition encountered: checkpoint will not be completed
 		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
@@ -547,18 +597,20 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		toNotify.setNextExpectedCheckpointId(1);
 		check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(0L, inputGate.getAlignmentDurationNanos());
 		Integer[] expectedUnblockedChannels1 = new Integer[] {0};
 		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		toNotify.setNextExpectedCheckpointId(2);
-		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
 		Integer[] expectedUnblockedChannels2 = new Integer[] {0};
 		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		toNotify.setNextExpectedCheckpointId(5);
-		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(5L, inputGate.getLatestCheckpointId());
 		assertEquals(4, toNotify.getLastCanceledCheckpointId());
 		assertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());
@@ -566,6 +618,7 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		Integer[] expectedUnblockedChannels3 = new Integer[] {0};
 		assertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
+		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(6L, inputGate.getLatestCheckpointId());
 		assertEquals(6, toNotify.getLastCanceledCheckpointId());
@@ -617,19 +670,28 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		long startTs;
 
-		// successful first checkpoint, with some aligned buffers
-		toNotify.setNextExpectedCheckpointId(1);
+		// pre checkpoint
 		check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
+
+		// first successful checkpoint
 		startTs = System.nanoTime();
+		toNotify.setNextExpectedCheckpointId(1);
+		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
+		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
+
+		// alignment of second checkpoint
+		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// canceled checkpoint on last barrier
@@ -643,42 +705,52 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		// one more successful checkpoint
 		startTs = System.nanoTime();
 		toNotify.setNextExpectedCheckpointId(3);
-		check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels3 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// this checkpoint gets immediately canceled
-		check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(4, toNotify.getLastCanceledCheckpointId());
 		assertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());
 		assertEquals(0L, inputGate.getAlignmentDurationNanos());
 		Integer[] expectedUnblockedChannels4 = new Integer[] {2};
 		assertArrayEquals(expectedUnblockedChannels4, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[23], inputGate.pollNext().get(), PAGE_SIZE);
+		Integer[] expectedUnblockedChannels5 = new Integer[] {0};
+		assertArrayEquals(expectedUnblockedChannels5, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// some buffers
 		check(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);
-		Integer[] expectedUnblockedChannels5 = new Integer[] {0};
-		assertArrayEquals(expectedUnblockedChannels5, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 		check(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// a simple successful checkpoint
 		startTs = System.nanoTime();
 		toNotify.setNextExpectedCheckpointId(5);
-		check(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[29], inputGate.pollNext().get(), PAGE_SIZE);
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels6 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels6, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);
 
-		check(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);
+		// this checkpoint gets immediately canceled
+		check(sequence[34], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(6, toNotify.getLastCanceledCheckpointId());
 		assertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());
 		assertEquals(0L, inputGate.getAlignmentDurationNanos());
 		Integer[] expectedUnblockedChannels7 = new Integer[] {0};
 		assertArrayEquals(expectedUnblockedChannels7, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);
 
 		assertEquals(3, toNotify.getTriggeredCheckpointCounter());
 		assertEquals(3, toNotify.getAbortedCheckpointCounter());
@@ -729,11 +801,12 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// starting first checkpoint
+		check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// cancelled by cancellation barrier
+		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(1, toNotify.getLastCanceledCheckpointId());
 		assertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());
 		Integer[] expectedUnblockedChannels1 = new Integer[] {1};
@@ -741,21 +814,27 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		// the next checkpoint alignment
 		startTs = System.nanoTime();
+		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);
-		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
+
+		// ignored barrier and unblock channel directly
+		check(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);
 		Integer[] expectedUnblockedChannels2 = new Integer[] {2};
 		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);
 
-		// checkpoint done
+		// checkpoint 2 done
 		toNotify.setNextExpectedCheckpointId(2);
-		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels3 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// trailing data
+		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);
 
@@ -803,15 +882,18 @@ public abstract class CheckpointBarrierAlignerTestBase {
 		check(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// beginning of first checkpoint
+		check(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// future barrier aborts checkpoint
 		startTs = System.nanoTime();
-		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);
 		assertEquals(3, toNotify.getLastCanceledCheckpointId());
 		assertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_SUBSUMED, toNotify.getCheckpointFailureReason());
 		Integer[] expectedUnblockedChannels1 = new Integer[] {0, 1};
 		assertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());
+		check(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);
 
 		// alignment of next checkpoint
@@ -820,12 +902,14 @@ public abstract class CheckpointBarrierAlignerTestBase {
 
 		// checkpoint finished
 		toNotify.setNextExpectedCheckpointId(5);
-		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);
+		check(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);
 		validateAlignmentTime(startTs, inputGate);
 		Integer[] expectedUnblockedChannels2 = new Integer[] {0, 1, 2};
 		assertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());
 
 		// remaining data
+		check(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);
 		check(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTrackerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTrackerTest.java
index 706570b4fa6..1deca6abcc0 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTrackerTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTrackerTest.java
@@ -94,9 +94,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(1, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
-				assertEquals(boe, inputGate.pollNext().get());
-			}
+			assertEquals(boe, inputGate.pollNext().get());
 		}
 	}
 
@@ -116,9 +114,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(1, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
-				assertEquals(boe, inputGate.pollNext().get());
-			}
+			assertEquals(boe, inputGate.pollNext().get());
 		}
 	}
 
@@ -147,9 +143,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(3, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
-				assertEquals(boe, inputGate.pollNext().get());
-			}
+			assertEquals(boe, inputGate.pollNext().get());
 		}
 	}
 
@@ -182,9 +176,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(3, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
-				assertEquals(boe, inputGate.pollNext().get());
-			}
+			assertEquals(boe, inputGate.pollNext().get());
 		}
 	}
 
@@ -256,9 +248,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(3, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
-				assertEquals(boe, inputGate.pollNext().get());
-			}
+			assertEquals(boe, inputGate.pollNext().get());
 		}
 	}
 
@@ -281,7 +271,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(1, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer()) {
+			if (boe.isBuffer() || boe.getEvent().getClass() != CancelCheckpointMarker.class) {
 				assertEquals(boe, inputGate.pollNext().get());
 			}
 		}
@@ -329,7 +319,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(3, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer()) {
+			if (boe.isBuffer() || boe.getEvent().getClass() != CancelCheckpointMarker.class) {
 				assertEquals(boe, inputGate.pollNext().get());
 			}
 		}
@@ -355,7 +345,7 @@ public class CheckpointBarrierTrackerTest {
 		inputGate = createBarrierTracker(3, sequence, validator);
 
 		for (BufferOrEvent boe : sequence) {
-			if (boe.isBuffer() || (boe.getEvent().getClass() != CheckpointBarrier.class && boe.getEvent().getClass() != CancelCheckpointMarker.class)) {
+			if (boe.isBuffer() || boe.getEvent().getClass() != CancelCheckpointMarker.class) {
 				assertEquals(boe, inputGate.pollNext().get());
 			}
 		}
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
index 509a48dcce1..a9b2ea0ddb5 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java
@@ -19,8 +19,10 @@
 package org.apache.flink.streaming.runtime.io;
 
 import org.apache.flink.api.common.typeutils.base.LongSerializer;
+import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.io.disk.iomanager.IOManager;
 import org.apache.flink.runtime.io.disk.iomanager.IOManagerAsync;
+import org.apache.flink.runtime.io.network.api.CheckpointBarrier;
 import org.apache.flink.runtime.io.network.api.EndOfPartitionEvent;
 import org.apache.flink.runtime.io.network.api.serialization.RecordSerializer;
 import org.apache.flink.runtime.io.network.api.serialization.SpanningRecordSerializer;
@@ -46,6 +48,7 @@ import org.junit.After;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -74,29 +77,35 @@ public class StreamTaskNetworkInputTest {
 
 	@Test
 	public void testIsAvailableWithBufferedDataInDeserializer() throws Exception {
-		BufferBuilder bufferBuilder = BufferBuilderTestUtils.createEmptyBufferBuilder(PAGE_SIZE);
-		BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
-
-		serializeRecord(42L, bufferBuilder);
-		serializeRecord(44L, bufferBuilder);
-
-		List<BufferOrEvent> buffers = Collections.singletonList(new BufferOrEvent(bufferConsumer.build(), 0, false));
+		List<BufferOrEvent> buffers = Collections.singletonList(createDataBuffer());
 
 		VerifyRecordsDataOutput output = new VerifyRecordsDataOutput<>();
-		StreamTaskNetworkInput input = new StreamTaskNetworkInput<>(
-			new CheckpointedInputGate(
-				new MockInputGate(1, buffers, false),
-				new CheckpointBarrierTracker(1, new DummyCheckpointInvokable())),
-			LongSerializer.INSTANCE,
-			ioManager,
-			new StatusWatermarkValve(1, output),
-			0);
+		StreamTaskNetworkInput input = createStreamTaskNetworkInput(buffers, output);
 
 		assertHasNextElement(input, output);
 		assertHasNextElement(input, output);
 		assertEquals(2, output.getNumberOfEmittedRecords());
 	}
 
+	/**
+	 * InputGate on CheckpointBarrier can enqueue a mailbox action to execute and StreamTaskNetworkInput must
+	 * allow this action to execute before processing a following record.
+	 */
+	@Test
+	public void testNoDataProcessedAfterCheckpointBarrier() throws Exception {
+		CheckpointBarrier barrier = new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation());
+
+		List<BufferOrEvent> buffers = new ArrayList<>(2);
+		buffers.add(new BufferOrEvent(barrier, 0));
+		buffers.add(createDataBuffer());
+
+		VerifyRecordsDataOutput output = new VerifyRecordsDataOutput<>();
+		StreamTaskNetworkInput input = createStreamTaskNetworkInput(buffers, output);
+
+		assertHasNextElement(input, output);
+		assertEquals(0, output.getNumberOfEmittedRecords());
+	}
+
 	@Test
 	public void testReleasingDeserializerTimely()
 		throws Exception {
@@ -130,6 +139,26 @@ public class StreamTaskNetworkInputTest {
 		}
 	}
 
+	private BufferOrEvent createDataBuffer() throws IOException {
+		BufferBuilder bufferBuilder = BufferBuilderTestUtils.createEmptyBufferBuilder(PAGE_SIZE);
+		BufferConsumer bufferConsumer = bufferBuilder.createBufferConsumer();
+		serializeRecord(42L, bufferBuilder);
+		serializeRecord(44L, bufferBuilder);
+
+		return new BufferOrEvent(bufferConsumer.build(), 0, false);
+	}
+
+	private StreamTaskNetworkInput createStreamTaskNetworkInput(List<BufferOrEvent> buffers, DataOutput output) {
+		return new StreamTaskNetworkInput<>(
+			new CheckpointedInputGate(
+				new MockInputGate(1, buffers, false),
+				new CheckpointBarrierTracker(1, new DummyCheckpointInvokable())),
+			LongSerializer.INSTANCE,
+			ioManager,
+			new StatusWatermarkValve(1, output),
+			0);
+	}
+
 	private void serializeRecord(long value, BufferBuilder bufferBuilder) throws IOException {
 		RecordSerializer<SerializationDelegate<StreamElement>> serializer = new SpanningRecordSerializer<>();
 		SerializationDelegate<StreamElement> serializationDelegate =
