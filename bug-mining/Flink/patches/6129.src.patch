diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
index d313ef3292a..19aa299aebc 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/minicluster/MiniCluster.java
@@ -93,6 +93,7 @@ import org.apache.flink.util.AutoCloseableAsync;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.ExecutorUtils;
 import org.apache.flink.util.FlinkException;
+import org.apache.flink.util.InstantiationUtil;
 import org.apache.flink.util.Reference;
 import org.apache.flink.util.SerializedValue;
 import org.apache.flink.util.concurrent.ExecutorThreadFactory;
@@ -897,22 +898,26 @@ public class MiniCluster implements AutoCloseableAsync {
     }
 
     public CompletableFuture<JobSubmissionResult> submitJob(JobGraph jobGraph) {
-        checkRestoreModeForRandomizedChangelogStateBackend(jobGraph);
+        // When MiniCluster uses the local RPC, the provided JobGraph is passed directly to the
+        // Dispatcher. This means that any mutations to the JG can affect the Dispatcher behaviour,
+        // so we rather clone it to guard against this.
+        final JobGraph clonedJobGraph = cloneJobGraph(jobGraph);
+        checkRestoreModeForRandomizedChangelogStateBackend(clonedJobGraph);
         final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture =
                 getDispatcherGatewayFuture();
         final CompletableFuture<InetSocketAddress> blobServerAddressFuture =
                 createBlobServerAddress(dispatcherGatewayFuture);
         final CompletableFuture<Void> jarUploadFuture =
-                uploadAndSetJobFiles(blobServerAddressFuture, jobGraph);
+                uploadAndSetJobFiles(blobServerAddressFuture, clonedJobGraph);
         final CompletableFuture<Acknowledge> acknowledgeCompletableFuture =
                 jarUploadFuture
                         .thenCombine(
                                 dispatcherGatewayFuture,
                                 (Void ack, DispatcherGateway dispatcherGateway) ->
-                                        dispatcherGateway.submitJob(jobGraph, rpcTimeout))
+                                        dispatcherGateway.submitJob(clonedJobGraph, rpcTimeout))
                         .thenCompose(Function.identity());
         return acknowledgeCompletableFuture.thenApply(
-                (Acknowledge ignored) -> new JobSubmissionResult(jobGraph.getJobID()));
+                (Acknowledge ignored) -> new JobSubmissionResult(clonedJobGraph.getJobID()));
     }
 
     // HACK: temporary hack to make the randomized changelog state backend tests work with forced
@@ -1207,6 +1212,14 @@ public class MiniCluster implements AutoCloseableAsync {
         }
     }
 
+    private static JobGraph cloneJobGraph(JobGraph jobGraph) {
+        try {
+            return InstantiationUtil.clone(jobGraph);
+        } catch (ClassNotFoundException | IOException e) {
+            throw new IllegalStateException("Unable to clone the provided JobGraph.", e);
+        }
+    }
+
     /** Internal factory for {@link RpcService}. */
     protected interface RpcServiceFactory {
         RpcService createRpcService() throws Exception;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/MiniClusterITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/MiniClusterITCase.java
index 6a2b23cd396..64dad6982df 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/MiniClusterITCase.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/minicluster/MiniClusterITCase.java
@@ -611,7 +611,7 @@ public class MiniClusterITCase extends TestLogger {
         try (final MiniCluster miniCluster = new MiniCluster(cfg)) {
             miniCluster.start();
 
-            final JobVertex failingJobVertex = new OutOfMemoryJobVertex();
+            final JobVertex failingJobVertex = new OutOfMemoryInFinalizationJobVertex();
             failingJobVertex.setInvokableClass(NoOpInvokable.class);
             failingJobVertex.setParallelism(parallelism);
 
@@ -653,14 +653,7 @@ public class MiniClusterITCase extends TestLogger {
         try (final MiniCluster miniCluster = new MiniCluster(cfg)) {
             miniCluster.start();
 
-            final JobVertex failingJobVertex =
-                    new JobVertex("FailingInFinalization") {
-
-                        @Override
-                        public void initializeOnMaster(ClassLoader loader) {
-                            throw new OutOfMemoryError("Java heap space");
-                        }
-                    };
+            final JobVertex failingJobVertex = new OutOfMemoryInInitializationVertex();
             failingJobVertex.setInvokableClass(NoOpInvokable.class);
             failingJobVertex.setParallelism(parallelism);
 
@@ -738,9 +731,9 @@ public class MiniClusterITCase extends TestLogger {
         }
     }
 
-    private static class OutOfMemoryJobVertex extends JobVertex {
+    private static class OutOfMemoryInFinalizationJobVertex extends JobVertex {
 
-        private OutOfMemoryJobVertex() {
+        private OutOfMemoryInFinalizationJobVertex() {
             super("FailingInFinalization");
         }
 
@@ -749,4 +742,16 @@ public class MiniClusterITCase extends TestLogger {
             throw new OutOfMemoryError("Java heap space");
         }
     }
+
+    private static class OutOfMemoryInInitializationVertex extends JobVertex {
+
+        OutOfMemoryInInitializationVertex() {
+            super("FailingInInitialization");
+        }
+
+        @Override
+        public void initializeOnMaster(ClassLoader loader) {
+            throw new OutOfMemoryError("Java heap space");
+        }
+    }
 }
