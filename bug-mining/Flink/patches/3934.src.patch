diff --git a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/expressions/ApiExpressionUtils.java b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/expressions/ApiExpressionUtils.java
index 1d8998af5b8..a3657a87a55 100644
--- a/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/expressions/ApiExpressionUtils.java
+++ b/flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/expressions/ApiExpressionUtils.java
@@ -284,8 +284,8 @@ public final class ApiExpressionUtils {
 	}
 
 	public static Expression toMonthInterval(Expression e, int multiplier) {
-		return ExpressionUtils.extractValue(e, Integer.class)
-			.map((v) -> intervalOfMonths(v * multiplier))
+		return ExpressionUtils.extractValue(e, BigDecimal.class)
+			.map((v) -> intervalOfMonths(v.intValue() * multiplier))
 			.orElseThrow(() -> new ValidationException("Invalid constant for year-month interval: " + e));
 	}
 
@@ -296,8 +296,8 @@ public final class ApiExpressionUtils {
 	}
 
 	public static Expression toMilliInterval(Expression e, long multiplier) {
-		return ExpressionUtils.extractValue(e, Long.class)
-			.map((v) -> intervalOfMillis(v * multiplier))
+		return ExpressionUtils.extractValue(e, BigDecimal.class)
+			.map((v) -> intervalOfMillis(v.longValue() * multiplier))
 			.orElseThrow(() -> new ValidationException("Invalid constant for day-time interval: " + e));
 	}
 
@@ -308,8 +308,8 @@ public final class ApiExpressionUtils {
 	}
 
 	public static Expression toRowInterval(Expression e) {
-		return ExpressionUtils.extractValue(e, Long.class)
-			.map(ApiExpressionUtils::valueLiteral)
+		return ExpressionUtils.extractValue(e, BigDecimal.class)
+			.map(bd -> ApiExpressionUtils.valueLiteral(bd.longValue()))
 			.orElseThrow(() -> new ValidationException("Invalid constant for row interval: " + e));
 	}
 
diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/expressions/ValueLiteralExpression.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/expressions/ValueLiteralExpression.java
index dd59d3b5af4..7d0800217e6 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/expressions/ValueLiteralExpression.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/expressions/ValueLiteralExpression.java
@@ -23,6 +23,7 @@ import org.apache.flink.table.api.ValidationException;
 import org.apache.flink.table.types.DataType;
 import org.apache.flink.table.types.inference.CallContext;
 import org.apache.flink.table.types.logical.LogicalType;
+import org.apache.flink.table.types.logical.LogicalTypeFamily;
 import org.apache.flink.table.types.utils.ValueDataTypeConverter;
 import org.apache.flink.table.utils.EncodingUtils;
 import org.apache.flink.util.Preconditions;
@@ -30,8 +31,17 @@ import org.apache.flink.util.Preconditions;
 import javax.annotation.Nullable;
 
 import java.math.BigDecimal;
+import java.sql.Date;
+import java.sql.Time;
+import java.sql.Timestamp;
 import java.time.Duration;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.OffsetDateTime;
 import java.time.Period;
+import java.time.ZonedDateTime;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
@@ -76,6 +86,10 @@ public final class ValueLiteralExpression implements ResolvedExpression {
 	/**
 	 * Returns the value (excluding null) as an instance of the given class.
 	 *
+	 * <p>It supports conversions to default conversion classes of {@link LogicalType LogicalTypes} and
+	 * additionally to {@link BigDecimal} for all types of {@link LogicalTypeFamily#NUMERIC}. This method
+	 * should not be called with other classes.
+	 *
 	 * <p>Note to implementers: Whenever we add a new class here, make sure to also update the planner
 	 * for supporting the class via {@link CallContext#getArgumentValue(int, Class)}.
 	 */
@@ -85,90 +99,101 @@ public final class ValueLiteralExpression implements ResolvedExpression {
 			return Optional.empty();
 		}
 
-		final Class<?> valueClass = value.getClass();
-
 		Object convertedValue = null;
 
 		if (clazz.isInstance(value)) {
 			convertedValue = clazz.cast(value);
+		} else {
+			Class<?> valueClass = value.getClass();
+			if (clazz == Period.class) {
+				convertedValue = convertToPeriod(value, valueClass);
+			} else if (clazz == Duration.class) {
+				convertedValue = convertToDuration(value, valueClass);
+			} else if (clazz == LocalDate.class) {
+				convertedValue = convertToLocalDate(value, valueClass);
+			} else if (clazz == LocalTime.class) {
+				convertedValue = convertToLocalTime(value, valueClass);
+			} else if (clazz == LocalDateTime.class) {
+				convertedValue = convertToLocalDateTime(value, valueClass);
+			} else if (clazz == OffsetDateTime.class) {
+				convertedValue = convertToOffsetDateTime(value, valueClass);
+			} else if (clazz == Instant.class) {
+				convertedValue = convertToInstant(value, valueClass);
+			} else if (clazz == BigDecimal.class) {
+				convertedValue = convertToBigDecimal(value);
+			}
 		}
 
-		else if (valueClass == Duration.class && clazz == Long.class) {
-			final Duration duration = (Duration) value;
-			convertedValue = duration.toMillis();
-		}
+		return Optional.ofNullable((T) convertedValue);
+	}
 
-		else if (valueClass == Long.class && clazz == Duration.class) {
-			final Long longVal = (Long) value;
-			convertedValue = Duration.ofMillis(longVal);
+	private @Nullable LocalDate convertToLocalDate(Object value, Class<?> valueClass) {
+		if (valueClass == java.sql.Date.class) {
+			return ((Date) value).toLocalDate();
+		} else if (valueClass == Integer.class) {
+			return LocalDate.ofEpochDay((int) value);
 		}
+		return null;
+	}
 
-		else if (valueClass == Period.class && clazz == Integer.class) {
-			final Period period = (Period) value;
-			convertedValue = (int) period.toTotalMonths();
+	private @Nullable LocalTime convertToLocalTime(Object value, Class<?> valueClass) {
+		if (valueClass == java.sql.Time.class) {
+			return ((Time) value).toLocalTime();
+		} else if (valueClass == Integer.class) {
+			return LocalTime.ofNanoOfDay((int) value * 1_000_000L);
+		} else if (valueClass == Long.class) {
+			return LocalTime.ofNanoOfDay((long) value);
 		}
+		return null;
+	}
 
-		else if (valueClass == Integer.class && clazz == Period.class) {
-			final Integer integer = (Integer) value;
-			convertedValue = Period.ofMonths(integer);
+	private @Nullable LocalDateTime convertToLocalDateTime(Object value, Class<?> valueClass) {
+		if (valueClass == java.sql.Timestamp.class) {
+			return ((Timestamp) value).toLocalDateTime();
 		}
 
-		else if (valueClass == java.sql.Date.class && clazz == java.time.LocalDate.class) {
-			final java.sql.Date date = (java.sql.Date) value;
-			convertedValue = date.toLocalDate();
-		}
+		return null;
+	}
 
-		else if (valueClass == java.sql.Time.class && clazz == java.time.LocalTime.class) {
-			final java.sql.Time time = (java.sql.Time) value;
-			convertedValue = time.toLocalTime();
+	private @Nullable OffsetDateTime convertToOffsetDateTime(Object value, Class<?> valueClass) {
+		if (valueClass == ZonedDateTime.class) {
+			return ((ZonedDateTime) value).toOffsetDateTime();
 		}
 
-		else if (valueClass == java.sql.Timestamp.class && clazz == java.time.LocalDateTime.class) {
-			final java.sql.Timestamp timestamp = (java.sql.Timestamp) value;
-			convertedValue = timestamp.toLocalDateTime();
-		}
+		return null;
+	}
 
-		else if (valueClass == java.time.LocalDate.class && clazz == java.sql.Date.class) {
-			final java.time.LocalDate date = (java.time.LocalDate) value;
-			convertedValue = java.sql.Date.valueOf(date);
+	private @Nullable Instant convertToInstant(Object value, Class<?> valueClass) {
+		if (valueClass == Integer.class) {
+			return Instant.ofEpochSecond((int) value);
+		} else if (valueClass == Long.class) {
+			return Instant.ofEpochMilli((long) value);
 		}
 
-		else if (valueClass == java.time.LocalTime.class && clazz == java.sql.Time.class) {
-			final java.time.LocalTime time = (java.time.LocalTime) value;
-			convertedValue = java.sql.Time.valueOf(time);
-		}
+		return null;
+	}
 
-		else if (valueClass == java.time.LocalDateTime.class && clazz == java.sql.Timestamp.class) {
-			final java.time.LocalDateTime dateTime = (java.time.LocalDateTime) value;
-			convertedValue = java.sql.Timestamp.valueOf(dateTime);
+	private @Nullable Duration convertToDuration(Object value, Class<?> valueClass) {
+		if (valueClass == Long.class) {
+			final Long longValue = (Long) value;
+			return Duration.ofMillis(longValue);
 		}
 
-		else if (Number.class.isAssignableFrom(valueClass) && Number.class.isAssignableFrom(clazz)) {
-			convertedValue = convertNumeric(clazz);
-		}
+		return null;
+	}
 
-		// we can offer more conversions in the future, these conversions must not necessarily
-		// comply with the logical type conversions
+	private @Nullable Period convertToPeriod(Object value, Class<?> valueClass) {
+		if (valueClass == Integer.class) {
+			final Integer integer = (Integer) value;
+			return Period.ofMonths(integer);
+		}
 
-		return Optional.ofNullable((T) convertedValue);
+		return null;
 	}
 
-	private @Nullable <T> Object convertNumeric(Class<T> toClazz) {
-		BigDecimal bigDecimal = new BigDecimal(String.valueOf(value));
-		if (toClazz == Byte.class) {
-			return bigDecimal.byteValue();
-		} else if (toClazz == Short.class) {
-			return bigDecimal.shortValue();
-		} else if (toClazz == Integer.class) {
-			return bigDecimal.intValue();
-		} else if (toClazz == Long.class) {
-			return bigDecimal.longValue();
-		} else if (toClazz == Float.class) {
-			return bigDecimal.floatValue();
-		} else if (toClazz == Double.class) {
-			return bigDecimal.doubleValue();
-		} else if (toClazz == BigDecimal.class) {
-			return bigDecimal;
+	private @Nullable BigDecimal convertToBigDecimal(Object value) {
+		if (Number.class.isAssignableFrom(value.getClass())) {
+			return new BigDecimal(String.valueOf(value));
 		}
 
 		return null;
diff --git a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/CallContext.java b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/CallContext.java
index 7004ea067e3..bdbdf5f0a08 100644
--- a/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/CallContext.java
+++ b/flink-table/flink-table-common/src/main/java/org/apache/flink/table/types/inference/CallContext.java
@@ -24,6 +24,7 @@ import org.apache.flink.table.api.ValidationException;
 import org.apache.flink.table.catalog.DataTypeFactory;
 import org.apache.flink.table.functions.FunctionDefinition;
 import org.apache.flink.table.types.DataType;
+import org.apache.flink.table.types.logical.LogicalType;
 
 import java.util.List;
 import java.util.Optional;
@@ -61,6 +62,9 @@ public interface CallContext {
 	 * Returns the literal value of the argument at the given position, given that the argument is a
 	 * literal, is not null, and can be expressed as an instance of the provided class.
 	 *
+	 * <p>It supports conversions to default conversion classes of {@link LogicalType LogicalTypes}.
+	 * This method should not be called with other classes.
+	 *
 	 * <p>Use {@link #isArgumentLiteral(int)} before to check if the argument is actually a literal.
 	 */
 	<T> Optional<T> getArgumentValue(int pos, Class<T> clazz);
diff --git a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/expressions/ExpressionTest.java b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/expressions/ExpressionTest.java
index 730ee6ee5bd..203fdd2b168 100644
--- a/flink-table/flink-table-common/src/test/java/org/apache/flink/table/expressions/ExpressionTest.java
+++ b/flink-table/flink-table-common/src/test/java/org/apache/flink/table/expressions/ExpressionTest.java
@@ -29,9 +29,19 @@ import org.junit.rules.ExpectedException;
 
 import java.math.BigDecimal;
 import java.nio.charset.StandardCharsets;
+import java.sql.Date;
+import java.sql.Time;
 import java.sql.Timestamp;
+import java.time.Instant;
+import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.OffsetDateTime;
 import java.time.Period;
+import java.time.ZoneId;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+import java.time.temporal.ChronoField;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
@@ -158,7 +168,7 @@ public class ExpressionTest {
 	}
 
 	@Test
-	public void testSqlTimestampValueLiteralExtraction() {
+	public void testLocalDateTimeValueLiteralExtraction() {
 		final Timestamp sqlTimestamp = Timestamp.valueOf("2006-11-03 00:00:00.123456789");
 		final LocalDateTime localDateTime = LocalDateTime.of(2006, 11, 3, 0, 0, 0, 123456789);
 
@@ -166,10 +176,85 @@ public class ExpressionTest {
 			localDateTime,
 			new ValueLiteralExpression(sqlTimestamp).getValueAs(LocalDateTime.class)
 				.orElseThrow(AssertionError::new));
+	}
+
+	@Test
+	public void testLocalTimeValueLiteralExtraction() {
+		final LocalTime localTime = LocalTime.of(12, 12, 12, 123456789);
+
+		final long nanos = localTime.toNanoOfDay();
+
+		final int millis = localTime.get(ChronoField.MILLI_OF_DAY);
+
+		final Time sqlTime = Time.valueOf("12:12:12");
+
+		assertEquals(
+			localTime.withNano(0),
+			new ValueLiteralExpression(sqlTime).getValueAs(LocalTime.class)
+				.orElseThrow(AssertionError::new));
+
+		assertEquals(
+			localTime,
+			new ValueLiteralExpression(nanos).getValueAs(LocalTime.class)
+				.orElseThrow(AssertionError::new));
+
+		assertEquals(
+			localTime.minusNanos(456789),
+			new ValueLiteralExpression(millis).getValueAs(LocalTime.class)
+				.orElseThrow(AssertionError::new));
+	}
+
+	@Test
+	public void testLocalDateValueLiteralExtraction() {
+		final LocalDate localDate = LocalDate.of(2012, 12, 12);
+
+		final int daysSinceEpoch = (int) localDate.toEpochDay();
+
+		final Date sqlDate = Date.valueOf("2012-12-12");
+
+		assertEquals(
+			localDate,
+			new ValueLiteralExpression(sqlDate).getValueAs(LocalDate.class)
+				.orElseThrow(AssertionError::new));
+
+		assertEquals(
+			localDate,
+			new ValueLiteralExpression(daysSinceEpoch).getValueAs(LocalDate.class)
+				.orElseThrow(AssertionError::new));
+	}
+
+	@Test
+	public void testInstantValueLiteralExtraction() {
+		final Instant instant = Instant.ofEpochMilli(100);
+
+		final long millis = instant.toEpochMilli();
+
+		final int seconds = (int) instant.toEpochMilli() / 1_000;
+
+		assertEquals(
+			instant,
+			new ValueLiteralExpression(millis).getValueAs(Instant.class)
+				.orElseThrow(AssertionError::new));
+
+		assertEquals(
+			instant.minusMillis(100),
+			new ValueLiteralExpression(seconds).getValueAs(Instant.class)
+				.orElseThrow(AssertionError::new));
+	}
+
+	@Test
+	public void testOffsetDateTimeValueLiteralExtraction() {
+		final OffsetDateTime offsetDateTime = OffsetDateTime.of(
+			LocalDateTime.parse("2012-12-12T12:12:12"),
+			ZoneOffset.ofHours(1)); // Europe/Berlin equals GMT+1 on 2012-12-12
+
+		final ZonedDateTime zonedDateTime = ZonedDateTime.of(
+			LocalDateTime.parse("2012-12-12T12:12:12"),
+			ZoneId.of("Europe/Berlin"));
 
 		assertEquals(
-			sqlTimestamp,
-			new ValueLiteralExpression(localDateTime).getValueAs(Timestamp.class)
+			offsetDateTime,
+			new ValueLiteralExpression(zonedDateTime).getValueAs(OffsetDateTime.class)
 				.orElseThrow(AssertionError::new));
 	}
 
@@ -185,11 +270,11 @@ public class ExpressionTest {
 
 	@Test
 	public void testPeriodValueLiteralExtraction() {
-		final Period period = Period.ofMonths(10);
-		Integer expectedValue = 10;
+		Integer periodInInt = 10;
+		final Period expected = Period.ofMonths(10);
 		assertEquals(
-			expectedValue,
-			new ValueLiteralExpression(period).getValueAs(Integer.class)
+			expected,
+			new ValueLiteralExpression(periodInInt).getValueAs(Period.class)
 				.orElseThrow(AssertionError::new));
 	}
 
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverter.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverter.java
index 42013ea2147..16d9a72de6c 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverter.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverter.java
@@ -30,35 +30,34 @@ import org.apache.flink.table.expressions.TimeIntervalUnit;
 import org.apache.flink.table.expressions.TimePointUnit;
 import org.apache.flink.table.expressions.TypeLiteralExpression;
 import org.apache.flink.table.expressions.ValueLiteralExpression;
-import org.apache.flink.table.planner.calcite.FlinkContext;
 import org.apache.flink.table.planner.calcite.FlinkTypeFactory;
 import org.apache.flink.table.planner.calcite.RexFieldVariable;
 import org.apache.flink.table.planner.expressions.RexNodeExpression;
 import org.apache.flink.table.planner.expressions.converter.CallExpressionConvertRule.ConvertContext;
 import org.apache.flink.table.planner.utils.ShortcutUtils;
-import org.apache.flink.table.types.logical.DecimalType;
-import org.apache.flink.table.types.logical.LocalZonedTimestampType;
 import org.apache.flink.table.types.logical.LogicalType;
-import org.apache.flink.table.types.logical.TimestampType;
+import org.apache.flink.table.types.logical.TimeType;
 
+import org.apache.calcite.avatica.util.ByteString;
 import org.apache.calcite.avatica.util.TimeUnit;
 import org.apache.calcite.avatica.util.TimeUnitRange;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexBuilder;
 import org.apache.calcite.rex.RexNode;
-import org.apache.calcite.sql.SqlIntervalQualifier;
-import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlTypeName;
 import org.apache.calcite.tools.RelBuilder;
 import org.apache.calcite.util.DateString;
 import org.apache.calcite.util.TimeString;
 
 import java.math.BigDecimal;
+import java.time.Duration;
 import java.time.Instant;
+import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.Period;
+import java.time.temporal.ChronoField;
 import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Date;
 import java.util.List;
 import java.util.Optional;
 import java.util.TimeZone;
@@ -108,93 +107,86 @@ public class ExpressionConverter implements ExpressionVisitor<RexNode> {
 		LogicalType type = fromDataTypeToLogicalType(valueLiteral.getOutputDataType());
 		RexBuilder rexBuilder = relBuilder.getRexBuilder();
 		FlinkTypeFactory typeFactory = (FlinkTypeFactory) relBuilder.getTypeFactory();
+
+		RelDataType relDataType = typeFactory.createFieldTypeFromLogicalType(type);
+
 		if (valueLiteral.isNull()) {
-			return relBuilder.getRexBuilder()
-					.makeCast(
-							typeFactory.createFieldTypeFromLogicalType(type),
-							relBuilder.getRexBuilder().constantNull());
+			return rexBuilder.makeNullLiteral(relDataType);
 		}
 
+		Object value = null;
 		switch (type.getTypeRoot()) {
 			case DECIMAL:
-				DecimalType dt = (DecimalType) type;
-				BigDecimal bigDecimal = extractValue(valueLiteral, BigDecimal.class);
-				RelDataType decType = relBuilder.getTypeFactory().createSqlType(SqlTypeName.DECIMAL,
-						dt.getPrecision(), dt.getScale());
-				return relBuilder.getRexBuilder().makeExactLiteral(bigDecimal, decType);
 			case TINYINT:
-				return relBuilder.getRexBuilder().makeLiteral(
-						extractValue(valueLiteral, Object.class),
-						typeFactory.createSqlType(SqlTypeName.TINYINT),
-						true);
 			case SMALLINT:
-				return relBuilder.getRexBuilder().makeLiteral(
-						extractValue(valueLiteral, Object.class),
-						typeFactory.createSqlType(SqlTypeName.SMALLINT),
-						true);
 			case INTEGER:
-				return relBuilder.getRexBuilder().makeLiteral(
-						extractValue(valueLiteral, Object.class),
-						typeFactory.createSqlType(SqlTypeName.INTEGER),
-						true);
 			case BIGINT:
-				// create BIGINT literals for long type
-				BigDecimal bigint = extractValue(valueLiteral, BigDecimal.class);
-				return relBuilder.getRexBuilder().makeBigintLiteral(bigint);
 			case FLOAT:
-				//Float/Double type should be liked as java type here.
-				return relBuilder.getRexBuilder().makeApproxLiteral(
-						extractValue(valueLiteral, BigDecimal.class),
-						relBuilder.getTypeFactory().createSqlType(SqlTypeName.FLOAT));
 			case DOUBLE:
-				//Float/Double type should be liked as java type here.
-				return rexBuilder.makeApproxLiteral(
-						extractValue(valueLiteral, BigDecimal.class),
-						relBuilder.getTypeFactory().createSqlType(SqlTypeName.DOUBLE));
+				value = extractValue(valueLiteral, BigDecimal.class);
+				break;
+			case VARCHAR:
+			case CHAR:
+				value = extractValue(valueLiteral, String.class);
+				break;
+			case BINARY:
+			case VARBINARY:
+				value = new ByteString(extractValue(valueLiteral, byte[].class));
+				break;
+			case INTERVAL_YEAR_MONTH:
+				// convert to total months
+				value = BigDecimal.valueOf(extractValue(valueLiteral, Period.class).toTotalMonths());
+				break;
+			case INTERVAL_DAY_TIME:
+				// TODO planner supports only milliseconds precision
+				// convert to total millis
+				value = BigDecimal.valueOf(extractValue(valueLiteral, Duration.class).toMillis());
+				break;
 			case DATE:
-				return relBuilder.getRexBuilder().makeDateLiteral(DateString.fromCalendarFields(
-						valueAsCalendar(extractValue(valueLiteral, java.sql.Date.class))));
+				value = DateString.fromDaysSinceEpoch((int) extractValue(valueLiteral, LocalDate.class).toEpochDay());
+				break;
 			case TIME_WITHOUT_TIME_ZONE:
-				return relBuilder.getRexBuilder().makeTimeLiteral(TimeString.fromCalendarFields(
-						valueAsCalendar(extractValue(valueLiteral, java.sql.Time.class))), 0);
+				// TODO type factory strips the precision, for literals we can be more lenient already
+				// Moreover conversion from long supports precision up to TIME(3) planner does not support higher
+				// precisions
+				TimeType timeType = (TimeType) type;
+				int precision = timeType.getPrecision();
+				relDataType = typeFactory.createSqlType(SqlTypeName.TIME, Math.min(precision, 3));
+				value = TimeString.fromMillisOfDay(
+					extractValue(valueLiteral, LocalTime.class).get(ChronoField.MILLI_OF_DAY)
+				);
+				break;
 			case TIMESTAMP_WITHOUT_TIME_ZONE:
-				TimestampType timestampType = (TimestampType) type;
 				LocalDateTime datetime = extractValue(valueLiteral, LocalDateTime.class);
-				return relBuilder.getRexBuilder().makeTimestampLiteral(
-					fromLocalDateTime(datetime), timestampType.getPrecision());
+				value = fromLocalDateTime(datetime);
+				break;
 			case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
-				LocalZonedTimestampType lzTs = (LocalZonedTimestampType) type;
-				TimeZone timeZone = TimeZone.getTimeZone(this.relBuilder.getCluster()
-					.getPlanner()
-					.getContext()
-					.unwrap(FlinkContext.class)
-					.getTableConfig()
-					.getLocalTimeZone());
+				TimeZone timeZone = TimeZone.getTimeZone(
+					ShortcutUtils.unwrapContext(this.relBuilder)
+						.getTableConfig()
+						.getLocalTimeZone()
+				);
 				Instant instant = extractValue(valueLiteral, Instant.class);
-				return this.relBuilder.getRexBuilder().makeTimestampWithLocalTimeZoneLiteral(
-					fromLocalDateTime(LocalDateTime.ofInstant(instant, timeZone.toZoneId())),
-					lzTs.getPrecision());
-			case INTERVAL_YEAR_MONTH:
-				return this.relBuilder.getRexBuilder().makeIntervalLiteral(
-						BigDecimal.valueOf(extractValue(valueLiteral, Integer.class)),
-						new SqlIntervalQualifier(TimeUnit.YEAR, TimeUnit.MONTH, SqlParserPos.ZERO));
-			case INTERVAL_DAY_TIME:
-				return this.relBuilder.getRexBuilder().makeIntervalLiteral(
-						BigDecimal.valueOf(extractValue(valueLiteral, Long.class)),
-						new SqlIntervalQualifier(TimeUnit.DAY, TimeUnit.SECOND, SqlParserPos.ZERO));
+				value = fromLocalDateTime(LocalDateTime.ofInstant(instant, timeZone.toZoneId()));
+				break;
 			default:
+				value = extractValue(valueLiteral, Object.class);
+				if (value instanceof TimePointUnit) {
+					value = timePointUnitToTimeUnit((TimePointUnit) value);
+				} else if (value instanceof TimeIntervalUnit) {
+					value = intervalUnitToUnitRange((TimeIntervalUnit) value);
+				}
 				break;
 		}
-		Object object = extractValue(valueLiteral, Object.class);
-		if (object instanceof TimePointUnit) {
-			TimeUnit value = timePointUnitToTimeUnit((TimePointUnit) object);
-			return relBuilder.getRexBuilder().makeFlag(value);
-		} else if (object instanceof TimeIntervalUnit) {
-			TimeUnitRange value = intervalUnitToUnitRange((TimeIntervalUnit) object);
-			return relBuilder.getRexBuilder().makeFlag(value);
-		} else {
-			return relBuilder.literal(extractValue(valueLiteral, Object.class));
-		}
+
+		return rexBuilder.makeLiteral(
+			value,
+			relDataType,
+			// This flag ensures that the resulting RexNode will match the type of the literal.
+			// It might be wrapped with a CAST though, if the value requires adjusting. In majority of
+			// cases the type will be simply pushed down into the RexLiteral, see RexBuilder#makeCast.
+			true
+		);
 	}
 
 	@Override
@@ -343,18 +335,4 @@ public class ExpressionConverter implements ExpressionVisitor<RexNode> {
 		return literal.getValueAs(clazz)
 			.orElseThrow(() -> new TableException("Unsupported literal class: " + clazz));
 	}
-
-	/**
-	 * Convert a Date value to a Calendar. Calcite's fromCalendarField functions use the
-	 * Calendar.get methods, so the raw values of the individual fields are preserved when
-	 * converted to the String formats.
-	 *
-	 * @return get the Calendar value
-	 */
-	private static Calendar valueAsCalendar(Object value) {
-		Date date = (Date) value;
-		Calendar cal = Calendar.getInstance();
-		cal.setTime(date);
-		return cal;
-	}
 }
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/functions/inference/AbstractSqlCallContext.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/functions/inference/AbstractSqlCallContext.java
index 4dcdbe99557..342ffb51e43 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/functions/inference/AbstractSqlCallContext.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/functions/inference/AbstractSqlCallContext.java
@@ -23,7 +23,6 @@ import org.apache.flink.table.expressions.ValueLiteralExpression;
 import org.apache.flink.table.functions.FunctionDefinition;
 import org.apache.flink.table.types.inference.CallContext;
 
-import org.apache.calcite.sql.SqlIntervalLiteral;
 import org.apache.calcite.sql.SqlOperatorBinding;
 import org.apache.calcite.util.DateString;
 import org.apache.calcite.util.TimeString;
@@ -82,9 +81,6 @@ public abstract class AbstractSqlCallContext implements CallContext {
 	 */
 	@SuppressWarnings("unchecked")
 	protected static <T> T getLiteralValueAs(LiteralValueAccessor accessor, Class<T> clazz) {
-		final Object value = accessor.getValueAs(Object.class);
-		final Class<?> valueClass = value.getClass();
-
 		Object convertedValue = null;
 
 		if (clazz == Duration.class) {
@@ -99,38 +95,16 @@ public abstract class AbstractSqlCallContext implements CallContext {
 			}
 		}
 
-		else if (valueClass == SqlIntervalLiteral.IntervalValue.class && clazz == Integer.class) {
-			final long longVal = accessor.getValueAs(Long.class);
-			if (longVal <= Integer.MAX_VALUE && longVal >= Integer.MIN_VALUE) {
-				convertedValue = (int) longVal;
-			}
-		}
-
-		else if (clazz == java.sql.Date.class) {
-			final DateString dateString = accessor.getValueAs(DateString.class);
-			convertedValue = java.sql.Date.valueOf(dateString.toString());
-		}
-
 		else if (clazz == java.time.LocalDate.class) {
 			final DateString dateString = accessor.getValueAs(DateString.class);
 			convertedValue = java.time.LocalDate.parse(dateString.toString());
 		}
 
-		else if (clazz == java.sql.Time.class) {
-			final TimeString timeString = accessor.getValueAs(TimeString.class);
-			convertedValue = java.sql.Time.valueOf(timeString.toString());
-		}
-
 		else if (clazz == java.time.LocalTime.class) {
 			final TimeString timeString = accessor.getValueAs(TimeString.class);
 			convertedValue = java.time.LocalTime.parse(timeString.toString());
 		}
 
-		else if (clazz == java.sql.Timestamp.class) {
-			final TimestampString timestampString = accessor.getValueAs(TimestampString.class);
-			convertedValue = java.sql.Timestamp.valueOf(timestampString.toString());
-		}
-
 		else if (clazz == java.time.LocalDateTime.class) {
 			final TimestampString timestampString = accessor.getValueAs(TimestampString.class);
 			convertedValue = java.time.LocalDateTime.parse(timestampString.toString().replace(' ', 'T'));
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/utils/ShortcutUtils.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/utils/ShortcutUtils.java
index 45680c958d6..de719a963eb 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/utils/ShortcutUtils.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/utils/ShortcutUtils.java
@@ -28,6 +28,7 @@ import org.apache.calcite.plan.RelOptPlanner;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.type.RelDataTypeFactory;
 import org.apache.calcite.sql.SqlOperatorBinding;
+import org.apache.calcite.tools.RelBuilder;
 
 /**
  * Utilities for quick access of commonly used instances (like {@link FlinkTypeFactory}) without
@@ -52,6 +53,10 @@ public final class ShortcutUtils {
 		return (FlinkTypeFactory) typeFactory;
 	}
 
+	public static FlinkContext unwrapContext(RelBuilder relBuilder) {
+		return unwrapContext(relBuilder.getCluster());
+	}
+
 	public static FlinkContext unwrapContext(RelNode relNode) {
 		return unwrapContext(relNode.getCluster());
 	}
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkTypeFactory.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkTypeFactory.scala
index a134ccdee03..357370ccd5d 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkTypeFactory.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkTypeFactory.scala
@@ -123,6 +123,9 @@ class FlinkTypeFactory(typeSystem: RelDataTypeSystem) extends JavaTypeFactoryImp
           true,
           getTypeSystem)
 
+      case LogicalTypeRoot.SYMBOL =>
+        createSqlType(SqlTypeName.SYMBOL)
+
       case _@t =>
         throw new TableException(s"Type is not supported: $t")
     }
diff --git a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverterTest.java b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverterTest.java
index bf923104746..a2cbd438ddd 100644
--- a/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverterTest.java
+++ b/flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/expressions/converter/ExpressionConverterTest.java
@@ -22,24 +22,38 @@ import org.apache.flink.table.api.DataTypes;
 import org.apache.flink.table.api.TableConfig;
 import org.apache.flink.table.catalog.CatalogManager;
 import org.apache.flink.table.catalog.FunctionCatalog;
-import org.apache.flink.table.expressions.ValueLiteralExpression;
+import org.apache.flink.table.expressions.TimePointUnit;
 import org.apache.flink.table.module.ModuleManager;
 import org.apache.flink.table.planner.delegation.PlannerContext;
 import org.apache.flink.table.planner.plan.metadata.MetadataTestUtil;
 import org.apache.flink.table.planner.plan.trait.FlinkRelDistributionTraitDef;
 import org.apache.flink.table.utils.CatalogManagerMocks;
 
+import org.apache.calcite.avatica.util.TimeUnit;
 import org.apache.calcite.jdbc.CalciteSchema;
 import org.apache.calcite.plan.ConventionTraitDef;
 import org.apache.calcite.rel.RelCollationTraitDef;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
 import org.apache.calcite.sql.type.SqlTypeName;
+import org.apache.calcite.util.DateString;
+import org.apache.calcite.util.TimeString;
+import org.apache.calcite.util.TimestampString;
 import org.junit.Assert;
 import org.junit.Test;
 
+import java.math.BigDecimal;
+import java.time.Duration;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.Period;
 import java.util.Arrays;
 
+import static org.apache.flink.table.expressions.ApiExpressionUtils.valueLiteral;
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.junit.Assert.assertThat;
+
 /**
  * Test for {@link ExpressionConverter}.
  */
@@ -65,16 +79,130 @@ public class ExpressionConverterTest {
 
 	@Test
 	public void testLiteral() {
-		RexNode rex = converter.visit(new ValueLiteralExpression((byte) 1, DataTypes.TINYINT()));
+		RexNode rex = converter.visit(valueLiteral((byte) 1));
 		Assert.assertEquals(1, (int) ((RexLiteral) rex).getValueAs(Integer.class));
 		Assert.assertEquals(SqlTypeName.TINYINT, rex.getType().getSqlTypeName());
 
-		rex = converter.visit(new ValueLiteralExpression((short) 1, DataTypes.SMALLINT()));
+		rex = converter.visit(valueLiteral((short) 1));
 		Assert.assertEquals(1, (int) ((RexLiteral) rex).getValueAs(Integer.class));
 		Assert.assertEquals(SqlTypeName.SMALLINT, rex.getType().getSqlTypeName());
 
-		rex = converter.visit(new ValueLiteralExpression(1, DataTypes.INT()));
+		rex = converter.visit(valueLiteral(1));
 		Assert.assertEquals(1, (int) ((RexLiteral) rex).getValueAs(Integer.class));
 		Assert.assertEquals(SqlTypeName.INTEGER, rex.getType().getSqlTypeName());
 	}
+
+	@Test
+	public void testCharLiteral() {
+		RexNode rex = converter.visit(valueLiteral("ABC", DataTypes.CHAR(4).notNull()));
+		assertThat(((RexLiteral) rex).getValueAs(String.class), equalTo("ABC "));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.CHAR));
+		assertThat(rex.getType().getPrecision(), equalTo(4));
+	}
+
+	@Test
+	public void testVarCharLiteral() {
+		RexNode rex = converter.visit(valueLiteral("ABC", DataTypes.STRING().notNull()));
+		assertThat(((RexLiteral) rex).getValueAs(String.class), equalTo("ABC"));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.VARCHAR));
+		assertThat(rex.getType().getPrecision(), equalTo(Integer.MAX_VALUE));
+	}
+
+	@Test
+	public void testBinaryLiteral() {
+		RexNode rex = converter.visit(valueLiteral(new byte[]{1, 2, 3}, DataTypes.BINARY(4).notNull()));
+		assertThat(((RexLiteral) rex).getValueAs(byte[].class), equalTo(new byte[] {1, 2, 3, 0}));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.BINARY));
+		assertThat(rex.getType().getPrecision(), equalTo(4));
+	}
+
+	@Test
+	public void testTimestampLiteral() {
+		RexNode rex = converter.visit(valueLiteral(
+			LocalDateTime.parse("2012-12-12T12:12:12.12345"),
+			DataTypes.TIMESTAMP(3).notNull()));
+		assertThat(
+			((RexLiteral) rex).getValueAs(TimestampString.class),
+			equalTo(new TimestampString("2012-12-12 12:12:12.123")));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.TIMESTAMP));
+		assertThat(rex.getType().getPrecision(), equalTo(3));
+	}
+
+	@Test
+	public void testTimeLiteral() {
+		RexNode rex = converter.visit(valueLiteral(
+			LocalTime.parse("12:12:12.12345"),
+			DataTypes.TIME(2).notNull()));
+		assertThat(
+			((RexLiteral) rex).getValueAs(TimeString.class),
+			equalTo(new TimeString("12:12:12.12")));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.TIME));
+		assertThat(rex.getType().getPrecision(), equalTo(2));
+	}
+
+	@Test
+	public void testTimeLiteralBiggerPrecision() {
+		RexNode rex = converter.visit(valueLiteral(
+			LocalTime.parse("12:12:12.12345"),
+			DataTypes.TIME(5).notNull()));
+		// TODO planner supports up to TIME(3)
+		assertThat(
+			((RexLiteral) rex).getValueAs(TimeString.class),
+			equalTo(new TimeString("12:12:12.123")));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.TIME));
+		assertThat(rex.getType().getPrecision(), equalTo(3));
+	}
+
+	@Test
+	public void testDateLiteral() {
+		RexNode rex = converter.visit(valueLiteral(
+			LocalDate.parse("2012-12-12"),
+			DataTypes.DATE().notNull()));
+		assertThat(
+			((RexLiteral) rex).getValueAs(DateString.class),
+			equalTo(new DateString("2012-12-12")));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.DATE));
+	}
+
+	@Test
+	public void testIntervalDayTime() {
+		Duration value = Duration.ofDays(3).plusMillis(21);
+		RexNode rex = converter.visit(valueLiteral(value));
+		assertThat(
+			((RexLiteral) rex).getValueAs(BigDecimal.class),
+			equalTo(BigDecimal.valueOf(value.toMillis())));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.INTERVAL_DAY_SECOND));
+		// TODO planner ignores the precision
+		assertThat(rex.getType().getPrecision(), equalTo(2)); // day precision, should actually be 1
+		assertThat(rex.getType().getScale(), equalTo(6));     // fractional precision, should actually be 3
+	}
+
+	@Test
+	public void testIntervalYearMonth() {
+		Period value = Period.of(999, 3, 1);
+		RexNode rex = converter.visit(valueLiteral(value));
+		assertThat(
+			((RexLiteral) rex).getValueAs(BigDecimal.class),
+			equalTo(BigDecimal.valueOf(value.toTotalMonths())));
+		// TODO planner ignores the precision
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.INTERVAL_YEAR_MONTH));
+		assertThat(rex.getType().getPrecision(), equalTo(2)); // year precision, should actually be 3
+	}
+
+	@Test
+	public void testDecimalLiteral() {
+		BigDecimal value = new BigDecimal("12345678.999");
+		RexNode rex = converter.visit(valueLiteral(value));
+		assertThat(((RexLiteral) rex).getValueAs(BigDecimal.class), equalTo(value));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.DECIMAL));
+		assertThat(rex.getType().getPrecision(), equalTo(11));
+		assertThat(rex.getType().getScale(), equalTo(3));
+	}
+
+	@Test
+	public void testSymbolLiteral() {
+		RexNode rex = converter.visit(valueLiteral(TimePointUnit.MICROSECOND));
+		assertThat(((RexLiteral) rex).getValueAs(TimeUnit.class), equalTo(TimeUnit.MICROSECOND));
+		assertThat(rex.getType().getSqlTypeName(), equalTo(SqlTypeName.SYMBOL));
+	}
 }
