diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetriever.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetriever.java
new file mode 100644
index 00000000000..caf8322315b
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetriever.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.scheduler;
+
+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
+
+import java.util.Collection;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * {@link InputsLocationsRetriever} which filters out only already available input locations.
+ */
+class AvailableInputsLocationsRetriever implements InputsLocationsRetriever {
+	private final InputsLocationsRetriever inputsLocationsRetriever;
+
+	AvailableInputsLocationsRetriever(InputsLocationsRetriever inputsLocationsRetriever) {
+		this.inputsLocationsRetriever = inputsLocationsRetriever;
+	}
+
+	@Override
+	public Collection<Collection<ExecutionVertexID>> getConsumedResultPartitionsProducers(
+			ExecutionVertexID executionVertexId) {
+		return inputsLocationsRetriever.getConsumedResultPartitionsProducers(executionVertexId);
+	}
+
+	@Override
+	public Optional<CompletableFuture<TaskManagerLocation>> getTaskManagerLocation(ExecutionVertexID executionVertexId) {
+		return inputsLocationsRetriever
+			.getTaskManagerLocation(executionVertexId)
+			.filter(future -> future.isDone() && !future.isCompletedExceptionally());
+	}
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSyncPreferredLocationsRetriever.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSyncPreferredLocationsRetriever.java
new file mode 100644
index 00000000000..8642e4ed81d
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultSyncPreferredLocationsRetriever.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.scheduler;
+
+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
+import org.apache.flink.util.Preconditions;
+
+import java.util.Collection;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Synchronous version of {@link DefaultPreferredLocationsRetriever}.
+ *
+ * <p>This class turns {@link DefaultPreferredLocationsRetriever} into {@link SyncPreferredLocationsRetriever}.
+ * The method {@link #getPreferredLocations(ExecutionVertexID, Set)} does not return {@link CompletableFuture}
+ * of preferred locations, it returns only locations which are available immediately.
+ * This behaviour is achieved by wrapping the original {@link InputsLocationsRetriever} with
+ * {@link AvailableInputsLocationsRetriever} and hence making it synchronous without blocking.
+ * As {@link StateLocationRetriever} is already synchronous,
+ * the overall location retrieval becomes synchronous without blocking.
+ */
+class DefaultSyncPreferredLocationsRetriever implements SyncPreferredLocationsRetriever {
+	private final PreferredLocationsRetriever asyncPreferredLocationsRetriever;
+
+	DefaultSyncPreferredLocationsRetriever(
+			StateLocationRetriever stateLocationRetriever,
+			InputsLocationsRetriever inputsLocationsRetriever) {
+		this.asyncPreferredLocationsRetriever = new DefaultPreferredLocationsRetriever(
+				stateLocationRetriever,
+				new AvailableInputsLocationsRetriever(inputsLocationsRetriever));
+	}
+
+	@Override
+	public Collection<TaskManagerLocation> getPreferredLocations(
+			ExecutionVertexID executionVertexId,
+			Set<ExecutionVertexID> producersToIgnore) {
+		CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =
+				asyncPreferredLocationsRetriever.getPreferredLocations(executionVertexId, producersToIgnore);
+		Preconditions.checkState(preferredLocationsFuture.isDone());
+		// it is safe to do the blocking call here
+		// as the underlying InputsLocationsRetriever returns only immediately available locations
+		return preferredLocationsFuture.join();
+	}
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverFactory.java
index 847a5f38a8b..9a8cd912412 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverFactory.java
@@ -21,7 +21,6 @@ package org.apache.flink.runtime.scheduler;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
 import org.apache.flink.runtime.clusterframework.types.SlotProfile;
-import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
 import org.apache.flink.util.Preconditions;
@@ -31,7 +30,6 @@ import java.util.Collection;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
-import java.util.concurrent.CompletableFuture;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
@@ -39,12 +37,12 @@ import java.util.stream.Collectors;
  * Factory for {@link MergingSharedSlotProfileRetriever}.
  */
 class MergingSharedSlotProfileRetrieverFactory implements SharedSlotProfileRetriever.SharedSlotProfileRetrieverFactory {
-	private final PreferredLocationsRetriever preferredLocationsRetriever;
+	private final SyncPreferredLocationsRetriever preferredLocationsRetriever;
 
 	private final Function<ExecutionVertexID, AllocationID> priorAllocationIdRetriever;
 
 	MergingSharedSlotProfileRetrieverFactory(
-			PreferredLocationsRetriever preferredLocationsRetriever,
+			SyncPreferredLocationsRetriever preferredLocationsRetriever,
 			Function<ExecutionVertexID, AllocationID> priorAllocationIdRetriever) {
 		this.preferredLocationsRetriever = Preconditions.checkNotNull(preferredLocationsRetriever);
 		this.priorAllocationIdRetriever = Preconditions.checkNotNull(priorAllocationIdRetriever);
@@ -96,33 +94,24 @@ class MergingSharedSlotProfileRetrieverFactory implements SharedSlotProfileRetri
 		 *
 		 * @param executionSlotSharingGroup executions sharing the slot.
 		 * @param physicalSlotResourceProfile {@link ResourceProfile} of the slot.
-		 * @return a future of the {@link SlotProfile} to allocate for the {@code executionSlotSharingGroup}.
+		 * @return {@link SlotProfile} to allocate for the {@code executionSlotSharingGroup}.
 		 */
 		@Override
-		public CompletableFuture<SlotProfile> getSlotProfileFuture(
+		public SlotProfile getSlotProfile(
 				ExecutionSlotSharingGroup executionSlotSharingGroup,
 				ResourceProfile physicalSlotResourceProfile) {
 			Collection<AllocationID> priorAllocations = new HashSet<>();
-			Collection<CompletableFuture<Collection<TaskManagerLocation>>> preferredLocationsPerExecution = new ArrayList<>();
+			Collection<TaskManagerLocation> preferredLocations = new ArrayList<>();
 			for (ExecutionVertexID execution : executionSlotSharingGroup.getExecutionVertexIds()) {
 				priorAllocations.add(priorAllocationIdRetriever.apply(execution));
-				preferredLocationsPerExecution.add(preferredLocationsRetriever
-					.getPreferredLocations(execution, producersToIgnore));
+				preferredLocations.addAll(preferredLocationsRetriever.getPreferredLocations(execution, producersToIgnore));
 			}
-
-			CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = FutureUtils
-				.combineAll(preferredLocationsPerExecution)
-				.thenApply(executionPreferredLocations ->
-					executionPreferredLocations.stream().flatMap(Collection::stream).collect(Collectors.toList()));
-
-			return preferredLocationsFuture.thenApply(
-				preferredLocations ->
-					SlotProfile.priorAllocation(
-						physicalSlotResourceProfile,
-						physicalSlotResourceProfile,
-						preferredLocations,
-						priorAllocations,
-						allBulkPriorAllocationIds));
+			return SlotProfile.priorAllocation(
+				physicalSlotResourceProfile,
+				physicalSlotResourceProfile,
+				preferredLocations,
+				priorAllocations,
+				allBulkPriorAllocationIds);
 		}
 	}
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlotProfileRetriever.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlotProfileRetriever.java
index c6e5255f0f7..e2fd710624b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlotProfileRetriever.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SharedSlotProfileRetriever.java
@@ -23,7 +23,6 @@ import org.apache.flink.runtime.clusterframework.types.SlotProfile;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
 
 import java.util.Set;
-import java.util.concurrent.CompletableFuture;
 
 /**
  * Computes a {@link SlotProfile} to allocate a slot for executions, sharing the slot.
@@ -35,9 +34,9 @@ interface SharedSlotProfileRetriever {
 	 *
 	 * @param executionSlotSharingGroup executions sharing the slot.
 	 * @param physicalSlotResourceProfile {@link ResourceProfile} of the slot.
-	 * @return a future of the {@link SlotProfile} to allocate for the {@code executionSlotSharingGroup}.
+	 * @return {@link SlotProfile} to allocate for the {@code executionSlotSharingGroup}.
 	 */
-	CompletableFuture<SlotProfile> getSlotProfileFuture(
+	SlotProfile getSlotProfile(
 		ExecutionSlotSharingGroup executionSlotSharingGroup,
 		ResourceProfile physicalSlotResourceProfile);
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java
index 44c59ddd4ed..921e86d8d13 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocator.java
@@ -178,10 +178,11 @@ class SlotSharingExecutionSlotAllocator implements ExecutionSlotAllocator {
 			.computeIfAbsent(executionSlotSharingGroup, group -> {
 				SlotRequestId physicalSlotRequestId = new SlotRequestId();
 				ResourceProfile physicalSlotResourceProfile = getPhysicalSlotResourceProfile(group);
-				CompletableFuture<PhysicalSlot> physicalSlotFuture = sharedSlotProfileRetriever
-					.getSlotProfileFuture(group, physicalSlotResourceProfile)
-					.thenCompose(slotProfile -> slotProvider.allocatePhysicalSlot(
-						new PhysicalSlotRequest(physicalSlotRequestId, slotProfile, slotWillBeOccupiedIndefinitely)))
+				SlotProfile slotProfile = sharedSlotProfileRetriever.getSlotProfile(group, physicalSlotResourceProfile);
+				PhysicalSlotRequest physicalSlotRequest =
+					new PhysicalSlotRequest(physicalSlotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);
+				CompletableFuture<PhysicalSlot> physicalSlotFuture = slotProvider
+					.allocatePhysicalSlot(physicalSlotRequest)
 					.thenApply(PhysicalSlotRequest.Result::getPhysicalSlot);
 				return new SharedSlot(
 					physicalSlotRequestId,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorFactory.java
index bf3541719eb..a67e082cff6 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorFactory.java
@@ -52,8 +52,8 @@ class SlotSharingExecutionSlotAllocatorFactory implements ExecutionSlotAllocator
 			context.getSchedulingTopology(),
 			context.getLogicalSlotSharingGroups(),
 			context.getCoLocationGroups());
-		PreferredLocationsRetriever preferredLocationsRetriever =
-			new DefaultPreferredLocationsRetriever(context, context);
+		SyncPreferredLocationsRetriever preferredLocationsRetriever =
+				new DefaultSyncPreferredLocationsRetriever(context, context);
 		SharedSlotProfileRetrieverFactory sharedSlotProfileRetrieverFactory = new MergingSharedSlotProfileRetrieverFactory(
 			preferredLocationsRetriever,
 			context::getPriorAllocationId);
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SyncPreferredLocationsRetriever.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SyncPreferredLocationsRetriever.java
new file mode 100644
index 00000000000..722b918b76f
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SyncPreferredLocationsRetriever.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.scheduler;
+
+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
+
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * Component to retrieve the preferred locations of an execution vertex.
+ */
+@FunctionalInterface
+public interface SyncPreferredLocationsRetriever {
+
+	/**
+	 * Returns preferred locations of an execution vertex.
+	 *
+	 * @param executionVertexId id of the execution vertex
+	 * @param producersToIgnore producer vertices to ignore when calculating input locations
+	 * @return future of preferred locations
+	 */
+	Collection<TaskManagerLocation> getPreferredLocations(
+		ExecutionVertexID executionVertexId,
+		Set<ExecutionVertexID> producersToIgnore);
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetrieverTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetrieverTest.java
new file mode 100644
index 00000000000..7e13b4a9c0e
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/AvailableInputsLocationsRetrieverTest.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.scheduler;
+
+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.Test;
+
+import java.util.Collection;
+
+import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.createRandomExecutionVertexId;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.core.Is.is;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Tests for {@link AvailableInputsLocationsRetriever}.
+ */
+public class AvailableInputsLocationsRetrieverTest extends TestLogger {
+	private static final ExecutionVertexID EV1 = createRandomExecutionVertexId();
+	private static final ExecutionVertexID EV2 = createRandomExecutionVertexId();
+
+	@Test
+	public void testNoInputLocation() {
+		TestingInputsLocationsRetriever originalLocationRetriever = getOriginalLocationRetriever();
+		InputsLocationsRetriever availableInputsLocationsRetriever =
+			new AvailableInputsLocationsRetriever(originalLocationRetriever);
+		assertThat(availableInputsLocationsRetriever.getTaskManagerLocation(EV1).isPresent(), is(false));
+	}
+
+	@Test
+	public void testNoInputLocationIfNotDone() {
+		TestingInputsLocationsRetriever originalLocationRetriever = getOriginalLocationRetriever();
+		originalLocationRetriever.markScheduled(EV1);
+		InputsLocationsRetriever availableInputsLocationsRetriever =
+			new AvailableInputsLocationsRetriever(originalLocationRetriever);
+		assertThat(availableInputsLocationsRetriever.getTaskManagerLocation(EV1).isPresent(), is(false));
+	}
+
+	@Test
+	public void testNoInputLocationIfFailed() {
+		TestingInputsLocationsRetriever originalLocationRetriever = getOriginalLocationRetriever();
+		originalLocationRetriever.failTaskManagerLocation(EV1, new Throwable());
+		InputsLocationsRetriever availableInputsLocationsRetriever =
+			new AvailableInputsLocationsRetriever(originalLocationRetriever);
+		assertThat(availableInputsLocationsRetriever.getTaskManagerLocation(EV1).isPresent(), is(false));
+	}
+
+	@Test
+	public void testInputLocationIfDone() {
+		TestingInputsLocationsRetriever originalLocationRetriever = getOriginalLocationRetriever();
+		originalLocationRetriever.assignTaskManagerLocation(EV1);
+		InputsLocationsRetriever availableInputsLocationsRetriever =
+			new AvailableInputsLocationsRetriever(originalLocationRetriever);
+		assertThat(availableInputsLocationsRetriever.getTaskManagerLocation(EV1).isPresent(), is(true));
+	}
+
+	@Test
+	public void testConsumedResultPartitionsProducers() {
+		TestingInputsLocationsRetriever originalLocationRetriever = getOriginalLocationRetriever();
+		InputsLocationsRetriever availableInputsLocationsRetriever =
+			new AvailableInputsLocationsRetriever(originalLocationRetriever);
+		Collection<Collection<ExecutionVertexID>> producers =
+			availableInputsLocationsRetriever.getConsumedResultPartitionsProducers(EV2);
+		assertThat(producers.size(), is(1));
+		Collection<ExecutionVertexID> resultProducers = producers.iterator().next();
+		assertThat(resultProducers, contains(EV1));
+	}
+
+	private static TestingInputsLocationsRetriever getOriginalLocationRetriever() {
+		return new TestingInputsLocationsRetriever.Builder().connectConsumerToProducer(EV2, EV1).build();
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSyncPreferredLocationsRetrieverTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSyncPreferredLocationsRetrieverTest.java
new file mode 100644
index 00000000000..b26b87f4941
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSyncPreferredLocationsRetrieverTest.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.scheduler;
+
+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.Test;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Optional;
+
+import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.createRandomExecutionVertexId;
+import static org.hamcrest.Matchers.contains;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Tests for {@link DefaultSyncPreferredLocationsRetriever}.
+ */
+public class DefaultSyncPreferredLocationsRetrieverTest extends TestLogger {
+	private static final ExecutionVertexID EV1 = createRandomExecutionVertexId();
+	private static final ExecutionVertexID EV2 = createRandomExecutionVertexId();
+	private static final ExecutionVertexID EV3 = createRandomExecutionVertexId();
+	private static final ExecutionVertexID EV4 = createRandomExecutionVertexId();
+	private static final ExecutionVertexID EV5 = createRandomExecutionVertexId();
+
+	@Test
+	public void testAvailableInputLocationRetrieval() {
+		TestingInputsLocationsRetriever originalLocationRetriever =
+				new TestingInputsLocationsRetriever
+						.Builder()
+						.connectConsumerToProducer(EV5, EV1)
+						.connectConsumerToProducer(EV5, EV2)
+						.connectConsumerToProducer(EV5, EV3)
+						.connectConsumerToProducer(EV5, EV4)
+						.build();
+
+		originalLocationRetriever.assignTaskManagerLocation(EV1);
+		originalLocationRetriever.markScheduled(EV2);
+		originalLocationRetriever.failTaskManagerLocation(EV3, new Throwable());
+		originalLocationRetriever.cancelTaskManagerLocation(EV4);
+
+		SyncPreferredLocationsRetriever locationsRetriever =
+				new DefaultSyncPreferredLocationsRetriever(
+						executionVertexId -> Optional.empty(),
+						originalLocationRetriever);
+
+		Collection<TaskManagerLocation> preferredLocations = locationsRetriever
+				.getPreferredLocations(EV5, Collections.emptySet());
+		TaskManagerLocation expectedLocation = originalLocationRetriever
+				.getTaskManagerLocation(EV1)
+				.get()
+				.join();
+
+		assertThat(preferredLocations, contains(expectedLocation));
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverTest.java
index e06c59bcf1a..f54e0276fa6 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/MergingSharedSlotProfileRetrieverTest.java
@@ -39,7 +39,6 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
@@ -54,8 +53,8 @@ import static org.junit.Assert.assertThat;
  */
 public class MergingSharedSlotProfileRetrieverTest {
 
-	private static final PreferredLocationsRetriever EMPTY_PREFERRED_LOCATIONS_RETRIEVER =
-		(executionVertexId, producersToIgnore) -> CompletableFuture.completedFuture(Collections.emptyList());
+	private static final SyncPreferredLocationsRetriever EMPTY_PREFERRED_LOCATIONS_RETRIEVER =
+		(executionVertexId, producersToIgnore) -> Collections.emptyList();
 
 	@Test
 	public void testGetEmptySlotProfile() throws ExecutionException, InterruptedException {
@@ -65,8 +64,7 @@ public class MergingSharedSlotProfileRetrieverTest {
 		).createFromBulk(Collections.emptySet());
 
 		SlotProfile slotProfile = sharedSlotProfileRetriever
-			.getSlotProfileFuture(new ExecutionSlotSharingGroup(), ResourceProfile.ZERO)
-			.get();
+			.getSlotProfile(new ExecutionSlotSharingGroup(), ResourceProfile.ZERO);
 
 		assertThat(slotProfile.getTaskResourceProfile(), is(ResourceProfile.ZERO));
 		assertThat(slotProfile.getPhysicalSlotResourceProfile(), is(ResourceProfile.ZERO));
@@ -107,7 +105,7 @@ public class MergingSharedSlotProfileRetrieverTest {
 		SlotProfile slotProfile = getSlotProfile(
 			(executionVertexId, producersToIgnore) -> {
 				assertThat(producersToIgnore, containsInAnyOrder(executions.toArray()));
-				return CompletableFuture.completedFuture(locations.get(executionVertexId));
+				return locations.get(executionVertexId);
 			},
 			executions,
 			ResourceProfile.ZERO,
@@ -147,7 +145,7 @@ public class MergingSharedSlotProfileRetrieverTest {
 	}
 
 	private static SlotProfile getSlotProfile(
-			PreferredLocationsRetriever preferredLocationsRetriever,
+			SyncPreferredLocationsRetriever preferredLocationsRetriever,
 			List<ExecutionVertexID> executions,
 			ResourceProfile resourceProfile,
 			List<AllocationID> prevAllocationIDs,
@@ -159,7 +157,7 @@ public class MergingSharedSlotProfileRetrieverTest {
 
 		ExecutionSlotSharingGroup executionSlotSharingGroup = new ExecutionSlotSharingGroup();
 		executions.stream().limit(executionSlotSharingGroupSize).forEach(executionSlotSharingGroup::addVertex);
-		return sharedSlotProfileRetriever.getSlotProfileFuture(executionSlotSharingGroup, resourceProfile).get();
+		return sharedSlotProfileRetriever.getSlotProfile(executionSlotSharingGroup, resourceProfile);
 	}
 
 	private static TaskManagerLocation createTaskManagerLocation() {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java
index abdb023de11..aee349f796c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/SlotSharingExecutionSlotAllocatorTest.java
@@ -46,7 +46,6 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -92,19 +91,6 @@ public class SlotSharingExecutionSlotAllocatorTest extends TestLogger {
 		assertThat(context.getSlotProfileRetrieverFactory().getAskedGroups(), containsInAnyOrder(executionSlotSharingGroup));
 	}
 
-	@Test
-	public void testSlotRequestCompletionAfterProfileCompletion() {
-		AllocationContext context = AllocationContext.newBuilder().addGroup(EV1, EV2).completeSlotProfileFutureManually().build();
-		ExecutionSlotSharingGroup executionSlotSharingGroup =
-			context.getSlotSharingStrategy().getExecutionSlotSharingGroup(EV1);
-
-		List<SlotExecutionVertexAssignment> executionVertexAssignments = context.allocateSlotsFor(EV1, EV2);
-
-		executionVertexAssignments.forEach(assignment -> assertThat(assignment.getLogicalSlotFuture().isDone(), is(false)));
-		context.getSlotProfileRetrieverFactory().completeSlotProfileFutureFor(executionSlotSharingGroup, ResourceProfile.ANY);
-		executionVertexAssignments.forEach(assignment -> assertThat(assignment.getLogicalSlotFuture().isDone(), is(true)));
-	}
-
 	@Test
 	public void testSlotRequestProfile() {
 		AllocationContext context = AllocationContext.newBuilder().addGroup(EV1, EV2, EV3).build();
@@ -452,7 +438,6 @@ public class SlotSharingExecutionSlotAllocatorTest extends TestLogger {
 		private static class Builder {
 			private final Collection<ExecutionVertexID[]> groups = new ArrayList<>();
 			private boolean completePhysicalSlotFutureManually = false;
-			private boolean completeSlotProfileFutureManually = false;
 			private boolean slotWillBeOccupiedIndefinitely = false;
 			private PhysicalSlotRequestBulkChecker bulkChecker = new TestingPhysicalSlotRequestBulkChecker();
 
@@ -471,11 +456,6 @@ public class SlotSharingExecutionSlotAllocatorTest extends TestLogger {
 				return this;
 			}
 
-			private Builder completeSlotProfileFutureManually() {
-				this.completeSlotProfileFutureManually = true;
-				return this;
-			}
-
 			private Builder setSlotWillBeOccupiedIndefinitely(boolean slotWillBeOccupiedIndefinitely) {
 				this.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;
 				return this;
@@ -489,7 +469,7 @@ public class SlotSharingExecutionSlotAllocatorTest extends TestLogger {
 			private AllocationContext build() {
 				TestingPhysicalSlotProvider slotProvider = new TestingPhysicalSlotProvider(completePhysicalSlotFutureManually);
 				TestingSharedSlotProfileRetrieverFactory sharedSlotProfileRetrieverFactory =
-					new TestingSharedSlotProfileRetrieverFactory(completeSlotProfileFutureManually);
+					new TestingSharedSlotProfileRetrieverFactory();
 				TestingSlotSharingStrategy slotSharingStrategy = TestingSlotSharingStrategy.createWithGroups(groups);
 				SlotSharingExecutionSlotAllocator allocator = new SlotSharingExecutionSlotAllocator(
 					slotProvider,
@@ -608,14 +588,10 @@ public class SlotSharingExecutionSlotAllocatorTest extends TestLogger {
 	private static class TestingSharedSlotProfileRetrieverFactory implements SharedSlotProfileRetrieverFactory {
 		private final List<Set<ExecutionVertexID>> askedBulks;
 		private final List<ExecutionSlotSharingGroup> askedGroups;
-		private final Map<ExecutionSlotSharingGroup, CompletableFuture<SlotProfile>> slotProfileFutures;
-		private final boolean completeSlotProfileFutureManually;
 
-		private TestingSharedSlotProfileRetrieverFactory(boolean completeSlotProfileFutureManually) {
-			this.completeSlotProfileFutureManually = completeSlotProfileFutureManually;
+		private TestingSharedSlotProfileRetrieverFactory() {
 			this.askedBulks = new ArrayList<>();
 			this.askedGroups = new ArrayList<>();
-			this.slotProfileFutures = new IdentityHashMap<>();
 		}
 
 		@Override
@@ -623,19 +599,10 @@ public class SlotSharingExecutionSlotAllocatorTest extends TestLogger {
 			askedBulks.add(bulk);
 			return (group, resourceProfile) -> {
 				askedGroups.add(group);
-				CompletableFuture<SlotProfile> slotProfileFuture =
-					slotProfileFutures.computeIfAbsent(group, g -> new CompletableFuture<>());
-				if (!completeSlotProfileFutureManually) {
-					completeSlotProfileFutureFor(group, resourceProfile);
-				}
-				return slotProfileFuture;
+				return SlotProfile.noLocality(resourceProfile);
 			};
 		}
 
-		private void completeSlotProfileFutureFor(ExecutionSlotSharingGroup group, ResourceProfile resourceProfile) {
-			slotProfileFutures.get(group).complete(SlotProfile.noLocality(resourceProfile));
-		}
-
 		private List<Set<ExecutionVertexID>> getAskedBulks() {
 			return Collections.unmodifiableList(askedBulks);
 		}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestingInputsLocationsRetriever.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestingInputsLocationsRetriever.java
index 113740aef89..7e1682dc451 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestingInputsLocationsRetriever.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/TestingInputsLocationsRetriever.java
@@ -75,6 +75,28 @@ class TestingInputsLocationsRetriever implements InputsLocationsRetriever {
 		});
 	}
 
+	void failTaskManagerLocation(final ExecutionVertexID executionVertexId, final Throwable cause) {
+		taskManagerLocationsByVertex.compute(executionVertexId, (key, future) -> {
+			CompletableFuture<TaskManagerLocation> futureToFail = future;
+			if (futureToFail == null) {
+				futureToFail = new CompletableFuture<>();
+			}
+			futureToFail.completeExceptionally(cause);
+			return futureToFail;
+		});
+	}
+
+	void cancelTaskManagerLocation(final ExecutionVertexID executionVertexId) {
+		taskManagerLocationsByVertex.compute(executionVertexId, (key, future) -> {
+			CompletableFuture<TaskManagerLocation> futureToCancel = future;
+			if (futureToCancel == null) {
+				futureToCancel = new CompletableFuture<>();
+			}
+			futureToCancel.cancel(true);
+			return futureToCancel;
+		});
+	}
+
 	static class Builder {
 
 		private final Map<ExecutionVertexID, List<ExecutionVertexID>> producersByConsumer = new HashMap<>();
