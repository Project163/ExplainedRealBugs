diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java
index 75690ab7b1a..034b1e1b658 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertex.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.runtime.executiongraph;
 
-import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.Archiveable;
 import org.apache.flink.api.common.ExecutionConfig;
 import org.apache.flink.api.common.InputDependencyConstraint;
@@ -26,7 +25,6 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.accumulators.Accumulator;
 import org.apache.flink.api.common.accumulators.AccumulatorHelper;
 import org.apache.flink.api.common.time.Time;
-import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.configuration.MemorySize;
 import org.apache.flink.core.io.InputSplit;
 import org.apache.flink.core.io.InputSplitAssigner;
@@ -126,27 +124,7 @@ public class ExecutionJobVertex implements AccessExecutionJobVertex, Archiveable
 
 	private InputSplitAssigner splitAssigner;
 
-	/**
-	 * Convenience constructor for testing.
-	 */
-	@VisibleForTesting
 	ExecutionJobVertex(
-			ExecutionGraph graph,
-			JobVertex jobVertex,
-			int defaultParallelism,
-			Time timeout) throws JobException {
-
-		this(
-			graph,
-			jobVertex,
-			defaultParallelism,
-			JobManagerOptions.MAX_ATTEMPTS_HISTORY_SIZE.defaultValue(),
-			timeout,
-			1L,
-			System.currentTimeMillis());
-	}
-
-	public ExecutionJobVertex(
 			ExecutionGraph graph,
 			JobVertex jobVertex,
 			int defaultParallelism,
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java
index 35023eecafb..a393dd47148 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/ExecutionVertex.java
@@ -23,7 +23,6 @@ import org.apache.flink.api.common.Archiveable;
 import org.apache.flink.api.common.InputDependencyConstraint;
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.time.Time;
-import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.core.io.InputSplit;
 import org.apache.flink.core.io.InputSplitAssigner;
 import org.apache.flink.runtime.JobException;
@@ -101,26 +100,6 @@ public class ExecutionVertex implements AccessExecutionVertex, Archiveable<Archi
 
 	// --------------------------------------------------------------------------------------------
 
-	/**
-	 * Convenience constructor for tests. Sets various fields to default values.
-	 */
-	@VisibleForTesting
-	ExecutionVertex(
-			ExecutionJobVertex jobVertex,
-			int subTaskIndex,
-			IntermediateResult[] producedDataSets,
-			Time timeout) {
-
-		this(
-			jobVertex,
-			subTaskIndex,
-			producedDataSets,
-			timeout,
-			1L,
-			System.currentTimeMillis(),
-			JobManagerOptions.MAX_ATTEMPTS_HISTORY_SIZE.defaultValue());
-	}
-
 	/**
 	 * Creates an ExecutionVertex.
 	 *
@@ -133,7 +112,7 @@ public class ExecutionVertex implements AccessExecutionVertex, Archiveable<Archi
 	 * @param maxPriorExecutionHistoryLength
 	 *            The number of prior Executions (= execution attempts) to keep.
 	 */
-	public ExecutionVertex(
+	ExecutionVertex(
 			ExecutionJobVertex jobVertex,
 			int subTaskIndex,
 			IntermediateResult[] producedDataSets,
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperationTest.java
index 7fed3cdd117..4eaa8bf6f17 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperationTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperationTest.java
@@ -18,13 +18,11 @@
 
 package org.apache.flink.runtime.checkpoint;
 
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.JobException;
 import org.apache.flink.runtime.OperatorIDPair;
 import org.apache.flink.runtime.client.JobExecutionException;
-import org.apache.flink.runtime.executiongraph.ExecutionGraph;
+import org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
-import org.apache.flink.runtime.executiongraph.TestingExecutionGraphBuilder;
 import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobgraph.OperatorID;
@@ -33,6 +31,7 @@ import org.apache.flink.runtime.state.KeyGroupRange;
 import org.apache.flink.runtime.state.OperatorStateHandle;
 import org.apache.flink.runtime.state.OperatorStreamStateHandle;
 import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.Assert;
@@ -325,7 +324,7 @@ public class StateAssignmentOperationTest extends TestLogger {
 	}
 
 	@Test
-	public void assigningStatesShouldWorkWithUserDefinedOperatorIdsAsWell() throws JobException, JobExecutionException {
+	public void assigningStatesShouldWorkWithUserDefinedOperatorIdsAsWell() throws Exception {
 		int numSubTasks = 1;
 		OperatorID operatorId = new OperatorID();
 		OperatorID userDefinedOperatorId = new OperatorID();
@@ -375,17 +374,22 @@ public class StateAssignmentOperationTest extends TestLogger {
 			}));
 	}
 
-	private ExecutionJobVertex buildExecutionJobVertex(OperatorID operatorID, int parallelism) throws JobException, JobExecutionException {
+	private ExecutionJobVertex buildExecutionJobVertex(OperatorID operatorID, int parallelism) throws Exception {
 		return buildExecutionJobVertex(operatorID, operatorID, parallelism);
 	}
 
-	private ExecutionJobVertex buildExecutionJobVertex(OperatorID operatorID, OperatorID userDefinedOperatorId, int parallelism) throws JobException, JobExecutionException {
-		ExecutionGraph graph = TestingExecutionGraphBuilder.newBuilder().build();
+	private ExecutionJobVertex buildExecutionJobVertex(
+			OperatorID operatorID,
+			OperatorID userDefinedOperatorId,
+			int parallelism) throws Exception {
+
 		JobVertex jobVertex = new JobVertex(
 			operatorID.toHexString(),
 			new JobVertexID(),
 			singletonList(OperatorIDPair.of(operatorID, userDefinedOperatorId)));
-		return new ExecutionJobVertex(graph, jobVertex, parallelism, 1, Time.seconds(1), 1L, 1L);
+		jobVertex.setInvokableClass(NoOpInvokable.class);
+		jobVertex.setParallelism(parallelism);
+		return ExecutionGraphTestUtils.getExecutionJobVertex(jobVertex);
 	}
 
 	private OperatorSubtaskState getAssignedState(ExecutionJobVertex executionJobVertex, OperatorID operatorId, int subtaskIdx) {
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/AllVerticesIteratorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/AllVerticesIteratorTest.java
index 783440a3f7d..e0f4cf84bc7 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/AllVerticesIteratorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/AllVerticesIteratorTest.java
@@ -18,15 +18,11 @@
 
 package org.apache.flink.runtime.executiongraph;
 
-import org.apache.flink.api.common.JobID;
-import org.apache.flink.configuration.Configuration;
-import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
-import org.apache.flink.runtime.testingUtils.TestingUtils;
+
 import org.junit.Assert;
 import org.junit.Test;
-import org.mockito.Mockito;
 
 import java.util.Arrays;
 
@@ -50,22 +46,13 @@ public class AllVerticesIteratorTest {
 			v2.setParallelism(7);
 			v3.setParallelism(3);
 			v4.setParallelism(2);
-			
-			ExecutionGraph eg = Mockito.mock(ExecutionGraph.class);
-			Configuration jobConf = new Configuration();
-			Mockito.when(eg.getFutureExecutor()).thenReturn(TestingUtils.directExecutionContext());
-			Mockito.when(eg.getJobConfiguration()).thenReturn(jobConf);
-			Mockito.when(eg.getJobID()).thenReturn(new JobID());
 
-			ExecutionJobVertex ejv1 = new ExecutionJobVertex(eg, v1, 1,
-					AkkaUtils.getDefaultTimeout());
-			ExecutionJobVertex ejv2 = new ExecutionJobVertex(eg, v2, 1,
-					AkkaUtils.getDefaultTimeout());
-			ExecutionJobVertex ejv3 = new ExecutionJobVertex(eg, v3, 1,
-					AkkaUtils.getDefaultTimeout());
-			ExecutionJobVertex ejv4 = new ExecutionJobVertex(eg, v4, 1,
-					AkkaUtils.getDefaultTimeout());
-			
+			ExecutionGraph eg = ExecutionGraphTestUtils.createSimpleTestGraph(v1, v2, v3, v4);
+			ExecutionJobVertex ejv1 = eg.getJobVertex(v1.getID());
+			ExecutionJobVertex ejv2 = eg.getJobVertex(v2.getID());
+			ExecutionJobVertex ejv3 = eg.getJobVertex(v3.getID());
+			ExecutionJobVertex ejv4 = eg.getJobVertex(v4.getID());
+
 			AllVerticesIterator iter = new AllVerticesIterator(Arrays.asList(ejv1, ejv2, ejv3, ejv4).iterator());
 			
 			int numReturned = 0;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java
index b9e23ef3ee1..ea7266f7248 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java
@@ -38,7 +38,6 @@ import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
 import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;
 import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;
-import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
@@ -47,11 +46,8 @@ import javax.annotation.Nullable;
 
 import java.lang.reflect.Field;
 import java.time.Duration;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 import java.util.Random;
-import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeoutException;
 import java.util.function.Predicate;
@@ -433,7 +429,19 @@ public class ExecutionGraphTestUtils {
 			ajv.setSlotSharingGroup(slotSharingGroup);
 		}
 
-		JobGraph jobGraph = new JobGraph(ajv);
+		return getExecutionJobVertex(ajv, executor, scheduleMode);
+	}
+
+	public static ExecutionJobVertex getExecutionJobVertex(JobVertex jobVertex) throws Exception {
+		return getExecutionJobVertex(jobVertex, new DirectScheduledExecutorService(), ScheduleMode.LAZY_FROM_SOURCES);
+	}
+
+	public static ExecutionJobVertex getExecutionJobVertex(
+			JobVertex jobVertex,
+			ScheduledExecutorService executor,
+			ScheduleMode scheduleMode) throws Exception {
+
+		JobGraph jobGraph = new JobGraph(jobVertex);
 		jobGraph.setScheduleMode(scheduleMode);
 
 		ExecutionGraph graph = TestingExecutionGraphBuilder
@@ -445,39 +453,20 @@ public class ExecutionGraphTestUtils {
 
 		graph.start(ComponentMainThreadExecutorServiceAdapter.forMainThread());
 
-		return new ExecutionJobVertex(graph, ajv, 1, AkkaUtils.getDefaultTimeout());
+		return graph.getJobVertex(jobVertex.getID());
 	}
 
 	public static ExecutionJobVertex getExecutionJobVertex(JobVertexID id) throws Exception {
 		return getExecutionJobVertex(id, new DirectScheduledExecutorService());
 	}
 
-	public static Execution getExecution() throws Exception {
-		final ExecutionJobVertex ejv = getExecutionJobVertex(new JobVertexID());
-		return ejv.getTaskVertices()[0].getCurrentExecutionAttempt();
+	public static ExecutionVertex getExecutionVertex() throws Exception {
+		return getExecutionJobVertex(new JobVertexID(), new DirectScheduledExecutorService()).getTaskVertices()[0];
 	}
 
-	public static Execution getExecution(final TaskManagerLocation... preferredLocations) throws Exception {
-		return getExecution(mapToPreferredLocationFutures(preferredLocations));
-	}
-
-	private static Collection<CompletableFuture<TaskManagerLocation>> mapToPreferredLocationFutures(
-			final TaskManagerLocation... preferredLocations) {
-
-		final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures = new ArrayList<>();
-		for (TaskManagerLocation preferredLocation : preferredLocations) {
-			preferredLocationFutures.add(CompletableFuture.completedFuture(preferredLocation));
-		}
-		return preferredLocationFutures;
-	}
-
-	public static Execution getExecution(
-			final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures) throws Exception {
-
+	public static Execution getExecution() throws Exception {
 		final ExecutionJobVertex ejv = getExecutionJobVertex(new JobVertexID());
-		final TestExecutionVertex ev = new TestExecutionVertex(ejv, 0, new IntermediateResult[0], DEFAULT_TIMEOUT);
-		ev.setPreferredLocationFutures(preferredLocationFutures);
-		return ev.getCurrentExecutionAttempt();
+		return ejv.getTaskVertices()[0].getCurrentExecutionAttempt();
 	}
 
 	public static Execution getExecution(
@@ -486,33 +475,14 @@ public class ExecutionGraphTestUtils {
 			final int numTasks,
 			final SlotSharingGroup slotSharingGroup) throws Exception {
 
-		return getExecution(jid, subtaskIndex, numTasks, slotSharingGroup, null);
-	}
-
-	public static Execution getExecution(
-			final JobVertexID jid,
-			final int subtaskIndex,
-			final int numTasks,
-			final SlotSharingGroup slotSharingGroup,
-			@Nullable final TaskManagerLocation... locations) throws Exception {
-
 		final ExecutionJobVertex ejv = getExecutionJobVertex(
 			jid,
 			numTasks,
 			slotSharingGroup,
 			new DirectScheduledExecutorService(),
 			ScheduleMode.LAZY_FROM_SOURCES);
-		final TestExecutionVertex ev = new TestExecutionVertex(
-			ejv,
-			subtaskIndex,
-			new IntermediateResult[0],
-			DEFAULT_TIMEOUT);
-
-		if (locations != null) {
-			ev.setPreferredLocationFutures(mapToPreferredLocationFutures(locations));
-		}
 
-		return ev.getCurrentExecutionAttempt();
+		return ejv.getTaskVertices()[subtaskIndex].getCurrentExecutionAttempt();
 	}
 
 	// ------------------------------------------------------------------------
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertexTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertexTest.java
index 3c350640f50..b3202fb031b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertexTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionJobVertexTest.java
@@ -18,12 +18,9 @@
 
 package org.apache.flink.runtime.executiongraph;
 
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.JobException;
-import org.apache.flink.runtime.client.JobExecutionException;
 import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
-import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
 
 import org.junit.Assert;
 import org.junit.Test;
@@ -122,7 +119,7 @@ public class ExecutionJobVertexTest {
 
 	public static ExecutionJobVertex createExecutionJobVertex(
 			int parallelism,
-			int preconfiguredMaxParallelism) throws JobException, JobExecutionException {
+			int preconfiguredMaxParallelism) throws Exception {
 		JobVertex jobVertex = new JobVertex("testVertex");
 		jobVertex.setInvokableClass(AbstractInvokable.class);
 		jobVertex.setParallelism(parallelism);
@@ -131,16 +128,6 @@ public class ExecutionJobVertexTest {
 			jobVertex.setMaxParallelism(preconfiguredMaxParallelism);
 		}
 
-		ExecutionGraph executionGraph = createExecutionGraph();
-		return new ExecutionJobVertex(executionGraph, jobVertex, 1, Time.seconds(10));
-	}
-
-	private static ExecutionGraph createExecutionGraph() throws JobException, JobExecutionException {
-		final ExecutionGraph executionGraph = TestingExecutionGraphBuilder
-			.newBuilder()
-			.setFutureExecutor(new DirectScheduledExecutorService())
-			.build();
-		executionGraph.transitionToRunning();
-		return executionGraph;
+		return ExecutionGraphTestUtils.getExecutionJobVertex(jobVertex);
 	}
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java
index 665e97204e1..ac6ef963462 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexCancelTest.java
@@ -20,16 +20,13 @@ package org.apache.flink.runtime.executiongraph;
 
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.time.Time;
-import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.concurrent.FutureUtils;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobmanager.scheduler.LocationPreferenceConstraint;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
 import org.apache.flink.runtime.jobmaster.TestingLogicalSlotBuilder;
 import org.apache.flink.runtime.messages.Acknowledge;
-import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
 import org.apache.flink.util.TestLogger;
 
 import org.junit.Test;
@@ -38,7 +35,7 @@ import java.io.IOException;
 import java.util.Collections;
 import java.util.concurrent.CompletableFuture;
 
-import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionJobVertex;
+import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionVertex;
 import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.setVertexResource;
 import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.setVertexState;
 import static org.junit.Assert.assertEquals;
@@ -59,11 +56,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	@Test
 	public void testCancelFromCreated() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());
 
@@ -86,11 +79,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	@Test
 	public void testCancelFromScheduled() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			setVertexState(vertex, ExecutionState.SCHEDULED);
 			assertEquals(ExecutionState.SCHEDULED, vertex.getExecutionState());
@@ -114,11 +103,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	@Test
 	public void testCancelFromRunning() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			LogicalSlot slot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new CancelSequenceSimpleAckingTaskManagerGateway(1)).createTestingLogicalSlot();
 
@@ -148,12 +133,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	@Test
 	public void testRepeatedCancelFromRunning() {
 		try {
-
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			LogicalSlot slot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new CancelSequenceSimpleAckingTaskManagerGateway(1)).createTestingLogicalSlot();
 
@@ -192,11 +172,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	public void testCancelFromRunningDidNotFindTask() {
 		// this may happen when the task finished or failed while the call was in progress
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			LogicalSlot slot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new CancelSequenceSimpleAckingTaskManagerGateway(1)).createTestingLogicalSlot();
 
@@ -222,11 +198,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	@Test
 	public void testCancelCallFails() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			LogicalSlot slot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new CancelSequenceSimpleAckingTaskManagerGateway(0)).createTestingLogicalSlot();
 
@@ -279,11 +251,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	@Test
 	public void testScheduleOrDeployAfterCancel() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 			setVertexState(vertex, ExecutionState.CANCELED);
 
 			assertEquals(ExecutionState.CANCELED, vertex.getExecutionState());
@@ -324,13 +292,9 @@ public class ExecutionVertexCancelTest extends TestLogger {
 	public void testActionsWhileCancelling() {
 
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
-
 			// scheduling while canceling is an illegal state transition
 			try {
-				ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-						AkkaUtils.getDefaultTimeout());
+				final ExecutionVertex vertex = getExecutionVertex();
 				setVertexState(vertex, ExecutionState.CANCELING);
 				vertex.scheduleForExecution(
 					TestingSlotProviderStrategy.from(new ProgrammedSlotProvider(1)),
@@ -343,8 +307,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 
 			// deploying while in canceling state is illegal (should immediately go to canceled)
 			try {
-				ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-						AkkaUtils.getDefaultTimeout());
+				final ExecutionVertex vertex = getExecutionVertex();
 				setVertexState(vertex, ExecutionState.CANCELING);
 
 				final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
@@ -358,8 +321,7 @@ public class ExecutionVertexCancelTest extends TestLogger {
 
 			// fail while canceling
 			{
-				ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-						AkkaUtils.getDefaultTimeout());
+				final ExecutionVertex vertex = getExecutionVertex();
 
 				final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexDeploymentTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexDeploymentTest.java
index e51e61bcf22..269c935772a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexDeploymentTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexDeploymentTest.java
@@ -19,7 +19,6 @@
 package org.apache.flink.runtime.executiongraph;
 
 import org.apache.flink.api.common.time.Time;
-import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;
@@ -28,14 +27,14 @@ import org.apache.flink.runtime.deployment.TaskDeploymentDescriptorFactory;
 import org.apache.flink.runtime.execution.ExecutionState;
 import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
-import org.apache.flink.runtime.jobgraph.IntermediateDataSetID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
+import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.ScheduleMode;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
 import org.apache.flink.runtime.jobmaster.TestingLogicalSlot;
 import org.apache.flink.runtime.jobmaster.TestingLogicalSlotBuilder;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
 import org.apache.flink.util.TestLogger;
 
@@ -45,7 +44,7 @@ import java.net.InetAddress;
 import java.util.Collection;
 import java.util.concurrent.CompletableFuture;
 
-import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionJobVertex;
+import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionVertex;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
@@ -61,15 +60,10 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testDeployCall() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
 
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-				AkkaUtils.getDefaultTimeout());
-
 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());
 			vertex.deployToSlot(slot);
 			assertEquals(ExecutionState.DEPLOYING, vertex.getExecutionState());
@@ -95,15 +89,10 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testDeployWithSynchronousAnswer() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
 
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-				AkkaUtils.getDefaultTimeout());
-
 			assertEquals(ExecutionState.CREATED, vertex.getExecutionState());
 
 			vertex.deployToSlot(slot);
@@ -132,11 +121,7 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testDeployWithAsynchronousAnswer() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-				AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
 
@@ -174,11 +159,7 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testDeployFailedSynchronous() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-				AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new SubmitFailingSimpleAckingTaskManagerGateway()).createTestingLogicalSlot();
 
@@ -202,10 +183,7 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testDeployFailedAsynchronously() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-			final ExecutionJobVertex ejv = getExecutionJobVertex(jid);
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-				AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new SubmitFailingSimpleAckingTaskManagerGateway()).createTestingLogicalSlot();
 
@@ -238,12 +216,7 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testFailExternallyDuringDeploy() {
 		try {
-			final JobVertexID jid = new JobVertexID();
-
-			final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(jid, new DirectScheduledExecutorService());
-
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-				AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			TestingLogicalSlot testingLogicalSlot = new TestingLogicalSlotBuilder().setTaskManagerGateway(new SubmitBlockingSimpleAckingTaskManagerGateway()).createTestingLogicalSlot();
 
@@ -288,17 +261,18 @@ public class ExecutionVertexDeploymentTest extends TestLogger {
 	@Test
 	public void testTddProducedPartitionsLazyScheduling() throws Exception {
 		for (ScheduleMode scheduleMode: ScheduleMode.values()) {
-			ExecutionJobVertex jobVertex = ExecutionGraphTestUtils.getExecutionJobVertex(
-				new JobVertexID(),
+			JobVertex jobVertex = new JobVertex("v1");
+			jobVertex.setInvokableClass(NoOpInvokable.class);
+			jobVertex.createAndAddResultDataSet(ResultPartitionType.PIPELINED);
+			ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(
+				jobVertex,
 				new DirectScheduledExecutorService(),
 				scheduleMode);
 
-			IntermediateResult result =
-				new IntermediateResult(new IntermediateDataSetID(), jobVertex, 1, ResultPartitionType.PIPELINED);
+			IntermediateResult result = ejv.getProducedDataSets()[0];
 
 			ExecutionAttemptID attemptID = new ExecutionAttemptID();
-			ExecutionVertex vertex =
-				new ExecutionVertex(jobVertex, 0, new IntermediateResult[]{result}, Time.minutes(1));
+			ExecutionVertex vertex = ejv.getTaskVertices()[0];
 			TaskDeploymentDescriptorFactory tddFactory =
 				TaskDeploymentDescriptorFactory.fromExecutionVertex(vertex, 1);
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java
index 45e920a0d6b..bd5d84bc930 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionVertexSchedulingTest.java
@@ -18,9 +18,7 @@
 
 package org.apache.flink.runtime.executiongraph;
 
-import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.execution.ExecutionState;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobmanager.scheduler.LocationPreferenceConstraint;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
 import org.apache.flink.runtime.jobmaster.TestingLogicalSlotBuilder;
@@ -31,7 +29,7 @@ import org.junit.Test;
 import java.util.Collections;
 import java.util.concurrent.CompletableFuture;
 
-import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionJobVertex;
+import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionVertex;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.fail;
@@ -41,9 +39,7 @@ public class ExecutionVertexSchedulingTest extends TestLogger {
 	@Test
 	public void testSlotReleasedWhenScheduledImmediately() {
 		try {
-			final ExecutionJobVertex ejv = getExecutionJobVertex(new JobVertexID());
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			// a slot than cannot be deployed to
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
@@ -73,9 +69,7 @@ public class ExecutionVertexSchedulingTest extends TestLogger {
 	@Test
 	public void testSlotReleasedWhenScheduledQueued() {
 		try {
-			final ExecutionJobVertex ejv = getExecutionJobVertex(new JobVertexID());
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			// a slot than cannot be deployed to
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
@@ -109,9 +103,7 @@ public class ExecutionVertexSchedulingTest extends TestLogger {
 	@Test
 	public void testScheduleToDeploying() {
 		try {
-			final ExecutionJobVertex ejv = getExecutionJobVertex(new JobVertexID());
-			final ExecutionVertex vertex = new ExecutionVertex(ejv, 0, new IntermediateResult[0],
-					AkkaUtils.getDefaultTimeout());
+			final ExecutionVertex vertex = getExecutionVertex();
 
 			final LogicalSlot slot = new TestingLogicalSlotBuilder().createTestingLogicalSlot();
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/IntermediateResultPartitionTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/IntermediateResultPartitionTest.java
index 918f98b225d..7677f35c758 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/IntermediateResultPartitionTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/IntermediateResultPartitionTest.java
@@ -18,12 +18,13 @@
 
 package org.apache.flink.runtime.executiongraph;
 
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.runtime.io.network.partition.ResultPartitionType;
-import org.apache.flink.runtime.jobgraph.IntermediateDataSetID;
-import org.apache.flink.runtime.jobgraph.JobVertexID;
+import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobgraph.ScheduleMode;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
 import org.apache.flink.util.TestLogger;
+
 import org.junit.Test;
 
 import static org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils.getExecutionJobVertex;
@@ -131,13 +132,13 @@ public class IntermediateResultPartitionTest extends TestLogger {
 			ResultPartitionType resultPartitionType,
 			int producerCount) throws Exception {
 
-		ExecutionJobVertex jobVertex = getExecutionJobVertex(new JobVertexID(), new DirectScheduledExecutorService());
-		IntermediateResult result =
-				new IntermediateResult(new IntermediateDataSetID(), jobVertex, producerCount, resultPartitionType);
-		for (int i = 0; i < producerCount; i++) {
-			// Generate result partition in the result
-			new ExecutionVertex(jobVertex, i, new IntermediateResult[]{result}, Time.minutes(1));
-		}
+		JobVertex jobVertex = new JobVertex("v1");
+		jobVertex.setInvokableClass(NoOpInvokable.class);
+		jobVertex.setParallelism(producerCount);
+		jobVertex.createAndAddResultDataSet(resultPartitionType);
+
+		ExecutionJobVertex ejv = getExecutionJobVertex(jobVertex, new DirectScheduledExecutorService(), ScheduleMode.LAZY_FROM_SOURCES);
+		IntermediateResult result = ejv.getProducedDataSets()[0];
 
 		return result;
 	}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/TestExecutionVertex.java b/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/TestExecutionVertex.java
deleted file mode 100644
index cb6f3387b02..00000000000
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/TestExecutionVertex.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.flink.runtime.executiongraph;
-
-import org.apache.flink.api.common.time.Time;
-import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
-
-import java.util.Collection;
-import java.util.concurrent.CompletableFuture;
-
-/**
- * An {@link ExecutionVertex} implementation for testing.
- */
-public class TestExecutionVertex extends ExecutionVertex {
-
-	private Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures;
-
-	TestExecutionVertex(
-		ExecutionJobVertex jobVertex,
-		int subTaskIndex,
-		IntermediateResult[] producedDataSets,
-		Time timeout) {
-
-		super(
-			jobVertex,
-			subTaskIndex,
-			producedDataSets,
-			timeout);
-	}
-
-	public void setPreferredLocationFutures(final Collection<CompletableFuture<TaskManagerLocation>> preferredLocationFutures) {
-		this.preferredLocationFutures = preferredLocationFutures;
-	}
-
-	@Override
-	public Collection<CompletableFuture<TaskManagerLocation>> getPreferredLocations() {
-		return preferredLocationFutures != null ? preferredLocationFutures : super.getPreferredLocations();
-	}
-}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/ScheduleWithCoLocationHintTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/ScheduleWithCoLocationHintTest.java
index 79a6aba8e93..b01421e07b1 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/ScheduleWithCoLocationHintTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/ScheduleWithCoLocationHintTest.java
@@ -306,25 +306,25 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 
 		// schedule something into the shared group so that both instances are in the sharing group
 		LogicalSlot s1 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s2 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 
 		// schedule one locally to instance 1
 		LogicalSlot s3 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		// schedule with co location constraint (yet unassigned) and a preference for
 		// instance 1, but it can only get instance 2
 		LogicalSlot s4 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		// schedule something into the assigned co-location constraints and check that they override the
 		// other preferences
 		LogicalSlot s5 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid3, 0, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid3, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 		LogicalSlot s6 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid3, 1, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid3, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		// check that each slot got three
 		assertEquals(s1.getTaskManagerLocation(), s3.getTaskManagerLocation());
@@ -366,9 +366,9 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 		CoLocationConstraint cc2 = new CoLocationConstraint(ccg);
 
 		LogicalSlot s1 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s2 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 
 		s1.releaseSlot();
 		s2.releaseSlot();
@@ -376,9 +376,9 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 		assertEquals(2, testingSlotProvider.getNumberOfAvailableSlots());
 
 		LogicalSlot s3 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 		LogicalSlot s4 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		// still preserves the previous instance mapping)
 		assertEquals(loc1, s3.getTaskManagerLocation());
@@ -412,9 +412,9 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 		CoLocationConstraint cc2 = new CoLocationConstraint(ccg);
 
 		LogicalSlot s1 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s2 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 
 		s1.releaseSlot();
 		s2.releaseSlot();
@@ -428,7 +428,7 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 
 		try {
 			testingSlotProvider.allocateSlot(
-					new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+					new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 			fail("should not be able to find a resource");
 		}
 		catch (ExecutionException e) {
@@ -468,14 +468,14 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 		// and give locality preferences that hint at using the same shared slot for both
 		// co location constraints (which we seek to prevent)
 		LogicalSlot s1 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s2 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		LogicalSlot s3 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s4 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		// check that each slot got three
 		assertEquals(s1.getTaskManagerLocation(), s3.getTaskManagerLocation());
@@ -513,14 +513,14 @@ public class ScheduleWithCoLocationHintTest extends SchedulerTestBase {
 		CoLocationConstraint cc2 = new CoLocationConstraint(ccg);
 
 		LogicalSlot s1 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc1), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s2 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup, loc2), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid1, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId(), cc2), slotProfileForLocation(loc2), TestingUtils.infiniteTime()).get();
 
 		LogicalSlot s3 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 0, 2, sharingGroup), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 		LogicalSlot s4 = testingSlotProvider.allocateSlot(
-				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup, loc1), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
+				new ScheduledUnit(getExecution(jid2, 1, 2, sharingGroup), sharingGroup.getSlotSharingGroupId()), slotProfileForLocation(loc1), TestingUtils.infiniteTime()).get();
 
 		// check that each slot got two
 		assertEquals(s1.getTaskManagerLocation(), s3.getTaskManagerLocation());
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/SchedulerIsolatedTasksTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/SchedulerIsolatedTasksTest.java
index 2cf19833be0..e467b4e87cb 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/SchedulerIsolatedTasksTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmanager/scheduler/SchedulerIsolatedTasksTest.java
@@ -28,7 +28,6 @@ import org.apache.flink.runtime.instance.SlotSharingGroupId;
 import org.apache.flink.runtime.jobgraph.JobVertexID;
 import org.apache.flink.runtime.jobmaster.LogicalSlot;
 import org.apache.flink.runtime.jobmaster.SlotRequestId;
-import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;
 import org.apache.flink.runtime.taskmanager.TaskManagerLocation;
 import org.apache.flink.runtime.testingUtils.TestingUtils;
 import org.apache.flink.util.ExceptionUtils;
@@ -192,7 +191,7 @@ public class SchedulerIsolatedTasksTest extends SchedulerTestBase {
 		final TaskManagerLocation taskManagerLocation3 = testingSlotProvider.addTaskManager(2);
 
 		// schedule something on an arbitrary instance
-		LogicalSlot s1 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(new LocalTaskManagerLocation())), SlotProfile.noRequirements(), TestingUtils.infiniteTime()).get();
+		LogicalSlot s1 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), SlotProfile.noRequirements(), TestingUtils.infiniteTime()).get();
 
 		// figure out how we use the location hints
 		ResourceID firstResourceId = s1.getTaskManagerLocation().getResourceID();
@@ -214,28 +213,28 @@ public class SchedulerIsolatedTasksTest extends SchedulerTestBase {
 		TaskManagerLocation third = taskManagerLocations.get((index + 2) % taskManagerLocations.size());
 
 		// something that needs to go to the first instance again
-		LogicalSlot s2 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(s1.getTaskManagerLocation())), slotProfileForLocation(s1.getTaskManagerLocation()), TestingUtils.infiniteTime()).get();
+		LogicalSlot s2 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), slotProfileForLocation(s1.getTaskManagerLocation()), TestingUtils.infiniteTime()).get();
 		assertEquals(first.getResourceID(), s2.getTaskManagerLocation().getResourceID());
 
 		// first or second --> second, because first is full
-		LogicalSlot s3 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(first, second)), slotProfileForLocation(first, second), TestingUtils.infiniteTime()).get();
+		LogicalSlot s3 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), slotProfileForLocation(first, second), TestingUtils.infiniteTime()).get();
 		assertEquals(second.getResourceID(), s3.getTaskManagerLocation().getResourceID());
 
 		// first or third --> third (because first is full)
-		LogicalSlot s4 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(first, third)), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
-		LogicalSlot s5 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(first, third)), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
+		LogicalSlot s4 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
+		LogicalSlot s5 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
 		assertEquals(third.getResourceID(), s4.getTaskManagerLocation().getResourceID());
 		assertEquals(third.getResourceID(), s5.getTaskManagerLocation().getResourceID());
 
 		// first or third --> second, because all others are full
-		LogicalSlot s6 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(first, third)), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
+		LogicalSlot s6 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
 		assertEquals(second.getResourceID(), s6.getTaskManagerLocation().getResourceID());
 
 		// release something on the first and second instance
 		runInMainThreadExecutor(s2::releaseSlot);
 		runInMainThreadExecutor(s6::releaseSlot);
 
-		LogicalSlot s7 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution(first, third)), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
+		LogicalSlot s7 = testingSlotProvider.allocateSlot(new ScheduledUnit(getExecution()), slotProfileForLocation(first, third), TestingUtils.infiniteTime()).get();
 		assertEquals(first.getResourceID(), s7.getTaskManagerLocation().getResourceID());
 
 		assertEquals(1, testingSlotProvider.getNumberOfUnconstrainedAssignments());
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/legacy/backpressure/BackPressureRequestCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/legacy/backpressure/BackPressureRequestCoordinatorTest.java
index 00bac1dc780..ad1f039bb42 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/legacy/backpressure/BackPressureRequestCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rest/handler/legacy/backpressure/BackPressureRequestCoordinatorTest.java
@@ -19,15 +19,19 @@
 package org.apache.flink.runtime.rest.handler.legacy.backpressure;
 
 import org.apache.flink.api.common.time.Time;
-import org.apache.flink.configuration.JobManagerOptions;
 import org.apache.flink.runtime.execution.ExecutionState;
-import org.apache.flink.runtime.executiongraph.Execution;
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
+import org.apache.flink.runtime.executiongraph.ExecutionGraphTestUtils;
 import org.apache.flink.runtime.executiongraph.ExecutionJobVertex;
-import org.apache.flink.runtime.executiongraph.ExecutionJobVertexTest;
 import org.apache.flink.runtime.executiongraph.ExecutionVertex;
-import org.apache.flink.runtime.executiongraph.IntermediateResult;
+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;
+import org.apache.flink.runtime.jobgraph.JobVertexID;
+import org.apache.flink.runtime.jobgraph.ScheduleMode;
+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;
+import org.apache.flink.runtime.jobmaster.LogicalSlot;
+import org.apache.flink.runtime.jobmaster.TestingLogicalSlotBuilder;
 import org.apache.flink.runtime.messages.TaskBackPressureResponse;
+import org.apache.flink.runtime.testutils.DirectScheduledExecutorService;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.TestLogger;
 
@@ -44,13 +48,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
-import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -61,7 +63,7 @@ import static org.junit.Assert.fail;
  */
 public class BackPressureRequestCoordinatorTest extends TestLogger {
 
-	private static final long requestTimeout = 10000;
+	private static final long requestTimeout = 100;
 	private static final double backPressureRatio = 0.5;
 	private static final String requestTimeoutMessage = "Request timeout.";
 
@@ -154,9 +156,7 @@ public class BackPressureRequestCoordinatorTest extends TestLogger {
 	 */
 	@Test
 	public void testBackPressureRequestTimeout() throws Exception {
-		long requestTimeout = 100;
-		ExecutionVertex[] vertices = createExecutionVertices(ExecutionState.RUNNING, CompletionType.TIMEOUT, requestTimeout);
-		BackPressureRequestCoordinator coordinator = new BackPressureRequestCoordinator(executorService, requestTimeout);
+		ExecutionVertex[] vertices = createExecutionVertices(ExecutionState.RUNNING, CompletionType.TIMEOUT);
 
 		try {
 			CompletableFuture<BackPressureStats> requestFuture = coordinator.triggerBackPressureRequest(vertices);
@@ -202,142 +202,86 @@ public class BackPressureRequestCoordinatorTest extends TestLogger {
 	private ExecutionVertex[] createExecutionVertices(
 			ExecutionState state,
 			CompletionType completionType) throws Exception {
-		return createExecutionVertices(state, completionType, requestTimeout);
-	}
 
-	private ExecutionVertex[] createExecutionVertices(
-			ExecutionState state,
-			CompletionType completionType,
-			long requestTimeout) throws Exception {
-		return new ExecutionVertex[] {
-			createExecutionVertex(0, ExecutionState.RUNNING, CompletionType.SUCCESSFULLY, requestTimeout),
-			createExecutionVertex(1, state, completionType, requestTimeout),
-			createExecutionVertex(2, ExecutionState.RUNNING, CompletionType.SUCCESSFULLY, requestTimeout)
-		};
-	}
+		final ExecutionJobVertex ejv = ExecutionGraphTestUtils.getExecutionJobVertex(
+			new JobVertexID(),
+			3,
+			null,
+			new DirectScheduledExecutorService(),
+			ScheduleMode.LAZY_FROM_SOURCES);
 
-	private ExecutionVertex createExecutionVertex(
-			int subTaskIndex,
-			ExecutionState state,
-			CompletionType completionType,
-			long requestTimeout) throws Exception {
-		return new TestingExecutionVertex(
-			ExecutionJobVertexTest.createExecutionJobVertex(4, 4),
-			subTaskIndex,
-			Time.seconds(10),
-			1L,
-			System.currentTimeMillis(),
-			state,
-			completionType,
-			requestTimeout);
+		final ExecutionVertex[] vertices = ejv.getTaskVertices();
+
+		assignSlot(vertices[0], CompletionType.SUCCESSFULLY);
+		vertices[0].getCurrentExecutionAttempt().transitionState(ExecutionState.RUNNING);
+
+		assignSlot(vertices[1], completionType);
+		vertices[1].getCurrentExecutionAttempt().transitionState(state);
+
+		assignSlot(vertices[2], CompletionType.SUCCESSFULLY);
+		vertices[2].getCurrentExecutionAttempt().transitionState(ExecutionState.RUNNING);
+
+		return vertices;
 	}
 
-	/**
-	 * Completion types of the request future.
-	 */
-	private enum CompletionType {
-		SUCCESSFULLY,
-		EXCEPTIONALLY,
-		TIMEOUT,
-		NEVER_COMPLETE
+	private static void assignSlot(ExecutionVertex executionVertex, CompletionType completionType) {
+		final LogicalSlot slot = new TestingLogicalSlotBuilder()
+			.setTaskManagerGateway(
+				createTaskManagerGateway(executionVertex.getCurrentExecutionAttempt().getAttemptId(), completionType))
+			.createTestingLogicalSlot();
+		ExecutionGraphTestUtils.setVertexResource(executionVertex, slot);
 	}
 
-	/**
-	 * A testing {@link ExecutionVertex} implementation used to wrap {@link TestingExecution}.
-	 */
-	private static class TestingExecutionVertex extends ExecutionVertex {
-
-		private final Execution execution;
-
-		TestingExecutionVertex(
-				ExecutionJobVertex jobVertex,
-				int subTaskIndex,
-				Time timeout,
-				long initialGlobalModVersion,
-				long createTimestamp,
-				ExecutionState state,
-				CompletionType completionType,
-				long requestTimeout) {
-
-			super(
-				jobVertex,
-				subTaskIndex,
-				new IntermediateResult[0],
-				timeout,
-				initialGlobalModVersion,
-				createTimestamp,
-				JobManagerOptions.MAX_ATTEMPTS_HISTORY_SIZE.defaultValue());
-			execution = new TestingExecution(
-				Runnable::run,
-				this,
-				0,
-				initialGlobalModVersion,
-				createTimestamp,
-				timeout,
-				state,
-				completionType,
-				requestTimeout);
+	private static TaskManagerGateway createTaskManagerGateway(
+			ExecutionAttemptID executionAttemptId,
+			CompletionType completionType) {
+		final CompletableFuture<TaskBackPressureResponse> responseFuture = new CompletableFuture<>();
+		switch (completionType) {
+			case SUCCESSFULLY:
+				responseFuture.complete(new TaskBackPressureResponse(0, executionAttemptId, backPressureRatio));
+				break;
+			case EXCEPTIONALLY:
+				responseFuture.completeExceptionally(new RuntimeException("Request failed."));
+				break;
+			case TIMEOUT:
+				executorService.schedule(
+					() -> responseFuture.completeExceptionally(new TimeoutException(requestTimeoutMessage)),
+					requestTimeout,
+					TimeUnit.MILLISECONDS);
+				break;
+			case NEVER_COMPLETE:
+				// do nothing
+				break;
+			default:
+				throw new RuntimeException("Unknown completion type.");
 		}
 
-		@Override
-		public Execution getCurrentExecutionAttempt() {
-			return execution;
-		}
+		return new MockBackPressureRequestTaskManagerGateway(responseFuture);
 	}
 
-	/**
-	 * A testing implementation of {@link Execution} which acts differently according to
-	 * the given {@link ExecutionState} and {@link CompletionType}.
-	 */
-	private static class TestingExecution extends Execution {
-
-		private final ExecutionState state;
-		private final CompletionType completionType;
-		private final long requestTimeout;
-
-		TestingExecution(
-				Executor executor,
-				ExecutionVertex vertex,
-				int attemptNumber,
-				long globalModVersion,
-				long startTimestamp,
-				Time rpcTimeout,
-				ExecutionState state,
-				CompletionType completionType,
-				long requestTimeout) {
-			super(executor, vertex, attemptNumber, globalModVersion, startTimestamp, rpcTimeout);
-			this.state = checkNotNull(state);
-			this.completionType = checkNotNull(completionType);
-			this.requestTimeout = requestTimeout;
+	private static class MockBackPressureRequestTaskManagerGateway extends SimpleAckingTaskManagerGateway {
+		private final CompletableFuture<TaskBackPressureResponse> responseFuture;
+
+		private MockBackPressureRequestTaskManagerGateway(CompletableFuture<TaskBackPressureResponse> responseFuture) {
+			this.responseFuture = responseFuture;
 		}
 
 		@Override
-		public CompletableFuture<TaskBackPressureResponse> requestBackPressure(int requestId, Time timeout) {
-			CompletableFuture<TaskBackPressureResponse> responseFuture = new CompletableFuture<>();
-			switch (completionType) {
-				case SUCCESSFULLY:
-					responseFuture.complete(new TaskBackPressureResponse(0, getAttemptId(), backPressureRatio));
-					break;
-				case EXCEPTIONALLY:
-					responseFuture.completeExceptionally(new RuntimeException("Request failed."));
-					break;
-				case TIMEOUT:
-					executorService.schedule(
-						() -> responseFuture.completeExceptionally(new TimeoutException(requestTimeoutMessage)),
-						requestTimeout,
-						TimeUnit.MILLISECONDS);
-					break;
-				case NEVER_COMPLETE:
-					break; // do nothing
-				default:
-					throw new RuntimeException("Unknown completion type.");
-			}
+		public CompletableFuture<TaskBackPressureResponse> requestTaskBackPressure(
+				ExecutionAttemptID executionAttemptId,
+				int requestId,
+				Time timeout) {
 			return responseFuture;
 		}
+	}
 
-		@Override
-		public ExecutionState getState() {
-			return state;
-		}
+	/**
+	 * Completion types of the request future.
+	 */
+	private enum CompletionType {
+		SUCCESSFULLY,
+		EXCEPTIONALLY,
+		TIMEOUT,
+		NEVER_COMPLETE
 	}
 }
