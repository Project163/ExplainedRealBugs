diff --git a/flink-core/src/main/java/org/apache/flink/configuration/ExecutionOptions.java b/flink-core/src/main/java/org/apache/flink/configuration/ExecutionOptions.java
index 7a1225c806a..e543ce2afef 100644
--- a/flink-core/src/main/java/org/apache/flink/configuration/ExecutionOptions.java
+++ b/flink-core/src/main/java/org/apache/flink/configuration/ExecutionOptions.java
@@ -31,6 +31,11 @@ import static org.apache.flink.configuration.description.TextElement.text;
 /** {@link ConfigOption}s specific for a single execution of a user program. */
 @PublicEvolving
 public class ExecutionOptions {
+    /** A special marker value for disabling buffer timeout. */
+    public static final long DISABLED_NETWORK_BUFFER_TIMEOUT = -1L;
+
+    /** A special marker value for flushing network buffers after each record. */
+    public static final long FLUSH_AFTER_EVERY_RECORD = 0L;
 
     public static final ConfigOption<RuntimeExecutionMode> RUNTIME_MODE =
             ConfigOptions.key("execution.runtime-mode")
@@ -92,9 +97,11 @@ public class ExecutionOptions {
                                             text(
                                                     "A positive value triggers flushing periodically by that interval"),
                                             text(
-                                                    "0 triggers flushing after every record thus minimizing latency"),
+                                                    FLUSH_AFTER_EVERY_RECORD
+                                                            + " triggers flushing after every record thus minimizing latency"),
                                             text(
-                                                    "-1 ms triggers flushing only when the output buffer is full thus maximizing "
+                                                    DISABLED_NETWORK_BUFFER_TIMEOUT
+                                                            + " ms triggers flushing only when the output buffer is full thus maximizing "
                                                             + "throughput"))
                                     .build());
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java
index 808d2e323c4..4be9941abdd 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/RecordWriter.java
@@ -19,6 +19,7 @@
 package org.apache.flink.runtime.io.network.api.writer;
 
 import org.apache.flink.annotation.VisibleForTesting;
+import org.apache.flink.configuration.ExecutionOptions;
 import org.apache.flink.core.io.IOReadableWritable;
 import org.apache.flink.core.memory.DataOutputSerializer;
 import org.apache.flink.runtime.event.AbstractEvent;
@@ -83,9 +84,10 @@ public abstract class RecordWriter<T extends IOReadableWritable> implements Avai
 
         this.serializer = new DataOutputSerializer(128);
 
-        checkArgument(timeout >= -1);
-        this.flushAlways = (timeout == 0);
-        if (timeout == -1 || timeout == 0) {
+        checkArgument(timeout >= ExecutionOptions.DISABLED_NETWORK_BUFFER_TIMEOUT);
+        this.flushAlways = (timeout == ExecutionOptions.FLUSH_AFTER_EVERY_RECORD);
+        if (timeout == ExecutionOptions.DISABLED_NETWORK_BUFFER_TIMEOUT
+                || timeout == ExecutionOptions.FLUSH_AFTER_EVERY_RECORD) {
             outputFlusher = null;
         } else {
             String threadName =
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java
index 94309acaafc..beb863c8da8 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/environment/StreamExecutionEnvironment.java
@@ -95,7 +95,6 @@ import org.apache.flink.streaming.api.functions.source.StatefulSequenceSource;
 import org.apache.flink.streaming.api.functions.source.TimestampedFileInputSplit;
 import org.apache.flink.streaming.api.graph.StreamGraph;
 import org.apache.flink.streaming.api.graph.StreamGraphGenerator;
-import org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator;
 import org.apache.flink.streaming.api.operators.StreamSource;
 import org.apache.flink.util.DynamicCodeLoadingException;
 import org.apache.flink.util.ExceptionUtils;
@@ -176,7 +175,7 @@ public class StreamExecutionEnvironment {
 
     protected final List<Transformation<?>> transformations = new ArrayList<>();
 
-    private long bufferTimeout = StreamingJobGraphGenerator.UNDEFINED_NETWORK_BUFFER_TIMEOUT;
+    private long bufferTimeout = ExecutionOptions.BUFFER_TIMEOUT.defaultValue().toMillis();
 
     protected boolean isChainingEnabled = true;
 
@@ -418,7 +417,7 @@ public class StreamExecutionEnvironment {
      * @param timeoutMillis The maximum time between two output flushes.
      */
     public StreamExecutionEnvironment setBufferTimeout(long timeoutMillis) {
-        if (timeoutMillis < -1) {
+        if (timeoutMillis < ExecutionOptions.DISABLED_NETWORK_BUFFER_TIMEOUT) {
             throw new IllegalArgumentException("Timeout of buffer must be non-negative or -1");
         }
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java
index 569eb90b2f3..e527170452e 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamGraphGenerator.java
@@ -171,7 +171,7 @@ public class StreamGraphGenerator {
 
     private SavepointRestoreSettings savepointRestoreSettings;
 
-    private long defaultBufferTimeout = StreamingJobGraphGenerator.UNDEFINED_NETWORK_BUFFER_TIMEOUT;
+    private long defaultBufferTimeout = ExecutionOptions.BUFFER_TIMEOUT.defaultValue().toMillis();
 
     private boolean shouldExecuteInBatchMode;
 
diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java
index 75a2c27fc3e..9ff2d028131 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java
@@ -26,6 +26,7 @@ import org.apache.flink.api.common.operators.ResourceSpec;
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.api.java.tuple.Tuple2;
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.ExecutionOptions;
 import org.apache.flink.configuration.IllegalConfigurationException;
 import org.apache.flink.core.memory.ManagedMemoryUseCase;
 import org.apache.flink.runtime.OperatorIDPair;
@@ -105,10 +106,6 @@ public class StreamingJobGraphGenerator {
 
     private static final Logger LOG = LoggerFactory.getLogger(StreamingJobGraphGenerator.class);
 
-    private static final long DEFAULT_NETWORK_BUFFER_TIMEOUT = 100L;
-
-    public static final long UNDEFINED_NETWORK_BUFFER_TIMEOUT = -1L;
-
     // ------------------------------------------------------------------------
 
     public static JobGraph createJobGraph(StreamGraph streamGraph) {
@@ -803,7 +800,7 @@ public class StreamingJobGraphGenerator {
                         "Data exchange mode " + edge.getExchangeMode() + " is not supported yet.");
         }
 
-        checkAndResetBufferTimeout(resultPartitionType, edge);
+        checkBufferTimeout(resultPartitionType, edge);
 
         JobEdge jobEdge;
         if (partitioner.isPointwise()) {
@@ -829,19 +826,16 @@ public class StreamingJobGraphGenerator {
         }
     }
 
-    private void checkAndResetBufferTimeout(ResultPartitionType type, StreamEdge edge) {
+    private void checkBufferTimeout(ResultPartitionType type, StreamEdge edge) {
         long bufferTimeout = edge.getBufferTimeout();
-        if (type.isBlocking() && bufferTimeout != UNDEFINED_NETWORK_BUFFER_TIMEOUT) {
+        if (type.isBlocking()
+                && bufferTimeout != ExecutionOptions.DISABLED_NETWORK_BUFFER_TIMEOUT) {
             throw new UnsupportedOperationException(
                     "Blocking partition does not support buffer timeout "
                             + bufferTimeout
                             + " for src operator in edge "
-                            + edge.toString()
-                            + ". \nPlease either reset buffer timeout as -1 or use the non-blocking partition.");
-        }
-
-        if (type.isPipelined() && bufferTimeout == UNDEFINED_NETWORK_BUFFER_TIMEOUT) {
-            edge.setBufferTimeout(DEFAULT_NETWORK_BUFFER_TIMEOUT);
+                            + edge
+                            + ". \nPlease either disable buffer timeout (via -1) or use the non-blocking partition.");
         }
     }
 
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java
index b1547846fd3..6b6f77abe61 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorTest.java
@@ -114,12 +114,12 @@ import java.util.stream.Collectors;
 import static org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator.areOperatorsChainable;
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -637,6 +637,7 @@ public class StreamingJobGraphGeneratorTest extends TestLogger {
     @Test
     public void testExchangeModeBatch() {
         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setBufferTimeout(-1);
         // fromElements -> Map -> Print
         DataStream<Integer> sourceDataStream = env.fromElements(1, 2, 3);
 
@@ -809,6 +810,24 @@ public class StreamingJobGraphGeneratorTest extends TestLogger {
         StreamingJobGraphGenerator.createJobGraph(env.getStreamGraph());
     }
 
+    @Test
+    public void testDisablingBufferTimeoutWithPipelinedExchanges() {
+        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setRuntimeMode(RuntimeExecutionMode.STREAMING);
+        env.setBufferTimeout(-1);
+
+        env.fromElements(1, 2, 3).map(value -> value).print();
+
+        final JobGraph jobGraph = StreamingJobGraphGenerator.createJobGraph(env.getStreamGraph());
+        for (JobVertex vertex : jobGraph.getVertices()) {
+            final StreamConfig streamConfig = new StreamConfig(vertex.getConfiguration());
+            for (StreamEdge streamEdge :
+                    streamConfig.getOutEdgesInOrder(this.getClass().getClassLoader())) {
+                assertThat(streamEdge.getBufferTimeout(), equalTo(-1L));
+            }
+        }
+    }
+
     /** Test iteration job, check slot sharing group and co-location group. */
     @Test
     public void testIteration() {
@@ -1385,6 +1404,7 @@ public class StreamingJobGraphGeneratorTest extends TestLogger {
      */
     private StreamGraph createStreamGraphForSlotSharingTest() {
         final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setBufferTimeout(-1);
 
         final DataStream<Integer> source1 = env.fromElements(1, 2, 3).name("source1");
         source1.rebalance().map(v -> v).name("map1");
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest.java
index 4042d8422e2..c28e775b34a 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest.java
@@ -52,8 +52,8 @@ public class StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest extends
 
     @Test
     public void testAllEdgesBlockingMode() {
-        final StreamGraph streamGraph = createStreamGraph();
-        streamGraph.setGlobalStreamExchangeMode(GlobalStreamExchangeMode.ALL_EDGES_BLOCKING);
+        final StreamGraph streamGraph =
+                createStreamGraph(GlobalStreamExchangeMode.ALL_EDGES_BLOCKING);
         final JobGraph jobGraph = StreamingJobGraphGenerator.createJobGraph(streamGraph);
 
         final List<JobVertex> verticesSorted = jobGraph.getVerticesSortedTopologicallyFromSources();
@@ -96,8 +96,8 @@ public class StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest extends
 
     @Test
     public void testForwardEdgesPipelinedMode() {
-        final StreamGraph streamGraph = createStreamGraph();
-        streamGraph.setGlobalStreamExchangeMode(GlobalStreamExchangeMode.FORWARD_EDGES_PIPELINED);
+        final StreamGraph streamGraph =
+                createStreamGraph(GlobalStreamExchangeMode.FORWARD_EDGES_PIPELINED);
         final JobGraph jobGraph = StreamingJobGraphGenerator.createJobGraph(streamGraph);
 
         final List<JobVertex> verticesSorted = jobGraph.getVerticesSortedTopologicallyFromSources();
@@ -118,8 +118,8 @@ public class StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest extends
 
     @Test
     public void testPointwiseEdgesPipelinedMode() {
-        final StreamGraph streamGraph = createStreamGraph();
-        streamGraph.setGlobalStreamExchangeMode(GlobalStreamExchangeMode.POINTWISE_EDGES_PIPELINED);
+        final StreamGraph streamGraph =
+                createStreamGraph(GlobalStreamExchangeMode.POINTWISE_EDGES_PIPELINED);
         final JobGraph jobGraph = StreamingJobGraphGenerator.createJobGraph(streamGraph);
 
         final List<JobVertex> verticesSorted = jobGraph.getVerticesSortedTopologicallyFromSources();
@@ -168,7 +168,19 @@ public class StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest extends
      * map2(parallelism=2) --(rebalance)--> sink(parallelism=2).
      */
     private static StreamGraph createStreamGraph() {
+        return createStreamGraph(GlobalStreamExchangeMode.ALL_EDGES_PIPELINED);
+    }
+
+    /**
+     * Topology: source(parallelism=1) --(forward)--> map1(parallelism=1) --(rescale)-->
+     * map2(parallelism=2) --(rebalance)--> sink(parallelism=2).
+     */
+    private static StreamGraph createStreamGraph(
+            GlobalStreamExchangeMode globalStreamExchangeMode) {
         final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        if (globalStreamExchangeMode != GlobalStreamExchangeMode.ALL_EDGES_PIPELINED) {
+            env.setBufferTimeout(-1);
+        }
 
         final DataStream<Integer> source = env.fromElements(1, 2, 3).setParallelism(1);
 
@@ -192,6 +204,8 @@ public class StreamingJobGraphGeneratorWithGlobalStreamExchangeModeTest extends
 
         map2.rebalance().print().setParallelism(2);
 
-        return env.getStreamGraph();
+        final StreamGraph streamGraph = env.getStreamGraph();
+        streamGraph.setGlobalStreamExchangeMode(globalStreamExchangeMode);
+        return streamGraph;
     }
 }
diff --git a/flink-tests/src/test/java/org/apache/flink/test/runtime/BlockingShuffleITCase.java b/flink-tests/src/test/java/org/apache/flink/test/runtime/BlockingShuffleITCase.java
index 0b38c5b2f13..4c50bc771e8 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/runtime/BlockingShuffleITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/runtime/BlockingShuffleITCase.java
@@ -84,6 +84,7 @@ public class BlockingShuffleITCase {
 
     private JobGraph createJobGraph(int numRecordsToSend) {
         StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setBufferTimeout(-1);
         env.setParallelism(numTaskManagers * numSlotsPerTaskManager);
         DataStream<String> source = env.addSource(new StringSource(numRecordsToSend));
         source.rebalance()
diff --git a/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java
new file mode 100644
index 00000000000..8597820b0fb
--- /dev/null
+++ b/flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BufferTimeoutITCase.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.test.streaming.runtime;
+
+import org.apache.flink.configuration.ExecutionOptions;
+import org.apache.flink.core.execution.JobClient;
+import org.apache.flink.runtime.testutils.CommonTestUtils;
+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
+import org.apache.flink.streaming.api.functions.sink.SinkFunction;
+import org.apache.flink.streaming.api.functions.source.SourceFunction;
+import org.apache.flink.test.util.AbstractTestBase;
+import org.apache.flink.testutils.junit.SharedObjects;
+import org.apache.flink.testutils.junit.SharedReference;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import java.util.ArrayList;
+
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.hamcrest.MatcherAssert.assertThat;
+
+/** Tests for {@link StreamExecutionEnvironment#setBufferTimeout(long)}. */
+public class BufferTimeoutITCase extends AbstractTestBase {
+
+    @Rule public final SharedObjects sharedObjects = SharedObjects.create();
+
+    /**
+     * The test verifies that it is possible to disable buffer flushing. It emits a single record,
+     * which should not fill an entire buffer, thus it should not never reach the sink. We check the
+     * sink has not seen any records after 2 times the default buffer timeout.
+     */
+    @Test
+    public void testDisablingBufferTimeout() throws Exception {
+        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.setParallelism(1);
+        env.setBufferTimeout(-1);
+        final SharedReference<ArrayList<Integer>> results = sharedObjects.add(new ArrayList<>());
+
+        env.addSource(
+                        new SourceFunction<Integer>() {
+
+                            @Override
+                            public void run(SourceContext<Integer> ctx) throws Exception {
+                                ctx.collect(1);
+                                // just sleep forever
+                                Thread.sleep(Long.MAX_VALUE);
+                            }
+
+                            @Override
+                            public void cancel() {}
+                        })
+                .slotSharingGroup("source")
+                .addSink(
+                        new SinkFunction<Integer>() {
+
+                            @Override
+                            public void invoke(Integer value, Context context) throws Exception {
+                                results.get().add(value);
+                            }
+                        })
+                .slotSharingGroup("sink");
+
+        final JobClient jobClient = env.executeAsync();
+        CommonTestUtils.waitForAllTaskRunning(
+                miniClusterResource.getMiniCluster(), jobClient.getJobID(), false);
+
+        Thread.sleep(2 * ExecutionOptions.BUFFER_TIMEOUT.defaultValue().toMillis());
+        assertThat(results.get().size(), equalTo(0));
+    }
+}
