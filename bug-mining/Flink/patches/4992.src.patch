diff --git a/docs/_includes/generated/resource_manager_configuration.html b/docs/_includes/generated/resource_manager_configuration.html
index 7cfcec69e1b..690c4e91fc5 100644
--- a/docs/_includes/generated/resource_manager_configuration.html
+++ b/docs/_includes/generated/resource_manager_configuration.html
@@ -26,6 +26,18 @@
             <td>Long</td>
             <td>Time in milliseconds of the start-up period of a standalone cluster. During this time, resource manager of the standalone cluster expects new task executors to be registered, and will not fail slot requests that can not be satisfied by any current registered slots. After this time, it will fail pending and new coming requests immediately that can not be satisfied by registered slots. If not set, 'slotmanager.request-timeout' will be used by default.</td>
         </tr>
+        <tr>
+            <td><h5>resourcemanager.start-worker.max-failure-rate</h5></td>
+            <td style="word-wrap: break-word;">10.0</td>
+            <td>Double</td>
+            <td>The maximum number of start worker failures (Native Kubernetes / Yarn / Mesos) per minute before pausing requesting new workers. Once the threshold is reached, subsequent worker requests will be postponed to after a configured retry interval ('resourcemanager.start-worker.retry-interval').</td>
+        </tr>
+        <tr>
+            <td><h5>resourcemanager.start-worker.retry-interval</h5></td>
+            <td style="word-wrap: break-word;">3 s</td>
+            <td>Duration</td>
+            <td>The time to wait before requesting new workers (Native Kubernetes / Yarn / Mesos) once the max failure rate of starting workers ('resourcemanager.start-worker.max-failure-rate') is reached.</td>
+        </tr>
         <tr>
             <td><h5>resourcemanager.taskmanager-timeout</h5></td>
             <td style="word-wrap: break-word;">30000</td>
diff --git a/flink-core/src/main/java/org/apache/flink/configuration/ResourceManagerOptions.java b/flink-core/src/main/java/org/apache/flink/configuration/ResourceManagerOptions.java
index 4a0f6f70628..15ac495568d 100644
--- a/flink-core/src/main/java/org/apache/flink/configuration/ResourceManagerOptions.java
+++ b/flink-core/src/main/java/org/apache/flink/configuration/ResourceManagerOptions.java
@@ -22,10 +22,15 @@ import org.apache.flink.annotation.PublicEvolving;
 import org.apache.flink.annotation.docs.Documentation;
 import org.apache.flink.configuration.description.Description;
 
+import java.time.Duration;
+
 /** The set of configuration options relating to the ResourceManager. */
 @PublicEvolving
 public class ResourceManagerOptions {
 
+    private static final String START_WORKER_RETRY_INTERVAL_KEY =
+            "resourcemanager.start-worker.retry-interval";
+
     /** Timeout for jobs which don't have a job manager as leader assigned. */
     public static final ConfigOption<String> JOB_TIMEOUT =
             ConfigOptions.key("resourcemanager.job.timeout")
@@ -79,6 +84,37 @@ public class ResourceManagerOptions {
                                     + "started by Flink, in order to speed up job recovery in case of failures due to task manager lost. "
                                     + "Note that this feature is available only to the active deployments (native K8s, Yarn and Mesos).");
 
+    /**
+     * The maximum number of start worker failures (Native Kubernetes / Yarn / Mesos) per minute
+     * before pausing requesting new workers. Once the threshold is reached, subsequent worker
+     * requests will be postponed to after a configured retry interval ({@link
+     * #START_WORKER_RETRY_INTERVAL}).
+     */
+    public static final ConfigOption<Double> START_WORKER_MAX_FAILURE_RATE =
+            ConfigOptions.key("resourcemanager.start-worker.max-failure-rate")
+                    .doubleType()
+                    .defaultValue(10.0)
+                    .withDescription(
+                            "The maximum number of start worker failures (Native Kubernetes / Yarn / Mesos) per minute "
+                                    + "before pausing requesting new workers. Once the threshold is reached, subsequent "
+                                    + "worker requests will be postponed to after a configured retry interval ('"
+                                    + START_WORKER_RETRY_INTERVAL_KEY
+                                    + "').");
+
+    /**
+     * The time to wait before requesting new workers (Native Kubernetes / Yarn / Mesos) once the
+     * max failure rate of starting workers ({@link #START_WORKER_MAX_FAILURE_RATE}) is reached.
+     */
+    public static final ConfigOption<Duration> START_WORKER_RETRY_INTERVAL =
+            ConfigOptions.key(START_WORKER_RETRY_INTERVAL_KEY)
+                    .durationType()
+                    .defaultValue(Duration.ofSeconds(3))
+                    .withDescription(
+                            "The time to wait before requesting new workers (Native Kubernetes / Yarn / Mesos) once the "
+                                    + "max failure rate of starting workers ('"
+                                    + START_WORKER_MAX_FAILURE_RATE.key()
+                                    + "') is reached.");
+
     /**
      * The timeout for a slot request to be discarded, in milliseconds.
      *
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java
index 939890f3916..bbf5d042d78 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriver.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.kubernetes;
 
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.configuration.GlobalConfiguration;
 import org.apache.flink.configuration.TaskManagerOptions;
@@ -63,8 +62,6 @@ public class KubernetesResourceManagerDriver
 
     private final String clusterId;
 
-    private final Time podCreationRetryInterval;
-
     private final KubeClientFactory kubeClientFactory;
 
     private Optional<FlinkKubeClient> kubeClientOpt;
@@ -93,8 +90,6 @@ public class KubernetesResourceManagerDriver
             KubernetesResourceManagerDriverConfiguration configuration) {
         super(flinkConfig, GlobalConfiguration.loadConfiguration());
         this.clusterId = Preconditions.checkNotNull(configuration.getClusterId());
-        this.podCreationRetryInterval =
-                Preconditions.checkNotNull(configuration.getPodCreationRetryInterval());
         this.kubeClientFactory = Preconditions.checkNotNull(kubeClientFactory);
         this.requestResourceFutures = new HashMap<>();
         this.podCreationCoolDown = FutureUtils.completedVoidFuture();
@@ -170,15 +165,8 @@ public class KubernetesResourceManagerDriver
                 parameters.getTaskManagerMemoryMB(),
                 parameters.getTaskManagerCPU());
 
-        // When K8s API Server is temporary unavailable, `kubeClient.createTaskManagerPod` might
-        // fail immediately.
-        // In case of pod creation failures, we should wait for an interval before trying to create
-        // new pods.
-        // Otherwise, ActiveResourceManager will always re-requesting the worker, which keeps the
-        // main thread busy.
         final CompletableFuture<Void> createPodFuture =
-                podCreationCoolDown.thenCompose(
-                        (ignore) -> getKubeClient().createTaskManagerPod(taskManagerPod));
+                getKubeClient().createTaskManagerPod(taskManagerPod);
 
         FutureUtils.assertNoException(
                 createPodFuture.handleAsync(
@@ -188,7 +176,6 @@ public class KubernetesResourceManagerDriver
                                         "Could not create pod {}, exception: {}",
                                         podName,
                                         exception);
-                                tryResetPodCreationCoolDown();
                                 CompletableFuture<KubernetesWorkerNode> future =
                                         requestResourceFutures.remove(taskManagerPod.getName());
                                 if (future != null) {
@@ -272,20 +259,6 @@ public class KubernetesResourceManagerDriver
                         KubernetesConfigOptions.EXTERNAL_RESOURCE_KUBERNETES_CONFIG_KEY_SUFFIX));
     }
 
-    private void tryResetPodCreationCoolDown() {
-        if (podCreationCoolDown.isDone()) {
-            log.info(
-                    "Pod creation failed. Will not retry creating pods in {}.",
-                    podCreationRetryInterval);
-            podCreationCoolDown = new CompletableFuture<>();
-            getMainThreadExecutor()
-                    .schedule(
-                            () -> podCreationCoolDown.complete(null),
-                            podCreationRetryInterval.getSize(),
-                            podCreationRetryInterval.getUnit());
-        }
-    }
-
     private void terminatedPodsInMainThread(List<KubernetesPod> pods) {
         getMainThreadExecutor()
                 .execute(
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/configuration/KubernetesResourceManagerDriverConfiguration.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/configuration/KubernetesResourceManagerDriverConfiguration.java
index 0c3a0d015f9..99be1238fd2 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/configuration/KubernetesResourceManagerDriverConfiguration.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/configuration/KubernetesResourceManagerDriverConfiguration.java
@@ -18,26 +18,18 @@
 
 package org.apache.flink.kubernetes.configuration;
 
-import org.apache.flink.api.common.time.Time;
-
 /**
  * Configuration specific to {@link org.apache.flink.kubernetes.KubernetesResourceManagerDriver}.
  */
 public class KubernetesResourceManagerDriverConfiguration {
+
     private final String clusterId;
-    private final Time podCreationRetryInterval;
 
-    public KubernetesResourceManagerDriverConfiguration(
-            String clusterId, Time podCreationRetryInterval) {
+    public KubernetesResourceManagerDriverConfiguration(String clusterId) {
         this.clusterId = clusterId;
-        this.podCreationRetryInterval = podCreationRetryInterval;
     }
 
     public String getClusterId() {
         return clusterId;
     }
-
-    public Time getPodCreationRetryInterval() {
-        return podCreationRetryInterval;
-    }
 }
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/entrypoint/KubernetesResourceManagerFactory.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/entrypoint/KubernetesResourceManagerFactory.java
index 6dc22d7b3c2..e2ba4e0b3c3 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/entrypoint/KubernetesResourceManagerFactory.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/entrypoint/KubernetesResourceManagerFactory.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.kubernetes.entrypoint;
 
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.kubernetes.KubernetesResourceManagerDriver;
 import org.apache.flink.kubernetes.KubernetesWorkerNode;
@@ -43,8 +42,6 @@ public class KubernetesResourceManagerFactory
     private static final KubernetesResourceManagerFactory INSTANCE =
             new KubernetesResourceManagerFactory();
 
-    private static final Time POD_CREATION_RETRY_INTERVAL = Time.seconds(3L);
-
     private KubernetesResourceManagerFactory() {}
 
     public static KubernetesResourceManagerFactory getInstance() {
@@ -57,8 +54,7 @@ public class KubernetesResourceManagerFactory
         final KubernetesResourceManagerDriverConfiguration
                 kubernetesResourceManagerDriverConfiguration =
                         new KubernetesResourceManagerDriverConfiguration(
-                                configuration.getString(KubernetesConfigOptions.CLUSTER_ID),
-                                POD_CREATION_RETRY_INTERVAL);
+                                configuration.getString(KubernetesConfigOptions.CLUSTER_ID));
 
         return new KubernetesResourceManagerDriver(
                 configuration,
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriverTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriverTest.java
index 330ae555b01..6d9b869f8dd 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriverTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/KubernetesResourceManagerDriverTest.java
@@ -18,7 +18,6 @@
 
 package org.apache.flink.kubernetes;
 
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.TaskManagerOptions;
 import org.apache.flink.kubernetes.configuration.KubernetesConfigOptions;
 import org.apache.flink.kubernetes.configuration.KubernetesResourceManagerDriverConfiguration;
@@ -38,17 +37,14 @@ import org.apache.flink.runtime.resourcemanager.active.ResourceManagerDriverTest
 import io.fabric8.kubernetes.api.model.ResourceRequirements;
 import org.junit.Test;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Consumer;
 
 import static org.hamcrest.Matchers.empty;
-import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertThat;
@@ -59,11 +55,9 @@ public class KubernetesResourceManagerDriverTest
         extends ResourceManagerDriverTestBase<KubernetesWorkerNode> {
 
     private static final String CLUSTER_ID = "testing-flink-cluster";
-    private static final Time POD_CREATION_INTERVAL = Time.milliseconds(50L);
     private static final KubernetesResourceManagerDriverConfiguration
             KUBERNETES_RESOURCE_MANAGER_CONFIGURATION =
-                    new KubernetesResourceManagerDriverConfiguration(
-                            CLUSTER_ID, POD_CREATION_INTERVAL);
+                    new KubernetesResourceManagerDriverConfiguration(CLUSTER_ID);
 
     @Test
     public void testOnPodAdded() throws Exception {
@@ -158,51 +152,6 @@ public class KubernetesResourceManagerDriverTest
         };
     }
 
-    @Test
-    public void testPodCreationInterval() throws Exception {
-        new Context() {
-            {
-                final AtomicInteger createPodCount = new AtomicInteger(0);
-                final List<CompletableFuture<Long>> createPodTimeFutures = new ArrayList<>();
-                createPodTimeFutures.add(new CompletableFuture<>());
-                createPodTimeFutures.add(new CompletableFuture<>());
-
-                flinkKubeClientBuilder.setCreateTaskManagerPodFunction(
-                        (ignore) -> {
-                            int idx = createPodCount.getAndIncrement();
-                            if (idx < createPodTimeFutures.size()) {
-                                createPodTimeFutures.get(idx).complete(System.currentTimeMillis());
-                            }
-                            return FutureUtils.completedExceptionally(
-                                    new Throwable("testing error"));
-                        });
-
-                runTest(
-                        () -> {
-                            // re-request resource on pod creation failed
-                            runInMainThread(
-                                    () ->
-                                            getDriver()
-                                                    .requestResource(TASK_EXECUTOR_PROCESS_SPEC)
-                                                    .whenComplete(
-                                                            (ignore1, ignore2) ->
-                                                                    getDriver()
-                                                                            .requestResource(
-                                                                                    TASK_EXECUTOR_PROCESS_SPEC)));
-
-                            // validate trying creating pod twice, with proper interval
-                            long t1 =
-                                    createPodTimeFutures.get(0).get(TIMEOUT_SEC, TimeUnit.SECONDS);
-                            long t2 =
-                                    createPodTimeFutures.get(1).get(TIMEOUT_SEC, TimeUnit.SECONDS);
-                            assertThat(
-                                    (t2 - t1),
-                                    greaterThanOrEqualTo(POD_CREATION_INTERVAL.toMilliseconds()));
-                        });
-            }
-        };
-    }
-
     @Test
     public void testRecoverPreviousAttemptWorkersPodTerminated() throws Exception {
         new Context() {
diff --git a/flink-metrics/flink-metrics-core/src/main/java/org/apache/flink/metrics/ThresholdMeter.java b/flink-metrics/flink-metrics-core/src/main/java/org/apache/flink/metrics/ThresholdMeter.java
new file mode 100644
index 00000000000..bd6e5421b68
--- /dev/null
+++ b/flink-metrics/flink-metrics-core/src/main/java/org/apache/flink/metrics/ThresholdMeter.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.metrics;
+
+import java.time.Duration;
+import java.util.ArrayDeque;
+import java.util.Queue;
+
+/** A timestamp queue based threshold meter. */
+public class ThresholdMeter implements Meter {
+    private static final double MILLISECONDS_PER_SECOND = 1000.0;
+    private final double maxEventsPerInterval;
+    private final Duration interval;
+    private final Queue<Long> eventTimestamps;
+    private long eventCount = 0;
+
+    public ThresholdMeter(double maxEventsPerInterval, Duration interval) {
+        this.maxEventsPerInterval = maxEventsPerInterval;
+        this.interval = interval;
+        this.eventTimestamps = new ArrayDeque<>();
+        if (interval.isNegative() || interval.isZero()) {
+            throw new IllegalArgumentException("The threshold interval should be larger than 0.");
+        }
+    }
+
+    @Override
+    public void markEvent() {
+        eventTimestamps.add(System.currentTimeMillis());
+        eventCount++;
+    }
+
+    @Override
+    public void markEvent(long n) {
+        long timestamp = System.currentTimeMillis();
+        for (int i = 0; i < n; i++) {
+            eventTimestamps.add(timestamp);
+        }
+        eventCount = eventCount + n;
+    }
+
+    @Override
+    public double getRate() {
+        return getEventCountsRecentInterval() / (interval.toMillis() / MILLISECONDS_PER_SECOND);
+    }
+
+    @Override
+    public long getCount() {
+        return eventCount;
+    }
+
+    public void checkAgainstThreshold() throws ThresholdExceedException {
+        if (getEventCountsRecentInterval() >= maxEventsPerInterval) {
+            throw new ThresholdExceedException(
+                    String.format(
+                            "%d events detected in the recent interval, reaching the threshold %f.",
+                            getEventCountsRecentInterval(), maxEventsPerInterval));
+        }
+    }
+
+    private int getEventCountsRecentInterval() {
+        Long currentTimeStamp = System.currentTimeMillis();
+        while (!eventTimestamps.isEmpty()
+                && currentTimeStamp - eventTimestamps.peek() > interval.toMillis()) {
+            eventTimestamps.remove();
+        }
+
+        return eventTimestamps.size();
+    }
+
+    /** Exception thrown when a threshold exceeds. */
+    public static class ThresholdExceedException extends RuntimeException {
+        private static final long serialVersionUID = 1L;
+
+        public ThresholdExceedException(String message) {
+            super(message);
+        }
+    }
+}
diff --git a/flink-metrics/flink-metrics-core/src/test/java/org/apache/flink/metrics/ThresholdMeterTest.java b/flink-metrics/flink-metrics-core/src/test/java/org/apache/flink/metrics/ThresholdMeterTest.java
new file mode 100644
index 00000000000..3562a70173e
--- /dev/null
+++ b/flink-metrics/flink-metrics-core/src/test/java/org/apache/flink/metrics/ThresholdMeterTest.java
@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.metrics;
+
+import org.apache.flink.metrics.ThresholdMeter.ThresholdExceedException;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.Test;
+
+import java.time.Duration;
+
+import static org.hamcrest.Matchers.closeTo;
+import static org.hamcrest.Matchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+
+/** Tests for {@link ThresholdMeter}. */
+public class ThresholdMeterTest extends TestLogger {
+    private static final double THRESHOLD_LARGE = 1000.0;
+    private static final double THRESHOLD_SMALL = 5.0;
+    private static final Duration INTERVAL = Duration.ofMillis(50);
+    private static final double ERROR = 1e-6;
+
+    @Test
+    public void testMarkEvent() {
+        final ThresholdMeter thresholdMeter = createLargeThresholdMeter();
+
+        thresholdMeter.markEvent();
+        assertThat(thresholdMeter.getCount(), is(1L));
+        assertThat(thresholdMeter.getRate(), closeTo(toPerSecondRate(1), ERROR));
+
+        thresholdMeter.markEvent();
+        assertThat(thresholdMeter.getCount(), is(2L));
+        assertThat(thresholdMeter.getRate(), closeTo(toPerSecondRate(2), ERROR));
+    }
+
+    @Test
+    public void testMarkMultipleEvents() {
+        final ThresholdMeter thresholdMeter = createLargeThresholdMeter();
+        thresholdMeter.markEvent(2);
+        assertThat(thresholdMeter.getCount(), is(2L));
+        assertThat(thresholdMeter.getRate(), closeTo(toPerSecondRate(2), ERROR));
+    }
+
+    @Test
+    public void testCheckAgainstThresholdNotExceeded() {
+        final ThresholdMeter thresholdMeter = createSmallThresholdMeter();
+        for (int i = 0; i < THRESHOLD_SMALL - 1; ++i) {
+            thresholdMeter.markEvent();
+            thresholdMeter.checkAgainstThreshold();
+        }
+    }
+
+    @Test
+    public void testCheckAgainstThreshold() {
+        final ThresholdMeter thresholdMeter = createSmallThresholdMeter();
+
+        // first THRESHOLD_SMALL - 1 events should not exceed threshold
+        for (int i = 0; i < THRESHOLD_SMALL - 1; ++i) {
+            thresholdMeter.markEvent();
+            thresholdMeter.checkAgainstThreshold();
+        }
+
+        // the THRESHOLD_SMALL-th event should exceed threshold
+        thresholdMeter.markEvent();
+        try {
+            thresholdMeter.checkAgainstThreshold();
+            fail();
+        } catch (ThresholdExceedException e) {
+            // expected
+        }
+    }
+
+    @Test
+    public void testUpdateInterval() throws InterruptedException {
+        final ThresholdMeter thresholdMeter = createSmallThresholdMeter();
+
+        thresholdMeter.markEvent();
+        Thread.sleep(INTERVAL.toMillis() * 2);
+
+        for (int i = 0; i < THRESHOLD_SMALL - 1; ++i) {
+            thresholdMeter.markEvent();
+        }
+
+        assertThat(thresholdMeter.getCount(), is((long) THRESHOLD_SMALL));
+        assertThat(
+                thresholdMeter.getRate(),
+                closeTo(toPerSecondRate((int) (THRESHOLD_SMALL - 1)), ERROR));
+        thresholdMeter.checkAgainstThreshold();
+    }
+
+    private static ThresholdMeter createLargeThresholdMeter() {
+        return new ThresholdMeter(THRESHOLD_LARGE, INTERVAL);
+    }
+
+    private static ThresholdMeter createSmallThresholdMeter() {
+        return new ThresholdMeter(THRESHOLD_SMALL, INTERVAL);
+    }
+
+    private static double toPerSecondRate(int eventsPerInterval) {
+        return eventsPerInterval * 1000.0 / INTERVAL.toMillis();
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java b/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java
index 504f30924bb..2a82e73088f 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/metrics/MetricNames.java
@@ -62,6 +62,8 @@ public class MetricNames {
     public static final String CHECKPOINT_ALIGNMENT_TIME = "checkpointAlignmentTime";
     public static final String CHECKPOINT_START_DELAY_TIME = "checkpointStartDelayNanos";
 
+    public static final String START_WORKER_FAILURE_RATE = "startWorkFailure" + SUFFIX_RATE;
+
     public static String currentInputWatermarkName(int index) {
         return String.format(IO_CURRENT_INPUT_WATERMARK_PATERN, index);
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
index deb94b0e622..c53b460ec79 100755
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/ResourceManager.java
@@ -145,7 +145,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
 
     private final ClusterInformation clusterInformation;
 
-    private final ResourceManagerMetricGroup resourceManagerMetricGroup;
+    protected final ResourceManagerMetricGroup resourceManagerMetricGroup;
 
     protected final Executor ioExecutor;
 
@@ -247,7 +247,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
             leaderElectionService.start(this);
             jobLeaderIdService.start(new JobLeaderIdActionsImpl());
 
-            registerTaskExecutorMetrics();
+            registerMetrics();
         } catch (Exception e) {
             handleStartResourceManagerServicesException(e);
         }
@@ -980,7 +980,7 @@ public abstract class ResourceManager<WorkerType extends ResourceIDRetrievable>
         }
     }
 
-    private void registerTaskExecutorMetrics() {
+    protected void registerMetrics() {
         resourceManagerMetricGroup.gauge(
                 MetricNames.NUM_REGISTERED_TASK_MANAGERS, () -> (long) taskExecutors.size());
     }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java
index 7d79e2928f2..6b5c09d6b0a 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManager.java
@@ -21,6 +21,7 @@ package org.apache.flink.runtime.resourcemanager.active;
 import org.apache.flink.annotation.VisibleForTesting;
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.metrics.ThresholdMeter;
 import org.apache.flink.runtime.akka.AkkaUtils;
 import org.apache.flink.runtime.clusterframework.ApplicationStatus;
 import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
@@ -33,6 +34,7 @@ import org.apache.flink.runtime.entrypoint.ClusterInformation;
 import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.io.network.partition.ResourceManagerPartitionTrackerFactory;
+import org.apache.flink.runtime.metrics.MetricNames;
 import org.apache.flink.runtime.metrics.groups.ResourceManagerMetricGroup;
 import org.apache.flink.runtime.resourcemanager.JobLeaderIdService;
 import org.apache.flink.runtime.resourcemanager.ResourceManager;
@@ -45,6 +47,7 @@ import org.apache.flink.util.Preconditions;
 
 import javax.annotation.Nullable;
 
+import java.time.Duration;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
@@ -54,6 +57,8 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
+import static org.apache.flink.util.Preconditions.checkNotNull;
+
 /**
  * An active implementation of {@link ResourceManager}.
  *
@@ -66,6 +71,8 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
 
     protected final Configuration flinkConfig;
 
+    private final Time startWorkerRetryInterval;
+
     private final ResourceManagerDriver<WorkerType> resourceManagerDriver;
 
     /** All workers maintained by {@link ActiveResourceManager}. */
@@ -77,6 +84,15 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
     /** Identifiers and worker resource spec of requested not registered workers. */
     private final Map<ResourceID, WorkerResourceSpec> currentAttemptUnregisteredWorkers;
 
+    private final ThresholdMeter startWorkerFailureRater;
+
+    /**
+     * Incompletion of this future indicates that the max failure rate of start worker is reached
+     * and the resource manager should not retry starting new worker until the future become
+     * completed again. It's guaranteed to be modified in main thread.
+     */
+    private CompletableFuture<Void> startWorkerCoolDown;
+
     public ActiveResourceManager(
             ResourceManagerDriver<WorkerType> resourceManagerDriver,
             Configuration flinkConfig,
@@ -90,6 +106,8 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
             ClusterInformation clusterInformation,
             FatalErrorHandler fatalErrorHandler,
             ResourceManagerMetricGroup resourceManagerMetricGroup,
+            ThresholdMeter startWorkerFailureRater,
+            Duration retryInterval,
             Executor ioExecutor) {
         super(
                 rpcService,
@@ -110,6 +128,9 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
         this.workerNodeMap = new HashMap<>();
         this.pendingWorkerCounter = new PendingWorkerCounter();
         this.currentAttemptUnregisteredWorkers = new HashMap<>();
+        this.startWorkerFailureRater = checkNotNull(startWorkerFailureRater);
+        this.startWorkerRetryInterval = Time.of(retryInterval.toMillis(), TimeUnit.MILLISECONDS);
+        this.startWorkerCoolDown = FutureUtils.completedVoidFuture();
     }
 
     // ------------------------------------------------------------------------
@@ -196,6 +217,13 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
         }
     }
 
+    @Override
+    protected void registerMetrics() {
+        super.registerMetrics();
+        resourceManagerMetricGroup.meter(
+                MetricNames.START_WORKER_FAILURE_RATE, startWorkerFailureRater);
+    }
+
     // ------------------------------------------------------------------------
     //  ResourceEventListener
     // ------------------------------------------------------------------------
@@ -215,6 +243,10 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
 
     @Override
     public void onWorkerTerminated(ResourceID resourceId, String diagnostics) {
+        if (currentAttemptUnregisteredWorkers.containsKey(resourceId)) {
+            recordWorkerFailureAndPauseWorkerCreationIfNeeded();
+        }
+
         if (clearStateForWorker(resourceId)) {
             log.info(
                     "Worker {} is terminated. Diagnostics: {}",
@@ -245,8 +277,13 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
                 workerResourceSpec,
                 pendingCount);
 
-        CompletableFuture<WorkerType> requestResourceFuture =
-                resourceManagerDriver.requestResource(taskExecutorProcessSpec);
+        // In case of start worker failures, we should wait for an interval before
+        // trying to start new workers.
+        // Otherwise, ActiveResourceManager will always re-requesting the worker,
+        // which keeps the main thread busy.
+        final CompletableFuture<WorkerType> requestResourceFuture =
+                startWorkerCoolDown.thenCompose(
+                        (ignore) -> resourceManagerDriver.requestResource(taskExecutorProcessSpec));
         FutureUtils.assertNoException(
                 requestResourceFuture.handle(
                         (worker, exception) -> {
@@ -258,6 +295,7 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
                                         workerResourceSpec,
                                         count,
                                         exception);
+                                recordWorkerFailureAndPauseWorkerCreationIfNeeded();
                                 requestWorkerIfRequired();
                             } else {
                                 final ResourceID resourceId = worker.getResourceID();
@@ -312,6 +350,40 @@ public class ActiveResourceManager<WorkerType extends ResourceIDRetrievable>
         }
     }
 
+    private void recordWorkerFailureAndPauseWorkerCreationIfNeeded() {
+        if (recordStartWorkerFailure()) {
+            // if exceed failure rate try to slow down
+            tryResetWorkerCreationCoolDown();
+        }
+    }
+
+    /**
+     * Record failure number of starting worker in ResourceManagers. Return whether maximum failure
+     * rate is reached.
+     *
+     * @return whether max failure rate is reached
+     */
+    private boolean recordStartWorkerFailure() {
+        startWorkerFailureRater.markEvent();
+
+        try {
+            startWorkerFailureRater.checkAgainstThreshold();
+        } catch (ThresholdMeter.ThresholdExceedException e) {
+            log.warn("Reaching max start worker failure rate: {}", e.getMessage());
+            return true;
+        }
+
+        return false;
+    }
+
+    private void tryResetWorkerCreationCoolDown() {
+        if (startWorkerCoolDown.isDone()) {
+            log.info("Will not retry creating worker in {}.", startWorkerRetryInterval);
+            startWorkerCoolDown = new CompletableFuture<>();
+            scheduleRunAsync(() -> startWorkerCoolDown.complete(null), startWorkerRetryInterval);
+        }
+    }
+
     /** Always execute on the current main thread executor. */
     private class GatewayMainThreadExecutor implements ScheduledExecutor {
 
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java
index ad17c3f5e62..c65d3972bdf 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerFactory.java
@@ -19,7 +19,10 @@
 package org.apache.flink.runtime.resourcemanager.active;
 
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.IllegalConfigurationException;
+import org.apache.flink.configuration.ResourceManagerOptions;
 import org.apache.flink.configuration.TaskManagerOptions;
+import org.apache.flink.metrics.ThresholdMeter;
 import org.apache.flink.runtime.clusterframework.TaskExecutorProcessUtils;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceIDRetrievable;
@@ -37,6 +40,7 @@ import org.apache.flink.runtime.rpc.RpcService;
 
 import javax.annotation.Nullable;
 
+import java.time.Duration;
 import java.util.concurrent.Executor;
 
 /**
@@ -98,6 +102,9 @@ public abstract class ActiveResourceManagerFactory<WorkerType extends ResourceID
             Executor ioExecutor)
             throws Exception {
 
+        final ThresholdMeter failureRater = createStartWorkerFailureRater(configuration);
+        final Duration retryInterval =
+                configuration.get(ResourceManagerOptions.START_WORKER_RETRY_INTERVAL);
         return new ActiveResourceManager<>(
                 createResourceManagerDriver(
                         configuration, webInterfaceUrl, rpcService.getAddress()),
@@ -112,10 +119,23 @@ public abstract class ActiveResourceManagerFactory<WorkerType extends ResourceID
                 clusterInformation,
                 fatalErrorHandler,
                 resourceManagerMetricGroup,
+                failureRater,
+                retryInterval,
                 ioExecutor);
     }
 
     protected abstract ResourceManagerDriver<WorkerType> createResourceManagerDriver(
             Configuration configuration, @Nullable String webInterfaceUrl, String rpcAddress)
             throws Exception;
+
+    public static ThresholdMeter createStartWorkerFailureRater(Configuration configuration) {
+        double rate = configuration.getDouble(ResourceManagerOptions.START_WORKER_MAX_FAILURE_RATE);
+        if (rate <= 0) {
+            throw new IllegalConfigurationException(
+                    String.format(
+                            "Configured max start worker failure rate ('%s') must be larger than 0. Current: %f",
+                            ResourceManagerOptions.START_WORKER_MAX_FAILURE_RATE.key(), rate));
+        }
+        return new ThresholdMeter(rate, Duration.ofMinutes(1));
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
index b325900f902..e1e21027741 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/active/ActiveResourceManagerTest.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.resourcemanager.active;
 
 import org.apache.flink.api.common.time.Time;
 import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.ResourceManagerOptions;
 import org.apache.flink.runtime.clusterframework.TaskExecutorProcessSpec;
 import org.apache.flink.runtime.clusterframework.TaskExecutorProcessUtils;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
@@ -48,6 +49,7 @@ import org.apache.flink.util.function.RunnableWithException;
 import org.junit.ClassRule;
 import org.junit.Test;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -57,6 +59,7 @@ import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.instanceOf;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.lessThan;
@@ -72,6 +75,7 @@ public class ActiveResourceManagerTest extends TestLogger {
 
     private static final long TIMEOUT_SEC = 5L;
     private static final Time TIMEOUT_TIME = Time.seconds(TIMEOUT_SEC);
+    private static final Time TESTING_START_WORKER_INTERVAL = Time.milliseconds(50);
 
     private static final WorkerResourceSpec WORKER_RESOURCE_SPEC = WorkerResourceSpec.ZERO;
 
@@ -488,6 +492,166 @@ public class ActiveResourceManagerTest extends TestLogger {
         };
     }
 
+    @Test
+    public void testStartWorkerIntervalOnWorkerTerminationExceedFailureRate() throws Exception {
+        new Context() {
+            {
+                flinkConfig.setDouble(ResourceManagerOptions.START_WORKER_MAX_FAILURE_RATE, 1);
+                flinkConfig.set(
+                        ResourceManagerOptions.START_WORKER_RETRY_INTERVAL,
+                        Duration.ofMillis(TESTING_START_WORKER_INTERVAL.toMilliseconds()));
+
+                final AtomicInteger requestCount = new AtomicInteger(0);
+
+                final List<ResourceID> tmResourceIds = new ArrayList<>();
+                tmResourceIds.add(ResourceID.generate());
+                tmResourceIds.add(ResourceID.generate());
+
+                final List<CompletableFuture<Long>> requestWorkerFromDriverFutures =
+                        new ArrayList<>();
+                requestWorkerFromDriverFutures.add(new CompletableFuture<>());
+                requestWorkerFromDriverFutures.add(new CompletableFuture<>());
+
+                driverBuilder.setRequestResourceFunction(
+                        taskExecutorProcessSpec -> {
+                            int idx = requestCount.getAndIncrement();
+                            assertThat(idx, lessThan(2));
+
+                            requestWorkerFromDriverFutures
+                                    .get(idx)
+                                    .complete(System.currentTimeMillis());
+                            return CompletableFuture.completedFuture(tmResourceIds.get(idx));
+                        });
+
+                slotManagerBuilder.setGetRequiredResourcesSupplier(
+                        () -> Collections.singletonMap(WORKER_RESOURCE_SPEC, 1));
+
+                runTest(
+                        () -> {
+                            // received worker request, verify requesting from driver
+                            CompletableFuture<Boolean> startNewWorkerFuture =
+                                    runInMainThread(
+                                            () ->
+                                                    getResourceManager()
+                                                            .startNewWorker(WORKER_RESOURCE_SPEC));
+                            long t1 =
+                                    requestWorkerFromDriverFutures
+                                            .get(0)
+                                            .get(TIMEOUT_SEC, TimeUnit.SECONDS);
+                            assertThat(
+                                    startNewWorkerFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),
+                                    is(true));
+
+                            // first worker failed before register, verify requesting another worker
+                            // from driver
+                            runInMainThread(
+                                    () ->
+                                            getResourceManager()
+                                                    .onWorkerTerminated(
+                                                            tmResourceIds.get(0),
+                                                            "terminate for testing"));
+                            long t2 =
+                                    requestWorkerFromDriverFutures
+                                            .get(1)
+                                            .get(TIMEOUT_SEC, TimeUnit.SECONDS);
+
+                            // validate trying creating worker twice, with proper interval
+                            assertThat(
+                                    (t2 - t1),
+                                    greaterThanOrEqualTo(
+                                            TESTING_START_WORKER_INTERVAL.toMilliseconds()));
+                            // second worker registered, verify registration succeed
+                            CompletableFuture<RegistrationResponse> registerTaskExecutorFuture =
+                                    registerTaskExecutor(tmResourceIds.get(1));
+                            assertThat(
+                                    registerTaskExecutorFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),
+                                    instanceOf(RegistrationResponse.Success.class));
+                        });
+            }
+        };
+    }
+
+    @Test
+    public void testStartWorkerIntervalOnRequestWorkerFailure() throws Exception {
+        new Context() {
+            {
+                flinkConfig.setDouble(ResourceManagerOptions.START_WORKER_MAX_FAILURE_RATE, 1);
+                flinkConfig.set(
+                        ResourceManagerOptions.START_WORKER_RETRY_INTERVAL,
+                        Duration.ofMillis(TESTING_START_WORKER_INTERVAL.toMilliseconds()));
+
+                final AtomicInteger requestCount = new AtomicInteger(0);
+                final ResourceID tmResourceId = ResourceID.generate();
+
+                final List<CompletableFuture<ResourceID>> resourceIdFutures = new ArrayList<>();
+                resourceIdFutures.add(new CompletableFuture<>());
+                resourceIdFutures.add(new CompletableFuture<>());
+
+                final List<CompletableFuture<Long>> requestWorkerFromDriverFutures =
+                        new ArrayList<>();
+                requestWorkerFromDriverFutures.add(new CompletableFuture<>());
+                requestWorkerFromDriverFutures.add(new CompletableFuture<>());
+
+                driverBuilder.setRequestResourceFunction(
+                        taskExecutorProcessSpec -> {
+                            int idx = requestCount.getAndIncrement();
+                            assertThat(idx, lessThan(2));
+
+                            requestWorkerFromDriverFutures
+                                    .get(idx)
+                                    .complete(System.currentTimeMillis());
+                            return resourceIdFutures.get(idx);
+                        });
+
+                slotManagerBuilder.setGetRequiredResourcesSupplier(
+                        () -> Collections.singletonMap(WORKER_RESOURCE_SPEC, 1));
+
+                runTest(
+                        () -> {
+                            // received worker request, verify requesting from driver
+                            CompletableFuture<Boolean> startNewWorkerFuture =
+                                    runInMainThread(
+                                            () ->
+                                                    getResourceManager()
+                                                            .startNewWorker(WORKER_RESOURCE_SPEC));
+                            assertThat(
+                                    startNewWorkerFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),
+                                    is(true));
+
+                            long t1 =
+                                    requestWorkerFromDriverFutures
+                                            .get(0)
+                                            .get(TIMEOUT_SEC, TimeUnit.SECONDS);
+                            // first request failed, verify requesting another worker from driver
+                            runInMainThread(
+                                    () ->
+                                            resourceIdFutures
+                                                    .get(0)
+                                                    .completeExceptionally(
+                                                            new Throwable("testing error")));
+                            long t2 =
+                                    requestWorkerFromDriverFutures
+                                            .get(1)
+                                            .get(TIMEOUT_SEC, TimeUnit.SECONDS);
+
+                            // validate trying creating worker twice, with proper interval
+                            assertThat(
+                                    (t2 - t1),
+                                    greaterThanOrEqualTo(
+                                            TESTING_START_WORKER_INTERVAL.toMilliseconds()));
+
+                            // second worker registered, verify registration succeed
+                            resourceIdFutures.get(1).complete(tmResourceId);
+                            CompletableFuture<RegistrationResponse> registerTaskExecutorFuture =
+                                    registerTaskExecutor(tmResourceId);
+                            assertThat(
+                                    registerTaskExecutorFuture.get(TIMEOUT_SEC, TimeUnit.SECONDS),
+                                    instanceOf(RegistrationResponse.Success.class));
+                        });
+            }
+        };
+    }
+
     /** Tests workers from previous attempt successfully recovered and registered. */
     @Test
     public void testRecoverWorkerFromPreviousAttempt() throws Exception {
@@ -588,6 +752,8 @@ public class ActiveResourceManagerTest extends TestLogger {
             final TestingRpcService rpcService = RPC_SERVICE_RESOURCE.getTestingRpcService();
             final MockResourceManagerRuntimeServices rmServices =
                     new MockResourceManagerRuntimeServices(rpcService, TIMEOUT_TIME, slotManager);
+            final Duration retryInterval =
+                    configuration.get(ResourceManagerOptions.START_WORKER_RETRY_INTERVAL);
 
             final ActiveResourceManager<ResourceID> activeResourceManager =
                     new ActiveResourceManager<>(
@@ -603,6 +769,9 @@ public class ActiveResourceManagerTest extends TestLogger {
                             new ClusterInformation("localhost", 1234),
                             fatalErrorHandler,
                             UnregisteredMetricGroups.createUnregisteredResourceManagerMetricGroup(),
+                            ActiveResourceManagerFactory.createStartWorkerFailureRater(
+                                    configuration),
+                            retryInterval,
                             ForkJoinPool.commonPool());
 
             activeResourceManager.start();
