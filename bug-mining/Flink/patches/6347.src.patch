diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/sink/filesystem/Bucket.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/sink/filesystem/Bucket.java
index f1f34baf1e2..8b5d2ab73fe 100644
--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/sink/filesystem/Bucket.java
+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/functions/sink/filesystem/Bucket.java
@@ -142,6 +142,7 @@ public class Bucket<IN, BucketID> {
                             bucketId,
                             inProgressFileRecoverable,
                             state.getInProgressFileCreationTime());
+            inProgressFileRecoverablesPerCheckpoint.put(Long.MIN_VALUE, inProgressFileRecoverable);
         } else {
             // if the writer does not support resume, then we close the
             // in-progress part and commit it, as done in the case of pending files.
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/sink/filesystem/BucketTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/sink/filesystem/BucketTest.java
index 9fc09cdb110..245e895878b 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/sink/filesystem/BucketTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/functions/sink/filesystem/BucketTest.java
@@ -117,6 +117,33 @@ public class BucketTest {
         assertThat(recoverableWriter, hasCalledDiscard(0)); // we have no in-progress file.
     }
 
+    @Test
+    public void shouldCleanupOutdatedResumablesAfterResumed() throws Exception {
+        final File outDir = TEMP_FOLDER.newFolder();
+        final Path path = new Path(outDir.toURI());
+
+        final TestRecoverableWriter recoverableWriter = getRecoverableWriter(path);
+        final Bucket<String, String> bucketUnderTest =
+                createBucket(recoverableWriter, path, 0, 0, OutputFileConfig.builder().build());
+
+        bucketUnderTest.write("test-element", 0L);
+        final BucketState<String> state0 = bucketUnderTest.onReceptionOfCheckpoint(0L);
+        assertThat(state0, hasActiveInProgressFile());
+        bucketUnderTest.onSuccessfulCompletionOfCheckpoint(0L);
+        assertThat(recoverableWriter, hasCalledDiscard(0));
+
+        final File newOutDir = TEMP_FOLDER.newFolder();
+        final Path newPath = new Path(newOutDir.toURI());
+        final TestRecoverableWriter newRecoverableWriter = getRecoverableWriter(newPath);
+        final Bucket<String, String> bucketAfterResume =
+                restoreBucket(
+                        newRecoverableWriter, 0, 0, state0, OutputFileConfig.builder().build());
+        final BucketState<String> state1 = bucketAfterResume.onReceptionOfCheckpoint(1L);
+        assertThat(state1, hasActiveInProgressFile());
+        bucketAfterResume.onSuccessfulCompletionOfCheckpoint(1L);
+        assertThat(newRecoverableWriter, hasCalledDiscard(1));
+    }
+
     // --------------------------- Checking Restore ---------------------------
 
     @Test
