diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
index b6aa84130ff..09890b31dbb 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java
@@ -977,7 +977,9 @@ public class CheckpointCoordinator {
         }
 
         final long checkpointId = message.getCheckpointId();
-        final String reason = (message.getReason() != null ? message.getReason().getMessage() : "");
+        final CheckpointException checkpointException =
+                message.getSerializedCheckpointException().unwrap();
+        final String reason = checkpointException.getMessage();
 
         PendingCheckpoint checkpoint;
 
@@ -1001,16 +1003,7 @@ public class CheckpointCoordinator {
                         message.getTaskExecutionId(),
                         job,
                         taskManagerLocationInfo,
-                        message.getReason());
-                final CheckpointException checkpointException;
-                if (message.getReason() == null) {
-                    checkpointException =
-                            new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED);
-                } else {
-                    checkpointException =
-                            getCheckpointException(
-                                    CheckpointFailureReason.JOB_FAILURE, message.getReason());
-                }
+                        checkpointException.getCause());
                 abortPendingCheckpoint(
                         checkpoint, checkpointException, message.getTaskExecutionId());
             } else if (LOG.isDebugEnabled()) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java
index 40f213a7bf7..44dc411d549 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManager.java
@@ -33,6 +33,8 @@ import static org.apache.flink.util.Preconditions.checkNotNull;
 public class CheckpointFailureManager {
 
     public static final int UNLIMITED_TOLERABLE_FAILURE_NUMBER = Integer.MAX_VALUE;
+    public static final String EXCEEDED_CHECKPOINT_TOLERABLE_FAILURE_MESSAGE =
+            "Exceeded checkpoint tolerable failure threshold.";
 
     private final int tolerableCpFailureNumber;
     private final FailJobCallback failureCallback;
@@ -94,8 +96,7 @@ public class CheckpointFailureManager {
             if (continuousFailureCounter.get() > tolerableCpFailureNumber) {
                 clearCount();
                 errorHandler.accept(
-                        new FlinkRuntimeException(
-                                "Exceeded checkpoint tolerable failure threshold."));
+                        new FlinkRuntimeException(EXCEEDED_CHECKPOINT_TOLERABLE_FAILURE_MESSAGE));
             }
         }
     }
@@ -127,7 +128,6 @@ public class CheckpointFailureManager {
             case CHECKPOINT_DECLINED_INPUT_END_OF_STREAM:
 
             case EXCEPTION:
-            case CHECKPOINT_ASYNC_EXCEPTION:
             case TASK_FAILURE:
             case TASK_CHECKPOINT_FAILURE:
             case UNKNOWN_TASK_CHECKPOINT_NOTIFICATION_FAILURE:
@@ -136,6 +136,7 @@ public class CheckpointFailureManager {
                 // ignore
                 break;
 
+            case CHECKPOINT_ASYNC_EXCEPTION:
             case CHECKPOINT_DECLINED:
             case CHECKPOINT_EXPIRED:
                 // we should make sure one checkpoint only be counted once
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/DeclineCheckpoint.java b/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/DeclineCheckpoint.java
index c76c9216b81..0122d9a3214 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/DeclineCheckpoint.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/DeclineCheckpoint.java
@@ -19,10 +19,11 @@
 package org.apache.flink.runtime.messages.checkpoint;
 
 import org.apache.flink.api.common.JobID;
+import org.apache.flink.runtime.checkpoint.CheckpointException;
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
-import org.apache.flink.util.SerializedThrowable;
+import org.apache.flink.util.Preconditions;
 
-import javax.annotation.Nullable;
+import javax.annotation.Nonnull;
 
 /**
  * This message is sent from the {@link org.apache.flink.runtime.taskexecutor.TaskExecutor} to the
@@ -34,22 +35,20 @@ public class DeclineCheckpoint extends AbstractCheckpointMessage implements java
 
     private static final long serialVersionUID = 2094094662279578953L;
 
-    /** The reason why the checkpoint was declined. */
-    @Nullable private final SerializedThrowable reason;
-
-    public DeclineCheckpoint(JobID job, ExecutionAttemptID taskExecutionId, long checkpointId) {
-        this(job, taskExecutionId, checkpointId, null);
-    }
+    /** The serialized reason why the checkpoint was declined. */
+    private final SerializedCheckpointException serializedCheckpointException;
 
     public DeclineCheckpoint(
             JobID job,
             ExecutionAttemptID taskExecutionId,
             long checkpointId,
-            @Nullable Throwable reason) {
+            CheckpointException checkpointException) {
         super(job, taskExecutionId, checkpointId);
 
-        // some other exception. replace with a serialized throwable, to be on the safe side
-        this.reason = reason == null ? null : new SerializedThrowable(reason);
+        Preconditions.checkNotNull(
+                checkpointException, "The checkpoint exception must not be null.");
+        // replace with a serialized throwable, to be on the safe side
+        this.serializedCheckpointException = new SerializedCheckpointException(checkpointException);
     }
 
     // --------------------------------------------------------------------------------------------
@@ -59,8 +58,9 @@ public class DeclineCheckpoint extends AbstractCheckpointMessage implements java
      *
      * @return The reason why the checkpoint was declined
      */
-    public SerializedThrowable getReason() {
-        return reason;
+    @Nonnull
+    public SerializedCheckpointException getSerializedCheckpointException() {
+        return serializedCheckpointException;
     }
 
     // --------------------------------------------------------------------------------------------
@@ -69,6 +69,9 @@ public class DeclineCheckpoint extends AbstractCheckpointMessage implements java
     public String toString() {
         return String.format(
                 "Declined Checkpoint %d for (%s/%s): %s",
-                getCheckpointId(), getJob(), getTaskExecutionId(), reason);
+                getCheckpointId(),
+                getJob(),
+                getTaskExecutionId(),
+                serializedCheckpointException.getCheckpointFailureReason());
     }
 }
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/SerializedCheckpointException.java b/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/SerializedCheckpointException.java
new file mode 100644
index 00000000000..a18ce3deae6
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/messages/checkpoint/SerializedCheckpointException.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.messages.checkpoint;
+
+import org.apache.flink.runtime.checkpoint.CheckpointException;
+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;
+import org.apache.flink.util.SerializedThrowable;
+
+import java.io.Serializable;
+
+/**
+ * Serialized checkpoint exception which wraps the checkpoint failure reason and its serialized
+ * throwable.
+ */
+public class SerializedCheckpointException implements Serializable {
+    private static final long serialVersionUID = 1L;
+
+    private final CheckpointFailureReason checkpointFailureReason;
+    private final SerializedThrowable serializedThrowable;
+
+    public SerializedCheckpointException(CheckpointException checkpointException) {
+        this.checkpointFailureReason = checkpointException.getCheckpointFailureReason();
+        this.serializedThrowable = new SerializedThrowable(checkpointException);
+    }
+
+    public CheckpointFailureReason getCheckpointFailureReason() {
+        return checkpointFailureReason;
+    }
+
+    public SerializedThrowable getSerializedThrowable() {
+        return serializedThrowable;
+    }
+
+    public CheckpointException unwrap() {
+        return new CheckpointException(checkpointFailureReason, serializedThrowable);
+    }
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/rpc/RpcCheckpointResponder.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/rpc/RpcCheckpointResponder.java
index a712bbab45c..e3d3e158bce 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/rpc/RpcCheckpointResponder.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/rpc/RpcCheckpointResponder.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.taskexecutor.rpc;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.runtime.checkpoint.CheckpointCoordinatorGateway;
+import org.apache.flink.runtime.checkpoint.CheckpointException;
 import org.apache.flink.runtime.checkpoint.CheckpointMetrics;
 import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;
 import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
@@ -65,7 +66,16 @@ public class RpcCheckpointResponder implements CheckpointResponder {
             long checkpointId,
             Throwable cause) {
 
+        // TODO the passed parameter 'cause' is actually always instance of CheckpointException,
+        //  we should change the interfaces to narrow all declined checkpoint's throwable to
+        // CheckpointException.
+        Preconditions.checkArgument(
+                cause instanceof CheckpointException,
+                "The given cause is "
+                        + cause.getClass()
+                        + " instead of expected CheckpointException.");
         checkpointCoordinatorGateway.declineCheckpoint(
-                new DeclineCheckpoint(jobID, executionAttemptID, checkpointId, cause));
+                new DeclineCheckpoint(
+                        jobID, executionAttemptID, checkpointId, (CheckpointException) cause));
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
index 29c1a2144bd..5b12701894d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTest.java
@@ -101,6 +101,8 @@ import java.util.concurrent.atomic.AtomicReference;
 
 import static org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTestingUtils.mockExecutionJobVertex;
 import static org.apache.flink.runtime.checkpoint.CheckpointCoordinatorTestingUtils.mockExecutionVertex;
+import static org.apache.flink.runtime.checkpoint.CheckpointFailureReason.CHECKPOINT_ASYNC_EXCEPTION;
+import static org.apache.flink.runtime.checkpoint.CheckpointFailureReason.CHECKPOINT_DECLINED;
 import static org.apache.flink.runtime.checkpoint.CheckpointFailureReason.CHECKPOINT_EXPIRED;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 import static org.apache.flink.util.Preconditions.checkState;
@@ -190,7 +192,8 @@ public class CheckpointCoordinatorTest extends TestLogger {
                 new DeclineCheckpoint(
                         jobID,
                         decliningVertex.getCurrentExecutionAttempt().getAttemptId(),
-                        checkpointId),
+                        checkpointId,
+                        new CheckpointException(CHECKPOINT_DECLINED)),
                 "test");
 
         CheckpointMetrics lateReportedMetrics =
@@ -435,7 +438,11 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
             // decline checkpoint from the other task
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID1, checkpointId),
+                    new DeclineCheckpoint(
+                            jobId,
+                            attemptID1,
+                            checkpointId,
+                            new CheckpointException(CHECKPOINT_DECLINED)),
                     TASK_MANAGER_LOCATION_INFO);
 
             fail("Test failed.");
@@ -481,14 +488,26 @@ public class CheckpointCoordinatorTest extends TestLogger {
         }
     }
 
+    @Test
+    public void testTriggerAndDeclineSyncCheckpointFailureSimple() {
+        testTriggerAndDeclineCheckpointSimple(CHECKPOINT_DECLINED);
+    }
+
+    @Test
+    public void testTriggerAndDeclineAsyncCheckpointFailureSimple() {
+        testTriggerAndDeclineCheckpointSimple(CHECKPOINT_ASYNC_EXCEPTION);
+    }
+
     /**
      * This test triggers a checkpoint and then sends a decline checkpoint message from one of the
      * tasks. The expected behaviour is that said checkpoint is discarded and a new checkpoint is
      * triggered.
      */
-    @Test
-    public void testTriggerAndDeclineCheckpointSimple() {
+    private void testTriggerAndDeclineCheckpointSimple(
+            CheckpointFailureReason checkpointFailureReason) {
         try {
+            final CheckpointException checkpointException =
+                    new CheckpointException(checkpointFailureReason);
             final JobID jobId = new JobID();
 
             // create some mock Execution vertices that receive the checkpoint trigger messages
@@ -497,9 +516,21 @@ public class CheckpointCoordinatorTest extends TestLogger {
             ExecutionVertex vertex1 = mockExecutionVertex(attemptID1);
             ExecutionVertex vertex2 = mockExecutionVertex(attemptID2);
 
+            TestFailJobCallback failJobCallback = new TestFailJobCallback();
             // set up the coordinator and validate the initial state
             CheckpointCoordinator checkpointCoordinator =
-                    getCheckpointCoordinator(jobId, vertex1, vertex2);
+                    new CheckpointCoordinatorBuilder()
+                            .setJobId(jobId)
+                            .setTasks(new ExecutionVertex[] {vertex1, vertex2})
+                            .setCheckpointCoordinatorConfiguration(
+                                    CheckpointCoordinatorConfiguration.builder()
+                                            .setAlignmentTimeout(Long.MAX_VALUE)
+                                            .setMaxConcurrentCheckpoints(Integer.MAX_VALUE)
+                                            .build())
+                            .setTimer(manuallyTriggeredScheduledExecutor)
+                            .setCheckpointFailureManager(
+                                    new CheckpointFailureManager(0, failJobCallback))
+                            .build();
 
             assertEquals(0, checkpointCoordinator.getNumberOfPendingCheckpoints());
             assertEquals(0, checkpointCoordinator.getNumberOfRetainedSuccessfulCheckpoints());
@@ -565,7 +596,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
             // decline checkpoint from the other task, this should cancel the checkpoint
             // and trigger a new one
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID1, checkpointId),
+                    new DeclineCheckpoint(jobId, attemptID1, checkpointId, checkpointException),
                     TASK_MANAGER_LOCATION_INFO);
             assertTrue(checkpoint.isDisposed());
 
@@ -579,12 +610,13 @@ public class CheckpointCoordinatorTest extends TestLogger {
             // decline again, nothing should happen
             // decline from the other task, nothing should happen
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID1, checkpointId),
+                    new DeclineCheckpoint(jobId, attemptID1, checkpointId, checkpointException),
                     TASK_MANAGER_LOCATION_INFO);
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID2, checkpointId),
+                    new DeclineCheckpoint(jobId, attemptID2, checkpointId, checkpointException),
                     TASK_MANAGER_LOCATION_INFO);
             assertTrue(checkpoint.isDisposed());
+            assertEquals(1, failJobCallback.getInvokeCounter());
 
             checkpointCoordinator.shutdown();
         } catch (Exception e) {
@@ -683,7 +715,11 @@ public class CheckpointCoordinatorTest extends TestLogger {
 
             // decline checkpoint from one of the tasks, this should cancel the checkpoint
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID1, checkpoint1Id),
+                    new DeclineCheckpoint(
+                            jobId,
+                            attemptID1,
+                            checkpoint1Id,
+                            new CheckpointException(CHECKPOINT_DECLINED)),
                     TASK_MANAGER_LOCATION_INFO);
             verify(vertex1.getCurrentExecutionAttempt(), times(1))
                     .notifyCheckpointAborted(eq(checkpoint1Id), any(Long.class));
@@ -722,10 +758,18 @@ public class CheckpointCoordinatorTest extends TestLogger {
             // decline again, nothing should happen
             // decline from the other task, nothing should happen
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID1, checkpoint1Id),
+                    new DeclineCheckpoint(
+                            jobId,
+                            attemptID1,
+                            checkpoint1Id,
+                            new CheckpointException(CHECKPOINT_DECLINED)),
                     TASK_MANAGER_LOCATION_INFO);
             checkpointCoordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, attemptID2, checkpoint1Id),
+                    new DeclineCheckpoint(
+                            jobId,
+                            attemptID2,
+                            checkpoint1Id,
+                            new CheckpointException(CHECKPOINT_DECLINED)),
                     TASK_MANAGER_LOCATION_INFO);
             assertTrue(checkpoint1.isDisposed());
 
@@ -1569,7 +1613,11 @@ public class CheckpointCoordinatorTest extends TestLogger {
         // let the checkpoint fail at the first ack vertex
         reset(subtaskStateTrigger);
         checkpointCoordinator.receiveDeclineMessage(
-                new DeclineCheckpoint(jobId, ackAttemptId1, checkpointId),
+                new DeclineCheckpoint(
+                        jobId,
+                        ackAttemptId1,
+                        checkpointId,
+                        new CheckpointException(CHECKPOINT_DECLINED)),
                 TASK_MANAGER_LOCATION_INFO);
 
         assertTrue(pendingCheckpoint.isDisposed());
@@ -2750,7 +2798,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
         } catch (ExecutionException e) {
             final Throwable cause = ExceptionUtils.stripExecutionException(e);
             assertTrue(cause instanceof CheckpointException);
-            assertEquals(expectedRootCause.getMessage(), cause.getCause().getMessage());
+            assertEquals(expectedRootCause.getMessage(), cause.getCause().getCause().getMessage());
         }
 
         assertEquals(1L, invocationCounterAndException.f0.intValue());
@@ -2759,6 +2807,7 @@ public class CheckpointCoordinatorTest extends TestLogger {
                         && invocationCounterAndException
                                 .f1
                                 .getCause()
+                                .getCause()
                                 .getMessage()
                                 .equals(expectedRootCause.getMessage()));
 
@@ -2837,7 +2886,12 @@ public class CheckpointCoordinatorTest extends TestLogger {
                     coordinator.getNumQueuedRequests());
 
             coordinator.receiveDeclineMessage(
-                    new DeclineCheckpoint(jobId, new ExecutionAttemptID(), 1L), "none");
+                    new DeclineCheckpoint(
+                            jobId,
+                            new ExecutionAttemptID(),
+                            1L,
+                            new CheckpointException(CHECKPOINT_DECLINED)),
+                    "none");
             manuallyTriggeredScheduledExecutor.triggerAll();
 
             activeRequests--; // savepoint triggered
@@ -3336,7 +3390,11 @@ public class CheckpointCoordinatorTest extends TestLogger {
                 coordinator.getPendingCheckpoints().entrySet().iterator().next().getKey();
         final PendingCheckpoint checkpoint = coordinator.getPendingCheckpoints().get(checkpointId);
         coordinator.receiveDeclineMessage(
-                new DeclineCheckpoint(jobId, attemptID, checkpointId, reason),
+                new DeclineCheckpoint(
+                        jobId,
+                        attemptID,
+                        checkpointId,
+                        new CheckpointException(CHECKPOINT_DECLINED, reason)),
                 TASK_MANAGER_LOCATION_INFO);
         return checkpoint;
     }
@@ -3433,4 +3491,24 @@ public class CheckpointCoordinatorTest extends TestLogger {
             this.owner = checkNotNull(coordinator);
         }
     }
+
+    private static class TestFailJobCallback implements CheckpointFailureManager.FailJobCallback {
+
+        private int invokeCounter = 0;
+
+        @Override
+        public void failJob(Throwable cause) {
+            invokeCounter++;
+        }
+
+        @Override
+        public void failJobDueToTaskFailure(
+                final Throwable cause, final ExecutionAttemptID executionAttemptID) {
+            invokeCounter++;
+        }
+
+        public int getInvokeCounter() {
+            return invokeCounter;
+        }
+    }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java
index 3e651a8cf82..ffe8201c01a 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinatorTestingUtils.java
@@ -713,6 +713,12 @@ public class CheckpointCoordinatorTestingUtils {
             return this;
         }
 
+        public CheckpointCoordinatorBuilder setCheckpointFailureManager(
+                CheckpointFailureManager checkpointFailureManager) {
+            this.failureManager = checkpointFailureManager;
+            return this;
+        }
+
         public CheckpointCoordinatorBuilder setCompletedCheckpointStore(
                 CompletedCheckpointStore completedCheckpointStore) {
             this.completedCheckpointStore = completedCheckpointStore;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManagerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManagerTest.java
index a73bf188743..66a137a3421 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManagerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/CheckpointFailureManagerTest.java
@@ -95,7 +95,8 @@ public class CheckpointFailureManagerTest extends TestLogger {
             failureManager.handleJobLevelCheckpointException(new CheckpointException(reason), -1);
         }
 
-        assertEquals(2, callback.getInvokeCounter());
+        // CHECKPOINT_DECLINED, CHECKPOINT_EXPIRED and CHECKPOINT_ASYNC_EXCEPTION
+        assertEquals(3, callback.getInvokeCounter());
     }
 
     @Test
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
index a56cdb6748f..edae8231172 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterTest.java
@@ -38,6 +38,8 @@ import org.apache.flink.core.io.InputSplitSource;
 import org.apache.flink.core.testutils.OneShotLatch;
 import org.apache.flink.queryablestate.KvStateID;
 import org.apache.flink.runtime.akka.AkkaUtils;
+import org.apache.flink.runtime.checkpoint.CheckpointException;
+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;
 import org.apache.flink.runtime.checkpoint.CheckpointProperties;
 import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.CheckpointRetentionPolicy;
@@ -134,7 +136,6 @@ import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.InstantiationUtil;
-import org.apache.flink.util.SerializedThrowable;
 import org.apache.flink.util.TestLogger;
 
 import akka.actor.ActorSystem;
@@ -325,7 +326,8 @@ public class JobMasterTest extends TestLogger {
                             System.currentTimeMillis()) {
                         @Override
                         public void declineCheckpoint(DeclineCheckpoint declineCheckpoint) {
-                            declineCheckpointMessageFuture.complete(declineCheckpoint.getReason());
+                            declineCheckpointMessageFuture.complete(
+                                    declineCheckpoint.getSerializedCheckpointException().unwrap());
                         }
                     };
 
@@ -343,6 +345,10 @@ public class JobMasterTest extends TestLogger {
             Throwable userException =
                     (Throwable) Class.forName(className, false, userClassLoader).newInstance();
 
+            CheckpointException checkpointException =
+                    new CheckpointException(
+                            CheckpointFailureReason.CHECKPOINT_DECLINED, userException);
+
             JobMasterGateway jobMasterGateway =
                     rpcService2
                             .connect(
@@ -354,13 +360,17 @@ public class JobMasterTest extends TestLogger {
             RpcCheckpointResponder rpcCheckpointResponder =
                     new RpcCheckpointResponder(jobMasterGateway);
             rpcCheckpointResponder.declineCheckpoint(
-                    jobGraph.getJobID(), new ExecutionAttemptID(), 1, userException);
+                    jobGraph.getJobID(), new ExecutionAttemptID(), 1, checkpointException);
 
             Throwable throwable =
                     declineCheckpointMessageFuture.get(
                             testingTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);
-            assertThat(throwable, instanceOf(SerializedThrowable.class));
-            assertThat(throwable.getMessage(), equalTo(userException.getMessage()));
+            assertThat(throwable, instanceOf(CheckpointException.class));
+            Optional<Throwable> throwableWithMessage =
+                    ExceptionUtils.findThrowableWithMessage(throwable, userException.getMessage());
+            assertTrue(throwableWithMessage.isPresent());
+            assertThat(
+                    throwableWithMessage.get().getMessage(), equalTo(userException.getMessage()));
         } finally {
             RpcUtils.terminateRpcServices(testingTimeout, rpcService1, rpcService2);
         }
diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskExecutionDecorationTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskExecutionDecorationTest.java
index 51e48036b4e..1d7f33e8f0b 100644
--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskExecutionDecorationTest.java
+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskExecutionDecorationTest.java
@@ -17,6 +17,8 @@
 
 package org.apache.flink.streaming.runtime.tasks;
 
+import org.apache.flink.runtime.checkpoint.CheckpointException;
+import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;
 import org.apache.flink.runtime.checkpoint.CheckpointMetaData;
 import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.checkpoint.CheckpointType;
@@ -48,7 +50,10 @@ public class StreamTaskExecutionDecorationTest {
 
     @Test
     public void testAbortCheckpointOnBarrierIsDecorated() throws Exception {
-        task.abortCheckpointOnBarrier(1, null);
+        task.abortCheckpointOnBarrier(
+                1,
+                new CheckpointException(
+                        CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER));
         Assert.assertTrue("execution decorator was not called", decorator.wasCalled());
     }
 
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/CheckpointFailureManagerITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/CheckpointFailureManagerITCase.java
new file mode 100644
index 00000000000..2b06a9752fc
--- /dev/null
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/CheckpointFailureManagerITCase.java
@@ -0,0 +1,214 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.test.checkpointing;
+
+import org.apache.flink.api.common.restartstrategy.RestartStrategies;
+import org.apache.flink.api.common.state.ListState;
+import org.apache.flink.api.common.state.ListStateDescriptor;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.configuration.ReadableConfig;
+import org.apache.flink.core.fs.CloseableRegistry;
+import org.apache.flink.runtime.checkpoint.CheckpointFailureManager;
+import org.apache.flink.runtime.checkpoint.CheckpointOptions;
+import org.apache.flink.runtime.client.JobExecutionException;
+import org.apache.flink.runtime.execution.Environment;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.state.AbstractSnapshotStrategy;
+import org.apache.flink.runtime.state.CheckpointStreamFactory;
+import org.apache.flink.runtime.state.DefaultOperatorStateBackend;
+import org.apache.flink.runtime.state.DefaultOperatorStateBackendBuilder;
+import org.apache.flink.runtime.state.FunctionInitializationContext;
+import org.apache.flink.runtime.state.FunctionSnapshotContext;
+import org.apache.flink.runtime.state.OperatorStateBackend;
+import org.apache.flink.runtime.state.OperatorStateHandle;
+import org.apache.flink.runtime.state.SnapshotResult;
+import org.apache.flink.runtime.state.memory.MemoryStateBackend;
+import org.apache.flink.runtime.testutils.MiniClusterResourceConfiguration;
+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;
+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
+import org.apache.flink.streaming.api.functions.sink.DiscardingSink;
+import org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction;
+import org.apache.flink.streaming.api.graph.StreamingJobGraphGenerator;
+import org.apache.flink.test.util.MiniClusterWithClientResource;
+import org.apache.flink.test.util.TestUtils;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.FlinkRuntimeException;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.annotation.Nonnull;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Optional;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.RunnableFuture;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static org.mockito.Mockito.mock;
+
+/** Tests to verify end-to-end logic of checkpoint failure manager. */
+public class CheckpointFailureManagerITCase extends TestLogger {
+    private static MiniClusterWithClientResource cluster;
+
+    @Before
+    public void setup() throws Exception {
+        Configuration configuration = new Configuration();
+
+        cluster =
+                new MiniClusterWithClientResource(
+                        new MiniClusterResourceConfiguration.Builder()
+                                .setConfiguration(configuration)
+                                .build());
+        cluster.before();
+    }
+
+    @AfterClass
+    public static void shutDownExistingCluster() {
+        if (cluster != null) {
+            cluster.after();
+            cluster = null;
+        }
+    }
+
+    @Test(timeout = 10000)
+    public void testAsyncCheckpointFailureTriggerJobFailed() throws Exception {
+        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
+        env.enableCheckpointing(100);
+        env.setRestartStrategy(RestartStrategies.noRestart());
+        env.setStateBackend(new AsyncFailureStateBackend());
+        env.addSource(new StringGeneratingSourceFunction()).addSink(new DiscardingSink<>());
+        JobGraph jobGraph = StreamingJobGraphGenerator.createJobGraph(env.getStreamGraph());
+        try {
+            // assert that the job only execute checkpoint once and only failed once.
+            TestUtils.submitJobAndWaitForResult(
+                    cluster.getClusterClient(), jobGraph, getClass().getClassLoader());
+        } catch (JobExecutionException jobException) {
+            Optional<FlinkRuntimeException> throwable =
+                    ExceptionUtils.findThrowable(jobException, FlinkRuntimeException.class);
+            Assert.assertTrue(throwable.isPresent());
+            Assert.assertEquals(
+                    CheckpointFailureManager.EXCEEDED_CHECKPOINT_TOLERABLE_FAILURE_MESSAGE,
+                    throwable.get().getMessage());
+        }
+        // assert that the job only failed once.
+        Assert.assertEquals(1, StringGeneratingSourceFunction.INITIALIZE_TIMES.get());
+    }
+
+    private static class StringGeneratingSourceFunction extends RichParallelSourceFunction<String>
+            implements CheckpointedFunction {
+        private static final long serialVersionUID = 1L;
+        private static final ListStateDescriptor<Long> stateDescriptor =
+                new ListStateDescriptor<>("emitted", Long.class);
+
+        private final byte[] randomBytes = new byte[10];
+
+        private ListState<Long> listState;
+        private long emitted = 0L;
+
+        private volatile boolean isRunning = true;
+
+        public static final AtomicInteger INITIALIZE_TIMES = new AtomicInteger(0);
+
+        @Override
+        public void snapshotState(FunctionSnapshotContext context) throws Exception {
+            listState.clear();
+            listState.add(emitted);
+        }
+
+        @Override
+        public void initializeState(FunctionInitializationContext context) throws Exception {
+            listState = context.getOperatorStateStore().getListState(stateDescriptor);
+            INITIALIZE_TIMES.addAndGet(1);
+        }
+
+        @Override
+        public void run(SourceContext<String> ctx) throws Exception {
+            while (isRunning) {
+                ThreadLocalRandom.current().nextBytes(randomBytes);
+                synchronized (ctx.getCheckpointLock()) {
+                    ctx.collect(new String(randomBytes));
+                    emitted += 1;
+                }
+                Thread.sleep(10);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            isRunning = false;
+        }
+    }
+
+    private static class AsyncFailureStateBackend extends MemoryStateBackend {
+
+        private static final long serialVersionUID = 1L;
+
+        @Override
+        public OperatorStateBackend createOperatorStateBackend(
+                Environment env,
+                String operatorIdentifier,
+                @Nonnull Collection<OperatorStateHandle> stateHandles,
+                CloseableRegistry cancelStreamRegistry) {
+            return new DefaultOperatorStateBackendBuilder(
+                    env.getUserCodeClassLoader().asClassLoader(),
+                    env.getExecutionConfig(),
+                    true,
+                    stateHandles,
+                    cancelStreamRegistry) {
+                @Override
+                @SuppressWarnings("unchecked")
+                public DefaultOperatorStateBackend build() {
+                    return new DefaultOperatorStateBackend(
+                            executionConfig,
+                            cancelStreamRegistry,
+                            new HashMap<>(),
+                            new HashMap<>(),
+                            new HashMap<>(),
+                            new HashMap<>(),
+                            mock(AbstractSnapshotStrategy.class)) {
+                        @Nonnull
+                        @Override
+                        public RunnableFuture<SnapshotResult<OperatorStateHandle>> snapshot(
+                                long checkpointId,
+                                long timestamp,
+                                @Nonnull CheckpointStreamFactory streamFactory,
+                                @Nonnull CheckpointOptions checkpointOptions) {
+
+                            return new FutureTask<>(
+                                    () -> {
+                                        throw new Exception("Expected async snapshot exception.");
+                                    });
+                        }
+                    };
+                }
+            }.build();
+        }
+
+        @Override
+        public AsyncFailureStateBackend configure(ReadableConfig config, ClassLoader classLoader) {
+            return this;
+        }
+    }
+}
