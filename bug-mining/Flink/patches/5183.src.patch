diff --git a/flink-core/src/main/java/org/apache/flink/api/common/time/Deadline.java b/flink-core/src/main/java/org/apache/flink/api/common/time/Deadline.java
index 16721b6d406..641a46bcdfb 100644
--- a/flink-core/src/main/java/org/apache/flink/api/common/time/Deadline.java
+++ b/flink-core/src/main/java/org/apache/flink/api/common/time/Deadline.java
@@ -23,6 +23,7 @@ import org.apache.flink.util.clock.Clock;
 import org.apache.flink.util.clock.SystemClock;
 
 import java.time.Duration;
+import java.time.LocalDateTime;
 import java.util.concurrent.TimeoutException;
 
 /** This class stores a deadline, as obtained via {@link #now()} or from {@link #plus(Duration)}. */
@@ -104,4 +105,9 @@ public class Deadline {
     public static Deadline fromNowWithClock(Duration duration, Clock clock) {
         return new Deadline(Math.addExact(clock.relativeTimeNanos(), duration.toNanos()), clock);
     }
+
+    @Override
+    public String toString() {
+        return LocalDateTime.now().plus(timeLeft()).toString();
+    }
 }
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
index 4a927fc7793..9cfb4c74b71 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
@@ -206,7 +206,11 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
         final int parallelism = env.getParallelism();
         final SingleOutputStreamOperator<Long> stream =
                 env.fromSource(
-                                new LongSource(minCheckpoints, parallelism, expectedRestarts),
+                                new LongSource(
+                                        minCheckpoints,
+                                        parallelism,
+                                        expectedRestarts,
+                                        env.getCheckpointInterval()),
                                 noWatermarks(),
                                 "source")
                         .slotSharingGroup(slotSharing ? "default" : "source")
@@ -232,7 +236,11 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
         for (int inputIndex = 0; inputIndex < NUM_SOURCES; inputIndex++) {
             final SingleOutputStreamOperator<Long> source =
                     env.fromSource(
-                                    new LongSource(minCheckpoints, parallelism, expectedRestarts),
+                                    new LongSource(
+                                            minCheckpoints,
+                                            parallelism,
+                                            expectedRestarts,
+                                            env.getCheckpointInterval()),
                                     noWatermarks(),
                                     "source" + inputIndex)
                             .slotSharingGroup(slotSharing ? "default" : ("source" + inputIndex))
@@ -262,7 +270,11 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
         for (int inputIndex = 0; inputIndex < NUM_SOURCES; inputIndex++) {
             final SingleOutputStreamOperator<Long> source =
                     env.fromSource(
-                                    new LongSource(minCheckpoints, parallelism, expectedRestarts),
+                                    new LongSource(
+                                            minCheckpoints,
+                                            parallelism,
+                                            expectedRestarts,
+                                            env.getCheckpointInterval()),
                                     noWatermarks(),
                                     "source" + inputIndex)
                             .slotSharingGroup(slotSharing ? "default" : ("source" + inputIndex))
@@ -301,7 +313,10 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
                 .uid("failing-map")
                 .slotSharingGroup(slotSharing ? "default" : "map")
                 .partitionCustom(new ChunkDistributingPartitioner(), l -> l)
-                .addSink(new StrictOrderVerifyingSink(minCheckpoints))
+                .addSink(
+                        new StrictOrderVerifyingSink(
+                                minCheckpoints,
+                                combinedSource.getExecutionEnvironment().getCheckpointInterval()))
                 .name("sink")
                 .uid("sink")
                 .slotSharingGroup(slotSharing ? "default" : "sink");
@@ -316,8 +331,8 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
         private boolean firstDuplicate = true;
         private boolean firstLostValue = true;
 
-        protected StrictOrderVerifyingSink(long minCheckpoints) {
-            super(minCheckpoints);
+        protected StrictOrderVerifyingSink(long minCheckpoints, long checkpointingInterval) {
+            super(minCheckpoints, checkpointingInterval);
         }
 
         @Override
@@ -376,12 +391,7 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
             state.lastRecordInPartitions[partition] = value;
             state.numOutput++;
 
-            if (backpressure) {
-                // induce backpressure until enough checkpoints have been written
-                Thread.sleep(1);
-            }
-            // after all checkpoints have been completed, the remaining data should be flushed out
-            // fairly quickly
+            induceBackpressure();
         }
 
         static class State extends VerifyingSinkStateBase {
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointRescaleITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointRescaleITCase.java
index 1716eaec8a7..e8dff421e0e 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointRescaleITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointRescaleITCase.java
@@ -200,7 +200,12 @@ public class UnalignedCheckpointRescaleITCase extends UnalignedCheckpointTestBas
                     .uid("failing-map")
                     .slotSharingGroup(slotSharing ? "default" : "failing-map")
                     .shuffle()
-                    .addSink(new VerifyingSink(minCheckpoints))
+                    .addSink(
+                            new VerifyingSink(
+                                    minCheckpoints,
+                                    combinedSource
+                                            .getExecutionEnvironment()
+                                            .getCheckpointInterval()))
                     .setParallelism(1)
                     .name("sink")
                     .uid("sink")
@@ -216,9 +221,14 @@ public class UnalignedCheckpointRescaleITCase extends UnalignedCheckpointTestBas
                 int inputIndex,
                 FilterFunction<Long> sourceFilter) {
             return env.fromSource(
-                            new LongSource(minCheckpoints, parallelism, expectedRestarts),
+                            new LongSource(
+                                    minCheckpoints,
+                                    parallelism,
+                                    expectedRestarts,
+                                    env.getCheckpointInterval()),
                             noWatermarks(),
                             "source" + inputIndex)
+                    .uid("source" + inputIndex)
                     .slotSharingGroup(slotSharing ? "default" : ("source" + inputIndex))
                     .filter(sourceFilter)
                     .name("input-filter" + inputIndex)
@@ -336,8 +346,8 @@ public class UnalignedCheckpointRescaleITCase extends UnalignedCheckpointTestBas
     protected static class VerifyingSink extends VerifyingSinkBase<VerifyingSink.State> {
         private boolean firstDuplicate = true;
 
-        protected VerifyingSink(long minCheckpoints) {
-            super(minCheckpoints);
+        protected VerifyingSink(long minCheckpoints, long checkpointingInterval) {
+            super(minCheckpoints, checkpointingInterval);
         }
 
         @Override
@@ -362,12 +372,7 @@ public class UnalignedCheckpointRescaleITCase extends UnalignedCheckpointTestBas
             state.encounteredNumbers.set(intValue);
             state.numOutput++;
 
-            if (backpressure) {
-                // induce heavy backpressure until enough checkpoints have been written
-                Thread.sleep(1);
-            }
-            // after all checkpoints have been completed, the remaining data should be flushed out
-            // fairly quickly
+            induceBackpressure();
         }
 
         @Override
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
index d5825d1947a..9a8529b9150 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
@@ -191,11 +191,17 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
         private final int minCheckpoints;
         private final int numSplits;
         private final int expectedRestarts;
+        private final long checkpointingInterval;
 
-        protected LongSource(int minCheckpoints, int numSplits, int expectedRestarts) {
+        protected LongSource(
+                int minCheckpoints,
+                int numSplits,
+                int expectedRestarts,
+                long checkpointingInterval) {
             this.minCheckpoints = minCheckpoints;
             this.numSplits = numSplits;
             this.expectedRestarts = expectedRestarts;
+            this.checkpointingInterval = checkpointingInterval;
         }
 
         @Override
@@ -206,7 +212,10 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
         @Override
         public SourceReader<Long, LongSplit> createReader(SourceReaderContext readerContext) {
             return new LongSourceReader(
-                    readerContext.getIndexOfSubtask(), minCheckpoints, expectedRestarts);
+                    readerContext.getIndexOfSubtask(),
+                    minCheckpoints,
+                    expectedRestarts,
+                    checkpointingInterval);
         }
 
         @Override
@@ -241,22 +250,23 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
             private final int expectedRestarts;
             private final LongCounter numInputsCounter = new LongCounter();
             private final List<LongSplit> splits = new ArrayList<>();
+            private final Duration pumpInterval;
             private int numAbortedCheckpoints;
             private int numRestarts;
             private int numCompletedCheckpoints;
-            private int numCheckpointsInThisAttempt;
-            private PollingState pollingState = PollingState.THROTTLING;
-
-            enum PollingState {
-                THROTTLING,
-                PUMPING,
-                FINISHING
-            }
-
-            public LongSourceReader(int subtaskIndex, int minCheckpoints, int expectedRestarts) {
+            private boolean finishing;
+            private boolean recovered;
+            @Nullable private Deadline pumpingUntil = null;
+
+            public LongSourceReader(
+                    int subtaskIndex,
+                    int minCheckpoints,
+                    int expectedRestarts,
+                    long checkpointingInterval) {
                 this.subtaskIndex = subtaskIndex;
                 this.minCheckpoints = minCheckpoints;
                 this.expectedRestarts = expectedRestarts;
+                pumpInterval = Duration.ofMillis(checkpointingInterval);
             }
 
             @Override
@@ -269,19 +279,17 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                     split.nextNumber += split.increment;
                 }
 
-                switch (pollingState) {
-                    case FINISHING:
-                        return InputStatus.END_OF_INPUT;
-                    case THROTTLING:
-                        // throttle source as long as sink is not backpressuring (which it does only
-                        // after full recovery)
-                        Thread.sleep(1);
-                        return InputStatus.MORE_AVAILABLE;
-                    case PUMPING:
-                        return InputStatus.MORE_AVAILABLE;
-                    default:
-                        throw new IllegalStateException("Unexpected state: " + pollingState);
+                if (finishing) {
+                    return InputStatus.END_OF_INPUT;
+                }
+
+                if (pumpingUntil != null && pumpingUntil.isOverdue()) {
+                    pumpingUntil = null;
                 }
+                if (pumpingUntil == null) {
+                    Thread.sleep(1);
+                }
+                return InputStatus.MORE_AVAILABLE;
             }
 
             @Override
@@ -291,6 +299,8 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                         splits,
                         subtaskIndex,
                         numRestarts);
+                // barrier passed, so no need to add more data for this test
+                pumpingUntil = null;
                 return splits;
             }
 
@@ -308,7 +318,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                 // new checkpoint).
                 updatePollingState();
                 numCompletedCheckpoints++;
-                numCheckpointsInThisAttempt++;
+                recovered = true;
                 numAbortedCheckpoints = 0;
             }
 
@@ -320,8 +330,8 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                     // here simply also advance completed checkpoints to avoid running into a live
                     // lock
                     numCompletedCheckpoints = minCheckpoints + 1;
-                    updatePollingState();
                 }
+                updatePollingState();
             }
 
             @Override
@@ -334,9 +344,10 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                 this.splits.addAll(splits);
                 updatePollingState();
                 LOG.info(
-                        "Added splits {}, pollingState={} @ {} subtask ({} attempt)",
+                        "Added splits {}, finishing={}, pumping until {} @ {} subtask ({} attempt)",
                         splits,
-                        pollingState,
+                        finishing,
+                        pumpingUntil,
                         subtaskIndex,
                         numRestarts);
             }
@@ -347,22 +358,16 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
             }
 
             private void updatePollingState() {
-                PollingState oldState = pollingState;
                 if (numCompletedCheckpoints >= minCheckpoints && numRestarts >= expectedRestarts) {
-                    pollingState = PollingState.FINISHING;
-                } else if (numCheckpointsInThisAttempt == 0) {
-                    // speed up recovery by throttling - use a successful checkpoint as a proxy
-                    // for a finished recovery
-                    pollingState = PollingState.THROTTLING;
-                } else {
-                    // cause backpressure
-                    pollingState = PollingState.PUMPING;
-                }
-                if (oldState != pollingState) {
+                    finishing = true;
+                    LOG.info("Finishing @ {} subtask ({} attempt)", subtaskIndex, numRestarts);
+                } else if (recovered) {
+                    // a successful checkpoint as a proxy for a finished recovery
+                    // cause backpressure until next checkpoint is added
+                    pumpingUntil = Deadline.fromNow(pumpInterval);
                     LOG.info(
-                            "Switched from {} to {} @ {} subtask ({} attempt)",
-                            oldState,
-                            pollingState,
+                            "Pumping until {} @ {} subtask ({} attempt)",
+                            pumpingUntil,
                             subtaskIndex,
                             numRestarts);
                 }
@@ -373,14 +378,13 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                 if (sourceEvent instanceof SyncEvent) {
                     numRestarts = ((SyncEvent) sourceEvent).numRestarts;
                     numCompletedCheckpoints = ((SyncEvent) sourceEvent).numCheckpoints;
-                    updatePollingState();
                     LOG.info(
-                            "Set restarts={}, numCompletedCheckpoints={}, pollingState={} @ {} subtask ({} attempt)",
+                            "Set restarts={}, numCompletedCheckpoints={} @ {} subtask ({} attempt)",
                             numRestarts,
                             numCompletedCheckpoints,
-                            pollingState,
                             subtaskIndex,
                             numRestarts);
+                    updatePollingState();
                 }
             }
 
@@ -687,7 +691,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 
             final LocalStreamEnvironment env =
                     StreamExecutionEnvironment.createLocalEnvironment(parallelism, conf);
-            env.enableCheckpointing(100);
+            env.enableCheckpointing(Math.max(100L, parallelism * 50L));
             env.getCheckpointConfig().setAlignmentTimeout(alignmentTimeout);
             env.setParallelism(parallelism);
             env.setRestartStrategy(
@@ -879,13 +883,16 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
         private final LongCounter lostCounter = new LongCounter();
         private final LongCounter duplicatesCounter = new LongCounter();
         private final IntCounter numFailures = new IntCounter();
+        private final Duration backpressureInterval;
         private ListState<State> stateList;
         protected transient State state;
         protected final long minCheckpoints;
-        protected boolean backpressure;
+        private boolean recovered;
+        @Nullable private Deadline backpressureUntil;
 
-        protected VerifyingSinkBase(long minCheckpoints) {
+        protected VerifyingSinkBase(long minCheckpoints, long checkpointingInterval) {
             this.minCheckpoints = minCheckpoints;
+            this.backpressureInterval = Duration.ofMillis(checkpointingInterval);
         }
 
         @Override
@@ -907,30 +914,50 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                                     new ListStateDescriptor<>(
                                             "state", (Class<State>) state.getClass()));
             this.state = getOnlyElement(stateList.get(), state);
-            backpressure = false;
             LOG.info(
-                    "Inducing backpressure=false @ {} subtask ({} attempt)",
+                    "Inducing no backpressure @ {} subtask ({} attempt)",
                     getRuntimeContext().getIndexOfThisSubtask(),
                     getRuntimeContext().getAttemptNumber());
         }
 
         protected abstract State createState();
 
+        protected void induceBackpressure() throws InterruptedException {
+            if (backpressureUntil != null) {
+                // induce heavy backpressure until enough checkpoints have been written
+                Thread.sleep(1);
+                if (backpressureUntil.isOverdue()) {
+                    backpressureUntil = null;
+                }
+            }
+            // after all checkpoints have been completed, the remaining data should be flushed out
+            // fairly quickly
+        }
+
         @Override
         public void snapshotState(FunctionSnapshotContext context) throws Exception {
             stateList.clear();
             stateList.add(state);
+            if (recovered) {
+                backpressureUntil = Deadline.fromNow(backpressureInterval);
+            }
         }
 
         @Override
         public void notifyCheckpointComplete(long checkpointId) {
+            recovered = true;
             state.completedCheckpoints++;
-            boolean backpressure = this.backpressure;
-            this.backpressure = state.completedCheckpoints < minCheckpoints;
-            if (backpressure != this.backpressure) {
+            if (state.completedCheckpoints < minCheckpoints) {
+                this.backpressureUntil = Deadline.fromNow(backpressureInterval);
+                LOG.info(
+                        "Inducing backpressure until {} @ {} subtask ({} attempt)",
+                        backpressureUntil,
+                        getRuntimeContext().getIndexOfThisSubtask(),
+                        getRuntimeContext().getAttemptNumber());
+            } else {
+                this.backpressureUntil = null;
                 LOG.info(
-                        "Inducing backpressure={} @ {} subtask ({} attempt)",
-                        this.backpressure,
+                        "Inducing no backpressure @ {} subtask ({} attempt)",
                         getRuntimeContext().getIndexOfThisSubtask(),
                         getRuntimeContext().getAttemptNumber());
             }
