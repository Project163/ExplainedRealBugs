diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/catalog/SqlCatalogViewTable.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/catalog/SqlCatalogViewTable.java
index 890564ac73a..a9f56e1f79a 100644
--- a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/catalog/SqlCatalogViewTable.java
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/catalog/SqlCatalogViewTable.java
@@ -21,6 +21,7 @@ package org.apache.flink.table.planner.catalog;
 import org.apache.flink.table.catalog.CatalogView;
 import org.apache.flink.table.planner.plan.schema.ExpandingPreparingTable;
 import org.apache.flink.table.planner.plan.stats.FlinkStatistic;
+import org.apache.flink.table.planner.plan.utils.RelOptUtils;
 
 import org.apache.calcite.plan.RelOptSchema;
 import org.apache.calcite.rel.RelNode;
@@ -53,6 +54,9 @@ public class SqlCatalogViewTable extends ExpandingPreparingTable {
 
 	@Override
 	public RelNode convertToRel(ToRelContext context) {
-		return context.expandView(rowType, view.getExpandedQuery(), viewPath, names).project();
+		RelNode original = context
+				.expandView(rowType, view.getExpandedQuery(), viewPath, names)
+				.project();
+		return RelOptUtils.createCastRel(original, rowType);
 	}
 }
diff --git a/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/utils/RelOptUtils.java b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/utils/RelOptUtils.java
new file mode 100644
index 00000000000..d3dfb3ecccb
--- /dev/null
+++ b/flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/utils/RelOptUtils.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.table.planner.plan.utils;
+
+import org.apache.calcite.plan.RelOptUtil;
+import org.apache.calcite.rel.RelNode;
+import org.apache.calcite.rel.core.Project;
+import org.apache.calcite.rel.core.RelFactories;
+import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rel.type.RelDataTypeField;
+import org.apache.calcite.rex.RexBuilder;
+import org.apache.calcite.rex.RexNode;
+import org.apache.calcite.rex.RexUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * <code>RelOptUtils</code> defines static utility methods for use in optimizing
+ * {@link RelNode}s.
+ *
+ * <p>This is an extension of {@link org.apache.calcite.plan.RelOptUtil}.
+ */
+public class RelOptUtils {
+	/**
+	 * Creates a projection which casts a rel's output to a desired row type.
+	 *
+	 * <p>This method is inspired by {@link RelOptUtil#createCastRel}, different with that,
+	 * we do not generate another {@link Project} if the {@code rel} is already a {@link Project}.
+	 *
+	 * @param rel Producer of rows to be converted
+	 * @param castRowType Row type after cast
+	 * @return Conversion rel with castRowType
+	 */
+	public static RelNode createCastRel(RelNode rel, RelDataType castRowType) {
+		RelFactories.ProjectFactory projectFactory = RelFactories.DEFAULT_PROJECT_FACTORY;
+		final RelDataType oriRowType = rel.getRowType();
+		if (RelOptUtil.areRowTypesEqual(oriRowType, castRowType, true)) {
+			// nothing to do
+			return rel;
+		}
+		final RexBuilder rexBuilder = rel.getCluster().getRexBuilder();
+
+		final List<RelDataTypeField> fieldList = oriRowType.getFieldList();
+		int n = fieldList.size();
+		assert n == castRowType.getFieldCount()
+			: "field count: lhs [" + castRowType + "] rhs [" + oriRowType + "]";
+
+		final List<RexNode> rhsExps;
+		final RelNode input;
+		if (rel instanceof Project) {
+			rhsExps = ((Project) rel).getProjects();
+			// Avoid to generate redundant project node.
+			input = rel.getInput(0);
+		} else {
+			rhsExps = new ArrayList<>();
+			for (RelDataTypeField field : fieldList) {
+				rhsExps.add(rexBuilder.makeInputRef(field.getType(), field.getIndex()));
+			}
+			input = rel;
+		}
+
+		final List<RexNode> castExps =
+				RexUtil.generateCastExpressions(rexBuilder, castRowType, rhsExps);
+		// Use names and types from castRowType.
+		return projectFactory.createProject(input, castExps,
+				castRowType.getFieldNames());
+	}
+}
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkPlannerImpl.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkPlannerImpl.scala
index 001b9fda7f8..cb2e390524f 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkPlannerImpl.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/calcite/FlinkPlannerImpl.scala
@@ -30,7 +30,7 @@ import org.apache.calcite.rel.{RelFieldCollation, RelRoot}
 import org.apache.calcite.sql.advise.{SqlAdvisor, SqlAdvisorValidator}
 import org.apache.calcite.sql.{SqlKind, SqlNode, SqlOperatorTable}
 import org.apache.calcite.sql2rel.{SqlRexConvertletTable, SqlToRelConverter}
-import org.apache.calcite.tools.{FrameworkConfig, RelBuilder, RelConversionException}
+import org.apache.calcite.tools.{FrameworkConfig, RelConversionException}
 
 import java.lang.{Boolean => JBoolean}
 import java.util
@@ -185,19 +185,7 @@ class FlinkPlannerImpl(
     )
     val validator = createSqlValidator(readerWithPathAdjusted)
     val validated = validate(parsed, validator)
-    val equivRel = rel(validated, validator)
-    if (!RelOptUtil.areRowTypesEqual(
-      rowType,
-      equivRel.validatedRowType,
-      true
-    )) {
-      throw new TableException(
-        s"""Could not expand view. Types mismatch.
-           | Expected row type: $rowType
-           | Expanded view type: ${equivRel.validatedRowType}
-           |""".stripMargin)
-    }
-    equivRel
+    rel(validated, validator)
   }
 
   override def createRelBuilder(): FlinkRelBuilder = {
diff --git a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRelOptUtil.scala b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRelOptUtil.scala
index c8086ecd4c3..2a05b74af66 100644
--- a/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRelOptUtil.scala
+++ b/flink-table/flink-table-planner-blink/src/main/scala/org/apache/flink/table/planner/plan/utils/FlinkRelOptUtil.scala
@@ -494,5 +494,4 @@ object FlinkRelOptUtil {
         }
     }
   }
-
 }
diff --git a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.xml b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.xml
index b86055971bc..cbe66fd8e46 100644
--- a/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.xml
+++ b/flink-table/flink-table-planner-blink/src/test/resources/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.xml
@@ -120,4 +120,45 @@ DataStreamScan(table=[[default_catalog, default_database, t1]], fields=[a, b, c]
 
     </Resource>
   </TestCase>
+  <TestCase name="testViewExpandingWithMismatchRowType[0]">
+    <Resource name="sql">
+      <![CDATA[select * from view1]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[CAST($0):INTEGER NOT NULL], b=[$1], c=[CAST($2):INTEGER])
++- LogicalAggregate(group=[{0, 1}], EXPR$2=[COUNT($2)])
+   +- LogicalTableScan(table=[[default_catalog, default_database, t1]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[CAST(a) AS a, b, CAST(EXPR$2) AS c])
++- HashAggregate(isMerge=[true], groupBy=[a, b], select=[a, b, Final_COUNT(count$0) AS EXPR$2])
+   +- Exchange(distribution=[hash[a, b]])
+      +- LocalHashAggregate(groupBy=[a, b], select=[a, b, Partial_COUNT(c) AS count$0])
+         +- BoundedStreamScan(table=[[default_catalog, default_database, t1]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
+  <TestCase name="testViewExpandingWithMismatchRowType[1]">
+    <Resource name="sql">
+      <![CDATA[select * from view1]]>
+    </Resource>
+    <Resource name="planBefore">
+      <![CDATA[
+LogicalProject(a=[CAST($0):INTEGER NOT NULL], b=[$1], c=[CAST($2):INTEGER])
++- LogicalAggregate(group=[{0, 1}], EXPR$2=[COUNT($2)])
+   +- LogicalTableScan(table=[[default_catalog, default_database, t1]])
+]]>
+    </Resource>
+    <Resource name="planAfter">
+      <![CDATA[
+Calc(select=[CAST(a) AS a, b, CAST(EXPR$2) AS c])
++- GroupAggregate(groupBy=[a, b], select=[a, b, COUNT(c) AS EXPR$2])
+   +- Exchange(distribution=[hash[a, b]])
+      +- DataStreamScan(table=[[default_catalog, default_database, t1]], fields=[a, b, c])
+]]>
+    </Resource>
+  </TestCase>
 </Root>
diff --git a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.scala b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.scala
index aab3d712fa3..efed57a949c 100644
--- a/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.scala
+++ b/flink-table/flink-table-planner-blink/src/test/scala/org/apache/flink/table/planner/plan/common/ViewsExpandingTest.scala
@@ -91,6 +91,31 @@ class ViewsExpandingTest(tableTestUtil: TableTestBase => TableTestUtil) extends
     tableUtil.verifyPlan(query)
   }
 
+  @Test
+  def testViewExpandingWithMismatchRowType(): Unit = {
+    val tableUtil = tableTestUtil(this)
+    val tableEnv = tableUtil.tableEnv
+    val originTableName = "t1"
+    tableUtil.addDataStream[(Int, String, Int)](originTableName, 'a, 'b, 'c)
+    val aggSqlView = new CatalogViewImpl(
+      s"select a, b, count(c) from $originTableName group by a, b",
+      s"select a, b, count(c) from $originTableName group by a, b",
+      TableSchema.builder()
+        .field("a", DataTypes.INT().notNull()) // Change the nullability intentionally.
+        .field("b", DataTypes.STRING())
+        .field("c", DataTypes.INT())
+        .build(),
+      new util.HashMap[String, String](),
+      ""
+    )
+    val catalog = tableEnv.getCatalog(tableEnv.getCurrentCatalog).get()
+    catalog.createTable(
+      new ObjectPath(tableEnv.getCurrentDatabase, "view1"),
+      aggSqlView,
+      false)
+    tableUtil.verifyPlan("select * from view1")
+  }
+
   private def createSqlView(originTable: String): CatalogView = {
       new CatalogViewImpl(
         s"select * as c from $originTable",
