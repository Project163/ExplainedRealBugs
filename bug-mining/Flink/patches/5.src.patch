diff --git a/stratosphere-addons/avro/src/test/java/eu/stratosphere/api/avro/AvroOutputFormatTest.java b/stratosphere-addons/avro/src/test/java/eu/stratosphere/api/avro/AvroOutputFormatTest.java
index b0e4b6e5d8e..20610a29d1b 100644
--- a/stratosphere-addons/avro/src/test/java/eu/stratosphere/api/avro/AvroOutputFormatTest.java
+++ b/stratosphere-addons/avro/src/test/java/eu/stratosphere/api/avro/AvroOutputFormatTest.java
@@ -32,6 +32,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 
+@SuppressWarnings("serial")
 public class AvroOutputFormatTest extends JavaProgramTestBase {
 
 	public static String outputPath1;
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/BulkIterationNode.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/BulkIterationNode.java
index b60f427451e..f6720ea2ed2 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/BulkIterationNode.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/BulkIterationNode.java
@@ -13,12 +13,14 @@
 
 package eu.stratosphere.compiler.dag;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 import eu.stratosphere.api.common.operators.base.BulkIterationBase;
+import eu.stratosphere.api.common.operators.util.FieldList;
 import eu.stratosphere.compiler.CompilerException;
 import eu.stratosphere.compiler.DataStatistics;
 import eu.stratosphere.compiler.PactCompiler.InterestingPropertyVisitor;
@@ -36,6 +38,9 @@ import eu.stratosphere.compiler.plan.BulkPartialSolutionPlanNode;
 import eu.stratosphere.compiler.plan.Channel;
 import eu.stratosphere.compiler.plan.NamedChannel;
 import eu.stratosphere.compiler.plan.PlanNode;
+import eu.stratosphere.compiler.plan.SingleInputPlanNode;
+import eu.stratosphere.compiler.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;
+import eu.stratosphere.pact.runtime.task.DriverStrategy;
 import eu.stratosphere.util.Visitor;
 
 /**
@@ -271,6 +276,9 @@ public class BulkIterationNode extends SingleInputNode implements IterationNode
 		// 1) Because we enumerate multiple times, we may need to clean the cached plans
 		//    before starting another enumeration
 		this.nextPartialSolution.accept(PlanCacheCleaner.INSTANCE);
+		if (this.terminationCriterion != null) {
+			this.terminationCriterion.accept(PlanCacheCleaner.INSTANCE);
+		}
 		
 		// 2) Give the partial solution the properties of the current candidate for the initial partial solution
 		this.partialSolution.setCandidateProperties(in.getGlobalProperties(), in.getLocalProperties(), in);
@@ -282,14 +290,51 @@ public class BulkIterationNode extends SingleInputNode implements IterationNode
 		// 4) Make sure that the beginning of the step function does not assume properties that 
 		//    are not also produced by the end of the step function.
 
-		for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {
-			PlanNode candidate = planDeleter.next();
+		{
+			List<PlanNode> newCandidates = new ArrayList<PlanNode>();
 			
-			// quick-check if the properties at the end of the step function are the same as at the beginning
-			if (candidate.getGlobalProperties().equals(pspn.getGlobalProperties()) && candidate.getLocalProperties().equals(pspn.getLocalProperties())) {
-				continue;
+			for (Iterator<PlanNode> planDeleter = candidates.iterator(); planDeleter.hasNext(); ) {
+				PlanNode candidate = planDeleter.next();
+				
+				GlobalProperties atEndGlobal = candidate.getGlobalProperties();
+				LocalProperties atEndLocal = candidate.getLocalProperties();
+				
+				FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobal, atEndLocal);
+				if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
+					; // depends only through broadcast variable on the partial solution
+				}
+				else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
+					// attach a no-op node through which we create the properties of the original input
+					Channel toNoOp = new Channel(candidate);
+					globPropsReq.parameterizeChannel(toNoOp, false, false);
+					locPropsReq.parameterizeChannel(toNoOp);
+					
+					UnaryOperatorNode rebuildPropertiesNode = new UnaryOperatorNode("Rebuild Partial Solution Properties", FieldList.EMPTY_LIST);
+					rebuildPropertiesNode.setDegreeOfParallelism(candidate.getDegreeOfParallelism());
+					rebuildPropertiesNode.setSubtasksPerInstance(candidate.getSubtasksPerInstance());
+					
+					SingleInputPlanNode rebuildPropertiesPlanNode = new SingleInputPlanNode(rebuildPropertiesNode, "Rebuild Partial Solution Properties", toNoOp, DriverStrategy.UNARY_NO_OP);
+					rebuildPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());
+					estimator.costOperator(rebuildPropertiesPlanNode);
+						
+					GlobalProperties atEndGlobalModified = rebuildPropertiesPlanNode.getGlobalProperties();
+					LocalProperties atEndLocalModified = rebuildPropertiesPlanNode.getLocalProperties();
+						
+					if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {
+						FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(pspn, atEndGlobalModified, atEndLocalModified);
+						
+						if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
+							newCandidates.add(rebuildPropertiesPlanNode);
+						}
+					}
+					
+					planDeleter.remove();
+				}
 			}
-			planDeleter.remove();
+		}
+		
+		if (candidates.isEmpty()) {
+			return;
 		}
 		
 		// 5) Create a candidate for the Iteration Node for every remaining plan of the step function.
@@ -302,13 +347,13 @@ public class BulkIterationNode extends SingleInputNode implements IterationNode
 				target.add(node);
 			}
 		}
-		else if(candidates.size() > 0) {
+		else if (candidates.size() > 0) {
 			List<PlanNode> terminationCriterionCandidates = this.terminationCriterion.getAlternativePlans(estimator);
 
 			SingleRootJoiner singleRoot = (SingleRootJoiner) this.singleRoot;
 			
 			for (PlanNode candidate : candidates) {
-				for(PlanNode terminationCandidate : terminationCriterionCandidates) {
+				for (PlanNode terminationCandidate : terminationCriterionCandidates) {
 					if (singleRoot.areBranchCompatible(candidate, terminationCandidate)) {
 						BulkIterationPlanNode node = new BulkIterationPlanNode(this, "BulkIteration ("+this.getPactContract().getName()+")", in, pspn, candidate, terminationCandidate);
 						GlobalProperties gProps = candidate.getGlobalProperties().clone();
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/DataSinkNode.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/DataSinkNode.java
index 15c7670b83c..fe823d2ff81 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/DataSinkNode.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/DataSinkNode.java
@@ -210,6 +210,8 @@ public class DataSinkNode extends OptimizerNode {
 					Channel c = new Channel(p);
 					gp.parameterizeChannel(c, globalDopChange, localDopChange);
 					lp.parameterizeChannel(c);
+					c.setRequiredLocalProps(lp);
+					c.setRequiredGlobalProps(gp);
 					
 					// no need to check whether the created properties meet what we need in case
 					// of ordering or global ordering, because the only interesting properties we have
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/SingleInputNode.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/SingleInputNode.java
index fd4b76a18a3..e1727f9e04b 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/SingleInputNode.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/SingleInputNode.java
@@ -312,6 +312,7 @@ public abstract class SingleInputNode extends OptimizerNode {
 					// requested properties
 					for (RequestedGlobalProperties rgps: allValidGlobals) {
 						if (rgps.isMetBy(c.getGlobalProperties())) {
+							c.setRequiredGlobalProps(rgps);
 							addLocalCandidates(c, broadcastPlanChannels, igps, outputPlans, estimator);
 							break;
 						}
@@ -365,6 +366,7 @@ public abstract class SingleInputNode extends OptimizerNode {
 			for (OperatorDescriptorSingle dps: getPossibleProperties()) {
 				for (RequestedLocalProperties ilps : dps.getPossibleLocalProperties()) {
 					if (ilps.isMetBy(in.getLocalProperties())) {
+						in.setRequiredLocalProps(ilps);
 						instantiateCandidate(dps, in, broadcastPlanChannels, target, estimator, rgps, ilp);
 						break outer;
 					}
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/TwoInputNode.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/TwoInputNode.java
index cccbeba6681..9898c8130c3 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/TwoInputNode.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/TwoInputNode.java
@@ -447,9 +447,13 @@ public abstract class TwoInputNode extends OptimizerNode {
 							if (gpp.getProperties1().isMetBy(c1.getGlobalProperties()) && 
 								gpp.getProperties2().isMetBy(c2.getGlobalProperties()) )
 							{
+								Channel c1Clone = c1.clone();
+								c1Clone.setRequiredGlobalProps(gpp.getProperties1());
+								c2.setRequiredGlobalProps(gpp.getProperties2());
+								
 								// we form a valid combination, so create the local candidates
 								// for this
-								addLocalCandidates(c1, c2, broadcastPlanChannels, igps1, igps2, outputPlans, allLocalPairs, estimator);
+								addLocalCandidates(c1Clone, c2, broadcastPlanChannels, igps1, igps2, outputPlans, allLocalPairs, estimator);
 								break;
 							}
 						}
@@ -495,7 +499,6 @@ public abstract class TwoInputNode extends OptimizerNode {
 				final Channel in2 = template2.clone();
 				ilp2.parameterizeChannel(in2);
 				
-				allPossibleLoop:
 				for (OperatorDescriptorDual dps: this.possibleProperties) {
 					for (LocalPropertiesPair lpp : dps.getPossibleLocalProperties()) {
 						if (lpp.getProperties1().isMetBy(in1.getLocalProperties()) &&
@@ -507,12 +510,16 @@ public abstract class TwoInputNode extends OptimizerNode {
 							if (dps.areCoFulfilled(lpp.getProperties1(), lpp.getProperties2(), 
 								in1.getLocalProperties(), in2.getLocalProperties()))
 							{
+								Channel in1Copy = in1.clone();
+								in1Copy.setRequiredLocalProps(lpp.getProperties1());
+								in2.setRequiredLocalProps(lpp.getProperties2());
+								
 								// all right, co compatible
-								instantiate(dps, in1, in2, broadcastPlanChannels, target, estimator, rgps1, rgps2, ilp1, ilp2);
-								break allPossibleLoop;
+								instantiate(dps, in1Copy, in2, broadcastPlanChannels, target, estimator, rgps1, rgps2, ilp1, ilp2);
+								break;
 							} else {
 								// meet, but not co-compatible
-								throw new CompilerException("Implements to adjust one side to the other!");
+//								throw new CompilerException("Implements to adjust one side to the other!");
 							}
 						}
 					}
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/WorksetIterationNode.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/WorksetIterationNode.java
index 76c4402104b..2c70794e821 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/WorksetIterationNode.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dag/WorksetIterationNode.java
@@ -41,6 +41,7 @@ import eu.stratosphere.compiler.plan.SingleInputPlanNode;
 import eu.stratosphere.compiler.plan.SolutionSetPlanNode;
 import eu.stratosphere.compiler.plan.WorksetIterationPlanNode;
 import eu.stratosphere.compiler.plan.WorksetPlanNode;
+import eu.stratosphere.compiler.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;
 import eu.stratosphere.compiler.util.NoOpBinaryUdfOp;
 import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
 import eu.stratosphere.pact.runtime.task.DriverStrategy;
@@ -279,7 +280,7 @@ public class WorksetIterationNode extends TwoInputNode implements IterationNode
 	@Override
 	protected void instantiate(OperatorDescriptorDual operator, Channel solutionSetIn, Channel worksetIn,
 			List<Set<? extends NamedChannel>> broadcastPlanChannels, List<PlanNode> target, CostEstimator estimator,
-			RequestedGlobalProperties globPropsReqSolutionSet,RequestedGlobalProperties globPropsReqWorkset,
+			RequestedGlobalProperties globPropsReqSolutionSet, RequestedGlobalProperties globPropsReqWorkset,
 			RequestedLocalProperties locPropsReqSolutionSet, RequestedLocalProperties locPropsReqWorkset)
 	{
 		// check for pipeline breaking using hash join with build on the solution set side
@@ -314,12 +315,54 @@ public class WorksetIterationNode extends TwoInputNode implements IterationNode
 		//    initial partial solution
 		
 		// Make sure that the workset candidates fulfill the input requirements
-		for (Iterator<PlanNode> planDeleter = worksetCandidates.iterator(); planDeleter.hasNext(); ) {
-			PlanNode candidate = planDeleter.next();
-			if (!(globPropsReqWorkset.isMetBy(candidate.getGlobalProperties()) && locPropsReqWorkset.isMetBy(candidate.getLocalProperties()))) {
-				planDeleter.remove();
+		{
+			List<PlanNode> newCandidates = new ArrayList<PlanNode>();
+			
+			for (Iterator<PlanNode> planDeleter = worksetCandidates.iterator(); planDeleter.hasNext(); ) {
+				PlanNode candidate = planDeleter.next();
+				
+				GlobalProperties atEndGlobal = candidate.getGlobalProperties();
+				LocalProperties atEndLocal = candidate.getLocalProperties();
+				
+				FeedbackPropertiesMeetRequirementsReport report = candidate.checkPartialSolutionPropertiesMet(wspn, atEndGlobal, atEndLocal);
+				if (report == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
+					; // depends only through broadcast variable on the workset solution
+				}
+				else if (report == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
+					// attach a no-op node through which we create the properties of the original input
+					Channel toNoOp = new Channel(candidate);
+					globPropsReqWorkset.parameterizeChannel(toNoOp, false, false);
+					locPropsReqWorkset.parameterizeChannel(toNoOp);
+					
+					UnaryOperatorNode rebuildWorksetPropertiesNode = new UnaryOperatorNode("Rebuild Workset Properties", FieldList.EMPTY_LIST);
+					
+					rebuildWorksetPropertiesNode.setDegreeOfParallelism(candidate.getDegreeOfParallelism());
+					rebuildWorksetPropertiesNode.setSubtasksPerInstance(candidate.getSubtasksPerInstance());
+					
+					SingleInputPlanNode rebuildWorksetPropertiesPlanNode = new SingleInputPlanNode(rebuildWorksetPropertiesNode, "Rebuild Workset Properties", toNoOp, DriverStrategy.UNARY_NO_OP);
+					rebuildWorksetPropertiesPlanNode.initProperties(toNoOp.getGlobalProperties(), toNoOp.getLocalProperties());
+					estimator.costOperator(rebuildWorksetPropertiesPlanNode);
+						
+					GlobalProperties atEndGlobalModified = rebuildWorksetPropertiesPlanNode.getGlobalProperties();
+					LocalProperties atEndLocalModified = rebuildWorksetPropertiesPlanNode.getLocalProperties();
+						
+					if (!(atEndGlobalModified.equals(atEndGlobal) && atEndLocalModified.equals(atEndLocal))) {
+						FeedbackPropertiesMeetRequirementsReport report2 = candidate.checkPartialSolutionPropertiesMet(wspn, atEndGlobalModified, atEndLocalModified);
+						
+						if (report2 != FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
+							newCandidates.add(rebuildWorksetPropertiesPlanNode);
+						}
+					}
+					
+					// remove the original operator and add the modified candidate
+					planDeleter.remove();
+					
+				}
 			}
+			
+			worksetCandidates.addAll(newCandidates);
 		}
+		
 		if (worksetCandidates.isEmpty()) {
 			return;
 		}
@@ -342,7 +385,7 @@ public class WorksetIterationNode extends TwoInputNode implements IterationNode
 		gp.setHashPartitioned(this.solutionSetKeyFields);
 		gp.addUniqueFieldCombination(this.solutionSetKeyFields);
 		
-		LocalProperties lp = LocalProperties.TRIVIAL.addUniqueFields(this.solutionSetKeyFields);
+		LocalProperties lp = LocalProperties.EMPTY.addUniqueFields(this.solutionSetKeyFields);
 		
 		// take all combinations of solution set delta and workset plans
 		for (PlanNode solutionSetCandidate : solutionSetDeltaCandidates) {
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/LocalProperties.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/LocalProperties.java
index b45e3415ecd..f49c1300a6b 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/LocalProperties.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/LocalProperties.java
@@ -27,7 +27,7 @@ import eu.stratosphere.compiler.dag.OptimizerNode;
  */
 public class LocalProperties implements Cloneable {
 	
-	public static final LocalProperties TRIVIAL = new LocalProperties();
+	public static final LocalProperties EMPTY = new LocalProperties();
 	
 	// --------------------------------------------------------------------------------------------
 	
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedGlobalProperties.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedGlobalProperties.java
index 3935f5ede36..574922a759f 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedGlobalProperties.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedGlobalProperties.java
@@ -229,8 +229,6 @@ public final class RequestedGlobalProperties implements Cloneable {
 		final GlobalProperties inGlobals = channel.getSource().getGlobalProperties();
 		// if we have no global parallelism change, check if we have already compatible global properties
 		if (!globalDopChange && !localDopChange && isMetBy(inGlobals)) {
-			channel.setRequiredGlobalProps(this);
-			
 			// we meet already everything, so go forward
 			channel.setShipStrategy(ShipStrategyType.FORWARD);
 			return;
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedLocalProperties.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedLocalProperties.java
index e714cea14f3..aeae0d2f8f2 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedLocalProperties.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/dataproperties/RequestedLocalProperties.java
@@ -33,9 +33,9 @@ public class RequestedLocalProperties implements Cloneable {
 	
 	// --------------------------------------------------------------------------------------------
 	
-	Ordering ordering;			// order inside a partition, null if not ordered
+	private Ordering ordering;			// order inside a partition, null if not ordered
 
-	FieldSet groupedFields;		// fields by which the stream is grouped. null if not grouped.
+	private FieldSet groupedFields;		// fields by which the stream is grouped. null if not grouped.
 
 	// --------------------------------------------------------------------------------------------
 	
@@ -190,8 +190,8 @@ public class RequestedLocalProperties implements Cloneable {
 		LocalProperties current = channel.getLocalProperties();
 		
 		if (isMetBy(current)) {
-			// we are met. record that this is needed.
-			channel.setRequiredLocalProps(this);
+			// we are met, all is good
+			channel.setLocalStrategy(LocalStrategy.NONE);
 		}
 		else if (this.ordering != null) {
 			channel.setLocalStrategy(LocalStrategy.SORT, this.ordering.getInvolvedIndexes(), this.ordering.getFieldSortDirections());
diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/plan/PlanNode.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/plan/PlanNode.java
index 16241e49b6c..69263bcfd9a 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/plan/PlanNode.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/plan/PlanNode.java
@@ -29,7 +29,9 @@ import eu.stratosphere.compiler.dataproperties.GlobalProperties;
 import eu.stratosphere.compiler.dataproperties.LocalProperties;
 import eu.stratosphere.compiler.plandump.DumpableConnection;
 import eu.stratosphere.compiler.plandump.DumpableNode;
+import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
 import eu.stratosphere.pact.runtime.task.DriverStrategy;
+import eu.stratosphere.pact.runtime.task.util.LocalStrategy;
 import eu.stratosphere.util.Visitable;
 
 /**
@@ -434,8 +436,85 @@ public abstract class PlanNode implements Visitable<PlanNode>, DumpableNode<Plan
 	
 	// --------------------------------------------------------------------------------------------
 	
+	/**
+	 * Checks whether this node has a dam on the way down to the given source node. This method
+	 * returns either that (a) the source node is not found as a (transitive) child of this node,
+	 * (b) the node is found, but no dam is on the path, or (c) the node is found and a dam is on
+	 * the path.
+	 * 
+	 * @param source The node on the path to which the dam is sought.
+	 * @return The result whether the node is found and whether a dam is on the path.
+	 */
 	public abstract SourceAndDamReport hasDamOnPathDownTo(PlanNode source);
 	
+	public FeedbackPropertiesMeetRequirementsReport checkPartialSolutionPropertiesMet(PlanNode partialSolution, GlobalProperties feedbackGlobal, LocalProperties feedbackLocal) {
+		if (this == partialSolution) {
+			return FeedbackPropertiesMeetRequirementsReport.PENDING;
+		}
+		
+		boolean found = false;
+		boolean allMet = true;
+		boolean allLocallyMet = true;
+		
+		for (Channel input : getInputs()) {
+			FeedbackPropertiesMeetRequirementsReport inputState = input.getSource().checkPartialSolutionPropertiesMet(partialSolution, feedbackGlobal, feedbackLocal);
+			
+			if (inputState == FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION) {
+				continue;
+			}
+			else if (inputState == FeedbackPropertiesMeetRequirementsReport.MET) {
+				found = true;
+				continue;
+			}
+			else if (inputState == FeedbackPropertiesMeetRequirementsReport.NOT_MET) {
+				return FeedbackPropertiesMeetRequirementsReport.NOT_MET;
+			}
+			else {
+				found = true;
+				
+				// the partial solution was on the path here. check whether the channel requires
+				// certain properties that are met, or whether the channel introduces new properties
+				
+				// if the plan introduces new global properties, then we can stop looking whether
+				// the feedback properties are sufficient to meet the requirements
+				if (input.getShipStrategy() != ShipStrategyType.FORWARD && input.getShipStrategy() != ShipStrategyType.NONE) {
+					continue;
+				}
+				
+				// first check whether this channel requires something that is not met
+				if (input.getRequiredGlobalProps() != null && !input.getRequiredGlobalProps().isMetBy(feedbackGlobal)) {
+					return FeedbackPropertiesMeetRequirementsReport.NOT_MET;
+				}
+				
+				// in general, not everything is met here already
+				allMet = false;
+				
+				// if the plan introduces new local properties, we can stop checking for matching local properties
+				if (inputState != FeedbackPropertiesMeetRequirementsReport.PENDING_LOCAL_MET) {
+					
+					if (input.getLocalStrategy() == LocalStrategy.NONE) {
+						
+						if (input.getRequiredLocalProps() != null && !input.getRequiredLocalProps().isMetBy(feedbackLocal)) {
+							return FeedbackPropertiesMeetRequirementsReport.NOT_MET;
+						}
+						
+						allLocallyMet = false;
+					}
+				}
+			}
+		}
+		
+		if (!found) {
+			return FeedbackPropertiesMeetRequirementsReport.NO_PARTIAL_SOLUTION;
+		} else if (allMet) {
+			return FeedbackPropertiesMeetRequirementsReport.MET;
+		} else if (allLocallyMet) {
+			return FeedbackPropertiesMeetRequirementsReport.PENDING_LOCAL_MET;
+		} else {
+			return FeedbackPropertiesMeetRequirementsReport.PENDING;
+		}
+	}
+	
 	// --------------------------------------------------------------------------------------------
 	
 
@@ -447,19 +526,16 @@ public abstract class PlanNode implements Visitable<PlanNode>, DumpableNode<Plan
 	
 	// --------------------------------------------------------------------------------------------
 	
-
 	@Override
 	public OptimizerNode getOptimizerNode() {
 		return this.template;
 	}
 
-
 	@Override
 	public PlanNode getPlanNode() {
 		return this;
 	}
 
-
 	@Override
 	public Iterable<DumpableConnection<PlanNode>> getDumpableInputs() {
 		List<DumpableConnection<PlanNode>> allInputs = new ArrayList<DumpableConnection<PlanNode>>();
@@ -480,4 +556,25 @@ public abstract class PlanNode implements Visitable<PlanNode>, DumpableNode<Plan
 	public static enum SourceAndDamReport {
 		NOT_FOUND, FOUND_SOURCE, FOUND_SOURCE_AND_DAM;
 	}
+	
+	
+	
+	public static enum FeedbackPropertiesMeetRequirementsReport {
+		/** Indicates that the path is irrelevant */
+		NO_PARTIAL_SOLUTION,
+		
+		/** Indicates that the question whether the properties are met has been determined pending
+		 * dependent on global and local properties */
+		PENDING,
+		
+		/** Indicates that the question whether the properties are met has been determined pending
+		 * dependent on global properties only */
+		PENDING_LOCAL_MET,
+		
+		/** Indicates that the question whether the properties are met has been determined true */
+		MET,
+		
+		/** Indicates that the question whether the properties are met has been determined false */
+		NOT_MET;
+	}
 }
diff --git a/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/CoGroupSolutionSetFirstTest.java b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/CoGroupSolutionSetFirstTest.java
index c2b377eef7a..1c995583961 100644
--- a/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/CoGroupSolutionSetFirstTest.java
+++ b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/CoGroupSolutionSetFirstTest.java
@@ -76,7 +76,6 @@ public class CoGroupSolutionSetFirstTest extends CompilerTestBase {
 		oPlan.accept(new Visitor<PlanNode>() {
 			@Override
 			public boolean preVisit(PlanNode visitable) {
-				System.out.println(visitable);
 				if (visitable instanceof WorksetIterationPlanNode) {
 					PlanNode deltaNode = ((WorksetIterationPlanNode) visitable).getSolutionSetDeltaPlanNode();
 
diff --git a/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/FeedbackPropertiesMatchTest.java b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/FeedbackPropertiesMatchTest.java
new file mode 100644
index 00000000000..cdbea5b6025
--- /dev/null
+++ b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/FeedbackPropertiesMatchTest.java
@@ -0,0 +1,1432 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2010-2013 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+
+package eu.stratosphere.pact.compiler;
+
+import static org.junit.Assert.*;
+import static eu.stratosphere.compiler.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport.*;
+
+import org.junit.Test;
+
+import eu.stratosphere.api.common.functions.GenericJoiner;
+import eu.stratosphere.api.common.functions.GenericMap;
+import eu.stratosphere.api.common.operators.BinaryOperatorInformation;
+import eu.stratosphere.api.common.operators.OperatorInformation;
+import eu.stratosphere.api.common.operators.Order;
+import eu.stratosphere.api.common.operators.Ordering;
+import eu.stratosphere.api.common.operators.UnaryOperatorInformation;
+import eu.stratosphere.api.common.operators.base.GenericDataSourceBase;
+import eu.stratosphere.api.common.operators.base.JoinOperatorBase;
+import eu.stratosphere.api.common.operators.base.MapOperatorBase;
+import eu.stratosphere.api.common.operators.util.FieldList;
+import eu.stratosphere.api.common.operators.util.FieldSet;
+import eu.stratosphere.api.java.io.TextInputFormat;
+import eu.stratosphere.api.java.typeutils.BasicTypeInfo;
+import eu.stratosphere.compiler.dag.DataSourceNode;
+import eu.stratosphere.compiler.dag.MapNode;
+import eu.stratosphere.compiler.dag.MatchNode;
+import eu.stratosphere.compiler.dataproperties.GlobalProperties;
+import eu.stratosphere.compiler.dataproperties.LocalProperties;
+import eu.stratosphere.compiler.dataproperties.RequestedGlobalProperties;
+import eu.stratosphere.compiler.dataproperties.RequestedLocalProperties;
+import eu.stratosphere.compiler.plan.Channel;
+import eu.stratosphere.compiler.plan.DualInputPlanNode;
+import eu.stratosphere.compiler.plan.SingleInputPlanNode;
+import eu.stratosphere.compiler.plan.SourcePlanNode;
+import eu.stratosphere.compiler.plan.PlanNode.FeedbackPropertiesMeetRequirementsReport;
+import eu.stratosphere.core.fs.Path;
+import eu.stratosphere.pact.compiler.testfunctions.DummyJoinFunction;
+import eu.stratosphere.pact.compiler.testfunctions.IdentityMapper;
+import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
+import eu.stratosphere.pact.runtime.task.DriverStrategy;
+import eu.stratosphere.pact.runtime.task.util.LocalStrategy;
+
+
+public class FeedbackPropertiesMatchTest {
+
+	@Test
+	public void testNoPartialSolutionFoundSingleInputOnly() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Source");
+			
+			SourcePlanNode otherTarget = new SourcePlanNode(getSourceNode(), "Source");
+			
+			Channel toMap1 = new Channel(target);
+			toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap1.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(map1);
+			toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap2.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = new LocalProperties();
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(otherTarget, gp, lp);
+				assertTrue(report == NO_PARTIAL_SOLUTION);
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testSingleInputOperators() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Source");
+			
+			Channel toMap1 = new Channel(target);
+			toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap1.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(map1);
+			toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap2.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			// no feedback properties and none are ever required and present
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = new LocalProperties();
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some global feedback properties and none are ever required and present
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 5));
+				LocalProperties lp = new LocalProperties();
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some local feedback properties and none are ever required and present
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some global and local feedback properties and none are ever required and present
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 5));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// --------------------------- requirements on channel 1 -----------------------
+			
+			// some required global properties, which are matched exactly
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 5));
+				LocalProperties lp = new LocalProperties();
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required local properties, which are matched exactly
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1, 2));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global and local properties, which are matched exactly
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 5));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1, 2));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global and local properties, which are over-fulfilled
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global properties that are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 1));
+				LocalProperties lp = new LocalProperties();
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some required local properties that are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2, 1));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some required global and local properties where the global properties are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 1));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(2, 5));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some required global and local properties where the local properties are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(1));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// --------------------------- requirements on channel 2 -----------------------
+			
+			// some required global properties, which are matched exactly
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 5));
+				LocalProperties lp = new LocalProperties();
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required local properties, which are matched exactly
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1, 2));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global and local properties, which are matched exactly
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 5));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1, 2));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global and local properties, which are over-fulfilled
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1, 2));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global properties that are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 1));
+				LocalProperties lp = new LocalProperties();
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setHashPartitioned(new FieldList(2, 5));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some required local properties that are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2, 1));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some required global and local properties where the global properties are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(2, 1));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(2, 5));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(1));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some required global and local properties where the local properties are not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(1));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// ---------------------- requirements mixed on 1 and 2 -----------------------
+			
+			// some required global properties at step one and some more at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.EMPTY;
+				
+				RequestedGlobalProperties reqGp1 = new RequestedGlobalProperties();
+				reqGp1.setAnyPartitioning(new FieldList(1, 2));
+				
+				RequestedGlobalProperties reqGp2 = new RequestedGlobalProperties();
+				reqGp2.setHashPartitioned(new FieldList(1, 2));
+				
+				toMap1.setRequiredGlobalProps(reqGp1);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp2);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required local properties at step one and some more at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forOrdering(new Ordering(3, null, Order.ASCENDING).appendOrdering(1, null, Order.DESCENDING));
+				
+				RequestedLocalProperties reqLp1 = new RequestedLocalProperties();
+				reqLp1.setGroupedFields(new FieldList(3, 1));
+				
+				RequestedLocalProperties reqLp2 = new RequestedLocalProperties();
+				reqLp2.setOrdering(new Ordering(3, null, Order.ANY).appendOrdering(1, null, Order.ANY));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp1);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp2);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required global properties at step one and some local ones at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(1, 2));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some required local properties at step one and some global ones at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(1, 2));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some fulfilled global properties at step one and some non-fulfilled local ones at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(1, 2));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2, 3));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some fulfilled local properties at step one and some non-fulfilled global ones at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(2, 3));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2, 1));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some non-fulfilled global properties at step one and some fulfilled local ones at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(2, 3));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2, 1));
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// some non-fulfilled local properties at step one and some fulfilled global ones at step 2
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldList(1, 2));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(2, 1, 3));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testSingleInputOperatorsWithReCreation() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Source");
+			
+			Channel toMap1 = new Channel(target);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(map1);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			// set ship strategy in first channel, so later non matching global properties do not matter
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.EMPTY;
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldSet(2, 5));
+				
+				toMap1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(2, 5));
+				toMap1.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap2.setLocalStrategy(LocalStrategy.NONE);
+				
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(reqGp);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(MET, report);
+			}
+			
+			// set ship strategy in second channel, so previous non matching global properties void the match
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.EMPTY;
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldSet(2, 5));
+				
+				toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap1.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap2.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(2, 5));
+				toMap2.setLocalStrategy(LocalStrategy.NONE);
+				
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// set local strategy in first channel, so later non matching local properties do not matter
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forOrdering(new Ordering(3, null, Order.ASCENDING).appendOrdering(1, null, Order.DESCENDING));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(4, 1));
+				
+				toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap1.setLocalStrategy(LocalStrategy.SORT, new FieldList(5, 7), new boolean[] {false, false});
+				
+				toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap2.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// set local strategy in second channel, so previous non matching local properties void the match
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forOrdering(new Ordering(3, null, Order.ASCENDING).appendOrdering(1, null, Order.DESCENDING));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(4, 1));
+				
+				toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap1.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap2.setLocalStrategy(LocalStrategy.SORT, new FieldList(5, 7), new boolean[] {false, false});
+				
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// create the properties on the same node as the requirement
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(1, 2));
+				LocalProperties lp = LocalProperties.forOrdering(new Ordering(3, null, Order.ASCENDING).appendOrdering(1, null, Order.DESCENDING));
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldSet(5, 7));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(5, 7));
+				
+				toMap1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(5, 7));
+				toMap1.setLocalStrategy(LocalStrategy.SORT, new FieldList(5, 7), new boolean[] {false, false});
+				
+				toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap2.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap1.setRequiredGlobalProps(reqGp);
+				toMap1.setRequiredLocalProps(reqLp);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map2.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(MET, report);
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testSingleInputOperatorsChainOfThree() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Source");
+			
+			Channel toMap1 = new Channel(target);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(map1);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			Channel toMap3 = new Channel(map2);
+			SingleInputPlanNode map3 = new SingleInputPlanNode(getMapNode(), "Mapper 3", toMap3, DriverStrategy.MAP);
+			
+			// set local strategy in first channel, so later non matching local properties do not matter
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.forOrdering(new Ordering(3, null, Order.ASCENDING).appendOrdering(1, null, Order.DESCENDING));
+				
+				RequestedLocalProperties reqLp = new RequestedLocalProperties();
+				reqLp.setGroupedFields(new FieldList(4, 1));
+				
+				toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap1.setLocalStrategy(LocalStrategy.SORT, new FieldList(5, 7), new boolean[] {false, false});
+				
+				toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap2.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap3.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap3.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				toMap3.setRequiredGlobalProps(null);
+				toMap3.setRequiredLocalProps(reqLp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map3.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// set global strategy in first channel, so later non matching global properties do not matter
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(5, 3));
+				LocalProperties lp = LocalProperties.EMPTY;
+				
+				RequestedGlobalProperties reqGp = new RequestedGlobalProperties();
+				reqGp.setAnyPartitioning(new FieldSet(2, 3));
+				
+				toMap1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(1, 2));
+				toMap1.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap2.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap3.setShipStrategy(ShipStrategyType.FORWARD);
+				toMap3.setLocalStrategy(LocalStrategy.NONE);
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toMap2.setRequiredGlobalProps(null);
+				toMap2.setRequiredLocalProps(null);
+				
+				toMap3.setRequiredGlobalProps(reqGp);
+				toMap3.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = map3.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testNoPartialSolutionFoundTwoInputOperator() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Partial Solution");
+
+			SourcePlanNode source1 = new SourcePlanNode(getSourceNode(), "Source 1");
+			SourcePlanNode source2 = new SourcePlanNode(getSourceNode(), "Source 2");
+			
+			Channel toMap1 = new Channel(source1);
+			toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap1.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(source2);
+			toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap2.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			Channel toJoin1 = new Channel(map1);
+			Channel toJoin2 = new Channel(map2);
+			
+			toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+			toJoin1.setLocalStrategy(LocalStrategy.NONE);
+			toJoin2.setShipStrategy(ShipStrategyType.FORWARD);
+			toJoin2.setLocalStrategy(LocalStrategy.NONE);
+			
+			DualInputPlanNode join = new DualInputPlanNode(getJoinNode(), "Join", toJoin1, toJoin2, DriverStrategy.HYBRIDHASH_BUILD_FIRST);
+			
+			FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, new GlobalProperties(), new LocalProperties());
+			assertEquals(NO_PARTIAL_SOLUTION, report);
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testTwoOperatorsOneIndependent() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Partial Solution");
+			SourcePlanNode source = new SourcePlanNode(getSourceNode(), "Other Source");
+			
+			Channel toMap1 = new Channel(target);
+			toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap1.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(source);
+			toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap2.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			Channel toJoin1 = new Channel(map1);
+			Channel toJoin2 = new Channel(map2);
+			
+			DualInputPlanNode join = new DualInputPlanNode(getJoinNode(), "Join", toJoin1, toJoin2, DriverStrategy.HYBRIDHASH_BUILD_FIRST);
+			
+			Channel toAfterJoin = new Channel(join);
+			toAfterJoin.setShipStrategy(ShipStrategyType.FORWARD);
+			toAfterJoin.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode afterJoin = new SingleInputPlanNode(getMapNode(), "After Join Mapper", toAfterJoin, DriverStrategy.MAP);
+			
+			// attach some properties to the non-relevant input
+			{
+				toMap2.setShipStrategy(ShipStrategyType.BROADCAST);
+				toMap2.setLocalStrategy(LocalStrategy.SORT, new FieldList(2, 7), new boolean[] {true, true});
+				
+				RequestedGlobalProperties joinGp = new RequestedGlobalProperties();
+				joinGp.setFullyReplicated();
+				
+				RequestedLocalProperties joinLp = new RequestedLocalProperties();
+				joinLp.setOrdering(new Ordering(2, null, Order.ASCENDING).appendOrdering(7, null, Order.ASCENDING));
+				
+				toJoin2.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin2.setLocalStrategy(LocalStrategy.NONE);
+				toJoin2.setRequiredGlobalProps(joinGp);
+				toJoin2.setRequiredLocalProps(joinLp);
+			}
+			
+			// ------------------------------------------------------------------------------------
+			
+			// no properties from the partial solution, no required properties
+			{
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.NONE);
+				
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.EMPTY;
+				
+				FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some properties from the partial solution, no required properties
+			{
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.NONE);
+				
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			
+			// produced properties match relevant input
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(2));
+				
+				toJoin1.setRequiredGlobalProps(rgp);
+				toJoin1.setRequiredLocalProps(rlp);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.NONE);
+				
+				FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// produced properties do not match relevant input
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(1, 2, 3));
+				
+				toJoin1.setRequiredGlobalProps(rgp);
+				toJoin1.setRequiredLocalProps(rlp);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.NONE);
+				
+				FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// produced properties overridden before join
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(2, 1));
+				
+				toMap1.setRequiredGlobalProps(rgp);
+				toMap1.setRequiredLocalProps(rlp);
+				
+				toJoin1.setRequiredGlobalProps(null);
+				toJoin1.setRequiredLocalProps(null);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(2, 1));
+				toJoin1.setLocalStrategy(LocalStrategy.SORT, new FieldList(7, 3), new boolean[] {true, false});
+				
+				FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(MET, report);
+			}
+			
+			// produced properties before join match, after join match as well
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(2, 1));
+				
+				toMap1.setRequiredGlobalProps(null);
+				toMap1.setRequiredLocalProps(null);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.NONE);
+				
+				toJoin1.setRequiredGlobalProps(rgp);
+				toJoin1.setRequiredLocalProps(rlp);
+			
+				toAfterJoin.setShipStrategy(ShipStrategyType.FORWARD);
+				toAfterJoin.setLocalStrategy(LocalStrategy.NONE);
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = join.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// produced properties before join match, after join do not match
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp1 = new RequestedGlobalProperties();
+				rgp1.setHashPartitioned(new FieldList(0));
+				
+				RequestedGlobalProperties rgp2 = new RequestedGlobalProperties();
+				rgp2.setHashPartitioned(new FieldList(3));
+				
+				RequestedLocalProperties rlp1 = new RequestedLocalProperties();
+				rlp1.setGroupedFields(new FieldList(2, 1));
+				
+				RequestedLocalProperties rlp2 = new RequestedLocalProperties();
+				rlp2.setGroupedFields(new FieldList(3, 4));
+				
+				toJoin1.setRequiredGlobalProps(rgp1);
+				toJoin1.setRequiredLocalProps(rlp1);
+			
+				toAfterJoin.setShipStrategy(ShipStrategyType.FORWARD);
+				toAfterJoin.setLocalStrategy(LocalStrategy.NONE);
+				
+				toAfterJoin.setRequiredGlobalProps(rgp2);
+				toAfterJoin.setRequiredLocalProps(rlp2);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// produced properties are overridden, does not matter that they do not match
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setAnyPartitioning(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(1));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(1, 2, 3));
+				
+				toJoin1.setRequiredGlobalProps(null);
+				toJoin1.setRequiredLocalProps(null);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(2, 1));
+				toJoin1.setLocalStrategy(LocalStrategy.SORT, new FieldList(7, 3), new boolean[] {true, false});
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(MET, report);
+			}
+			
+			// local property overridden before join, local property mismatch after join not relevant
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setAnyPartitioning(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(1, 2, 3));
+				
+				toJoin1.setRequiredGlobalProps(null);
+				toJoin1.setRequiredLocalProps(null);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.SORT, new FieldList(7, 3), new boolean[] {true, false});
+				
+				toAfterJoin.setRequiredGlobalProps(null);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// local property overridden before join, global property mismatch after join void the match
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setAnyPartitioning(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(1));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(1, 2, 3));
+				
+				toJoin1.setRequiredGlobalProps(null);
+				toJoin1.setRequiredLocalProps(null);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.SORT, new FieldList(7, 3), new boolean[] {true, false});
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	@Test
+	public void testTwoOperatorsBothDependent() {
+		try {
+			SourcePlanNode target = new SourcePlanNode(getSourceNode(), "Partial Solution");
+			
+			Channel toMap1 = new Channel(target);
+			toMap1.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap1.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map1 = new SingleInputPlanNode(getMapNode(), "Mapper 1", toMap1, DriverStrategy.MAP);
+			
+			Channel toMap2 = new Channel(target);
+			toMap2.setShipStrategy(ShipStrategyType.FORWARD);
+			toMap2.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode map2 = new SingleInputPlanNode(getMapNode(), "Mapper 2", toMap2, DriverStrategy.MAP);
+			
+			Channel toJoin1 = new Channel(map1);
+			toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+			toJoin1.setLocalStrategy(LocalStrategy.NONE);
+			
+			Channel toJoin2 = new Channel(map2);
+			toJoin2.setShipStrategy(ShipStrategyType.FORWARD);
+			toJoin2.setLocalStrategy(LocalStrategy.NONE);
+			
+			DualInputPlanNode join = new DualInputPlanNode(getJoinNode(), "Join", toJoin1, toJoin2, DriverStrategy.HYBRIDHASH_BUILD_FIRST);
+			
+			Channel toAfterJoin = new Channel(join);
+			toAfterJoin.setShipStrategy(ShipStrategyType.FORWARD);
+			toAfterJoin.setLocalStrategy(LocalStrategy.NONE);
+			SingleInputPlanNode afterJoin = new SingleInputPlanNode(getMapNode(), "After Join Mapper", toAfterJoin, DriverStrategy.MAP);
+			
+			// no properties from the partial solution, no required properties
+			{
+				GlobalProperties gp = new GlobalProperties();
+				LocalProperties lp = LocalProperties.EMPTY;
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// some properties from the partial solution, no required properties
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// test requirements on one input and met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(2, 1));
+				
+				toJoin1.setRequiredGlobalProps(rgp);
+				toJoin1.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// test requirements on both input and met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(2, 1));
+				
+				toJoin1.setRequiredGlobalProps(rgp);
+				toJoin1.setRequiredLocalProps(rlp);
+				
+				toJoin2.setRequiredGlobalProps(rgp);
+				toJoin2.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertTrue(report != null && report != NO_PARTIAL_SOLUTION && report != NOT_MET);
+			}
+			
+			// test requirements on both inputs, one not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp1 = new RequestedGlobalProperties();
+				rgp1.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp1 = new RequestedLocalProperties();
+				rlp1.setGroupedFields(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp2 = new RequestedGlobalProperties();
+				rgp2.setHashPartitioned(new FieldList(1));
+				
+				RequestedLocalProperties rlp2 = new RequestedLocalProperties();
+				rlp2.setGroupedFields(new FieldList(0, 3));
+				
+				toJoin1.setRequiredGlobalProps(rgp1);
+				toJoin1.setRequiredLocalProps(rlp1);
+				
+				toJoin2.setRequiredGlobalProps(rgp2);
+				toJoin2.setRequiredLocalProps(rlp2);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// test override on both inputs, later requirement ignored
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(1));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(0, 3));
+				
+				toJoin1.setRequiredGlobalProps(null);
+				toJoin1.setRequiredLocalProps(null);
+				
+				toJoin2.setRequiredGlobalProps(null);
+				toJoin2.setRequiredLocalProps(null);
+				
+				toJoin1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(88));
+				toJoin2.setShipStrategy(ShipStrategyType.BROADCAST);
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(MET, report);
+			}
+			
+			// test override on one inputs, later requirement met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(0));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(2, 1));
+				
+				toJoin1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(88));
+				toJoin2.setShipStrategy(ShipStrategyType.FORWARD);
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(PENDING, report);
+			}
+			
+			// test override on one input, later requirement not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(3));
+				
+				RequestedLocalProperties rlp = new RequestedLocalProperties();
+				rlp.setGroupedFields(new FieldList(77, 69));
+				
+				toJoin1.setShipStrategy(ShipStrategyType.PARTITION_HASH, new FieldList(88));
+				toJoin2.setShipStrategy(ShipStrategyType.FORWARD);
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(rlp);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+			
+			// test override on one input locally, later global requirement not met
+			{
+				GlobalProperties gp = new GlobalProperties();
+				gp.setHashPartitioned(new FieldList(0));
+				LocalProperties lp = LocalProperties.forGrouping(new FieldList(2, 1));
+				
+				RequestedGlobalProperties rgp = new RequestedGlobalProperties();
+				rgp.setHashPartitioned(new FieldList(3));
+				
+				
+				toJoin1.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.SORT, new FieldList(3), new boolean[] { false });
+				
+				toJoin2.setShipStrategy(ShipStrategyType.FORWARD);
+				toJoin1.setLocalStrategy(LocalStrategy.NONE);
+				
+				toAfterJoin.setRequiredGlobalProps(rgp);
+				toAfterJoin.setRequiredLocalProps(null);
+				
+				FeedbackPropertiesMeetRequirementsReport report = afterJoin.checkPartialSolutionPropertiesMet(target, gp, lp);
+				assertEquals(NOT_MET, report);
+			}
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+	
+	// --------------------------------------------------------------------------------------------
+	
+	private static final DataSourceNode getSourceNode() {
+		return new DataSourceNode(new GenericDataSourceBase<String, TextInputFormat>(new TextInputFormat(new Path("/")), new OperatorInformation<String>(BasicTypeInfo.STRING_TYPE_INFO)));
+	}
+	
+	private static final MapNode getMapNode() {
+		return new MapNode(new MapOperatorBase<String, String, GenericMap<String,String>>(new IdentityMapper<String>(), new UnaryOperatorInformation<String, String>(BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO), "map op"));
+	}
+	
+	private static final MatchNode getJoinNode() {
+		return new MatchNode(new JoinOperatorBase<String, String, String, GenericJoiner<String, String, String>>(new DummyJoinFunction<String>(), new BinaryOperatorInformation<String, String, String>(BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO), new int[] {1}, new int[] {2}, "join op"));
+	}
+}
diff --git a/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/IterationsCompilerTest.java b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/IterationsCompilerTest.java
index a123099ae35..05a863c8a5f 100644
--- a/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/IterationsCompilerTest.java
+++ b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/IterationsCompilerTest.java
@@ -38,7 +38,6 @@ import eu.stratosphere.compiler.plan.BulkIterationPlanNode;
 import eu.stratosphere.compiler.plan.Channel;
 import eu.stratosphere.compiler.plan.OptimizedPlan;
 import eu.stratosphere.compiler.plan.WorksetIterationPlanNode;
-import eu.stratosphere.compiler.plandump.PlanJSONDumpGenerator;
 import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
 import eu.stratosphere.util.Collector;
 
@@ -164,8 +163,6 @@ public class IterationsCompilerTest extends CompilerTestBase {
 			Plan p = env.createProgramPlan();
 			OptimizedPlan op = compileNoStats(p);
 			
-			System.out.println(new PlanJSONDumpGenerator().getOptimizerPlanAsJSON(op));
-			
 			assertEquals(1, op.getDataSinks().size());
 			assertTrue(op.getDataSinks().iterator().next().getInput().getSource() instanceof BulkIterationPlanNode);
 			
diff --git a/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/testfunctions/DummyJoinFunction.java b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/testfunctions/DummyJoinFunction.java
new file mode 100644
index 00000000000..aed8f266ec0
--- /dev/null
+++ b/stratosphere-compiler/src/test/java/eu/stratosphere/pact/compiler/testfunctions/DummyJoinFunction.java
@@ -0,0 +1,28 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2010-2013 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+
+package eu.stratosphere.pact.compiler.testfunctions;
+
+import eu.stratosphere.api.java.functions.JoinFunction;
+
+public class DummyJoinFunction<T> extends JoinFunction<T, T, T> {
+
+	private static final long serialVersionUID = 1L;
+
+	@Override
+	public T join(T first, T second) {
+		return null;
+	}
+}
diff --git a/stratosphere-examples/stratosphere-java-examples/src/main/java/eu/stratosphere/example/java/graph/PageRankBasic.java b/stratosphere-examples/stratosphere-java-examples/src/main/java/eu/stratosphere/example/java/graph/PageRankBasic.java
index 00764d86c8a..3be5009ff15 100644
--- a/stratosphere-examples/stratosphere-java-examples/src/main/java/eu/stratosphere/example/java/graph/PageRankBasic.java
+++ b/stratosphere-examples/stratosphere-java-examples/src/main/java/eu/stratosphere/example/java/graph/PageRankBasic.java
@@ -24,6 +24,7 @@ import eu.stratosphere.api.java.ExecutionEnvironment;
 import eu.stratosphere.api.java.IterativeDataSet;
 import eu.stratosphere.api.java.functions.FilterFunction;
 import eu.stratosphere.api.java.functions.FlatMapFunction;
+import eu.stratosphere.api.java.functions.FunctionAnnotation.ConstantFields;
 import eu.stratosphere.api.java.functions.GroupReduceFunction;
 import eu.stratosphere.api.java.functions.MapFunction;
 import eu.stratosphere.api.java.tuple.Tuple1;
@@ -94,7 +95,7 @@ public class PageRankBasic {
 		DataSet<Tuple2<Long, Double>> pagesWithRanks = pagesInput.
 				map(new RankAssigner((1.0d / numPages)));
 		
-		// build adjecency list from link input
+		// build adjacency list from link input
 		DataSet<Tuple2<Long, Long[]>> adjacencyListInput = 
 				linksInput.groupBy(0).reduceGroup(new BuildOutgoingEdgeList());
 		
@@ -150,8 +151,9 @@ public class PageRankBasic {
 	
 	/**
 	 * A reduce function that takes a sequence of edges and builds the adjacency list for the vertex where the edges
-	 * originate. Run as a preprocessing step.
+	 * originate. Run as a pre-processing step.
 	 */
+	@ConstantFields("0")
 	public static final class BuildOutgoingEdgeList extends GroupReduceFunction<Tuple2<Long, Long>, Tuple2<Long, Long[]>> {
 		
 		private final ArrayList<Long> neighbors = new ArrayList<Long>();
@@ -190,6 +192,7 @@ public class PageRankBasic {
 	/**
 	 * The function that applies the page rank dampening formula
 	 */
+	@ConstantFields("0")
 	public static final class Dampener extends MapFunction<Tuple2<Long,Double>, Tuple2<Long,Double>> {
 
 		private final double dampening;
@@ -275,5 +278,4 @@ public class PageRankBasic {
 			return PageRankData.getDefaultEdgeDataSet(env);
 		}
 	}
-	
 }
diff --git a/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/cache/FileCache.java b/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/cache/FileCache.java
index 882c3a9fb51..e4f0a4b5034 100644
--- a/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/cache/FileCache.java
+++ b/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/cache/FileCache.java
@@ -14,6 +14,7 @@
 package eu.stratosphere.pact.runtime.cache;
 
 import eu.stratosphere.api.common.cache.DistributedCache;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.HashMap;
@@ -64,7 +65,7 @@ public class FileCache {
 	 */
 	public FutureTask<Path> createTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {
 		synchronized (count) {
-			Pair<JobID, String> key = new ImmutablePair(jobID, name);
+			Pair<JobID, String> key = new ImmutablePair<JobID, String>(jobID, name);
 			if (count.containsKey(key)) {
 				count.put(key, count.get(key) + 1);
 			} else {
@@ -84,7 +85,7 @@ public class FileCache {
 	 * @param jobID
 	 */
 	public void deleteTmpFile(String name, DistributedCacheEntry entry, JobID jobID) {
-		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair(jobID,name)));
+		DeleteProcess dp = new DeleteProcess(name, entry, jobID, count.get(new ImmutablePair<JobID, String>(jobID,name)));
 		executorService.schedule(dp, 5000L, TimeUnit.MILLISECONDS);
 	}
 
@@ -138,6 +139,7 @@ public class FileCache {
 	 */
 	private class CopyProcess implements Callable<Path> {
 		private JobID jobID;
+		@SuppressWarnings("unused")
 		private String name;
 		private String filePath;
 		private Boolean executable;
@@ -167,6 +169,7 @@ public class FileCache {
 	 */
 	private class DeleteProcess implements Runnable {
 		private String name;
+		@SuppressWarnings("unused")
 		private String filePath;
 		private JobID jobID;
 		private int oldCount;
@@ -180,7 +183,7 @@ public class FileCache {
 		@Override
 		public void run() {
 			synchronized (count) {
-				if (count.get(new ImmutablePair(jobID, name)) != oldCount) {
+				if (count.get(new ImmutablePair<JobID, String>(jobID, name)) != oldCount) {
 					return;
 				}
 			}
diff --git a/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/shipping/ShipStrategyType.java b/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/shipping/ShipStrategyType.java
index a86c2097784..a8a12933dcd 100644
--- a/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/shipping/ShipStrategyType.java
+++ b/stratosphere-runtime/src/main/java/eu/stratosphere/pact/runtime/shipping/ShipStrategyType.java
@@ -25,7 +25,7 @@ public enum ShipStrategyType {
 	NONE(false, false, false),
 	
 	/**
-	 * Forwarding the data locally in memory.
+	 * Forwarding the data preserving all global properties.
 	 */
 	FORWARD(false, false, false),
 	
diff --git a/stratosphere-runtime/src/test/java/eu/stratosphere/runtime/io/network/netty/NettyConnectionManagerTest.java b/stratosphere-runtime/src/test/java/eu/stratosphere/runtime/io/network/netty/NettyConnectionManagerTest.java
index c380431eb38..d23b0f38dfe 100644
--- a/stratosphere-runtime/src/test/java/eu/stratosphere/runtime/io/network/netty/NettyConnectionManagerTest.java
+++ b/stratosphere-runtime/src/test/java/eu/stratosphere/runtime/io/network/netty/NettyConnectionManagerTest.java
@@ -124,7 +124,7 @@ public class NettyConnectionManagerTest {
 	}
 
 
-	private class VerifyEnvelopes implements Answer {
+	private class VerifyEnvelopes implements Answer<Object> {
 
 		private final ConcurrentMap<ChannelID, Integer> received = new ConcurrentHashMap<ChannelID, Integer>();
 
diff --git a/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/ConnectedComponentsTest.java b/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/ConnectedComponentsTest.java
index 3f4d258b2f7..9c8c0c80dc2 100644
--- a/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/ConnectedComponentsTest.java
+++ b/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/ConnectedComponentsTest.java
@@ -102,7 +102,7 @@ public class ConnectedComponentsTest extends CompilerTestBase {
 		Assert.assertEquals(DriverStrategy.NONE, vertexSource.getDriverStrategy());
 		Assert.assertEquals(DriverStrategy.NONE, edgesSource.getDriverStrategy());
 		
-//		Assert.assertEquals(DriverStrategy.HYBRIDHASH_BUILD_SECOND, neighborsJoin.getDriverStrategy());
+		Assert.assertEquals(DriverStrategy.HYBRIDHASH_BUILD_SECOND, neighborsJoin.getDriverStrategy());
 		Assert.assertEquals(set0, neighborsJoin.getKeysForInput1());
 		Assert.assertEquals(set0, neighborsJoin.getKeysForInput2());
 		
@@ -182,7 +182,7 @@ public class ConnectedComponentsTest extends CompilerTestBase {
 		Assert.assertEquals(DriverStrategy.NONE, vertexSource.getDriverStrategy());
 		Assert.assertEquals(DriverStrategy.NONE, edgesSource.getDriverStrategy());
 		
-//		Assert.assertEquals(DriverStrategy.HYBRIDHASH_BUILD_SECOND, neighborsJoin.getDriverStrategy());
+		Assert.assertEquals(DriverStrategy.HYBRIDHASH_BUILD_SECOND, neighborsJoin.getDriverStrategy());
 		Assert.assertEquals(set0, neighborsJoin.getKeysForInput1());
 		Assert.assertEquals(set0, neighborsJoin.getKeysForInput2());
 		
diff --git a/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/PageRankCompilerTest.java b/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/PageRankCompilerTest.java
new file mode 100644
index 00000000000..547a45398cf
--- /dev/null
+++ b/stratosphere-tests/src/test/java/eu/stratosphere/test/compiler/iterations/PageRankCompilerTest.java
@@ -0,0 +1,108 @@
+/***********************************************************************************************************************
+ *
+ * Copyright (C) 2010-2013 by the Stratosphere project (http://stratosphere.eu)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ **********************************************************************************************************************/
+
+package eu.stratosphere.test.compiler.iterations;
+
+import static eu.stratosphere.api.java.aggregation.Aggregations.SUM;
+import static org.junit.Assert.fail;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import eu.stratosphere.api.common.Plan;
+import eu.stratosphere.api.java.DataSet;
+import eu.stratosphere.api.java.ExecutionEnvironment;
+import eu.stratosphere.api.java.IterativeDataSet;
+import eu.stratosphere.api.java.tuple.Tuple1;
+import eu.stratosphere.api.java.tuple.Tuple2;
+import eu.stratosphere.compiler.PactCompiler;
+import eu.stratosphere.compiler.plan.BulkIterationPlanNode;
+import eu.stratosphere.compiler.plan.BulkPartialSolutionPlanNode;
+import eu.stratosphere.compiler.plan.OptimizedPlan;
+import eu.stratosphere.compiler.plan.SinkPlanNode;
+import eu.stratosphere.configuration.Configuration;
+import eu.stratosphere.example.java.graph.PageRankBasic.BuildOutgoingEdgeList;
+import eu.stratosphere.example.java.graph.PageRankBasic.Dampener;
+import eu.stratosphere.example.java.graph.PageRankBasic.EpsilonFilter;
+import eu.stratosphere.example.java.graph.PageRankBasic.JoinVertexWithEdgesMatch;
+import eu.stratosphere.example.java.graph.PageRankBasic.RankAssigner;
+import eu.stratosphere.pact.runtime.shipping.ShipStrategyType;
+import eu.stratosphere.pact.runtime.task.util.LocalStrategy;
+import eu.stratosphere.test.compiler.util.CompilerTestBase;
+
+public class PageRankCompilerTest extends CompilerTestBase{
+	
+	@Test
+	public void testPageRank() {
+		try {
+			final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();
+			
+			// get input data
+			@SuppressWarnings("unchecked")
+			DataSet<Tuple1<Long>> pagesInput = env.fromElements(new Tuple1<Long>(1l));
+			@SuppressWarnings("unchecked")
+			DataSet<Tuple2<Long, Long>> linksInput =env.fromElements(new Tuple2<Long, Long>(1l, 2l));
+			
+			// assign initial rank to pages
+			DataSet<Tuple2<Long, Double>> pagesWithRanks = pagesInput.
+					map(new RankAssigner((1.0d / 10)));
+			
+			// build adjacency list from link input
+			DataSet<Tuple2<Long, Long[]>> adjacencyListInput = 
+					linksInput.groupBy(0).reduceGroup(new BuildOutgoingEdgeList());
+			
+			// set iterative data set
+			IterativeDataSet<Tuple2<Long, Double>> iteration = pagesWithRanks.iterate(10);
+			
+			Configuration cfg = new Configuration();
+			cfg.setString(PactCompiler.HINT_LOCAL_STRATEGY, PactCompiler.HINT_LOCAL_STRATEGY_HASH_BUILD_SECOND);
+			
+			DataSet<Tuple2<Long, Double>> newRanks = iteration
+					// join pages with outgoing edges and distribute rank
+					.join(adjacencyListInput).where(0).equalTo(0).withParameters(cfg)
+					.flatMap(new JoinVertexWithEdgesMatch())
+					// collect and sum ranks
+					.groupBy(0).aggregate(SUM, 1)
+					// apply dampening factor
+					.map(new Dampener(0.85, 10));
+			
+			DataSet<Tuple2<Long, Double>> finalPageRanks = iteration.closeWith(
+					newRanks, 
+					newRanks.join(iteration).where(0).equalTo(0)
+					// termination condition
+					.filter(new EpsilonFilter()));
+	
+			finalPageRanks.print();
+	
+			// get the plan and compile it
+			Plan p = env.createProgramPlan();
+			OptimizedPlan op = compileNoStats(p);
+			
+			SinkPlanNode sinkPlanNode = (SinkPlanNode) op.getDataSinks().iterator().next();
+			BulkIterationPlanNode iterPlanNode = (BulkIterationPlanNode) sinkPlanNode.getInput().getSource();
+			
+			// check that the partitioning is pushed out of the first loop
+			Assert.assertEquals(ShipStrategyType.PARTITION_HASH, iterPlanNode.getInput().getShipStrategy());
+			Assert.assertEquals(LocalStrategy.NONE, iterPlanNode.getInput().getLocalStrategy());
+			
+			BulkPartialSolutionPlanNode partSolPlanNode = iterPlanNode.getPartialSolutionPlanNode();
+			Assert.assertEquals(ShipStrategyType.FORWARD, partSolPlanNode.getOutgoingChannels().get(0).getShipStrategy());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+}
