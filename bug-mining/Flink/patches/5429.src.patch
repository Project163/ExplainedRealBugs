diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreITCase.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreITCase.java
index 009dc9815bc..75da66c8905 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreITCase.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreITCase.java
@@ -68,8 +68,8 @@ public class KubernetesStateHandleStoreITCase extends TestLogger {
                 new TestingLeaderCallbackHandler[leaderNum];
 
         @SuppressWarnings("unchecked")
-        final KubernetesStateHandleStore<Long>[] stateHandleStores =
-                new KubernetesStateHandleStore[leaderNum];
+        final KubernetesStateHandleStore<TestingLongStateHandleHelper.LongStateHandle>[]
+                stateHandleStores = new KubernetesStateHandleStore[leaderNum];
 
         try {
             for (int i = 0; i < leaderNum; i++) {
@@ -103,17 +103,19 @@ public class KubernetesStateHandleStoreITCase extends TestLogger {
                 if (leaderCallbackHandlers[i].getLockIdentity().equals(lockIdentity)) {
                     expectedState = (long) i;
                 }
-                stateHandleStores[i].addAndLock(KEY, (long) i);
+                stateHandleStores[i].addAndLock(
+                        KEY, new TestingLongStateHandleHelper.LongStateHandle(i));
             }
 
             // Only the leader could add successfully
             assertThat(expectedState, is(notNullValue()));
             assertThat(stateHandleStores[0].getAllAndLock().size(), is(1));
             assertThat(
-                    stateHandleStores[0].getAllAndLock().get(0).f0.retrieveState(),
+                    stateHandleStores[0].getAllAndLock().get(0).f0.retrieveState().getValue(),
                     is(expectedState));
             assertThat(stateHandleStores[0].getAllAndLock().get(0).f1, is(KEY));
         } finally {
+            TestingLongStateHandleHelper.clearGlobalState();
             // Cleanup the resources
             for (int i = 0; i < leaderNum; i++) {
                 if (leaderElectors[i] != null) {
diff --git a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
index 339291d8e79..6e230f5250f 100644
--- a/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
+++ b/flink-kubernetes/src/test/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStoreTest.java
@@ -25,7 +25,6 @@ import org.apache.flink.kubernetes.kubeclient.resources.KubernetesLeaderElector;
 import org.apache.flink.runtime.persistence.StateHandleStore;
 import org.apache.flink.runtime.persistence.StringResourceVersion;
 import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper;
-import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper.LongRetrievableStateHandle;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.function.FunctionUtils;
 
@@ -36,6 +35,7 @@ import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
 
 import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.is;
@@ -49,14 +49,16 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
     private static final String PREFIX = "test-prefix-";
     private final String key = PREFIX + JobID.generate();
     private final Predicate<String> filter = k -> k.startsWith(PREFIX);
-    private final Long state = 12345L;
+    private final TestingLongStateHandleHelper.LongStateHandle state =
+            new TestingLongStateHandleHelper.LongStateHandle(12345L);
 
-    private TestingLongStateHandleHelper longStateStorage;
+    private final TestingLongStateHandleHelper longStateStorage =
+            new TestingLongStateHandleHelper();
 
     @Before
     public void setup() {
         super.setup();
-        longStateStorage = new TestingLongStateHandleHelper();
+        TestingLongStateHandleHelper.clearGlobalState();
     }
 
     @Test
@@ -67,13 +69,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             store.addAndLock(key, state);
                             assertThat(store.getAllAndLock().size(), is(1));
                             assertThat(store.getAndLock(key).retrieveState(), is(state));
@@ -92,13 +96,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
 
                             getLeaderConfigMap().getData().put(key, "existing data");
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
 
                             try {
                                 store.addAndLock(key, state);
@@ -110,12 +116,10 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                                                 key, LEADER_CONFIGMAP_NAME);
                                 assertThat(ex, FlinkMatchers.containsMessage(msg));
                             }
-                            assertThat(longStateStorage.getStateHandles().size(), is(1));
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(1));
                             assertThat(
-                                    longStateStorage
-                                            .getStateHandles()
-                                            .get(0)
-                                            .getNumberOfDiscardCalls(),
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(0),
                                     is(1));
                         });
             }
@@ -128,13 +132,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
             {
                 runTest(
                         () -> {
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
 
                             try {
                                 store.addAndLock(key, state);
@@ -146,12 +152,10 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                                                 LEADER_CONFIGMAP_NAME);
                                 assertThat(ex, FlinkMatchers.containsMessage(msg));
                             }
-                            assertThat(longStateStorage.getStateHandles().size(), is(1));
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(1));
                             assertThat(
-                                    longStateStorage
-                                            .getStateHandles()
-                                            .get(0)
-                                            .getNumberOfDiscardCalls(),
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(0),
                                     is(1));
                         });
             }
@@ -166,17 +170,20 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
 
                             store.addAndLock(key, state);
 
-                            final Long newState = 23456L;
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(23456L);
                             final StringResourceVersion resourceVersion = store.exists(key);
                             store.replace(key, resourceVersion, newState);
 
@@ -195,14 +202,17 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
-                            final Long newState = 23456L;
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(23456L);
 
                             try {
                                 assertThat(
@@ -230,14 +240,17 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
-                            final Long newState = 23456L;
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(23456L);
 
                             store.addAndLock(key, state);
                             // Lost leadership
@@ -253,18 +266,14 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                             // The state do not change
                             assertThat(store.getAndLock(key).retrieveState(), is(state));
 
-                            assertThat(longStateStorage.getStateHandles().size(), is(2));
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
                             assertThat(
-                                    longStateStorage
-                                            .getStateHandles()
-                                            .get(0)
-                                            .getNumberOfDiscardCalls(),
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(0),
                                     is(0));
                             assertThat(
-                                    longStateStorage
-                                            .getStateHandles()
-                                            .get(1)
-                                            .getNumberOfDiscardCalls(),
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(1),
                                     is(1));
                         });
             }
@@ -280,13 +289,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             store.addAndLock(key, state);
 
                             final FlinkKubeClient anotherFlinkKubeClient =
@@ -296,15 +307,18 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                                                         throw updateException;
                                                     })
                                             .build();
-                            final KubernetesStateHandleStore<Long> anotherStore =
-                                    new KubernetesStateHandleStore<>(
-                                            anotherFlinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
-
-                            final Long newState = 23456L;
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    anotherStore =
+                                            new KubernetesStateHandleStore<>(
+                                                    anotherFlinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
+
+                            final TestingLongStateHandleHelper.LongStateHandle newState =
+                                    new TestingLongStateHandleHelper.LongStateHandle(23456L);
                             final StringResourceVersion resourceVersion = anotherStore.exists(key);
                             assertThat(resourceVersion.isExisting(), is(true));
                             try {
@@ -318,18 +332,14 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                             // The state do not change
                             assertThat(anotherStore.getAndLock(key).retrieveState(), is(state));
 
-                            assertThat(longStateStorage.getStateHandles().size(), is(2));
+                            assertThat(TestingLongStateHandleHelper.getGlobalStorageSize(), is(2));
                             assertThat(
-                                    longStateStorage
-                                            .getStateHandles()
-                                            .get(0)
-                                            .getNumberOfDiscardCalls(),
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(0),
                                     is(0));
                             assertThat(
-                                    longStateStorage
-                                            .getStateHandles()
-                                            .get(1)
-                                            .getNumberOfDiscardCalls(),
+                                    TestingLongStateHandleHelper
+                                            .getDiscardCallCountForStateHandleByIndex(1),
                                     is(1));
                         });
             }
@@ -344,13 +354,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             store.addAndLock(key, state);
                             assertThat(
                                     store.exists(key),
@@ -369,13 +381,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             final String nonExistingKey = "non-existing-key";
                             store.addAndLock(key, state);
                             assertThat(
@@ -404,26 +418,37 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             final List<Long> expected = Arrays.asList(3L, 2L, 1L);
 
                             for (Long each : expected) {
-                                store.addAndLock(key + each, each);
+                                store.addAndLock(
+                                        key + each,
+                                        new TestingLongStateHandleHelper.LongStateHandle(each));
                             }
-                            final Long[] actual =
+                            final TestingLongStateHandleHelper.LongStateHandle[] actual =
                                     store.getAllAndLock().stream()
                                             .map(
                                                     FunctionUtils.uncheckedFunction(
                                                             e -> e.f0.retrieveState()))
-                                            .toArray(Long[]::new);
+                                            .toArray(
+                                                    TestingLongStateHandleHelper.LongStateHandle[]
+                                                            ::new);
                             assertThat(
-                                    Arrays.asList(actual), containsInAnyOrder(expected.toArray()));
+                                    Arrays.stream(actual)
+                                            .map(
+                                                    TestingLongStateHandleHelper.LongStateHandle
+                                                            ::getValue)
+                                            .collect(Collectors.toList()),
+                                    containsInAnyOrder(expected.toArray()));
                         });
             }
         };
@@ -437,13 +462,15 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                         () -> {
                             leaderCallbackGrantLeadership();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             final List<String> expected = Arrays.asList(key + 3, key + 2, key + 1);
 
                             for (String each : expected) {
@@ -465,24 +492,23 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                 runTest(
                         () -> {
                             leaderCallbackGrantLeadership();
-                            LongRetrievableStateHandle.clearNumberOfGlobalDiscardCalls();
-
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             store.addAndLock(key, state);
                             assertThat(store.getAllAndLock().size(), is(1));
                             assertThat(store.releaseAndTryRemove(key), is(true));
                             assertThat(store.getAllAndLock().size(), is(0));
 
                             // State should also be discarded.
-                            assertThat(
-                                    LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls(),
-                                    is(1));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(1));
                         });
             }
         };
@@ -495,15 +521,16 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                 runTest(
                         () -> {
                             leaderCallbackGrantLeadership();
-                            LongRetrievableStateHandle.clearNumberOfGlobalDiscardCalls();
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
 
                             store.addAndLock(key, state);
                             // Lost leadership
@@ -516,9 +543,7 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                             assertThat(store.releaseAndTryRemove(key), is(false));
                             assertThat(store.getAllAndLock().size(), is(1));
 
-                            assertThat(
-                                    LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls(),
-                                    is(0));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(0));
                         });
             }
         };
@@ -531,23 +556,24 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                 runTest(
                         () -> {
                             leaderCallbackGrantLeadership();
-                            LongRetrievableStateHandle.clearNumberOfGlobalDiscardCalls();
-
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             store.addAndLock(key, state);
-                            store.addAndLock(key + "1", 2L);
+                            store.addAndLock(
+                                    key + "1",
+                                    new TestingLongStateHandleHelper.LongStateHandle(2L));
                             assertThat(store.getAllAndLock().size(), is(2));
                             store.releaseAndTryRemoveAll();
                             assertThat(store.getAllAndLock().size(), is(0));
-                            assertThat(
-                                    LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls(),
-                                    is(2));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(2));
                         });
             }
         };
@@ -560,26 +586,27 @@ public class KubernetesStateHandleStoreTest extends KubernetesHighAvailabilityTe
                 runTest(
                         () -> {
                             leaderCallbackGrantLeadership();
-                            LongRetrievableStateHandle.clearNumberOfGlobalDiscardCalls();
 
                             final String anotherKey = "key-not-with-prefix";
                             getLeaderConfigMap().getData().put(anotherKey, "value");
 
-                            final KubernetesStateHandleStore<Long> store =
-                                    new KubernetesStateHandleStore<>(
-                                            flinkKubeClient,
-                                            LEADER_CONFIGMAP_NAME,
-                                            longStateStorage,
-                                            filter,
-                                            LOCK_IDENTITY);
+                            final KubernetesStateHandleStore<
+                                            TestingLongStateHandleHelper.LongStateHandle>
+                                    store =
+                                            new KubernetesStateHandleStore<>(
+                                                    flinkKubeClient,
+                                                    LEADER_CONFIGMAP_NAME,
+                                                    longStateStorage,
+                                                    filter,
+                                                    LOCK_IDENTITY);
                             store.addAndLock(key, state);
-                            store.addAndLock(key + "1", 2L);
+                            store.addAndLock(
+                                    key + "1",
+                                    new TestingLongStateHandleHelper.LongStateHandle(2L));
                             assertThat(store.getAllAndLock().size(), is(2));
                             store.clearEntries();
                             assertThat(store.getAllAndLock().size(), is(0));
-                            assertThat(
-                                    LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls(),
-                                    is(0));
+                            assertThat(TestingLongStateHandleHelper.getGlobalDiscardCount(), is(0));
 
                             // Should only remove the key with specified prefix.
                             assertThat(
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java b/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java
index 4010391c1e2..fd387b24881 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/persistence/TestingLongStateHandleHelper.java
@@ -19,72 +19,122 @@
 package org.apache.flink.runtime.persistence;
 
 import org.apache.flink.runtime.state.RetrievableStateHandle;
+import org.apache.flink.runtime.state.StateObject;
+import org.apache.flink.util.AbstractID;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.StringJoiner;
 
 /**
  * Testing implementation for {@link RetrievableStateStorageHelper} and {@link
  * RetrievableStateHandle} with type {@link Long}.
  */
-public class TestingLongStateHandleHelper implements RetrievableStateStorageHelper<Long> {
+public class TestingLongStateHandleHelper
+        implements RetrievableStateStorageHelper<TestingLongStateHandleHelper.LongStateHandle> {
 
-    private final List<LongRetrievableStateHandle> stateHandles = new ArrayList<>();
+    private static final List<LongStateHandle> STATE_STORAGE = new ArrayList<>();
 
     @Override
-    public RetrievableStateHandle<Long> store(Long state) {
-        final LongRetrievableStateHandle stateHandle = new LongRetrievableStateHandle(state);
-        stateHandles.add(stateHandle);
+    public RetrievableStateHandle<LongStateHandle> store(LongStateHandle state) {
+        final int pos = STATE_STORAGE.size();
+        STATE_STORAGE.add(state);
 
-        return stateHandle;
+        return new LongRetrievableStateHandle(pos);
     }
 
-    public List<LongRetrievableStateHandle> getStateHandles() {
-        return stateHandles;
+    public static LongStateHandle createState(long value) {
+        return new LongStateHandle(value);
     }
 
-    /** Testing {@link RetrievableStateStorageHelper} implementation with {@link Long}. */
-    public static class LongRetrievableStateHandle implements RetrievableStateHandle<Long> {
+    public static long getStateHandleValueByIndex(int index) {
+        return STATE_STORAGE.get(index).getValue();
+    }
 
-        private static final long serialVersionUID = -3555329254423838912L;
+    public static int getDiscardCallCountForStateHandleByIndex(int index) {
+        return STATE_STORAGE.get(index).getNumberOfDiscardCalls();
+    }
 
-        private static AtomicInteger numberOfGlobalDiscardCalls = new AtomicInteger(0);
+    public static int getGlobalStorageSize() {
+        return STATE_STORAGE.size();
+    }
+
+    public static void clearGlobalState() {
+        STATE_STORAGE.clear();
+    }
+
+    public static int getGlobalDiscardCount() {
+        return STATE_STORAGE.stream().mapToInt(LongStateHandle::getNumberOfDiscardCalls).sum();
+    }
 
-        private final Long state;
+    /**
+     * {@code LongStateHandle} implements {@link StateObject} to monitor the {@link
+     * StateObject#discardState()} calls.
+     */
+    public static class LongStateHandle implements StateObject {
+
+        private static final long serialVersionUID = -5752042587113549855L;
+
+        private final Long value;
 
         private int numberOfDiscardCalls = 0;
 
-        public LongRetrievableStateHandle(Long state) {
-            this.state = state;
+        public LongStateHandle(long value) {
+            this.value = value;
         }
 
-        @Override
-        public Long retrieveState() {
-            return state;
+        public long getValue() {
+            return value;
         }
 
         @Override
         public void discardState() {
-            numberOfGlobalDiscardCalls.incrementAndGet();
             numberOfDiscardCalls++;
         }
 
+        public int getNumberOfDiscardCalls() {
+            return numberOfDiscardCalls;
+        }
+
         @Override
         public long getStateSize() {
-            return 0;
+            return 8L;
         }
 
-        public int getNumberOfDiscardCalls() {
-            return numberOfDiscardCalls;
+        @Override
+        public String toString() {
+            return new StringJoiner(", ", LongStateHandle.class.getSimpleName() + "[", "]")
+                    .add("value=" + value)
+                    .add("numberOfDiscardCalls=" + numberOfDiscardCalls)
+                    .toString();
         }
+    }
+
+    /** Testing {@link RetrievableStateStorageHelper} implementation with {@link Long}. */
+    public static class LongRetrievableStateHandle
+            implements RetrievableStateHandle<LongStateHandle> {
 
-        public static int getNumberOfGlobalDiscardCalls() {
-            return numberOfGlobalDiscardCalls.get();
+        private static final long serialVersionUID = -3555329254423838912L;
+
+        private final int stateReference;
+
+        public LongRetrievableStateHandle(int stateReference) {
+            this.stateReference = stateReference;
         }
 
-        public static void clearNumberOfGlobalDiscardCalls() {
-            numberOfGlobalDiscardCalls.set(0);
+        @Override
+        public LongStateHandle retrieveState() {
+            return STATE_STORAGE.get(stateReference);
+        }
+
+        @Override
+        public void discardState() {
+            STATE_STORAGE.get(stateReference).discardState();
+        }
+
+        @Override
+        public long getStateSize() {
+            return AbstractID.SIZE;
         }
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
index c89e9d5acb3..e9f0bd249ae 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/zookeeper/ZooKeeperStateHandleStoreTest.java
@@ -24,7 +24,6 @@ import org.apache.flink.configuration.HighAvailabilityOptions;
 import org.apache.flink.runtime.persistence.IntegerResourceVersion;
 import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper;
-import org.apache.flink.runtime.persistence.TestingLongStateHandleHelper.LongRetrievableStateHandle;
 import org.apache.flink.runtime.state.RetrievableStateHandle;
 import org.apache.flink.runtime.util.ZooKeeperUtils;
 import org.apache.flink.util.InstantiationUtil;
@@ -82,26 +81,27 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     @Before
     public void cleanUp() throws Exception {
         ZOOKEEPER.deleteAll();
+        TestingLongStateHandleHelper.clearGlobalState();
     }
 
     /** Tests add operation with lock. */
     @Test
     public void testAddAndLock() throws Exception {
         final TestingLongStateHandleHelper longStateStorage = new TestingLongStateHandleHelper();
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
         // Config
         final String pathInZooKeeper = "/testAdd";
-        final Long state = 1239712317L;
+        final long state = 1239712317L;
 
         // Test
-        store.addAndLock(pathInZooKeeper, state);
+        store.addAndLock(pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(state));
 
         // Verify
         // State handle created
         assertEquals(1, store.getAllAndLock().size());
-        assertEquals(state, store.getAndLock(pathInZooKeeper).retrieveState());
+        assertEquals(state, store.getAndLock(pathInZooKeeper).retrieveState().getValue());
 
         // Path created and is persistent
         Stat stat = ZOOKEEPER.getClient().checkExists().forPath(pathInZooKeeper);
@@ -121,12 +121,13 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
 
         // Data is equal
         @SuppressWarnings("unchecked")
-        Long actual =
-                ((RetrievableStateHandle<Long>)
+        final long actual =
+                ((RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>)
                                 InstantiationUtil.deserializeObject(
                                         ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),
                                         ClassLoader.getSystemClassLoader()))
-                        .retrieveState();
+                        .retrieveState()
+                        .getValue();
 
         assertEquals(state, actual);
     }
@@ -136,23 +137,25 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testAddAlreadyExistingPath() throws Exception {
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         ZOOKEEPER.getClient().create().forPath("/testAddAlreadyExistingPath");
 
-        store.addAndLock("/testAddAlreadyExistingPath", 1L);
+        store.addAndLock(
+                "/testAddAlreadyExistingPath",
+                new TestingLongStateHandleHelper.LongStateHandle(1L));
 
         // writing to the state storage should have succeeded
-        assertEquals(1, stateHandleProvider.getStateHandles());
+        assertEquals(1, TestingLongStateHandleHelper.getGlobalStorageSize());
 
         // the created state handle should have been cleaned up if the add operation failed
-        assertEquals(1, stateHandleProvider.getStateHandles().get(0).getNumberOfDiscardCalls());
+        assertEquals(1, TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(0));
     }
 
     /** Tests that the created state handle is discarded if ZooKeeper create fails. */
     @Test
-    public void testAddDiscardStateHandleAfterFailure() throws Exception {
+    public void testAddDiscardStateHandleAfterFailure() {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
@@ -160,25 +163,26 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         when(client.inTransaction().create())
                 .thenThrow(new RuntimeException("Expected test Exception."));
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(client, stateHandleProvider);
 
         // Config
         final String pathInZooKeeper = "/testAddDiscardStateHandleAfterFailure";
-        final Long state = 81282227L;
+        final long state = 81282227L;
 
         try {
             // Test
-            store.addAndLock(pathInZooKeeper, state);
+            store.addAndLock(
+                    pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(state));
             fail("Did not throw expected exception");
         } catch (Exception ignored) {
         }
 
         // Verify
         // State handle created and discarded
-        assertEquals(1, stateHandleProvider.getStateHandles().size());
-        assertEquals(state, stateHandleProvider.getStateHandles().get(0).retrieveState());
-        assertEquals(1, stateHandleProvider.getStateHandles().get(0).getNumberOfDiscardCalls());
+        assertEquals(1, TestingLongStateHandleHelper.getGlobalStorageSize());
+        assertEquals(state, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
+        assertEquals(1, TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(0));
     }
 
     /** Tests that a state handle is replaced. */
@@ -187,23 +191,27 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         // Config
         final String pathInZooKeeper = "/testReplace";
-        final Long initialState = 30968470898L;
-        final Long replaceState = 88383776661L;
+        final long initialState = 30968470898L;
+        final long replaceState = 88383776661L;
 
         // Test
-        store.addAndLock(pathInZooKeeper, initialState);
-        store.replace(pathInZooKeeper, IntegerResourceVersion.valueOf(0), replaceState);
+        store.addAndLock(
+                pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(initialState));
+        store.replace(
+                pathInZooKeeper,
+                IntegerResourceVersion.valueOf(0),
+                new TestingLongStateHandleHelper.LongStateHandle(replaceState));
 
         // Verify
         // State handles created
-        assertEquals(2, stateHandleProvider.getStateHandles().size());
-        assertEquals(initialState, stateHandleProvider.getStateHandles().get(0).retrieveState());
-        assertEquals(replaceState, stateHandleProvider.getStateHandles().get(1).retrieveState());
+        assertEquals(2, TestingLongStateHandleHelper.getGlobalStorageSize());
+        assertEquals(initialState, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
+        assertEquals(replaceState, TestingLongStateHandleHelper.getStateHandleValueByIndex(1));
 
         // Path created and is persistent
         Stat stat = ZOOKEEPER.getClient().checkExists().forPath(pathInZooKeeper);
@@ -212,12 +220,13 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
 
         // Data is equal
         @SuppressWarnings("unchecked")
-        Long actual =
-                ((RetrievableStateHandle<Long>)
+        final long actual =
+                ((RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>)
                                 InstantiationUtil.deserializeObject(
                                         ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),
                                         ClassLoader.getSystemClassLoader()))
-                        .retrieveState();
+                        .retrieveState()
+                        .getValue();
 
         assertEquals(replaceState, actual);
     }
@@ -225,12 +234,16 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     /** Tests that a non existing path throws an Exception. */
     @Test(expected = Exception.class)
     public void testReplaceNonExistingPath() throws Exception {
-        final RetrievableStateStorageHelper<Long> stateStorage = new TestingLongStateHandleHelper();
+        final RetrievableStateStorageHelper<TestingLongStateHandleHelper.LongStateHandle>
+                stateStorage = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateStorage);
 
-        store.replace("/testReplaceNonExistingPath", IntegerResourceVersion.valueOf(0), 1L);
+        store.replace(
+                "/testReplaceNonExistingPath",
+                IntegerResourceVersion.valueOf(0),
+                new TestingLongStateHandleHelper.LongStateHandle(1L));
     }
 
     /** Tests that the replace state handle is discarded if ZooKeeper setData fails. */
@@ -242,38 +255,43 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         CuratorFramework client = spy(ZOOKEEPER.getClient());
         when(client.setData()).thenThrow(new RuntimeException("Expected test Exception."));
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(client, stateHandleProvider);
 
         // Config
         final String pathInZooKeeper = "/testReplaceDiscardStateHandleAfterFailure";
-        final Long initialState = 30968470898L;
-        final Long replaceState = 88383776661L;
+        final long initialState = 30968470898L;
+        final long replaceState = 88383776661L;
 
         // Test
-        store.addAndLock(pathInZooKeeper, initialState);
+        store.addAndLock(
+                pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(initialState));
 
         try {
-            store.replace(pathInZooKeeper, IntegerResourceVersion.valueOf(0), replaceState);
+            store.replace(
+                    pathInZooKeeper,
+                    IntegerResourceVersion.valueOf(0),
+                    new TestingLongStateHandleHelper.LongStateHandle(replaceState));
             fail("Did not throw expected exception");
         } catch (Exception ignored) {
         }
 
         // Verify
         // State handle created and discarded
-        assertEquals(2, stateHandleProvider.getStateHandles().size());
-        assertEquals(initialState, stateHandleProvider.getStateHandles().get(0).retrieveState());
-        assertEquals(replaceState, stateHandleProvider.getStateHandles().get(1).retrieveState());
-        assertEquals(1, stateHandleProvider.getStateHandles().get(1).getNumberOfDiscardCalls());
+        assertEquals(2, TestingLongStateHandleHelper.getGlobalStorageSize());
+        assertEquals(initialState, TestingLongStateHandleHelper.getStateHandleValueByIndex(0));
+        assertEquals(replaceState, TestingLongStateHandleHelper.getStateHandleValueByIndex(1));
+        assertEquals(1, TestingLongStateHandleHelper.getDiscardCallCountForStateHandleByIndex(1));
 
         // Initial value
         @SuppressWarnings("unchecked")
-        Long actual =
-                ((RetrievableStateHandle<Long>)
+        final long actual =
+                ((RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>)
                                 InstantiationUtil.deserializeObject(
                                         ZOOKEEPER.getClient().getData().forPath(pathInZooKeeper),
                                         ClassLoader.getSystemClassLoader()))
-                        .retrieveState();
+                        .retrieveState()
+                        .getValue();
 
         assertEquals(initialState, actual);
     }
@@ -284,21 +302,22 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         // Config
         final String pathInZooKeeper = "/testGetAndExists";
-        final Long state = 311222268470898L;
+        final long state = 311222268470898L;
 
         // Test
         assertThat(store.exists(pathInZooKeeper).isExisting(), is(false));
 
-        store.addAndLock(pathInZooKeeper, state);
-        RetrievableStateHandle<Long> actual = store.getAndLock(pathInZooKeeper);
+        store.addAndLock(pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(state));
+        RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle> actual =
+                store.getAndLock(pathInZooKeeper);
 
         // Verify
-        assertEquals(state, actual.retrieveState());
+        assertEquals(state, actual.retrieveState().getValue());
         assertTrue(store.exists(pathInZooKeeper).getValue() >= 0);
     }
 
@@ -307,7 +326,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testGetNonExistingPath() throws Exception {
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         store.getAndLock("/testGetNonExistingPath");
@@ -319,7 +338,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         // Config
@@ -333,11 +352,13 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
 
         // Test
         for (long val : expected) {
-            store.addAndLock(pathInZooKeeper + val, val);
+            store.addAndLock(
+                    pathInZooKeeper + val, new TestingLongStateHandleHelper.LongStateHandle(val));
         }
 
-        for (Tuple2<RetrievableStateHandle<Long>, String> val : store.getAllAndLock()) {
-            assertTrue(expected.remove(val.f0.retrieveState()));
+        for (Tuple2<RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>, String>
+                val : store.getAllAndLock()) {
+            assertTrue(expected.remove(val.f0.retrieveState().getValue()));
         }
         assertEquals(0, expected.size());
     }
@@ -348,7 +369,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         // Config
@@ -359,10 +380,12 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Test
         for (long val : expected) {
             final String pathInZooKeeper = String.format("%s%016d", basePath, val);
-            store.addAndLock(pathInZooKeeper, val);
+            store.addAndLock(
+                    pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(val));
         }
 
-        List<Tuple2<RetrievableStateHandle<Long>, String>> actual = store.getAllAndLock();
+        List<Tuple2<RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>, String>>
+                actual = store.getAllAndLock();
         assertEquals(expected.length, actual.size());
 
         // bring the elements in sort order
@@ -370,7 +393,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         Collections.sort(actual, Comparator.comparing(o -> o.f1));
 
         for (int i = 0; i < expected.length; i++) {
-            assertEquals(expected[i], actual.get(i).f0.retrieveState());
+            assertEquals(expected[i], (Long) actual.get(i).f0.retrieveState().getValue());
         }
     }
 
@@ -380,17 +403,16 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         // Config
         final String pathInZooKeeper = "/testRemove";
-        final Long state = 27255442L;
 
-        store.addAndLock(pathInZooKeeper, state);
+        store.addAndLock(
+                pathInZooKeeper, new TestingLongStateHandleHelper.LongStateHandle(27255442L));
 
-        final int numberOfGlobalDiscardCalls =
-                LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls();
+        final int numberOfGlobalDiscardCalls = TestingLongStateHandleHelper.getGlobalDiscardCount();
 
         // Test
         store.releaseAndTryRemove(pathInZooKeeper);
@@ -399,7 +421,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         assertEquals(0, ZOOKEEPER.getClient().getChildren().forPath("/").size());
         assertEquals(
                 numberOfGlobalDiscardCalls + 1,
-                LongRetrievableStateHandle.getNumberOfGlobalDiscardCalls());
+                TestingLongStateHandleHelper.getGlobalDiscardCount());
     }
 
     /** Tests that all state handles are correctly discarded. */
@@ -408,7 +430,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         // Setup
         final TestingLongStateHandleHelper stateHandleProvider = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateHandleProvider);
 
         // Config
@@ -422,7 +444,8 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
 
         // Test
         for (long val : expected) {
-            store.addAndLock(pathInZooKeeper + val, val);
+            store.addAndLock(
+                    pathInZooKeeper + val, new TestingLongStateHandleHelper.LongStateHandle(val));
         }
 
         store.releaseAndTryRemoveAll();
@@ -439,7 +462,7 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testCorruptedData() throws Exception {
         final TestingLongStateHandleHelper stateStorage = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> store =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> store =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), stateStorage);
 
         final Collection<Long> input = new HashSet<>();
@@ -448,21 +471,23 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         input.add(3L);
 
         for (Long aLong : input) {
-            store.addAndLock("/" + aLong, aLong);
+            store.addAndLock("/" + aLong, new TestingLongStateHandleHelper.LongStateHandle(aLong));
         }
 
         // corrupt one of the entries
         ZOOKEEPER.getClient().setData().forPath("/" + 2, new byte[2]);
 
-        List<Tuple2<RetrievableStateHandle<Long>, String>> allEntries = store.getAllAndLock();
+        List<Tuple2<RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>, String>>
+                allEntries = store.getAllAndLock();
 
         Collection<Long> expected = new HashSet<>(input);
         expected.remove(2L);
 
         Collection<Long> actual = new HashSet<>(expected.size());
 
-        for (Tuple2<RetrievableStateHandle<Long>, String> entry : allEntries) {
-            actual.add(entry.f0.retrieveState());
+        for (Tuple2<RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle>, String>
+                entry : allEntries) {
+            actual.add(entry.f0.retrieveState().getValue());
         }
 
         assertEquals(expected, actual);
@@ -478,23 +503,24 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testConcurrentDeleteOperation() throws Exception {
         final TestingLongStateHandleHelper longStateStorage = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> zkStore1 =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore1 =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
-        ZooKeeperStateHandleStore<Long> zkStore2 =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore2 =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
         final String statePath = "/state";
 
-        zkStore1.addAndLock(statePath, 42L);
-        RetrievableStateHandle<Long> stateHandle = zkStore2.getAndLock(statePath);
+        zkStore1.addAndLock(statePath, new TestingLongStateHandleHelper.LongStateHandle(42L));
+        RetrievableStateHandle<TestingLongStateHandleHelper.LongStateHandle> stateHandle =
+                zkStore2.getAndLock(statePath);
 
         // this should not remove the referenced node because we are still holding a state handle
         // reference via zkStore2
         zkStore1.releaseAndTryRemove(statePath);
 
         // sanity check
-        assertEquals(42L, (long) stateHandle.retrieveState());
+        assertEquals(42L, stateHandle.retrieveState().getValue());
 
         Stat nodeStat = ZOOKEEPER.getClient().checkExists().forPath(statePath);
 
@@ -521,15 +547,15 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testLockCleanupWhenGetAndLockFails() throws Exception {
         final TestingLongStateHandleHelper longStateStorage = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> zkStore1 =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore1 =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
-        ZooKeeperStateHandleStore<Long> zkStore2 =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore2 =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
         final String path = "/state";
 
-        zkStore1.addAndLock(path, 42L);
+        zkStore1.addAndLock(path, new TestingLongStateHandleHelper.LongStateHandle(42L));
 
         final byte[] corruptedData = {1, 2};
 
@@ -581,12 +607,12 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
         try (CuratorFramework client = ZooKeeperUtils.startCuratorFramework(configuration);
                 CuratorFramework client2 = ZooKeeperUtils.startCuratorFramework(configuration)) {
 
-            ZooKeeperStateHandleStore<Long> zkStore =
+            ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore =
                     new ZooKeeperStateHandleStore<>(client, longStateStorage);
 
             final String path = "/state";
 
-            zkStore.addAndLock(path, 42L);
+            zkStore.addAndLock(path, new TestingLongStateHandleHelper.LongStateHandle(42L));
 
             // this should delete all ephemeral nodes
             client.close();
@@ -612,12 +638,12 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testRelease() throws Exception {
         final TestingLongStateHandleHelper longStateStorage = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> zkStore =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
         final String path = "/state";
 
-        zkStore.addAndLock(path, 42L);
+        zkStore.addAndLock(path, new TestingLongStateHandleHelper.LongStateHandle(42L));
 
         final String lockPath = zkStore.getLockPath(path);
 
@@ -648,13 +674,13 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
     public void testReleaseAll() throws Exception {
         final TestingLongStateHandleHelper longStateStorage = new TestingLongStateHandleHelper();
 
-        ZooKeeperStateHandleStore<Long> zkStore =
+        ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore =
                 new ZooKeeperStateHandleStore<>(ZOOKEEPER.getClient(), longStateStorage);
 
         final Collection<String> paths = Arrays.asList("/state1", "/state2", "/state3");
 
         for (String path : paths) {
-            zkStore.addAndLock(path, 42L);
+            zkStore.addAndLock(path, new TestingLongStateHandleHelper.LongStateHandle(42L));
         }
 
         for (String path : paths) {
@@ -680,12 +706,12 @@ public class ZooKeeperStateHandleStoreTest extends TestLogger {
 
     @Test
     public void testRemoveAllHandlesShouldRemoveAllPaths() throws Exception {
-        final ZooKeeperStateHandleStore<Long> zkStore =
+        final ZooKeeperStateHandleStore<TestingLongStateHandleHelper.LongStateHandle> zkStore =
                 new ZooKeeperStateHandleStore<>(
                         ZooKeeperUtils.useNamespaceAndEnsurePath(ZOOKEEPER.getClient(), "/path"),
                         new TestingLongStateHandleHelper());
 
-        zkStore.addAndLock("/state", 1L);
+        zkStore.addAndLock("/state", new TestingLongStateHandleHelper.LongStateHandle(1L));
         zkStore.clearEntries();
 
         assertThat(zkStore.getAllHandles(), is(empty()));
