diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointIDCounter.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointIDCounter.java
index ede797e0bb0..a08146a956e 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointIDCounter.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointIDCounter.java
@@ -29,6 +29,8 @@ import org.apache.flink.util.FlinkRuntimeException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
+
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicLong;
 
@@ -48,15 +50,15 @@ public class KubernetesCheckpointIDCounter implements CheckpointIDCounter {
 
     private final String configMapName;
 
-    private final String lockIdentity;
+    @Nullable private final String lockIdentity;
 
     private boolean running;
 
     public KubernetesCheckpointIDCounter(
-            FlinkKubeClient kubeClient, String configMapName, String lockIdentity) {
+            FlinkKubeClient kubeClient, String configMapName, @Nullable String lockIdentity) {
         this.kubeClient = checkNotNull(kubeClient);
         this.configMapName = checkNotNull(configMapName);
-        this.lockIdentity = checkNotNull(lockIdentity);
+        this.lockIdentity = lockIdentity;
 
         this.running = false;
     }
@@ -81,7 +83,7 @@ public class KubernetesCheckpointIDCounter implements CheckpointIDCounter {
             kubeClient.checkAndUpdateConfigMap(
                     configMapName,
                     configMap -> {
-                        if (KubernetesLeaderElector.hasLeadership(configMap, lockIdentity)) {
+                        if (isValidOperation(configMap)) {
                             configMap.getData().remove(CHECKPOINT_COUNTER_KEY);
                             return Optional.of(configMap);
                         }
@@ -90,6 +92,11 @@ public class KubernetesCheckpointIDCounter implements CheckpointIDCounter {
         }
     }
 
+    private boolean isValidOperation(KubernetesConfigMap configMap) {
+        return lockIdentity == null
+                || KubernetesLeaderElector.hasLeadership(configMap, lockIdentity);
+    }
+
     @Override
     public long getAndIncrement() throws Exception {
         final AtomicLong current = new AtomicLong();
@@ -98,8 +105,7 @@ public class KubernetesCheckpointIDCounter implements CheckpointIDCounter {
                         .checkAndUpdateConfigMap(
                                 configMapName,
                                 configMap -> {
-                                    if (KubernetesLeaderElector.hasLeadership(
-                                            configMap, lockIdentity)) {
+                                    if (isValidOperation(configMap)) {
                                         final long currentValue = getCurrentCounter(configMap);
                                         current.set(currentValue);
                                         configMap
@@ -143,7 +149,7 @@ public class KubernetesCheckpointIDCounter implements CheckpointIDCounter {
                 .checkAndUpdateConfigMap(
                         configMapName,
                         configMap -> {
-                            if (KubernetesLeaderElector.hasLeadership(configMap, lockIdentity)) {
+                            if (isValidOperation(configMap)) {
                                 final String existing =
                                         configMap.getData().get(CHECKPOINT_COUNTER_KEY);
                                 final String newValue = String.valueOf(newCount);
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointRecoveryFactory.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointRecoveryFactory.java
index 71dd388598c..2c318645a46 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointRecoveryFactory.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesCheckpointRecoveryFactory.java
@@ -27,6 +27,8 @@ import org.apache.flink.runtime.checkpoint.CheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
 import org.apache.flink.runtime.state.SharedStateRegistryFactory;
 
+import javax.annotation.Nullable;
+
 import java.util.concurrent.Executor;
 import java.util.function.Function;
 
@@ -45,7 +47,9 @@ public class KubernetesCheckpointRecoveryFactory implements CheckpointRecoveryFa
 
     private final Configuration configuration;
 
-    private final String lockIdentity;
+    @Nullable private final String lockIdentity;
+
+    private final String clusterId;
 
     /**
      * Create a KubernetesCheckpointRecoveryFactory.
@@ -56,18 +60,20 @@ public class KubernetesCheckpointRecoveryFactory implements CheckpointRecoveryFa
      * @param function Function to get the ConfigMap name for checkpoint.
      * @param lockIdentity Lock identity of current HA service
      */
-    public KubernetesCheckpointRecoveryFactory(
+    private KubernetesCheckpointRecoveryFactory(
             FlinkKubeClient kubeClient,
             Configuration configuration,
             Executor executor,
             Function<JobID, String> function,
-            String lockIdentity) {
+            String clusterId,
+            @Nullable String lockIdentity) {
 
         this.kubeClient = checkNotNull(kubeClient);
         this.configuration = checkNotNull(configuration);
         this.executor = checkNotNull(executor);
         this.getConfigMapNameFunction = checkNotNull(function);
-        this.lockIdentity = checkNotNull(lockIdentity);
+        this.lockIdentity = lockIdentity;
+        this.clusterId = clusterId;
     }
 
     @Override
@@ -78,12 +84,14 @@ public class KubernetesCheckpointRecoveryFactory implements CheckpointRecoveryFa
             SharedStateRegistryFactory sharedStateRegistryFactory,
             Executor ioExecutor)
             throws Exception {
+        final String configMapName = getConfigMapNameFunction.apply(jobID);
+        KubernetesUtils.createConfigMapIfItDoesNotExist(kubeClient, configMapName, clusterId);
 
         return KubernetesUtils.createCompletedCheckpointStore(
                 configuration,
                 kubeClient,
                 executor,
-                getConfigMapNameFunction.apply(jobID),
+                configMapName,
                 lockIdentity,
                 maxNumberOfCheckpointsToRetain,
                 sharedStateRegistryFactory,
@@ -91,8 +99,31 @@ public class KubernetesCheckpointRecoveryFactory implements CheckpointRecoveryFa
     }
 
     @Override
-    public CheckpointIDCounter createCheckpointIDCounter(JobID jobID) {
-        return new KubernetesCheckpointIDCounter(
-                kubeClient, getConfigMapNameFunction.apply(jobID), lockIdentity);
+    public CheckpointIDCounter createCheckpointIDCounter(JobID jobID) throws Exception {
+        final String configMapName = getConfigMapNameFunction.apply(jobID);
+        KubernetesUtils.createConfigMapIfItDoesNotExist(kubeClient, configMapName, clusterId);
+
+        return new KubernetesCheckpointIDCounter(kubeClient, configMapName, lockIdentity);
+    }
+
+    public static KubernetesCheckpointRecoveryFactory withLeadershipValidation(
+            FlinkKubeClient kubeClient,
+            Configuration configuration,
+            Executor executor,
+            String clusterId,
+            Function<JobID, String> function,
+            String lockIdentity) {
+        return new KubernetesCheckpointRecoveryFactory(
+                kubeClient, configuration, executor, function, clusterId, lockIdentity);
+    }
+
+    public static KubernetesCheckpointRecoveryFactory withoutLeadershipValidation(
+            FlinkKubeClient kubeClient,
+            Configuration configuration,
+            Executor executor,
+            String clusterId,
+            Function<JobID, String> function) {
+        return new KubernetesCheckpointRecoveryFactory(
+                kubeClient, configuration, executor, function, clusterId, null);
     }
 }
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesHaServices.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesHaServices.java
index 86bb4c24f17..e66973f872d 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesHaServices.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesHaServices.java
@@ -130,10 +130,11 @@ public class KubernetesHaServices extends AbstractHaServices {
 
     @Override
     public CheckpointRecoveryFactory createCheckpointRecoveryFactory() {
-        return new KubernetesCheckpointRecoveryFactory(
+        return KubernetesCheckpointRecoveryFactory.withLeadershipValidation(
                 kubeClient,
                 configuration,
                 ioExecutor,
+                clusterId,
                 this::getLeaderPathForJobManager,
                 lockIdentity);
     }
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java
index 158780a7218..1a208d25b4a 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesMultipleComponentLeaderElectionHaServices.java
@@ -149,8 +149,8 @@ public class KubernetesMultipleComponentLeaderElectionHaServices extends Abstrac
 
     @Override
     protected CheckpointRecoveryFactory createCheckpointRecoveryFactory() {
-        return new KubernetesCheckpointRecoveryFactory(
-                kubeClient, configuration, ioExecutor, this::getJobSpecificConfigMap, lockIdentity);
+        return KubernetesCheckpointRecoveryFactory.withoutLeadershipValidation(
+                kubeClient, configuration, ioExecutor, clusterId, this::getJobSpecificConfigMap);
     }
 
     private String getJobSpecificConfigMap(JobID jobID) {
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
index 68caf9f387e..ca6083a4750 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/highavailability/KubernetesStateHandleStore.java
@@ -33,6 +33,8 @@ import org.apache.flink.util.ExceptionUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.annotation.Nullable;
+
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
@@ -82,7 +84,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
 
     private final Predicate<String> configMapKeyFilter;
 
-    private final String lockIdentity;
+    @Nullable private final String lockIdentity;
 
     /**
      * Creates a {@link KubernetesStateHandleStore}.
@@ -99,13 +101,13 @@ public class KubernetesStateHandleStore<T extends Serializable>
             String configMapName,
             RetrievableStateStorageHelper<T> storage,
             Predicate<String> configMapKeyFilter,
-            String lockIdentity) {
+            @Nullable String lockIdentity) {
 
         this.kubeClient = checkNotNull(kubeClient, "Kubernetes client");
         this.storage = checkNotNull(storage, "State storage");
         this.configMapName = checkNotNull(configMapName, "ConfigMap name");
         this.configMapKeyFilter = checkNotNull(configMapKeyFilter);
-        this.lockIdentity = checkNotNull(lockIdentity, "Lock identity of current HA service");
+        this.lockIdentity = lockIdentity;
     }
 
     /**
@@ -141,8 +143,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
                             .checkAndUpdateConfigMap(
                                     configMapName,
                                     c -> {
-                                        if (KubernetesLeaderElector.hasLeadership(
-                                                c, lockIdentity)) {
+                                        if (isValidOperation(c)) {
                                             if (!c.getData().containsKey(key)) {
                                                 c.getData()
                                                         .put(
@@ -178,6 +179,10 @@ public class KubernetesStateHandleStore<T extends Serializable>
         }
     }
 
+    private boolean isValidOperation(KubernetesConfigMap c) {
+        return lockIdentity == null || KubernetesLeaderElector.hasLeadership(c, lockIdentity);
+    }
+
     /**
      * Replaces a state handle in ConfigMap and discards the old state handle. Wo do not lock
      * resource version and then replace in Kubernetes. Since the ConfigMap is periodically updated
@@ -214,8 +219,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
                             .checkAndUpdateConfigMap(
                                     configMapName,
                                     c -> {
-                                        if (KubernetesLeaderElector.hasLeadership(
-                                                c, lockIdentity)) {
+                                        if (isValidOperation(c)) {
                                             // Check the existence
                                             if (c.getData().containsKey(key)) {
                                                 c.getData()
@@ -380,7 +384,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
                 .checkAndUpdateConfigMap(
                         configMapName,
                         configMap -> {
-                            if (KubernetesLeaderElector.hasLeadership(configMap, lockIdentity)) {
+                            if (isValidOperation(configMap)) {
                                 final String content = configMap.getData().remove(key);
                                 if (content != null) {
                                     try {
@@ -424,7 +428,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
                 .checkAndUpdateConfigMap(
                         configMapName,
                         c -> {
-                            if (KubernetesLeaderElector.hasLeadership(c, lockIdentity)) {
+                            if (isValidOperation(c)) {
                                 final Map<String, String> updateData = new HashMap<>(c.getData());
                                 c.getData().entrySet().stream()
                                         .filter(entry -> configMapKeyFilter.test(entry.getKey()))
@@ -481,7 +485,7 @@ public class KubernetesStateHandleStore<T extends Serializable>
                 .checkAndUpdateConfigMap(
                         configMapName,
                         c -> {
-                            if (KubernetesLeaderElector.hasLeadership(c, lockIdentity)) {
+                            if (isValidOperation(c)) {
                                 c.getData().keySet().removeIf(configMapKeyFilter);
                                 return Optional.of(c);
                             }
diff --git a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java
index b1452d254b4..e02d3a824e2 100644
--- a/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java
+++ b/flink-kubernetes/src/main/java/org/apache/flink/kubernetes/utils/KubernetesUtils.java
@@ -44,6 +44,8 @@ import org.apache.flink.runtime.leaderelection.LeaderInformation;
 import org.apache.flink.runtime.persistence.RetrievableStateStorageHelper;
 import org.apache.flink.runtime.persistence.filesystem.FileSystemStateStorageHelper;
 import org.apache.flink.runtime.state.SharedStateRegistryFactory;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.FlinkRuntimeException;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.StringUtils;
@@ -51,6 +53,7 @@ import org.apache.flink.util.function.FunctionUtils;
 
 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.dataformat.yaml.YAMLMapper;
 
+import io.fabric8.kubernetes.api.model.ConfigMapBuilder;
 import io.fabric8.kubernetes.api.model.Container;
 import io.fabric8.kubernetes.api.model.ContainerBuilder;
 import io.fabric8.kubernetes.api.model.KubernetesResource;
@@ -73,12 +76,14 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
 
 import static org.apache.flink.kubernetes.utils.Constants.CHECKPOINT_ID_KEY_PREFIX;
 import static org.apache.flink.kubernetes.utils.Constants.COMPLETED_CHECKPOINT_FILE_SUFFIX;
 import static org.apache.flink.kubernetes.utils.Constants.JOB_GRAPH_STORE_KEY_PREFIX;
+import static org.apache.flink.kubernetes.utils.Constants.LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY;
 import static org.apache.flink.kubernetes.utils.Constants.LEADER_ADDRESS_KEY;
 import static org.apache.flink.kubernetes.utils.Constants.LEADER_SESSION_ID_KEY;
 import static org.apache.flink.kubernetes.utils.Constants.SUBMITTED_JOBGRAPH_FILE_PREFIX;
@@ -299,7 +304,7 @@ public class KubernetesUtils {
             FlinkKubeClient kubeClient,
             Executor executor,
             String configMapName,
-            String lockIdentity,
+            @Nullable String lockIdentity,
             int maxNumberOfCheckpointsToRetain,
             SharedStateRegistryFactory sharedStateRegistryFactory,
             Executor ioExecutor)
@@ -512,6 +517,51 @@ public class KubernetesUtils {
         return configuration.getBoolean(KubernetesConfigOptions.KUBERNETES_HOSTNETWORK_ENABLED);
     }
 
+    /**
+     * Creates a config map with the given name if it does not exist.
+     *
+     * @param flinkKubeClient to use for creating the config map
+     * @param configMapName name of the config map
+     * @param clusterId clusterId to which the map belongs
+     * @throws FlinkException if the config map could not be created
+     */
+    public static void createConfigMapIfItDoesNotExist(
+            FlinkKubeClient flinkKubeClient, String configMapName, String clusterId)
+            throws FlinkException {
+
+        int attempt = 0;
+        CompletionException lastException = null;
+
+        final int maxAttempts = 10;
+        final KubernetesConfigMap configMap =
+                new KubernetesConfigMap(
+                        new ConfigMapBuilder()
+                                .withNewMetadata()
+                                .withName(configMapName)
+                                .withLabels(
+                                        getConfigMapLabels(
+                                                clusterId, LABEL_CONFIGMAP_TYPE_HIGH_AVAILABILITY))
+                                .endMetadata()
+                                .build());
+
+        while (!flinkKubeClient.getConfigMap(configMapName).isPresent() && attempt < maxAttempts) {
+            try {
+                flinkKubeClient.createConfigMap(configMap).join();
+            } catch (CompletionException e) {
+                // retrying
+                lastException = ExceptionUtils.firstOrSuppressed(e, lastException);
+            }
+
+            attempt++;
+        }
+
+        if (attempt >= maxAttempts && lastException != null) {
+            throw new FlinkException(
+                    String.format("Could not create the config map %s.", configMapName),
+                    lastException);
+        }
+    }
+
     /** Cluster components. */
     public enum ClusterComponent {
         JOB_MANAGER,
