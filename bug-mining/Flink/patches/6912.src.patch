diff --git a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java
index 349061ede32..6fd9fa9f2ce 100644
--- a/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java
+++ b/flink-libraries/flink-cep/src/main/java/org/apache/flink/cep/nfa/compiler/NFACompiler.java
@@ -613,9 +613,7 @@ public class NFACompiler {
                     proceedState,
                     takeCondition,
                     getIgnoreCondition(currentPattern),
-                    currentPattern
-                            .getQuantifier()
-                            .hasProperty(Quantifier.QuantifierProperty.OPTIONAL));
+                    isPatternOptional(currentPattern));
         }
 
         /**
@@ -659,14 +657,17 @@ public class NFACompiler {
          * pattern, the optional status depends on the group pattern.
          */
         private boolean isPatternOptional(Pattern<T, ?> pattern) {
-            if (headOfGroup(pattern)) {
-                return isCurrentGroupPatternFirstOfLoop()
-                        && currentGroupPattern
-                                .getQuantifier()
-                                .hasProperty(Quantifier.QuantifierProperty.OPTIONAL);
-            } else {
-                return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL);
+            return pattern.getQuantifier().hasProperty(Quantifier.QuantifierProperty.OPTIONAL);
+        }
+
+        private boolean isHeadOfOptionalGroupPattern(Pattern<T, ?> pattern) {
+            if (!headOfGroup(pattern)) {
+                return false;
             }
+            return isCurrentGroupPatternFirstOfLoop()
+                    && currentGroupPattern
+                            .getQuantifier()
+                            .hasProperty(Quantifier.QuantifierProperty.OPTIONAL);
         }
 
         /**
@@ -719,11 +720,7 @@ public class NFACompiler {
             // if no element accepted the previous nots are still valid.
             final IterativeCondition<T> proceedCondition = getTrueFunction();
 
-            // for the first state of a group pattern, its PROCEED edge should point to the
-            // following state of
-            // that group pattern and the edge will be added at the end of creating the NFA for that
-            // group pattern
-            if (isOptional && !headOfGroup(currentPattern)) {
+            if (isOptional) {
                 if (currentPattern
                         .getQuantifier()
                         .hasProperty(Quantifier.QuantifierProperty.GREEDY)) {
@@ -748,7 +745,7 @@ public class NFACompiler {
 
             if (ignoreCondition != null) {
                 final State<T> ignoreState;
-                if (isOptional) {
+                if (isOptional || isHeadOfOptionalGroupPattern(currentPattern)) {
                     ignoreState = createState(State.StateType.Normal, false);
                     ignoreState.addTake(sink, takeCondition);
                     ignoreState.addIgnore(ignoreCondition);
diff --git a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java
index 9c06342cd14..b49b36a5464 100644
--- a/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java
+++ b/flink-libraries/flink-cep/src/test/java/org/apache/flink/cep/nfa/GroupITCase.java
@@ -887,4 +887,84 @@ public class GroupITCase extends TestLogger {
         assertEquals(1, nfaState.getPartialMatches().size());
         assertEquals("start", nfaState.getPartialMatches().peek().getCurrentStateName());
     }
+
+    @Test
+    public void testGroupStartsWithOptionalPattern() throws Exception {
+        List<StreamRecord<Event>> inputEvents = new ArrayList<>();
+
+        Event a = new Event(40, "a", 1.0);
+        Event c = new Event(41, "c", 2.0);
+        Event d = new Event(42, "d", 3.0);
+
+        inputEvents.add(new StreamRecord<>(a, 1));
+        inputEvents.add(new StreamRecord<>(c, 2));
+        inputEvents.add(new StreamRecord<>(d, 3));
+
+        // a (b? c) d
+        Pattern<Event, ?> pattern =
+                Pattern.<Event>begin("start")
+                        .where(SimpleCondition.of(value -> value.getName().equals("a")))
+                        .next(
+                                Pattern.<Event>begin("middle1")
+                                        .where(
+                                                SimpleCondition.of(
+                                                        value -> value.getName().equals("b")))
+                                        .optional()
+                                        .next("middle2")
+                                        .where(
+                                                SimpleCondition.of(
+                                                        value -> value.getName().equals("c"))))
+                        .next("d")
+                        .where(SimpleCondition.of(value -> value.getName().equals("d")));
+
+        NFA<Event> nfa = compile(pattern, false);
+
+        NFAState nfaState = nfa.createInitialNFAState();
+
+        NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).withNFAState(nfaState).build();
+        final List<List<Event>> resultingPatterns = nfaTestHarness.feedRecords(inputEvents);
+
+        comparePatterns(
+                resultingPatterns, Lists.<List<Event>>newArrayList(Lists.newArrayList(a, c, d)));
+    }
+
+    @Test
+    public void testFollowedByOptionalGroupPattern() throws Exception {
+        List<StreamRecord<Event>> inputEvents = new ArrayList<>();
+
+        Event a = new Event(40, "a", 1.0);
+        Event d1 = new Event(41, "d", 2.0);
+        Event d2 = new Event(42, "d", 3.0);
+
+        inputEvents.add(new StreamRecord<>(a, 1));
+        inputEvents.add(new StreamRecord<>(d1, 2));
+        inputEvents.add(new StreamRecord<>(d2, 3));
+
+        // a -> (b c)? d
+        Pattern<Event, ?> pattern =
+                Pattern.<Event>begin("start")
+                        .where(SimpleCondition.of(value -> value.getName().equals("a")))
+                        .followedBy(
+                                Pattern.<Event>begin("middle1")
+                                        .where(
+                                                SimpleCondition.of(
+                                                        value -> value.getName().equals("b")))
+                                        .next("middle2")
+                                        .where(
+                                                SimpleCondition.of(
+                                                        value -> value.getName().equals("c"))))
+                        .optional()
+                        .next("d")
+                        .where(SimpleCondition.of(value -> value.getName().equals("d")));
+
+        NFA<Event> nfa = compile(pattern, false);
+
+        NFAState nfaState = nfa.createInitialNFAState();
+
+        NFATestHarness nfaTestHarness = NFATestHarness.forNFA(nfa).withNFAState(nfaState).build();
+        final List<List<Event>> resultingPatterns = nfaTestHarness.feedRecords(inputEvents);
+
+        comparePatterns(
+                resultingPatterns, Lists.<List<Event>>newArrayList(Lists.newArrayList(a, d1)));
+    }
 }
