diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcess.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcess.java
new file mode 100644
index 00000000000..6d5c29bddb4
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcess.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.dispatcher.Dispatcher;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.util.AutoCloseableAsync;
+
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Leader process which encapsulates the lifecycle of the {@link Dispatcher} component.
+ */
+interface DispatcherLeaderProcess extends AutoCloseableAsync {
+
+	void start();
+
+	UUID getLeaderSessionId();
+
+	CompletableFuture<DispatcherGateway> getDispatcherGateway();
+
+	CompletableFuture<String> getConfirmLeaderSessionFuture();
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessFactory.java
new file mode 100644
index 00000000000..d3bd700024e
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessFactory.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import java.util.UUID;
+
+/**
+ * Factory for the {@link DispatcherLeaderProcess}.
+ */
+public interface DispatcherLeaderProcessFactory {
+
+	DispatcherLeaderProcess create(UUID leaderSessionID);
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNG.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNG.java
new file mode 100644
index 00000000000..16f79657d49
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNG.java
@@ -0,0 +1,208 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;
+import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.runtime.leaderelection.LeaderContender;
+import org.apache.flink.runtime.leaderelection.LeaderElectionService;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.util.FlinkException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Arrays;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Runner for the {@link org.apache.flink.runtime.dispatcher.Dispatcher} which is responsible for the
+ * leader election.
+ */
+public class DispatcherRunnerImplNG implements DispatcherRunner, LeaderContender {
+
+	private static final Logger LOG = LoggerFactory.getLogger(DispatcherRunnerImplNG.class);
+
+	private final Object lock = new Object();
+
+	private final LeaderElectionService leaderElectionService;
+
+	private final FatalErrorHandler fatalErrorHandler;
+
+	private final DispatcherLeaderProcessFactory dispatcherLeaderProcessFactory;
+
+	private final CompletableFuture<Void> terminationFuture;
+
+	private final CompletableFuture<ApplicationStatus> shutDownFuture;
+
+	private boolean isRunning;
+
+	private DispatcherLeaderProcess dispatcherLeaderProcess;
+
+	private CompletableFuture<Void> previousDispatcherLeaderProcessTerminationFuture;
+
+	private CompletableFuture<DispatcherGateway> dispatcherGatewayFuture;
+
+	DispatcherRunnerImplNG(
+			LeaderElectionService leaderElectionService,
+			FatalErrorHandler fatalErrorHandler,
+			DispatcherLeaderProcessFactory dispatcherLeaderProcessFactory) throws Exception {
+		this.leaderElectionService = leaderElectionService;
+		this.fatalErrorHandler = fatalErrorHandler;
+		this.dispatcherLeaderProcessFactory = dispatcherLeaderProcessFactory;
+		this.terminationFuture = new CompletableFuture<>();
+		this.shutDownFuture = new CompletableFuture<>();
+
+		this.isRunning = true;
+		this.dispatcherLeaderProcess = StoppedDispatcherLeaderProcess.INSTANCE;
+		this.previousDispatcherLeaderProcessTerminationFuture = CompletableFuture.completedFuture(null);
+		this.dispatcherGatewayFuture = new CompletableFuture<>();
+
+		startDispatcherRunner(leaderElectionService);
+	}
+
+	private void startDispatcherRunner(LeaderElectionService leaderElectionService) throws Exception {
+		LOG.info("Starting {}.", getClass().getName());
+
+		leaderElectionService.start(this);
+	}
+
+	@Override
+	public CompletableFuture<DispatcherGateway> getDispatcherGateway() {
+		synchronized (lock) {
+			return dispatcherGatewayFuture;
+		}
+	}
+
+	@Override
+	public CompletableFuture<ApplicationStatus> getShutDownFuture() {
+		return shutDownFuture;
+	}
+
+	@Override
+	public CompletableFuture<Void> closeAsync() {
+		synchronized (lock) {
+			if (!isRunning) {
+				return terminationFuture;
+			} else {
+				isRunning = false;
+			}
+		}
+
+		stopDispatcherLeaderProcess();
+		final CompletableFuture<Void> servicesTerminationFuture = stopServices();
+
+		FutureUtils.forward(
+			FutureUtils.completeAll(
+				Arrays.asList(
+					previousDispatcherLeaderProcessTerminationFuture,
+					servicesTerminationFuture)),
+			terminationFuture);
+
+		return terminationFuture;
+	}
+
+	private CompletableFuture<Void> stopServices() {
+		Exception exception = null;
+
+		try {
+			leaderElectionService.stop();
+		} catch (Exception e) {
+			exception = e;
+		}
+		if (exception == null) {
+			return CompletableFuture.completedFuture(null);
+		} else {
+			return FutureUtils.completedExceptionally(exception);
+		}
+	}
+
+	// ---------------------------------------------------------------
+	// Leader election
+	// ---------------------------------------------------------------
+
+	@Override
+	public void grantLeadership(UUID leaderSessionID) {
+		runActionIfRunning(() -> startNewDispatcherLeaderProcess(leaderSessionID));
+	}
+
+	private void startNewDispatcherLeaderProcess(UUID leaderSessionID) {
+		stopDispatcherLeaderProcess();
+
+		createAndAssignNewDispatcherLeaderProcess(leaderSessionID);
+
+		final DispatcherLeaderProcess newDispatcherLeaderProcess = dispatcherLeaderProcess;
+		FutureUtils.assertNoException(
+			previousDispatcherLeaderProcessTerminationFuture.thenRun(newDispatcherLeaderProcess::start));
+	}
+
+	private void createAndAssignNewDispatcherLeaderProcess(UUID leaderSessionID) {
+		dispatcherLeaderProcess = createNewDispatcherLeaderProcess(leaderSessionID);
+
+		final CompletableFuture<DispatcherGateway> newDispatcherGatewayFuture = dispatcherLeaderProcess.getDispatcherGateway();
+		FutureUtils.forward(newDispatcherGatewayFuture, dispatcherGatewayFuture);
+		dispatcherGatewayFuture = newDispatcherGatewayFuture;
+
+		FutureUtils.assertNoException(
+			dispatcherLeaderProcess.getConfirmLeaderSessionFuture().thenAccept(
+				leaderAddress -> {
+					if (leaderElectionService.hasLeadership(leaderSessionID)) {
+						leaderElectionService.confirmLeadership(leaderSessionID, leaderAddress);
+					}
+				}));
+	}
+
+	private void stopDispatcherLeaderProcess() {
+		final CompletableFuture<Void> terminationFuture = dispatcherLeaderProcess.closeAsync();
+		previousDispatcherLeaderProcessTerminationFuture = FutureUtils.completeAll(
+			Arrays.asList(
+				previousDispatcherLeaderProcessTerminationFuture,
+				terminationFuture));
+	}
+
+	private DispatcherLeaderProcess createNewDispatcherLeaderProcess(UUID leaderSessionID) {
+		LOG.debug("Create new {} with leader session id {}.", DispatcherLeaderProcess.class.getSimpleName(), leaderSessionID);
+		return dispatcherLeaderProcessFactory.create(leaderSessionID);
+	}
+
+	@Override
+	public void revokeLeadership() {
+		runActionIfRunning(this::stopDispatcherLeaderProcess);
+	}
+
+	private void runActionIfRunning(Runnable runnable) {
+		synchronized (lock) {
+			if (isRunning) {
+				runnable.run();
+			} else {
+				LOG.debug("Ignoring action because {} has already been stopped.", getClass().getSimpleName());
+			}
+		}
+	}
+
+	@Override
+	public void handleError(Exception exception) {
+		fatalErrorHandler.onFatalError(
+			new FlinkException(
+				String.format("Exception during leader election of %s occurred.", getClass().getSimpleName()),
+				exception));
+	}
+}
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/StoppedDispatcherLeaderProcess.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/StoppedDispatcherLeaderProcess.java
new file mode 100644
index 00000000000..d63102b965f
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/StoppedDispatcherLeaderProcess.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * {@link DispatcherLeaderProcess} implementation which is stopped. This class
+ * is useful as the initial state of the {@link DispatcherRunnerImplNG}.
+ */
+public enum StoppedDispatcherLeaderProcess implements DispatcherLeaderProcess {
+	INSTANCE;
+
+	private static final CompletableFuture<Void> TERMINATION_FUTURE = CompletableFuture.completedFuture(null);
+	private static final UUID LEADER_SESSION_ID = new UUID(0L, 0L);
+	private static final CompletableFuture<String> NEVER_COMPLETED_FUTURE = new CompletableFuture<>();
+
+	@Override
+	public void start() {
+
+	}
+
+	@Override
+	public UUID getLeaderSessionId() {
+		return LEADER_SESSION_ID;
+	}
+
+	@Override
+	public CompletableFuture<DispatcherGateway> getDispatcherGateway() {
+		return null;
+	}
+
+	@Override
+	public CompletableFuture<String> getConfirmLeaderSessionFuture() {
+		return NEVER_COMPLETED_FUTURE;
+	}
+
+	@Override
+	public CompletableFuture<Void> closeAsync() {
+		return TERMINATION_FUTURE;
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java
new file mode 100644
index 00000000000..e6eb8002b9d
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherRunnerImplNGTest.java
@@ -0,0 +1,302 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.clusterframework.ApplicationStatus;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.runtime.dispatcher.DispatcherId;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
+import org.apache.flink.runtime.util.LeaderConnectionInfo;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;
+import org.apache.flink.runtime.webmonitor.TestingDispatcherGateway;
+import org.apache.flink.util.TestLogger;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for the {@link DispatcherRunnerImplNG}.
+ */
+public class DispatcherRunnerImplNGTest extends TestLogger {
+
+	private TestingLeaderElectionService testingLeaderElectionService;
+	private TestingFatalErrorHandler testingFatalErrorHandler;
+	private TestingDispatcherLeaderProcessFactory testingDispatcherLeaderProcessFactory;
+
+	@Before
+	public void setup() {
+		testingLeaderElectionService = new TestingLeaderElectionService();
+		testingFatalErrorHandler = new TestingFatalErrorHandler();
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.defaultValue();
+	}
+
+	@After
+	public void teardown() throws Exception {
+		if (testingLeaderElectionService != null) {
+			testingLeaderElectionService.stop();
+			testingLeaderElectionService = null;
+		}
+
+		if (testingFatalErrorHandler != null) {
+			testingFatalErrorHandler.rethrowError();
+			testingFatalErrorHandler = null;
+		}
+	}
+
+	@Test
+	public void closeAsync_withUncompletedShutDownFuture_completesShutDownFuture() throws Exception {
+		final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner();
+
+		final CompletableFuture<Void> terminationFuture = dispatcherRunner.closeAsync();
+		terminationFuture.get();
+
+		final CompletableFuture<ApplicationStatus> shutDownFuture = dispatcherRunner.getShutDownFuture();
+		assertThat(shutDownFuture.isDone(), is(true));
+		assertThat(shutDownFuture.get(), is(ApplicationStatus.UNKNOWN));
+	}
+
+	@Test
+	public void getDispatcherGateway_beforeDispatcherLeaderProcessCompletes_returnsDispatcherGateway() throws Exception {
+		final UUID leaderSessionId = UUID.randomUUID();
+		final TestingDispatcherGateway expectedDispatcherGateway = createDispatcherGateway(leaderSessionId);
+		final TestingDispatcherLeaderProcess testingDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(leaderSessionId)
+			.setDispatcherGatewayFuture(CompletableFuture.completedFuture(expectedDispatcherGateway))
+			.build();
+
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.from(testingDispatcherLeaderProcess);
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+
+			final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture = dispatcherRunner.getDispatcherGateway();
+
+			assertThat(dispatcherGatewayFuture.isDone(), is(false));
+
+			testingLeaderElectionService.isLeader(leaderSessionId);
+
+			assertThat(dispatcherGatewayFuture.get(), is(expectedDispatcherGateway));
+		}
+	}
+
+	@Test
+	public void getDispatcherGateway_withChangingLeaders_returnsLeadingDispatcherGateway() throws Exception {
+		final UUID firstLeaderSessionId = UUID.randomUUID();
+		final UUID secondLeaderSessionId = UUID.randomUUID();
+		final TestingDispatcherGateway firstDispatcherGateway = createDispatcherGateway(firstLeaderSessionId);
+		final TestingDispatcherGateway secondDispatcherGateway = createDispatcherGateway(secondLeaderSessionId);
+
+		final TestingDispatcherLeaderProcess firstDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(firstLeaderSessionId)
+			.setDispatcherGatewayFuture(CompletableFuture.completedFuture(firstDispatcherGateway))
+			.build();
+		final TestingDispatcherLeaderProcess secondDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(secondLeaderSessionId)
+			.setDispatcherGatewayFuture(CompletableFuture.completedFuture(secondDispatcherGateway))
+			.build();
+
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.from(
+			firstDispatcherLeaderProcess,
+			secondDispatcherLeaderProcess);
+
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+			testingLeaderElectionService.isLeader(firstLeaderSessionId);
+
+			final CompletableFuture<DispatcherGateway> firstDispatcherGatewayFuture = dispatcherRunner.getDispatcherGateway();
+
+			testingLeaderElectionService.notLeader();
+			testingLeaderElectionService.isLeader(secondLeaderSessionId);
+
+			final CompletableFuture<DispatcherGateway> secondDispatcherGatewayFuture = dispatcherRunner.getDispatcherGateway();
+
+			assertThat(firstDispatcherGatewayFuture.get(), is(firstDispatcherGateway));
+			assertThat(secondDispatcherGatewayFuture.get(), is(secondDispatcherGateway));
+		}
+	}
+
+	@Test
+	public void grantLeadership_withExistingLeader_waitsForTerminationOfFirstLeader() throws Exception {
+		final UUID firstLeaderSessionId = UUID.randomUUID();
+		final UUID secondLeaderSessionId = UUID.randomUUID();
+
+		final StartStopTestingDispatcherLeaderProcess firstTestingDispatcherLeaderProcess = StartStopTestingDispatcherLeaderProcess.create(firstLeaderSessionId);
+		final StartStopTestingDispatcherLeaderProcess secondTestingDispatcherLeaderProcess = StartStopTestingDispatcherLeaderProcess.create(secondLeaderSessionId);
+
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.from(
+			firstTestingDispatcherLeaderProcess.asTestingDispatcherLeaderProcess(),
+			secondTestingDispatcherLeaderProcess.asTestingDispatcherLeaderProcess());
+
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+			testingLeaderElectionService.isLeader(firstLeaderSessionId);
+
+			assertThat(firstTestingDispatcherLeaderProcess.isStarted(), is(true));
+
+			testingLeaderElectionService.isLeader(secondLeaderSessionId);
+
+			assertThat(secondTestingDispatcherLeaderProcess.isStarted(), is(false));
+			firstTestingDispatcherLeaderProcess.terminateProcess();
+			assertThat(secondTestingDispatcherLeaderProcess.isStarted(), is(true));
+			secondTestingDispatcherLeaderProcess.terminateProcess(); // make the dispatcherRunner terminate
+		}
+	}
+
+	@Test
+	public void grantLeadership_validLeader_confirmsLeaderSession() throws Exception {
+		final UUID leaderSessionId = UUID.randomUUID();
+
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+			testingLeaderElectionService.isLeader(leaderSessionId);
+
+			final CompletableFuture<LeaderConnectionInfo> confirmationFuture = testingLeaderElectionService.getConfirmationFuture();
+
+			final LeaderConnectionInfo leaderConnectionInfo = confirmationFuture.get();
+			assertThat(leaderConnectionInfo.getLeaderSessionId(), is(leaderSessionId));
+		}
+	}
+
+	@Test
+	public void grantLeadership_oldLeader_doesNotConfirmLeaderSession() throws Exception {
+		final UUID leaderSessionId = UUID.randomUUID();
+		final CompletableFuture<String> contenderConfirmationFuture = new CompletableFuture<>();
+		final TestingDispatcherLeaderProcess testingDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(leaderSessionId)
+			.setConfirmLeaderSessionFuture(contenderConfirmationFuture)
+			.build();
+
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.from(testingDispatcherLeaderProcess);
+
+		try (final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner()) {
+			testingLeaderElectionService.isLeader(leaderSessionId);
+
+			testingLeaderElectionService.notLeader();
+
+			// complete the confirmation future after losing the leadership
+			contenderConfirmationFuture.complete("leader address");
+
+			final CompletableFuture<LeaderConnectionInfo> leaderElectionConfirmationFuture = testingLeaderElectionService.getConfirmationFuture();
+
+			try {
+				leaderElectionConfirmationFuture.get(5L, TimeUnit.MILLISECONDS);
+				fail("No valid leader should exist.");
+			} catch (TimeoutException expected) {}
+		}
+	}
+
+	@Test
+	public void grantLeadership_multipleLeaderChanges_lastDispatcherLeaderProcessWaitsForOthersToTerminateBeforeItStarts() throws Exception {
+		final UUID firstLeaderSession = UUID.randomUUID();
+		final UUID secondLeaderSession = UUID.randomUUID();
+		final UUID thirdLeaderSession = UUID.randomUUID();
+
+		final CompletableFuture<Void> firstDispatcherLeaderProcessTerminationFuture = new CompletableFuture<>();
+		final TestingDispatcherLeaderProcess firstDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(firstLeaderSession)
+			.setCloseAsyncSupplier(() -> firstDispatcherLeaderProcessTerminationFuture)
+			.build();
+		final CompletableFuture<Void> secondDispatcherLeaderProcessTerminationFuture = new CompletableFuture<>();
+		final TestingDispatcherLeaderProcess secondDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(secondLeaderSession)
+			.setCloseAsyncSupplier(() -> secondDispatcherLeaderProcessTerminationFuture)
+			.build();
+		final CompletableFuture<Void> thirdDispatcherLeaderProcessHasBeenStartedFuture = new CompletableFuture<>();
+		final TestingDispatcherLeaderProcess thirdDispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(thirdLeaderSession)
+			.setStartConsumer(thirdDispatcherLeaderProcessHasBeenStartedFuture::complete)
+			.build();
+
+		testingDispatcherLeaderProcessFactory = TestingDispatcherLeaderProcessFactory.from(
+			firstDispatcherLeaderProcess,
+			secondDispatcherLeaderProcess,
+			thirdDispatcherLeaderProcess);
+
+		final DispatcherRunnerImplNG dispatcherRunner = createDispatcherRunner();
+
+		try {
+			testingLeaderElectionService.isLeader(firstLeaderSession);
+			testingLeaderElectionService.isLeader(secondLeaderSession);
+			testingLeaderElectionService.isLeader(thirdLeaderSession);
+
+			firstDispatcherLeaderProcessTerminationFuture.complete(null);
+
+			assertThat(thirdDispatcherLeaderProcessHasBeenStartedFuture.isDone(), is(false));
+
+			secondDispatcherLeaderProcessTerminationFuture.complete(null);
+
+			assertThat(thirdDispatcherLeaderProcessHasBeenStartedFuture.isDone(), is(true));
+		} finally {
+			firstDispatcherLeaderProcessTerminationFuture.complete(null);
+			secondDispatcherLeaderProcessTerminationFuture.complete(null);
+
+			dispatcherRunner.close();
+		}
+	}
+
+	private static class StartStopTestingDispatcherLeaderProcess {
+
+		private final TestingDispatcherLeaderProcess testingDispatcherLeaderProcess;
+		private final CompletableFuture<Void> startFuture;
+		private final CompletableFuture<Void> terminationFuture;
+
+		private StartStopTestingDispatcherLeaderProcess(
+				TestingDispatcherLeaderProcess testingDispatcherLeaderProcess,
+				CompletableFuture<Void> startFuture,
+				CompletableFuture<Void> terminationFuture) {
+			this.testingDispatcherLeaderProcess = testingDispatcherLeaderProcess;
+			this.startFuture = startFuture;
+			this.terminationFuture = terminationFuture;
+		}
+
+		private TestingDispatcherLeaderProcess asTestingDispatcherLeaderProcess() {
+			return testingDispatcherLeaderProcess;
+		}
+
+		private boolean isStarted() {
+			return startFuture.isDone();
+		}
+
+		private void terminateProcess() {
+			terminationFuture.complete(null);
+		}
+
+		private static StartStopTestingDispatcherLeaderProcess create(UUID leaderSessionId) {
+			final CompletableFuture<Void> processStartFuture = new CompletableFuture<>();
+			final CompletableFuture<Void> processTerminationFuture = new CompletableFuture<>();
+			final TestingDispatcherLeaderProcess dispatcherLeaderProcess = TestingDispatcherLeaderProcess.newBuilder(leaderSessionId)
+				.setStartConsumer(processStartFuture::complete)
+				.setCloseAsyncSupplier(() -> processTerminationFuture)
+				.build();
+
+			return new StartStopTestingDispatcherLeaderProcess(dispatcherLeaderProcess, processStartFuture, processTerminationFuture);
+		}
+	}
+
+	private TestingDispatcherGateway createDispatcherGateway(UUID leaderSessionId) {
+		return new TestingDispatcherGateway.Builder()
+			.setFencingToken(DispatcherId.fromUuid(leaderSessionId))
+			.build();
+	}
+
+	private DispatcherRunnerImplNG createDispatcherRunner() throws Exception {
+		return new DispatcherRunnerImplNG(
+			testingLeaderElectionService,
+			testingFatalErrorHandler,
+			testingDispatcherLeaderProcessFactory);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherLeaderProcess.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherLeaderProcess.java
new file mode 100644
index 00000000000..7f4d51ae3ad
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherLeaderProcess.java
@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+class TestingDispatcherLeaderProcess implements DispatcherLeaderProcess {
+	private final UUID leaderSessionId;
+
+	private final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture;
+	private final Consumer<Void> startConsumer;
+	private final Supplier<CompletableFuture<Void>> closeAsyncSupplier;
+	private final CompletableFuture<String> confirmLeaderSessionFuture;
+
+	private CompletableFuture<Void> terminationFuture = null;
+
+	private TestingDispatcherLeaderProcess(
+			UUID leaderSessionId,
+			CompletableFuture<DispatcherGateway> dispatcherGatewayFuture,
+			Consumer<Void> startConsumer,
+			Supplier<CompletableFuture<Void>> closeAsyncSupplier,
+			CompletableFuture<String> confirmLeaderSessionFuture) {
+		this.leaderSessionId = leaderSessionId;
+		this.dispatcherGatewayFuture = dispatcherGatewayFuture;
+		this.startConsumer = startConsumer;
+		this.closeAsyncSupplier = closeAsyncSupplier;
+		this.confirmLeaderSessionFuture = confirmLeaderSessionFuture;
+	}
+
+	@Override
+	public void start() {
+		startConsumer.accept(null);
+	}
+
+	@Override
+	public UUID getLeaderSessionId() {
+		return leaderSessionId;
+	}
+
+	@Override
+	public CompletableFuture<DispatcherGateway> getDispatcherGateway() {
+		return dispatcherGatewayFuture;
+	}
+
+	@Override
+	public CompletableFuture<String> getConfirmLeaderSessionFuture() {
+		return confirmLeaderSessionFuture;
+	}
+
+	@Override
+	public CompletableFuture<Void> closeAsync() {
+		if (terminationFuture == null) {
+			terminationFuture = closeAsyncSupplier.get();
+		}
+
+		return terminationFuture;
+	}
+
+	public static Builder newBuilder(UUID leaderSessionId) {
+		return new Builder(leaderSessionId);
+	}
+
+	public static class Builder {
+		private final UUID leaderSessionId;
+
+		private CompletableFuture<DispatcherGateway> dispatcherGatewayFuture = new CompletableFuture<>();
+
+		private Consumer<Void> startConsumer = (ignored) -> {};
+
+		private Supplier<CompletableFuture<Void>> closeAsyncSupplier = () -> CompletableFuture.completedFuture(null);
+
+		private CompletableFuture<String> confirmLeaderSessionFuture = CompletableFuture.completedFuture("Unknown address");
+
+		private Builder(UUID leaderSessionId) {
+			this.leaderSessionId = leaderSessionId;
+		}
+
+		public Builder setDispatcherGatewayFuture(CompletableFuture<DispatcherGateway> dispatcherGatewayFuture) {
+			this.dispatcherGatewayFuture = dispatcherGatewayFuture;
+			return this;
+		}
+
+		public Builder setStartConsumer(Consumer<Void> startConsumer) {
+			this.startConsumer = startConsumer;
+			return this;
+		}
+
+		public Builder setCloseAsyncSupplier(Supplier<CompletableFuture<Void>> closeAsyncSupplier) {
+			this.closeAsyncSupplier = closeAsyncSupplier;
+			return this;
+		}
+
+		public Builder setConfirmLeaderSessionFuture(CompletableFuture<String> confirmLeaderSessionFuture) {
+			this.confirmLeaderSessionFuture = confirmLeaderSessionFuture;
+			return this;
+		}
+
+		public TestingDispatcherLeaderProcess build() {
+			return new TestingDispatcherLeaderProcess(
+				leaderSessionId,
+				dispatcherGatewayFuture,
+				startConsumer,
+				closeAsyncSupplier,
+				confirmLeaderSessionFuture);
+		}
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherLeaderProcessFactory.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherLeaderProcessFactory.java
new file mode 100644
index 00000000000..cb434072197
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherLeaderProcessFactory.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.util.Preconditions;
+
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.Queue;
+import java.util.UUID;
+
+class TestingDispatcherLeaderProcessFactory implements DispatcherLeaderProcessFactory {
+	private final Queue<TestingDispatcherLeaderProcess> processes;
+
+	private TestingDispatcherLeaderProcessFactory(Queue<TestingDispatcherLeaderProcess> processes) {
+		this.processes = processes;
+	}
+
+	@Override
+	public TestingDispatcherLeaderProcess create(UUID leaderSessionID) {
+		if (processes.isEmpty()) {
+			return TestingDispatcherLeaderProcess.newBuilder(leaderSessionID).build();
+		} else {
+			final TestingDispatcherLeaderProcess nextProcess = processes.poll();
+			Preconditions.checkState(leaderSessionID.equals(nextProcess.getLeaderSessionId()));
+
+			return nextProcess;
+		}
+	}
+
+	public static TestingDispatcherLeaderProcessFactory from(TestingDispatcherLeaderProcess... processes) {
+		return new TestingDispatcherLeaderProcessFactory(new ArrayDeque<>(Arrays.asList(processes)));
+	}
+
+	public static TestingDispatcherLeaderProcessFactory defaultValue() {
+		return new TestingDispatcherLeaderProcessFactory(new ArrayDeque<>(0));
+	}
+}
