diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
new file mode 100644
index 00000000000..b079ab141c0
--- /dev/null
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImpl.java
@@ -0,0 +1,415 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.dispatcher.Dispatcher;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.runtime.rpc.RpcUtils;
+import org.apache.flink.runtime.webmonitor.RestfulGateway;
+import org.apache.flink.util.AutoCloseableAsync;
+import org.apache.flink.util.ExceptionUtils;
+import org.apache.flink.util.FlinkRuntimeException;
+import org.apache.flink.util.Preconditions;
+import org.apache.flink.util.function.FunctionUtils;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+/**
+ * Process which encapsulates the job recovery logic and life cycle management of a
+ * {@link Dispatcher}.
+ */
+public class DispatcherLeaderProcessImpl implements DispatcherLeaderProcess, JobGraphStore.JobGraphListener {
+
+	private static final Logger LOG = LoggerFactory.getLogger(DispatcherLeaderProcessImpl.class);
+
+	private final Object lock = new Object();
+
+	private final UUID leaderSessionId;
+
+	private final DispatcherServiceFactory dispatcherFactory;
+
+	private final JobGraphStore jobGraphStore;
+
+	private final Executor ioExecutor;
+
+	private final FatalErrorHandler fatalErrorHandler;
+
+	private final CompletableFuture<DispatcherGateway> dispatcherGatewayFuture;
+
+	private final CompletableFuture<String> confirmLeaderSessionFuture;
+
+	private final CompletableFuture<Void> terminationFuture;
+
+	private State state;
+
+	@Nullable
+	private DispatcherService dispatcher;
+
+	private CompletableFuture<Void> onGoingRecoveryOperation = FutureUtils.completedVoidFuture();
+
+	private DispatcherLeaderProcessImpl(
+			UUID leaderSessionId,
+			DispatcherServiceFactory dispatcherFactory,
+			JobGraphStore jobGraphStore,
+			Executor ioExecutor,
+			FatalErrorHandler fatalErrorHandler) {
+		this.leaderSessionId = leaderSessionId;
+		this.dispatcherFactory = dispatcherFactory;
+		this.jobGraphStore = jobGraphStore;
+		this.ioExecutor = ioExecutor;
+		this.fatalErrorHandler = fatalErrorHandler;
+
+		this.dispatcherGatewayFuture = new CompletableFuture<>();
+		this.confirmLeaderSessionFuture = dispatcherGatewayFuture.thenApply(RestfulGateway::getAddress);
+		this.terminationFuture = new CompletableFuture<>();
+
+		this.state = State.CREATED;
+		this.dispatcher = null;
+	}
+
+	State getState() {
+		synchronized (lock) {
+			return state;
+		}
+	}
+
+	@Override
+	public void start() {
+		runIfStateIs(
+			State.CREATED,
+			this::startInternal);
+	}
+
+	private void startInternal() {
+		LOG.info("Start {}.", getClass().getSimpleName());
+		state = State.RUNNING;
+		startServices();
+
+		onGoingRecoveryOperation = recoverJobsAsync()
+			.thenAccept(this::createDispatcherIfRunning)
+			.handle(this::onErrorIfRunning);
+	}
+
+	private void startServices() {
+		try {
+			jobGraphStore.start(this);
+		} catch (Exception e) {
+			throw new FlinkRuntimeException(
+				String.format(
+					"Could not start %s when trying to start the %s.",
+					jobGraphStore.getClass().getSimpleName(),
+					getClass().getSimpleName()),
+				e);
+		}
+	}
+
+	private <T> Void onErrorIfRunning(T ignored, Throwable throwable) {
+		synchronized (lock) {
+			if (state != State.RUNNING) {
+				return null;
+			}
+		}
+
+		if (throwable != null) {
+			closeAsync();
+			fatalErrorHandler.onFatalError(throwable);
+		}
+
+		return null;
+	}
+
+	private void createDispatcherIfRunning(Collection<JobGraph> jobGraphs) {
+		runIfStateIs(State.RUNNING, () -> createDispatcher(jobGraphs));
+	}
+
+	private void createDispatcher(Collection<JobGraph> jobGraphs) {
+		dispatcher = dispatcherFactory.create(jobGraphs, jobGraphStore);
+		dispatcherGatewayFuture.complete(dispatcher.getGateway());
+	}
+
+	private CompletableFuture<Collection<JobGraph>> recoverJobsAsync() {
+		return CompletableFuture.supplyAsync(
+			this::recoverJobsIfRunning,
+			ioExecutor);
+	}
+
+	private Collection<JobGraph> recoverJobsIfRunning() {
+		return supplyUnsynchronizedIfRunning(this::recoverJobs).orElse(Collections.emptyList());
+
+	}
+
+	private Collection<JobGraph> recoverJobs() {
+		LOG.info("Recover all persisted job graphs.");
+		final Collection<JobID> jobIds = getJobIds();
+		final Collection<JobGraph> recoveredJobGraphs = new ArrayList<>();
+
+		for (JobID jobId : jobIds) {
+			recoveredJobGraphs.add(recoverJob(jobId));
+		}
+
+		LOG.info("Successfully recovered {} persisted job graphs.", recoveredJobGraphs.size());
+
+		return recoveredJobGraphs;
+	}
+
+	private Collection<JobID> getJobIds() {
+		try {
+			return jobGraphStore.getJobIds();
+		} catch (Exception e) {
+			throw new FlinkRuntimeException(
+				"Could not retrieve job ids of persisted jobs.",
+				e);
+		}
+	}
+
+	private JobGraph recoverJob(JobID jobId) {
+		LOG.info("Trying to recover job with job id {}.", jobId);
+		try {
+			return jobGraphStore.recoverJobGraph(jobId);
+		} catch (Exception e) {
+			throw new FlinkRuntimeException(
+				String.format("Could not recover job with job id %s.", jobId),
+				e);
+		}
+	}
+
+	@Override
+	public UUID getLeaderSessionId() {
+		return leaderSessionId;
+	}
+
+	@Override
+	public CompletableFuture<DispatcherGateway> getDispatcherGateway() {
+		return dispatcherGatewayFuture;
+	}
+
+	@Override
+	public CompletableFuture<String> getConfirmLeaderSessionFuture() {
+		return confirmLeaderSessionFuture;
+	}
+
+	@Override
+	public CompletableFuture<Void> closeAsync() {
+		runIfStateIsNot(
+			State.STOPPED,
+			this::closeInternal);
+
+		return terminationFuture;
+	}
+
+	private void closeInternal() {
+		LOG.info("Stopping {}.", getClass().getSimpleName());
+		final CompletableFuture<Void> dispatcherTerminationFuture;
+
+		if (dispatcher != null) {
+			dispatcherTerminationFuture = dispatcher.closeAsync();
+		} else {
+			dispatcherTerminationFuture = FutureUtils.completedVoidFuture();
+		}
+
+		final CompletableFuture<Void> stopServicesFuture = FutureUtils.runAfterwardsAsync(
+			dispatcherTerminationFuture,
+			this::stopServices,
+			ioExecutor);
+
+		FutureUtils.forward(
+			stopServicesFuture,
+			terminationFuture);
+
+		state = State.STOPPED;
+	}
+
+	private void stopServices() throws Exception {
+		Exception exception = null;
+
+		try {
+			jobGraphStore.stop();
+		} catch (Exception e) {
+			exception = e;
+		}
+
+		ExceptionUtils.tryRethrowException(exception);
+	}
+
+	// ------------------------------------------------------------
+	// JobGraphListener
+	// ------------------------------------------------------------
+
+	@Override
+	public void onAddedJobGraph(JobID jobId) {
+		runIfStateIs(
+			State.RUNNING,
+			() -> handleAddedJobGraph(jobId));
+	}
+
+	private void handleAddedJobGraph(JobID jobId) {
+		// serialize all ongoing recovery operations
+		onGoingRecoveryOperation = onGoingRecoveryOperation
+			.thenApplyAsync(
+				ignored -> recoverJobIfRunning(jobId),
+				ioExecutor)
+			.thenCompose(optionalJobGraph -> optionalJobGraph
+				.flatMap(this::submitAddedJobIfRunning)
+				.orElse(FutureUtils.completedVoidFuture()))
+			.handle(this::onErrorIfRunning);
+	}
+
+	private Optional<CompletableFuture<Void>> submitAddedJobIfRunning(JobGraph jobGraph) {
+		return supplyIfRunning(() -> submitAddedJob(jobGraph));
+	}
+
+	private CompletableFuture<Void> submitAddedJob(JobGraph jobGraph) {
+		final DispatcherGateway dispatcherGateway = getDispatcherGatewayInternal();
+
+		// TODO: Filter out duplicate job submissions which can happen with the JobGraphListener
+		return dispatcherGateway
+			.submitJob(jobGraph, RpcUtils.INF_TIMEOUT)
+			.thenApply(FunctionUtils.nullFn());
+	}
+
+	private DispatcherGateway getDispatcherGatewayInternal() {
+		return Preconditions.checkNotNull(dispatcherGatewayFuture.getNow(null));
+	}
+
+	private Optional<JobGraph> recoverJobIfRunning(JobID jobId) {
+		return supplyUnsynchronizedIfRunning(() -> recoverJob(jobId));
+	}
+
+	@Override
+	public void onRemovedJobGraph(JobID jobId) {
+		runIfStateIs(
+			State.RUNNING,
+			() -> handleRemovedJobGraph(jobId));
+	}
+
+	private void handleRemovedJobGraph(JobID jobId) {
+		onGoingRecoveryOperation = onGoingRecoveryOperation
+			.thenCompose(ignored -> removeJobGraphIfRunning(jobId).orElse(FutureUtils.completedVoidFuture()))
+			.handle(this::onErrorIfRunning);
+	}
+
+	private Optional<CompletableFuture<Void>> removeJobGraphIfRunning(JobID jobId) {
+		return supplyIfRunning(() -> removeJobGraph(jobId));
+	}
+
+	private CompletableFuture<Void> removeJobGraph(JobID jobId) {
+		final DispatcherGateway dispatcherGateway = getDispatcherGatewayInternal();
+
+		// TODO: replace cancel with other fail method
+		return dispatcherGateway
+			.cancelJob(jobId, RpcUtils.INF_TIMEOUT)
+			.thenApply(FunctionUtils.nullFn());
+	}
+
+	// ---------------------------------------------------------------
+	// Factory methods
+	// ---------------------------------------------------------------
+
+	public static DispatcherLeaderProcessImpl create(
+			UUID leaderSessionId,
+			DispatcherServiceFactory dispatcherFactory,
+			JobGraphStore jobGraphStore,
+			Executor ioExecutor,
+			FatalErrorHandler fatalErrorHandler) {
+		return new DispatcherLeaderProcessImpl(
+			leaderSessionId,
+			dispatcherFactory,
+			jobGraphStore,
+			ioExecutor,
+			fatalErrorHandler);
+	}
+
+	// ---------------------------------------------------------------
+	// Internal helper methods
+	// ---------------------------------------------------------------
+
+	private <V> Optional<V> supplyUnsynchronizedIfRunning(Supplier<V> supplier) {
+		synchronized (lock) {
+			if (state != State.RUNNING) {
+				return Optional.empty();
+			}
+		}
+
+		return Optional.of(supplier.get());
+	}
+
+	private <V> Optional<V> supplyIfRunning(Supplier<V> supplier) {
+		synchronized (lock) {
+			if (state != State.RUNNING) {
+				return Optional.empty();
+			}
+
+			return Optional.of(supplier.get());
+		}
+	}
+
+	private void runIfStateIs(State expectedState, Runnable action) {
+		runIfState(expectedState::equals, action);
+	}
+
+	private void runIfStateIsNot(State notExpectedState, Runnable action) {
+		runIfState(
+			state -> !notExpectedState.equals(state),
+			action);
+	}
+
+	private void runIfState(Predicate<State> actionPredicate, Runnable action) {
+		synchronized (lock) {
+			if (actionPredicate.test(state)) {
+				action.run();
+			}
+		}
+	}
+
+	// ------------------------------------------------------------
+	// Internal classes
+	// ------------------------------------------------------------
+
+	interface DispatcherServiceFactory {
+		DispatcherService create(Collection<JobGraph> recoveredJobs, JobGraphStore jobGraphStore);
+	}
+
+	interface DispatcherService extends AutoCloseableAsync {
+		DispatcherGateway getGateway();
+	}
+
+	enum State {
+		CREATED,
+		RUNNING,
+		STOPPED
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
new file mode 100644
index 00000000000..02ad01041b1
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/DispatcherLeaderProcessImplTest.java
@@ -0,0 +1,250 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.core.testutils.OneShotLatch;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobmanager.JobGraphStore;
+import org.apache.flink.runtime.testutils.TestingJobGraphStore;
+import org.apache.flink.runtime.util.TestingFatalErrorHandler;
+import org.apache.flink.runtime.webmonitor.TestingDispatcherGateway;
+import org.apache.flink.util.ExecutorUtils;
+import org.apache.flink.util.TestLogger;
+import org.apache.flink.util.function.BiFunctionWithException;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.hamcrest.Matchers.hasSize;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for the {@link DispatcherLeaderProcessImpl}.
+ */
+public class DispatcherLeaderProcessImplTest extends TestLogger {
+
+	private static final JobGraph PERSISTED_JOB_GRAPH = new JobGraph("Persisted JobGraph");
+
+	private static ExecutorService ioExecutor;
+
+	private final UUID leaderSessionId = UUID.randomUUID();
+
+	private TestingFatalErrorHandler fatalErrorHandler;
+
+	private JobGraphStore jobGraphStore;
+
+	private TestingDispatcherServiceFactory dispatcherServiceFactory;
+
+	@BeforeClass
+	public static void setupClass() {
+		ioExecutor = Executors.newSingleThreadExecutor();
+	}
+
+	@Before
+	public void setup() {
+		fatalErrorHandler = new TestingFatalErrorHandler();
+		jobGraphStore = TestingJobGraphStore.newBuilder().build();
+		dispatcherServiceFactory = TestingDispatcherServiceFactory.newBuilder().build();
+	}
+
+	@After
+	public void teardown() throws Exception {
+		if (fatalErrorHandler != null) {
+			fatalErrorHandler.rethrowError();
+			fatalErrorHandler = null;
+		}
+	}
+
+	@AfterClass
+	public static void teardownClass() {
+		if (ioExecutor != null) {
+			ExecutorUtils.gracefulShutdown(5L, TimeUnit.SECONDS, ioExecutor);
+		}
+	}
+
+	@Test
+	public void start_afterClose_doesNotHaveAnEffect() throws Exception {
+		final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess();
+
+		dispatcherLeaderProcess.close();
+		dispatcherLeaderProcess.start();
+
+		assertThat(dispatcherLeaderProcess.getState(), is(DispatcherLeaderProcessImpl.State.STOPPED));
+	}
+
+	@Test
+	public void start_triggersJobGraphRecoveryAndDispatcherServiceCreation() throws Exception {
+		jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setInitialJobGraphs(Collections.singleton(PERSISTED_JOB_GRAPH))
+			.build();
+
+		final CompletableFuture<Collection<JobGraph>> recoveredJobGraphsFuture = new CompletableFuture<>();
+		dispatcherServiceFactory = TestingDispatcherServiceFactory.newBuilder()
+			.setCreateFunction(
+				(recoveredJobGraphs, jobGraphStore) -> {
+					recoveredJobGraphsFuture.complete(recoveredJobGraphs);
+					return TestingDispatcherService.newBuilder().build();
+				}
+			)
+			.build();
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+			assertThat(dispatcherLeaderProcess.getState(), is(DispatcherLeaderProcessImpl.State.RUNNING));
+
+			final Collection<JobGraph> recoveredJobGraphs = recoveredJobGraphsFuture.get();
+
+			assertThat(recoveredJobGraphs, hasSize(1));
+			assertThat(recoveredJobGraphs, containsInAnyOrder(PERSISTED_JOB_GRAPH));
+		}
+	}
+
+	@Test
+	public void closeAsync_stopsJobGraphStoreAndDispatcher() throws Exception {
+		final CompletableFuture<Void> jobGraphStopFuture = new CompletableFuture<>();
+		jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setStopRunnable(() -> jobGraphStopFuture.complete(null))
+			.build();
+
+		final CompletableFuture<Void> dispatcherServiceTerminationFuture = new CompletableFuture<>();
+		final OneShotLatch dispatcherServiceShutdownLatch = new OneShotLatch();
+		dispatcherServiceFactory = TestingDispatcherServiceFactory.newBuilder()
+			.setCreateFunction((ignoredA, ignoredB) -> TestingDispatcherService.newBuilder()
+				.setTerminationFutureSupplier(() -> {
+					dispatcherServiceShutdownLatch.trigger();
+					return dispatcherServiceTerminationFuture;
+				})
+				.build())
+			.build();
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+
+			// wait for the creation of the DispatcherService
+			dispatcherLeaderProcess.getDispatcherGateway().get();
+
+			final CompletableFuture<Void> terminationFuture = dispatcherLeaderProcess.closeAsync();
+
+			assertThat(jobGraphStopFuture.isDone(), is(false));
+			assertThat(terminationFuture.isDone(), is(false));
+
+			dispatcherServiceShutdownLatch.await();
+			dispatcherServiceTerminationFuture.complete(null);
+
+			// verify that we shut down the JobGraphStore
+			jobGraphStopFuture.get();
+
+			// verify that we completed the dispatcher leader process shut down
+			terminationFuture.get();
+		}
+	}
+
+	@Test
+	public void confirmLeaderSessionFuture_completesAfterDispatcherServiceHasBeenStarted() throws Exception {
+		final OneShotLatch createDispatcherServiceLatch = new OneShotLatch();
+		final String dispatcherAddress = "myAddress";
+		final TestingDispatcherGateway dispatcherGateway = new TestingDispatcherGateway.Builder()
+			.setAddress(dispatcherAddress)
+			.build();
+
+		dispatcherServiceFactory = TestingDispatcherServiceFactory.newBuilder()
+			.setCreateFunction(
+				BiFunctionWithException.unchecked((ignoredA, ignoredB) -> {
+					createDispatcherServiceLatch.await();
+					return TestingDispatcherService.newBuilder()
+						.setDispatcherGateway(dispatcherGateway)
+						.build();
+				}))
+			.build();
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			final CompletableFuture<String> confirmLeaderSessionFuture = dispatcherLeaderProcess.getConfirmLeaderSessionFuture();
+
+			dispatcherLeaderProcess.start();
+
+			assertThat(confirmLeaderSessionFuture.isDone(), is(false));
+
+			createDispatcherServiceLatch.trigger();
+
+			assertThat(confirmLeaderSessionFuture.get(), is(dispatcherAddress));
+		}
+	}
+
+	@Test
+	public void closeAsync_duringJobRecovery_preventsDispatcherServiceCreation() throws Exception {
+		final OneShotLatch jobRecoveryStarted = new OneShotLatch();
+		final OneShotLatch completeJobRecovery = new OneShotLatch();
+		final OneShotLatch createDispatcherService = new OneShotLatch();
+
+		this.jobGraphStore = TestingJobGraphStore.newBuilder()
+			.setJobIdsFunction(storedJobs -> {
+				jobRecoveryStarted.trigger();
+				completeJobRecovery.await();
+				return storedJobs;
+			})
+			.build();
+
+		this.dispatcherServiceFactory = TestingDispatcherServiceFactory.newBuilder()
+			.setCreateFunction(
+				(ignoredA, ignoredB) -> {
+					createDispatcherService.trigger();
+					return TestingDispatcherService.newBuilder().build();
+				})
+			.build();
+
+		try (final DispatcherLeaderProcessImpl dispatcherLeaderProcess = createDispatcherLeaderProcess()) {
+			dispatcherLeaderProcess.start();
+
+			jobRecoveryStarted.await();
+
+			dispatcherLeaderProcess.closeAsync();
+
+			completeJobRecovery.trigger();
+
+			try {
+				createDispatcherService.await(10L, TimeUnit.MILLISECONDS);
+				fail("No dispatcher service should be created after the process has been stopped.");
+			} catch (TimeoutException expected) {}
+		}
+	}
+
+	private DispatcherLeaderProcessImpl createDispatcherLeaderProcess() {
+		return DispatcherLeaderProcessImpl.create(
+			leaderSessionId,
+			dispatcherServiceFactory,
+			jobGraphStore,
+			ioExecutor,
+			fatalErrorHandler);
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherService.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherService.java
new file mode 100644
index 00000000000..9e9ba7d2473
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherService.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.concurrent.FutureUtils;
+import org.apache.flink.runtime.dispatcher.DispatcherGateway;
+import org.apache.flink.runtime.webmonitor.TestingDispatcherGateway;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Supplier;
+
+class TestingDispatcherService implements DispatcherLeaderProcessImpl.DispatcherService {
+
+	private final Object lock = new Object();
+
+	private final Supplier<CompletableFuture<Void>> terminationFutureSupplier;
+
+	private final DispatcherGateway dispatcherGateway;
+
+	private CompletableFuture<Void> terminationFuture;
+
+	private TestingDispatcherService(Supplier<CompletableFuture<Void>> terminationFutureSupplier, DispatcherGateway dispatcherGateway) {
+		this.terminationFutureSupplier = terminationFutureSupplier;
+		this.dispatcherGateway = dispatcherGateway;
+	}
+
+	@Override
+	public DispatcherGateway getGateway() {
+		return dispatcherGateway;
+	}
+
+	@Override
+	public CompletableFuture<Void> closeAsync() {
+		synchronized (lock) {
+			if (terminationFuture == null) {
+				terminationFuture = terminationFutureSupplier.get();
+			}
+
+			return terminationFuture;
+		}
+	}
+
+	public static Builder newBuilder() {
+		return new Builder();
+	}
+
+	public static class Builder {
+
+		private Supplier<CompletableFuture<Void>> terminationFutureSupplier = FutureUtils::completedVoidFuture;
+
+		private DispatcherGateway dispatcherGateway = new TestingDispatcherGateway.Builder().build();
+
+		private Builder() {}
+
+		public Builder setTerminationFutureSupplier(Supplier<CompletableFuture<Void>> terminationFutureSupplier) {
+			this.terminationFutureSupplier = terminationFutureSupplier;
+			return this;
+		}
+
+		public Builder setDispatcherGateway(DispatcherGateway dispatcherGateway) {
+			this.dispatcherGateway = dispatcherGateway;
+			return this;
+		}
+
+		public TestingDispatcherService build() {
+			return new TestingDispatcherService(terminationFutureSupplier, dispatcherGateway);
+		}
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherServiceFactory.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherServiceFactory.java
new file mode 100644
index 00000000000..7b0faeed98c
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/runner/TestingDispatcherServiceFactory.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher.runner;
+
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobmanager.JobGraphStore;
+
+import java.util.Collection;
+import java.util.function.BiFunction;
+
+class TestingDispatcherServiceFactory implements DispatcherLeaderProcessImpl.DispatcherServiceFactory {
+	private final BiFunction<Collection<JobGraph>, JobGraphStore, DispatcherLeaderProcessImpl.DispatcherService> createFunction;
+
+	private TestingDispatcherServiceFactory(BiFunction<Collection<JobGraph>, JobGraphStore, DispatcherLeaderProcessImpl.DispatcherService> createFunction) {
+		this.createFunction = createFunction;
+	}
+
+	@Override
+	public DispatcherLeaderProcessImpl.DispatcherService create(Collection<JobGraph> recoveredJobs, JobGraphStore jobGraphStore) {
+		return createFunction.apply(recoveredJobs, jobGraphStore);
+	}
+
+	public static Builder newBuilder() {
+		return new Builder();
+	}
+
+	public static class Builder {
+		private BiFunction<Collection<JobGraph>, JobGraphStore, DispatcherLeaderProcessImpl.DispatcherService> createFunction = (ignoredA, ignoredB) -> TestingDispatcherService.newBuilder().build();
+
+		private Builder() {}
+
+		Builder setCreateFunction(BiFunction<Collection<JobGraph>, JobGraphStore, DispatcherLeaderProcessImpl.DispatcherService> createFunction) {
+			this.createFunction = createFunction;
+			return this;
+		}
+
+		public TestingDispatcherServiceFactory build() {
+			return new TestingDispatcherServiceFactory(createFunction);
+		}
+	}
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java
index bdf6f0b56c6..0376d448546 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/testutils/TestingJobGraphStore.java
@@ -65,7 +65,8 @@ public class TestingJobGraphStore implements JobGraphStore {
 			BiFunctionWithException<JobID, Map<JobID, JobGraph>, JobGraph, ? extends Exception> recoverJobGraphFunction,
 			ThrowingConsumer<JobGraph, ? extends Exception> putJobGraphConsumer,
 			ThrowingConsumer<JobID, ? extends Exception> removeJobGraphConsumer,
-			ThrowingConsumer<JobID, ? extends Exception> releaseJobGraphConsumer) {
+			ThrowingConsumer<JobID, ? extends Exception> releaseJobGraphConsumer,
+			Collection<JobGraph> initialJobGraphs) {
 		this.startConsumer = startConsumer;
 		this.stopRunnable = stopRunnable;
 		this.jobIdsFunction = jobIdsFunction;
@@ -73,6 +74,10 @@ public class TestingJobGraphStore implements JobGraphStore {
 		this.putJobGraphConsumer = putJobGraphConsumer;
 		this.removeJobGraphConsumer = removeJobGraphConsumer;
 		this.releaseJobGraphConsumer = releaseJobGraphConsumer;
+
+		for (JobGraph initialJobGraph : initialJobGraphs) {
+			storedJobs.put(initialJobGraph.getJobID(), initialJobGraph);
+		}
 	}
 
 	@Override
@@ -146,6 +151,8 @@ public class TestingJobGraphStore implements JobGraphStore {
 
 		private ThrowingConsumer<JobID, ? extends Exception> releaseJobGraphConsumer = ignored -> {};
 
+		private Collection<JobGraph> initialJobGraphs = Collections.emptyList();
+
 		private Builder() {}
 
 		public Builder setStartConsumer(ThrowingConsumer<JobGraphListener, ? extends Exception> startConsumer) {
@@ -183,6 +190,11 @@ public class TestingJobGraphStore implements JobGraphStore {
 			return this;
 		}
 
+		public Builder setInitialJobGraphs(Collection<JobGraph> initialJobGraphs) {
+			this.initialJobGraphs = initialJobGraphs;
+			return this;
+		}
+
 		public TestingJobGraphStore build() {
 			return new TestingJobGraphStore(
 				startConsumer,
@@ -191,7 +203,8 @@ public class TestingJobGraphStore implements JobGraphStore {
 				recoverJobGraphFunction,
 				putJobGraphConsumer,
 				removeJobGraphConsumer,
-				releaseJobGraphConsumer);
+				releaseJobGraphConsumer,
+				initialJobGraphs);
 		}
 	}
 
