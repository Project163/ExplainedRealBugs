diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java
index 4c7ada51256..3d7d29a3e9b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/Scheduler.java
@@ -432,17 +432,23 @@ public class Scheduler implements InstanceListener, SlotAvailabilityListener {
 				// root SharedSlot
 				SharedSlot sharedSlot = instanceToUse.allocateSharedSlot(vertex.getJobId(), groupAssignment, groupID);
 
-				// If constraint != null, then slot nested in a SharedSlot nested in sharedSlot
-				// If constraint == null, then slot nested in sharedSlot
-				SimpleSlot slot = groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot, locality, groupID, constraint);
-
 				// if the instance has further available slots, re-add it to the set of available resources.
 				if (instanceToUse.hasResourcesAvailable()) {
 					this.instancesWithAvailableResources.add(instanceToUse);
 				}
 
-				if (slot != null) {
-					return slot;
+				if(sharedSlot != null){
+					// If constraint != null, then slot nested in a SharedSlot nested in sharedSlot
+					// If constraint == null, then slot nested in sharedSlot
+					SimpleSlot slot = groupAssignment.addSharedSlotAndAllocateSubSlot(sharedSlot,
+							locality, groupID, constraint);
+
+					if(slot != null){
+						return slot;
+					} else {
+						// release shared slot
+						sharedSlot.releaseSlot();
+					}
 				}
 			}
 			catch (InstanceDiedException e) {
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/SlotSharingGroupAssignment.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/SlotSharingGroupAssignment.java
index 4e0349a7c89..32c810cf74b 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/SlotSharingGroupAssignment.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/SlotSharingGroupAssignment.java
@@ -65,38 +65,56 @@ public class SlotSharingGroupAssignment {
 
 			SimpleSlot subSlot = null;
 
-			if(constraint == null){
+			if (constraint == null) {
 				// allocate us a sub slot to return
 				subSlot = sharedSlot.allocateSubSlot(groupId);
 			} else {
 				// we need a colocation slot --> a SimpleSlot nested in a SharedSlot to host other colocated tasks
 				SharedSlot constraintGroupSlot = sharedSlot.allocateSharedSlot(groupId);
-				subSlot = constraintGroupSlot.allocateSubSlot(null);
+
+				if(constraintGroupSlot == null) {
+					subSlot = null;
+				} else {
+					subSlot = constraintGroupSlot.allocateSubSlot(null);
+
+					// could not create a sub slot --> release constraintGroupSlot
+					if(subSlot == null){
+						constraintGroupSlot.releaseSlot();
+					}
+				}
 			}
 
-			// preserve the locality information
-			subSlot.setLocality(locality);
+			// if sharedSlot is dead, but this should never happen since we just created a fresh
+			// SharedSlot in the caller
+			if(subSlot == null) {
+				LOG.warn("Could not allocate a sub slot.");
 
-			boolean entryForNewJidExists = false;
+				return null;
+			} else {
+				// preserve the locality information
+				subSlot.setLocality(locality);
 
-			// let the other vertex types know about this one as well
-			for (Map.Entry<AbstractID, Map<Instance, List<SharedSlot>>> entry : availableSlotsPerJid.entrySet()) {
+				boolean entryForNewJidExists = false;
 
-				if (entry.getKey().equals(groupId)) {
-					entryForNewJidExists = true;
-					continue;
+				// let the other vertex types know about this one as well
+				for (Map.Entry<AbstractID, Map<Instance, List<SharedSlot>>> entry : availableSlotsPerJid.entrySet()) {
+
+					if (entry.getKey().equals(groupId)) {
+						entryForNewJidExists = true;
+						continue;
+					}
+
+					Map<Instance, List<SharedSlot>> available = entry.getValue();
+					putIntoMultiMap(available, location, sharedSlot);
 				}
 
-				Map<Instance, List<SharedSlot>> available = entry.getValue();
-				putIntoMultiMap(available, location, sharedSlot);
-			}
+				// make sure an empty entry exists for this group, if no other entry exists
+				if (!entryForNewJidExists) {
+					availableSlotsPerJid.put(groupId, new LinkedHashMap<Instance, List<SharedSlot>>());
+				}
 
-			// make sure an empty entry exists for this group, if no other entry exists
-			if (!entryForNewJidExists) {
-				availableSlotsPerJid.put(groupId, new LinkedHashMap<Instance, List<SharedSlot>>());
+				return subSlot;
 			}
-
-			return subSlot;
 		}
 	}
 
