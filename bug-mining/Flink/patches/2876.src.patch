diff --git a/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumer.java b/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumer.java
index 36a4e92c179..3ab5d8112fe 100644
--- a/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumer.java
+++ b/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/internals/ShardConsumer.java
@@ -44,6 +44,7 @@ import java.util.Date;
 import java.util.List;
 import java.util.Properties;
 
+import static org.apache.flink.streaming.connectors.kinesis.model.SentinelSequenceNumber.isSentinelSequenceNumber;
 import static org.apache.flink.util.Preconditions.checkArgument;
 import static org.apache.flink.util.Preconditions.checkNotNull;
 
@@ -139,69 +140,95 @@ public class ShardConsumer<T> implements Runnable {
 	}
 
 	/**
-	 * Find the initial shard iterator to start getting records from.
+	 * Returns a shard iterator for the given {@link SequenceNumber}.
+	 *
 	 * @return shard iterator
 	 * @throws Exception
 	 */
-	protected String getInitialShardIterator() throws Exception {
-		String nextShardItr;
+	protected String getShardIterator(SequenceNumber sequenceNumber) throws Exception {
 
-		// before infinitely looping, we set the initial nextShardItr appropriately
+		if (isSentinelSequenceNumber(sequenceNumber)) {
+			return getShardIteratorForSentinel(sequenceNumber);
+		} else {
+			// we will be starting from an actual sequence number (due to restore from failure).
+			return getShardIteratorForRealSequenceNumber(sequenceNumber);
+		}
+	}
 
-		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_LATEST_SEQUENCE_NUM.get())) {
+	protected String getShardIteratorForSentinel(SequenceNumber sentinelSequenceNumber) throws InterruptedException {
+		String nextShardItr;
+
+		if (sentinelSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_LATEST_SEQUENCE_NUM.get())) {
 			// if the shard is already closed, there will be no latest next record to get for this shard
 			if (subscribedShard.isClosed()) {
 				nextShardItr = null;
 			} else {
 				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.LATEST.toString(), null);
 			}
-		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())) {
+		} else if (sentinelSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())) {
 			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.TRIM_HORIZON.toString(), null);
-		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {
+		} else if (sentinelSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {
 			nextShardItr = null;
-		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {
+		} else if (sentinelSequenceNumber.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {
 			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_TIMESTAMP.toString(), initTimestamp);
 		} else {
-			// we will be starting from an actual sequence number (due to restore from failure).
-			// if the last sequence number refers to an aggregated record, we need to clean up any dangling sub-records
-			// from the last aggregated record; otherwise, we can simply start iterating from the record right after.
-
-			if (lastSequenceNum.isAggregated()) {
-				String itrForLastAggregatedRecord =
-					kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber());
-
-				// get only the last aggregated record
-				GetRecordsResult getRecordsResult = getRecords(itrForLastAggregatedRecord, 1);
-
-				List<UserRecord> fetchedRecords = deaggregateRecords(
-					getRecordsResult.getRecords(),
-					subscribedShard.getShard().getHashKeyRange().getStartingHashKey(),
-					subscribedShard.getShard().getHashKeyRange().getEndingHashKey());
-
-				long lastSubSequenceNum = lastSequenceNum.getSubSequenceNumber();
-				for (UserRecord record : fetchedRecords) {
-					// we have found a dangling sub-record if it has a larger subsequence number
-					// than our last sequence number; if so, collect the record and update state
-					if (record.getSubSequenceNumber() > lastSubSequenceNum) {
-						deserializeRecordForCollectionAndUpdateState(record);
-					}
-				}
+			throw new RuntimeException("Unknown sentinel type: " + sentinelSequenceNumber);
+		}
 
-				// set the nextShardItr so we can continue iterating in the next while loop
-				nextShardItr = getRecordsResult.getNextShardIterator();
-			} else {
-				// the last record was non-aggregated, so we can simply start from the next record
-				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber());
+		return nextShardItr;
+	}
+
+	protected String getShardIteratorForRealSequenceNumber(SequenceNumber sequenceNumber)
+			throws Exception {
+
+		// if the last sequence number refers to an aggregated record, we need to clean up any dangling sub-records
+		// from the last aggregated record; otherwise, we can simply start iterating from the record right after.
+
+		if (sequenceNumber.isAggregated()) {
+			return getShardIteratorForAggregatedSequenceNumber(sequenceNumber);
+		} else {
+			// the last record was non-aggregated, so we can simply start from the next record
+			return kinesis.getShardIterator(
+					subscribedShard,
+					ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(),
+					sequenceNumber.getSequenceNumber());
+		}
+	}
+
+	protected String getShardIteratorForAggregatedSequenceNumber(SequenceNumber sequenceNumber)
+			throws Exception {
+
+		String itrForLastAggregatedRecord =
+				kinesis.getShardIterator(
+						subscribedShard,
+						ShardIteratorType.AT_SEQUENCE_NUMBER.toString(),
+						sequenceNumber.getSequenceNumber());
+
+		// get only the last aggregated record
+		GetRecordsResult getRecordsResult = getRecords(itrForLastAggregatedRecord, 1);
+
+		List<UserRecord> fetchedRecords = deaggregateRecords(
+				getRecordsResult.getRecords(),
+				subscribedShard.getShard().getHashKeyRange().getStartingHashKey(),
+				subscribedShard.getShard().getHashKeyRange().getEndingHashKey());
+
+		long lastSubSequenceNum = sequenceNumber.getSubSequenceNumber();
+		for (UserRecord record : fetchedRecords) {
+			// we have found a dangling sub-record if it has a larger subsequence number
+			// than our last sequence number; if so, collect the record and update state
+			if (record.getSubSequenceNumber() > lastSubSequenceNum) {
+				deserializeRecordForCollectionAndUpdateState(record);
 			}
 		}
-		return nextShardItr;
+
+		return getRecordsResult.getNextShardIterator();
 	}
 
 	@SuppressWarnings("unchecked")
 	@Override
 	public void run() {
 		try {
-			String nextShardItr = getInitialShardIterator();
+			String nextShardItr = getShardIterator(lastSequenceNum);
 
 			long processingStartTimeNanos = System.nanoTime();
 
@@ -366,7 +393,7 @@ public class ShardConsumer<T> implements Runnable {
 	 * @return get records result
 	 * @throws InterruptedException
 	 */
-	private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {
+	private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws Exception {
 		GetRecordsResult getRecordsResult = null;
 		while (getRecordsResult == null) {
 			try {
@@ -380,7 +407,8 @@ public class ShardConsumer<T> implements Runnable {
 			} catch (ExpiredIteratorException eiEx) {
 				LOG.warn("Encountered an unexpected expired iterator {} for shard {};" +
 					" refreshing the iterator ...", shardItr, subscribedShard);
-				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber());
+
+				shardItr = getShardIterator(lastSequenceNum);
 
 				// sleep for the fetch interval before the next getRecords attempt with the refreshed iterator
 				if (fetchIntervalMillis != 0) {
diff --git a/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumber.java b/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumber.java
index f1481672bfb..8e84d3143e9 100644
--- a/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumber.java
+++ b/flink-connectors/flink-connector-kinesis/src/main/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumber.java
@@ -54,4 +54,16 @@ public enum SentinelSequenceNumber {
 	public SequenceNumber get() {
 		return sentinel;
 	}
+
+	/**
+	 * Returns {@code true} if the given {@link SequenceNumber} is a sentinel.
+	 */
+	public static boolean isSentinelSequenceNumber(SequenceNumber candidateSequenceNumber) {
+		for (SentinelSequenceNumber sentinel : values()) {
+			if (candidateSequenceNumber.equals(sentinel.get())) {
+				return true;
+			}
+		}
+		return false;
+	}
 }
diff --git a/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumberTest.java b/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumberTest.java
new file mode 100644
index 00000000000..75abddc8231
--- /dev/null
+++ b/flink-connectors/flink-connector-kinesis/src/test/java/org/apache/flink/streaming/connectors/kinesis/model/SentinelSequenceNumberTest.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.connectors.kinesis.model;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Tests for {@link SentinelSequenceNumber}.
+ */
+public class SentinelSequenceNumberTest {
+
+	@Test
+	public void allSentinelNumbersAreRecognized() {
+		for (SentinelSequenceNumber sentinel : SentinelSequenceNumber.values()) {
+			assertTrue(SentinelSequenceNumber.isSentinelSequenceNumber(sentinel.get()));
+		}
+	}
+}
