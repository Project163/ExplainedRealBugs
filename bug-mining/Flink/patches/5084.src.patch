diff --git a/flink-core/src/main/java/org/apache/flink/core/memory/HeapMemorySegment.java b/flink-core/src/main/java/org/apache/flink/core/memory/HeapMemorySegment.java
index 3787c13f981..ed9c464030f 100644
--- a/flink-core/src/main/java/org/apache/flink/core/memory/HeapMemorySegment.java
+++ b/flink-core/src/main/java/org/apache/flink/core/memory/HeapMemorySegment.java
@@ -25,6 +25,8 @@ import java.io.DataOutput;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.function.Function;
 
 /**
  * This class represents a piece of heap memory managed by Flink. The segment is backed by a byte
@@ -170,6 +172,16 @@ public final class HeapMemorySegment extends MemorySegment {
         source.get(this.memory, offset, numBytes);
     }
 
+    @Override
+    public <T> T processAsByteBuffer(Function<ByteBuffer, T> processFunction) {
+        throw new UnsupportedOperationException("Unsupported because not needed atm.");
+    }
+
+    @Override
+    public void processAsByteBuffer(Consumer<ByteBuffer> processConsumer) {
+        throw new UnsupportedOperationException("Unsupported because not needed atm.");
+    }
+
     // -------------------------------------------------------------------------
     //                             Factoring
     // -------------------------------------------------------------------------
diff --git a/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java b/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java
index f04dcbcc475..34f93f658eb 100644
--- a/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java
+++ b/flink-core/src/main/java/org/apache/flink/core/memory/HybridMemorySegment.java
@@ -19,6 +19,7 @@
 package org.apache.flink.core.memory;
 
 import org.apache.flink.annotation.Internal;
+import org.apache.flink.util.Preconditions;
 
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
@@ -30,6 +31,8 @@ import java.nio.BufferOverflowException;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
 import java.nio.ReadOnlyBufferException;
+import java.util.function.Consumer;
+import java.util.function.Function;
 
 import static org.apache.flink.core.memory.MemoryUtils.getByteBufferAddress;
 
@@ -99,6 +102,10 @@ public final class HybridMemorySegment extends MemorySegment {
 
     @Override
     public ByteBuffer wrap(int offset, int length) {
+        return wrapInternal(offset, length);
+    }
+
+    private ByteBuffer wrapInternal(int offset, int length) {
         if (address <= addressLimit) {
             if (heapMemory != null) {
                 return ByteBuffer.wrap(heapMemory, offset, length);
@@ -342,4 +349,14 @@ public final class HybridMemorySegment extends MemorySegment {
             }
         }
     }
+
+    @Override
+    public <T> T processAsByteBuffer(Function<ByteBuffer, T> processFunction) {
+        return Preconditions.checkNotNull(processFunction).apply(wrapInternal(0, size));
+    }
+
+    @Override
+    public void processAsByteBuffer(Consumer<ByteBuffer> processConsumer) {
+        Preconditions.checkNotNull(processConsumer).accept(wrapInternal(0, size));
+    }
 }
diff --git a/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegment.java b/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegment.java
index 169bc43229b..255ccd69418 100644
--- a/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegment.java
+++ b/flink-core/src/main/java/org/apache/flink/core/memory/MemorySegment.java
@@ -26,6 +26,8 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.ReadOnlyBufferException;
+import java.util.function.Consumer;
+import java.util.function.Function;
 
 /**
  * This class represents a piece of memory managed by Flink. The segment may be backed by heap
@@ -1386,4 +1388,29 @@ public abstract class MemorySegment {
     public byte[] getHeapMemory() {
         return heapMemory;
     }
+
+    /**
+     * Applies the given process function on a {@link ByteBuffer} that represents this entire
+     * segment.
+     *
+     * <p>Note: The {@link ByteBuffer} passed into the process function is temporary and could
+     * become invalid after the processing. Thus, the process function should not try to keep any
+     * reference of the {@link ByteBuffer}.
+     *
+     * @param processFunction to be applied to the segment as {@link ByteBuffer}.
+     * @return the value that the process function returns.
+     */
+    public abstract <T> T processAsByteBuffer(Function<ByteBuffer, T> processFunction);
+
+    /**
+     * Supplies a {@link ByteBuffer} that represents this entire segment to the given process
+     * consumer.
+     *
+     * <p>Note: The {@link ByteBuffer} passed into the process consumer is temporary and could
+     * become invalid after the processing. Thus, the process consumer should not try to keep any
+     * reference of the {@link ByteBuffer}.
+     *
+     * @param processConsumer to accept the segment as {@link ByteBuffer}.
+     */
+    public abstract void processAsByteBuffer(Consumer<ByteBuffer> processConsumer);
 }
diff --git a/flink-core/src/test/java/org/apache/flink/core/memory/MemorySegmentChecksTest.java b/flink-core/src/test/java/org/apache/flink/core/memory/MemorySegmentChecksTest.java
index 764eefd7b8e..11e95f07879 100644
--- a/flink-core/src/test/java/org/apache/flink/core/memory/MemorySegmentChecksTest.java
+++ b/flink-core/src/test/java/org/apache/flink/core/memory/MemorySegmentChecksTest.java
@@ -23,6 +23,8 @@ import org.junit.Test;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.nio.ByteBuffer;
+import java.util.function.Consumer;
+import java.util.function.Function;
 
 /** Tests for the sanity checks of the memory segments. */
 public class MemorySegmentChecksTest {
@@ -119,5 +121,13 @@ public class MemorySegmentChecksTest {
 
         @Override
         public void put(int offset, ByteBuffer source, int numBytes) {}
+
+        @Override
+        public <T> T processAsByteBuffer(Function<ByteBuffer, T> processFunction) {
+            return null;
+        }
+
+        @Override
+        public void processAsByteBuffer(Consumer<ByteBuffer> processConsumer) {}
     }
 }
