diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java
index 9cdc834f4f3..a106375f38d 100644
--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java
+++ b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunction.java
@@ -160,13 +160,14 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 			inputs.add(input);
 			dataState.put(sortKey, inputs);
 		} else {
+			final boolean stateRemoved;
 			// emit updates first
 			if (outputRankNumber || hasOffset()) {
 				// the without-number-algorithm can't handle topN with offset,
 				// so use the with-number-algorithm to handle offset
-				retractRecordWithRowNumber(sortedMap, sortKey, input, out);
+				stateRemoved = retractRecordWithRowNumber(sortedMap, sortKey, input, out);
 			} else {
-				retractRecordWithoutRowNumber(sortedMap, sortKey, input, out);
+				stateRemoved = retractRecordWithoutRowNumber(sortedMap, sortKey, input, out);
 			}
 
 			// and then update sortedMap
@@ -190,6 +191,26 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 				}
 			}
 
+			if (!stateRemoved) {
+				// the input record has not been removed from state
+				// should update the data state
+				List<RowData> inputs = dataState.get(sortKey);
+				if (inputs != null) {
+					// comparing record by equaliser
+					Iterator<RowData> inputsIter = inputs.iterator();
+					while (inputsIter.hasNext()) {
+						if (equaliser.equals(inputsIter.next(), input)) {
+							inputsIter.remove();
+							break;
+						}
+					}
+					if (inputs.isEmpty()) {
+						dataState.remove(sortKey);
+					} else {
+						dataState.put(sortKey, inputs);
+					}
+				}
+			}
 		}
 		treeMap.update(sortedMap);
 	}
@@ -298,7 +319,11 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 		}
 	}
 
-	private void retractRecordWithRowNumber(
+	/**
+	 * Retract the input record and emit updated records. This works for outputting with row_number.
+	 * @return true if the input record has been removed from {@link #dataState}.
+	 */
+	private boolean retractRecordWithRowNumber(
 			SortedMap<RowData, Long> sortedMap, RowData sortKey, RowData inputRow, Collector<RowData> out)
 			throws Exception {
 		Iterator<Map.Entry<RowData, Long>> iterator = sortedMap.entrySet().iterator();
@@ -358,9 +383,15 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 			// there is no enough elements in Top-N, emit DELETE message for the retract record.
 			collectDelete(out, prevRow, currentRank);
 		}
+
+		return findsSortKey;
 	}
 
-	private void retractRecordWithoutRowNumber(
+	/**
+	 * Retract the input record and emit updated records. This works for outputting without row_number.
+	 * @return true if the input record has been removed from {@link #dataState}.
+	 */
+	private boolean retractRecordWithoutRowNumber(
 			SortedMap<RowData, Long> sortedMap, RowData sortKey, RowData inputRow, Collector<RowData> out)
 			throws Exception {
 		Iterator<Map.Entry<RowData, Long>> iterator = sortedMap.entrySet().iterator();
@@ -418,5 +449,7 @@ public class RetractableTopNFunction extends AbstractTopNFunction {
 				nextRank += entry.getValue();
 			}
 		}
+
+		return findsSortKey;
 	}
 }
diff --git a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java
index b17cc2b99f6..26e55150916 100644
--- a/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java
+++ b/flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/rank/RetractableTopNFunctionTest.java
@@ -447,4 +447,60 @@ public class RetractableTopNFunctionTest extends TopNFunctionTestBase {
 		expectedOutput.add(updateAfterRecord("a", 4L, 2, 3L));
 		assertorWithRowNumber.assertOutputEquals("output wrong.", expectedOutput, testHarness.getOutput());
 	}
+
+	@Test
+	public void testRetractRecordOutOfRankRangeWithoutRowNumber() throws Exception {
+		AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER, new ConstantRankRange(1, 2), false,
+			false);
+		OneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(func);
+		testHarness.open();
+		testHarness.processElement(insertRecord("a", 1L, 1));
+		testHarness.processElement(insertRecord("a", 2L, 2));
+		testHarness.processElement(insertRecord("a", 3L, 2));
+		testHarness.processElement(insertRecord("a", 4L, 4));
+		testHarness.processElement(insertRecord("a", 5L, 4));
+
+		// delete records from out of rank range
+		testHarness.processElement(deleteRecord("a", 4L, 4));
+		testHarness.processElement(deleteRecord("a", 1L, 1));
+		testHarness.processElement(deleteRecord("a", 2L, 2));
+		testHarness.close();
+
+		List<Object> expectedOutput = new ArrayList<>();
+		expectedOutput.add(insertRecord("a", 1L, 1));
+		expectedOutput.add(insertRecord("a", 2L, 2));
+		expectedOutput.add(deleteRecord("a", 1L, 1));
+		expectedOutput.add(insertRecord("a", 3L, 2));
+		expectedOutput.add(deleteRecord("a", 2L, 2));
+		expectedOutput.add(insertRecord("a", 5L, 4));
+		assertorWithoutRowNumber.assertOutputEquals("output wrong.", expectedOutput, testHarness.getOutput());
+	}
+
+	@Test
+	public void testRetractRecordOutOfRankRangeWithRowNumber() throws Exception {
+		AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER, new ConstantRankRange(1, 2), false,
+			true);
+		OneInputStreamOperatorTestHarness<RowData, RowData> testHarness = createTestHarness(func);
+		testHarness.open();
+		testHarness.processElement(insertRecord("a", 1L, 1));
+		testHarness.processElement(insertRecord("a", 2L, 2));
+		testHarness.processElement(insertRecord("a", 3L, 2));
+		testHarness.processElement(insertRecord("a", 4L, 4));
+		testHarness.processElement(insertRecord("a", 5L, 4));
+
+		// delete records from out of rank range
+		testHarness.processElement(deleteRecord("a", 4L, 4));
+		testHarness.processElement(deleteRecord("a", 1L, 1));
+		testHarness.processElement(deleteRecord("a", 2L, 2));
+		testHarness.close();
+
+		List<Object> expectedOutput = new ArrayList<>();
+		expectedOutput.add(insertRecord("a", 1L, 1, 1L));
+		expectedOutput.add(insertRecord("a", 2L, 2, 2L));
+		expectedOutput.add(updateAfterRecord("a", 2L, 2, 1L));
+		expectedOutput.add(updateAfterRecord("a", 3L, 2, 2L));
+		expectedOutput.add(updateAfterRecord("a", 3L, 2, 1L));
+		expectedOutput.add(updateAfterRecord("a", 5L, 4, 2L));
+		assertorWithRowNumber.assertOutputEquals("output wrong.", expectedOutput, testHarness.getOutput());
+	}
 }
