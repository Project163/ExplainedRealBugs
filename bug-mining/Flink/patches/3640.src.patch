diff --git a/flink-end-to-end-tests/test-scripts/common_kubernetes.sh b/flink-end-to-end-tests/test-scripts/common_kubernetes.sh
index d3509cd7b98..b634e1e196c 100755
--- a/flink-end-to-end-tests/test-scripts/common_kubernetes.sh
+++ b/flink-end-to-end-tests/test-scripts/common_kubernetes.sh
@@ -26,6 +26,21 @@ MINIKUBE_START_RETRIES=3
 MINIKUBE_START_BACKOFF=5
 RESULT_HASH="e682ec6622b5e83f2eb614617d5ab2cf"
 
+# If running tests on non-linux os, the kubectl and minikube should be installed manually
+function setup_kubernetes_for_linux {
+    # Download kubectl, which is a requirement for using minikube.
+    if ! [ -x "$(command -v kubectl)" ]; then
+        local version=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)
+        curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$version/bin/linux/amd64/kubectl && \
+            chmod +x kubectl && sudo mv kubectl /usr/local/bin/
+    fi
+    # Download minikube.
+    if ! [ -x "$(command -v minikube)" ]; then
+        curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && \
+            chmod +x minikube && sudo mv minikube /usr/local/bin/
+    fi
+}
+
 function check_kubernetes_status {
     minikube status
     return $?
@@ -33,7 +48,12 @@ function check_kubernetes_status {
 
 function start_kubernetes_if_not_running {
     if ! check_kubernetes_status; then
-        minikube start
+        start_command="minikube start"
+        # We need sudo permission to set vm-driver to none in linux os.
+        [[ "${OS_TYPE}" = "linux" ]] && start_command="sudo ${start_command} --vm-driver=none"
+        ${start_command}
+        # Fix the kubectl context, as it's often stale.
+        minikube update-context
     fi
 
     check_kubernetes_status
@@ -41,11 +61,21 @@ function start_kubernetes_if_not_running {
 }
 
 function start_kubernetes {
+    [[ "${OS_TYPE}" = "linux" ]] && setup_kubernetes_for_linux
     if ! retry_times ${MINIKUBE_START_RETRIES} ${MINIKUBE_START_BACKOFF} start_kubernetes_if_not_running; then
-        echo "Minikube not running. Could not start minikube. Aborting..."
+        echo "Could not start minikube. Aborting..."
         exit 1
     fi
     eval $(minikube docker-env)
 }
 
+function stop_kubernetes {
+    stop_command="minikube stop"
+    [[ "${OS_TYPE}" = "linux" ]] && stop_command="sudo ${stop_command}"
+    if ! retry_times ${MINIKUBE_START_RETRIES} ${MINIKUBE_START_BACKOFF} "${stop_command}"; then
+        echo "Could not stop minikube. Aborting..."
+        exit 1
+    fi
+}
+
 on_exit cleanup
diff --git a/flink-end-to-end-tests/test-scripts/test_kubernetes_embedded_job.sh b/flink-end-to-end-tests/test-scripts/test_kubernetes_embedded_job.sh
index e15c00d350e..52464652eea 100755
--- a/flink-end-to-end-tests/test-scripts/test_kubernetes_embedded_job.sh
+++ b/flink-end-to-end-tests/test-scripts/test_kubernetes_embedded_job.sh
@@ -30,6 +30,7 @@ function cleanup {
     kubectl delete job flink-job-cluster
     kubectl delete service flink-job-cluster
     kubectl delete deployment flink-task-manager
+    stop_kubernetes
 }
 
 start_kubernetes
diff --git a/flink-end-to-end-tests/test-scripts/test_kubernetes_session.sh b/flink-end-to-end-tests/test-scripts/test_kubernetes_session.sh
index 845e8a2086f..ecdf5b88c5c 100755
--- a/flink-end-to-end-tests/test-scripts/test_kubernetes_session.sh
+++ b/flink-end-to-end-tests/test-scripts/test_kubernetes_session.sh
@@ -29,6 +29,7 @@ ARGS="--output ${OUTPUT_PATH}"
 function cleanup {
     kubectl delete service ${CLUSTER_ID}
     kubectl delete clusterrolebinding ${CLUSTER_ROLE_BINDING}
+    stop_kubernetes
 }
 
 start_kubernetes
diff --git a/tools/travis/nightly.sh b/tools/travis/nightly.sh
index 4b7fc4b014a..a12f3db4acd 100755
--- a/tools/travis/nightly.sh
+++ b/tools/travis/nightly.sh
@@ -29,7 +29,6 @@ SCRIPT=$1
 CMD=${@:2}
 
 source ${HERE}/setup_docker.sh
-source ${HERE}/setup_kubernetes.sh
 
 ARTIFACTS_DIR="${HERE}/artifacts"
 
diff --git a/tools/travis/setup_kubernetes.sh b/tools/travis/setup_kubernetes.sh
deleted file mode 100755
index e84ab6e2936..00000000000
--- a/tools/travis/setup_kubernetes.sh
+++ /dev/null
@@ -1,24 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Download kubectl, which is a requirement for using minikube.
-curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/
-# Download minikube.
-curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.25.2/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/
-sudo minikube start --vm-driver=none --kubernetes-version=v1.9.0
-# Fix the kubectl context, as it's often stale.
-minikube update-context
-# Wait for Kubernetes to be up and ready.
-JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'; until kubectl get nodes -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do sleep 1; done
