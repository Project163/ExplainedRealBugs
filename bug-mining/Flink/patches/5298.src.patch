diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RescalingITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RescalingITCase.java
index 24f4f1a0788..aeda6994fe5 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RescalingITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/RescalingITCase.java
@@ -293,6 +293,8 @@ public class RescalingITCase extends TestLogger {
             JobGraph jobGraph =
                     createJobGraphWithOperatorState(
                             parallelism, maxParallelism, OperatorCheckpointMethod.NON_PARTITIONED);
+            // make sure the job does not finish before we take the savepoint
+            StateSourceBase.canFinishLatch = new CountDownLatch(1);
 
             final JobID jobID = jobGraph.getJobID();
 
@@ -306,8 +308,9 @@ public class RescalingITCase extends TestLogger {
             final String savepointPath =
                     savepointPathFuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);
 
+            // we took a savepoint, the job can finish now
+            StateSourceBase.canFinishLatch.countDown();
             client.cancel(jobID).get();
-
             while (!getRunningJobs(client).isEmpty()) {
                 Thread.sleep(50);
             }
@@ -366,6 +369,8 @@ public class RescalingITCase extends TestLogger {
 
             final JobID jobID = jobGraph.getJobID();
 
+            // make sure the job does not finish before we take the savepoint
+            StateSourceBase.canFinishLatch = new CountDownLatch(1);
             client.submitJob(jobGraph).get();
 
             // wait til the sources have emitted numberElements for each key and completed a
@@ -400,6 +405,8 @@ public class RescalingITCase extends TestLogger {
             final String savepointPath =
                     savepointPathFuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);
 
+            // we took a savepoint, the job can finish now
+            StateSourceBase.canFinishLatch.countDown();
             client.cancel(jobID).get();
 
             while (!getRunningJobs(client).isEmpty()) {
@@ -508,6 +515,8 @@ public class RescalingITCase extends TestLogger {
         try {
             JobGraph jobGraph =
                     createJobGraphWithOperatorState(parallelism, maxParallelism, checkpointMethod);
+            // make sure the job does not finish before we take the savepoint
+            StateSourceBase.canFinishLatch = new CountDownLatch(1);
 
             final JobID jobID = jobGraph.getJobID();
 
@@ -527,8 +536,9 @@ public class RescalingITCase extends TestLogger {
             final String savepointPath =
                     savepointPathFuture.get(deadline.timeLeft().toMillis(), TimeUnit.MILLISECONDS);
 
+            // we took a savepoint, the job can finish now
+            StateSourceBase.canFinishLatch.countDown();
             client.cancel(jobID).get();
-
             while (!getRunningJobs(client).isEmpty()) {
                 Thread.sleep(50);
             }
@@ -852,6 +862,7 @@ public class RescalingITCase extends TestLogger {
 
         private static final long serialVersionUID = 7512206069681177940L;
         private static CountDownLatch workStartedLatch = new CountDownLatch(1);
+        private static CountDownLatch canFinishLatch = new CountDownLatch(0);
 
         protected volatile int counter = 0;
         protected volatile boolean running = true;
@@ -876,6 +887,8 @@ public class RescalingITCase extends TestLogger {
                     break;
                 }
             }
+
+            canFinishLatch.await();
         }
 
         @Override
