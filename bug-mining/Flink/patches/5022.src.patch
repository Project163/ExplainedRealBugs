diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
index 6445750c3f4..75c5e4e0ed8 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java
@@ -269,7 +269,8 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
         final SingleOutputStreamOperator<Long> deduplicated =
                 combinedSource
                         .partitionCustom(
-                                (key, numPartitions) -> (int) (key % numPartitions), l -> l)
+                                (key, numPartitions) -> (int) (withoutHeader(key) % numPartitions),
+                                l -> l)
                         .flatMap(new CountingMapFunction(numSources));
         addFailingPipeline(minCheckpoints, slotSharing, deduplicated);
     }
@@ -306,7 +307,7 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
     protected static class ShiftingPartitioner implements Partitioner<Long> {
         @Override
         public int partition(Long key, int numPartitions) {
-            return (int) ((key + 1) % numPartitions);
+            return (int) ((withoutHeader(key) + 1) % numPartitions);
         }
     }
 
@@ -314,7 +315,7 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
     protected static class ChunkDistributingPartitioner implements Partitioner<Long> {
         @Override
         public int partition(Long key, int numPartitions) {
-            return (int) ((key / numPartitions) % numPartitions);
+            return (int) ((withoutHeader(key) / numPartitions) % numPartitions);
         }
     }
 
@@ -351,6 +352,7 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
 
         @Override
         public void invoke(Long value, Context context) throws Exception {
+            value = withoutHeader(value);
             int parallelism = state.lastRecordInPartitions.length;
             int partition = (int) (value % parallelism);
             long lastRecord = state.lastRecordInPartitions[partition];
@@ -433,16 +435,18 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
 
         @Override
         public void flatMap1(Long value, Collector<Long> out) {
-            state.lastLeft = value;
-            if (state.lastRight >= value) {
+            long baseValue = withoutHeader(value);
+            state.lastLeft = baseValue;
+            if (state.lastRight >= baseValue) {
                 out.collect(value);
             }
         }
 
         @Override
         public void flatMap2(Long value, Collector<Long> out) {
-            state.lastRight = value;
-            if (state.lastLeft >= value) {
+            long baseValue = withoutHeader(value);
+            state.lastRight = baseValue;
+            if (state.lastLeft >= baseValue) {
                 out.collect(value);
             }
         }
@@ -468,6 +472,7 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
 
         @Override
         public void processElement(Long value, Context ctx, Collector<Long> out) {
+            checkHeader(value);
             out.collect(value);
         }
     }
@@ -486,7 +491,8 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {
 
         @Override
         public void flatMap(Long value, Collector<Long> out) throws Exception {
-            final int offset = StrictMath.toIntExact(value * withdrawnCount);
+            long baseValue = withoutHeader(value);
+            final int offset = StrictMath.toIntExact(baseValue * withdrawnCount);
             for (int index = 0; index < withdrawnCount; index++) {
                 if (!seenRecords.get(index + offset)) {
                     seenRecords.set(index + offset);
diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
index 9e8211070c5..94cd00a674f 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java
@@ -94,6 +94,9 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
     protected static final String NUM_LOST = "lost";
     public static final int BUFFER_PER_CHANNEL = 1;
 
+    private static final long HEADER = 0xABCDEAFCL << 32;
+    private static final long HEADER_MASK = 0xFFFFFFFFL << 32;
+
     @Rule public final TemporaryFolder temp = new TemporaryFolder();
 
     @Rule public ErrorCollector collector = new ErrorCollector();
@@ -193,7 +196,6 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
         }
 
         private static class LongSourceReader implements SourceReader<Long, LongSplit> {
-
             private final long minCheckpoints;
             private final int expectedRestarts;
             private final LongCounter numInputsCounter = new LongCounter();
@@ -216,7 +218,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
                     return InputStatus.NOTHING_AVAILABLE;
                 }
 
-                output.collect(split.nextNumber, split.nextNumber);
+                output.collect(withHeader(split.nextNumber), split.nextNumber);
                 split.nextNumber += split.increment;
 
                 if (throttle) {
@@ -664,7 +666,7 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
 
         @Override
         public Long map(Long value) throws Exception {
-            lastValue = value;
+            lastValue = withoutHeader(value);
             checkFail(failDuringMap, "map");
             return value;
         }
@@ -840,4 +842,19 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {
             super.close();
         }
     }
+
+    protected static long withHeader(long value) {
+        return value ^ HEADER;
+    }
+
+    protected static long withoutHeader(long value) {
+        checkHeader(value);
+        return value ^ HEADER;
+    }
+
+    protected static void checkHeader(long value) {
+        if ((value & HEADER_MASK) != HEADER) {
+            throw new IllegalArgumentException("Stream corrupted");
+        }
+    }
 }
