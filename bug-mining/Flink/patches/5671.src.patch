diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
index 4e1d15ffa75..0fd13770128 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java
@@ -380,8 +380,7 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
         return persistAndRunFuture.handleAsync(
                 (acknowledge, throwable) -> {
                     if (throwable != null) {
-                        cleanUpJobData(jobGraph.getJobID(), true);
-
+                        cleanUpHighAvailabilityJobData(jobGraph.getJobID());
                         ClusterEntryPointExceptionUtils.tryEnrichClusterEntryPointError(throwable);
                         final Throwable strippedThrowable =
                                 ExceptionUtils.stripCompletionException(throwable);
@@ -437,7 +436,9 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
                         .thenApply(cleanupJobState -> removeJob(jobId, cleanupJobState))
                         .thenCompose(Function.identity());
 
-        FutureUtils.assertNoException(jobTerminationFuture);
+        FutureUtils.handleUncaughtException(
+                jobTerminationFuture,
+                (thread, throwable) -> fatalErrorHandler.onFatalError(throwable));
         registerJobManagerRunnerTerminationFuture(jobId, jobTerminationFuture);
     }
 
@@ -743,31 +744,48 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
 
     private CompletableFuture<Void> removeJob(JobID jobId, CleanupJobState cleanupJobState) {
         final JobManagerRunner job = checkNotNull(runningJobs.remove(jobId));
-
-        final CompletableFuture<Void> jobTerminationFuture = job.closeAsync();
-
-        return jobTerminationFuture.thenRunAsync(
-                () -> cleanUpJobData(jobId, cleanupJobState.cleanupHAData), ioExecutor);
+        return CompletableFuture.supplyAsync(
+                        () -> cleanUpJobGraph(jobId, cleanupJobState.cleanupHAData), ioExecutor)
+                .thenCompose(
+                        jobGraphRemoved -> job.closeAsync().thenApply(ignored -> jobGraphRemoved))
+                .thenAcceptAsync(
+                        jobGraphRemoved -> cleanUpRemainingJobData(jobId, jobGraphRemoved),
+                        ioExecutor);
     }
 
-    private void cleanUpJobData(JobID jobId, boolean cleanupHA) {
-        jobManagerMetricGroup.removeJob(jobId);
-
-        boolean jobGraphRemoved = false;
+    /**
+     * Clean up job graph from {@link org.apache.flink.runtime.jobmanager.JobGraphStore}.
+     *
+     * @param jobId Reference to the job that we want to clean.
+     * @param cleanupHA Flag signalling whether we should remove (we're done with the job) or just
+     *     release the job graph.
+     * @return True if we have removed the job graph. This means we can clean other HA-related
+     *     services as well.
+     */
+    private boolean cleanUpJobGraph(JobID jobId, boolean cleanupHA) {
         if (cleanupHA) {
             try {
                 jobGraphWriter.removeJobGraph(jobId);
-
-                // only clean up the HA blobs and ha service data for the particular job
-                // if we could remove the job from HA storage
-                jobGraphRemoved = true;
+                return true;
             } catch (Exception e) {
                 log.warn(
                         "Could not properly remove job {} from submitted job graph store.",
                         jobId,
                         e);
+                return false;
             }
+        }
+        try {
+            jobGraphWriter.releaseJobGraph(jobId);
+        } catch (Exception e) {
+            log.warn("Could not properly release job {} from submitted job graph store.", jobId, e);
+        }
+        return false;
+    }
 
+    private void cleanUpRemainingJobData(JobID jobId, boolean jobGraphRemoved) {
+        jobManagerMetricGroup.removeJob(jobId);
+        if (jobGraphRemoved) {
             try {
                 runningJobsRegistry.clearJob(jobId);
             } catch (IOException e) {
@@ -776,31 +794,21 @@ public abstract class Dispatcher extends PermanentlyFencedRpcEndpoint<Dispatcher
                         jobId,
                         e);
             }
-
-            if (jobGraphRemoved) {
-                try {
-                    highAvailabilityServices.cleanupJobData(jobId);
-                } catch (Exception e) {
-                    log.warn(
-                            "Could not properly clean data for job {} stored by ha services",
-                            jobId,
-                            e);
-                }
-            }
-        } else {
             try {
-                jobGraphWriter.releaseJobGraph(jobId);
+                highAvailabilityServices.cleanupJobData(jobId);
             } catch (Exception e) {
                 log.warn(
-                        "Could not properly release job {} from submitted job graph store.",
-                        jobId,
-                        e);
+                        "Could not properly clean data for job {} stored by ha services", jobId, e);
             }
         }
-
         blobServer.cleanupJob(jobId, jobGraphRemoved);
     }
 
+    private void cleanUpHighAvailabilityJobData(JobID jobId) {
+        final boolean jobGraphRemoved = cleanUpJobGraph(jobId, true);
+        cleanUpRemainingJobData(jobId, jobGraphRemoved);
+    }
+
     /** Terminate all currently running {@link JobManagerRunner}s. */
     private void terminateRunningJobs() {
         log.info("Stopping all currently running jobs of dispatcher {}.", getAddress());
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
index 921e79fc019..eb7a76e2511 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SchedulerBase.java
@@ -195,8 +195,6 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
                         mainThreadExecutor,
                         jobStatusListener);
 
-        registerShutDownCheckpointServicesOnExecutionGraphTermination(executionGraph);
-
         this.schedulingTopology = executionGraph.getSchedulingTopology();
 
         stateLocationRetriever =
@@ -218,12 +216,6 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
                         jobMasterConfiguration.getInteger(WebOptions.MAX_EXCEPTION_HISTORY_SIZE));
     }
 
-    private void registerShutDownCheckpointServicesOnExecutionGraphTermination(
-            ExecutionGraph executionGraph) {
-        FutureUtils.assertNoException(
-                executionGraph.getTerminationFuture().thenAccept(this::shutDownCheckpointServices));
-    }
-
     private void shutDownCheckpointServices(JobStatus jobStatus) {
         Exception exception = null;
 
@@ -606,12 +598,17 @@ public abstract class SchedulerBase implements SchedulerNG, CheckpointScheduling
 
         final FlinkException cause = new FlinkException("Scheduler is being stopped.");
 
+        final CompletableFuture<Void> checkpointServicesShutdownFuture =
+                executionGraph
+                        .getTerminationFuture()
+                        .thenAcceptAsync(this::shutDownCheckpointServices, getMainThreadExecutor());
+        FutureUtils.assertNoException(checkpointServicesShutdownFuture);
+
         incrementVersionsOfAllVertices();
         cancelAllPendingSlotRequestsInternal();
         executionGraph.suspend(cause);
         operatorCoordinatorHandler.disposeAllOperatorCoordinators();
-
-        return CompletableFuture.completedFuture(null);
+        return checkpointServicesShutdownFuture;
     }
 
     @Override
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/DefaultSchedulerCheckpointCoordinatorTest.java
similarity index 71%
rename from flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
rename to flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/DefaultSchedulerCheckpointCoordinatorTest.java
index 50c7dd140ef..190487e973c 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/ExecutionGraphCheckpointCoordinatorTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/DefaultSchedulerCheckpointCoordinatorTest.java
@@ -31,6 +31,7 @@ import org.apache.flink.runtime.jobgraph.JobVertex;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
 import org.apache.flink.runtime.jobgraph.tasks.CheckpointCoordinatorConfiguration;
 import org.apache.flink.runtime.jobgraph.tasks.JobCheckpointingSettings;
+import org.apache.flink.runtime.scheduler.DefaultScheduler;
 import org.apache.flink.runtime.scheduler.SchedulerBase;
 import org.apache.flink.runtime.scheduler.SchedulerTestingUtils;
 import org.apache.flink.runtime.taskmanager.TaskExecutionState;
@@ -45,14 +46,15 @@ import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertThat;
 
 /**
- * Tests for the interaction between the {@link ExecutionGraph} and the {@link
- * CheckpointCoordinator}.
+ * Tests for the interaction between the {@link DefaultScheduler}, {@link ExecutionGraph} and the
+ * {@link CheckpointCoordinator}.
  */
-public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
+public class DefaultSchedulerCheckpointCoordinatorTest extends TestLogger {
 
     /** Tests that the checkpoint coordinator is shut down if the execution graph is failed. */
     @Test
-    public void testShutdownCheckpointCoordinatorOnFailure() throws Exception {
+    public void testClosingSchedulerShutsDownCheckpointCoordinatorOnFailedExecutionGraph()
+            throws Exception {
         final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>();
         CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture);
 
@@ -68,6 +70,8 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 
         graph.failJob(new Exception("Test Exception"), System.currentTimeMillis());
 
+        scheduler.closeAsync().get();
+
         assertThat(checkpointCoordinator.isShutdown(), is(true));
         assertThat(counterShutdownFuture.get(), is(JobStatus.FAILED));
         assertThat(storeShutdownFuture.get(), is(JobStatus.FAILED));
@@ -75,7 +79,8 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 
     /** Tests that the checkpoint coordinator is shut down if the execution graph is suspended. */
     @Test
-    public void testShutdownCheckpointCoordinatorOnSuspend() throws Exception {
+    public void testClosingSchedulerShutsDownCheckpointCoordinatorOnSuspendedExecutionGraph()
+            throws Exception {
         final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>();
         CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture);
 
@@ -91,6 +96,8 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 
         graph.suspend(new Exception("Test Exception"));
 
+        scheduler.closeAsync().get();
+
         assertThat(checkpointCoordinator.isShutdown(), is(true));
         assertThat(counterShutdownFuture.get(), is(JobStatus.SUSPENDED));
         assertThat(storeShutdownFuture.get(), is(JobStatus.SUSPENDED));
@@ -98,7 +105,8 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 
     /** Tests that the checkpoint coordinator is shut down if the execution graph is finished. */
     @Test
-    public void testShutdownCheckpointCoordinatorOnFinished() throws Exception {
+    public void testClosingSchedulerShutsDownCheckpointCoordinatorOnFinishedExecutionGraph()
+            throws Exception {
         final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>();
         CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture);
 
@@ -123,12 +131,39 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
 
         assertThat(graph.getTerminationFuture().get(), is(JobStatus.FINISHED));
 
+        scheduler.closeAsync().get();
+
         assertThat(checkpointCoordinator.isShutdown(), is(true));
         assertThat(counterShutdownFuture.get(), is(JobStatus.FINISHED));
         assertThat(storeShutdownFuture.get(), is(JobStatus.FINISHED));
     }
 
-    private SchedulerBase createSchedulerAndEnableCheckpointing(
+    /** Tests that the checkpoint coordinator is shut down if the execution graph is suspended. */
+    @Test
+    public void testClosingSchedulerSuspendsExecutionGraphAndShutsDownCheckpointCoordinator()
+            throws Exception {
+        final CompletableFuture<JobStatus> counterShutdownFuture = new CompletableFuture<>();
+        CheckpointIDCounter counter = new TestingCheckpointIDCounter(counterShutdownFuture);
+
+        final CompletableFuture<JobStatus> storeShutdownFuture = new CompletableFuture<>();
+        CompletedCheckpointStore store = new TestingCompletedCheckpointStore(storeShutdownFuture);
+
+        final SchedulerBase scheduler = createSchedulerAndEnableCheckpointing(counter, store);
+        final ExecutionGraph graph = scheduler.getExecutionGraph();
+        final CheckpointCoordinator checkpointCoordinator = graph.getCheckpointCoordinator();
+
+        assertThat(checkpointCoordinator, Matchers.notNullValue());
+        assertThat(checkpointCoordinator.isShutdown(), is(false));
+
+        scheduler.closeAsync().get();
+
+        assertThat(graph.getState(), is(JobStatus.SUSPENDED));
+        assertThat(checkpointCoordinator.isShutdown(), is(true));
+        assertThat(counterShutdownFuture.get(), is(JobStatus.SUSPENDED));
+        assertThat(storeShutdownFuture.get(), is(JobStatus.SUSPENDED));
+    }
+
+    private DefaultScheduler createSchedulerAndEnableCheckpointing(
             CheckpointIDCounter counter, CompletedCheckpointStore store) throws Exception {
         final Time timeout = Time.days(1L);
 
@@ -136,17 +171,10 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
         jobVertex.setInvokableClass(AbstractInvokable.class);
 
         final CheckpointCoordinatorConfiguration chkConfig =
-                new CheckpointCoordinatorConfiguration(
-                        100,
-                        100,
-                        100,
-                        1,
-                        CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION,
-                        true,
-                        false,
-                        false,
-                        0,
-                        0);
+                CheckpointCoordinatorConfiguration.builder()
+                        .setCheckpointInterval(100L)
+                        .setCheckpointTimeout(100L)
+                        .build();
         final JobCheckpointingSettings checkpointingSettings =
                 new JobCheckpointingSettings(chkConfig, null);
 
@@ -156,14 +184,10 @@ public class ExecutionGraphCheckpointCoordinatorTest extends TestLogger {
                         .setJobCheckpointingSettings(checkpointingSettings)
                         .build();
 
-        final SchedulerBase scheduler =
-                SchedulerTestingUtils.newSchedulerBuilder(
-                                jobGraph, ComponentMainThreadExecutorServiceAdapter.forMainThread())
-                        .setCheckpointRecoveryFactory(
-                                new TestingCheckpointRecoveryFactory(store, counter))
-                        .setRpcTimeout(timeout)
-                        .build();
-
-        return scheduler;
+        return SchedulerTestingUtils.newSchedulerBuilder(
+                        jobGraph, ComponentMainThreadExecutorServiceAdapter.forMainThread())
+                .setCheckpointRecoveryFactory(new TestingCheckpointRecoveryFactory(store, counter))
+                .setRpcTimeout(timeout)
+                .build();
     }
 }
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/AbstractDispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/AbstractDispatcherTest.java
new file mode 100644
index 00000000000..f0525889658
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/AbstractDispatcherTest.java
@@ -0,0 +1,207 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.api.common.time.Deadline;
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.configuration.BlobServerOptions;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.blob.BlobServer;
+import org.apache.flink.runtime.blob.VoidBlobStore;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;
+import org.apache.flink.runtime.heartbeat.HeartbeatServices;
+import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobmanager.JobGraphWriter;
+import org.apache.flink.runtime.jobmanager.StandaloneJobGraphStore;
+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;
+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.runtime.rpc.RpcUtils;
+import org.apache.flink.runtime.rpc.TestingRpcService;
+import org.apache.flink.runtime.testutils.CommonTestUtils;
+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;
+import org.apache.flink.util.TestLogger;
+import org.apache.flink.util.TimeUtils;
+
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.rules.TemporaryFolder;
+import org.junit.rules.TestName;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ForkJoinPool;
+
+/** Abstract test for the {@link Dispatcher} component. */
+public class AbstractDispatcherTest extends TestLogger {
+
+    static TestingRpcService rpcService;
+
+    static final Time TIMEOUT = Time.minutes(1L);
+
+    @BeforeClass
+    public static void setupClass() {
+        rpcService = new TestingRpcService();
+    }
+
+    @AfterClass
+    public static void teardownClass() throws Exception {
+        if (rpcService != null) {
+            RpcUtils.terminateRpcService(rpcService, TIMEOUT);
+            rpcService = null;
+        }
+    }
+
+    static void awaitStatus(DispatcherGateway dispatcherGateway, JobID jobId, JobStatus status)
+            throws Exception {
+        CommonTestUtils.waitUntilCondition(
+                () -> status.equals(dispatcherGateway.requestJobStatus(jobId, TIMEOUT).get()),
+                Deadline.fromNow(TimeUtils.toDuration(TIMEOUT)));
+    }
+
+    @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+    @Rule
+    public final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource =
+            new TestingFatalErrorHandlerResource();
+
+    @Rule public TestName name = new TestName();
+
+    Configuration configuration;
+
+    BlobServer blobServer;
+
+    TestingHighAvailabilityServices haServices;
+
+    HeartbeatServices heartbeatServices;
+
+    @Before
+    public void setUp() throws Exception {
+        heartbeatServices = new HeartbeatServices(1000L, 10000L);
+
+        haServices = new TestingHighAvailabilityServices();
+        haServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());
+        haServices.setResourceManagerLeaderRetriever(new SettableLeaderRetrievalService());
+        haServices.setJobGraphStore(new StandaloneJobGraphStore());
+
+        configuration = new Configuration();
+        configuration.setString(
+                BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath());
+
+        blobServer = new BlobServer(configuration, new VoidBlobStore());
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        if (haServices != null) {
+            haServices.closeAndCleanupAllData();
+        }
+        if (blobServer != null) {
+            blobServer.close();
+        }
+    }
+
+    /** A convenient builder for the {@link TestingDispatcher}. */
+    public class TestingDispatcherBuilder {
+
+        private Collection<JobGraph> initialJobGraphs = Collections.emptyList();
+
+        private final DispatcherBootstrapFactory dispatcherBootstrapFactory =
+                (dispatcher, scheduledExecutor, errorHandler) -> new NoOpDispatcherBootstrap();
+
+        private HeartbeatServices heartbeatServices = AbstractDispatcherTest.this.heartbeatServices;
+
+        private HighAvailabilityServices haServices = AbstractDispatcherTest.this.haServices;
+
+        private JobManagerRunnerFactory jobManagerRunnerFactory =
+                JobMasterServiceLeadershipRunnerFactory.INSTANCE;
+
+        private JobGraphWriter jobGraphWriter = NoOpJobGraphWriter.INSTANCE;
+
+        private FatalErrorHandler fatalErrorHandler =
+                testingFatalErrorHandlerResource.getFatalErrorHandler();
+
+        TestingDispatcherBuilder setHeartbeatServices(HeartbeatServices heartbeatServices) {
+            this.heartbeatServices = heartbeatServices;
+            return this;
+        }
+
+        TestingDispatcherBuilder setHaServices(HighAvailabilityServices haServices) {
+            this.haServices = haServices;
+            return this;
+        }
+
+        TestingDispatcherBuilder setInitialJobGraphs(Collection<JobGraph> initialJobGraphs) {
+            this.initialJobGraphs = initialJobGraphs;
+            return this;
+        }
+
+        TestingDispatcherBuilder setJobManagerRunnerFactory(
+                JobManagerRunnerFactory jobManagerRunnerFactory) {
+            this.jobManagerRunnerFactory = jobManagerRunnerFactory;
+            return this;
+        }
+
+        TestingDispatcherBuilder setJobGraphWriter(JobGraphWriter jobGraphWriter) {
+            this.jobGraphWriter = jobGraphWriter;
+            return this;
+        }
+
+        public TestingDispatcherBuilder setFatalErrorHandler(FatalErrorHandler fatalErrorHandler) {
+            this.fatalErrorHandler = fatalErrorHandler;
+            return this;
+        }
+
+        TestingDispatcher build() throws Exception {
+            TestingResourceManagerGateway resourceManagerGateway =
+                    new TestingResourceManagerGateway();
+
+            final MemoryExecutionGraphInfoStore executionGraphInfoStore =
+                    new MemoryExecutionGraphInfoStore();
+
+            return new TestingDispatcher(
+                    rpcService,
+                    DispatcherId.generate(),
+                    initialJobGraphs,
+                    dispatcherBootstrapFactory,
+                    new DispatcherServices(
+                            configuration,
+                            haServices,
+                            () -> CompletableFuture.completedFuture(resourceManagerGateway),
+                            blobServer,
+                            heartbeatServices,
+                            executionGraphInfoStore,
+                            fatalErrorHandler,
+                            VoidHistoryServerArchivist.INSTANCE,
+                            null,
+                            UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
+                            jobGraphWriter,
+                            jobManagerRunnerFactory,
+                            ForkJoinPool.commonPool()));
+        }
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java
new file mode 100644
index 00000000000..a629a25c962
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherFailoverITCase.java
@@ -0,0 +1,241 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.JobStatus;
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.runtime.checkpoint.CompletedCheckpointStore;
+import org.apache.flink.runtime.checkpoint.EmbeddedCompletedCheckpointStore;
+import org.apache.flink.runtime.checkpoint.JobManagerTaskRestore;
+import org.apache.flink.runtime.checkpoint.PerJobCheckpointRecoveryFactory;
+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointIDCounter;
+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;
+import org.apache.flink.runtime.execution.ExecutionState;
+import org.apache.flink.runtime.highavailability.nonha.standalone.StandaloneRunningJobsRegistry;
+import org.apache.flink.runtime.jobgraph.JobGraph;
+import org.apache.flink.runtime.jobgraph.JobGraphBuilder;
+import org.apache.flink.runtime.jobgraph.JobVertex;
+import org.apache.flink.runtime.jobgraph.tasks.CheckpointCoordinatorConfiguration;
+import org.apache.flink.runtime.jobgraph.tasks.JobCheckpointingSettings;
+import org.apache.flink.runtime.jobmaster.JobMasterGateway;
+import org.apache.flink.runtime.jobmaster.JobMasterId;
+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
+import org.apache.flink.runtime.rpc.FatalErrorHandler;
+import org.apache.flink.runtime.rpc.RpcEndpoint;
+import org.apache.flink.runtime.rpc.RpcUtils;
+import org.apache.flink.runtime.testtasks.NoOpInvokable;
+import org.apache.flink.runtime.testutils.TestingJobGraphStore;
+import org.apache.flink.util.ExceptionUtils;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import static org.junit.Assert.assertTrue;
+
+/** An integration test for various fail-over scenarios of the {@link Dispatcher} component. */
+public class DispatcherFailoverITCase extends AbstractDispatcherTest {
+
+    private static final Time TIMEOUT = Time.seconds(1);
+
+    private final BlockingQueue<RpcEndpoint> toTerminate = new LinkedBlockingQueue<>();
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        final CompletedCheckpointStore completedCheckpointStore =
+                new EmbeddedCompletedCheckpointStore();
+        haServices.setCheckpointRecoveryFactory(
+                PerJobCheckpointRecoveryFactory.useSameServicesForAllJobs(
+                        completedCheckpointStore, new StandaloneCheckpointIDCounter()));
+    }
+
+    @After
+    public void tearDown() {
+        while (!toTerminate.isEmpty()) {
+            final RpcEndpoint endpoint = toTerminate.poll();
+            try {
+                RpcUtils.terminateRpcEndpoint(endpoint, TIMEOUT);
+            } catch (Exception e) {
+                // Ignore.
+            }
+        }
+    }
+
+    @Test
+    public void testRecoverFromCheckpointAfterJobGraphRemovalOfTerminatedJobFailed()
+            throws Exception {
+        final JobGraph jobGraph = createJobGraph();
+        final JobID jobId = jobGraph.getJobID();
+
+        // Construct job graph store.
+        final Error jobGraphRemovalError = new Error("Unable to remove job graph.");
+        final TestingJobGraphStore jobGraphStore =
+                TestingJobGraphStore.newBuilder()
+                        .setRemoveJobGraphConsumer(
+                                graph -> {
+                                    throw jobGraphRemovalError;
+                                })
+                        .build();
+        jobGraphStore.start(null);
+        haServices.setJobGraphStore(jobGraphStore);
+
+        // Construct leader election service.
+        final TestingLeaderElectionService leaderElectionService =
+                new TestingLeaderElectionService();
+        haServices.setJobMasterLeaderElectionService(jobId, leaderElectionService);
+
+        // Start the first dispatcher and submit the job.
+        final CountDownLatch jobGraphRemovalErrorReceived = new CountDownLatch(1);
+        final Dispatcher dispatcher =
+                createRecoveredDispatcher(
+                        throwable -> {
+                            final Optional<Error> maybeError =
+                                    ExceptionUtils.findThrowable(throwable, Error.class);
+                            if (maybeError.isPresent()
+                                    && jobGraphRemovalError.equals(maybeError.get())) {
+                                jobGraphRemovalErrorReceived.countDown();
+                            } else {
+                                testingFatalErrorHandlerResource
+                                        .getFatalErrorHandler()
+                                        .onFatalError(throwable);
+                            }
+                        });
+        toTerminate.add(dispatcher);
+        leaderElectionService.isLeader(UUID.randomUUID());
+        final DispatcherGateway dispatcherGateway =
+                dispatcher.getSelfGateway(DispatcherGateway.class);
+        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
+        awaitStatus(dispatcherGateway, jobId, JobStatus.RUNNING);
+
+        // Run vertices, checkpoint and finish.
+        final JobMasterGateway jobMasterGateway =
+                connectToLeadingJobMaster(leaderElectionService).get();
+        try (final JobMasterTester tester =
+                new JobMasterTester(rpcService, jobId, jobMasterGateway)) {
+            final List<TaskDeploymentDescriptor> descriptors = tester.deployVertices(2).get();
+            tester.transitionTo(descriptors, ExecutionState.INITIALIZING).get();
+            tester.transitionTo(descriptors, ExecutionState.RUNNING).get();
+            tester.getCheckpointFuture(1L).get();
+            tester.transitionTo(descriptors, ExecutionState.FINISHED).get();
+        }
+        awaitStatus(dispatcherGateway, jobId, JobStatus.FINISHED);
+        jobGraphRemovalErrorReceived.await();
+
+        // Remove job master leadership.
+        leaderElectionService.notLeader();
+
+        // This will clear internal state of election service, so a new contender can register.
+        leaderElectionService.stop();
+
+        // Run a second dispatcher, that restores our finished job.
+        final Dispatcher secondDispatcher = createRecoveredDispatcher(null);
+        toTerminate.add(secondDispatcher);
+        final DispatcherGateway secondDispatcherGateway =
+                secondDispatcher.getSelfGateway(DispatcherGateway.class);
+        UUID uuid = UUID.randomUUID();
+        leaderElectionService.isLeader(uuid);
+        awaitStatus(secondDispatcherGateway, jobId, JobStatus.RUNNING);
+
+        // Now make sure that restored job started from checkpoint.
+        final JobMasterGateway secondJobMasterGateway =
+                connectToLeadingJobMaster(leaderElectionService).get();
+        try (final JobMasterTester tester =
+                new JobMasterTester(rpcService, jobId, secondJobMasterGateway)) {
+            final List<TaskDeploymentDescriptor> descriptors = tester.deployVertices(2).get();
+            final Optional<JobManagerTaskRestore> maybeRestore =
+                    descriptors.stream()
+                            .map(TaskDeploymentDescriptor::getTaskRestore)
+                            .filter(Objects::nonNull)
+                            .findAny();
+            assertTrue("Job has recovered from checkpoint.", maybeRestore.isPresent());
+        }
+    }
+
+    private JobGraph createJobGraph() {
+        final JobVertex firstVertex = new JobVertex("first");
+        firstVertex.setInvokableClass(NoOpInvokable.class);
+        firstVertex.setParallelism(1);
+
+        final JobVertex secondVertex = new JobVertex("second");
+        secondVertex.setInvokableClass(NoOpInvokable.class);
+        secondVertex.setParallelism(1);
+
+        final CheckpointCoordinatorConfiguration checkpointCoordinatorConfiguration =
+                CheckpointCoordinatorConfiguration.builder()
+                        .setCheckpointInterval(20L)
+                        .setMinPauseBetweenCheckpoints(20L)
+                        .setCheckpointTimeout(10_000L)
+                        .build();
+        final JobCheckpointingSettings checkpointingSettings =
+                new JobCheckpointingSettings(checkpointCoordinatorConfiguration, null);
+        return JobGraphBuilder.newStreamingJobGraphBuilder()
+                .addJobVertex(firstVertex)
+                .addJobVertex(secondVertex)
+                .setJobCheckpointingSettings(checkpointingSettings)
+                .build();
+    }
+
+    private TestingDispatcher createRecoveredDispatcher(
+            @Nullable FatalErrorHandler fatalErrorHandler) throws Exception {
+        final List<JobGraph> jobGraphs = new ArrayList<>();
+        for (JobID jobId : haServices.getJobGraphStore().getJobIds()) {
+            jobGraphs.add(haServices.getJobGraphStore().recoverJobGraph(jobId));
+        }
+        haServices.setRunningJobsRegistry(new StandaloneRunningJobsRegistry());
+        final TestingDispatcher dispatcher =
+                new TestingDispatcherBuilder()
+                        .setJobManagerRunnerFactory(
+                                JobMasterServiceLeadershipRunnerFactory.INSTANCE)
+                        .setJobGraphWriter(haServices.getJobGraphStore())
+                        .setInitialJobGraphs(jobGraphs)
+                        .setFatalErrorHandler(
+                                fatalErrorHandler == null
+                                        ? testingFatalErrorHandlerResource.getFatalErrorHandler()
+                                        : fatalErrorHandler)
+                        .build();
+        dispatcher.start();
+        return dispatcher;
+    }
+
+    private static CompletableFuture<JobMasterGateway> connectToLeadingJobMaster(
+            TestingLeaderElectionService leaderElectionService) {
+        return leaderElectionService
+                .getConfirmationFuture()
+                .thenCompose(
+                        leaderConnectionInfo ->
+                                rpcService.connect(
+                                        leaderConnectionInfo.getAddress(),
+                                        JobMasterId.fromUuidOrNull(
+                                                leaderConnectionInfo.getLeaderSessionId()),
+                                        JobMasterGateway.class));
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
index 6fbb07ee249..bef8ec2df4e 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java
@@ -332,7 +332,7 @@ public class DispatcherResourceCleanupTest extends TestLogger {
     @Test
     public void testHACleanupWhenJobFinishedWhileClosingDispatcher() throws Exception {
         final TestingJobManagerRunner testingJobManagerRunner =
-                new TestingJobManagerRunner.Builder()
+                TestingJobManagerRunner.newBuilder()
                         .setBlockingTermination(true)
                         .setJobId(jobId)
                         .build();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
index 4abf983095f..9c7ff51d1d4 100755
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherTest.java
@@ -22,15 +22,10 @@ import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.common.JobStatus;
 import org.apache.flink.api.common.operators.ResourceSpec;
 import org.apache.flink.api.common.time.Deadline;
-import org.apache.flink.api.common.time.Time;
 import org.apache.flink.api.java.tuple.Tuple2;
-import org.apache.flink.configuration.BlobServerOptions;
 import org.apache.flink.configuration.Configuration;
 import org.apache.flink.core.testutils.OneShotLatch;
-import org.apache.flink.runtime.blob.BlobServer;
-import org.apache.flink.runtime.blob.VoidBlobStore;
 import org.apache.flink.runtime.checkpoint.Checkpoints;
-import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;
 import org.apache.flink.runtime.checkpoint.metadata.CheckpointMetadata;
 import org.apache.flink.runtime.client.DuplicateJobSubmissionException;
 import org.apache.flink.runtime.client.JobSubmissionException;
@@ -42,11 +37,11 @@ import org.apache.flink.runtime.heartbeat.HeartbeatServices;
 import org.apache.flink.runtime.highavailability.HighAvailabilityServices;
 import org.apache.flink.runtime.highavailability.RunningJobsRegistry;
 import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;
+import org.apache.flink.runtime.highavailability.nonha.standalone.StandaloneRunningJobsRegistry;
 import org.apache.flink.runtime.jobgraph.JobGraph;
 import org.apache.flink.runtime.jobgraph.JobGraphBuilder;
 import org.apache.flink.runtime.jobgraph.JobGraphTestUtils;
 import org.apache.flink.runtime.jobgraph.JobVertex;
-import org.apache.flink.runtime.jobmanager.JobGraphWriter;
 import org.apache.flink.runtime.jobmaster.JobManagerRunner;
 import org.apache.flink.runtime.jobmaster.JobManagerRunnerResult;
 import org.apache.flink.runtime.jobmaster.JobManagerSharedServices;
@@ -64,17 +59,13 @@ import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;
 import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;
 import org.apache.flink.runtime.leaderelection.LeaderElectionService;
 import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;
-import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;
 import org.apache.flink.runtime.messages.Acknowledge;
 import org.apache.flink.runtime.messages.FlinkJobNotFoundException;
 import org.apache.flink.runtime.messages.webmonitor.MultipleJobsDetails;
-import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;
-import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;
 import org.apache.flink.runtime.rest.handler.legacy.utils.ArchivedExecutionGraphBuilder;
 import org.apache.flink.runtime.rpc.FatalErrorHandler;
 import org.apache.flink.runtime.rpc.RpcService;
 import org.apache.flink.runtime.rpc.RpcUtils;
-import org.apache.flink.runtime.rpc.TestingRpcService;
 import org.apache.flink.runtime.scheduler.ExecutionGraphInfo;
 import org.apache.flink.runtime.state.CheckpointMetadataOutputStream;
 import org.apache.flink.runtime.state.CheckpointStorage;
@@ -85,24 +76,17 @@ import org.apache.flink.runtime.testtasks.NoOpInvokable;
 import org.apache.flink.runtime.testutils.CommonTestUtils;
 import org.apache.flink.runtime.testutils.TestingJobGraphStore;
 import org.apache.flink.runtime.util.TestingFatalErrorHandler;
-import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;
 import org.apache.flink.util.ExceptionUtils;
 import org.apache.flink.util.FlinkException;
 import org.apache.flink.util.Preconditions;
-import org.apache.flink.util.TestLogger;
 import org.apache.flink.util.TimeUtils;
 import org.apache.flink.util.function.ThrowingRunnable;
 
 import org.hamcrest.Matchers;
 import org.junit.After;
-import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.TestName;
 
 import javax.annotation.Nonnull;
 
@@ -113,9 +97,8 @@ import java.net.URISyntaxException;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.time.Duration;
-import java.time.temporal.ChronoUnit;
-import java.util.Collection;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Optional;
 import java.util.UUID;
@@ -124,7 +107,7 @@ import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicReference;
@@ -143,19 +126,13 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Test for the {@link Dispatcher} component. */
-public class DispatcherTest extends TestLogger {
+public class DispatcherTest extends AbstractDispatcherTest {
 
-    private static RpcService rpcService;
-
-    private static final Time TIMEOUT = Time.seconds(10L);
-
-    @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
-
-    @Rule
-    public final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource =
-            new TestingFatalErrorHandlerResource();
-
-    @Rule public TestName name = new TestName();
+    private static final String CLEANUP_JOB_GRAPH_REMOVE = "job-graph-remove";
+    private static final String CLEANUP_JOB_GRAPH_RELEASE = "job-graph-release";
+    private static final String CLEANUP_JOB_MANAGER_RUNNER = "job-manager-runner";
+    private static final String CLEANUP_HA_SERVICES = "ha-services";
+    private static final String CLEANUP_RUNNING_JOBS_REGISTRY = "running-jobs-registry";
 
     private JobGraph jobGraph;
 
@@ -165,52 +142,17 @@ public class DispatcherTest extends TestLogger {
 
     private CountDownLatch createdJobManagerRunnerLatch;
 
-    private Configuration configuration;
-
-    private BlobServer blobServer;
-
     /** Instance under test. */
     private TestingDispatcher dispatcher;
 
-    private TestingHighAvailabilityServices haServices;
-
-    private HeartbeatServices heartbeatServices;
-
-    @BeforeClass
-    public static void setupClass() {
-        rpcService = new TestingRpcService();
-    }
-
-    @AfterClass
-    public static void teardownClass() throws Exception {
-        if (rpcService != null) {
-            RpcUtils.terminateRpcService(rpcService, TIMEOUT);
-
-            rpcService = null;
-        }
-    }
-
     @Before
     public void setUp() throws Exception {
+        super.setUp();
         jobGraph = JobGraphTestUtils.singleNoOpJobGraph();
         jobId = jobGraph.getJobID();
-
-        heartbeatServices = new HeartbeatServices(1000L, 10000L);
-
         jobMasterLeaderElectionService = new TestingLeaderElectionService();
-
-        haServices = new TestingHighAvailabilityServices();
         haServices.setJobMasterLeaderElectionService(jobId, jobMasterLeaderElectionService);
-        haServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());
-        haServices.setResourceManagerLeaderRetriever(new SettableLeaderRetrievalService());
-
-        configuration = new Configuration();
-
-        configuration.setString(
-                BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath());
-
         createdJobManagerRunnerLatch = new CountDownLatch(2);
-        blobServer = new BlobServer(configuration, new VoidBlobStore());
     }
 
     @Nonnull
@@ -224,9 +166,9 @@ public class DispatcherTest extends TestLogger {
                         .setHaServices(haServices)
                         .setHeartbeatServices(heartbeatServices)
                         .setJobManagerRunnerFactory(jobManagerRunnerFactory)
+                        .setJobGraphWriter(haServices.getJobGraphStore())
                         .build();
         dispatcher.start();
-
         return dispatcher;
     }
 
@@ -235,14 +177,7 @@ public class DispatcherTest extends TestLogger {
         if (dispatcher != null) {
             RpcUtils.terminateRpcEndpoint(dispatcher, TIMEOUT);
         }
-
-        if (haServices != null) {
-            haServices.closeAndCleanupAllData();
-        }
-
-        if (blobServer != null) {
-            blobServer.close();
-        }
+        super.tearDown();
     }
 
     /**
@@ -373,10 +308,7 @@ public class DispatcherTest extends TestLogger {
         blockingJobMaster.unblockJobMasterInitialization();
 
         // ensure job is running
-        CommonTestUtils.waitUntilCondition(
-                () -> dispatcherGateway.requestJobStatus(jobId, TIMEOUT).get() == JobStatus.RUNNING,
-                Deadline.fromNow(TimeUtils.toDuration(TIMEOUT)),
-                5L);
+        awaitStatus(dispatcherGateway, jobId, JobStatus.RUNNING);
     }
 
     @Test
@@ -652,16 +584,44 @@ public class DispatcherTest extends TestLogger {
         final FlinkException testException = new FlinkException("Test exception.");
         final ArrayBlockingQueue<Optional<Exception>> queue = new ArrayBlockingQueue<>(2);
 
-        BlockingJobManagerRunnerFactory blockingJobManagerRunnerFactory =
+        final BlockingJobManagerRunnerFactory blockingJobManagerRunnerFactory =
                 new BlockingJobManagerRunnerFactory(
                         () -> {
-                            final Optional<Exception> take = queue.take();
-                            final Exception exception = take.orElse(null);
-
-                            if (exception != null) {
-                                throw exception;
+                            final Optional<Exception> maybeException = queue.take();
+                            if (maybeException.isPresent()) {
+                                throw maybeException.get();
                             }
                         });
+
+        final BlockingQueue<String> cleanUpEvents = new LinkedBlockingQueue<>();
+
+        // Track cleanup - ha-services
+        final CompletableFuture<JobID> cleanupJobData = new CompletableFuture<>();
+        haServices.setCleanupJobDataFuture(cleanupJobData);
+        cleanupJobData.thenAccept(jobId -> cleanUpEvents.add(CLEANUP_HA_SERVICES));
+
+        // Track cleanup - job-graph
+        final TestingJobGraphStore jobGraphStore =
+                TestingJobGraphStore.newBuilder()
+                        .setReleaseJobGraphConsumer(
+                                jobId -> cleanUpEvents.add(CLEANUP_JOB_GRAPH_RELEASE))
+                        .setRemoveJobGraphConsumer(
+                                jobId -> cleanUpEvents.add(CLEANUP_JOB_GRAPH_REMOVE))
+                        .build();
+        jobGraphStore.start(null);
+        haServices.setJobGraphStore(jobGraphStore);
+
+        // Track cleanup - running jobs registry
+        haServices.setRunningJobsRegistry(
+                new StandaloneRunningJobsRegistry() {
+
+                    @Override
+                    public void clearJob(JobID jobID) {
+                        super.clearJob(jobID);
+                        cleanUpEvents.add(CLEANUP_RUNNING_JOBS_REGISTRY);
+                    }
+                });
+
         dispatcher =
                 createAndStartDispatcher(
                         heartbeatServices, haServices, blockingJobManagerRunnerFactory);
@@ -669,12 +629,21 @@ public class DispatcherTest extends TestLogger {
         final DispatcherGateway dispatcherGateway =
                 dispatcher.getSelfGateway(DispatcherGateway.class);
 
+        // submit and fail during job master runner construction
         queue.offer(Optional.of(testException));
         try {
             dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
         } catch (Throwable expectedException) {
             assertThat(expectedException, containsCause(FlinkException.class));
             assertThat(expectedException, containsMessage(testException.getMessage()));
+            // make sure we've cleaned up in correct order (including HA)
+            assertThat(
+                    new ArrayList<>(cleanUpEvents),
+                    equalTo(
+                            Arrays.asList(
+                                    CLEANUP_JOB_GRAPH_REMOVE,
+                                    CLEANUP_RUNNING_JOBS_REGISTRY,
+                                    CLEANUP_HA_SERVICES)));
         }
 
         // don't fail this time
@@ -684,12 +653,7 @@ public class DispatcherTest extends TestLogger {
         blockingJobManagerRunnerFactory.setJobStatus(JobStatus.RUNNING);
 
         // Ensure job is running
-        CommonTestUtils.waitUntilCondition(
-                () ->
-                        dispatcherGateway.requestJobStatus(jobGraph.getJobID(), TIMEOUT).get()
-                                == JobStatus.RUNNING,
-                Deadline.fromNow(Duration.of(10, ChronoUnit.SECONDS)),
-                5L);
+        awaitStatus(dispatcherGateway, jobId, JobStatus.RUNNING);
     }
 
     @Test
@@ -850,6 +814,75 @@ public class DispatcherTest extends TestLogger {
         assertThat(initializationTimestamp, greaterThan(0L));
     }
 
+    @Test
+    public void testJobDataAreCleanedUpInCorrectOrderOnFinishedJob() throws Exception {
+        testJobDataAreCleanedUpInCorrectOrder(JobStatus.FINISHED);
+    }
+
+    @Test
+    public void testJobDataAreCleanedUpInCorrectOrderOnFailedJob() throws Exception {
+        testJobDataAreCleanedUpInCorrectOrder(JobStatus.FAILED);
+    }
+
+    private void testJobDataAreCleanedUpInCorrectOrder(JobStatus jobStatus) throws Exception {
+        final BlockingQueue<String> cleanUpEvents = new LinkedBlockingQueue<>();
+
+        // Track cleanup - ha-services
+        final CompletableFuture<JobID> cleanupJobData = new CompletableFuture<>();
+        haServices.setCleanupJobDataFuture(cleanupJobData);
+        cleanupJobData.thenAccept(jobId -> cleanUpEvents.add(CLEANUP_HA_SERVICES));
+
+        // Track cleanup - job-graph
+        final TestingJobGraphStore jobGraphStore =
+                TestingJobGraphStore.newBuilder()
+                        .setReleaseJobGraphConsumer(
+                                jobId -> cleanUpEvents.add(CLEANUP_JOB_GRAPH_RELEASE))
+                        .setRemoveJobGraphConsumer(
+                                jobId -> cleanUpEvents.add(CLEANUP_JOB_GRAPH_REMOVE))
+                        .build();
+        jobGraphStore.start(null);
+        haServices.setJobGraphStore(jobGraphStore);
+
+        // Track cleanup - running jobs registry
+        haServices.setRunningJobsRegistry(
+                new StandaloneRunningJobsRegistry() {
+
+                    @Override
+                    public void clearJob(JobID jobID) {
+                        super.clearJob(jobID);
+                        cleanUpEvents.add(CLEANUP_RUNNING_JOBS_REGISTRY);
+                    }
+                });
+
+        final CompletableFuture<JobManagerRunnerResult> resultFuture = new CompletableFuture<>();
+        dispatcher =
+                createAndStartDispatcher(
+                        heartbeatServices,
+                        haServices,
+                        new FinishingJobManagerRunnerFactory(
+                                resultFuture, () -> cleanUpEvents.add(CLEANUP_JOB_MANAGER_RUNNER)));
+
+        final DispatcherGateway dispatcherGateway =
+                dispatcher.getSelfGateway(DispatcherGateway.class);
+        dispatcherGateway.submitJob(jobGraph, TIMEOUT).get();
+        resultFuture.complete(
+                JobManagerRunnerResult.forSuccess(
+                        new ExecutionGraphInfo(
+                                new ArchivedExecutionGraphBuilder().setState(jobStatus).build())));
+
+        // Wait for job to terminate.
+        dispatcher.getJobTerminationFuture(jobId, TIMEOUT).get();
+
+        assertThat(
+                new ArrayList<>(cleanUpEvents),
+                equalTo(
+                        Arrays.asList(
+                                CLEANUP_JOB_GRAPH_REMOVE,
+                                CLEANUP_JOB_MANAGER_RUNNER,
+                                CLEANUP_RUNNING_JOBS_REGISTRY,
+                                CLEANUP_HA_SERVICES)));
+    }
+
     private static class JobManagerRunnerWithBlockingJobMasterFactory
             implements JobManagerRunnerFactory {
 
@@ -1086,79 +1119,7 @@ public class DispatcherTest extends TestLogger {
                 FatalErrorHandler fatalErrorHandler,
                 long initializationTimestamp) {
             initializationTimestampQueue.offer(initializationTimestamp);
-            return new TestingJobManagerRunner.Builder().setJobId(jobGraph.getJobID()).build();
-        }
-    }
-
-    /** Builder for the TestingDispatcher. */
-    public class TestingDispatcherBuilder {
-
-        private Collection<JobGraph> initialJobGraphs = Collections.emptyList();
-
-        private final DispatcherBootstrapFactory dispatcherBootstrapFactory =
-                (dispatcher, scheduledExecutor, errorHandler) -> new NoOpDispatcherBootstrap();
-
-        private HeartbeatServices heartbeatServices = DispatcherTest.this.heartbeatServices;
-
-        private HighAvailabilityServices haServices = DispatcherTest.this.haServices;
-
-        private JobManagerRunnerFactory jobManagerRunnerFactory =
-                JobMasterServiceLeadershipRunnerFactory.INSTANCE;
-
-        private JobGraphWriter jobGraphWriter = NoOpJobGraphWriter.INSTANCE;
-
-        TestingDispatcherBuilder setHeartbeatServices(HeartbeatServices heartbeatServices) {
-            this.heartbeatServices = heartbeatServices;
-            return this;
-        }
-
-        TestingDispatcherBuilder setHaServices(HighAvailabilityServices haServices) {
-            this.haServices = haServices;
-            return this;
-        }
-
-        TestingDispatcherBuilder setInitialJobGraphs(Collection<JobGraph> initialJobGraphs) {
-            this.initialJobGraphs = initialJobGraphs;
-            return this;
-        }
-
-        TestingDispatcherBuilder setJobManagerRunnerFactory(
-                JobManagerRunnerFactory jobManagerRunnerFactory) {
-            this.jobManagerRunnerFactory = jobManagerRunnerFactory;
-            return this;
-        }
-
-        TestingDispatcherBuilder setJobGraphWriter(JobGraphWriter jobGraphWriter) {
-            this.jobGraphWriter = jobGraphWriter;
-            return this;
-        }
-
-        TestingDispatcher build() throws Exception {
-            TestingResourceManagerGateway resourceManagerGateway =
-                    new TestingResourceManagerGateway();
-
-            final MemoryExecutionGraphInfoStore executionGraphInfoStore =
-                    new MemoryExecutionGraphInfoStore();
-
-            return new TestingDispatcher(
-                    rpcService,
-                    DispatcherId.generate(),
-                    initialJobGraphs,
-                    dispatcherBootstrapFactory,
-                    new DispatcherServices(
-                            configuration,
-                            haServices,
-                            () -> CompletableFuture.completedFuture(resourceManagerGateway),
-                            blobServer,
-                            heartbeatServices,
-                            executionGraphInfoStore,
-                            testingFatalErrorHandlerResource.getFatalErrorHandler(),
-                            VoidHistoryServerArchivist.INSTANCE,
-                            null,
-                            UnregisteredMetricGroups.createUnregisteredJobManagerMetricGroup(),
-                            jobGraphWriter,
-                            jobManagerRunnerFactory,
-                            ForkJoinPool.commonPool()));
+            return TestingJobManagerRunner.newBuilder().setJobId(jobGraph.getJobID()).build();
         }
     }
 
@@ -1218,6 +1179,39 @@ public class DispatcherTest extends TestLogger {
         }
     }
 
+    private static class FinishingJobManagerRunnerFactory implements JobManagerRunnerFactory {
+
+        private final CompletableFuture<JobManagerRunnerResult> resultFuture;
+        private final Runnable onClose;
+
+        private FinishingJobManagerRunnerFactory(
+                CompletableFuture<JobManagerRunnerResult> resultFuture, Runnable onClose) {
+            this.resultFuture = resultFuture;
+            this.onClose = onClose;
+        }
+
+        @Override
+        public JobManagerRunner createJobManagerRunner(
+                JobGraph jobGraph,
+                Configuration configuration,
+                RpcService rpcService,
+                HighAvailabilityServices highAvailabilityServices,
+                HeartbeatServices heartbeatServices,
+                JobManagerSharedServices jobManagerServices,
+                JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory,
+                FatalErrorHandler fatalErrorHandler,
+                long initializationTimestamp)
+                throws Exception {
+            final TestingJobManagerRunner runner =
+                    TestingJobManagerRunner.newBuilder()
+                            .setJobId(jobGraph.getJobID())
+                            .setResultFuture(resultFuture)
+                            .build();
+            runner.getTerminationFuture().thenRun(onClose::run);
+            return runner;
+        }
+    }
+
     private static class BlockingJobVertex extends JobVertex {
         private final OneShotLatch oneShotLatch = new OneShotLatch();
 
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java
new file mode 100644
index 00000000000..e59ed445053
--- /dev/null
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/JobMasterTester.java
@@ -0,0 +1,279 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.runtime.dispatcher;
+
+import org.apache.flink.api.common.JobID;
+import org.apache.flink.api.common.time.Time;
+import org.apache.flink.runtime.checkpoint.CheckpointMetrics;
+import org.apache.flink.runtime.checkpoint.CheckpointOptions;
+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;
+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;
+import org.apache.flink.runtime.clusterframework.types.AllocationID;
+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;
+import org.apache.flink.runtime.execution.ExecutionState;
+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;
+import org.apache.flink.runtime.executiongraph.TaskInformation;
+import org.apache.flink.runtime.jobgraph.OperatorID;
+import org.apache.flink.runtime.jobmaster.JobMasterGateway;
+import org.apache.flink.runtime.jobmaster.JobMasterId;
+import org.apache.flink.runtime.messages.Acknowledge;
+import org.apache.flink.runtime.rpc.TestingRpcService;
+import org.apache.flink.runtime.scheduler.ExecutionGraphInfo;
+import org.apache.flink.runtime.state.OperatorStreamStateHandle;
+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;
+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;
+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;
+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;
+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;
+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;
+import org.apache.flink.runtime.taskmanager.TaskExecutionState;
+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;
+import org.apache.flink.util.concurrent.FutureUtils;
+
+import org.apache.flink.shaded.guava30.com.google.common.collect.Iterables;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+/**
+ * A testing utility, that simulates the desired interactions with {@link JobMasterGateway} RPC.
+ * This is useful for light-weight e2e tests, eg. simulating specific fail-over scenario.
+ */
+public class JobMasterTester implements Closeable {
+
+    private static final Time TIMEOUT = Time.minutes(1);
+
+    private static TaskStateSnapshot createNonEmptyStateSnapshot(TaskInformation taskInformation) {
+        final TaskStateSnapshot checkpointStateHandles = new TaskStateSnapshot();
+        checkpointStateHandles.putSubtaskStateByOperatorID(
+                OperatorID.fromJobVertexID(taskInformation.getJobVertexId()),
+                OperatorSubtaskState.builder()
+                        .setManagedOperatorState(
+                                new OperatorStreamStateHandle(
+                                        Collections.emptyMap(),
+                                        new ByteStreamStateHandle("foobar", new byte[0])))
+                        .build());
+        return checkpointStateHandles;
+    }
+
+    private static class CheckpointCompletionHandler {
+
+        private final Map<ExecutionAttemptID, CompletableFuture<Void>> completedAttemptFutures;
+        private final CompletableFuture<Void> completedFuture;
+
+        public CheckpointCompletionHandler(List<TaskDeploymentDescriptor> descriptors) {
+            this.completedAttemptFutures =
+                    descriptors.stream()
+                            .map(TaskDeploymentDescriptor::getExecutionAttemptId)
+                            .collect(
+                                    Collectors.toMap(
+                                            Function.identity(),
+                                            ignored -> new CompletableFuture<>()));
+            this.completedFuture = FutureUtils.completeAll(completedAttemptFutures.values());
+        }
+
+        void completeAttempt(ExecutionAttemptID executionAttemptId) {
+            completedAttemptFutures.get(executionAttemptId).complete(null);
+        }
+
+        CompletableFuture<Void> getCompletedFuture() {
+            return completedFuture;
+        }
+    }
+
+    private final UnresolvedTaskManagerLocation taskManagerLocation =
+            new LocalUnresolvedTaskManagerLocation();
+    private final ConcurrentMap<ExecutionAttemptID, TaskDeploymentDescriptor> descriptors =
+            new ConcurrentHashMap<>();
+
+    private final TestingRpcService rpcService;
+    private final JobID jobId;
+    private final JobMasterGateway jobMasterGateway;
+    private final TaskExecutorGateway taskExecutorGateway;
+
+    private final CompletableFuture<ExecutionGraphInfo> executionGraphInfoFuture;
+
+    private final CompletableFuture<List<TaskDeploymentDescriptor>> descriptorsFuture =
+            new CompletableFuture<>();
+
+    private final ConcurrentMap<Long, CheckpointCompletionHandler> checkpoints =
+            new ConcurrentHashMap<>();
+
+    public JobMasterTester(
+            TestingRpcService rpcService, JobID jobId, JobMasterGateway jobMasterGateway) {
+        this.rpcService = rpcService;
+        this.jobId = jobId;
+        this.jobMasterGateway = jobMasterGateway;
+        this.taskExecutorGateway = createTaskExecutorGateway();
+        executionGraphInfoFuture = jobMasterGateway.requestJob(TIMEOUT);
+    }
+
+    public CompletableFuture<Acknowledge> transitionTo(
+            List<TaskDeploymentDescriptor> descriptors, ExecutionState state) {
+        final List<CompletableFuture<Acknowledge>> futures =
+                descriptors.stream()
+                        .map(TaskDeploymentDescriptor::getExecutionAttemptId)
+                        .map(
+                                attemptId ->
+                                        jobMasterGateway.updateTaskExecutionState(
+                                                new TaskExecutionState(attemptId, state)))
+                        .collect(Collectors.toList());
+        return FutureUtils.completeAll(futures).thenApply(ignored -> Acknowledge.get());
+    }
+
+    public CompletableFuture<List<TaskDeploymentDescriptor>> deployVertices(int numSlots) {
+        return jobMasterGateway
+                .registerTaskManager(
+                        taskExecutorGateway.getAddress(), taskManagerLocation, jobId, TIMEOUT)
+                .thenCompose(ignored -> offerSlots(numSlots))
+                .thenCompose(ignored -> descriptorsFuture);
+    }
+
+    public CompletableFuture<Void> getCheckpointFuture(long checkpointId) {
+        return descriptorsFuture.thenCompose(
+                descriptors ->
+                        checkpoints
+                                .computeIfAbsent(
+                                        checkpointId,
+                                        key -> new CheckpointCompletionHandler(descriptors))
+                                .getCompletedFuture());
+    }
+
+    @Override
+    public void close() throws IOException {
+        rpcService.unregisterGateway(taskExecutorGateway.getAddress());
+    }
+
+    private TaskExecutorGateway createTaskExecutorGateway() {
+        final TestingTaskExecutorGateway taskExecutorGateway =
+                new TestingTaskExecutorGatewayBuilder()
+                        .setSubmitTaskConsumer(this::onSubmitTaskConsumer)
+                        .setTriggerCheckpointFunction(this::onTriggerCheckpoint)
+                        .setConfirmCheckpointFunction(this::onConfirmCheckpoint)
+                        .createTestingTaskExecutorGateway();
+        rpcService.registerGateway(taskExecutorGateway.getAddress(), taskExecutorGateway);
+        return taskExecutorGateway;
+    }
+
+    private CompletableFuture<TaskInformation> getTaskInformation(
+            ExecutionAttemptID executionAttemptId) {
+        return descriptorsFuture.thenApply(
+                descriptors -> {
+                    final TaskDeploymentDescriptor descriptor =
+                            descriptors.stream()
+                                    .filter(
+                                            desc ->
+                                                    executionAttemptId.equals(
+                                                            desc.getExecutionAttemptId()))
+                                    .findAny()
+                                    .orElseThrow(
+                                            () ->
+                                                    new IllegalStateException(
+                                                            String.format(
+                                                                    "Task descriptor for %s not found.",
+                                                                    executionAttemptId)));
+                    try {
+                        return descriptor
+                                .getSerializedTaskInformation()
+                                .deserializeValue(Thread.currentThread().getContextClassLoader());
+                    } catch (Exception e) {
+                        throw new IllegalStateException(
+                                String.format(
+                                        "Unable to deserialize task information of %s.",
+                                        executionAttemptId));
+                    }
+                });
+    }
+
+    private CompletableFuture<Acknowledge> onTriggerCheckpoint(
+            ExecutionAttemptID executionAttemptId,
+            long checkpointId,
+            long checkpointTimestamp,
+            CheckpointOptions checkpointOptions) {
+        return getTaskInformation(executionAttemptId)
+                .thenCompose(
+                        taskInformation -> {
+                            jobMasterGateway.acknowledgeCheckpoint(
+                                    jobId,
+                                    executionAttemptId,
+                                    checkpointId,
+                                    new CheckpointMetrics(),
+                                    createNonEmptyStateSnapshot(taskInformation));
+                            return CompletableFuture.completedFuture(Acknowledge.get());
+                        });
+    }
+
+    private CompletableFuture<Acknowledge> onConfirmCheckpoint(
+            ExecutionAttemptID executionAttemptId, long checkpointId, long checkpointTimestamp) {
+        return getTaskInformation(executionAttemptId)
+                .thenCompose(
+                        taskInformation ->
+                                completeAttemptCheckpoint(checkpointId, executionAttemptId));
+    }
+
+    private CompletableFuture<Acknowledge> onSubmitTaskConsumer(
+            TaskDeploymentDescriptor taskDeploymentDescriptor, JobMasterId jobMasterId) {
+        return executionGraphInfoFuture.thenCompose(
+                executionGraphInfo -> {
+                    final int numVertices =
+                            Iterables.size(
+                                    executionGraphInfo
+                                            .getArchivedExecutionGraph()
+                                            .getAllExecutionVertices());
+                    descriptors.put(
+                            taskDeploymentDescriptor.getExecutionAttemptId(),
+                            taskDeploymentDescriptor);
+                    if (descriptors.size() == numVertices) {
+                        descriptorsFuture.complete(new ArrayList<>(descriptors.values()));
+                    }
+                    return CompletableFuture.completedFuture(Acknowledge.get());
+                });
+    }
+
+    private CompletableFuture<Acknowledge> completeAttemptCheckpoint(
+            long checkpointId, ExecutionAttemptID executionAttemptId) {
+        return descriptorsFuture
+                .thenAccept(
+                        descriptors ->
+                                checkpoints
+                                        .computeIfAbsent(
+                                                checkpointId,
+                                                key -> new CheckpointCompletionHandler(descriptors))
+                                        .completeAttempt(executionAttemptId))
+                .thenApply(ignored -> Acknowledge.get());
+    }
+
+    private CompletableFuture<Collection<SlotOffer>> offerSlots(int numSlots) {
+        final List<SlotOffer> offers = new ArrayList<>();
+        for (int idx = 0; idx < numSlots; idx++) {
+            offers.add(new SlotOffer(new AllocationID(), 0, ResourceProfile.ANY));
+        }
+        return jobMasterGateway.offerSlots(taskManagerLocation.getResourceID(), offers, TIMEOUT);
+    }
+}
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingJobManagerRunnerFactory.java b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingJobManagerRunnerFactory.java
index aea16518d6f..384444d0619 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingJobManagerRunnerFactory.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/TestingJobManagerRunnerFactory.java
@@ -77,7 +77,7 @@ public class TestingJobManagerRunnerFactory implements JobManagerRunnerFactory {
     @Nonnull
     private TestingJobManagerRunner createTestingJobManagerRunner(JobGraph jobGraph) {
         final boolean blockingTermination = numBlockingJobManagerRunners.getAndDecrement() > 0;
-        return new TestingJobManagerRunner.Builder()
+        return TestingJobManagerRunner.newBuilder()
                 .setJobId(jobGraph.getJobID())
                 .setBlockingTermination(blockingTermination)
                 .build();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestUtils.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestUtils.java
index 80772fd2558..ebd0ae3d20d 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestUtils.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestUtils.java
@@ -93,7 +93,7 @@ public class TestUtils {
             SavepointRestoreSettings savepointRestoreSettings, JobVertex... jobVertices) {
 
         // enable checkpointing which is required to resume from a savepoint
-        final CheckpointCoordinatorConfiguration checkpoinCoordinatorConfiguration =
+        final CheckpointCoordinatorConfiguration checkpointCoordinatorConfiguration =
                 CheckpointCoordinatorConfiguration.builder()
                         .setCheckpointInterval(1000L)
                         .setCheckpointTimeout(1000L)
@@ -107,7 +107,7 @@ public class TestUtils {
                         .setTolerableCheckpointFailureNumber(0)
                         .build();
         final JobCheckpointingSettings checkpointingSettings =
-                new JobCheckpointingSettings(checkpoinCoordinatorConfiguration, null);
+                new JobCheckpointingSettings(checkpointCoordinatorConfiguration, null);
 
         return JobGraphBuilder.newStreamingJobGraphBuilder()
                 .addJobVertices(Arrays.asList(jobVertices))
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java
index 863b6b5c832..e6d613ccf7b 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/TestingJobManagerRunner.java
@@ -33,6 +33,10 @@ import java.util.concurrent.CompletableFuture;
 /** Testing implementation of the {@link JobManagerRunner}. */
 public class TestingJobManagerRunner implements JobManagerRunner {
 
+    public static Builder newBuilder() {
+        return new Builder();
+    }
+
     private final JobID jobId;
 
     private final boolean blockingTermination;
@@ -156,12 +160,17 @@ public class TestingJobManagerRunner implements JobManagerRunner {
 
     /** {@code Builder} for instantiating {@link TestingJobManagerRunner} instances. */
     public static class Builder {
+
         private JobID jobId = null;
         private boolean blockingTermination = false;
         private CompletableFuture<JobMasterGateway> jobMasterGatewayFuture =
                 new CompletableFuture<>();
         private CompletableFuture<JobManagerRunnerResult> resultFuture = new CompletableFuture<>();
 
+        private Builder() {
+            // No-op.
+        }
+
         public Builder setJobId(JobID jobId) {
             this.jobId = jobId;
             return this;
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorSchedulerTest.java
index 6e3d12e794d..88cd7e60386 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/operators/coordination/OperatorCoordinatorSchedulerTest.java
@@ -119,7 +119,7 @@ public class OperatorCoordinatorSchedulerTest extends TestLogger {
     @After
     public void shutdownScheduler() throws Exception {
         if (createdScheduler != null) {
-            createdScheduler.close();
+            closeScheduler(createdScheduler);
         }
     }
 
@@ -140,7 +140,7 @@ public class OperatorCoordinatorSchedulerTest extends TestLogger {
         final DefaultScheduler scheduler = createAndStartScheduler();
         final TestingOperatorCoordinator coordinator = getCoordinator(scheduler);
 
-        scheduler.close();
+        closeScheduler(scheduler);
 
         assertTrue(coordinator.isClosed());
     }
@@ -868,6 +868,12 @@ public class OperatorCoordinatorSchedulerTest extends TestLogger {
         return checkpointId;
     }
 
+    private void closeScheduler(DefaultScheduler scheduler) throws Exception {
+        final CompletableFuture<Void> closeFuture = scheduler.closeAsync();
+        executor.triggerAll();
+        closeFuture.get();
+    }
+
     // ------------------------------------------------------------------------
     //  miscellaneous utilities
     // ------------------------------------------------------------------------
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/TestingRpcService.java b/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/TestingRpcService.java
index 401b829f88f..b9bf3754881 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/TestingRpcService.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/rpc/TestingRpcService.java
@@ -108,6 +108,13 @@ public class TestingRpcService implements RpcService {
         }
     }
 
+    public void unregisterGateway(String address) {
+        checkNotNull(address);
+        if (registeredConnections.remove(address) == null) {
+            throw new IllegalStateException("no gateway is registered under " + address);
+        }
+    }
+
     @SuppressWarnings("unchecked")
     private <C extends RpcGateway> CompletableFuture<C> getRpcGatewayFuture(C gateway) {
         return (CompletableFuture<C>) rpcGatewayFutureFunction.apply(gateway);
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
index c062cd423e8..6ac532636c4 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultSchedulerTest.java
@@ -129,7 +129,7 @@ public class DefaultSchedulerTest extends TestLogger {
 
     @ClassRule public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();
 
-    private ManuallyTriggeredScheduledExecutor taskRestartExecutor =
+    private final ManuallyTriggeredScheduledExecutor taskRestartExecutor =
             new ManuallyTriggeredScheduledExecutor();
 
     private ExecutorService executor;
@@ -1071,7 +1071,6 @@ public class DefaultSchedulerTest extends TestLogger {
         scheduler.updateTaskExecutionState(
                 new TaskExecutionState(attemptId, ExecutionState.CANCELED, expectedException));
         taskRestartExecutor.triggerScheduledTasks();
-        final long end = System.currentTimeMillis();
 
         final Iterable<RootExceptionHistoryEntry> actualExceptionHistory =
                 scheduler.getExceptionHistory();
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGateway.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGateway.java
index 28834456429..84b803822d4 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGateway.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGateway.java
@@ -46,6 +46,7 @@ import org.apache.flink.types.SerializableOptional;
 import org.apache.flink.util.Preconditions;
 import org.apache.flink.util.SerializedValue;
 import org.apache.flink.util.concurrent.FutureUtils;
+import org.apache.flink.util.function.QuadFunction;
 import org.apache.flink.util.function.TriConsumer;
 import org.apache.flink.util.function.TriFunction;
 
@@ -108,6 +109,17 @@ public class TestingTaskExecutorGateway implements TaskExecutorGateway {
     private final Supplier<CompletableFuture<TaskThreadInfoResponse>>
             requestThreadInfoSamplesSupplier;
 
+    private final QuadFunction<
+                    ExecutionAttemptID,
+                    Long,
+                    Long,
+                    CheckpointOptions,
+                    CompletableFuture<Acknowledge>>
+            triggerCheckpointFunction;
+
+    private final TriFunction<ExecutionAttemptID, Long, Long, CompletableFuture<Acknowledge>>
+            confirmCheckpointFunction;
+
     TestingTaskExecutorGateway(
             String address,
             String hostname,
@@ -142,7 +154,16 @@ public class TestingTaskExecutorGateway implements TaskExecutorGateway {
                             CompletableFuture<Acknowledge>>
                     operatorEventHandler,
             Supplier<CompletableFuture<ThreadDumpInfo>> requestThreadDumpSupplier,
-            Supplier<CompletableFuture<TaskThreadInfoResponse>> requestThreadInfoSamplesSupplier) {
+            Supplier<CompletableFuture<TaskThreadInfoResponse>> requestThreadInfoSamplesSupplier,
+            QuadFunction<
+                            ExecutionAttemptID,
+                            Long,
+                            Long,
+                            CheckpointOptions,
+                            CompletableFuture<Acknowledge>>
+                    triggerCheckpointFunction,
+            TriFunction<ExecutionAttemptID, Long, Long, CompletableFuture<Acknowledge>>
+                    confirmCheckpointFunction) {
 
         this.address = Preconditions.checkNotNull(address);
         this.hostname = Preconditions.checkNotNull(hostname);
@@ -162,6 +183,8 @@ public class TestingTaskExecutorGateway implements TaskExecutorGateway {
         this.operatorEventHandler = operatorEventHandler;
         this.requestThreadDumpSupplier = requestThreadDumpSupplier;
         this.requestThreadInfoSamplesSupplier = requestThreadInfoSamplesSupplier;
+        this.triggerCheckpointFunction = triggerCheckpointFunction;
+        this.confirmCheckpointFunction = confirmCheckpointFunction;
     }
 
     @Override
@@ -218,13 +241,15 @@ public class TestingTaskExecutorGateway implements TaskExecutorGateway {
             long checkpointID,
             long checkpointTimestamp,
             CheckpointOptions checkpointOptions) {
-        return CompletableFuture.completedFuture(Acknowledge.get());
+        return triggerCheckpointFunction.apply(
+                executionAttemptID, checkpointID, checkpointTimestamp, checkpointOptions);
     }
 
     @Override
     public CompletableFuture<Acknowledge> confirmCheckpoint(
             ExecutionAttemptID executionAttemptID, long checkpointId, long checkpointTimestamp) {
-        return CompletableFuture.completedFuture(Acknowledge.get());
+        return confirmCheckpointFunction.apply(
+                executionAttemptID, checkpointId, checkpointTimestamp);
     }
 
     @Override
diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGatewayBuilder.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGatewayBuilder.java
index 2c0979b14a7..f2bc48d30a7 100644
--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGatewayBuilder.java
+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TestingTaskExecutorGatewayBuilder.java
@@ -20,6 +20,7 @@ package org.apache.flink.runtime.taskexecutor;
 
 import org.apache.flink.api.common.JobID;
 import org.apache.flink.api.java.tuple.Tuple6;
+import org.apache.flink.runtime.checkpoint.CheckpointOptions;
 import org.apache.flink.runtime.clusterframework.types.AllocationID;
 import org.apache.flink.runtime.clusterframework.types.ResourceID;
 import org.apache.flink.runtime.clusterframework.types.ResourceProfile;
@@ -38,6 +39,7 @@ import org.apache.flink.runtime.resourcemanager.ResourceManagerId;
 import org.apache.flink.runtime.rest.messages.taskmanager.ThreadDumpInfo;
 import org.apache.flink.util.SerializedValue;
 import org.apache.flink.util.concurrent.FutureUtils;
+import org.apache.flink.util.function.QuadFunction;
 import org.apache.flink.util.function.TriConsumer;
 import org.apache.flink.util.function.TriFunction;
 
@@ -89,10 +91,22 @@ public class TestingTaskExecutorGatewayBuilder {
                     (a, b, c) -> CompletableFuture.completedFuture(Acknowledge.get());
     private static final Supplier<CompletableFuture<ThreadDumpInfo>> DEFAULT_THREAD_DUMP_SUPPLIER =
             () -> FutureUtils.completedExceptionally(new UnsupportedOperationException());
-
     private static final Supplier<CompletableFuture<TaskThreadInfoResponse>>
             DEFAULT_THREAD_INFO_SAMPLES_SUPPLIER =
                     () -> FutureUtils.completedExceptionally(new UnsupportedOperationException());
+    private static final QuadFunction<
+                    ExecutionAttemptID,
+                    Long,
+                    Long,
+                    CheckpointOptions,
+                    CompletableFuture<Acknowledge>>
+            NOOP_TRIGGER_CHECKPOINT_FUNCTION =
+                    ((executionAttemptId, checkpointId, checkpointTimestamp, checkpointOptions) ->
+                            CompletableFuture.completedFuture(Acknowledge.get()));
+    private static final TriFunction<ExecutionAttemptID, Long, Long, CompletableFuture<Acknowledge>>
+            NOOP_CONFIRM_CHECKPOINT_FUNCTION =
+                    ((executionAttemptId, checkpointId, checkpointTimestamp) ->
+                            CompletableFuture.completedFuture(Acknowledge.get()));
 
     private String address = "foobar:1234";
     private String hostname = "foobar";
@@ -133,6 +147,17 @@ public class TestingTaskExecutorGatewayBuilder {
     private Supplier<CompletableFuture<TaskThreadInfoResponse>> requestThreadInfoSamplesSupplier =
             DEFAULT_THREAD_INFO_SAMPLES_SUPPLIER;
 
+    private QuadFunction<
+                    ExecutionAttemptID,
+                    Long,
+                    Long,
+                    CheckpointOptions,
+                    CompletableFuture<Acknowledge>>
+            triggerCheckpointFunction = NOOP_TRIGGER_CHECKPOINT_FUNCTION;
+
+    private TriFunction<ExecutionAttemptID, Long, Long, CompletableFuture<Acknowledge>>
+            confirmCheckpointFunction = NOOP_CONFIRM_CHECKPOINT_FUNCTION;
+
     public TestingTaskExecutorGatewayBuilder setAddress(String address) {
         this.address = address;
         return this;
@@ -249,6 +274,25 @@ public class TestingTaskExecutorGatewayBuilder {
         return this;
     }
 
+    public TestingTaskExecutorGatewayBuilder setTriggerCheckpointFunction(
+            QuadFunction<
+                            ExecutionAttemptID,
+                            Long,
+                            Long,
+                            CheckpointOptions,
+                            CompletableFuture<Acknowledge>>
+                    triggerCheckpointFunction) {
+        this.triggerCheckpointFunction = triggerCheckpointFunction;
+        return this;
+    }
+
+    public TestingTaskExecutorGatewayBuilder setConfirmCheckpointFunction(
+            TriFunction<ExecutionAttemptID, Long, Long, CompletableFuture<Acknowledge>>
+                    confirmCheckpointFunction) {
+        this.confirmCheckpointFunction = confirmCheckpointFunction;
+        return this;
+    }
+
     public TestingTaskExecutorGateway createTestingTaskExecutorGateway() {
         return new TestingTaskExecutorGateway(
                 address,
@@ -267,6 +311,8 @@ public class TestingTaskExecutorGatewayBuilder {
                 releaseClusterPartitionsConsumer,
                 operatorEventHandler,
                 requestThreadDumpSupplier,
-                requestThreadInfoSamplesSupplier);
+                requestThreadInfoSamplesSupplier,
+                triggerCheckpointFunction,
+                confirmCheckpointFunction);
     }
 }
